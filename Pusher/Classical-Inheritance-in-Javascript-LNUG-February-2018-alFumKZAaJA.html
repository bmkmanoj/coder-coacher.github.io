<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Classical Inheritance in Javascript - LNUG - February 2018 | Coder Coacher - Coaching Coders</title><meta content="Classical Inheritance in Javascript - LNUG - February 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Classical Inheritance in Javascript - LNUG - February 2018</b></h2><h5 class="post__date">2018-03-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/alFumKZAaJA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so a few things about me I've just
recently moved to London from Greece and
for the past five years I've been doing
node.js professionally remote jobs with
for startups in the USA I'm doing a lot
of open source work got over 40 MPA and
packages published lots of contributions
to major packages used by the north
community and I'm also very active I've
had been very active back in my hometown
I was running the local no just meet up
there I found it a squeegee tech IR
which is like an umbrella of all the
local communities and ignited the local
skin scene there and that resulted in us
in the whole community organizing the
David conference which is a world-class
conference happening every year in June
in sunny Greece so if you want to get
some Sun it's a great opportunity it's
going to cost you less than a ticket in
any high-end conference including
airplane tickets and hotel so let's
decide it today what I'm going to talk
about inheritance with JavaScript and
lots of ways to do inheritance it's a
very battled issue in JavaScript it is
it can be complicated and today we will
talk about the classical prototypical
inheritance you may hear it as
pseudo-classical as well and what we are
going to talk about specifically is how
inheritance works and this is going to
be the focus of this talk versus
comparing different ways to do
inheritance having said that I am going
to give a brief explanation of why I'm
talking about classical inheritance and
one of the main reasons is that
classical inheritance was a type of
inheritance intended by the JavaScript
to create
to be used for inheritance so there are
specific keywords in the language that
are being fully used and utilized by
doing prototypical Curtin's like the new
keyword or the instance of keyword the
class the new class keyword introduced
in the script 2015 afterwards basically
does classical inheritance behind the
scenes it's basically sugar for
classical inheritance as all of you know
and before we had the class keyword the
nodejs
libraries provided a built-in method to
help us perform inheritance so the core
library util has the method inherits
which allows us to do prototypical
inheritance in JavaScript there are many
alternatives to classical inheritance
just doing classical inheritance can be
done in again so many ways you can have
composition which is a different thing
entirely you can use object literals to
do what you need to do again this talk
isn't about comparing this is about
diving deep into how inheritance works
in JavaScript so again like I said it is
the languages intended way for
inheritance it's generally accepted as a
way to do inheritance my last point is
that in the JavaScript community
everybody knows we all know that there's
a high very high signal-to-noise ratio
and that can be a problem what I advise
is to stay confident and focused on what
you do and keep an open mind towards
everything I'll abide an open critical
mind okay
many people like Adam said are
rediscovering things every day
and we don't need to go back so let's
have a quick look on how it prototypical
inheritance happens this is for es6 and
beyond years 2015 you basically have the
class keyword and you you have the
statement we're inside the class
statement you can declare a constructor
that is again a keyword which basically
is the function that's going to get
executed each time we instantiate a new
instance of that class inheritance
happens with the extents keyword as you
can see under the definition of animal
we simply extend and that's it pretty
simple straightforward why should we
bother more with that because before we
had that we had to do it more manually
we had to declare our class as a
function which basically that was a
convention that we did and said all
right our animal is now a class and we
indicate that by capitalizing the first
letter and every class basically is a
function and that function is the
constructor and there along along all
the presentation flies you see that
notations seem tall that is the
constructor and that is the best way to
refer to classes in JavaScript so from
here on out I'm going to call them as
constructors rather than classes because
that's what they are and if I want to
have it if cut wants to hate from animal
what I have to do is again declare the
constructor and on the very first line I
need to call the parent constructor by
using the call method which is a
built-in method in the function it is a
predefined method that all functions
have we are going to explain this
further down what this does right there
and after our constructor declaration is
finished we do the util dot inherits we
invoke that we did inherits method to to
perform the inheritance that is how we
did prototypical inheritance in ACMA
script 5 which basically is any node
version before 8 now what inherits does
I'm breaking out this function it's
basically two lines of code we have the
child constructor and have the parent
constructor from which we are going to
inherit and what we basically need to do
is to copy the prototype of the parent
to the child and the way this happens
with es5 is by using them object create
method a very handy method it's going to
create a new object based on a source
object that we provided and and then
what we need to do is point the
constructor to the parent so that we
establish the chain of inheritance now
what happens before he is 5 we had ps3
and object dot create doesn't exist in
history and basically this is the lowest
common denominator for inheritance in
JavaScript this is how we did JavaScript
this is how we did inheritance in
JavaScript in 2010/11 before we got
object create and all of those goodies a
lot of crazy things going on here we are
going to analyze them later on don't get
afraid so exactly prototype JavaScript
is a prototypical language so it has
these foundations is upon a prototype a
prototypes job is to to help create new
is
it's basically a blueprint okay
everything in JavaScript is an object so
a string is in your string boolean a
number and the only things I don't have
the prototype are instances or objects
which are considered the result of the
blueprint right so we have the blueprint
and using that we create instances and
objects so those don't have a product
functions have a prototype and it points
to the originating construct or method
which is a built in vicinity of
JavaScript
now again prototype is the blueprint for
creating objects and instances in that
example the pony is the instance and by
using the new keyword we instruct Java
Script to execute the animal constructor
and this is the constructor definition
all right it's very simple you just
define a function that's all it is and
this right there is a local variable to
our constructor with the keyword this
this as a keyword is one of the most
dreaded keywords when learning
JavaScript and end the scope altogether
I am going to try to explain it to you
today I hope I make a good job of it you
let me know so after we have defined our
constructor we can define methods on our
constructor only by using the prototype
definition that is when we create
methods that are going to be available
in the instances that we create so the
very last line that you see Pony get
name that wouldn't be available if we
define the get name on the animal
function directly and we'll see soon
enough an example on how that is going
to behave the prototype itself is an
object alright so when we print it and
see what it contains we can see that it
has basically two properties it has a
constructor which is basically the
function that gets invoked to build our
object we've already seen a constructor
and it has a proto reference which is a
reference to the parent constructor so
there is a chain of inheritance always
going on and we're going to see more
about that later a little bit every
variable in JavaScript has a proto
property and it's job is to point to the
originating to the parent prototype to
the prototype that was used to create
the instance that property that viable
that everything every variable has a
proto again proto is a reference okay
points to the object that constructed
the instance and for when we are using
the new keyword to instantiate a
constructor naturally the proto of that
instance points back to the constructor
that's how this works now we should we
this is the example from ACMA script
three inheritance and everybody went
bonkers when when it's they saw it now
let's let's go through it line by line
and understand what's going on here so
at the very first line we create a
temporary constructor we create a
temporary constructor so we can copy the
parent prototype onto that
and I'll explain a little bit later why
we could we need a temporary construct
we then assign by reference the the
prototype the prototype of the
constructor that we want to inherit from
we assign it to the temporary
constructor and we do that so we can
then invoke the temporary constructor
with a new keyword and get a fresh copy
of the prototype properties the
prototype properties are properties that
we call values or methods and last but
not least on the newly constructed child
constructor which is the class inherits
we assign the constructor itself
remember the child constructor right
here is nothing but a function so what
we are saying is basically we are
starting to create block by block how a
constructor DS and a constructor what
does it have it has methods and
properties on its prototype and it has
the constructor all right that is what
we are doing right there and yeah again
this is what I've explained for for the
proto the prod is going to reference the
temp and that's about it now let's see
why we did that it's essential that that
we discard the default child paradigm
and so we essentially discarded the
default charge prototype and we overrode
it with the instance of the parent
constructor there is why did we do that
right
important question here now if we
directly assigned the parent constructor
prototype to the child constructor
prototype we would be assigning by
reference and that would mean that the
child and the parents prototypes would
be exactly the same if I added a new
method on the on the child that will
automatically put the method on the
parent as well so we would have
side-effects between them so that is why
we need to have a temporary constructor
to initialize to do the to do that new
temp constructor and the reason we need
that the new is because in es3 we lock
the object create method the reason why
we wouldn't do this directly we and we
did we instantiate the temporary
constructor with a new keyword instead
of instantiating the parent constructor
is if we did that within the context of
inheritance we would unintentionally
invoke the parent constructor and that
can have dire consequences and that is
why we need a temporary constructor to
perform the copy of the prototype which
is an object yeah there's a lot of a lot
more so again we copied the parent
prototype to the child and now we need
to make sure that all the constructors
from our parents will be invoked in the
right code and this is where things get
a little crazy
let's talk about the scope now this is
again an example of inheritance in ACMA
script 5 I'm using across week 5 to
better illustrate what's going on and as
you can see in that example we have a
line that is performing a call right
there and what the call method does
first off who is familiar with the dot
colon dot apply methods of functions
right good
so what called does is basically says
invoke the animal function remember
animal is a constructor what is a
constructor a function invoke the animal
function but by using this context and
the context is provided as the first
argument of the call method in this case
the context is this when we are
instantiating a constructor using the
new keyword using the new keyword we
create a new scope and that constructor
is executed within that new scope in
that new scope is referenced by the
keyword this within the constructor
okay I've lost most of you so what we
want to do is on the child constructor
we want to invoke the parent constructor
so that we are sure that all of the
inheritance chain power constructors and
evokes but we invoke it with the scope
of the new instance and as we need the
call method and that is what ensures
that every constructor in the
inheritance chain is going to be invoked
with the same scope or context you may
have heard it as well and that is what
will enable us to do proper handling of
prototypical inheritance again scope so
scope refers to where variables and
functions are accessible and in what
context it is being executed
all right in the case of an instance
scope is critical in maintaining access
to methods and local properties so when
we are defining a property this age
equals 20 in order to access that
property we need to access it within the
same scope let's see some examples of
that again this name equals name so our
constructor has an argument when we are
doing a new animal we give it as an
argument a name so that animal has a
name and then we can get the name by
invoking the method get name which
basically returns this name now let's
see how scope behaves our animal equals
new animal cut so now the name of our
instance is cut we say animal don't get
name we get cut in return everything
works if we assign the method into a new
variable and we lose the context that is
the animal and then invoke that variable
the context is lost
and we're getting undefined what we need
to do is use the key word bind and what
bind does is that in a capsule AIT's our
function within the context that we have
provided it and returns the encapsulated
function and executed so we can execute
it on the next line and get the proper
response because the context and the
scope are correct now the first example
again we are playing with the call and
the apply methods so what does call do
it invokes the method get name get name
now doesn't have a scope because we
abolished it but we say that I need you
to get invoked with the context of the
animal and then it returns cut we could
further hack that and create another
instance with a named dog and if we mix
the two together we would get mixed
responses so we would invoke the get
name of the cut animal and get dog as a
response but that's more complicated and
unneeded call an apply have the same
effect it's their only difference is in
the arguments with call you can assign
any arguments serially in the function
apply expect the argument expressed as
an array on the second argument of the
apply method so let's see some more
practical examples on scope so a very
classical example that everybody learns
the hard way is that you can't you can't
define the method without binding it to
the scope otherwise it loses its scope
it's the same effect as assigning the
variable back
and one way to skip that effect with
modern JavaScript is to use the arrow
function notation you can scroll through
the presentation afterwards it's already
uploaded on speaker tech and again
repeating what is going on here oh I
think we've gone through it enough times
so that you're already familiar with it
this is the same steps of what is going
on in the from node 8 and afterwards
things are looking better in node 8 this
is how the prototype chain works all
right and the reason I want to show you
this is because I need you to be wary
that if you are creating long
inheritance chains that can be a
performance issue in JavaScript although
I've never faced that problem and we're
professionally I didn't have to go past
three levels of inheritance in any of my
projects some common God says never
define property values on the prototype
always define them within the
constructor that is the purpose of the
constructor to construct the object and
assign the properties of course these
are these are errors that you are going
to to learn anyway if you perform the
utility here it's at the end of the
definition it's going to overwrite all
of your methods and properties so do it
right after it scope and callbacks right
so again this is where the scope becomes
important when you have anonymous
callbacks sorry when you're essentially
creating closures you don't have the
right context within the closure be wary
of that that is very important we call
constructors constructors and not
classes because they don't behave like
classes
they resemble a glass and that does
that's why we call it classical
inheritance it's not exactly but in
reality it's really prototypical
inheritance we signify infrastructure by
capitalizing the first letter use the
constructor only to construct the
instance do not do all a synchronous
functions inside the Constructors it's
not allowed never return a value in a
constructor
you're breaking the whole inheritance
use now as a best practice that is don't
I mean even if you don't have a value
don't define a new property within a
method down the road
put it on your constructor have it value
null and if yeah that was if you define
a function on the constructor a non not
on the prototype of the constructor
you're essentially creating what we call
a static function that you can invoke
directly by doing animal dot static
effect FN but that static method will
not be inherited</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>