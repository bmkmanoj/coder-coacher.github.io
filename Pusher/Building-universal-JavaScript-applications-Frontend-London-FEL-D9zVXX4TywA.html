<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building universal JavaScript applications - Front-end London (FEL) | Coder Coacher - Coaching Coders</title><meta content="Building universal JavaScript applications - Front-end London (FEL) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building universal JavaScript applications - Front-end London (FEL)</b></h2><h5 class="post__date">2016-06-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/D9zVXX4TywA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everyone thankfully into R&amp;amp;D and for
having me for the third time here I
think and an epic fellows well so don't
know why still putting up with me but he
keeps letting me come along and I keep
talking about JavaScript hopefully
without boring people too much so yeah
my name is Jack oh that's me on Twitter
I work for a company called pusher I'm
entrust whose heads are pusher that's
pretty good as my job done for evening
those haven't we're like a hosted
real-time platform coming chat to me
about pusher I'm not here to talk about
them what I talk about is actually my
own company as one of my colleagues whom
is sat in the audience so I just work
for a company called Go Carles who's
heard of goecart this it's not gonna be
every slide okay more people have more
people have heard of go Carlist so I've
made a dreadful career move but anyway
so this whole story started the reason
this this talk came about was we had to
rebuild this website so go cars is a
payments provider and at the time we
were based purely in the UK and we only
served UK businesses that was fine so
the go card is kind of what I would call
these the splash pages the static site
was a jackal build and it was all in
English because we only served the UK
and that was easy we just generate some
HTML and threw it onto the internet but
then we we launched in France and we
needed a French version so we needed
actual you know French pages so we did
what every good developer does and
copied the folder
made another one called France and got
the people who speak French in the
office which is not me to to make the
French version and that kind of worked
just about you know jus plication is
okay once and all the rest of it and
then we need to launch in a current a
Germany wherever it was another language
basically and we can quite bring
ourselves to to do it three times
although it was quite tempting and we
started think about what else we might
instead do and we needed to build a
framework to kind of let us manage all
these multiple languages on the site
additionally this site you know this is
their whole go color site so there's all
about our product but there's also
things like the jobs pages about us so
we needed not just engineer's to be able
to edit this stuff ideally this should
be as well across the whole company and
at the time there was this little
library called react flowing around and
we kind of use this as a mint of excuse
to see if we could build a react
application that would that would run
all us all our all the splash pages for
go cardless as we'd let use we'd have a
French version and so on and so forth we
build it as a kind of
javascript framework if you like but of
course we didn't want go cardless to be
a massive javascript application that
wasn't accessible there was no need for
it to be a JavaScript application though
these days everyone is doing that and we
started look at how we could write react
on the server as well react does come
out the box we have server-side support
that means you can run reactant and say
a node environment and just get it to
spit out strings of HTML for you and
that's really where where we started
from the website launched I can remember
how long ago it launched it was quite a
while ago it's been out a while I've see
I've not been there for a while but I'm
led to believe it's still doing a good
job and still plugging along and it's a
really nice experience because if you
visit it without JavaScript you get the
website because it comes from the server
if you happen to have JavaScript loaded
for whatever reason then you get the
full just experience it's all loaded in
the page so every click is incredibly
snappy because you're just you're just
swapping out bits of content basically
using react if you load it and then you
lose connection or your JavaScript
doesn't load you click a button it just
goes it goes back to serve again so it's
a really nice experience for for all the
really and why we kind of we really
bought into it and why I bought into it
so I'll link to all these at the end but
I wrote a blog post for twenty four ways
last Christmas on Universal react and
then from this the blog post kind of
sorry from that blog post that the
talking about there's a few kind of
reasons that we you know building Java
applications that are a hundred central
line on JavaScript is a bad idea I just
work at GDS as well along with long
Sharron and we did this study or I say
we someone in the company but if I say
we it sounds like I was involved did
this study and on the gov UK website one
in one in ninety three or one point one
percent of people weren't getting
JavaScript so when they visited gov UK
for whatever reason we didn't have any
JavaScript running what's more
interesting than that stat is that of
those 1.1 percent only nought point two
were the people who had explicitly gone
into their browser and configured
JavaScript to be turned off the rest
hadn't got JavaScript for any number of
reasons their connectivity was bad
whatever they were in a train they went
in a tunnel they were on a national rail
train whatever it might be and and this
was really interesting to me because I
did used to have this kind of gung-ho
attitude of well you know if people have
turned off JavaScript and they don't
deserve anything and I still kind of
think
might be a little bit true but you know
most people who are visiting without
javascript didn't actually have it in
the first place and not out of choice
because of their their certain situation
and this blog posting includes that
quote just only a small slice of people
who don't run JavaScript are the ones
who have chosen not to and this kind of
comes down to the whole progressive
enhancement and does it just mean if
javascript is turned off or not Jake
Archibald in this blog post about
progressive enhancement says it's still
it's never been about people who have
turned JavaScript off these greens by
the way all links and I'll put the
slides up afterwards and a guy called
Stuart language is this really cool
flowchart which again is linked at the
bottom which goes through the the steps
taken from a user hitting like go Carlos
comm and it downloading all the files
and all the points that for what some
reason the requests can fail and
therefore JavaScript won't make it to
the end user on a train there was
incident where sky they decided that
jquery's from I think the Google CDN was
a virus and blocked jQuery again might
be the best decision they've ever made
but you know suddenly loads these
websites broke completely because sky
made a mistake and we've had like
browser add-ons can mess with JavaScript
there are so many different
circumstances in which your JavaScript
can partially xq not ask you at all be a
bit or whatever so it's really important
that we we deal with that and bear that
in mind a really recent talk from Google
IO which I've stupidly not put the link
to so you have to copy it from the
screenshot yeah that was a bit silly of
me this is addy osmani talking about
progressive web apps across all
frameworks this was literally last week
I just want to put this in there and I
mention this again in a minute whilst
I'm gonna talk within the context of a
react application because that's what I
know and have worked on this this this
kind of general thinking is is spreading
across all frameworks as well so even if
you personally are not using react if
using something else I hope that the
talk can still be relevant team and
another thing just to be clear I'm
definitely not here to advocate building
all websites and applications as we're
at applications that are run on the
server and the client as well there's
very you have to think about if this is
the right fit for you you know go
cardless could easily be a server-side
application only and that'd be fine
we found that with a little bit of
JavaScript we could really improve the
experience but this isn't a talk where
I'm going to have
react for absolutely everything and also
caveats were kind of just we're just
starting to really get deep into the
nitty-gritty of server-side rendering
and frameworks and how this this plays
nicely so there are a bit of rough edges
I'm gonna throw some code at you I'll
see all the sides will be online there
is also github repo that has an actual
working example some of the api's are
stuff for a little bit rough like these
will probably be chained these will
probably change over time and be
outdated in six months or a year or a
day so so just bear with me like some of
the stuff is a bit rough around the
edges but we are kind of really at the
boundaries of this stuff as I said react
to paved the way but we have Ember have
a thing called fastboot which is the
same idea you can run your ember app in
a node node kind of environment and
angular 2 has angular Universal which is
a similar idea to that you can run these
apps away from the browser and the whole
idea here with all of these framers is
that we can get this not for free but
with very little effort so that the goal
here is that you can write your react or
ember or angular or whatever app and
just put a small amount extra effort in
to get that service side rendering for
you and just to give you a link again
I'll tweet the slides and hashtag it and
put it in the slack group and all the
rest of it but there is a repo on github
there is a branch called fel because
I've done this talk about four times
that has the latest version of all the
demos and stuff on them so if we take a
look at a kind of standard reactor
application in-depth knowledge of react
definitely not required for the talk but
we have a component called my app and it
has a render method in that render
method I declare what this component
should look like when it's put into the
browser then we call react Dom dot
render we give it the component to
render this this my app tag here and
then we just tell it where to put it
onto the page so this in this case it's
going to render that my app component
and put it into the div on the page with
an ID of app and that's the the browser
side and if I want to swap this to a
server-side render that I just swap out
the react Dom bit to render to string
and that instead of trying to render it
into a Dom into a browser will just give
me a literal string of HTML and that's
it talks over but it's really cool that
react gives you all that out of the box
and it is that that simple and the key
thing to note here is that the my app
bit never changes and that's the thing I
want you to keep
heads as we go through and if you start
building apps in this way as little of
your as excuse me as little as your
application as possible should know
whether it's on the server or the client
or whatnot ideally we keep it entirely
agnostic and only at the very boundaries
do we change where we're going to render
it to of course it's a little bit more
involved in that so we can set up like a
little Express node server which just
kind of imports this this app component
we pull in the render to string methods
and then on any request we just generate
our own markup and we render this just
renders a template and just runs the
HTML the kind of details of that aren't
too important and that's it that will
spin up a server that does indeed work
and in some examples you'll see this
method render to string used
there's also another method called
render to static markup that react
provides for us there's a subtle
difference between the two you should
use render to string when you're
expecting the the HTML that is rendered
to be picked up by react application on
the client rendered source string will
include some kind of extra attributes in
the HTML that will allow the client-side
JavaScript to pick it up and work with
it if you know that's not going to be
the case you're purely working on the
server-side you're not going to run
client-side JavaScript for whatever
reason you can just call renders a
static markup and that will give you a
kind of lien markup if you like that
doesn't have any of the specific react
attributes and if I take this server and
I run it I just get back this I think
actually this with the latest version of
react some of these nitty-gritty details
have changed but the idea is are saying
this is generated purely from from react
so that's a bit very basic server-side
example but one of the benefits we found
at go cardless was that we could then
take all this code and push it onto the
client as well and those people who did
have JavaScript will get a just a little
bit more of a snappy experience then if
we start looking at how we can take this
client-side we're gonna have a shared
set of components that are environment
agnostic this is all our react
components will have a server rendering
step just that that little JavaScript
file we we saw that run on our server
will have a similar file that runs on
the client which we'll look at in a
minute
and we need some form of bundler like a
web pack or a browserify type thing that
can take all our JavaScript and create a
browsers version of it as well but the
real key detail here is the agnostic
components your
Component shouldn't know whether they're
on the server or the client you of
course can check in either the typical
check is to check if a type of window is
undefined to know if you're on the
server or the client but you should try
to do that as little as possible and try
and keep all your components plain and
without knowledge and we are going to
use webpack some people love it some
people hate it but in this the example I
have will use webpack to bundle but I'm
not going to go into too much detail on
that but the example in the github repo
has all this stuff set up so you can
have a look through it so if we look at
rendering on the client the first thing
you need to do is update the actual
template that we're using from the
server
so my server-side template looks someone
like this so the mark-up here that's
going to be the thing that's generated
by react on the server and this tank
will be swapped out by the HTML we
generated bill J's will be the
client-side bundle that's pulled in
through web pack to create my client J's
file all you have to do is write this as
if there was no server-side rendering
ever so you just write this as if you're
only building JavaScript on the browser
so again I import what I need I'm port
my app and I call read on dot render
react Dom its render method is really
really clever if it calls render and the
stuff inside this div looks like the
same react app it knows that and it will
not completely re re render your entire
application so we're not getting the
thing where you render from the server
the JavaScript loads and we then get a
big flash of white as the react app
re-renders itself is clever enough to
pick up and know where it where it is so
it doesn't have to do that and the
important thing here as I said I'm going
to keep harping on about it we have the
same components on the client and server
this my app component is the same one on
on both sides very briefly look at how
we can configure the clients I build
you'll notice I'm using quite a lot of
es2015 features and so on and also the
JSX kind of HTML in your JavaScript
syntax that rillette provides so we
store a bunch of things web pack and
Babel and Babel something else and Babel
something else and Babel something else
and you keep guessing what you need to
install and you kind of write random
config files that might work and they
might not work and they'll be out of
date next week and who knows but
eventually then you write some more but
eventually once you get through all this
stuff you're able to run web pack or
whatever you've chosen and get this this
build out it's worthless well I'm not
going to talk
upon how in production I would like
minify this and all the rest of it but
this builders you'll notice 690
kilobytes that this is for a HelloWorld
react application
this is incredibly unoptimized this this
would be way smaller if I actually
bothered to do a proper demo and wasn't
such a shoddy speaker so so we've got
this far but so far the components we
built have just been like HelloWorld and
there's not much to it and if you're
building in an application for real
you'd probably gone a bit over the top
doing all this just to render HelloWorld
onto the screen so if we imagine a more
interactive component this component it
might be a little bit small but
basically it's it's a button that you
can click a button and it increments a
number by one and shows it on the page
and it looks somewhat like that so I can
click and we get the count if I then
disable JavaScript I can refresh and
although I still get some things
although I can't click off see because
we have no JavaScript we can still get
something onto the page now I'm expert
contrived examples and this is an
incredibly contrived example but I'm
trying to illustrate here is that a
read-only experience is way better than
no experience for users this is I don't
think many of us are building that
application in production this is kind
of analogous if you think of an app that
that pulls from an API and put some data
on the screen then lets you click a
button say delete one of those entries
or whatever it might be you might not be
able to replicate all of that without
JavaScript enabled you might be able to
with a bit more work but even if you can
just get your your list of data rendered
without JavaScript that's way better
than getting a blank screen or or an
error instead so whilst you know ideally
we are striving for a hundred percent
functionality without JavaScript in
reality sometimes we can't quite get
there and that's absolutely fine you
know even the read-only view is going to
be way better than absolutely nothing
now if we're going to start building a
proper application like say go Carles
the one thing we do need to look at is
routing or if you're building just
client-side applications you can get
away with not bothering with URLs or
they definitely shouldn't I think we've
all like taken a URL from a JavaScript
app and sent it to a friend and they've
clicked that URL and got a completely
different page and because the developer
hasn't kept the URL in sync but
obviously on the server side we have to
kind of set up URLs the de-facto kind of
standard solution
this in react is called react Rooter it
might as well be kind of built-in to
react at this point it's very much
because the winner if you like it's a
very good library so the first thing I'm
going to do is actually build my proper
app so I'm going to have an app
component and this is my kind of top
level component so I'll have this minus
heading and then this dot product is
where the the kind of nested routes will
go so this is like my layout file if you
like and this is just a placeholder for
whichever route we're currently on its
content will be put there again the kind
of nitty-gritty details of routing and
react components aren't too important
here then create an index page which is
just returns this is the index page and
then to find my roots so again I have
this top route called app component and
this path slash I have this index
component and now on the server side
what we need to do is take the current
URL that's just been requested see if we
have a route that matches and render the
the correct components now the API here
is a little bit hairy and it looks trust
me it does look worse on a projector
than it actually is if you actually were
to write it yourself so please stick
with me the other thing is that you'd
only ever need to write this once and
you can pretend it doesn't exist so so
please bear with me so we need a couple
of things from react Rooter we need this
match function which is a function that
can take a URL and all our routes and
decide if they match up and then Rooter
context is the react component that we
need to render that will deal with
rendering everything else so the overall
code looks like that easy
okay next so what do is we'll we'll
break that down a little bit so the
first thing I do is I call match I give
it all our routes and I tell it the
location which if you're using Express
on the server is the request URL
property that will do that
asynchronously we then have a callback
function which takes an error redirect
location and render properties if we've
got an error that means something went
wrong we should probably return a 500 or
something similar or return the fail
whale type page if we get a redirect
location that means we've actually hit a
route that is a redirect because react
routes or supports redirects finally if
we get to if we don't have an error and
we don't have a redirect then we have
these render props which means we've got
all the data we need to render
generate our HTML render props is
basically all the information the Rooter
needs to generate the the HTML and
render the components so firstly if
there's an error I just send the error
message with 500 you would probably want
to do something a bit more polished for
your app else if we have a redirect I'll
just redirect with a 302
and finally if we've got to this file we
can actually render successfully so I'll
render my index template again and I'll
call render to string and I have to use
this Rooter context component and pass
in all the properties this this isn't
really important this is basically just
saying if we get to this stage I've got
all the information I need to render and
generate your HTML for you and this just
does it finally if we get past and we
get to this last bit not really sure
what happens that's just 404 again you'd
probably fail well we'd lock this too to
you it so you'd be aware of it as the
developer working on it
and this actually completely works it's
pretty dull but it does work with all
without JavaScript so let's make it a
bit more interesting let's add an about
page so we're add an about page with
some really dreadful text on it and then
we add it in as a root just down here
and then I'm going to use react Rooter
gives us a link component which is just
like a layer on top of an anchor the
great thing about this is it means in a
non JavaScript environment it will just
be an anchor effectively and in a
JavaScript environment react routes will
kind of hijack the click and and
progress you through JavaScript so I'll
add a link to the home and about page
with no client-side bundles this is all
server-side this does work I can click
between them I get the right content
rendered and as a user I'm none the
wiser
oh nice white flash at the end none the
wiser that that I you know something is
wrong I don't have JavaScript enabled or
something's gone wrong with my request
or whatever it might be we can update
the client-side generator as well or
sorry client-side JavaScript so I just
could react on that render and I just
rendered this Reuter component which
comes from react Reuter I can talk in
much more detail about react Reuter
there's lots of tutorials online so when
going to too much of what's going on
here then if I regenerate web pack and I
visit it with JavaScript turned on we
get a really nice so this it's a bit
unclear to see but these clicks now
aren't going to the server they're just
all in my browser and note as well that
rear Rooter is is great and deals with
things like forward and back
and it all works for us as you would
expect and this would work I don't think
I include it but this also works without
JavaScript as well so that's very nice
we're at this point now where our
application works pretty seamlessly
between JavaScript and non JavaScript
the final step is kind of dealing with
data on the server and the client
a lot of react applications or Jasjit
applications generally will make a
request to some API get some data in
probably JSON and then render that in
some form and let the user manipulate it
this is actually something we didn't
have to tackle it go carlos because ours
was more kind of a marketing page you
weren't hitting so many api's and but
I've delved into this a little bit more
since this area if you think server-side
rendering is a bit more work in progress
this is particularly working progress
there's kind of a number of different
kind of approaches to this and thoughts
going on so there's lots of unknowns
here I think better solutions or improve
solutions will kind of reveal themselves
over time but for now this is what I've
come up with see the general idea here
is we want to be able to fetch data from
some API on the server and the client so
if I don't have JavaScript that request
should happen on the server and we
should get the results of it fetching
that data and rendering it into my HTML
however if I do have jobs gets enabled
the server should still make the request
but then when I when I come back into my
browser and everything's rendered I
don't want the browser to then remake
that same request within kind of a
second of the server doing it because
that's just a complete waste of time so
what you really want to do is avoid
making the request again and that's
where this gets a little bit tricky
there's a number of libraries out there
I've come to really enjoy one called
react resolver this again is a link the
the general idea here is we have a
component so just look at this top bit
for now and this component renders some
information about someone from github so
I reference this top props which is kind
of properties you can give a component
some extra information doc github which
will be the data I've got from github
and then public repos is one of the keys
that github provides you it just tell
you how many repositories you've got
there public what I can then do is down
here I can use react resolver which is
where this resolve function comes from
to say the github prop that I that I
want defined on this component should be
the result of fetching this this URL and
then returning
the data from it so react resolver lets
us basically say this component needs
this data from some API and then on the
client side what we do is instead of
using react Dom don't render I use
resolver dot render on the server side
it's a little bit more involved but I
resolve and then we do some extra stuff
so basically we're resolving we use
react Rooter to render everything the
key thing here is now I have got this
data
I don't just I need to spit out my HTML
that I've just generated that this has
generated for me or sorry this this
render to string call here but I also
need to pass the data from any API
request down to the client because if I
don't do that the client can't reuse
that data and is going to have to make
the request all over again and then my
template I add this extra property
called react resolver payload and that's
going to be any data the server had to
fetch from an API so we update the
server-side rendering to spit out this
payload we update the client-side
rendering to use rail resolver all data
gets resolved on the server by default
it's rendered and it's then used to
populate the data on the client side as
well so react routes are all kind of set
this a sorry rillette resolve will set
this property to all the data it got
then when the client runs on the in the
browser it can see that this exists and
it can use data from that rather than
having to remake all those requests to
an API and now this definitely works
with and without JavaScript so see I've
not made any extra requests here and
I've still got over here my github repo
count 201 which is that is actually
coming from the API just you can have to
trust me on that but with them without
JavaScript we do get the the full
application experience so I appreciate
that was quite a lot of stuff to throw
at you in quite short space of time I
was quite relieved to see the previous
two talks didn't have lots of code else
you'd be way fed up of all this by now
and that's something to get hub it's
just that repository basically if you
have any questions after I'm on Twitter
I can also be emailed as Jack pusher
comm some final closing thoughts
I think universal JavaScript is here to
stay I expect the techniques and
libraries and approaches to change over
time if I did this talk in in 12 months
if Andy housing back yes again
I'd probably do a very different slide
deck and the code will look pretty
different but I think we're kind of
getting there with react on ember and
angular and I think view jess might be
working on it all the rest of them kind
of all going in this direction I've no
doubt that will kind of will improve our
approaches and when one framework figure
something out that will kind of come
through to the the others as well and
kind of the the goal here is that as
developers you we should be able to get
this working with very little effort and
that is the direction we're going in
ember fastboot will kind of do it all
for you angular 2 Universal should do a
lot of it for you and as you've seen
react does make it pretty
straightforward to long time I'd love to
see frameworks go server-side by default
and it kind of be the baseline that a
new JavaScript framework of which I
already 10 also out since I started will
kind of be server side by default and
just kind of work and the hopefully will
will get somewhere towards that soon but
you know go Carlos was a site that we
used it on there are loads of site now
using it as well I think packed coffee
we've probably all come across they use
the same approach to and they've had a
lot of success from that loads of people
are doing this so you know there'll be a
lot of advancement in this area so final
links that's my that's the blog post on
24 ways there's a blog post by my former
colleague Jamie on how we built the new
go cars website from whenever it was the
actual source code so the go Carter site
is entirely freely available at least it
was I think I'm pretty sure it still is
and that's a link to that and then the
example application on github as well it
wouldn't be a talk at meetup if I didn't
do a plug if you want to do more react
or you'd like to learn more about it I'm
doing day-long workshops in London so a
day-long workshop in London so they're
still tickets available it's on the 10th
of June so it's not too long away it's
in it's time for the river it is an
elephant and castle but if you can bear
that there are tickets available wasn't
my choice of venue
so thank very much for listening I hope
that was useful I'm Jack and Scott
frankly in JavaScript I am calm is my
blog I will put the slide on to speaker
deck so you can find me there and if
there are any questions when you wake up
tomorrow morning about react life or
anything else or Rafa Benitez staying at
Newcastle jacket pusher comment its way
finally so thank you very much for
listening
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>