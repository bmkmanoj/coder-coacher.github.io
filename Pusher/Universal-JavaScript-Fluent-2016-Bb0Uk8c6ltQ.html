<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Universal JavaScript: Fluent 2016 | Coder Coacher - Coaching Coders</title><meta content="Universal JavaScript: Fluent 2016 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Universal JavaScript: Fluent 2016</b></h2><h5 class="post__date">2016-04-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Bb0Uk8c6ltQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello buddy thank you very much coming
along my name is Jack and today we're
going to be talking a little bit about
Universal JavaScript Susan me on Twitter
Jack undergo Franklin I work for a
company in London called pusher out of
interest who's heard of pusher that's
pretty good that's more no's expecting
thank you just very briefly pusher is a
hosted real-time infrastructure API
provider so if you want to add real-time
functionality to your app your website
whatever without having to bother with
any of the infrastructure and managing
it and scanning it etc come chat to me
we can help that's that this is also my
first talk outside of Europe which I'm
pretty excited about so thank you very
much to fluent for for accepting it I
know it's going to go well though
because I've got my Batman socks on so
it all prepared to go so really the the
idea from this talk started the company
I worked out before pusher a company
called whip company called go cardless
we were payments provider based in the
UK and this was our homepage go cars
calm and at first we built just an
English version of the site because we
only served UK customers at that point
in time and it was a statically
generated site using Jekyll which takes
a bunch of markdown and produces a
website that work fine and then we
launched in France and we needed a
French version of the website so we came
up with the best engineering solution
possible we copied and pasted the folder
renamed it to fr and rebuilt the website
again in French easy peasy we kind of
got away with that and then we needed a
German version of the site we launched
in Germany and we couldn't bring
ourselves to copy and paste the folder a
third time once was was just bad enough
so we started looking into other
solutions and at the time we we knew we
wanted to build kind of this this
framework for managing all of these
different versions of the website we
would need different languages and so on
and on the team of kind of a few
JavaScript developers we're all quite
familiar with react and we began to
wonder if we could take this idea of
reactant and put it onto the server we'd
kind of read that this was possible but
we don't really have any idea about
about how it went and we did it we built
a large kind of framework around
act for managing multiple versions of
the site in different languages we built
it entirely on the server and then on
the very last day or kind of the
penultimate day we said oh what if we
generate took the same JavaScript and
generated a client-side version of it
and put that into the page as well so we
did and it ended up being a really nice
experience if you didn't have JavaScript
you'd get it rendered from the server
and when you click to link we just go
back to the server like any traditional
website if you did have javascript
enabled react would kick in locally and
you'd be able to click through really
snappily because there were no HTTP
requests going back to the server so it
ended up kind of being the the best of
both worlds reactors are really good fit
and it's react that I'm going to talk a
bit more about today for those who
prefer written I wrote a blog post at
Christmas on 24 ways which like an
advent calendar for geeks which
hopefully some of you have have come
across so this talk really is is this
blog post in in talk forum the slides
will go online afterwards I've got lots
of links to this post of a post code etc
all online please don't rush to write
any URLs down i'll share all the all the
links afterwards and with that but
that's kind of the the intro the first
thing i want to talk about is is why
this is a good idea why we should be
considering taking our client-side
applications and running them on the
server and i'll admit that i was pretty
ignorant coming into building the the go
card the site i was one of these people
who did think that we should just build
client side JavaScript applications
about really concerning too much about
those who wouldn't have JavaScript so I
have this kind of well if they turn
javascript off then it's their fault
right and serves them right this is bad
you should not think this unfortunately
I did there's a really interesting study
done by the government digital service
or GDS who run gov dat UK which is the
the government's official website back
in the UK where I worked for a bit and
they did a study on the number of people
who came to govern you came who didn't
have JavaScript on the page and they
found that one point one percent or one
in 93 visitors didn't have JavaScript on
the page now you might think that that's
not too surprising but what's more
interesting here is about 1.1 percent
only naught point two percent were
people who had explicitly disable
JavaScript in their browser so naught
point two percent that people
have gone into their browser and take
the turn javascript off box but naught
point nine percent of these people
hadn't done that they just hadn't got
the JavaScript so this isn't really a
case of helping the people who have
explicitly chosen not to have JavaScript
it's a it's helping the people who for
whatever reason don't get JavaScript and
this is the blog post which I've got
linked to support system just says only
a small slice of people don't actually
run JavaScript the ones who don't get it
haven't done so out choice and Jake
Archibald takes his point further when
he talks about progressive enhancement
not being about people who have turned
JavaScript off and then he rambled about
service workers for a few hours or
something I don't every name and you can
think about the reasons why people might
not have JavaScript this is really
interesting flowchart by a gentleman
called Stuart language that's a link
down the bottom by the way thinking
about the reasons why we might lose
JavaScript as someone's browsing the
page if you're on a train you might go
for a tunnel as you're requesting the
page you might lose the JavaScript the
UK rail network I'm pretty sure was
routed around no signal so that's quite
common for me back home your HTTP
requests can hang a firewall could get
in your way there was a case sky who are
internet service provider in the UK at
one point they temporarily their systems
for that jQuery was a virus some of you
might think that's a great decision but
what it meant was a ton of websites
broke because suddenly these websites
that depending on jQuery didn't have it
anymore and this was nothing a developer
had done this was what probably was it
was someone at sky who definitely done
the wrong thing you'll see the end could
go down as well you can have a browser
add-on messing with something on your
page there's lots of reasons why
javascript might not make it to the end
user and lots of reasons why they might
not be browsing with with JavaScript and
this is that naught point nine percent
of the gov UK visitors very few of them
explicitly chosen most of them had hit
one of these issues or others just be
clear I'm not here to advocate for
everyone building server-side rendered
react applications there's definitely a
time in a place where these are
appropriate and will make sense for your
use case they made sense for us at go
cardless which wants to talk about it
but this isn't I don't a stand here and
go you should write react every website
should be rendered on the server
it really does depend on the use case
additionally these techniques should map
across to other frameworks reactors by
no means the only one working on this in
this direction and it should map as well
if you just want to write JavaScript
without a framework that should work too
and a lot of this as well is
particularly cutting edge client
applications or client-side javascript
is pretty kind of cutting edge taking
this stuff back onto the server is is
even more so so you'll see here a few
code examples throughout this
presentation that maybe don't look quite
as nice as we'd like them to this is an
area of kind of a lot of progress at the
moment is being worked on all the time
if I came back next year into this talk
i expect the code examples would be much
nicer I could say a lot more things
we're figured out we're still kind of
figuring it out but it is definitely at
the stage where you can use this in
production if you'd like as I said react
paved the way but kind of supporting
surfside rendering out the box if you
like from the very GetGo but other
frameworks are working on this ember
have a fast boot so ember users will
soon hopefully be able to to run that
app on the server using this as we heard
from Bradley earlier angular are working
on this very heavily too there's the
universal project on the angular
repository so once this talk is is react
specific because that's where I
personally have the the experience this
is by no means a talk that you can only
take advantage of if you're working in
react hopefully as we go and more more
frameworks kind of buy into this there
should be something most JavaScript
developers can take advantage of as I
said all the code and demos are up on
github I've had to take a few of the
demos out because I don't quite have
enough time but all the examples i will
show you our fully working on github so
you should be able to pull them down and
run them locally if you do hit any
problems doing so please come and find
me I'd love to kind of help you get them
up and running and talk through things
so if we start taking a look at a
standard kind of react app doesn't
really matter what this app does is
probably a to-do list we have a render
method where we we define kind of what
HTML we we expect our application to
produce and then we use react Dom to
render this this app component into
something on the page in this case a doc
and element with the ID of app what's
really nice if I've got this big react
app and imagine my app is is really
complicated it's a very large app
I can switch it to server side rendering
just by changing this render call down
the bottom to render to string so we
don't give it the app component anymore
because sorry the app element because we
don't need it but reactants dead now
will generate a string of HTML rather
than rendering to a dom this is very
nice the most important thing to note
about these two slides is that the my
app component never changes and what's
inside it doesn't change you don't have
to to make any changes you just change
your your rendering method effectively
and react is a really good fit for this
because of its it's pure rendering
because it represents all your HTML is
virtual Dom using jsx so it's only at
the very kind of last second that you
have to choose if you want it to go into
a dom or just give give ourselves a
string of HTML so running a little node
server that the gets our started here is
pretty straightforward as well we can
import react we can import my app
component and then I grab the renders of
string method from the react Dom server
package and I just say get star means
any get requests render this markup so I
get this markup constant which is the
result of rendering to string my app and
I do res which is the response render I
give it a template which is my index
template doesn't really matter what's in
there and I give it the markup so our
server will will take a request generate
the HTML that represents my app
component and then spit it back to us in
a small HTML template and that's it it
really is that straightforward there
isn't really too much weird stuff going
on it's not a hat you don't have to hack
into lots of components to make it work
out-of-the-box react as a good job of
supporting this and hopefully every
other framework will be similar as well
when we when we get there and you could
always just render react on the server
if you wanted if you didn't think having
it on the client was was beneficial or
whatever reason and react has to
rendering methods to support this we
have rendered a string this this method
will generate HTML with a bunch of
additional react kind of meta
information in it because this is
designed for the the HTML that it
generates to be picked up on the client
side by react again you have rendered a
static markup to and this is when you
are generating HTML that you know will
never be manipulated by react on the on
the climb if we take a look at kind of
this server so
that server and what it generates it's
pretty dull it's just nature mail
document it's got that paragraph with
these couple of extra react kind of
attributes that it needs and then we've
got hello from react so so that's it
we've built a rear server-side app and I
could stop now if I wanted to but
obviously there's there's a bit more to
it so now we built this server side we
can start thinking about if we want to
go client-side if we do we're actually
most of the way there we need the shared
set of components we have the my app
component we have a server rendering
step just like that little node server I
just showed you we then need a small bit
of client specific code to deal with
rendering on the client and then we need
some form of bundler to to bundle are
our JavaScript together into a browser
compatible build that we can send to the
users as I said you didn't you wouldn't
necessarily have to go client-side the
whole idea here is that you can build on
the server and ship to the client if
you'd like to and one of the key things
that makes this approach really nice to
work with as a developer is that your
component should stay as agnostic as
possible if you start having lots of if
else's depending on whether a components
on the server or on the in a browser
that's going to quickly lead to a really
tricky environment for you to work with
as a developer what's so nice about this
workflow is once you've set up that
server in that client rendering all your
components are shared between both and
you don't really have to think about it
as a developer you get a whole lot for
free there are times where you do need
to check if you're on the browser or on
the server but ideally you should keep
your components as generic as they
possibly can so to generate one of these
clients I bills we're going to use web
pack I believe there was a talk about
web pack yesterday that some of you
hopefully we're at web pack is humongous
I could tell you about two percent of
what web pack does there's it does a
whole lot it's pretty advanced it's
pretty complicated and I still don't
really know how it works at all but it
is really handy for taking a bunch of
JavaScript and generating a client-side
build so we're going to use that today
we're going to use it in its most
simplest form you can find lots of
stores online about how to really kind
of battle with it so rendering on the
client basically we're going to keep
things as is all we need to do is
generate that client-side build and also
add to our generated HTML the script tag
that points to that bundle
so if i change my server site template
we've got the mark up there which is
where the HTML that riac generates is is
slotted into this template and i'll also
include a script tag to build guess
which is the file i'm going to ask
webpack to generate for me and then i'm
going to create a file called client
jess and this file will be responsible
for generating the the react on the
client side so I'm port react on react
Dom I'm port my component which is the
same one that i'm importing on the
server side and i just go react on
render give it my app and then give it
tell it where to put it what's really
important here is that when this code
runs when we've got that server-side
generated HTML react doesn't just
blindly re-render your entire
application it smart enough to figure
out that the contents of that active are
already a react application so we're not
shipping it down and then reactors
completely rear ndering everything all
over again we kind of react to smart
enough to pick up where the server left
off and yeah just to note is that the
same components on the client and the
server to get webpack going it playing
nicely we need a ton of plugins and
stuff so many web pack many babel loader
we need the presets and we need
something else probably we create a babe
lossy and then we can create our web
config as i said i'm not going to go too
much into web packing and how it works
but effectively here we're giving it the
entry which is client jess web pack will
take that file it will then pass all its
dependencies squish them all together
and output the file called build Dodger
since the public folder and we have this
loader here which basically says for
every javascript file you encounter
along the way run it through babel so we
can run web pack note that if this was a
production deploy i certainly would be
minifying i'm configuring webpack to get
this bundle down a bunch i don't think
690 kilobytes for a hello world app is
is a septa ball but we run web pack and
that spits out our app top tip if you
are working on at like this you can run
webpack minus W and it will continually
build as you say files web packs also
really clever in the it'll cache files
so every time you hit save it doesn't
rebuild your entire bundle from scratch
you can just rebuild a little bit that
has changed so it's really nice to just
open the new terminal tab and just and
just run
minus W and then forget about it so just
to demonstrate how this might work with
an interactive component I have a
component here that is it's a little app
that has a button you can click and it
will increment the count by one and
display it doesn't really matter what it
does this isn't really a very practical
example but the idea here is you can
imagine that if you replaced a counter
being clicked with some data being
fetched what you'll note is in a minute
on the demo even when I turn javascript
off although I can't click the button I
still get the counter rendered so we're
not talking here always about rent
having your entire app working fully on
the server but at least giving something
to the user rather than nothing if you
imagine your API your app sorry is maybe
listing a table of data from your API
and it's got a button by each row that
says delete and maybe the delete button
needs JavaScript it has to run in a
JavaScript environment and the client
that's kind of fine if I have a dodgy
signal worst case I'm going to get a
table with the delete buttons that don't
work but least and I've give being given
some data this is kind of what I'm
trying to demonstrate with this and
hopefully this will play this is with
JavaScript on you can see I get the
account and I can click it goes up if i
disable javascript and refresh the
button doesn't work now because I've
turned JavaScript off but i do get
something back down from the server this
is the idea we at least give the user
something in the worst case scenario and
a read-only experiences is way better
than the no experience that we've all
experienced the white pages and
refreshing on a train or or whatever so
moving on very quickly talk a bit about
routing we all know hopefully that the
URLs are really important I think this
used to be common thankfully it's not so
much now we've all been in a JavaScript
app where you've copied the URL or
you've accidentally refreshed and your
back to the home page because it doesn't
update the URL there's nothing worse
than that really don't be that person
thankfully there is react Rooter which
is the kind of the go to standard de
facto pretty established routing
solution for react applications and
react route to support server-side
rendering as well so it's pretty
straightforward to get URLs working
fully on the server and in the client so
first we just need a few more components
I create a pas which is heading to my
web two point O app the the curly braces
and this doc props doc children is
where will insert kind of the nested
roots so we'll have the app component
that contains our whole app and
different components will be inserted in
depending which route we're on so that's
all that that means if i create the
index and just say this is the index
page there's nothing too exciting going
on there I then define our roots react
Rooter provides us with some root
components let us do that so you can see
I have app component that will match
every single root and inside there I
have the the index component and now we
can we can update our server side
rendering to to match against these now
this is a bit where the the API isn't
quite as nice as maybe it could be and
it looks pretty kind of hideous at first
glance it's honestly not so bad so
please do stick with me this is one of
the bits where I think maybe in six
months 12 months we'll probably have
kind of cleaned out this API and learned
a bit about how we can improve it so the
first one can do is import those roots
so that's these roots down here at the
bottom well then import a couple of
things from the reactor package that we
need we need match which is the function
that can take our roots and the current
URL and figure out which roots need to
be rendered and we're going to take root
of context this is a react component
that kind of that react Rueter expects
to be rendered that wraps your entire
application with some routing logic so
you don't need to worry about how roots
of context works we need to know is that
it's a component that will wrap your
entire app and as I click around
different URLs the root of context
component will change what it renders to
match what what the URL is so this is
the whole thing I am going to go into it
step by step so please don't panic but
that's kind of as much code as we need
to write to get service I'd routine
going so yeah let's break that down a
bit so the first thing you do is match a
match takes the roots and also our
location and the Express land wreck you
RL gives us the full URL and it will it
will look to see what routes need to be
rendered and cool and cool our callback
function it will pass an error is
something went wrong that's the first
argument react root of fully supports
redirects so there's a redirect route
matched will tell us and pass the
redirect location so we know to do a
server-side redirect finally if we don't
have an error and we don't have a
redirect it will pass render props all
these are is the object of information
so our app knows so reroute Sasori knows
what to be rendered again the the finer
details of
this this is you don't have to worry
about at all so firstly if there was an
error this is kind of unexpected this
shouldn't happen this is where you
probably do your fail whale or similar
does a farewell still exists even know
if it suppose this but this is where you
would fail whale show a hilarious page
or link to your status page or something
else oh we've got a redirect we would
redirect with a HTTP 302 giving it the
path name and any extra parameters it's
kind of fine else if we have render
props that means right we've got the
information we need to render our
application so I'll pass in markup to my
index template and i'll give it a Rooter
context and then I'll take all the
render properties and I'll pass them
through to the react component as
properties on there to this dot dot
effect is a shorthand for taking an
object and passing it all those
properties into a react component
finally if we get all the way through
and we didn't have an error we didn't
have a location and we didn't have rent
the props it might be it's probably a
404 that's come the best bet well that
you can handle 40 falls in rheatt Rooter
so i'll just send for a for it doesn't
really matter and if we run that and I
visit it locally i do get my web two
point O app and this is an index page so
I'm not quite ready to sell for millions
but we do now have react routing working
on the server just to demonstrate now
once you've got that kind of hairy bit
set up it's pretty easy to start adding
new pages so let's add an about page so
I'm going on about page I want to get
hired so i'm going to say i'm a rockstar
developer sure that will work we go into
routes and we just add a new route /
about which which uses that about
component and then just to demonstrate
it I go into the the app component and I
use reaction Reuters link component
which is kind of a layer on top of
anchors the main reason this is useful
is because obviously if we go to the
client and we do have javascript enabled
the link component won't make our user
go back to the server it will it will
navigate entirely in browser so if I
generate that and I don't generate the
client-side bundle so we're running
server side only at this point it all
works kind of fine everything just not
see that I'm clicking and although it's
really really quick it is going to the
server every time and rendering what
we'd its bet that's really nice that
works pretty well then we can update the
client side so we have roosting on the
client as well
we render now this Rooter component we
give it all our roots and we give it
this browser history object that
basically configures react Rooter so we
use the html5 push state API rather than
doing like hash bangs in the URL and
weird hacks so we just get it to use
nice URLs effectively if I regenerate
with web pack is probably tricky to see
but I think that's playing it is playing
but now I can go forwards and back i can
click the links and I've never once it's
in the server this is now all local but
if I went through a tunnel my JavaScript
died whatever this would still work I
just don't go into the server every time
so it's a really kind of nice seamless
experience regardless of if I do or
don't have javascript the final bit I
just want to touch on this dealing with
data on the server and the client
because this is kind of fine but most
react apps tend to hit some API to
render some data that kind of thing I
don't think many people have put apps
like this live and just a bit more of an
extra caviar this area is even more work
in progress and server-side rendering
generally a lot of people are still
figuring out the best way to deal with
this says a fair amount of unknowns a
lot is changing but we do have some idea
of a kind of direction we're heading in
the problem here is we want to be able
to fetch data on the server and all the
client but if we if we're on the client
and we get data from the server if that
server has already made the HTTP request
or our API to get the data we want to
render I don't then want the client to
immediately make that same HTTP request
again that's just a waste of a request
it's pointless in it it doesn't do any
any good so we can't really we can't
just like chuck a fetch call in our
react components because it won't work
so we do need to kind of reach out to a
library to make this work for us there's
one that I've used a few times called a
sink props it's created by Ryan Florence
who is one of the two main contributors
to react Rooter it's not
production-ready still a work in
progress in the github repository the
with a sync data folder has an example
of an app working so asing props asker's
asks us to define its load props method
on each of our react components and it
does something acing in this case I
fetch data from github for my username
and then we just have to call back with
the the data we found
so async props will look for this method
call it and get the data back from it
and then we can refer to this data in
our render call as if we had it without
having to deal with the async part of it
so I can reference this doc props github
public underscore repose which is a bit
of data that github API returns to us
I'm not going to show you how to do it
but because there's code and I don't
have too much time but async props the
way it works it generates a script tag
that contains the data that fetched on
the server that then passes down to the
client the client then looks for that
that kind of script tag and it exposes
some data on the window object and will
render based on that data rather than
making the HTTP request all over again
asing props is one of many there's also
react resolver which is a slightly
different take of a similar idea that's
pretty small so you probably can't read
it the idea is we decorate our
components with with using react
resolver so we stayed we resolve a hey
before you render this component we need
to resolve this this async thing in my
case again I'm just fetching data from
from github resolver then gives you some
data that you need to expose as window
underscore underscore react resolver
payload underscore underscore the data
gets resolved in the server sent down to
the client and again the client will
first look to see if that payload exists
on the window object before then making
the request again so we don't have to
make the request twice the server makes
it once and then the client just gets
the data from the server and here's a
little video just showing you that this
does work so you see here this has come
down from the server and I haven't had
any extra request to github because it's
all kind of working if i disable
javascript and refresh it still works
too so that's working with and without
javascript as an aside i disabled
javascript to record this video and then
spend about an hour figuring out why my
app wasn't working last night on the
entirely different project really if
anyone from the Crone team is here I'd
love a big shiny like you've turned off
JavaScript button somewhere on this page
because it yeah how many stuck for way
too long this area is as I said it's
very kind of being figured out very
rough around the edges more solutions
will come with this i think as as ember
and angular and other frameworks tackle
the problem will gain more info and more
insight there's a bunch of people doing
it in different ways we've react so I
don't think if I was back here in 12
months
I'll be able to give you a much more
polished polished excuse me solution to
the problem yeah as I said everything is
on github if you look for the universal
react talk repository I'm around for the
rest day I'm happy to take questions
kind of in person I'm Jack on school
Franklin on Twitter and jacket pusher
calm feel free to email me at any point
any questions and I think what's really
important here is that Universal
JavaScript clearly is here to stay we've
got enough enough people who kind of
matter in the industry really buying
into it we are tember annular kind of
the big three if you like all kind of
gunning for it our techniques will
refine over time as more and more people
do it if you think back to where we were
with client-side applications maybe a
couple of years ago I feel like we're
kind of at that point with with
server-side applications and things will
improve long-term I'd like to see is
frameworks doing most of this for us so
it's almost effortless for a developer
to add server side and to a project and
eventually even get to the point where
we can can build server side by default
because really there's there's no reason
not to there's not much additional
overhead to developer in terms of effort
and time and it just all kind of works
out of the box that's what I'd like to
get to I think we're heading there as
you can see right now there's a there's
a bit of work to be done just some more
links for you there's the universal
react blog post on 24 ways we wrote a
blog post about how we built the go-kart
asst comm the the reactor universal
rental application which again these are
all links the go cost or con website is
actually entirely open source so you can
go and check it out I don't work there
anymore so whatever's happened in the
last few months nothing doing me and
there is also a universal react example
app so yeah the go karts talk on repo is
a complete mess which I'm sure it's not
then it's it's not me if you're a fan of
react I know that we're about five and a
half thousand miles away from London but
I'm doing two workshops there if
anyone's particularly keen or has also
come halfway around the world like me
come and do a day of react on the 16th
March or the tenth of June but although
it means to me say is thank you very
much listening as I said that's my
Twitter handle I blog at javascript
playground calm love it if you and check
that out I'll put the slide onto speaker
deck orange at Franklin and finally I'm
jacket pusher calm if you've got any
questions I'm around for the rest of the
day and I'd love to chat through your
stuff in person as well so please do
come and find me
like a million feet tall and wearing a
gray pusha t shirt so yeah thank you
very much for listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>