<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The JS Roundabout, Time to React to Testing, January 2018 | Coder Coacher - Coaching Coders</title><meta content="The JS Roundabout, Time to React to Testing, January 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The JS Roundabout, Time to React to Testing, January 2018</b></h2><h5 class="post__date">2018-02-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tL2UpJQtLPQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi yes so and I'm bandhas Clem um we're
software developers working at Theodore
which is a start-up working with other
startups to build products really
quickly and for large corporates to work
it sort of startup speed as we are from
working quite fast to develop new
products testing 20 points to make sure
we're not breaking the features we're
building and as things work once we
leave the project so we like to think of
testing sort of as a pyramid as lots of
people do so going from the bottom which
is the least complex more libery applied
stuff like static analysis to the top
where the more complex end-to-end tests
which take a lot of time to writes but
you need on your critical paths so we
start in react switch the talk is about
what your purposes are said so testing
and reacts static analysis we use flow
and es Lintz flow for type checking and
es lint for style checking then up to UI
regression tests so checking that things
don't disappear from the front end where
we use jess snapshot tests up to unit
tests which again we use jest which is a
tester on a certain library and snapshot
tool from Facebook to run our unit tests
traditional and once where we actually
mount components and play with the UI
and then for the end-to-end tests we use
WD i/o or also Nightwatch to run a
selenium server and actually simulate
actions on a browser for those complex
paths that we want to check work so
starting from the bottom up static
analysis normally in JavaScript is quite
a liberal language we're used to
catching problems in runtime or in code
review or on production but we can fail
earlier fail faster by using static
analysis tools to build upon the type
checking in JavaScript and also more
enforcement on what syntax is allowed so
it class example adding a number to a
string it works in JavaScript but you
shouldn't be able to make 12 from one
and two so when it comes to static
analysis what are your options and you
can check a style you can make sure that
you're not building very complex code so
you don't have too many variables don't
have so many too many nested if
statements you can get rid of code
duplication by making sure that it's
detected and fails you're built and then
type checking which is why we're using
flow to make sure that you always making
the right operations and you expect the
parameters that you get and finally
there are some security linters which is
static analysis to make sure you're not
using anti pass
on security there aren't actually any
good ones for react yet but for the
backends OpenStack bandit is good for
Python and then for the style complexity
and duplication
yes Lintz is a standard with different
plugins and packages and four types flow
as a tool we found most useful for react
so yes Lin is really easy to install
it's just a yarn dependency there are
two things with the eslint configs and
plugins so conflicts say which rooms are
turned on and which rules are turned off
and plugins define new rules a B and
we've come out with a really good es
link config for react projects so
includes several dependencies which make
sure you've got all the plugins and
configurations set for the best
practices and reacts some examples from
that so forbid certain prop types prop
types away define what your component
expects to get a prevents duplication of
prototypes and it makes you write
components as functions when you don't
need the more complex code for flow and
where we're applying types to JavaScript
it's a static type checker for Java
scripts you have to run your code
through babel first to make sure that
you remove these types before runtime
and then you can just add it with a flow
so add it with the yarn dependency run
flow and you can see the code passes for
people familiar with react you've
probably seen we already have prop types
in react so why do we need more type
checking
well flow is more powerful because we
can do type checking on all of our
services and all of the other logic of
our code also we can apply types to the
state as well as the props and because
we can infer types it means we get more
out of what we specify a classic example
of flow not in react but just in simple
java scripts if we're the function to
square a number we can see that here
we're saying the N is a number and then
we're multiplying its and if we try use
a string we'll get an error the nice
thing about flow which you don't get
with typescript is that it can
automatically figure out what your type
should be and infer types so you
shouldn't have to specify the types or
everything so here we're not specifying
the type but flow is still going to fire
an error because it knows we shouldn't
be using a number in multiplication so
in react if this is a traditional sort
of components so using a class
extending react components we're
importing prop types from its own
library has that changed in reacts and
then we're saying the prop types we've
got foo which is a number that's
required bar which is a string that's
not required and they've got a simple
render method if we flow if I this we
can define a type object at the top with
foo being a number and bar being a
string which isn't required shown by the
question mark and we can also define
types for our states where you've got
counts as a number and then in the
angular brackets just after the class
definition we can specify the types of
the props and then the type of the
states and four functional components as
it's just a normal function we can say
props is of type props and props as a
type we've defined with foo and bar
Thanks so now you've seen static
analysis so basically once you've
configured your ear skin you can use it
on every new project so on on all the
theater projects on all new projects now
we have a nice feed configured so that
when you start a project you have just
static analysis ready for you then you
can implement flow as well but you have
to configure it for every file for every
component something really like to do as
well that is cheap it's the UI
regression test and for this we use the
snapshot so this is way cheaper than
doing end-to-end test and this allows
you to prevent any unwanted UI
modification this is what I like to call
unit tests in your UI so basically you
have a component you tell it this is how
it should render so if you've got deals
and the span inside this should render
as deals and span inside so how does it
work we use just so this is a tool
provided by Facebook frame or as
Facebook it's really quick to implement
you do it on our chest you have it and
to run it then you use the unjust and
that's it
you can configure it in your package of
JSON to specify the coverage the
threshold and some other things like
which files you want to extrude from
your coverage this is really useful to
catch at say most of your regressions
while you are cutting because let's say
you touch a button you
brought to your button and you realized
while running your test because your
test can run automatically like you are
watching your test we brake
automatically telling you that this
button was used on another page so that
you don't forget that you should add
these props in this new page as well and
it's also useful at code review because
when you create a snapshot this will
create a new file explaining how this
component should render and you commit
this file so that then the people who
review will be able to catch if there is
any issue it's also a good practice for
you to structure your code because
snapshot can become a real pain if it
gets really big if your components are
will be so it forces you to have really
small components so structuring your
code having really small components and
for instance if you're using if you're
familiar with atomic design is really
good too because you structure your
components inside the different folders
so how does this work let's take an
example of a footer so it's really
simple this is a div it has an ID footer
and I'm using start component this time
I deal with a color black how do I
snapshot this simple I use render I
create my footer and then I expect this
element to much a snapshot and
automatically what it will create what
just will do when you run your gist is
create a snapshot file explaining how
this component should render it will
look like this so it will tell you for
photo renderer component correctly if we
create a class with color black inside
and a div with the class name in the ID
and that's it thanks to two packages
enzyme done JSON and just style
components which allows you to simplify
this snapshot otherwise it's a bit messy
and thanks to this you can have a track
a trace of how it should look like when
it fails it will look like this so yeah
let's say I change the class name
because I'm you're not using style
components and change the class name of
the photo to header then you will see
directly and you can assume whether I
did it intentionally or Anita changes so
these are snapshots test
some developers don't think it's real
test because it's really cheap to do and
it actually doesn't allow you to catch
any problems for instance when you click
on a button if your button doesn't work
the snapshot will not catch this if
you're all your logic doesn't work the
snapshots will not catch this but it's
so cheap to do in two lines you can't
have this that we usually do it on every
component then you want to test all your
logic with unit tests so how does it
work in react obviously you want to test
really small things with unit tests and
why do we do this because it allows you
to understand directly the route of the
bus whereas if you have an end-to-end
test maybe it breaks when you click on a
button and then you have to investigate
why it breaks what's happening and it
takes you time and if you have a really
good coverage and everything is tested
then you are more confident to cut
faster it's really good for us
developers to know that if you work on a
feature all the tests will catch what
may happen so that's a big question do
should we aim for 100% or not I think it
really depends on a project we can
debate about this I don't know if you're
familiar with Redux
in theater we are familiar a lot with it
because all our projects use it and why
do we use it because basically it's
really useful to debug an application so
if you are not familiar with it quickly
the view represent your components and
the view will be render based on the
store which is like a storage and the
only way you can modify this store is by
dispatching an action ok and when the
store catches the action it will update
and then the view will say all the
stores updated so if the props I'm using
has been updated as well then I will
rerender so this is the flow that's
happening in the videos I want to focus
on this to explain you how how it has
this so basically what we want to do
what we want to test is the view is
correctly instantiated based on the
store so if you have got a component
that is receiving props we want to be
sure it's accentuated correctly then
when you click on a button the correct
action is triggered to be sure that it
will reach the actions and then you want
to test as well that once an action is
dispatched the store updates correctly
then you've got the whole cycle and you
can understand how this works so how do
we do that we're going to test logic
functions business logic functions
really simple they can be used
everywhere
you're gonna test selectors as well so
for instance your component is using
some computed data from the store via a
selector then you want to test this to
ensure this data is in a correct format
you want to test the register actions to
be sure that the stories of data
correctly in depending when once an
action is dispatched and then the
components behavior once you click on a
button something happens so what do we
use for this just again because it's
really powerful and easy to use and
enzyme a tool created by our B&amp;amp;B that
allows you to how can I say this to
create a component either by shallowing
it which is really simple you create a
small components and it will render it
with props and then you can manipulate
it all by mounting it where it will
trigger the whole redox flow which is
mounting the elements and then you can
fetch in another tutorial
let's take a really classic example I've
got a function get highest number which
is a service that takes an array returns
a number how do we test this we've got
here got my array I expect my function
to return the correct value and then I
have an edge case it returns nil if I
give it an empty array obviously if it
passes the news it green and then if it
breaks if someone breaks it that is not
the one who developed it he will see oh
I was expected to see no they receive an
empty area so then you can understand
what's happening just is really useful
because it gives you a lot of functions
like this that you can use on all your
cases for instance to be in a little bit
fruity you can set if your function
froze correctly or passive
correctly that's the basics of just then
you want to test that your components if
it uses selectors to get data from the
store do it correctly so you want to
test the selectors for instance I've got
a selector that from the state returned
a number which is in a sub register so
how do we test this while you mop the
stage you create the fake state with the
server disown your number inside you
test your function and it you expect it
to return the correct value and then if
it changes it will break then I mention
it's too shallow up component let's say
I've got a component that once you click
on it it should do something you want to
be sure that it does it so what I will
do is shallow my element and I will
create a function as well there is a
mock function
thanks to Jess you can't read just @fn
choose a function you can manipulate
afterwards I will give it to my
components and then I will simulate a
kick thanks to the wrapper and I expect
my the mock to be called at least once a
little higher if you mount it then you
can test functions like component did
mount so it's something that happens
only once the component is mounted I
want to be sure that this function is
triggered so I do the same but you get
need to give it a bit more data I need
to give it the store and everything so
that I create again my function here I
create the store with my function inside
and then once I run just by mounting it
my function should be called so
basically we tested the whole flow the
radix flow what we could do is also test
the middleware for instant yuccas test
sagas it's really straightforward to
test because a gas can be declare really
easily so you expect with time you
create a generator you do an X and you
expect the values to be the one you
expect that's it for yeah unit test
yes we've worked our way up to the top
of the pyramid as I mentioned at the
start the ones at the bottom of the
easiest to implement and the ones you
should have more liberally and the ones
at the top are the ones you should use
less but for the most important parts
and end-to-end testing is the most
significant one for this so it's the
things you never want to fail we use WD
IO and Night Watch for some of our
projects it's not really react specific
the only react specific element of it is
some components can take a while to
mount onto the page and in those
instances you might need to do some
weird timeouts stuff other than that
it's like testing any other websites so
WD IO provides a test runner and also
supports multiple test frameworks to run
on top of a selenium server to integrate
with your websites a browser and the
important thing is do this for your
critical paths so if your Amazon you
want to make sure someone can put
something in a basket and you want to
make sure they can buy it but mainly you
want to test the happy cases for that
and not every different error message
your application will have and only it's
expensive to write but all these tests
will be on your continuous integration
if it takes 30 minutes for every build
to surpass or even to fail your
developers are gonna be slowed down a
lot and these tests can break very
easily and sometimes not even because
something's broken just they can fail
randomly quite easily so the testing
framer they went over from static
analysis up to UI regression tests unit
tests and the unit tests that mounts and
interact with the UI and then up to the
end-to-end tests the final thing is it's
important these are all in a continuous
integration so they're on every build
and staging or UAT and into production
all these different checks should pass
your linter should pass on all your
files including your test files and all
the different tests and that pyramid
should pass we use circle CI which we've
seen to be quite fast especially since
circle CI 2 but Travis and many of the
things are quite easy to use yeah that's
everything if anyone's got any questions
please yeah
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>