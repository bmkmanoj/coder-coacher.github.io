<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ViennaJS, Why we should care about Code Splitting, November 2017 | Coder Coacher - Coaching Coders</title><meta content="ViennaJS, Why we should care about Code Splitting, November 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ViennaJS, Why we should care about Code Splitting, November 2017</b></h2><h5 class="post__date">2018-02-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iSit-m6kjFI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey everybody so welcome to my talk
about why I should care about code
splitting I gave the talk like half a
year ago at Vienna J's but it was kind
of like a prototype of it so hands up
who has heard about who was here like
half a year ago I see one end to okay so
not too many so it's good yeah Dan would
stop and go outgo so yeah my name is
Glenn Reyes and the one behind this is
my face because if you see it and this
is also my twitter handle which is my
name actually but without the ease and
I'm a freelance front-end engineer
currently working with react and
currently working with graph GL and I'm
also married to play the guitar and be
like to be around the globe so I'm also
part of the array Agana meetup group
which is I helped them up to organise
meetups and the next one is on December
13 so you may want to check this out if
you're interesting if you're interested
in react or react to related stuff and
yeah let's talk about a little bit code
splitting so hands up in the air who
knows what code splitting is awesome
who who knows who who has played with it
but haven't had the chance to ship
something something who has sheep
production died with it
not too many oh it's so what is code
splitting actually code splitting is
nothing but a feature that allows you to
split code into that can be loaded on
demand or in parallel so what does this
mean in our component architecture like
like and react so let's say we have this
component three and top-level one
represents like the entry points imagine
of webpack the empty point of a module
and that imports react components and
and so on and so forth so most apps
likely have ever out separate the views
right so let's say this
part in blue is is our components that
is used for a homer out and the the one
on the right is are the parts for that
are used for a profiler out right so
this example just uses two routes in
total and most simple configuration of a
bundler like web pack for example they
they generate like one giant bundle and
it contains like NPM packages and all
the react components they all are
squeezed into one giant monolithic
Bangla the camera really be dependent on
your application and the problem if the
problem is if you would only visit the
if you would only visit the home page
for example all the parts that that you
use for the profile page would be loaded
as well over the network and so we need
to split the bundle into smaller pieces
and to do so we first want to define
speeding points exactly there and
separate pieces of code so you want to
basically set boundaries that are
specific to the views and our share code
that is that is used across across all
pages which is which is in this case
only the entry point and as a result we
expect to to to have our application
divided into separate smaller pieces of
chunks and it's in this case we have the
bound on the GS and the parts for the
home that GS and the parts for profile
of GS these two parts are like the route
specific chunks that you would use only
if you visit this route right and
imagining visiting our app if you visit
the home route these are the parts that
you want to do one a load over the
network right and all the pink parts
shouldn't be loaded as you visit only
the home page and yeah again these are
the two bundles that you would that you
want that you want to load that should
be present when you visit the home page
so we want to skip the profile code
because it's not needed at the moment
and because of this we will potentially
improve
performance introduced PageSpeed load
read and actually why should we why
should we care
do we really need it and when I started
to dig deeper into this I was like hell
of Hell of God I I don't I don't I don't
want it it's just much probably too much
overhead it's my app is too small enough
I don't need it right and of course if
it was just me I wouldn't need it
because I'm really support held in that
most of the time when I'm when I'm
surfing or the Internet
it's it's on 100 megabytes per second
and all of us here we all we know it we
are all engineers and we know how to
handle networks and to get to get like
fast internet connection and we know
that we are privileged so and most of
the time we know how to troubleshoot
tech right and we should really
appreciate it so mostly we don't have to
worry about properly accessing our Web
Apps and it's basically everything is
cool until we see this this guy right so
everybody everybody hates this like
especially if you want if you need
something really but you need you need
to wait like forever and it's really
frustrating when especially in
situations where your needs connectivity
right now imagine you're in the middle
of nowhere right and then and then your
your your only survivor is now internet
connection and then suddenly yeah
suddenly a CD let me see this guy right
so so the thing is we are used to expect
the internet users work and in fact the
vast majority of people surfing on the
internet right now is not on on on our
elegant super high fast computers it's
it's it's it's like this where's the
more and more people like are using the
internet over the smart phones and very
little phones that are very that are not
that that it does not have the same
capability is like like your computers
right so again back to question why
should we care
code speeding can help out can help out
to reduce or idle time and despite this
why
Coates but is because it's so simple
correlating is nothing else but
replacing one line code of code with
with four lines of code it doesn't it
doesn't mean you want you need to
reflect or like like your whole
application or a half code of the
application is basically one it's
basically three more lines of extra code
now how does code trading mean for
performance what's how does it increase
performance so one reason why I wanna a
cosplayer is to separate the bundles is
long-term caching and long-term caching
means you split your vendor codes like
packages in node modules that almost
never changes with app code that you
frequently updates and add over that
features over the time so and after this
you basically get the benefit of not
read downloading NPM packages it hasn't
changed deployed after you have deployed
your your your app right and also split
up codes are being loaded asynchronously
by using the power of promises and this
means you don't have to worry about
render blocking while you were you're
loading the page and this this allows
you to easily customize components like
like Laura loading opponents and and
render them as you as you want and they
are they're already there as you stay as
you wanted you want them to be rendered
right so with code splitting or all
necessary code are loaded on demand and
the bundler would take care of injecting
code automatically to the Dom and that
is needed in the page I'll explain it a
little bit later so we as developer we
shouldn't have to worry about what
happens what happens and at a low level
is on level right so what we aim for is
not to waste any kilobytes that's being
downloaded through your network and
what we aim for is to load code as
needed so yeah let's you might be
curious about how this how this works
and let's take a sec that the app
example earlier where we have there's
our home home route right with the blue
background and if we take a closer look
to the h2 element 3 we see that we have
here underneath the bounded GS which is
which is our shared application code and
here in the head the home that jankoji s
that is loaded as our app recognized
oh we here the home page and so let's
load this dynamically and after after
both after both scripts are there you
will see your your app in the end
rendered on the browser or any or any
environment so if as we click on the
profile page while being on the home
page and looking at dependents looking
at the HTML element tree again we know
they stirrers now another script tag
which is the proper that chunk of GS and
the profit chunk the GS is the part that
we have that is that is used for the for
the other forty of other other route and
we notice we have now home that jankoji
has probably challenges and bondage GS
and the thing is we moved from the home
page to a profile page and as we moved
to the home to the profile page we we
dynamically loaded another chunk and and
the code that we have in the profile
page is a nano key been added to the to
to our to our browser right so
everything is there and nothing will be
loaded anymore to the wire well we have
this and if you're also if you're using
CSS mgs all styles are being the not
only are being downloaded dynamically
for free by using this code splitting
because CSS and J's relies on your
modules and relies on your components
that you're using they are all tightly
coupled on door and the environment
because of this styles are loaded on the
mound as well which is which is really
powerful actually and despite despite
despite this all we can all load code
that is dynamically based on its
interactions and yeah it's really cool
isn't it so
yeah let's take a little bit a look at
syntax so right now there are a number
of ways on how you want to import
modules or components into your
interview into some modules right so
there is for example a system that I've
really bad to read but the system that
j/s systems is not import for example or
system that import which is I think web
pick to you or so and there's also
common GS requires and require that
ensure and even people implement their
own way of importing modules and there's
thankfully something better than than
this and it's called dynamic import so
it looks like this and its really
awesome very familiar for us JavaScript
developers so what is it and how how do
I use it
syntactically it looks like like a
function and use the reserved word
import as a name of a function but yeah
it except it accepts the path to your
module and it doesn't actually behave
like like a function it behaves more
like like like the super in your
constructor for example it doesn't what
it also does is it returns a promise and
behaves like like this so very a lot of
open source libraries are adapting this
feature because the syntax makes a lot
of sense and there is an open tc39
proposal which you can check out at
github and if you're interested into the
into the steps
I think it's currently in stage 3 right
now but if you're interested into the
progress so definitely check this out
but even if it's a proposal it's it's we
don't have to wait for for this to land
to the spec right because with babel we
are able to allow we're able to use
these the syntax today and with syntax
dynamic plugin and with this baby we'll
be able to parse the new syntax the new
import syntax into code 3
is actually readable in your browser or
any other - in target environment and
actually I want to add to this is chrome
better and and Firefox better I guess
they they have it already on in the
browser natively so they implemented it
already into the browser but yeah if you
if you're still using other browsers
than the better so the magic will happen
all in this in the bundler which is in
this case web pack and you find here are
fantastic guides on how to set up code
splitting what it does and all the
informations you need for setting up and
configuring this thing and also there is
a nice step-by-step guide from duo of
survived J's calm so definitely check
this out it's it's a really great thing
I also tweet my my slides so you so you
don't need to catch pictures or so now
let's talk a little bit about more about
how how the Namek imports are different
to synchronous imports basically u6
imports loads module synchronously by
just importing for import charge from
chart and so on and and then you have
access on the module so it's nothing you
write and we have asynchronous imports
using dynamic imports you basically call
the import by passing passing the patent
module and then use it just as you would
deal with promises like in this case
with the debt dam module and then you
have access to your module and the cool
thing is you can use a second and wait
with import as well with the name
keepers as well you just basically wrap
an async at the wrapping function or add
an async to the wrapping function and
then you can access to the module with
pretending awaits before your dynamic
import and everything looks more like
imperative Lee and more like sync code
even if it stays in code right and
let's talk a little bit about more how
you wanted how you would use a dynamic
import with react and note that react
isn't just the only way on how you can
apply the name imports there's a lot of
frameworks like angular view or ember
that probably will are will adapt is
feature to write so watch but in this
but for now I'll show you an example in
react so in our app components we
basically want to render a component
that is being loaded asynchronously or
we basically want to load an
asynchronous components by importing
some something and once that we mounted
so what what is once you set initial
initial state in our react state and
render first or return first with a
function simple react element by to just
show that nothing is loaded so this is
our synchronous nothing nothing has been
loaded indicator right so and react
react components has have this has this
pattern that is called lifecycle hooks
like component did mountain in this case
and it fires when the component has been
mounted and in component did mount we
want to call the dynamic import and pass
the path for the async component as an
argument and then we simply assign the
result to our to our constant Asian
component and then we simply set the
state to to update or to perform a
rerender of our component and with
setting the state we basically replace
that we have in this nothing loading
indicator with our async loaded
component ret so and the run function
will we will first see the nothing has
loaded indicator and after the a sync
component has been loaded it will be
loaded afterwards like like after after
the set state has been has been called
and after
after I did the app component has been
rear-ended right so but what about
loading multiple component at once and
for this we have we can take advantage
of promised at all and it's basically
just the same thing like you would do
with simple promises and in component
didn't are we basically would call the
promise promise at all and then pass an
array of dynamic imports and then we set
the state of components which is here an
array and initially an empty array and
after we have set it it's an array of
the of promises and and then in render
we simply map through the array and then
and then render them right and you
probably might be like are you kidding
me this is not this is not three lines
of extra code it is actually this is
actually your your your you you screwed
my component so it's going on here right
and for this we have react loadable
which will be able to cut these lines
down into just a few lines and it's it's
a higher-order component offered by the
james kyle and it's it's basically
taking all the complexities i just show
it before and makes dynamic imports you
mix using that making imports even
easier so including a server-side render
support here's a tiny comparison of a
synchronous we're out and here we we
simply passed a component with the
component per up and if you want to it
asynchronously we basically call our
called loadable composer
higher-order component and pass passed a
bunch of options like here in this case
loader
with a function that returns the dynamic
import and yeah i'm here loading
indicator which is also again react and
simply react element and what would what
this would do is the example that i've
shown before but only in three lines
right
and with this we will be able to replace
in this with this we will be able to
make our app up five times faster before
than before and create reactive is a
great way to start using using dynamic
imports it supports this and also you'll
be able to do this with react loadable
it's it's it's 100% compatible with this
and especially if you're new to react
it's a great way to start actually so
definitely worth consider using it if
you start new projects or some of you
might be like crate reactive is not an
option and we need server-side rendering
for app right and of course there must
be something and I there's this
resolution parts of crate react app but
also does the parts on the server too so
it has liked to webpack instances and I
played with react loadable and made
experiments with this so check this out
this is basically razzle with react
Louisville and has server-side rendering
support with it and just work like
create react app and also there is next
GS which has code splitting and dynamic
imports out of the box it has a very
minimalistic API and renders your app
complete on a server too and I guess
agent that SH uses it right so yeah
check this out
game Ralph author out next to GS
mentioned that sighted Co is built of it
and uses hundreds of code splitting
entry points and with this they have
really speed up time from thousand
milliseconds to down to 200 milliseconds
which is pretty pretty awesome so when I
started to dig deeper into this topic I
saw so many guides on how to do and what
it does but in reality what it where I
was more interested in was how do I
actually make it right how does the big
player do it what are the common
practices and how do I actually make my
app even faster and I'd love to share an
approach that works for me applying
common practices
and to strategically code split the
entire application and the first besides
dynamic imports may want to split your
code your app code and been decoded that
that I've explained you before to get
the benefit of long-term caching as I've
as I mentioned before to create one
bundle for the vendors and another
bundle for our frequently updating or
for frequently updating app and if you
want to read more about this here is a
nice medium blog post by Tim Sebastian
and he basically treats the problem with
named chunks and named chunks IDs so
check this out
yeah the second is considered code
splitting your code at the router level
using dynamic imports this is basically
what I've showed you the last 15 minutes
everything every single line of code you
of a page that you visit that typically
belongs to to a page right so in general
it's common practice to to split your
code at the route entry points and even
there might be code that can be shared
so if you have if you have the case that
you have like shared code between routes
even even for this web peg has an
awesome feature which is called epic
chunk names and it's basically doing
this import thing and then adding this
weird comment in between and with this
you'll be able to allow to organize and
group multiple chunks of modules
together and assign it with the same
name and it's pretty neat if you
especially if you want to to use shared
code just for parts of the app all right
and the third thing is after splitting
vendor code with your app code and then
further down speeding your your code at
the router level consider splitting your
your code further down that component
level so what does this mean imagine you
have this huge chart but imagine it's
still not in this huge imagine it is
somewhere not in the view not in the
viewport
and what you want is you want to load
this chart as you scroll in so you you
might want to lazy load this chart into
the view and it's really really
important it to do this especially for
for bigger for bigger components for
example like like chars that have that
have but so so you don't wastefully
loads something to the browser or you
you you get you will be able to render
things faster to the viewport by yeah by
splitting by splitting them up component
level so also we we should we should we
shouldn't overuse dynamic splitting
points since this can also have a
negative effects so don't split
everything but don't split definitely
like big things that that are like where
you feel you want to split them right so
also try to predict what they use
intends to do in your app and prefetch
based on your user interaction so
sometimes their use cases where most
where people where users most most
likely will click on certain things and
therefore you can prefetch the chunks so
that the coded is already there and
prepared for for the user to be
displayed and react pyramid is actually
a great tool for this that can be used
for prefetching data based on mouse
behavior and with this you can define
for example like imagine you have a
component and then you add then you have
like a parameter like like an area where
where your mouse reach in and then and
then you load everything for the next
route for example by calling a function
so it looks like this imagine your your
your mouse is here and then as you move
here you know now the chunks that that
you are about to to visit to the next
route for example and then it's loaded
and then in it's loaded before you click
or the button right and this is how the
syntax would look like and it's very
simple
you have here a parameter parameter
element and here the button as a child
and here in the arm bridge to basically
define your your own sense and when you
when you click or when you when you
breach the gray area that I've shown you
before and this is actually their
padding that can be set with react
parameter so it's great thing to yeah to
do prefetching as well so to sum up
where code split split up and vendor
code for long time caching split at
route level as synchronously to load
only the code that is needed for the
page and also split a component level to
lazily load parts of the page as the
user Scrolls in or as the user interacts
these are the nice good reads if you're
interested in cultivating benchmarks and
loading loading performance definitely
check them out and the recap dynamic
imports
it's a tc39 proposal with babel you can
use it now don't load useless code by
splitting your codes with dynamic
imports depending on the project size we
will be able to reduce the page load up
to five times first splits app and
vendor codes and then at route level and
a component level create react app and
next is I'll clue is to start also check
out this rattle experiment I've shown
you before and also note that the idea
can be applied to any frame it's not
just react so yeah that's basically it
if you're interested to talk more about
code splitting that's definitely talk to
talk to me and yeah also you can ping me
on Twitter if you if you want so thanks
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>