<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Vienna Go, Reference in Golang, March 2018 | Coder Coacher - Coaching Coders</title><meta content="Vienna Go, Reference in Golang, March 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Vienna Go, Reference in Golang, March 2018</b></h2><h5 class="post__date">2018-04-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WLMtDCqUCV4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my talk is going to be beginners talk
this time last time we went more into
death but now I want to talk about
things that happen to the two newbies
actually quite a lot that fullscreen
yeah and I think it could be helpful for
those especially those switching
languages and coming to go for the first
time to understand what's the headline
go is passed by value so whenever you
call a function or you use the range
parameter or whatever it's always passed
by value and this is actually many
languages follow that paradigm but I
think not many languages have it
implemented as well as go has and
therefore people are actually used to
faulty behavior and have difficulty
adapting to it and go ooh it's not
working yet sorry mm-hmm
I really want to use that clicker there
we go
credits thanks Janos once again for
sponsoring things we accelerate for for
letting us be here that's really great
opportunity especially with sector 5
breaking off and thanks Robert for
usually organizing this and I'm pretty
sad that he's not here today myself I'm
a software developer for actually at
least 10 years and I'm doing golang
nowadays and do a lot of Perl and
typescript I used to be a sister that's
actually the slides from my last talk at
a different venue so I had to talk more
about my sister admin experience but
matches your requirements I've done that
15 years and for I don't know
installations of 20,000 users and more
and I'm an expert still at causing and
fixing disasters and if you are
interested in what I tweet too
follow my twitter handle it's quite easy
to remember and my email address if you
don't remember my twitter this is a
beginners talk and it's about go passing
everything strictly by value if you have
questions I'm I can't recall but I think
that there was a reason last time that
you couldn't ask me questions during the
talk because I think it's due to the
recording so ask questions after the
talk has something to do with the record
what is passed by value all parameters
are always passed as values that there's
two paradigms the one is passed by
reference and the one is passed by value
and if you pass by value the or if you
pass by reference it's easier to explain
the the calling and the Khalif function
actually just share the same variable
and so whatever you do to the value in
that variable happens on both sides to
the calling and to call each side and
people got quite used to that in some
languages like javascript perl python
and so it's hard to see that the go
follows it actually the same that all
languages say they do pass by value but
not all behave that way and so I want to
talk about the details in in this talk
let's start with examples we have a
struct example here it's quite easy we
have the skill struct with a person
struct and we have can you read all that
is it big enough and we have a very
simple main function and it's just okay
what is this what is it going to print
output is going to be cokie has a
painting skill of two which is an
excited duration because i can't paint
at all and but this is just the
introduction with this truck we are
going
to work on so we have person with name
and skill we have a skill and we have
some main function working with that so
we now we want to increase the skill and
and this is what happens quite a lot we
have a function and we have receiving
type that can call the increased skill
and so we construct our person and say
increased skill and what is it going to
to print and for those who are new to
the language they might be astonished
that actually from print line is going
to print too so what is happening we are
constructing a person we are actually
passing that person into the increased
skill function and we are incrementing
the level printing and it says ok your
skill is now three which is increased
and but when we call print line for the
for the calling or in the calling
function we reduce to 2 again and this
is the basic idea of pass by value we
copied all the values of person into the
function did something here and the
calling function doesn't know anything
because they are not sharing the the
values or the variables sorry ok so what
can we do to fix this problem we can
pass in a pointer to a person which is
probably what most people do and it's
not a bad way I'm going to show another
way as well so we constructing a person
coqui skill is painting you know this
notation as well
and we say increased skill once again we
increment the level and now what we are
passing into the function we are not
passing destruct itself but a pointer to
that struct so what is happening the
pointer is also copied by value but the
pointer is pointing to an address of the
or
all struct so keep that in mind we're
actually dereferencing and copying the
value of the pointer so now the output
is as expected
painting three painting three there's an
alternative way to do it and you have to
decide depending on the situation what
you prefer is to have a receiving
function P person increase kill person
if you like chaining for example then
this would be so this dysfunction
because you're looking the astonished we
have a function that's called on person
called increased skill that returns a
person okay so what we do is we actually
copy this person into here and then we
increase the level of this new variable
and we return this new struct okay so
this whole thing only works because I'm
saying P equals so I'm reassigning P two
to my old P and now print line also says
painting is three yes
questions after the talk but ask now
skill is part of it is another scrap but
it's also it's also copied okay it's a
deep copy oh yeah it's a deep copy but
of course I could have implemented the
struct as having skill of being a
pointer to something so in the type
definition er you can say is it is it
skill the type skill or is it a pointer
type skill that would have been in the
in the initial slide here then I would
have said skill is asterisk skill
wouldn't make a difference in wouldn't
have made a difference because we oh
because we're copying that person
structs okay because it's it's not the
when you copy you you copy I mean okay
you think you said it's a point yes then
I would have dereference that pointer
instructor yeah it would have been this
same yeah it would have dereference this
skill yes correct yeah yeah but be
careful with those drugs
yeah yes okay good so
okay now I explained that the basic
thing and now let's that's the question
which one is going to work okay so we're
now a func main and we have a person I
still have the painting skill of two and
now what do we do we have a P equals P
set name a Hannes and so what is going
to happen when we are here in this print
line thumb anyone so what do you think
are we going to print
you can make mistakes or just guesses or
well let's do it the other way around
who thinks we are going to return cookie
or print out cookie nobody ok who thinks
we're going to print out Hanna's are
good ok said name B what's going to
happen so said name B is being called
after that's a weird Hannah snow and now
we're sitting get hood what are we going
to have printed in the next line are we
going to have Hannah's or are we going
to have casual sorry Hannah's correct
because we are only changing the copies
value ok and set names see Bella Bella
ok very good
and for the newcomers also quite good to
know and and it's quite useful in go if
you have a pointer receiver then you can
still access the fields but just
accessing them so you don't need you
could but you don't need to dereference
the receiving struck and and just set it
and go does that for you so I've I've
seen this being criticized I actually
love that feature
ok did we save this I hope we did ok so
the second example I want to give is
four slices and I think slices are
really the implementation where where
you see that the most the effect of that
copy by value and I don't know if you
all know the difference between array
and slice and so this is how you define
an array an array has a fixed size you
know exactly how many elements something
has and a slice has a sliced is actually
a struct pointing to an underlying array
and does not defined it did the length
of the array by itself you initiated a
slice with the make function so a nil
slice is always useless and you can't
work with it unless you append to it but
then a paint actually creates an array
and the slice has the advantage that you
can append to it and you can use slicing
on it and and so it's the it's a useful
implementation of array array is very
performing but slices are actually what
you see in the wild and the important
thing to note here is that slice is as
let's call it a struct with a pointer to
an array with the information of length
and capacity so length is how many
values we have actually used from that
array capacities how big the the
underlying array is so how many more
values could we just add to the
underlying array without doing
additional work like increasing the
array assigning another array so our
example again person but a simplified
person it's not so important what the
person can do with just a name field and
we have data is in a slice of person
with Frank doors and B be at okay I
think that's it
switch name and when we print that we we
get this result okay we already know the
deal from our first example from the
struct example and so let's just return
a person slice we learned that before
that always works right so what do we do
we we have data equals modified slice
modify slice returns a slice of person
wonderful and we have data we range over
data everybody know
the range so range can go through slices
and maps and stuff and returns an index
and the the element the copy of the
element itself but I now I told you the
solution already so and we say if p name
equals the search parameter then replace
p name with the replacing so these are
both strings so we want to find Frank
and replace it by turin and our initial
data array you remember is Frank Torres
beard and the output is Frank Torres
beard what happened what happened here
is we say arrange data and so we go
through each person range copies the
value of the element and if we change
name in here we're actually changing the
name of a copied element and we're not
changing the name of the underlying
array and this is actually code that
I've found two weeks ago in our code
base which is advanced so it happens it
happens especially when you switch
languages this does nothing ok I mean it
burns CPU cycles it does it does
something so okay it is copied by by
value especially careful be careful with
range and so let's fix that okay we can
deconstruct of actually returning a
slice wasn't bad what we can do is for
IP so I is an index peas the copied I'm
just I wouldn't usually write it this
way probably but I did now for for
making it more clear we range over data
and say if p name equals the search
parameter then change data I theta I so
the index of data
named to the replaced ring so why is
this working because we copied data in
here and data is a slice it's not the
array so we didn't spread the array but
we are actually copying the slice which
is a descriptor to what we said it's
pointing to an array it has the value of
length and capacity so this is what we
copied we didn't copy the underlying
array we just copied the descripting
thing and we returned data and modify
slice is actually going to be as
expected torrent or is being so clear
okay what would happen if we do not
assign it to our data so we have the
same function modify slice and from main
we called the same function and but we
do not assign it to data again what is
going to be printed yeah of course it's
a question you have to yes yeah
yeah you are correct
okay but this is this is unexpected
when you when you don't think about what
you are actually passing it is correct
what you're saying because we are still
working on the same array right it was
the pointer and we changed the pointers
value of element whatever the one that
matched it Matt okay
but this is we're getting to the next
example why this is important to notice
okay
so wise go behaving that way it's a
question like in JavaScript it's so easy
I just pass an array and I say airy push
and it it pushes to that array and if I
return I get the same array and if the
calling function has this collie and
kala have the same thing okay we said it
was passed by value and slice is not the
array slice is pointing to an array and
this is I think this is the main thing I
want to tell you actually in this talk
so it's a descriptor for a segment of an
array a slice okay and another important
thing to mention is one array can have
many slices pointing to it and they can
actually be mixed so you can have an
array of ten elements and you can have a
slice taking the first three elements
and another slice taking all ten
elements and you can have another slice
just taking the last three elements so
you have to be very cautious what you do
with your underlying data structures and
all descriptors are pointing to the same
array so even if you do slicing of this
slice you have to be careful are you
doing lazy slicing or do you are you
actually really copying the values of
the underlying array into a new array
think I'll show you another example of
that later and yeah a slice is only the
Pointer capacity and length and the
actually data is being held in the array
okay
so sounds easy but this is the again the
questionnaire part and so we have
another function called a pen to slice
and okay we've found that pattern
somehow useful we're returning slice
that that somehow worked for us in the
past and we're doing two things so first
we're passing Kim Kim named and we're
actually appending him to data and what
we're also doing is I mean this is a bit
dangerous because we can't know that the
slice has more than more than one
elements but for the sake of this
example I think it's not important and
we're actually assigning new name to the
first to the second element in the slice
so mod data append to slice what is data
what is mod data sorry
data is going to so our initial Frank
what was it Frank Frank it was Frank
Torres and Piatt what's gonna happen so
no oh yeah you're correct
yeah compiler error okay sorry for that
because I copied from code to to this
slide no we want to but it's a very good
point we want we would have written a
person person name okay sorry for that
but if it compiled so what we'd get is
actually Frank new name beard it's the
same thing with we are changing the
underlying array the initial the the
initial slice is still the same and the
initial slice has the information length
is three so it doesn't care that the
array actually holds more values but
this slice still only holds three values
and the mod data that is being returned
if it had compiled is actually longer
than the origin so I think these are
caveats where you really have to be very
cautious that stick to how you modify
your data and and don't don't trick
around with what you're doing either
copy or modify in place but don't mix
match because you're going to have
results like that totally unexpected so
rules the the behavior of goal is
extremely consistent there's whenever
you wrap your brain around it and think
about it it's a
she's super consistent there's there's
nothing that's strange about it I really
I talked to
super advanced Perl developer the other
day about this topic and we actually
came to the conclusion that in in Perl
its although Perl is a very well-defined
language and consistent we actually came
to the conclusion that this is more
consistent and more you can more count
on what's actually happening and you
really need to know the basic datatypes
so everybody says that read up the
language specification and it's hard to
read document to actually read it
correct and reread it in and really to
parse it correctly but it is
well-written and in corner cases you can
always reference it and use it to to
actually know what's happening and
always whenever you call a function keep
in mind what are you actually passing
are you passing a value or are you
passing or you're always passing a value
but is the value they pointer to
something or is it the data itself and I
mean this is true for all the languages
and is a very useful paradigm nowadays I
mean in in JavaScript we're starting to
use Rhonda and and libraries like that
where you actually you don't ever modify
data anymore you just generate new data
and pipe that out to the calling
function and I think this holds true for
go as well if you want to do something
and it's not performance isn't your
biggest issue and believe me performance
isn't your biggest issue because your
biggest issue is readability and
maintainability and bug-free actually
then don't share too much data ok that's
it thank you
easy talk</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>