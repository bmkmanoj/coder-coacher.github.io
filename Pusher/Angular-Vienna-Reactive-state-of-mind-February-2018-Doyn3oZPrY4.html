<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Angular Vienna, Reactive state of mind, February 2018 | Coder Coacher - Coaching Coders</title><meta content="Angular Vienna, Reactive state of mind, February 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Angular Vienna, Reactive state of mind, February 2018</b></h2><h5 class="post__date">2018-02-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Doyn3oZPrY4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Miroslav janosh I'm going to
talk about reactive state of mind so I'm
gonna try to help you go completely into
the reactive world and understand all
the aspects so first of all how many of
you heard about reactive axe how many of
you know wood okay that's pretty much
everyone how many of you are using rx on
daily basis during your working time
okay again quite a lot of people okay
let's try something harder how many of
you are using more than five different
operators on daily basis okay three four
five hands okay let's go even harder how
many of you can tell the difference
between these operators I don't know if
you can see it but it says fork/join
compile a tests merge and with latest
from without looking at animation okay
and finally how many of you think they
would be able to explain the whole
reactive axe to someone non-technical or
let's say eight-year-old kid difficult
right okay so let's try to understand
why is this difficult when I started
working with angular 2 it was packed an
alpha version it was driven completely
on Eric's chest this was a completely
new concept although I knew what
reactive programming was Eric says the
library was quite new to me and I did
understand standard even driven
development so we have something that
some event producer and then you
subscribe right but if you go deeper and
you go to our X J's site you see the
definition first of all definition was
something like this it's an API for
asynchronous programming with observable
streams for most people this is like
what so then if you go further you see
something like this reactive axis
library for composing a synchronous and
even based programs by using observable
sequences again
of phrases that most people don't
understand and finally our dear
wikipedia says something like this
reactive programming is a declarative
programming paradigm concerned with data
streams and the propagation of change
although all of this definition say
Qalat they don't really explain what the
reactive is and and how the operators
work and if you were unlucky enough to
go to our xj site in the early days you
would see some quite weird definitions
of operators that I'm pretty sure even
they don't understand what they wanted
to say it was quite quite hard to
comprehend what they are doing and there
was this thing called marbles marbles
were brilliant for easy operators like
mat filter but when you try to apply
marbles to something complex you
suddenly get lost you don't know where
these marbles are coming from how they
are being combined so one of the things
that's now written on the reactive ax
website is this it's a combination of
best ideas from observer pattern
iterator pattern and functional
programming now although this is not
clearer than the previous definitions it
gives us something to work with
so since I'm a backward man I'm gonna
start backwards with functional
programming this doesn't mean that the
library or the stuff you are using is
functioning so functional is something
completely different
me as you are aware functional
programming is core parts of the
JavaScript and there are different
definitions some of them say that
functional programming is the
programming where you can use function
as a first-class member in plain English
that means that function can be
parameter of another function you can
also combine functions to get some some
new function or some new object the more
important part for the functional
programming is that functional
programming tells you that each function
has to be pure function again in the
plain English that means that function
should not have side-effects there
should be one or zero or multiple inputs
and there should be there can be zero or
multiple outputs but the important thing
is that whatever comes in should not be
changed inside a function so the the
data you pass in the function have to
remain the same as they are and you can
pass something new as a result of
calculation in your function but
function should not do some side effect
like if you think about our standard
login function the way we used to do it
is that we pass in user name and
password then we do some magic called
backend check if the user is
authenticated or not and then we
redirect this V Direction is actually
side-effect because your function is
checking for your credentials it should
not redirect you should use different
flow and it's part of the way we are
used to program and how we are taught to
program so since this was allowed for us
of course we were misusing this in
different ways but once you switch to
fully functional programming it's quite
easier to comprehend because then these
side-effects don't exist anymore and
it's easy to follow the whole workflow
of your data with side-effects you never
know what happens there can be a bunch
of different situations you cannot
follow but with functional you have a
clear path so something comes in
something comes out it's simple so the
second two patterns are iterator and
observable most of you I guess heard
about Gang of Four this is referring to
for altars that created the original 23
design patterns and iterator and
observable were two of these patterns
they weren't as used in the beginning
but now with reactive programming they
are becoming more and more popular
more and more important so first
iterator pattern now this would maybe
have more sense if there was actually
pizza today but unfortunately you would
just have to assume that there is pizza
today and I'm gonna try to explain you
iterator pattern with a simple pizza
example so you can think of an iterator
pattern as a pull mechanism so let's say
our we have a pizza and this pizza is
our iterator the iterator pattern
explains that you have a collection of
some information let's call it slices
for pizza and you can take or you can
enumerate through these items until we
reach the end so in pizza world this
would mean you can take slices of pizza
until there are no more slices left so
pizza provides two things it can give
you a slice and it could tell you hey I
don't have any slices anymore so you can
come and take one slice and then take
next slice and tank next slice and at
some point the pizza will say well
that's it from me clearly enough okay
let's go to observer pattern observer
pattern is your gramma
so let's see how we can explain observer
with a grammar so in contrast to pizza
and the pool gramma is working more on a
push mechanism so what happens you go to
your grandma and you say hey grandma I'm
hungry and grandma starts creating
pancakes and you sit in the table and
the first pancake arrives and then the
second you don't have to ask for
pancakes they just keep arriving and
also
on on top of it you can do some
operators on top of the pancakes so
let's assume the substance from which
the pickings are done is one type of
observable and then you have the heat as
a second observable and then you can
combine the pen with the substance in a
heat to get a pancake and then normally
grandma doesn't make one pancake at a
time and deliver it one at a time she
creates some sort of buffer of Pam
pancakes and then when she has ten
pickings she brings it to you and then
you can use your map function to to or
scan to enhance the pancake with jam and
then map to wrap it in the bank cake
underneath it so you can explain pretty
much the whole process of making and
eating pancakes through the observable
the important thing is that it works
with a push so you just have to initiate
the stream or tell grandma that you are
hungry and she starts making the
pancakes now there are two types of
observables which you might have heard
one of them are cold and the other one
are called hot observables since I like
sushi what I'm going to try to explain
this on a sushi principle so let's say
you want to eat sushi so in Vienna
pretty much there are two ways how you
can do it you can go to a standard
restaurant you can sit there
you order a sushi then there's some a
sink weight time and after some time
your sushi arrives now the difference
between observables and promises which
is one of the core differences is that
observables are cancelable so with
promise if your sushi was a promise that
would mean that once you order you are
chained to the table and you cannot
leave before you eat it and you pay for
it but with observable you can order
sushi and you can change your mind and
say to it or hey actually I want
something else or you can just bail just
leave and who cares
the second kind of way how you can
or your sushi is go to running sushi
does is anyone familiar with running
sushi okay most of you so for those that
are not it's the place where you have
sushi as all-you-can-eat so you just sit
and then sushi is circulating around you
and you just take whatever you want
so you can sit there as long as you want
then you can take as much as you want
sushi so for this sushi you don't
trigger the event stream it just keeps
going whether you are in the restaurant
or not the sushi is there and it's going
in the round whether you take it or not
it's up to you but so she keeps running
around this is how the hot observables
work so in IT world this would be for
example mouse clicks or mouse moves or
keyboard clicks or whatever type of
stream that keeps going or like
listening to the radio so you can switch
on your your set and listen to the radio
but if you don't the radio will still be
there the broadcast is still there it's
not just for you it's there for everyone
so now I'm going to show you how to
build a relatively complex game in a
iterative world but in a relative simple
way with RX so as you can see is the
game of tetris I guess most of you are
familiar with this game so it's an old
Russian game that used to be quite
popular in 90s because everyone had
these small gadgets where they were
playing Tetris sweet but it was one of
the first oral popular games created on
computers so I did some work up front I
was cheating I have to promise
so I created something like shapes which
is the definition now if you can see it
maybe I can reduce it as well still
visible
so we have like definition for a point
definition for shapes of shape has two
dimension it's some sort of matrix it
has a block we have a random index
generator we have our predefined shapes
etc also there are some constants which
we're going to use make the colors the
keys we want to deal with so we are
interested only with arrow left arrow
right down key and space which will be
our rotation we have some definitions
here our game speed and that's pretty
much it also they are of course the core
part which is the different methods that
are modifying the scene or checking if
the game is over generating the blocks
moving rotating etc but we're going to
go back to our game so at the moment as
you can see there is pretty much not
even in the game we have just reference
to canvas it runs this method which
again doesn't have anything so let's try
to analyze what one tetris might need so
first of all I said that we defined some
keys so let's see what we can do with
those keys so we're going to define one
observable and we're going to call it
from event now let's take it here so we
say document and then we're going to say
key down and let's just call subscribe
on it
okay and now when we run this let's just
bring this console walk and now let's
try to click okay so we have our
keyboard events okay but we are not
interested in this whole object of
keyboard you and right we are probably
interested just in a code so what we can
say you say that pipe now for those who
are unfamiliar with pipe I'm going to
come back to that later but for the time
being let's just say that the all the
operators with a pipe bubble or a letter
ball operators are now organized under
pipe so it's easier to kind of
comprehend what's going on so you have
clear observable you have a subscription
and you have your methods in between so
let's say we want to take event and
we're interested in event that code now
let's see what happens now
okay there now as I mentioned we have
four keys that we are interested in so
we don't really want to listen to all of
them and we map them to this object
now if I start clicking you see that
sometimes it comes as undefined that
means that some of the events that we
are triggering are not being mapped so
we want to get rid of this right so
we're going to go filter and again
filter we want from operators and we're
gonna say he returned me just the keys
that have value okay now you can't
really see but I'm like randomly typing
on a keyboard and nothing happens unless
I hit one of the keys very interested in
so what do we have next
as a game we want game to have some sort
of natural progression like even if you
don't type on your keyboard these blocks
will still be moving and we have to make
them somehow move right so first we want
to create interval so this will be our
main mechanism and we want to say that
it will run on game speed which was 500
millisecond and again we want to treat
subscribe so we have some number and we
want to console.log it
okay now you can see it's generating
something but it's not the numbers we
want right we want key down event
because what game should eventually do
it should move this block one one line
at a time so we can again use pipe first
and then we're gonna map we don't care
about the number so we return just keys
dot arrow down so now if I run this you
can see that the arrow down function has
been triggered now if you look at these
two subscribes there are pretty much the
same right so let's create something
that would combine them together so
we're going to create one action subject
now for those of you that don't know
what subject is subject is a object in
observable Road that's both observer and
observable so you can subscribe to it as
to any observable but it can also
subscribe to something so let's pass
these two actions so now instead of go
sending it to console.log we're gonna
send it to actions and then we can do
something like this
random L
okay so when you look at the cons of
luck it's still the same right so it's
still reacting okay now what we need to
do next is on every key we need to
generate our scene our scene will
consist of the board and also the object
I can hide this now
so let's write something like this
actions and then we're gonna write pipe
now what we want to do is we want to
bring the scan function now scan
function is similar to the reducer to
reduce in array with the difference that
standard reduce only creates a response
at the end so let's say you have a array
of numbers so if you create a function
that sums it up the reduce on this array
will just give you the final number the
final result now scan does this but it
also sends the current sum in every step
so if you have numbers from 1 to 5 it
will send 5 10 3 then 6 etc until it
reaches the end so on every action we're
gonna call the method called modify
scene which I'm going to show in a
second and as our first step or as our
initial step we're gonna call generate
scene now if I go here you can see the
generate scene doesn't do much it just
takes port shape and generates the block
and generate block is just taking a
random shape setting a random color and
setting the initial starting point so
yeah one more thing so this is the
modify scene it reacts on arrow down for
example and it tries to move it if there
was a mood and it if the move cannot be
done any more than it adds the block to
the board the detects if there are some
row that is completely full that you can
remove it again on arrow left it just
moving left or moving right and on space
it's rotating so not much to it now this
is this action will will now return the
following type will return the following
result so let's see what we have here
okay so we're getting some object and
you see there's a board and there's a
block inside so instead of returning
just this object let's try to render it
so we can call something like this you
can say that next sorry
next we have our scene and we're gonna
do render scene bypassing the context
and scene let's see what this brings us
okay nice right now bear with me this we
are not done yet so okay now if I would
just pull this down quickly it's not as
fast as this could see nothing happens
they just keep falling so we have to
solve this right okay let's call this
our scene and get rid of this
okay so we don't want to run this
endlessly right ideally we would like
this to stop at some point so we're
going to again use our pipe and let's
say take while seen so this method just
checks if our game is over now if we
just bring them down quickly again this
this is not showing anything so we're
doing something wrong right so let's see
what we might be doing wrong when we are
running the SUBSCRIBE we are rendering
the scene on next
but although our observable has ended
because the take while happened
we don't really see it right so let's
check if we can render it so on complete
we're gonna say render game over and
we're passing just context let's see if
this change is something so again
quickly down
oh there it is now I don't know if you
can see it but there's some jumping
animations happening there whenever I'm
or things so it's not as fluent as we
would like to be so let's see what we
can do
now so sorry so you're gonna just leave
it as it is one thing that we want to do
we don't want to render the scene every
time we want to render a scene say 60
frames per second so we're going to
create one interval and we're gonna pass
it FPS that's my constant 60 frames per
second so that's just thousand divided
by fps
and on top of it what we want to do is
we want to reserve our animation frame
so we're going to use animation frame
for our X what this does is pretty much
make sure that you have your animation
frame request it whenever you want to
render your CPU is free to do it so
there's nothing else running in the
background
now the interval as we know returns just
a number so we need to map this to our
scene so we can use something like with
latest from and now we have our scene
observable and we have our method so the
first parameter is a number from
interval we don't really care about it
and the second is scene and we're going
to return just seen so what this does
this every time when the interval fires
which is hopefully 60 times per second
it will take the latest value from our
scene and it will send this instead and
again then
okay it's better and then we can
continue working with scenes so that's
pretty much we switched from our our
integer or our number to the current
scene we're checking if scene is not
game over we subscribe and render so see
now by the way you can rotate them of
course let's see if we can get rid of
this line okay there is one more thing
which we shouldn't forget and that's
getting rid of the observables once we
are done so as you know observables are
just the event streams and once you
start listening to these event streams
your listeners remainder so what we want
to do we want to make sure that we get
rid of this even streams when the
application is done so some of them like
this scene they don't really happen on
their own but stuff like interval it's
pretty much generating on its own
keydown event as well interval so what
are we going to do here is we're going
to create one subject which we're going
to call this Troy
and we're gonna make sure that on
destroy maybe you've seen this so this
is pretty good practice we're gonna call
next which will fire value and then we
can call this destroy dot complete
because we don't need it anymore now
what do we want to do is we want to make
sure that all of these are done so what
we can do is we can say take until and
then pass our destroy and we can do this
for intro as well this is really good
practice because then you have it in one
central place and you know that ng
ondestroy will be called every time you
close your component or destroy
component and on the other hand this
destroy will make sure that everything
gets destroyed
so here again take until this dot
so now when you look at this couple of
lines of code this is pretty much the
whole game the whole application there
are of course these helper methods that
calculate everything but the domain flow
is explained in these few lines now just
try to imagine how you would solve this
without observables so for key event you
will have some add that add
eventlistener then you will have to make
sure that you know at which point you
have to detach from this event listener
with intervals again you would have to
make sure that the interval is not
running and you have to combine in
combination of this would be horrible
you will have to keep some state and yet
this creating this hole in iterative
world would be just huge madness and
most likely you would miss something you
would get some memory leaks with Oryx
the taken till make sure that there are
no memory leaks so once you're done
everything gets cleaned up also the
important part is that Rx is by default
pure function so it doesn't mutate your
object whatever whatever observable
comes in something completely different
comes out so it makes sure that you it
doesn't change the original observable
if you create observable and then you
map it to something else you can still
subscribe to the first observable and
you would still get the original data
although it was mapped to something else
you can have two separate instances and
this is really powerful because by using
the event streams you can organize your
entire applications you just have to
think from user perspective what do I
want to do what is the user fool does
the user clicks here or does he does
this and then what happens on this click
or what happens on this input field so
once you are able to visualize these
streams then everything else is simple
then it's just a matter of picking the
right operators picking the right
observables and link
them together and the important thing is
that when you have some error or
something is wrong in the application
you can simply just follow the
observable stream and figure out what
happened with iterate boss it's quite
difficult because something somewhere it
might go wrong if you're using promises
at some point something breaks and if
everything is changed you really don't
know what happened with observables you
can easily follow so let's get back to
the presentation I promise that I will
talk about piper ball or lateral
operators so in the beginning they were
called lateral because they were similar
to existing light operator in Rx but
they decided to call it Piper ball
because it makes more sense and as you
can see it uses pipe to link the
operators together so why were they
introduced at all it came with a version
5 it's pretty much standard in a version
5.5 and this is how we started and at
least I started this way so there was
this rx
library I just took care it again
because why would I import piece by
piece let's just take everything right
and then you bundle your application and
suddenly it has seven mega bytes because
Rx is huge there are like hundreds of
operators and some of them depend on
stuff that's not even rx with bundles
again with bunch of node modules which
you don't really need so there came the
prototype patching that was a nice way
to separate the functionality so you
would take just the core observable and
then you would import operators so by
doing this you are actually patching the
observable so observable itself didn't
have anything in the new import is line
and under the hood it adds to Ajax meta
to the observable then this one acts
catch and this one adds map this was
nice because the size was reduced but
the bad thing was that it's quite easy
to forget this and we still have it this
way
in our application and we just had the
issue today with this did we just forgot
one Operator
and it's quite easy to do this because
there's no intelligence there's no UI
helping you telling you hey you're
missing this so there was then another
way this is pretty much supported by
angular team and if you look at their
code especially the router which is
completely built on top of our X you can
see that this is how they're calling it
so by importing it directly our
operators they make sure that every
operator is there and that nothing is
missing the bad thing is that JavaScript
call function by default doesn't have
type so response is any so all these
intelligence and night nice things that
type had just that type screen brings is
completely gone and this is especially
hard if you are trying to figure out
what's going on in rx if you ever try to
debug router you will just end up in
hundreds of observables going each other
and your original code is completely
gone you can't even see from where you
call this you just get lost in the
observables and this was of course pain
for debugging so that's pretty much the
main reason why reactive X team decided
to bring pipes with pipes you have the
same benefit of the call where you can
pretty much target directly the parts
that you need and instead of bringing
observables and then patching it you're
actually bringing the upper of the
different types of observables so if I
would like interval I just bring
interval which is completely isolated
part it's built on top of operate of
observable but it's completely separate
and then I can use pipes to nicely
organize my my operators and the best
thing is that if you try to debug you
can actually see the whole flow you can
track it so it's no longer mass of
different observe
you can nicely follow what's going on so
that's it and hopefully you can see this
nice video so once you learn the secrets
of rx and learn how the operators work
then doing synchronizations like this
won't be a big deal for you if you're
interested in the game itself
it's hosted on the github these slides
will be available probably tomorrow
already on the meetup page that's my
handle for Twitter if you want to follow
me or just want to see what's going on
thank you for your listening and hope it
was worth it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>