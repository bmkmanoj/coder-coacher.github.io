<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Unit Testing Is Life! - LNUG - January 2018 | Coder Coacher - Coaching Coders</title><meta content="Unit Testing Is Life! - LNUG - January 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Unit Testing Is Life! - LNUG - January 2018</b></h2><h5 class="post__date">2018-03-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/USxm8Cgr12I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm lastly by the way and I'm a cougar
neither of this meter along with Adam
and Clark II and Elly and the others I
didn't mention so when I start the
programming or unit testing
I've already understood how unit testing
can help me but in practice I didn't
really know how to do it I had no clue
how to start how to write a unit test we
had the tools we had the frameworks and
some online tutorials but I felt like
the ideas and concepts they were not
emphasized so I had no clue where to
start now that a few years have passed
and I think I've written about a few
hundred or not thousands of unit tests
so this talk is about me summing up all
of those abstract strategies that I've
learned along the way
so I guess many of us can relate to a
situation like this where by the way I
drew the slides by myself because it's
much easier to draw slides than find
images on internet it's just you get you
get into this you get into this wormhole
of googling images funny images and it
just like two hours later you you have
nothing so yes there's many of many of
us being here we're unit testing kind of
seems like it's a chore something that
we do as an addition to the
implementation rather than being vital
part of the development process I think
this is mainly because unit testing
requires a buy-in a full buy-in from the
development team rather than just doing
it doing it after we've done the
development work it also demands a
discipline to hold the test code to the
same level as the production code and
and yeah and this this can happen and I
think test after can be a bad sign not
necessarily a the the worst case
scenario but it can be a bad sign so why
do we write you need testing the first
place this is like a simple question it
has many answers but I think mainly
because we we write units so let's say
the application consists of many
building blocks we can call them units
and we write tests to prove that each
unit work in isolation so we can trust
them trust I think is the most important
yeah I know so Trust is the most
important obviously the most important
reason to write a test oh we have many
of course we have many other benefits
beyond trust what Trust gives us the the
feeling that we can reflect units
without breaking their intended behavior
so I can refactor my code base and I
know when I touch a unit that I can
trust that somebody somebody two years
ago intended a behavior and I won't
break it or if I break it I know that
I'm changing the intended behavior so
let's look at some testing approaches
where do we start I mean obviously
obviously you have to start identifying
your own units this is this is probably
the easiest one because there is no rule
for this it's entirely up to us what we
consider a unit we can consider a unit a
bunch of functions as a unit or a single
function as a unit you can consider a
class as a unit or we can take framework
provided abstractions like an angular
component or a react component and just
test that as a unit so let's say we we
have we have been tossed to refactor a
legacy code base with zero absolutely
zero unit tests so you probably go like
this
so obviously say once once we come down
and and just left the office came back
and ditched our resignation letter we
you know we go ahead we go ahead and we
try to refactor a messy ten years of
legacy code base unit testing actually
can help us the first thing we do is we
try to identify a unit and there is a
there is a really really simple rule
that can help to start the work is if
there is a unit that is if proofs so you
say this is the unit this is my unit and
it proves still proves very difficult to
test what do you do is simple you just
break it down to multiple units this is
a very simple rule but we often overlook
it break it down keep breaking it down
until you can manhandle it I can you get
a grip of it so what you need testing
aligns with I think is a few parts of
the UNIX philosophy which was UNIX
philosophies is rather aged now and it
still holds up and it goes right
programs that do one thing and do it
well also it goes white programs that
work together which will detail a bit
later and it also goes white programs to
handle text streams because that is the
universal interface obviously the last
one is the unique specific ones so we
only focus on their first two I think
I'm so fond of these philosophies that I
think is this should be the mantra of
most of the software engineers and just
rehearsed in the morning just like
religiously and stand up so okay so
let's move on
another thing that I've I've learned and
also we were discussing the same thing
in the pub there it's it's important to
try to test the behavior rather than the
implementation
self when trying to test an
implementation detail we can we can run
into problems but we can't always avoid
so units you bet first approach you need
to take in unit testing you try to test
it as a black box and the second
approach is to move on and if it's not a
black box then see what it is
the reason it's difficult to just test
the behavior it's because units interact
they were so most of the units in a real
life application most units of the
application are designed to work with
each other they collaborate so just to
say just test the behavior is not always
that easy you have to look inside and
then see what the unit is for so when
testing a unit that was designed to use
another unit another dependency then we
need to make sure that it's using the
dependency correctly and that's where
people the process of studying and
spying comes in the picture and I think
that's the most debated and probably the
weakest point of unit testing so let's
move on quickly move on to something
that is much more easier to test in
trivial when when the component under
tests has let's say branching if our
statements switch statements and so on
it's important to cover all the cases
it's easy to say but what if a unit has
many variable results too many to be
able to test this is again an example
for just breaking down the component and
making sure that the component is not
too complex
not too many variable results to test
same for data traveling the parts is
important and following your data most
of the thing most I think one of the one
of the things we web developers do is we
just massage data in and out from
different components and you need to
make sure the unit tests follow that
data so we don't lose the actual output
okay so that was just the first part of
the talk and I have some code examples I
think we covered enough and let's let's
just let me show you how what I mean
about following data following the paths
in spying and and stubbing and so on so
what I've done I've created comets of
the steps I'm going to take because I
there's no way I'm going to code it live
sorry
so what I'm using is just a simple
module that I wrote and I just need to
type next and it will give you my my
next comment so I'm using really simple
examples and I'm going to really just be
quick with this because there are two
other speakers to talk so I know most of
us here are developers so I don't I
created these examples that anybody can
follow so just let me know if it's too
basic and I just closed it down so this
is a this is a unit called get users and
all it does it gets users from the API
so I'm going to show you different ways
of testing this and then also improving
on it and adding features with the test
so yeah
all right so the first test we can write
is a really simple one and it's also a
wrong one
although it does it halfway through it
doesn't test the unit correctly so I'm
using mocha choice in and setup which is
the one I used for years and it's it's
my go to testing tools but I'll show you
some new ones later on so what I'm
testing here is if the API is getting
called so I'm spying on the API call and
I'm testing if it was getting called
with users so I'm basically testing the
contract I'm testing if my unit is using
the dependency correctly however in this
case even though I'm going to get a
green build it's not enough because the
get users what it doesn't do what it has
to do I mean even if even if it does it
we I'm not sure if it does so I'm just
gonna run the test here sorry so it's
not returning the users I mean it is
returning the users but I'm not testing
if it was really returning the users so
the next step is to check if the users
are returned
so my next iteration of the test is to
not spy but stub on the API method give
it some returning data and then check if
the returned data equals what I stopped
for so this is a highly debated part of
unit testing when you have a dependency
and you start studying it and modifying
it but really there is no way there is
another way to test it there are the
elegant ways more elegant than these
ones so I'm going to show you that one
okay just good next so this is the same
test but written with testable which is
a new testing library I'll be using and
also it's using Ava which is the test
Runner Ava assertion can be seen in DP
core and then the test double stub you
create the test double in three steps
you write a testable function so you
override
the gate function with a testable
function you use the test doubles API to
set up stubs and then you return a use
user data so okay for the next example I
thought it would be cool to add some
more features to get users because it's
very basic and people could call me just
out while you're not using API itself so
the next one just gonna give
walkthroughs quickly so the next step is
to cover some unhappy path so what if
the API returns false II data I want the
user I want the get users to return me
an empty array so I just listed all the
faulty values and I'm using Ava Ava has
a plan assertion where you can plan your
assertion numbers so if the assertion if
I assert more or less than it will also
fail the fail the test and I do the
stubbing as prior so the next so as you
can see my test started failing which
means that I need to implement it so
once I implement the five minutes okay
cool so once I implement I've just so
I've implemented a really simple
function so now I got a passing test
what else do I have here
okay so the last test I've written here
is the check let's filter out users that
have invalid and has invalid values so
I've written the test again a very
simple manner with the test double and
evil sessions I have a failing test and
then I can just go and implement it it
in the first place so here's the code
it doesn't filter users here's the next
iteration it does filter users so what
I've wrote here is a for loop
implementation I've got a passing test
but I'm not happy with the for loop
because like functional programming so
I'm going to reduce that to a filter and
I still have a passing test that's the
end of my talk Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>