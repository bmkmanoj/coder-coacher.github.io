<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Async in Redux - JS Monthly London | Coder Coacher - Coaching Coders</title><meta content="Async in Redux - JS Monthly London - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Async in Redux - JS Monthly London</b></h2><h5 class="post__date">2016-09-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9UZla3uIo3A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and we don't see is predictable state
container for JavaScript apps
it's like flux but there's only a single
store and you implement changes through
using reducers to compute the next state
of the store
so the basic Redux flow is the store
dispatch is an action or more
specifically a view dispatch is an
action by the store and Redux will run
through any middleware this is the place
where our async flows get to run through
these middlewares they get to intercept
the the action that the current state
and then do something so they can delay
they can just run let it run for you
completely then finally the route
reducers get the they received the
action and then they can compute next
state of the store you can compose
reducers in multiple ways normally you
have a reducer which namespaces are part
of your store and then after your
reducers finished the redux stores will
update with the new state tree and then
the Store updates anyone that's
listening which is typically your views
so that's basically what a reducer looks
like there pure functions which means
there's no side-effects there's a lot of
pure functions when you work with Redux
vector pretty much everything should be
a pure function except your async
functions so an action is just plain
object it must have a type and then it
can have anything else that you want and
you typically see them shortened to the
shorthand property notation where the
key and value is the same same thing
next ring Creator is just a function and
basically returns this object and that's
how you do a call that's how you
dispatch an action through the store so
async actions redux out-of-the-box will
only support synchronous actions you're
going to have to use some
where if you want to do any asynchronous
so I'm going to talk about in this talk
is redux tunc redux promise and redux
saga there are some other ones but I'm
just going to talk about those two free
so redux has the apply middleware
function which is what you use to set up
your Redux store with the middleware so
there's an example of the setting up
with a thunk ok so now we're going to go
through the individual examples so redux
thunk this is the easiest one to
understand and get your head round
because there's not that much there's
not that much new to learn about so this
is recommended and referenced quite a
lot in the readout stocks I think is
made by Dan Abramov as well you create
action creators that return a function
instead of an object so your action
creator function returns a function that
gets injected with the dispatch function
plus get state and then you're free to
do whatever you want within that
function so within this example in the
code my first bank we return the
function gets the dispatch and the get
state functions and then we're free to
do multiple dispatch calls within there
and then these these actions are treated
just like any other redux action so an
Inc more real example think here we've
got an action create Accord submit
comment which is passed in message and
user ID return our function which is
injective dispatch and get state
functions we dispatch an immediate
function to say the comment form
submitting with the message we do our
asynchronous fetch which is using the
new fetch API this returns a promise and
when that promise resolves we check the
responses responses ok then we'll go and
try and get a JSON response with that
and then if that works then we'll get
will dispatch our add comment function
so this is the resolved comment which
has a message user ID and the comment ID
otherwise we can dispatch like failures
and then it's always good to catch
errors in case of a network failure
because a lot of people miss this out so
a testing thunks typically you need to
mock a lot of things you need to mock
the read out store you need to mock the
redux mock the middleware you can mock
the store using redux mock store and
then for your async requests or any
libraries that you want to mark you can
use in on Jas or if you want to mock her
specifically HTTP calls you can use not
so there's actually quite a lot of
effort involved in testing redux thunk
and then you can see this link if you
want to see some more examples of that
so now I move on to redux link demo so i
put together a small application let me
find it
yeah okay so I basically recreated a
little tweet then Twitter search thing
you can go in and search for tweets
let's say like I don't know react okay
and then you can switch between the
searches and then if I were to search
for react again this would increase the
number of tweets that searched so I can
keep running more search searches I
could add a checkbox to do polling on
this same search and we'd get end up
getting more tweets and more treats and
they were all cached in session if I
reloaded this and this were it would
start off from scratch so I have the
plug-in called think it's the redux
debugger plug-in now I don't even I can
make this bigger
all right that's probably not that
visible one on the left hand side I know
I'll make that over there
okay you see that on the left side you
can see all of the actions that have
come through you can see I've got an
action called search for sweet started
this is the thing if I click the search
button it's going to show that there's
an active search running and it or
disabled a button and then we have an
event for success which the action for
this success event gives me my tweets
let's just have a look at that in the
code
alright here are in the editor now for
Redux thunk what you're doing is you're
creating your asynchronous action
craters so this is the one that we're
interested in here
it's called fetch street wearing
interest in the dispatch function we
dispatch the search for tweets are
started with the search text and then we
call API search and then API is just
some little library that does just wraps
a lot of their fetch logic this
internally is using a Twitter proxy
which just means it's something that
runs in the background at this URL which
means I can make requests to this URL
which is localhost at this port without
having to go through all their Olaf
stuff you need to do with Twitter so
back to actions okay so when this this
API search returns a promise which Rin
resolves we're given the tweets and then
we need to spatch search for tweet
success and the reducers for these
there's two or three reducers but you
can see at the root level we've got
tweets and we have searches here's where
you handle all the started success error
and all of that and then when we
actually got some tweets the tweets part
of the state we're just interested in
this event and creating an object this
is not not an array of tweets we're
creating an object so that it can index
by the tweet IDs because that's useful
later on especially in big apps and so
that's the reductant demo so praise for
readers funk it's easy to understand
easiest to understand from my opinion
out of all of the ones that are on offer
there's plenty of documentation loads of
tutorials and you code it all so there's
no magic involved which is why it's easy
to understand cons it can get quite calm
kated quickly you have to resolve
promises and handle those yourselves and
it can be difficult to test because
you're going to have to mock a lot of
things right now we move on to redux
promise so this is what they call a flux
standard action compliant promise
middleware for redux which is very
complicated but basically it's just
saying your actions have to have these
type of things so you need the type
which is common for all redux actions
you specify a payload field the payload
field can either be a promise it can be
the day that's resolved from a promise
or the error from promise error which is
an optional boolean flag and then meta
which is where you stick everything else
there's also reduction promise
middleware which is a better version
than redux promise it has like you Billy
to have pending actions and allows you
to give post fixes to your actions so
for instance we've redux promise I want
to go and say fetch something I'd set my
payload to API fetch something and then
what the reducers would receive is
eventually an action that has the
payload with the fetch data or if
something went wrong a payload with the
error and error flag set to true so this
is basically just what I said you set
your action payload to be a promise the
middle way is going to intercept your
action check for a promise as the
payload and then wait for that to
resolve or fail before it passes it on
to the reducers so if you're successful
payload will be the result the promise
and if it fails in a beedi error right
here's a more complete example if we
were like posting comments so here I go
to do a post on my API comments endpoint
and that's the body it's a response is
okay then we'll try and resolve and
return the actual comment that's
returned from the network request
otherwise we throw these errors and then
here's the action crater that
corresponds to that
API requests and in Redux promised demo
and SKU to here
right so this is just the same thing
just in code again we've got fetch
tweets action but this time the API the
payload is in the API search function
that's caught and you can see it resorts
the same way in here if I open their dev
tools again just put that on the button
search for react those are gone okay we
get search for tweet started and then
search for tweets but now this time
search for tweets has the payload as
being actual data and there's no error
filled by us to go and stop this Twitter
proxy thing from running and then do
like another search we get fail to fail
to fetch so here we've got the same
search for tweets started again action
and in the same search for tweets action
that's pass through but this time there
is a boolean that says there's an error
and the meta contains the era the sorry
the payload contains yeah although you
can't see a mu and then finally okay
pros and cons of the redux promise this
is quite easy to understand it can can
result in less boilerplate code and you
get simplistic action creators however
there's this has the least amount
documentation to it and it also assumes
that you're going to use some other
library like Redux actions and you may
even still require Redux thunks so my
opinion it's not that we're not really
worth pursuing
and if you were going to go down Redux
promise route you're better off with
free ducks promise middleware which does
things like slightly better as I said
you can have like the actions with the
suffix that tells you whether something
is an error or it succeeded that's all
and you also get pending actions for
free
so Redux saga this is the one I prefer
so the only thing to really understand
about this is you need to know
generators it uses generators to handle
your asynchronous flows but the
advantages you get so you get code
that's really easy to read you can
understand what's going on what's
happening in an error case and what's
happening in failure
and best way to think of them is like
they're kind of like background daemons
to handle some asynchronous process you
create a you can have a saga that's
watching for something in the background
and then once you get an action it can
go and start doing all the work in the
background and dispatching actions as
usual and you can compose sagas as well
sagas can call other sagas but you
normally trigger saga on some action
that's dispatched by the store so the
middleware controls the flow of the
sagas and generator functions yield
objects to the redux saga middleware
this is probably not going to make much
sense unless you understand how
generators work so it's definitely worth
doing some tutorial videos if that's not
familiar for you so if there if you
yield a promise in one of your sagas the
Rios middleware will again wait for that
to resolve and then it will pass back in
the resource state of the promise or a
failure there's lots of helper functions
that can control what the middleware
supposed to do next so you can serve it
to like dispatch in action wait for a
despite tection you can call a function
and it can allow for pretty complicated
flows this is the one of the the biggest
advantages is it's quite easy to write
tests for the flows we've a little - no
mocking because we in most cases if
we're testing our asynchronous flows
we're not really and we don't really
want to test an API library that's just
checking
if API library works there should be a
separate unit test if you want to test
an asynchronous flow you just want to
check that your flow is dispatching the
right actions at the end so this is an
example saga so you've imagine I have an
API and which is same api's before we're
using some help functions here like take
every call and put and describe what
those do in a minute
so this is our main saga to go and fetch
products so in this case we're wrapping
this in a try-catch block and we're
yielding a call this is the call
function that's up here we're saying
redux aria please call this function we
have these arguments and this API fetch
is going to go do the fetch for products
redux oil will wait for the promise to
resolve and it will inject the results
of that back into this line so this
yield call gets eventually replaced with
a value which is the result of this call
then after we've got our products we can
dispatch products received and then in
case there's an arrow down we dispatcher
failure this is a watcher saga where we
use or take every helper function this
is saying to redux all go we yield this
and this event and this action is
dispatched by the store then run this
saga so every time this event dispatcher
is we start this saga and then it runs
and then same thing we can have that for
create product and then watch create
product and then what you have is your
route saga which is where you start off
all of the Watchers basically so here in
this fort call we're just basically
saying start these two watches which is
watching for this action and then that
one's watching for something else now
this is the example from the
documentation about how you'd write
tests for these sagas
so here we're using call input
so call is the function that goes and
say is Redux I'll call this function for
me now input is a helper function that
says reared up saga go and dispatch in
action for me put this action for you to
store so if you're writing a test for
this saga we create an instance of the
saga so that fetch product example from
before we're just basically calling it
and remember this is a generator
function generate functions return an
iterator that you can use to step
through all of your yield statements so
our first test is saying iterator an
x-value which is the first yielded
statement is supposed to equal DP equal
to this now you look at this line this
is saying this is a call statement the
same call statement that we have from
the Reducto functions which saying call
API fetch products and the reason you
can do this is because call this call
API fetch products is just like an
action create itself it returns an
object it's not actually doing anything
it's an instruction that is being sent
to redock saga to say go do this so from
the first step in this function we can
assert that it's an instruction to go
and do this and then we can do is then
create a fake response you tell it to
step through the next one passing in the
products and then you assert that your
async function and asynchronous flow has
dispatched the correct action which in
this case is supposed to be a put
statement Rama put statements are saying
dispatched in action and so here we're
setting dispatch that we've received the
products and these are the products we
received that's why it's so easy to test
sagas so last step just kind of
redundant part here it is in search for
react again and I get failed to fetch
because I stopped thing running
oK we've got something and then finally
here is all of the requests now there
are lots of helper functions that you
can use in them Redux Redux saga you
just open one of them
okay now you notice that our actions
file has only the synchronous actions we
have no funny actions here going on
these are all pure functions what you
have now instead is a file called sagas
which is very put all of our
asynchronous sagas in this example we've
got fetch tweets as our worker saga
again we're doing the call to search we
dispatch the successful with the tweets
or if there's an arrow then we dispatch
an error and then we have a watcher for
what searching for tweets now you notice
on this line of using take every which
is saying listen for every every type of
this event so I'll just clear out the
events here and then just click this
light three times and go back see we got
free requested and then free success so
it went and run all three of them
there's an alternative to that which you
are coming out this line and put that
one on this is take latest which is
saying instead of doing take every just
take the last action and process that so
the previous call every time one of
these events all every time one of these
actions gets dispatched it's going to
start your worker saga and wait for them
to finish in this case take latest we'll
do the same thing but it's going to
cancel any previously running sagas so
the handler for this one will be
cancelled and it should only do the last
one so they do the same and do like rat
free searches see now we've got the free
requested actions and then only one
success which is what you want and they
have other things like that
which I won't go into too much detail
right so it appraised for Redux Agha
this has a lot of documentation and you
actually end up writing a lot a lot less
code as long as you've wrapped your ate
API calls into some sort of promise and
library
dating flows are very declarative easy
to read you can handle pretty
complicated scenarios and they're easy
to test cons is you need to understand
generators and it has a steeper learning
curve so each of these proaches got
their own pros and cons and stick with
what you know some of them you
especially Redux promise you might still
have to rely on redux link but I would
just I would recommend spending the time
to learn learn generators and give rig
up redux auger ago and then if you use
rxjs you might want to try Redux
observable i'll admit i have not looked
at this all and but from the docks it
says it's pretty similar to redux saga
except you work with an observable and i
know one one final tip isolate your api
test from your async flow tests that's
what Redux AAG is really good for so
here's if you want to learn more and the
gif isn't playing but it was a cat who
goes behind the back top that's it I'll
put a link to the slides on their meetup
page</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>