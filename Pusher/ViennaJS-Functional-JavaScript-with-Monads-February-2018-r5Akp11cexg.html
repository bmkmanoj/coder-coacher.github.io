<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ViennaJS, Functional JavaScript with Monads, February 2018 | Coder Coacher - Coaching Coders</title><meta content="ViennaJS, Functional JavaScript with Monads, February 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ViennaJS, Functional JavaScript with Monads, February 2018</b></h2><h5 class="post__date">2018-04-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/r5Akp11cexg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm gonna do sort of a follow-up to the
previous talk this is going to be
functional I have my let's call it a
presentation for the sake of the
argument in ten slides which are 10
different files and I'm going to show
you how to take the classic Gela script
array methods and make them more
functional some sounds interesting yeah
all right so to talk about functional
programming we have to talk about things
that are not functional so let's take a
classic example and you'll see that we
use the same example in every single
thing so we have an array of 10 numbers
in this case we have to say ok an output
array is going to be an empty one and
then what we want to do is to take every
single thing in that array and double it
so back in the days in my case it was
actually days before I actually knew how
to code we had to do four loops so you
had to say from four we have to define
the variable that we use for that then
it has to be smaller than this and it
has to go up and it's just so much so
many things to write then you have to
say ok we have to have that output array
defined and then we have to push
something into it and then we have to
ask for that input array on that
specific nah-nah okay same thing if you
want to filter for something let's say
that we have the array of 10 numbers and
we only want to get the even ones same
thing but in this case we have a
predicate
if the modulo this is a bit of math but
it basically returns the even numbers
okay but these days we can do it a bit
smarter we have the array methods so we
can take the input array and we can call
a map function
and what a map function does is it takes
the item in that array one by one every
single piece of that array and does
something to it in this case it returns
times two so if I try running this one
it gives me the array x two can you see
these small numbers in the back yeah
because that's actually no way to make
those that phone bigger all right same
thing if we want to filter something we
have a function we have a method on on
the array prototype called filter and it
takes a function that returns the
element into the output array if it
meets the predicate pretty simple what I
love the most about this is that it's so
semantic just compare this code to
I know what's happening and at first
glance in this case I even have to work
filter highlighted it's not amazing
now imagine if you're reading something
very complex and you have nested loops
and and everything just turns into a
mess all right
so again all right now let's take it a
bit further and let's say that we want
to do multiple things at once so we want
to take the input array we want to take
only the even ones then we want to
multiply them by 2 and then we want to
return only the ones that are less than
10 in this case this is going to return
4 and 8 and this is where the first
problem with these things start these
are very easy to read but if you imagine
that you're dealing with a ton of
data and you're dealing with something
very computational heavy then you're
going to start in running into problems
because what actually is happening in in
this case is that after
every operation we create a new array we
put every single thing in it and then we
take that array and we process the next
one and I found this amazing
illustration of it which is sort of off
so this is what's happening one piece
after another through every single
operation so these bits are the
operations that we want to do and the
array items are moving through them now
this is not really something we want
because we only interested in the
outcome here we don't really care for
these arrays in the middle and if you're
dealing with something that's memory
heavy then you're gonna start running
into issues because what you actually
want and it is actually cached because
what you want is you want to have that
item go through every single operation
you want to have done on it and end up
in the array this is amazing
illustration this is just so much more
efficient now you probably don't run
into issues like this when you're
running something on the client but
let's say that you're running your
back-end in JavaScript and you're
dealing with a lot of data you might
want to think about these things so in
order to make this thing even more
functional we have to understand a bit
how these things actually work so we've
talked about two methods on the
prototype we have to filter and we have
to map we also have a third one which is
called reduce now reduce is a bit of a
mindfuck to to understand I remember
struggling with it since my very first
days of seeing it and I wouldn't still
say I fully understand it thank you very
much for having me giving the talk so
what reduce does is it takes two items
it takes the accumulator which i think
is a terrible name I like calling it the
current value like this is what we have
in this current iteration of going
through the array and then we have the
item the current one that we're dealing
with and in this case
hey so have a look at the same thing we
did before mapping it to the twice the
value in in the array so in this case we
can be a bit smart cuz I run a modern
note and we can say okay return me an
array return into the array everything
that is in the accumulator everything
from the previous values this is what
these three dots do if you don't know
them highly recommend it it's called the
spread syntax and it saves so much
typing and then we just say hey after
all of these items do the item x -
another important thing for reducing you
need to say what we want to reduce into
so in this case since we want to get an
array back we have to say if start with
an empty array and the same thing if you
run this we get all of the numbers
multiplied okay same thing for filtering
in this case we only return the item
into the accumulator if it meets what we
wanted to meet if not we just return
what's currently in early move to the
next part of the array make sense
because this was the easy part
now let's talk about abstracting the
reducing the reducers a bit so we have
seen two operations one for mapping
which takes a function ya have to go up
which takes a function which just some
sort of a transformation in our case it
was multiply the item by 2 and it takes
a reducing function which our case was
the added into the array but what you
can do with reducers are many other
things you can say that I want to get
the sum of all of these things in the
array for the sake of this presentation
let's just say that we want to get the
array back with some
sort of a transformation now then we
take the accumulator and the item again
you've seen this with the with the
reducer signature and then we return the
reducer and this is one of the first
mind mind foxfox I might say because
they sort of reduce on themselves and in
there we Ritter we say call it with the
accumulator and transform each of the
items now what this does is the map
you've seen before with one difference
we can say that we want we the reduction
the reducing function can be whatever we
want it to be and this is something
that's going to come in handy a bit
later now same thing for filtering these
helpers only take the reducing function
out of that reducing function now this
allows us to do something like this if
we want to do the map if you remember we
can just say hey reduce it with doing
the mapping with this accumulation so in
this case it's very easy to use this
function signature to say hey I want to
map everything and then reduce it
differently not by adding into but into
an array but let's say summing it so it
makes sense do you see the difference
yeah I thought this is going to be the
difficult slide so if we try running
this it produces the same thing just
written slightly differently because
we've abstracted some parts of the
things that are written in it out it
still returns double everything that's
in the original array now we can do the
same thing for the filtering so if you
were on this it only gives us the even
ones same thing just like you get it out
of the browser
modern browser but this is where the
interesting part comes in because what a
reducer is it takes the accumulator and
the current value and it returns the
output the current state with the input
is the output which means that we can
say the mapping will do the filtering
and then this will return whatever we
want it to return make sense yeah all
right so if you run this we get the same
thing multiply everything and then
return all of the even ones which in
this case everything's even if you
multiply it by two but this is important
because this would be already called a
transducer because it's doing because of
the reduction it's doing these two
operations at once in this case there is
no intermediate array created remember
this one we're already doing this we're
not doing this where was the previous
one you're not doing this we're doing
this the problem is this is terrible to
read and imagine if you have multiple
ones and you want to do ten operations
if you've ever been in the callback hell
in JavaScript this is sort of similar
similar idea of it so what we have what
we have to do is we have to figure out
how to and this is going to sound funny
how do you reduce these things through a
reducer is the one of still around thank
you so we have to reduce these through a
reducer to make them more readable which
brings me to this slide so we have the
same helpers we had before the mapping
and the filtering they just got a bit
shorter because you can write things a
bit more terse
and we have a new one and there are two
returns in that function I'm not going
to go in depth in how composing
functions work the important thing we
need to know for this example is that
compose works backwards so in this
example we were saying first filter then
map and then filter when are we doing
composing we have to do it backwards or
we don't have to do it we have to write
it backwards if you're interested in why
I think you would be the perfect person
to ask
alright so let's make it a bit more easy
to read so we take this thing called
transform acts form because it's shorter
to write and we take the output would be
the reduce of the transform because we
already have it figure out we already
have it defined through the compose
function and let me do the same thing
take the take the accumulator take the
item and return whatever in them now if
I have everything properly commented out
the output is wrong somewhere output
it's not defined it should be now yes so
we get the same output now again this is
the journey to understand how it works
so my last slide is the miracle that
happened so we have all of the helpers
we have before again return in a terse
away and now we add a new one which is
finally called transduce because this
talk about transducers and the signature
of the transducer is that we take the
transform the reducing function the
initial thing that we want to transduce
reduce into do you get the idea
transform and reduce transduce
it's a great pun and the input whatever
we have to give it I sort of don't like
taking the input as the last one but
this is the way it's done in functional
things and then again it returns the
input reduced through this and that if
you have any questions about this
probably ask me after because I would
have to go through all of those slides
again but ultimately what it allows us
is say ok so the transform we want to do
is the same one we did in the chaining
method so you you had filter and on top
of that you had the map and on top of
that you had the filter in this case we
compost we compost written upside down
in this case and the output we have full
control over it so we can say hey we
have we want to have this transformation
we want to have this reduction and again
this could be summing or any any other
reduction you can do we want to do it
into an mtra and we want to do it on
this and if I run this and this fails it
doesn't so it gives me those four and
eight all of these all of the doubles of
the array that are less than 10 now the
reason I'm telling this this was the
last slide the reason I'm telling this
is if you don't care about why it's
doing it if you don't care about
anything between say 2 and 10 you don't
have to there libraries that do this if
you like black boxes if you like to get
the output go for it
there's nothing wrong with it I like to
dig in and I like to understand why it's
happening and I think it's fascinating
that's it any questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>