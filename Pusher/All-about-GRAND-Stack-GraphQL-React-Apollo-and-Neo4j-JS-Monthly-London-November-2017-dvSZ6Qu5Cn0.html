<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>All about GRAND Stack: GraphQL, React, Apollo, and Neo4j - JS Monthly London - November 2017 | Coder Coacher - Coaching Coders</title><meta content="All about GRAND Stack: GraphQL, React, Apollo, and Neo4j - JS Monthly London - November 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>All about GRAND Stack: GraphQL, React, Apollo, and Neo4j - JS Monthly London - November 2017</b></h2><h5 class="post__date">2018-04-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dvSZ6Qu5Cn0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I want to be talking about full stack
development with the grand stack which
is graph QL react Apollo and VG database
so my name's will I work at near 4j
which is an open source graph database I
don't work on the the core engineering
team for near 4j instead the the team I
work on build integrations so making
sure that you can use neo4j with your
favorite web development framework that
you can move data back and forth from
different data processing frameworks
tools like that and so what I'm going to
talk about today is largely the the most
recent integration that that I've been
working on which is a mere 4j graph QL
integration which makes up a big part of
the of the grand stack but if you get
bored while while I'm talking you can go
to bit dot Lee slash graph hacker and
there's a little challenge there
basically it will take you to an Apollo
launch pad which is a tool for building
a graph QL service in the browser and
there's just a couple of steps to follow
basically just connect connect that
launch pad to a hosted near 4je instance
and get the graph QL service working and
then just tweet us about it and we'll
send you one of these cool new everyday
graph QL hacker t-shirts you don't have
to do it while I'm talking you can can
do it later too cool so uh so what do I
want to talk about well I want to talk
about this this idea of the grand stack
so these these technologies that we can
use together to build to build full
stack applications because most of most
of our developers I want to talk about
focus on the how we do this so we're
gonna go through go through some code
samples of how we can build a full stack
grand stack application but first of all
what is the the grand stack what are
these components so the first component
of the grand stack is graph QL how many
people have used graph QL
at all okay cool so that's maybe like a
call that like two-thirds of the
audience so graph QL is this new
paradigm for building API is it's an
alternative for building REST API is
it's very focused around a schema
definition so we start by defining a
schema we define the types that are
available the fields available on these
types and then we can select from this
schema the client which fields we want
in our query the other components are
say the next component is reacts how
many people use react okay that's that's
a lot of folks cool so as you all know
react is this this javascript library
for building user interfaces for the web
native VR very much focused on on
components that encapsulate data and
logic and then we have Apollo how many
people have used any of the Apollo
tooling a few folks yeah so Apollo is
not just a single tool Apollo is instead
a suite of tools for working with graph
QL
so you see Apollo show up both on on the
client side with things like Apollo
client and then also on server side
tooling for building and graph QL
service things like performance
monitoring and mocking so when we say
Apollo in this example today we're going
to look at the Apollo clients
specifically the react integration for
Apollo client but really there are lots
of different Apollo projects that help
with we're going to graph QL throughout
the throughout the stack and then the
final components is an infant a database
how many people have used near for J
okay okay a few so near for J is is a
native graph database what that means is
that we use the property graph to store
model and queried
as a graph so nodes are the entities in
the in the graph relationships connect
them we can store arbitrary key value
pair properties on nodes and
relationships we use the the cipher
query language or working with data in
Nia for J you can see a an example at
the bottom of the screen there and then
we have client drivers in lots of
different languages for working with me
or for J so in the example today we'll
be using the JavaScript driver for near
for J well so those are the individual
components of the grand stack how do
they how do they fit together well let's
look at a simple example let's consider
a super simple movie search and
recommendation web app so what are the
the requirements for this well user
should be able to search by title and
then view some movie details for any
matching movies and then we also want to
show personalized recommendations so for
for this movie that a user searched for
what are some other movies that user
might like and if you're familiar with
graph databases this kind of
recommendation query is really easy to
express in a graph so if you've if you
use Amazon or e-commerce things people
who bought this also bought this for
movies
someone who viewed and rated this movie
highly also rated these other movies
highly that's a simple example we can do
much more complex things but that's the
general idea okay so with that sort of
that application in mind how do the the
piece of the grand stack fit together
well we have react on the front end the
user types in their movie river runs
through it hits search and the Apollo
client integration in this case sends a
graph QL query to our graph QL service
our graph QL server has logic in there
to query our neo4j database to look up
movies by
and that data comes back to Apollo
client the react integration for Apollo
client binds the graph QL query result
to the props for our view for our
components and and the view is rendered
okay so that's that's how those pieces
fit together let's look at that in a bit
more detail starting starting at the
data layer so starting with with neo4j
so since since I everyone is familiar
with me here for J I want to spend just
a little bit of time talking about what
is near for J and I think the best way
to explain something is often in the
form of a tweet
so here's near for J in 140 characters I
guess I could redo this in 280 now but
so near for J is open source software
that stores in queries data as nodes and
relationships using the cipher query
language with index free adjacency okay
so there's there's a bit going on there
let's dissect that a bit so first of all
India for J is open source software all
the codes on github we can we can go
build it from source we can we can
download it we can use the docker image
for Nia for J so lots of different ways
to get near forge a new everyday is
primarily a database so focused on
modeling storing and querying data so
when we write some data tenir for j its
durably committed to disk near for j is
not just an in-memory processing
framework it's it's very much a database
okay so it allows us to store in query
data as nodes and relationships so we
said that nodes these are the entities
or the objects in the graph and
relationships connect them so
relationships are first-class citizens
in the data model and we can store key
value pairs so properties attributes
both on nodes and relationships
and if you look at this this data model
this might look somewhat familiar if
you've been following the news recently
so this is the data model from the
Paradise Papers data leak so this was
leaked data from in this case a law firm
in the Bahamas that had lots of
information on rich people that had
connections to offshore legal entities
and the the data journalists that were
working with this leaked data they use
near 4j to make sense of the connections
to these offshore legal entities and and
this makes sense if you think of a
person who has some shareholder interest
in a legal entity that is the
beneficiary of another legal entity that
is a shareholder in an offshore trust
and things like this where there's a
very long path to get to the ultimate
beneficial owner so that kind of data it
makes a lot of sense to work within a
graph so we we model store and query the
data as nodes and relationships using
the cipher query language so here's a
cipher example and this this again this
is querying the the Paradise Papers data
set so this is saying find addresses in
London find all of the officers so in
this case the people find all of the
people with addresses in London and then
for those people find all of the legal
entities that they're connected to so
you can see that cipher is very much
about pattern matching in that first
line in the match statement we're
defining a graph pattern so we define
nodes within parenthesis relationships
within brackets and we're basically
traversing the graph to find paths that
match this pattern of people with
addresses in London and their
connections to offshore entities and if
we run this in your browser we get this
graph visualization okay so these are
all of the people the addresses in
London that have
of connections to offshore legal
entities from the Paradise Papers and
this is useful to sort of see where
there are some highly connected clusters
we can see a couple of connected
clusters there there's something
something interesting going on there
someone that has lots of connections to
legal entities okay that's interesting
but oftentimes the answer to our
question is not a graphical ization
maybe it's the result of of an
aggregation or maybe it's tabular data
so we can modify our query slightly to
ask a different question in this case
we're saying okay for all these people
with addresses in London that have some
connection to offshore legal entities
what are the most common jurisdictions
for those offshore legal entities so for
people in London where do they like to
hide their money offshore
well Bermuda is the most common offshore
jurisdiction followed by the Cayman
Islands Mauritius is on the list as well
so the point there is just that graph
queries are not just about graph
visualizations we can do sort of the
same things that you would expect from
other query languages like sequel and
that kind of thing
ciphers part of the open cipher project
so it's an open call and wa jet is
implemented by other databases other
processing frameworks we can use cipher
with spark for example okay so back to
our tweet so neo4j
open source software stores and queries
data as nodes and relationships using
cipher with index free adjacency so this
last part index free adjacency is an
important performance characteristic of
graph databases what this means is that
when we Traverse from one node to any
other through a relationship that we're
connected to we're not doing an index
lookup that means that the performance
then of a local graph traversal is a
constant time operation it's not
dependent on the overall size the data
so our query is on a data set of you
know a few million nodes
then can scale to one with several
billion nodes so we can scale these
queries to very very large datasets this
is a really important performance
characteristic of graph databases it's
very different from other types of
databases okay so that was my near for J
in 140 characters overview if you're
interested in playing around with me or
for J or that paradise paper is data set
as well new everyday sandbox is a good a
good example of a way to spin up near
for J incidents with some different data
sets they're hosted on AWS with some
example queries you can can play around
and get started
ok so let's take a look at at some data
in near for J since we we said we want
to build out our movie recommendation
app and I said we were gonna look at
data about movies and and user ratings
but but I lied instead let's look at
some data about Russian Twitter trolls
so so again if you've been following the
the news at least this has been been big
in the US I think in Europe too but
there's been investigation into Russia's
meddling with the u.s. election
especially through social media and so
twitter twitter released a list of 3000
screen names that are tied to russia and
then promptly suspended those accounts
which deleted all of the tweets from
Twitter calm and from the Twitter API so
you can't really figure out what those
3,000 Russian trolls were tweeting about
but I I found some of them on Internet
Archive so I scraped in our archive for
all the tweets I could find by these
Russian trolls and put them in here for
Jay so here's the here's the schema that
we have so we have we have a tweet a
tweet
was posted by a user so user posted to
tweets then we have hashtags
we have URLs that the tweet might
contain oh and then I also ran some some
simple natural language processing like
Kennedy extraction to find any any
people organization or locations that
any of these tweets mentioned so let's
look at look at an example query so for
one user this is ten underscore GOP so
this was an account that was intended to
look like a political party of the state
of Tennessee in the US but was very much
not so we can say okay show me all of
the tweets posted by this user and that
have a hashtag and show me all of the
the hashtags for these tweets and we can
get back sort of this sort of
visualization so here's the user it's
posted post some tweets so here's
something about civil rights that Trump
is taking away we can see some of the
the hashtags that are used we can see
here that here's several tweets from
this user that that used the hashtag
Barcelona so we can sort of get an idea
of what what this account was was
tweeting about and we can we can run
queries over the the full date dataset
so this one is interesting what are what
are the most common hashtags that are
used and for some reason that there's a
lot of a lot of tweets that we captured
in German targeting I think things going
around around miracles re-election in
Germany we can also look at the hashtags
used together most frequently which i
think is also interesting and again we
get a lot of a lot of German tweets
there okay so that's the that's the data
set that actually want to work with
instead of instead of movies so
keep that that data set in mind and
we'll talk about how to build a graph QL
service on top of this so so first of
all let's talk a little bit about about
graph QL so we said the graphic QL is
this new paradigm for building API is
it's not really a query language for a
database necessarily but instead it's a
query language for API so it's a way of
specifying data and then querying the
data but it's limited support for what
we would think of as queries like
there's no support for aggregations or
filtering things like that and then
there's also a big community of tools
built around graph QL so graphical which
we'll look at in a second is this sort
of in browser IDE for working working
with graphically well we already
mentioned mocking and performance so the
the schema is really important in graph
QL it defines what data is available and
then a client for any given request
selects only the data that that the
client is interested in from the schema
and this reduces then the amount of data
that Scents sent over the wire and it
also allows the client to pick the data
it needs to render a particular view and
these were the the two reasons that that
Facebook created graph QL originally it
was to be able to render a view with a
single round-trip request and to reduce
the data sense sent over the wire so
this was particularly Facebook's native
apps over slow networks where this sort
of network latency is really obvious
when you have multiple requests to
render a view graph QL also makes this
this observation that your application
data is a graph and we'll come back to
this in a minute because this thing this
is pretty important so here's a graph QL
query we're looking up a business by ID
and then we're specifying some fields
that we that we want to grab okay so
what's the the graph
piece of this well graph QL makes this
observation that your application data
is a graph sort of irrespective of how
we store that on the back ends but when
we're talking about our application data
in the clients that that's a graph and
we're traversing it with graphic QL so
we're starting from the business within
seeing okay what are the the categories
connected to this business okay for
those category objects what are the the
name property associated with that and
so on so we're traversing traversing
this graph and we get back get back our
results notice that the the shape of our
result matches matches our query because
those are the fields that we specified
that we're interested in so this this
observation that your application data
is a graph is interesting because it
implies then that if you're not using a
graph database on the backend if we're
using a relational database or a
document database then there's some sort
of mapping and translation that has to
occur from our application data graph
graph QL to how we're storing and
modeling that data in the backend let's
take a look at graphical so we can sort
of see our data being queried live so
here's graphical this is sort of this
this in browser IDE for working with
graph QL and this is querying the the
neo4j database that I have running so
let's just grab the first three tweets
or requiring for hashtag politics
finding the first three tweets grabbing
the text but we can also see all of the
other hashtags in the tweet and so on so
you can see how our response is changing
as we're adding adding more fields here
skip some of these slides and talk about
how we build a graphical service so so
the first thing we do is define a schema
and then we define resolver functions
that define how we fetch data for that
schema here's our movie schema but let's
take a look at our Russian Twitter troll
schema looks like this so we have it's
pretty simple we have three types we
have tweets we have a user we have a
hashtag and we also have a link and you
can see the fields that are available so
we have so a tweet has has a text it has
a permalink and our fields can reference
other types so a tweet has an author
that's that's a user here and then the
other important thing that we define in
our graph QL schema is the entry point
for our graph QL service so here we have
two entry points so these are the the
queries the graphical queries that we
can run we can start by looking up hash
tags by by tag or we can do tweets by
text so search the text of tweets to
find tweets and we define we define our
schema using this schema definition
language which is this sort of language
agnostic way of defining a schema okay
and then we said our resolver function
has the logic for fetching fetching that
data so this is what a typical resolver
function looks like where for our entry
point we define how in this case a
cipher query to look up a movie by title
but then we have some other fields that
that's not resolving so things like our
recommended movies so we have to have
another query to find our recommended
movies our genres are in another another
node so we need to have another query to
find our John Rose so if we end up with
a non-trivial graph QL query what we end
up with are lots of these different
queries that are multiple round trips to
the database
so we end up having to batch these for
performance and this is typical for for
really any graph QL implementation so
what we wanted to look at where as well
could we build a new your geographic QL
integration that offers some some
developer productivity benefits really
implementing those resolvers seems kind
of tedious we're just sort of writing
cipher queries there and if we do this
with a relational database for writing
sequel or we're writing our RM queries
so is there a way that we could
translate graph QL to cipher and then
not have to write those resolver
functions and then would this give us
better performance because we can just
generate a single cipher query so that's
one round-trip to the database rather
than having to batch a bunch of queries
and then could we expose cipher through
graph QL because if graph QL is somewhat
limited and support for projections
aggregations so these are the things we
wanted to want it to explore and so we
built what we call near for Geographic
qlj yes which is a integration for graph
QL linear for J that basically takes the
graph QL schema and uses this to drive
what the neo4j
data model should be which then allows
us to translate arbitrary cipher queries
- I'm sorry arbitrary graph QL queries -
cipher and what this means is that for
any any given graph QL query there is
just a single cipher query so a single
round-trip to the database in here for J
has a very smart cipher execution engine
so those end up being being optimized
pretty well and then we can also expose
cipher in graph QL with a cipher
directive so in our schema definition we
can annotate any of these fields so this
is a this is a field called similar on
on our movie type
so we said we needed to generate movie
recommendations for a movie
so this fields similar in this case
we're just looking for movies that have
the same genre but we could have a much
more complex query there looking at user
ratings or something that and that done
becomes a computed field so that's this
idea of the the cypher schema directive
and that still is just one cipher query
that we are are able to generate that
computed field essentially becomes a sub
query in our cipher query ok so we
thought we thought that was was pretty
good and if we if we take a look here
this so this is the graph QL server
implementation that I was hitting when I
was running graphical here so my Russian
Twitter data and this is the only code
to to implement my resolver so I don't I
don't have to write any cipher there
basically all I'm doing is calling the
New York Geographic Q L integration
passing along the graph QL query and any
parameters and our integration is
generating the cipher behind-the-scenes
these are these are the generated
queries so here you can see we were
looking for the hashtag politics and
looking for any tweets that have that
hashtag and
and so on so anyway so so I think this
was really cool this was a big a big I
think developer productivity boost it
allows you also still to have the
flexibility of querying other services
so if you want to fetch data from
another another database you can do that
as well just implement your own resolver
rather than calling out to the to the
integration cool so that's that's the
near video graph QL integration I'm
about out of time so I'm gonna gonna
skip over this this react piece I think
we're all pretty familiar with react
the only thing I want to say about about
the reactor Paulo integration is that
Apollo clients the reactor integration
for Paulo client is really neat because
it allows us to basically bind a
components props to a graphic UL query
that's sort of the only missing piece
here and my my super simple
react app that I wrote in just a few
minutes as you can see with no no
styling or anything basically just
allows us to search by by hashtag so all
it's doing is binding our tweet list
props to to a graph Gale cray anyway the
code is is is online if anyone wants to
check that out I just want to mention a
couple of things one is that these sorts
of integrations that we're building
these are largely feedback driven so
this if this sounds like an interesting
project like something that you might
want to play around with please do and
then let us know what you think are
there features that would be helpful
a lot of snow we can build them because
really our goal is to sort of figure out
what's sort of the sort of integrations
like this make sense to make it easier
to build to build cool applications so
I'll mention just just a couple of
resources the New York Jay sandbox which
I mentioned before is a great way to get
started with neo4j
it has this data set for movies and
movie recommendations that power the the
movie app that I didn't really talk
about but as other other data sets as
well that are really fun and this portal
grand stack that I oh this is sort of a
landing page that collects lots of
information about these integrations
that we're working on has documentation
and tutorials for these different
different projects so if you want to get
started looking at looking at grand
stack apps or any of these integrations
I talked about that's a good place to to
start cool
so that that is what I have to say yeah
question yeah yeah so the question is
there's this other database called
DeGraff why would I why would I use neo
and instead of D graph for a graph QL
integration so so D graph is there's a
triple store it it's not quite the same
thing as a graph database but for
intents and purposes is very similar
they they use something kind of like
graph QL for their query language they
call it graph QL plus - I think so they
they sort of have added some things to
to their flavor of graph QL and like
they've added some some filtering
functions and things like this and the
the problem with that is because it's
not graph QL it means that that doesn't
work with any of the other graph QL
tools so you you can't just like wire up
Paulo clients to it because it's it's
not graph QL so things will break
there's actually um I won't bring it up
here but there's a really good github
issue or some of the Apollo folks
basically said hey you say this is graph
QL but it doesn't work with any of our
tooling what's going on so so anyway so
that's that's one thing that I think is
a bit confusing about D graph is it's
not actually not actually graph QL that
you know is compliant with the spec that
works with other graphic UL tooling in
the ecosystem but having said that the
with what they've done with the the
graphical language is really interesting
because they've taken taking an
interesting query language and sort of
added missing functionality I just don't
think they've done it in a way that
plays well with other tooling so so
anyway the answer to to your question is
sort of for if I want to build a graph
QL app with with an ear for J or or D
graph you know an important
consideration is how does it work with
other
other tooling in the ecosystem and so
the these ciphers schema directives
these are sort of the the built-in way
in the graph QL spec to sort of extend
graph QL so this means that we're sort
of extending graph QL by annotating
these fields but we're doing in a way
that is compliant with the spec and that
means it'll work with all of the other
graph QL tooling in the ecosystem well
thank you if there's no more questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>