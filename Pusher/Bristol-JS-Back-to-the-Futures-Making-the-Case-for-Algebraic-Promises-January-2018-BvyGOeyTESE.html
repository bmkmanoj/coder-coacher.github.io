<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bristol JS, Back to the Futures: Making the Case for Algebraic Promises, January 2018 | Coder Coacher - Coaching Coders</title><meta content="Bristol JS, Back to the Futures: Making the Case for Algebraic Promises, January 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bristol JS, Back to the Futures: Making the Case for Algebraic Promises, January 2018</b></h2><h5 class="post__date">2018-02-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BvyGOeyTESE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well futures thank you so much for come
down and listen to me talk about futures
I've got a rather grand proposition here
and you'll be making the case for
algebraic promises don't worry about
that I'm sure there's two questions in
your mind question number one quite
rightly is what is a future so a future
is a wrapper for a value we really
really cares about tight I'm not just
talking about a good date were we're
representing time but something that you
actually have them waiting for and when
it comes you might have succeeded or my
failed I'm not talking about the bus
these things like promises if you did
you see the before and a second question
I imagine on everybody's minds is how do
you think you can get away is such an
awful pun as back to the futures well
reason number one I have a shame and
reason number two you technically works
so what's the functional JavaScript seen
is fairly new each and thing around for
only three or four years in JavaScript
but they actually have a very old
history see the IO type in Haskell is
actually a kind of future and that's
been the wave then interactions in
Haskell for the last 20 years so
technically we can go back to the
futures so what I want to do well I
think one of you is leave anyone behind
so I'm starting the presentation with a
little bit of a need-to-know section so
this is what I would ideally like people
to know so this is a common baseline so
that we can press forward together so
the Mike everyone tonight JavaScript you
can I got mostly JavaScript guys here
cool like people to have some experience
of the map function if any of these well
it's only the second team map and
parameters if you don't know them
I can do a really quick crash course on
them
so I'm gonna ask for a little bit of
audience participation which isn't great
but so if I have a rough show of hands
the people who think they know what map
is who have seen map their JavaScript
everyone comfortable with map
actually pretty high level of comfort
with map there that's really good so I
will talk about what we don't need to
know okay so we don't need to know
functional programming I know a
name-checked has been already I'm really
sorry for doing that one minute
presentation this is about JavaScript I
love JavaScript a lot functional
JavaScript I don't expect you to know a
strongly typed functional language don't
expect you to know category theory for
mathematics I like don't even expect you
to know any other async techniques so
events observables it's not like that's
not important today we're just comparing
futures and promises to give you a fair
go on what if this is something you
might want to try out at work or in your
home for everything so no okay well
there we go
so yeah map a little refresher on that
so map is a higher order function which
basically means it's a function that
takes another function and the function
that you give it is then applied every
item in a list so let's say for example
we have a list with some numbers in one
two and three and I call map on that
list function I give to map I think it's
applied to each item above this so for
example if I call this function up there
and what is evan called the arrow syntax
yeah i've only kind of more traditional
pre es6 version there for people who are
not used to the arrow syntax but i've
got add one take some x adds 1 to the X
X plus 1 so if I call 1 2 3 Matt at 1
the result should be 2 3 oh pretty
simple I've also got an example there
where we've used an anonymous learn the
function is for the same thing so
actually catch you up on that and then
we've also got promises and then there's
a ferry a kind of niche famous article
on a broken promises
which is all bad teachers so that
teachers are a better there's no promise
I think that's strictly true but they go
you've got your broken process so just
like futures a pro-x is an object that
wraps an eventual value so the natal
waiting for that will come to you
it represents the eventual completion or
eventual failure of some asynchronous
operations so that might be sending out
an HTTP server for Bennett Jason might
be reading a file from a file system
hoping like I example he's now in a lot
as well as adding one to things that use
that one so much today so to create a
promise you've got new promise and so
it's kind of a little bit object to that
you parts of the function for a text
function for resolve and reject so you
then start your underlying asynchronous
operation when it succeeds you call that
resolve function with the success value
like fails you call the reject value you
pull the reject function with the
failure value okay so when you're using
promises it looks a have a lot like that
second example because I'm doing
something that takes some time and then
there's a hell of a lot then top and
then then as you kind of chain together
everything that happens after this
initial innovate synchronicity so we
kind of thing in core with with Matt
compromise you can kind of press up okay
really really really crash course on
what what matters to me about functional
programming so punctual programs and
again I crash the bus how many of you
have kind of done functional programming
seen functional programming heard of
functional programming to be honest
susan has again really really great
numbers fantastic so yeah what matters
doing functional programming is the
programs are composed of smaller
programs which eventually you get down
into these kind of atomic values which
are
and values okay so values used to you
things like number of strings objects
arrays functions you've seen this add
one function as a surface it come up a
lot even things like this reduce is
slightly slightly more complex example
function so what I'm going to be doing
is introducing couple types to really
help you get a handle on what futures
are in particular I'll be introducing
the future type so please come in a
title there and I'll be showing you the
either type because it's a way of really
unlocking some of the superpowers of
futures this also means that we're going
to need to make a little bit of a start
on a concept called type classes okay so
I'm not gonna go into too much detail
because it pulls us down into a kind of
category Theory rabbit hole there we go
really really deep into them but if
anybody does any object-oriented
programming it might be useful to think
of them as interfaces so the type class
will generally come with one or more
functions and in order to be a member of
that type class you have to implement
those punches don't worry it's those
that don't worry we're mostly just
naming them and moving on okay
so type classes this kind of rainbows in
the unicorn stuff this isn't just to
make you feel happier at this point
hopefully it is distracting you from
some of the words that we're gonna come
up in a second and this is actually the
logo for a kind of movement called
Fantasyland within the open source
JavaScript community this comes from a
common Dominic demo kernel made and I
promise this colleague who went way back
in the day where he said you can go and
live in your typed languages Fantasyland
we never introducing those changes into
promises if the promise is a prospect
and of course the monadic things that we
were asking for didn't end up in the
problem
they perspec but we did decide to go and
live in a fantasy land
so this algebraic specification is
created it's kind of cribbed from her
school but it's not Haskell again the
people working on algebraic typed
functional JavaScript like me are
passionate about JavaScript and it's the
very idiomatic JavaScript field it's got
some different different terminology for
some other things you might know from
Haskell so I'm going to start you with a
couple of the type classes or a type
that you already know so you all know
what a list is the list is a container
for zero or more values when there is
more than one value the order matters
and the type class is a couple under
type classes involved in lists functor
and foldable so just keep keep things in
the back of your mind future has yeah
well I'm not going to do today the Magno
tutorial that's that's a topic that no
really needs to get into again I will
touch very likely I'll leave it alone
and either I kind of name checks either
the previous like that's also a fun time
as a monad it's also - so it sounds
pretty cool
so pota any type which influenced the
function map and it's not quite things
like terminology but this is broadly for
me what we're getting onto any type in
finish approaching a man is a boater
okay
what map does do you think what that
does to a list this is a function that
run against every element of the list
so when map is applied to a different
kind of Hunter
it runs the function you give it so
every having in that photo
now in the case of the future probably
only one element in it probably just
that one value that you're waiting for
come back from HTTP over the file system
when you call map on it it'll act on
that one value follow the world type to
the full world function can you can have
a situation where all the animals of the
structure folded together into a single
value so you probably know this is
reduce in JavaScript my map has two
functions in the fantasyland
specification they actually can be
inherited from other types but so you've
got chain which allows you to combine
monads together and you've got off which
lets you turn simple values into mo
notes and then this will come a very end
try remember though we've got I hunter I
went to is the type that can hold two
values and has several functions to
change in those values which is left
right and by none you sure it's on
papyrus but you can kind of put that in
your brain print it because I want to
talk about a like a really cool logo
this is called future I think it's
called future might be called the luxury
or something like that it seems more
likely that it's complete check done at
supply sector peak flat sorry anyway
this is the what I really recommend
there's a few different ways of getting
up and running the futures or em here
we'll get home I recommend future
because of the great documentation it's
got some links to some great wikis and
really good articles a couple of good
videos it's also measured as having the
highest performance of all the future
libraries and actually it seems fullness
of some promise libraries so that's
really good
I recommend you check your name so we're
kind of kind of point where we can
actually start talking about features I
think we've done the grain work because
not something about this tight so if you
remember I showed you a slide about how
we might want to create a promise
this is how you might create future
looking really similar so far so the new
keyword their new future reject reject
okay I'll stick opposite way right so
when you make the promise to resolve the
reject when you make the future reject
the result in futures error case always
comes first because there's no way of
ignoring the error case in futures just
design decision a really sensible design
at this point you would do or your async
you start your underlying process
whenever that might be when it comes
back with success resolve when it comes
with heylia you can't reject so all
really similar so fun here's a concrete
example of a little bit of node.js that
i have converted to be to use a future
so you've got read file as you'd expect
takes apology as the argument we then
move go too far we then instantiate our
future with projecting yourself we call
FS file system don't read file if you
don't know note i don't think it should
be a big problem i think the concepts of
reading the file from a hard drive
should be pretty straightforward utf-8
is just encodings just something you
need to write so takes the file name
thanks team coding
start an otoscope callback eric data if
there's an error
I reject providing the Heron helps lies
a result and then the rest is just so
once you've got your future maybe you've
made it yourself
maybe you're lucky enough that you're
working with a library that exposes the
futures API you then probably want to do
things with the value that you've waited
for
we'd you've waited for it you fetched it
from somewhere you must be
and the really cool thing this is where
those type classes start kicking it so a
future is a functor if you remember that
other boat that it can be mapped so what
it can do is they have got a future of
teeth I can map that probably my add one
function and what I get I get out a
future which holds the value three so
relative transformation or I have
prepared a transformation for that
future slight difference get to in a
minute
same way of the era state so if your
future is holding a fatal state in this
case coming your string describing the
type of area we can map over that as
well in this case it could have been
laws what you put in this much
transformation and just carries on
returning a future of the contents same
errand so how do you get stuff eight of
the future well two to finish off the
future you have to go org what that does
is it actually begins the computation so
the point in which you call fork that's
when that underlying async process kicks
off okay so I make my future I do any
sorts of transformations I want and then
I'll call fork so as I said earlier
futures are really really keen of making
sure you handle your errors most future
libraries will will throw errors if you
don't provide two functions and you have
to provide an error callback the error
callbacks first it's very important and
a success callback the success callback
is second and these callbacks let you
handle basically what comes out of your
future to add all the subsequent
transformations so
come back to the homeowner thing
unfortunately there was only a matter of
time so I said that my notes have a
chain function for combining with other
monads so in the case of teachers the
chain function will take the value
wrapped up in your future so maybe
you've got the number two with that like
we've had a couple of times
it must return a new monnet okay so I'd
like map where we were able to take 210
3 if we call chain we wouldn't be able
to do that 3 would not be a valid return
value it'd have to be a new moment ok so
this could be used to chain different
asynchronous actions ok so maybe you
need to fetch something from HTTP and
then you have to fetch something else
from a different end point somewhere
that's when the use case for chain comes
in when you need to do something
asynchronous and then another thing
that's asynchronous so I'll give you a
pet example here so I've got refiled but
I spoke to you earlier I'm reading file
conversion dot txt now this isn't the
way to do software versioning just to be
really really clear especially in your
JavaScript there's a thing called
package dot J's new stuffs em both way
better but for this example we're
loading version dot txt this is this is
a text file with a number in it so as
you can imagine we're going to think
that thing we always do we're going to
increment a number add one to it and
then change something this is where we
take our new measurement and we do write
file
Activision dot txt without new version
of the selection so that we need to
forget this tells the future to begin
its computation with a total load
conselheiro here for the every case
could not save and give the reason white
and it's a test case safety new version
of that that is a working program I
probably need some imports at the top
this is JavaScript but compilers from
just a few tiny parts you've got a
working semi useful set a useful program
for completeness that's a lot right fine
would look like kind of encased in that
notes I'll come back right part of the
future hey won't come with that yeah
yeah little bit me it appears a little
bit more fiddly compromises with
promises you'd be able to do the same
thing and you just beyond so kind of
them then it's a lot easier then dot and
this forces you to be more precise but
so far you know what's the benefit so I
start getting into the actual benefits
of futures because so far they seem like
a slightly more fiddly province okay so
we've seen how how we can use chain
so-called to two futures in series
sometimes there are common use cases
where you need to call stuff in parallel
so maybe there's a bunch of stuff that
you need to fetch it once or just a mode
of asynchronous thing just don't depend
but another and you don't want them kind
of lock in each other so here's a
technique to do that and this is
specific to the future library I'm going
to talk about problems there in a moment
so you can do future but peridot you can
pass in a concurrency with it at this
point so this basically tells it how
many features to keep him fluent at once
this means that you don't overload the
system that you're calling out to if you
have no concerns about that you can just
use the number of into here second
argument will be an array of features
and what comes out of a parallel is a
future that contains a list of the
results from all those other features
okay so I'll just go over that one more
time what goes in in on the list of
futures what comes out is a future of a
list okay so you can see the types got
kind of knocked over into their sites
okay
it's got this built in rate limiting so
in this instance where I've set my limit
is five I've got my futures as a couple
of read files the result of the contents
of file one and the contents of party
yes is that sequence this is not in
sequence this is no no it's not the same
as sequence yes yeah yeah I'm going to
get right to that cold so understand I
was feeling a little bit problematic
about the fact that parallels is mr.
fiction future library in fact I'm kind
of almost prepared in advance all the
functions that I thought we would be
using today I talked about chain about
map I talked about oh I didn't mention
parallel in there anyway so what's the
deal with that
well isn't interesting quote embodied
success at all costs dr. Simon Paton
Jones say what he doesn't need well he's
not trying to do this is so this is the
creator of Haskell wouldn't one of the
creators of Haskell one of the maintain
is its compiler what he never means by
saying this and it's a little program
that Jake witness he doesn't mean that
he's trying to avoid success that's not
what it means he's not scared of success
he's not worried about giving away his
cool language he wants success but what
he doesn't want is part of the sentence
success at all costs he thinks that is
something to be avoided what is
successful costs successful costs is
succeeding at the expense of something
else okay
in the case of functional programming I
think it's up 7-pin Jones's case he
doesn't want to succeed at the cost of
his descendants okay
and I think this instance where we've
used a parallel function is perhaps a
case of us succeeding at the cost of our
principles because by using a function
that isn't type of a type part of the
type cuts like now locked myself into
the library future I've failed to learn
something as well so by seeing this
really useful really successful in
parallel function
I now haven't had to learn how to really
do and how you really do it is a little
bit more complex so how you might really
want to tackle this is to use a more
generic function called Traverse trigger
this well let me do exactly the same
thing it will let me take a list of
futures and turn it into a future of
lists let me do that 90 degree turn what
it does it does it in a way that works
at any photo Lonette and that is
powerful and the reason that is powerful
is because at that point it's not an API
it's a grammar the beauty of learning
small reusable pieces that can be
combined in different ways is the core
of functional programming at the point
at which you start flooding your API
with a hundred functions 300 potions
four five six big libraries you've lost
that elegance you have succeeded at too
high a cost if you can build your
programs in the smallest components from
the smallest grammars and an infinite
complexity rolls out from there you
succeeded with principles so I'm not
going to have time tonight to actually
show you some of the better ways to do
parallelism but just like that when you
save a little nugget your minds so well
you want to talk about
is why term I thought about this one a
long time a really good futures a use
case okay and this is error tolerance so
this okay mo came up with work okay so
we've built we've got having I realize
that what slide got missed at the start
neg I'm gonna get back a second so the
slider got missed there's a slide about
Who I am to take you on this genuine
Peter's new line new is this guy is his
deal so I will share the slides at the
end I'll marked with this nice to meet
you
I work for a company calm happy we do
kind of work in software with based here
in Bristol and then we'll also some
other stuff they were stuff about my
beard I keep some parasites and pictures
of parents I don't know I've been a
white or got lost
it's got my kind of get over my Twitter
so just pretend you saw there and it
will happen right so we've got happy on
AWS Lanza which are kind of which has
service functions that exist in the
cloud so what else's computer the really
nice thing about this is we don't have a
single ec2 instance we don't have to
manage any databases a drawback of this
is that you have to have all your useful
work done in I'm function within five
minutes at most so we have a few kind of
end-of-month processes take longer than
five minutes so we didn't want to just
spin up an ec2 instance some write an
Express server that would be too easy so
when we wanted to keep it all hosted and
keep it all managed so we came up with a
cue system so we used only Mon bÃ©bÃ©
streams as our kind of cute
and so what what the keep does is it
allows you to cut a hole jobs in like
way more than a single line the function
will be up to handle and then they kind
of just like a real cue like a nightclub
or whatever then as the cube that's the
doorman that's a batch of five in closes
the thought yeah able a synchronously
resolved I'm pretty sure I haven't been
clubbing in a long time I remember it
being a bit like that so this is what
happens in having our big list of jobs
in our case it's kind of indifferent
binning where we challenge people on
behalf of other people I'm able to take
a few minutes time and resolve them so
I've been about using process I thought
honesty is good I'll take my batch of
five jobs
I'll put it all in a promise to all oh
no some failed rather than failed if one
fails they all fail that's a bit of a
problem because I want to know the
successes and I want to know the
failures either successes I want to
write the back to the DynamoDB table and
say succeeded and for the failures I
want to increment a retry number and
leave the statuses is ready to go so
that they go back to the back of the
queue and they try again later so the
fact that price that all failed them all
it's a big problem so as promised like
we called Bluebird the providing utility
function for handle in this situation I
saw how brilliant I use that in my last
job that would be great I'm looking at
this called settle so I go to the
Bluebird website and I look up settled
it's not that it's the API version 3 now
it's called something else I definitely
forgot what it's called and that's kind
of the point right it's got a specific
vendor locking style API if you forget
what it's called you forget what it's
called
anyway I implemented it with Bluebird
worked really nicely my colleagues sound
said that he said we've got these we've
got these handlers that we wrap around I
like the functions and I don't know if
you noticed they're using generic a plus
spec promises I don't want them time to
believe it it's just one implementation
I was like okay maybe there's a better
way so I thought well I've seen I've
seen these features things that it be
research on them before and I thought
well let's try futures so I tried future
parallel check my five jumps in at one
fails and they all fail that's a problem
right how do i how do I result how do I
make them all look as if they've
succeeded and your futures as an actual
way to do it an actual sensible way
using these type classes using this
grammar using this small simple API
there's a way of doing it and it's it
involves the ether type so quick aside
onto one either is and either is going
to feel a lot like a future okay and
either is a wrapper for about you which
can either be one thing or another thing
you can either be the left or right by
convention we generally put a success
value in the right hand side of an
either think of it as like two little
boxes made it we put the success in the
right because right is right like
correct it's not a political statement
it's because everyone wonder how we use
left for the area because it's the only
business name so you code and either we
look at it like this either Peninsula
neither library not right put value in
say five I don't know we can stop
calling map against it because it's a
filter we get to reuse these things
again and again and again and what you
get are you gonna write the score six in
either thought that as per our messaging
know a number Oh suddenly sounds
interesting
no matter I was great
easy way of handling not under specific
citing again we map it what comes out
not number doesn't even touch it doesn't
throw an error we've taken a we've taken
they're not a number and tried to add
one to it didn't even personnel exclude
it it's also got these five app
functions which let you put let you put
a function for running against the value
in the net box on the left function for
running against the value in the right
box on the right and then it calls the
appropriate one based on what value that
hasn't it so in this case if it's got a
righty value it adds one Lefty value it
goes all exclamation marking
okay so thanks that's either why did
well it did at work have it was I made
this air intolerant batch handler this
isn't the exact code really similar
though so I've got my cucumber takes my
array of futures future not parallel put
in my linear it wouldn't be really five
and B in configuration somewhere and
then I'm at home in my futures we're
mapping over a list here we're not
nothing to the future and then I fold my
future into left or right okay so you're
all remember fold forward lets you take
elements of the sequence and turn them
into one value okay so in the case of
the list we might have list of numbers
one two three if we fold them all up
with the the summer value I come up a
six so it turned multiple things into
one thing in the case of folding over a
future you've turned the multiple
potential values success on the Left
failure on the right we've turned them
into one thing which is always success
okay so our futures are always mapped to
a success we've been getting weird with
chucking away the fact that they may
fail but because we've now gotten either
inside our future the either tells us
whether it failed or succeeded so we
haven't lost the information we've just
hidden it buried inside the either okay
so now - the future is they're all going
to succeed they're all going to succeed
but they're going to hold that failure
or success data inside of their
structure so at this point I know now
all five of my future's are going to
succeed and so I'm definitely gonna end
up in the positive side of my book in
that case I can call a function put
value funny is like fork but you don't
have to supply America you only have to
supply the success case and it gives me
my list of others so I can do them as I
can extract the successes from them I
can extract the failures from them I can
record back into my database which ones
succeeded which ones failed I can look
at the failures and I've done so really
really similar to the code we put into
production this is so in there's a tiny
amount of code using simple principles
using the grammar of algebraic data
types I've created simple reusable
system or giving me an error tolerant
key I'm really pleased about so into the
conclusion apart should we be using
these things
another thing I've said tonight convince
you that features might be worth and
look at so I think what we want to do is
go into some of the pros and cons
because of the length of this piece the
United content I was trying to squeeze
in some of these pros I haven't actually
even mentioned yet and so one thing I
have some a lot of my it's got a precise
API it's got this kind of grammar based
API with consistency across different
vendors so whether I'm using
cause future future data's our future
I'm getting a level of consistency
because they all implement that they all
implemented chain they all implement of
they all import right you've got that
consistency next up we've got great
compatibility with all over fantasy and
complaint monads focus etc so we got
that compatibility angle so it's a lazy
so laziness is a big advantage to
functional programmers thinking about
this job you already if you can be lazy
it means that this really nice way of
encapsulating side effects because they
need to start happening in two equal
four
and also it can be cancelled this is
just a straight-up efficiency game if
you imagine if you had a promise that
all the future not parallel or if you do
not reverse whatever you want to think
of it whatever those comes back in the
fania you don't it stops
you don't care about the rest of the
results in the case of promised at all
all those other four still carry on
doing the underlying async operation
though that's talking to HTTP whether
life accessing the file system you can't
tell them to stop
so from an efficient efficiency
perspective they're doing stuff in your
program but they don't need to be doing
whereas because features are cancelable
if you've got a list of five features
going on and one comes about quickly
with a vania it's touch the rest clear
that the resources you know just
efficient just an efficient thing today
so the pros are promises promises are
deep back to industry standard
everywhere you look you see promises
there are lots not so whenever you need
to access something where you're waiting
for a response there will be a promise
version of the library that's talking to
a major database talking to you I think
probably that just the API imagine has a
promise based interface easier to learn
and remember
the basic API the other basics it might
get trickier because it might get very
very specific but the basic API it's
just then and then like you've
remembered it already
congratulations the other great thing by
promises is async/await syntax yes i
babel really really good for imperative
style makes you allows you to forget
that you're even working with the label
use at all so if you're writing an
object-oriented or an imperative style a
single way it's nicely got7 that's all
powered by promises and finally it's
functional enough for most purposes
promises why you how about 80 other uses
functions you get something returned
that's a really good step one if you're
a functional programmer it's a lot
better than a callback you're actually
getting a value back you can pass it
around pass it through functions a lot
of the time that's good enough
so in conclusion do we want to be
adopting futures well level the meanings
of the word adoption so matters that
don't use them at all
just suck up the limitations of promises
sometimes the error handling is a bit
wonky maybe you can't cancel them maybe
that's a bit inefficient but hey maybe
it's someone else isn't it inefficiency
option number two use the wiki
consolation or another killer feature
our table so Shoji if you do this you
might have an ad hoc jump job to do so
you might look at this of code the view
code base that could be improved by
futures and the codes surrounding that
you might need to convert all your
promises into futures you might won't
have to entirely rewrite your code base
well the third approach is to go all-in
wrap all of your libraries in the
futures API and enjoy sweet sweet sound
coding to real principles and a real
fully functional approach and we've got
the kind of everyone we wean these folks
at
we've these features a couple of times
but it's made sense we haven't been as
Ellison at it but yeah hopefully a
little bit of food for thought a little
bit of an option Utes hopefully you
learned something about and why grammar
based API is might be better than
grab-bag api's and hopefully on a bit
more back functional programming they
say thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>