<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>WebAssembly and the Death of JavaScript - JS Monthly - February 2018 | Coder Coacher - Coaching Coders</title><meta content="WebAssembly and the Death of JavaScript - JS Monthly - February 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>WebAssembly and the Death of JavaScript - JS Monthly - February 2018</b></h2><h5 class="post__date">2018-03-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pBYqen3B2gc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm talking to you today about
webassembly and asking the question is
this going to be the death of JavaScript
and yeah it might not be the best
meet-up to ask a question like that if
you feel like throwing something at me
that's fine just wait till the end
that's all cool so I'm going to start
off in typical fashion with a brief
history of the web and I'm I know the
web is a complex complex set of
technologies I'm mostly going to be
looking at javascript and as I think
most people have worked with JavaScript
for a while know the language itself was
invented in a very short space of time
by a chap called Brendan Eich he
invented it in just 10 days and back in
1995 the web was a very very different
place it wasn't the kind of dynamic
single page app react type environment
that we know right now it was mostly
static pages the occasional form and
JavaScript was there to just add a
little bit of interactivity on top of an
otherwise pretty static web since then
other languages have come along and Java
applets ActiveX flash you might have
used some of these Silverlight my
apologies if you've used that dart and
so on and that's it that's the history
of the web done because 2018 it's still
JavaScript it's still only javascript
javascript is the only language which is
officially supported by the web but the
interesting thing is the way that we're
using javascript has changed a lot in
the 20 odd years since it was originally
invented I guess without going into too
much detail one of the things that's
that that I've observed is that we
collectively we write a lot of
JavaScript and when I say a lot I mean a
lot of JavaScript and just the other day
I started up a new react app so I used
the create react app package so this is
me creating a new application and then
finding all the the JavaScript files
within the projects and doing a line
count 79 thousand lines of JavaScript
that's a lot of JavaScript and the thing
is weird we using JavaScript for far
more than just adding interactivity on
webpages which is the world that Brendan
Eich was was creating JavaScript for
we're using it as build tools we're
using it on the server we're using our
mobile devices we you
all over the place but the weird thing
is the way that we're using the language
itself has changed quite a bit
many years ago I guess when I first
started using JavaScript it was quite
simple you don't pop a text editor you'd
write some JavaScript it would be served
over HTTP and exactly the code that you
had written would be executed within the
browser that doesn't happen very often
these days typically the code that you
rights will be transpiled it will be
minified it would be bundled it will go
through all kinds of really quite
advanced transformations and by the time
it lands in your browser it will look a
bit like a garbled mess and that's led a
few people to consider javascript to be
the assembly language of the web it's
it's a compilation target as well as the
language we use to write our
applications but this is where I move my
cursor this is where the problems start
to surface because JavaScript actually
isn't a very good assembly language and
it's no surprise again reflecting on the
context within which it was invented in
the first place it was never designed to
be an assembly language it was never
designed to be a compilation target and
to understand why it's a bad compilation
target why it's not a good assembly
language you have to understand a little
bit more about how javascript is
executed within the browser so this is a
diagram that I took from a a Mozilla
blog post where they were giving a rough
overview of how JavaScript is executed
in the browser so the first bits on the
left hand side is a bunch of characters
come along over HTTP and they're passed
into a thing called an abstract syntax
tree it's a it's a tree like
representation of your code after that
it generates some PI byte code which is
then run within an interpreter and then
this is where the really clever stuff
starts happening many years ago that was
it that was the way that JavaScript was
executed these days a lot of work has
gone into optimizing JavaScript so what
will happen is the runtime will start to
look at your code look at the execution
to make certain assumptions if you've
got a function that is always called
with a pair of integers for example it
will generate an optimized version of
that and the execution of that function
will become faster and I think it was
the Safari browser has something
like four different tiers of
optimization and the your code sort of
moves up and down these tiers so as it
can spot optimizations it moves up a
tier but if the assumptions it makes
about your code is false it has to push
it back down again it's really really
complicated and as you can imagine this
isn't an efficient compilation target
and how does this actually manifest
itself what one of the things that as a
JavaScript developer most of us are
pretty much all of us concerned about is
the execution speed of our code within
the browser and there's the one of the
most important things what's something
that people have been focusing on a lot
recently is is the time to interactive
the time it takes to load all your code
and actually start doing something and
this is a timeline that I shamelessly
borrowed from this fantastic blog post
by Lyn Clark it's it's well worth the
read she does an excellent job of
describing why web assembly is needed
I'm just grabbing this diagram here this
is a timeline that approximates the
execution of JavaScript within your
browser so the first thing it does is it
has to pass your pass your JavaScript
the next is it has to compile and
optimize it and then potentially it will
have to re optimize it and then
afterwards you've got a certain amount
of execution and garbage collection the
timeline you see here that the past time
the compile time the optimized time has
a significant impact on how long it
takes for your application to actually
execute and be interactive so this is
again why I'm saying that JavaScript
isn't a good an assembly language
this isn't your were designing it from
scratch you wouldn't design it like this
and I guess this this little quote here
I think summarizes it quite nicely this
is a quote from the team that created
web assembly and they mentioned that the
web has become the most ubiquitous
application platform ever and yet by
historical accidents the only natively
supported programming language for that
platform is JavaScript and this is
coming from a bunch of guys who are web
developers and they love javascript so
it's not they're not against the
JavaScript languages itself but the the
situation we found ourselves is is a
weird quirk of history so that brings me
on to web assembly if you look at the
web assembly specification the web
assembly
website they describe it as a new
portable size and load time efficient
format suitable for compilation to the
web so it was designed specifically to
solve some of the problems I've been
talking about now hands up if you've
heard of ASM jeaious before okay that's
that's good so an interesting parts of
the history of web assembly is quite
tightly related to asm.js
don't worry if you've not heard of it
before it doesn't matter I'll give you a
quick illustration of what it is and
hopefully that will help you understand
some of the design goals of a web
assembly so ASM j/s was a bit of an
experiment it was actually a bit of a
wacky idea that was created by Mozilla I
think around about five years ago and at
that point in time there were various
other plugin like technologies being
considered in that the standard plug-in
model is you take some other runtime and
you kind of bolt it onto the side of the
browser that's how that's how plugins
works and at that time there were other
people considering other plug-in style
models whereas the Mozilla team came up
with this slightly crazy idea of why
don't we create this sort of virtual
runtime that sits within the JavaScript
virtual machine so they said okay we
need memory so we'll just have an array
that can be our memory we need
instructions so we'll create effectively
patterns within our JavaScript that
represent those instructions so I'll
quickly illustrate what it is and then
show you why that is a great
demonstration of a slightly better way
of doing things so here's a here's a bit
of code this is some asm.js code don't
but don't worry too much about the
detail pop this is a function written in
C that there's your standard Fibonacci
calculation I'm compiling it using a
tool called M scripting into a SMGs and
that's what you see at the bottom there
so a s MJS is JavaScript but it's a
particularly peculiar looking kind of
JavaScript I'll highlight a few things I
won't go into all the details but the
first thing you'll see here is the
reassignment of the arguments to this
function so a equals plus a so typically
you'd use that to kind of coerce
something to be a number B equals B or
zero which means that it's exactly the
same as it was previously these are type
hints these are telling the runtime that
and one of these is a floats and one of
them is an integer you can see at the
bottom it's returning plus C again you
can see the pattern here that res in my
C code is a float you can see that we've
got in the JavaScript code a for loop
and a s MJS doesn't support for loops
here you've got a do while instead so
that all looks a bit crazy you might be
asking why on earth would you do that
getting back to the way that JavaScript
executes within the browser you can see
what they were trying to achieve with a
s MJS so what happens with within a
browser that understands it well firstly
if the browser doesn't understand is MJS
it doesn't matter it's just plain old
JavaScript and it executes says normal
however if the JavaScript recognizes a s
MJS and it does that by looking at this
use ASM literal string at the top what
it does is it starts doing the usual
thing it it parses it into an abstract
syntax tree but then immediately it
spots the patterns it effectively reads
the ASM J s assembly language and
immediately is able to push it right up
the right up to quite a highly optimized
version of the code skipping some of the
quiet and time-consuming interpreter
steps and optimization steps so as you
can imagine this is quite a neat idea
but I think s MJ s was only ever put
together as a a technical proof of
concept because one of the things they
could never get around is the very first
bit bit at the beginning their parsing
the JavaScript language and as you can
see it's a s MJ s is itself pretty
verbose so as you can imagine parsing it
to the abstract syntax tree has got
quite a lot of overhead but a s MJ s was
a great proof of concept that there
might be a better way of doing things
and their early demos were really quite
impressive the M scripting tool they
used also had a logic in it to convert
OpenGL code into a WebGL code and they
were able to take some game engines and
do some pretty impressive things so a s
MJ s pointed pointed people towards a a
different and interesting approach to
solving this problem which was quite
different to the standard sort of
plug-in model as a result the web
assembly working group was formed and it
was formed in 20
fifteen with with representation from
all the main browser vendors and a bunch
of others and quite impressively within
the space of two years they managed to
design their MVP scope for web assembly
and and get it released in the wild so
in November last year and it was turned
on in all browsers all major browsers
without the need for flags
so it's officially out there in the wild
it's also in node version 8 and beyond
and just earlier this month w3c
published their first public draft as
well so they managed to get this done in
a very short space of time and I think
it was mostly because ASM j/s
effectively created a blueprint to
demonstrate some of the concepts here so
I've talked a lot about web assembly but
I haven't actually shown you any
webassembly so I thought the best way to
do that was to actually and show some
code and talk around the code just so
you get a better idea of what it
actually looks like in in real life so
switching to code this is obviously
where all goes horribly wrong okay so
I'm going to start with a very very
simple example this is a function that
adds two numbers together and even
though this is visual vs code that's
actually C which is horrible and dirty
and makes me want to wash my hands but
there you go there's an odd function and
what happens is with my build my tool
chain I'm not going to go into too much
detail about that my tall chain is
compiling that into web assembly and
there are two distinct formats that you
can use to view your web assembly the
the obvious one is Oh tiny tiny is in
hex so the output of web assembly is a
binary format so again recalling how
JavaScript is is processed by your
browser it no longer has to pause the
characters into an abstract syntax tree
it's a compact binary format but the
more useful way of looking at it is the
actually they've changed the file
extension for this it's the white format
web assembly text format it's a shame
they didn't go for web assembly text
format WTF as an extension that would
have been awesome but anyway this is my
C code so I'm adding two two numbers
together and this is what it looks like
as web assembly
so a few little bits and pieces here
we've got the concept of memory so
memory within webassembly is very
similar to the memory concept they
invented with a s MJ s memory is a
contiguous array of bytes and that
memory is actually shared between the
webassembly runtime in the JavaScript
runtime so you can you can make writes
to the web assembly memory from your
JavaScript code it defines functions
it's got a whole load of instructions
there are about 60 year old instructions
and it works as a stack machine if
you've done anything if you've done any
programming with some kind of assembly
language of some sort the full
instruction set will look quite familiar
to you web assembly can also export and
import functions so you can export to a
JavaScript function from your web
assembly module so you can export a web
assembly function from your module and
invoke it from JavaScript and vice versa
you can import a JavaScript module so it
can be executed by your JavaScript so
that's that's my web assembly and we've
got the binary format and I'll show you
how it's actually loaded instantiated
instantiated and executed now because I
can't be bothered by with creating HTML
page to house this I'm just doing it
with in node but it's pretty similar
within the browser so we're we're
loading the web assembly binary format
and we're constructing a module from it
and then from the module we're creating
an instance from the instance we can
invoke the exported functions so here if
I execute ad it tells me that to add 3
equals 5 so here I've gone from
JavaScript X it's executed and web
assembly function within the web
assembly virtual machine and return the
result that's all pretty straightforward
I'll show you now some of the areas
where it gets a little bit tricky and
now I feel like I'm showing you a bit of
a tip of the iceberg in that it's not a
simple case of just writing a whole load
of code and web assembly creating an API
layer and invoking it from JavaScript at
the moment is relatively challenging to
do that one of the reasons for doing
that is that web assembly has a very
small number of built-in types only has
four types and they're all numeric so
it's got two floating points and two
integer types what that means is if you
want to do something with
something a little bit more advanced
like strings it gets quite complicated
so my next little demo is just something
which returns a simple string from my
web assembly function and renders it
from JavaScript so I'll just put back
there okay so this is my C code so what
I've done is I've created a a hello wasm
string which is reference as a character
pointer and I've got a function which is
get message ref so what that's doing is
is returning the reference to the
message if we look at the compiled
output it's a little bit more
complicated this time we've got these
things called data sections within our
web assembly module and these are
basically ways of instantiating your web
assembly module memory to a known state
and here you can see it's actually
writing hello wasm it's writing
something else which i think is the
offset to actually I'm not sure I'll
have to check that it's writing
something else and here is how it's
actually executed within JavaScript and
here you can see that simply by changing
it from an example based on integer
types to strings
things get a little bit more complicated
so we've seen this bit of code before
this loads my our web assembly binary
and instantiate some odd module but now
to return the string the the get message
ref function isn't returning a string
it's returning an integer which is an
index to the location of that string
within linear memory so I'm having to
get hold of a reference to my linear
memory create a crater buffer and
iterate over that buffer populating it
with going byte by byte across my linear
memory reading the data route and if I
execute it it does indeed say hello
Azzam and that's by all means not an
exhaustive is the exhaustive
demonstration of web assembly but
hopefully it gives you a bit of a feel
for how where but how you use a web
assembly module for women from within
JavaScript and some of the current
limitations that there are so a little
bit more in the web assembly
architecture so web assembly itself is a
stack machine as I mentioned it has four
built-in types 67 instructions
importantly it's designed to support
streaming compilation so there are some
features that are specific to web
assembly
which reflect the context its used
within for the vast majority of use
cases your code is being streamed over
HTTP so it makes sense that webassembly
can be compiled in in a streaming
fashion and what that means is your your
your browser is able to chop up the web
assembly module and compile it in
parallel on multiple threads so again
it's been designed to be very very fast
it also has some very simple validation
rules Java scripts and any other
web-based language has a lot of
validation rules that ensure security
where assembly is just the same but
again they have been designed in such a
way that they can be processed and in
serial is it streamed in and as I
mentioned before it exports imports
functions and has a concept of shared
linear memory with JavaScript now one of
the first questions that people ask when
they look at web assembly is are great
this is going to be SuperDuper
performance it's gonna be really really
fast and I must admit I've read a lot of
blog posts which makes some quite quite
impressive and to be honest quite
incorrect claims about the performance
of web assembly I've seen blog posts
claiming that it's a hundred times
faster than JavaScript unfortunately
most of those blog posts suffer from the
classic problem of doing micro
benchmarking and either bench
benchmarking the wrong thing as well so
what I did was created a slightly more
representative test case I created a a
Mandelbrot and rendered that using C
JavaScript and a bunch of different
mechanisms for for generating web
assembly modules and I compared the
performance of them and as you can see
the black line here is the native
performance so that's my C code compiled
directly on my Mac and executed natively
and the interesting observation
immediately is Wow
javascript is really really fast it's
only about 20% slower rendering a
Mandelbrot
and that's because of the many many
years that's gone into compiler
optimization for JavaScript
disappointingly when I ran it within web
assembly it was actually a little bit
slower and using wisdom assembly scripts
and a few other different approaches I
eventually through a number of
optimizations managed to make it just a
little bit faster than JavaScript so I
must admit I was a little bit
disappointed by that
I've had a look at other benchmarks and
other results and most importantly the
the paper that was published by the web
assembly team the the accepted sort of
general feeling is that web assembly
should be around about twenty to thirty
percent faster at runtime execution than
JavaScript but because JavaScript is is
really quite fast there are there isn't
that much of a performance gain to be
made where they expect web assembly to
beat JavaScript significantly is the
past time and the initial compilation
time so the time to interactive with web
assembly should theoretically be a lot
less than with JavaScript so in the
future one of the things I mentioned was
that web assembly was developed over a
really quite short space of time and
partly that was because they had a SMGs
as a kind of reference implementation
another reason is the current web
assembly release is very much an MVP
they were quite aggressive about
ensuring that they had a very small set
of features so that they could release
quickly and the idea is that they're
going to be releasing new features over
the over the coming years so some of the
things that it doesn't have at the
moment is a garbage collector and I'll
explain why that's a bit bit of a pain
later on in the future it will also have
threading support a thing called host
bindings which is a way as I showed you
the interface between JavaScript and web
assembly is a little complicated at the
moment and if you want to start doing
Dom manipulation from web assembly
that's hard with host bindings in the
future that will become a lot easier so
one of the final things I want to look
at is webassembly language support and
what some people are actually doing with
the language so I showed you a little
bit of writing a bit of C code as a way
to show you what web assembly actually
looks like the text formats and so on
but most people aren't going to write
web assembly and it's it's machine code
but in its binary format or in the text
format most people are going to want to
use a language maybe C maybe not rust go
people are going to be using other
languages and in treating web assembly
as a compilation target so I'm going to
quickly look at the different languages
and their current level of support so
the first one is C or C++
and this is the the very first language
that gains webassembly support and again
that's due to its heritage from ASM Jas
there's a toll called M scriptum that
you can use to compile C to webassembly
an M script and does a lot more than
just a straightforward compilation it
has as I've mentioned it's got the open
GL to web GL bindings and it's got a
whole load of other things that make it
quite easy to take an existing C
codebase and compile it to web assembly
and put all the glue that's required
around it to actually make it work and
as I mentioned it was originally used to
create the ASM j/s concept some of the
practical things I've seen people do
with it there's a there's a company that
have a thing called PS PDF kit and it's
basically a PDF renderer and just last
year they started exploring the use of
web assembly so they've got a C++ code
base and they explored the use of web
assembly as a way of using exactly the
same code base to do PDF rendering on
the web and they they found it quite a
good experience they managed to create
something which I think they're going to
actually ship as a as a product and with
very good performance this one's a fun
one JSC so the JavaScript core which is
the JavaScript machine that runs within
within WebKit
is itself written in C++ now using M
scripting you can compile C++ to web
assembly so what that means is you can
take javascriptcore compile it to web
assembly and then run it on top of your
JavaScript virtual machine so what this
is is the the Safari JavaScript virtual
machine compiled to web assembly running
on Chrome which is great it's exactly
what you need finally one thing you'll
probably notice here is at the moment a
lot of people are essentially
experimenting with this technology there
are you won't find a huge number of
really practical use cases yet I think
that's still to come although where I
work at Scott logic we've done a bit of
work with a company called active
financial and they provide
they provide market data for people that
need high-frequency data so people that
are doing an algorithmic trading for
example and all of their distribution
logic all their serialization logic is
written in C and C++
and they've been getting a lot of
requests from from their their clients
who want to start using it
consuming this data from within
JavaScript either perhaps AWS and a
lambda function or perhaps within the
browser so we help them take their C++
code compile it to web assembly and use
exactly the same code to to to pass
their packets of data and deliver their
high-frequency data to the web so that's
something that we were able to achieve
with web assembly oh that should say she
C sharp that's a mistake anyway so C C++
that's the story and Java and c-sharp
these ones are a little bit more
challenging because as you I'm sure
you're aware Java and c-sharp and
languages that both rely on garbage
collection whereas C C++ you manually
manage the lifecycle of your objects and
because web assembly doesn't have
garbage collection yet that means it's a
it's quite a problem it's quite a
challenge to take Java and c-sharp code
and compile it to web assembly there's
an experimental project called Blaser
and that's become an official I think
asp.net experiment and which uses mono
some of you may be aware of mono as a
way to run Java and c-sharp within web
assembly and what they're doing is
they're experimenting with a couple of
different ways of doing it
one of one of them is interpretive mode
so they've basically taken the runtime
and compiled it to web assembly and
they're executing they're executing
c-sharp dll's directly within the
browser the other one is ahead of time
compilation so they're actually
compiling the dll directly to web
assembly and they're they're
experimenting with ease to side by side
blazer is a project that wraps around
Manos web assembly supports and it's a
fully featured single page application
framework so there's a lot of fun
c-sharp developers getting quite excited
about the potential of Blaser I don't
have anything practical show on c-sharp
and blazer because it's very very new
and I don't think anyone's done anything
practical with it quite yet so I guess
one of the final ones to talk about
is is JavaScript so why why shouldn't
you compile JavaScript to web assembly
and there's a lot of people writing
react applications and all kinds of
other JavaScript based applications and
and you look at the features you get
with web assembly and you think yeah I'd
like some of that I'd like my JavaScript
to to pass more quickly to be optimized
immediately so there are a lot of people
trying to find creative ways to compile
JavaScript to web assembly and obviously
there are even more challenges there so
firstly you need a garbage collector
secondly it's not statically typed so
you've got typing as a bit of an issue
there are a couple of projects that I've
been keeping an eye on that are trying
to tackle this first is called Walt
which is a JavaScript like syntax for a
web assembly so what they've done is
they've taken that text-based format
which I've shown you and tried to map it
as closely as possible to JavaScript so
it's it's a thin veneer on top of the
web assembly text format the other one
that I've actually had a bit of a go
with is assembly script so in order to
solve the typing issue that's pretty
straightforward with JavaScript these
days you've got things like flow and
typescript that introduce typing so with
typescript you can enforce typing of
your code and use a very similar
compilation path that you do for a c and
c++ and at the moment that project is is
in its early stages and they're
currently awaiting news of when garbage
collection will appear within web
assembly to make some fairly critical
design decisions about how they how they
tackle that i've actually got a bit of a
demo hopefully i typed in the Wi-Fi
password so has anyone used d3 before
yeah cool yeah everyone loves d3 so this
is a d3 force layout but what I've done
is I've taken d3 force layout and taken
all other algorithmic code and rewritten
it using typescript and compiled it to
web assembly so basically the the
standard sort of n-body algorithm and
the kind of Hookes law spring concepts
are all being computed here within web
assembly using typescript and it was
quite an interesting experiment for me
to see how easy it is to take a
JavaScript application that wasn't
written in typescript add type
information to it and then compile it to
web assembly and work out how to
managed the interface between the two so
actually if you scroll down if you
scroll if I scroll down you can see it's
got it supports exactly the same API as
d3 itself but all the computations being
done in web assembly that that was good
fun I enjoyed that actually I'm going
one thing I'm going to do is I'm going
to get rid of that demo because it's got
a memory leak yeah I know
the final one I want to briefly touch on
is is rust has anyone used rust here
before nope definitely the wrong room
for that Oh a few yeah so rust is
gaining popularity quite quickly if you
ever have a look at the sort of metrics
Stack Overflow does a survey every year
and they do quite a lot of data analysis
and rust seems to be a programming
language that makes people really really
really happy so it's a modern language
it's a very very popular language
significantly here it doesn't require a
garbage collector it's got quite an
interesting memory model that has the
concept of ownership so every every
object that's allocated on the heap is
only ever owned by one reference at one
point in time which makes it very very
easy to reason about memory and clean up
memory it's hard getting your head
around it initially but it's a good
concept
so within rust what they did was they
used the EM scripting tool chain and are
actually investing time in creating some
better tool chains and I found this
quote actually from someone within the
Russ community that who says we're
poised to be the language of choice for
full web assembly and the reason for
that is it's a much-loved language and
because it doesn't need a garbage
collector it's actually in a great
position for for being compiled to web
assembly right now so I had a bit of a
clay with it myself I created a a chip a
time you later
so chip eight is a a pretty old engine
for for playing arcade games I say
engine it was it was one the very first
virtual machines actually it was
developed by someone who at the time
came up with a concept for a virtual
machine for playing games that could
then be incorporated into a number of
the the current computers at the time it
was a great idea wasn't terribly
successful but it's great for people who
want to experiment with creating
emulators because it's actually quite a
simple machine to emulate so for me this
was great fun having a go at rust I'd
not I'd not used rust before so trying
to do rust right an emulator which I've
not do before and then compile that to
web assembly that kept me up a lot of
nights but that was good fun but having
said that people are doing some really
practical and useful stuff with rust and
web assembly and again a lot of this is
coming out coming from Mozilla so in in
a very recent blog post they've talked
about some of the work they've done on
source maps so source maps is if you if
you're not aware what source Maps is
source maps is a technology that allows
you to map that highly mangled version
of the code that runs in your browser to
the source code that you created in the
first place so source maps are a way of
mapping from one representation of codes
to another and source map serve as you
can imagine quite computationally
intensive but the most popular source
Maps library that supports parsing and
understanding source maps is all written
in JavaScript and the team behind it
decided to take some of the most
performance critical logic rewrite it in
rust compile it to web assembly and then
evaluate the performance and you can see
here when the performance metrics they
were looking at was the time it takes
from setting a breakpoint to be able to
actually inspect your code so basically
to be able to parse I don't have parses
the right word but understand the source
map some map the breakpoint back to your
original code and as you can see here
the web assembly performance I know the
text is a bit small there at the bottom
but the web assembly performance is
these little blue clusters so a couple
of observations the first one is clearly
web assembly is is quite a bit faster in
the order of two to three times faster
but another interesting aspect here is
the JavaScript performance you'll see
quite a spread in performance and that
is because again of the nature of the
way that JavaScript is executed it goes
through multiple tiers of optimization
where it might be optimized and then D
optimized and what that means is your
runtime performance isn't terribly
predictable whereas within web assembly
the runtime performance is highly
predictable in comparison so that was
that was a fan
blog post and a really interesting read
and the interesting thing is even though
this was done as an experiment if
they're happy with it if all the unit
tests run they can put that in
production now and everyone who uses
source Maps directly or indirectly is
then going to receive the performance
boost so finally I want to do a bit of
crystal ball gazing so as I've shown you
that the current state of web assembly
is is is variable depending on language
and in terms of what people are doing
with it again there's lots and lots of
experimentation but now I think we're
starting to see the signs of where it's
actually going to be used in the future
and how it's practically going to be
used so my prediction for 2018 is as you
can imagine lots more creativity mostly
coming out of languages like rust but
we're also seeing a lot of creativity
with c-sharp I have a feeling the Swift
community are going to be very very keen
on this because Swift has a lot of
common attributes with rust it's a
modern language it's quite a pleasant
language to use and also using arc
ultimate yeah automatic reference
counting it's got a memory model that's
quite compatible with web assembly also
within 2018 I don't know if you've
noticed two days ago there was a new web
pack release version 4 and that included
web assembly support so web assembly as
a chain now allows you to import rust
directly within your code and web
assembly sorry web pack because it's
magic will do its magic and the right
thing will pop out the other ends
hopefully if you get your configuration
right so yeah if you get configuration
right it's great if it's not right then
it's hell but I also think that within
20 18 you'll start to see web assembly
sneaking into your daily workflow
without actually knowing it so as I
showed you right back at the beginning
when I create a react application it
adds 79 thousand lines of JavaScript to
my machine and most of that code is is
being used at Build time very little bit
is actually being used at run time I
think that 79,000 is going to start
going down as people start to use web
assembly to hit performance critical
parts of your of your tooling and not
thing I think you're going to start
seeing is native node modules using
webassembly I don't know about you but I
find it quite frustrating that the
workflow involved in using node modules
that have native code there's a lot of
friction there now there isn't a
terribly good reason to do that anymore
you can actually ship webassembly
instead so 2019 within web assembly
itself I'm pretty sure we'll start to
see garbage collection host binding
threading will start see web assembly
itself become a lot more powerful as a
result c-sharp and java some of the
languages that require a garbage
collector will become first-class
citizens of the sort of web assembly an
ecosystem I think we're also going to
start seeing why some UI frameworks so
we're going to start seeing UI
frameworks that are targeted that are
entirely written as web assembly into
and and geared towards perhaps c-sharp
or java developers and we're already
starting to see that I saw a project
which was called ASM Dom which was a
virtual Dom so modeling the react
concept a virtual Dom written in C++
compiling the web assembly where's next
year I think that'll actually started to
become a practical option also I think
we'll see more of our our general
plumbing move to web assembly for
example again using reacts as an example
it does some computationally intensive
tasks to do the Dom dipping why not put
down web assembly others other
frameworks for example there's a I think
called the glimmer VM which is a
templating engine which is in one of the
UI frameworks whose name I can't
remember but I'm pretty sure that will
move to web assembly as well
interestingly though I think we're going
to start seeing rust go Swift and other
languages start to gain some web market
share you might think that's a good
thing you might think that's a bad thing
but I honestly think it's going to start
happening 2020 and beyond again I'm
going to go back to that quote the web
has become the most ubiquitous platform
ever yet historically by accident the
only language that is supported by the
browser is JavaScript I think in 2020
we're going to see that that being
challenged javascript will no longer be
the only language of the browser and the
web I also think people are going to
start making significant progress
towards compiling JavaScript
rectly to webassembly again for the very
reason that javascript is a perfectly
good language for writing web
applications there's absolutely nothing
wrong with it but at the same time as
JavaScript developers start seeing Russ
developers and Swift developers benefit
from web assembly they're going to be
one things get some of that as well
my gut feeling is that the JavaScript
language itself will start to move
towards some of the typescript concepts
to allow web assembly compilation and if
you've been following the way that
typescript has evolved over time
typescript has deliberately stayed on a
relatively convergent path with the
JavaScript language itself I have a
feeling that some of these features
typing for example might become a
first-class feature of JavaScript in
order to allow us to compile to web
assembly finally I guess it regretfully
I do honestly think Java scripts
popularity will decrease a little bit is
anyone gonna throw anything at me quite
yet no maybe leave live a little bit I'm
a big javascript found myself honest no
but I do honestly think and JavaScript
has got a monopoly at the moment and and
the web platform is ubiquitous
I don't I think it's a safe bet that
JavaScript will start to have a bit of a
fight with some of these other languages
but at the same time I think the reach
of the web will increase even more so I
think through progressive web apps so
progressive web apps currently talked
about mostly within the context of
mobile but progressive web apps make a
lot of sense on the desktop as well so I
think a combination of progressive web
apps and the ability of web assembly to
allow you to do computationally
intensive complex operations will mean
things like Photoshop for example will
become a progressive web app I think
things like AutoCAD the AutoCAD team
already are looking at web assembly I
think the ability of the web will
increase or the ability of JavaScript
will it will and web assembly will
increase and move more onto the desktop
so yeah that that pretty much brings me
to the end web assembly in the death of
JavaScript and I'm gonna say no it's
it's not going to die but I think it's
got a real fight on its hands and if you
disagree you can start throwing things
at me right now</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>