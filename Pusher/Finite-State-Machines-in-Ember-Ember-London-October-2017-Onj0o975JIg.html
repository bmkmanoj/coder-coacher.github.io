<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Finite State Machines in Ember - Ember London - October 2017 | Coder Coacher - Coaching Coders</title><meta content="Finite State Machines in Ember - Ember London - October 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Finite State Machines in Ember - Ember London - October 2017</b></h2><h5 class="post__date">2018-04-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Onj0o975JIg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">quite a small crowd here and basically
decided to give this talk at the very
last minute the original plan was just
to do some live coding however started
doing some slides in the end I ended up
preparing some slides I didn't prepare
any live coding at all so I might try
and do a little bit of live coding but I
will see how it goes but please please
feel free to interrupt me at any time
and ask questions right so ma'am
finite state machines according to
Wikipedia I'm not gonna open that you
can open it she wants us so a finite
state machine is a mathematical model of
computation and probably one thing of
particularly interest about a finite
state machine is that it's less powerful
than some other models of computation in
particular the Turing machine so why
would why why would one wants to use
something which is not as powerful as
something else and I guess the the main
idea is that it restricts you from doing
certain things and it restricts you in a
good way it forces you to use a certain
formalism and keeps you from making big
mistakes
so thinking convention over
configuration okay so the formal
definition I'm gonna skip that in
particular because I don't know how to
render lay back inside of or cannot yet
so we'll just go to an example so I'm
using a tool called plant UML which lets
you describe state machines amongst
other things that also lets you do some
activity diagrams and just general other
UML stuff just really cool
wonderful doesn't zoom the image can you
see the image at the bottom okay so this
is a simple state machine it has two
states who are called locked and
unlocked its initial state is locked
over here so this little dots is an
indicator which shows that this state is
the initial state and this all the
arrows are called transitions so this
particular arrow is kind of like the
initializing transition it's implied and
the state machine accepts two types of
actions or and the mathematical
formalism cookie called alphabet or the
input alphabet but let's call them
actions so this accepts the push action
and the coin action cone action
corresponds to you putting a coin into
the turnstile and the first action
corresponds to you trying to push the
turnstile so if it's locked you put in a
coin it becomes unlocked you can keep on
putting coins that doesn't change the
state but as soon as you push the trans
no becomes lock together and what you
can notice is that you can't push while
you're in the locked state or at least
this machine does not allow you it's a
push in the lock state and this is on
purpose so it basically prevents you
from doing something bad
let's look at another example a little
bit longer so one two three four five
six two three four five six seven states
so probably the most interesting part is
the names of the transitions so here so
we have an initial state a we have a
final state F so that's the so this
indicator is that means this is the
final state you can't transition from
here like once the state machine reached
that state that's it the program is
terminated so you might want that or
might not want that the previous one
didn't have a
like that so the shake machine lives on
forever so what does the state machine
do it accepts an action called e then
okay this is really bad
this a an arrow which loops upon itself
also labeled with E then it accept then
there's a transition called M transition
called B position transition called e
then another one which loops upon itself
called E and a final one called R and
I'll show you what it does in a minute
this over here which brings me to
applications of state machines and
software so one of them is regular
expressions or to be more specific
it's regular languages which is a subset
of regular expressions but I'm not going
to go into too much detail about the
differences so if you look at this as a
regular expression and either takes
letter e one or more times or a letter a
one or more times then the lettuce MMB
and then the letter e one or more times
and then finally letter R so this
regular expression corresponds exactly
to the to this state machine right here
so you can use state machines to model
your application behavior so that's what
you would call a state design but
they're also pretty good - modeling
event-driven behavior which pretty much
old front-end applications are I mean
they're way too user inputs and react to
user input
so look what what else is there I can
try and do some live coding just as a
little illustration so it's number
twiddle let's just create a components
okay so I'm gonna make a component which
lets you log in and log out just just
playing a button sorry can you remind me
what the value
this work no thank you
okay here we go can you see that maybe
okay it's gonna make it harder to edit
the coats but whatever okay so this
button does nothing for now let's say we
and actions hash would you login
actually so usually when you log in it
okay so um I start off with this okay it
doesn't do anything because we haven't
connected the action button on okay here
we go
okay so
and we went from logging to logout do
the same thing to work out
okay login logout okay now this is a
little bit unrealistic because usually
if you log in you need to send an HTTP
request to the server you need to wait
for it to authenticate so it's going to
be an asynchronous action so we could
say so how could we emulate December run
later let's say we run of the second
later so we click login and this didn't
work because we need this there we go
so what's the problem with this you can
click login several times so we might
want to we might want to disable the
button right when we click it so this
set is enabled say the component what do
you do this should be binding is this
gonna work
nope
are we going something happens okay so
we probably want the well thank you
sorry there we go so that worked we'll
look back ouch oh look the buttons still
disabled alright so I guess like that's
the the smallest example I could think
of right now to illustrate the benefits
of a state-based design so so what's
happening here if we look at the code
over here so we have an online boolean
variable and we have a disabled boolean
variable so each one of those can take
one of two states so the total state
space of our components is actually two
to the power of two which is four
however what we really want is only to
have three states so we want the state
where we see the login button we want
the states where the login button is
disabled because we're currently logging
in and we want the state where where we
logged in and we have a lookout button
and when we click that we want to end up
in the states where we just have the
login button which is enabled right so
of course what we can do is we can also
set this
so this works but let's say all right
I'm not gonna try and come up with more
complex examples the thing is like once
you start adding more and more boolean
variables you can end up with a state
space which is potentially huge whereas
what you really want is only a very
small subset of those states and what
can happen is if you if you change the
code at some point somebody doesn't
there's a pay attention to what one of
the boolean variables does and you might
have an inconsistent UI basically all
right let's let's go back
so the right couple Oh actually this is
exactly the example that we had so there
are couple simplifications two state
machines so basically this is a state
machine which has three states
disconnected connecting and online
however we can group two of these states
together and they're a super state
called offline now this can have several
advantages one of them is for instance
if you want to render something in the
in the UI if and only if you're in the
offline state you can just check is your
state currently offline rather than
checking explicitly are we disconnected
or connecting so it saves you one end
and the in the template what else so
over here we have a transition called
disconnect once that transition is
initiated the me as the program it
shouldn't really worry about do I want
to go into the disconnected state or do
I want to go into the connecting state
and that's because we have a default
state so inside the offline state the
default state is gets disconnected so
once I transition back to your fine
state then by default I end up in the
disconnected state so it's just
basically a way to save yourself some
extra so I guess like the other one
which we which we don't have here is if
we had an action going from from the
offline state and this basically means
that we want both the disconnected state
and the connecting state to behave
exactly exactly the same manner when
that particular action is called then we
would draw the action from the offline
state and I'll I'll draw the parallel to
ember in there in two slides okay so oh
oh here we go
so the other simplifying concept in
state machines is concurrent state and I
guess concurrent state pretty closely
corresponds to what you or I think this
particular one pretty closely
corresponds to what you get if you use
boolean variables so if you have three
boolean variables then let's call them
no mwah num lock caps lock and scroll
lock and this pretty much describes this
particular state machine and so this is
supposed to model a keyboard which has
three modifier keys so you press num
lock and then depending if num lock is
on or off you go into the other state
program lock
similarly for caps lock and scroll lock
but they are independent of each other
so basically this state machine has
eight states over all two to the three
so I find this is sometimes a helpful
way to model this if you're drawing our
state machines but in terms of
programming it doesn't really make
things easier so I think it's easier if
you do want to have concurrent state
then you just basically define two
independent state machines and then your
overall state as the basically the
product of these two states
mathematically or you just use boolean
variables okay so embrance States so I
have a copy of amber GS and my my drive
and I just run a grep for a current
state and these are my results
amber glimmer amber routing a number of
views and I'll get to that in a second
I also ran it on amber data and there's
a couple more add ons sorry a couple
more results but I guess the most
important one is this one model
and it's rental model both of them so
amber does use some state machines
internally
what are they okay so um I'm not gonna
fool all of them I'm just gonna
concentrate on amber routing mostly well
I'll talk briefly about amber routing Oh
talk briefly about Amber data
amber routing which hopefully you're all
familiar with so an Amber routing you
define the state machine yourself or
rather you define the states of the
state machine and you defined the
transition rules and then amber takes
care of setting your current state and
your current state is the route in which
you are in we do have some hierarchical
States which are basically nested routes
state dependent and behavior is invoked
by using this dot sent sending an action
on our routes and you can transition
between states explicitly by using
transition the transition to function
and amber routing has a couple nice
goodies including bubbling affections
and the activate and deactivate hook so
which basically lets you do some cleanup
work or some set up work independent of
how you enter relief route so amber data
also has a state machine however that
state machine is defined by amber data
itself
it's a hierarchical state machine with a
couple almost concurrent definitions it
used to use a library called member
states this library is now not supported
by Amber officially anymore so basically
the code was half copy and paste it on
modified and styling and so it's amber
data so I dug around a little bit and I
managed to come up with a following
diagram so this is the source code
and as you can see a lot of the
transitions are commented out because
basically they would completely blow up
the diagram here we go that's the heat
picture and people who've dealt with
amber dates are probably familiar with
some things like the the root state
route that loaded route that loaded that
created route that loaded that created
that uncommitted or in flight and so
forth updated
there's also routes that empty and
routed loading actually there's quite a
few states state-transition missing from
here so I tried to make a slightly
simpler diagram so basically number D
that you start out when you create a new
Amber and the data model this model
starts out its life cycle inside the
empty state work really its root empty
but I'm not going to write route
everywhere so it's empty
then what's your loading data its
loading if it's loaded then it's in the
loaded safe state if you created the
model yourself locally then it will be
in the uncommitted state so although
these are basically newly created models
these are models that are loaded from
from the server and these are models
that are about to be deleted so like
once you delete a model it's not delete
it immediately you need to call that
safe on the model and I'm basically the
transition inside these states over here
and if you look at the sub states
they're actually quite similar so this
and flight saved and uncommitted and
it's the same for the for the loaded
state sorry
for the for the create it in flight I'm
committed and flight and uncommitted so
if you look at the actual implementation
like some things are sort of similar but
some things are slightly different so
what's the amber data guys did is they
used object orientation and inheritance
of objects to emulate similarities
between different states so it's not
really truly a concurrent state machine
anyway so this brings me to what else
can you use state machines for when
state machines for models we had state
machines for routes there's also some
internal state machines for components
the the certain components life cycle I
haven't looked at exactly how that works
so I'm not gonna talk about that but two
natural things which I guess you could
see from my example over here we're
modeling a component so anything that
has semi persistent dates so not data
that you might want to persist to the
server but data which is long-lived
during a session and might change States
and like a number is one of two things
either it's a components or service so
these are the two most common use cases
so this the amber States library
actually gonna this is not the the
github library as you see but this is
some documentation code for amber
version one release candidate three
after which this library was removed
from ember proper but it shows how to
use this thing so you create a state
manager inside the state manager you
create a couple of states so this is
hierarchical as you can see and then you
use transition to transition to other
states and I think this is a full exam
points either beautif
your initial state powered down it also
has some enter and exit hooks and I'm
not sure how you explicitly call the oh
here we go
no just a create yeah and you sent to
send an action so this is very similar
to the routing thing and I'm not sure if
amber state was ever intended to be used
in the router or whether it was used in
the router but certainly the
terminologies is similar however it's
not really maintained anymore and I
didn't really like the fact that you
have to create a state manager and then
then estates and like just basically
creating lots of extra objects so the
next example is IV stateful one-star
I've watch's 0 Forks man commits 3 years
old there's not too mean it's bad though
this is actually a lot simpler so it
uses a basically exposes one mixin and
lets you define your state machine on
this object fluid States so the roots so
you have the product state over here the
idling state over here and first first
gear state over here each state can have
its own properties and each state has
transitions or sorry actions
you also have an answer and an exit
action presumably to working as the
enter and exit okay and you move between
states by echoing transition transition
through so relatively similar
what does vehicle oh yeah and every
state receives
the state machine as the as the first
parameter and this is how you such
states presumably but as you notice this
doesn't let you have hierarchical States
and yeah I don't like the fact that you
get this vehicle thing over here inside
the action you have to use this route
State thing over there and you're sort
of yeah that's it I have an initial
state so that's good anyway there's one
more actually it's two more so we'll get
to that so this one is a lot more
popular also hasn't been updated in
eight months a lot more commits I
haven't examined it in too much detail
but from what I can tell it's basically
seems to be just as complex as the as
this one as number states plus it claims
that it is promising where and I'm not
entirely sure what that means so but I
guess one of the biggest downsides is Oh
to downsize it's rather complex and it's
also not hierarchical so you define your
state's over here and every state has a
lot of different hooks will enter it did
enter will exit did exit and here you
define events so events are like actions
and there's some extra stuff that you
can define in actions and then basically
this tells you that if you receive an
action event and you are inside this
state inside a wake state then your
transitions the sleeping State or
something like that
I basically if I didn't understand
immediately how it works and plus you
get these macros expand on those states
a minute
so I didn't like this so what do you do
if you don't like something okay
I'll show you this in a minute but I'll
tell you my motivations behind this so I
wanted to have somebody intuitive so I
like the sari I like the original member
states to the extent that it uses some
terminology were familiar with it uses
transition to and it uses scent the
scent sends an action position to
transitions to the state I wanted to
keep that moreover I wanted to keep the
actions hash because we already use that
for actions oh and I wanted it to be
hierarchical so I wanted to use the
actions hash and I wanted to have
bubbling justice you doing routes so if
you return true and from an action it's
going to bubble up to the year to the
next state above and one conscious
design decision was that transition to
as asynchronous function so basically if
you don't concurrency if you don't some
asynchronous stuff you have to take care
of it yourself so and we'll come back to
this with the example in a second okay
so it's mostly three months old I expect
this to go up after tonight users is
just a simple mix in so like the entire
add-on
it's just one file about 140 lines all
it does is overwrite the scent the scent
method right
okay so a okay does something in the and
and the ended thing and yeah and it
overwrites sorry it overwrites end and
yeah and it adds transition to so let's
have a look I know what to use it you
define your states explicitly inside the
state's property if you want
hierarchical states you use dot notation
so on dot idle is a subset of dove on
I'm detective is also subset of on no
complicated nesting of hashes or
whatever and you define your actions as
you would inside your actions hash
however if you want some actions only
happen in specific States then you
create a property inside the actions
hash with the name of the state and you
define the action inside inside that
state so for instance if you are inside
the on state and if you call turn on
then it will execute this we're turning
on but then it will actually bubble so
it was execute this bit
if your insights if your insights what
I'm missing off okay so if your insight
off
we don't have often side the actions
hash because there's no specific actions
we want off to take so if we don't want
any specific actions to happen we just
put them just at the top so if you're
inside the off state then and you and
you send turn on then the default action
will be executed so what's the advantage
of this basically you can add this mixin
without modifying your existing code so
unless you have the state's variable use
it use for something else you can just
add it and then gradually improve your
components or services the other thing
that it does we expose a property called
state and that property is quite clever
so if you're inside the off state then
this will be true fish so this will
actually evaluate to a hash to an empty
hash which in JavaScript lenders truth
ish so you can use this in templates
quite easily so rather than so for
instance over here if we had the boolean
variables for idle and active over here
we would have to do if and sorry if were
idle active but instead we can just do F
state on some description about
asynchronicity
anyway let's let's go back to our
example right at the beginning things
this one right and let's see how we can
gradually make this into an stateful
components so the first thing you do is
we talked into paste some code from here
okay my components we import stable and
we're stateful and thank you yeah
and it's working okay so what are the
states that we once we want the state
were the botanist sorry with a button
this says login and it's active where it
says login and is not active and when it
says log out so logout and so this state
could be a fine
the next thing could be connecting next
day could be online move this
we immediately start connecting okay
know what I'm doing here is not very
nice but and I'll show it to do it
properly in a second just trying to
replicate the sorry thank you
okay again no something wrong no it's
not
okay
ah Joseph father yes thank you
so we didn't have a state for the
connecting thing so basically here we'll
need F States is offline or state as
connecting and will mitigate this
problem in second and one we want it to
disable if we are connecting what's
wrong this time or is not a helper okay
what's the NB truth filters simply look
up the recent version that works so
gonna work once we all
wait oh yeah that's the yeah that's
something I prepared earlier this is our
example right okay here we go
so a works like a charm
however this is quite ugly so we have an
or helper over here so maybe in these
two states should be grouped together
under a super state we have the
component I guess let's call that super
state actually let's call it offline and
I have two sub states called connecting
and disconnected
okay
okay so this didn't work because this is
wrong huh thank you okay so if we're in
here transitioning to offline connecting
okay also what I didn't mention is some
of the other implementations if you're
inside the sub state then sometimes you
don't have to specify the full substitue
you want to position two if it shares an
ancestor so lets you take some shortcuts
like if we were in the disconnected
state we could say transitions are
connecting rather than transition to
offline connecting however I think this
is a bad thing it's error-prone and I
insist that you always specify and state
explicitly okay this is all fine as you
notice here this transitions to the
offline state so what does that mean so
we click on logout in the offline states
so there's one more property exposed by
the stateful add-on and that's called
iron state just as it's called and some
of the other some of the amber source
code be careful
don't mix it up with underscore current
states because that's something actually
used by the amber framework on
components we go offline disconnected
offline connecting online log out of
line disconnected so why is it
disconnected because because it's the
first one exactly so I didn't want to
have an extra property called initial
State
it's just the first one
so what happens if we what if that's the
next one okay so we start out on the
connecting States and we basically
screwed because we can't have this talk
like this okay let's try it differently
what about the online state first okay
no this is not ideal as well okay what
happened here yes exactly and that's
because it's the the first one as well
so during the set up we go through the
entire state hierarchy and we for every
super States we always set a default sub
state and this corresponds to the order
of the states so I thought that's sort
of a nice simple way to a very concise
way to restrict yourself from doing some
things and having to do them manually
it's probably two more things I could
show one of them is okay let's let's
have this one mess first
we keep another five months okay so all
right so it also works like they don't
have to be in any particular water
either it's it's clever enough to figure
out that this and this have a common
super state what we can do is okay let's
make another button say two more things
like a shot
thank you this new keyboard
Houston okay
let's say we want people we want to
prevent people from trying to log out
while they're already logged out so we
could put this log out action inside the
online hash so this corresponds to this
action and basically this says if we're
inside the online action then execute
this when we send log out okay so what
happens we log out and everything is
fine so if we have to we did this
everything is fine okay
what happens if we click this error okay
let's try it again
error can make this how do you increase
the size of this sorry plus okay route
action named log out was not found in
the component and that's because we the
only route action we have is log in so
we could have another go actually
if we're actually logged in then then
it's fine
how did this what's expected through
this inside here that executes both
actions right so that's that's bubbling
for you right there okay one final thing
if we have another two minutes
is that right because basically what
we're doing here is we're defining two
transitions inside a single action
so we're saying transition to offline
connecting and then later at some point
we transition to online so this is
conceptually not great so what we could
do instead is inside the off line
connecting said the offline connecting
state we have the interaction this
golden here
so this indicates of the connecting
state there's pretty much nothing else
but just wait for a promise to resolve
and then at the end once it resolves it
transitions to a different state what
are the advantages of doing something
like this
let's give it a slice that's - it's like
a longer time out
make sure it still works yeah it still
works okay let's say instead of doing a
dump logout we do a stop action
basically stops whatever you doing okay
well it does pretty much the same thing
as log out for now it's the only
difference is there we go okay well what
happened there so I mean we're already
disconnected that's fine if we're online
stop we'll disconnect actually you know
what that's called
yeah let's keep it cold stop so so what
happened here okay clog and then we
click stop okay and then we then
something happens
basically we're while we're inside the
connecting states we're clicking stop
we're transitioning synchronously to the
disconnected State however later this
promise results and we have another
transition into the online state so
probably what what we meant is that we
want to cancel the connection so inside
stop
we could call number one cup cancel this
gets tea
stop this works as expected
however okay what happens if we call
stop over here again actually nothing
happens I was hoping that was gonna be
an error because you're trying to cancel
a timeout which has already been
cancelled or whatnot or it doesn't exist
anymore but as you can imagine like if
you're trying to cancel a promise or try
to cancel an ever concurrency task for
instance and that sauce is not running
again it's like something unexpected
might happen so this is exactly what the
exit action that's good for as basically
says like once you're transitioning out
of this specific routes we can do some
cleanup work so in this case we go again
stop again online stop work is expected
and what's the other advantage of that
now stop has exactly the same
implementation as logout well actually
let's go back to it was before
yes so before stop had the cancel and
then transition - no it's exactly like
the logout growths in fact over here we
can just call the action log on and we
can remove this so it's like another way
you could have done it as you you know
cancel I'm out then you do this that's
and log out whoever you're chaining more
than one actually on to each other and
again it's an easy way to get lost so I
think it's much cleaner if you handle
this with enter and exit actions and
like basically it's a nice way to
display asynchronous states and your UI</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>