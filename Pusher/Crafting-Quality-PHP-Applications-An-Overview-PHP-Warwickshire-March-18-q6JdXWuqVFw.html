<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Crafting Quality PHP Applications- An Overview - PHP Warwickshire - March 18 | Coder Coacher - Coaching Coders</title><meta content="Crafting Quality PHP Applications- An Overview - PHP Warwickshire - March 18 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Crafting Quality PHP Applications- An Overview - PHP Warwickshire - March 18</b></h2><h5 class="post__date">2018-04-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/q6JdXWuqVFw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is James Sikkim I come from East
Yorkshire used to be
Portsmouth but I move recently I work
for this group of freelance consultant
training people called rove we can come
along in your business and we'll charge
you lots of money for you to ignore our
advice
so instead tonight I'm going to give you
that advice for free whoa like free
stuff so this is how we do quality stuff
in PHP right we we add you sleep with a
build number in to our code and then
when the business complains that the
code is getting slow we remove it an
instant profit that's not how we do
quality so what is quality right it's
kind of a bit of a vague word perhaps
what does it mean maybe it means
something like really
precision-engineered maybe less so these
this particular brand of laptop these
days but traditionally perhaps you know
meticulously created with a lot of
attention to detail very finely crafted
and so on well maybe it's something like
a Land Rover the British cars well known
for their durability they're built with
quality components that are resistant to
mud and rust and bombs possibly and
they're built to last a long time or
maybe it's something like carpentry
where you spend a lot of hours putting
in a lot of you know handcrafted a lot
of love you make a lot of mistakes
potentially I certainly do with my
carpentry and you know you you put a lot
of persistence into that so I think we
need more of this in software not just
PHP applications but all kinds of
software whether it's front-end or
back-end but I'm going to focus on PHP
because that's what I do a lot of so
quite often I've had discussions with
colleagues that end up in agreeing that
the best code is no code at all
unfortunately this is not very practical
because you'll get fired very quickly so
maybe don't do that so we need to make
some trade-offs we need to be practical
about what we're trying to do okay and
it's worth mentioning that we don't
always need to make high-quality PHP
application or web application
for example if you prototyping stuff
making a short-lived brochure site
that's gonna be only be chucked up for
like at one or two weeks and it happens
right maybe we don't always need this
high quality well tested well built
following all the best practices
application all the time what I'm going
to talk today is about products about
stuff that you will work on for several
years of your life or maybe if you're a
consultant or freelancer or contractor
you'll come along to a project and the
project will probably outlive you
perhaps but you still need to put in
your best effort to make this a good
quality piece of software and what I
find quite amusing or not musing what I
find interesting rather is the correct
word is that open-source software very
much mirrors a long term project or
product and they share a lot of similar
traits right open-source software is a
long-lived project itself right hope
most of them are so what's quality in
applications this is not a specific
thing this is not just about writing
neat code and stuff like that
this is about the whole process this is
about planning and thinking about what
you're going to do is about developing
it documenting it testing it automating
those tests doing things like code
review and then deployment enough to
care afterwards so there's a whole
process and I'm going to have a look at
some of that stuff today with you as
quick as I can it's a bit of an overview
because I've only got an hour and I'm
trying to fit like however many years of
experience I have into a very short
amount of time so I'm not gonna lie this
stuff does take time and therefore costs
money right time is money so but what I
found over and over again is the
investment upfront in building a good
quality piece of software will pay for
itself and it's key this quote summed it
up nicely a freelancer at $25 an hour
for 100 hours still costs more than a
freelancer $150 an hour the cost that
takes 10 hours to do the same task
and this rings true over and over again
some of the contracts that Rover hire to
do will be saving a project from going
down in flames and we will come along
and say you know you asked us you wanted
to hire us like a year ago and now your
project is failing why didn't you just
hire us the first time you just over it
too expensive but now we can come along
and fix it and it will just cost you a
lot more money because you've wasted it
never mind get an expert in I'm not
saying hi Rove but you know do but
getting someone who knows what they're
doing is really kind of important right
whether that's someone in your team or
whether you want to hire a consultant do
a bit training or something to make sure
that you're knowledgeable but
knowledgeable as possible about what
you're building they can train you they
can mentor you they can set you in the
right direction right even if you're a
senior developer it helps to have
another sounding board to say I've had
these great ideas what do you think
right and if you're in a company of like
two or three developers and you're the
best developer there you've got no one
else to talk to you to tell you that
your ideas are terrible right and we
need that we need to be told that our
ideas are terrible or hopefully they're
a good idea and that we can develop them
all right maybe you said that in a bit
nicer way that your ideas are terrible
maybe it's not not great people skills
there but this talks not about people
skills entirely so yeah
these tips I'm going to show you today
are from my experience of working with
high complexity applications high
complexity software long lived products
open source software and I'm going to
give you a disclaimer that hopefully not
all of this is new to you if it is great
you're gonna learn lots if not you know
this is good advice and hopefully you
will agree that this is good advice at
least some of it
it's very opinionated but it's okay in
reality there's no secrets building
great college quality software it's
about following processes and
can show that you know when to cut the
corners when not to and so on I'm sure
we've heard that many times before and
maybe the not so experienced people will
always think well what do they mean by
that but then as you get more
experienced you will realize what it
means to know when to cut the right
corners because if you think oh okay
I'll cut this corner and then like yeah
a year down the line you think I
shouldn't have cut that corner then you
know not to do that again or why it went
wrong so you can fix it next time and
things like that so experience helps a
lot but following processes is kind of
important there's this planning stuff
the developing the testing and things
like that just do it all right all of
this stuff let's have a look at it we'll
start off with planning is this an
integral part of software believe it or
not often not done in enough detail at
all sometimes completely overlooked yeah
let's do this
okay great dive in start writing some
code it's not how it should work
hopefully we do at least some planning
and have some kind of discussion maybe
some kind of they expect Docs that tell
us what we should be doing that's not
always the case
planning is if effective planning is
rooted in good communication being able
to discuss with business stakeholders to
say what we trying to do right and
that's not just spoken communication but
it's also all forms of communication
email documentation you know writing
things down in a big document to say
this is this is the big specs document
or breaking things down into user
stories if you like however you want to
do that it's about effectively
communicating and discussing those
things when you are discussing things
whether it's through verbal
communication which is going to happen a
lot hopefully but when you're planning
these things out you need to be strict
on using the business terminology don't
talk about how you're going to detect a
mime type from store some xml's and s3
and use a sax parser to extract some
data because it needs nothing it means
nothing to the business right the
businesspeople that you're working for
you know more often than not will not
know anything about tech so their eyes
will glaze over and they will start
thinking about how to make money
elsewhere in the business right it means
nothing because it doesn't describe the
behavior of the application instead we
need to talk about things like how a
user can upload their bank statement and
reconcile the transactions against their
accounting package that's much better
it describes exactly what the
application is supposed to be doing and
instead of saying things like user we
need to use other terminology like my
accountant can upload their bank
statement the statement statement from
NatWest or whatever and reconcile the
transactions and so on and that allows
the business stakeholders to be involved
in that conversation and that is really
important because they know how the
businesses work and I've learnt this is
more and more important as I've become a
freelancer and I've come into a company
and suddenly I need to know everything
about what this company is doing and I
need to do it as quick as possible
so the only ways to do that is to engage
with these people right they're not like
weird demons or anything like that
they're not going to bite our heads off
it's fine you can talk to them all right
and we have this flowing conversation
and so avoiding things like jargon is as
well all right so that goes to the other
side as well if they start saying oh you
know we're gonna do something with our
foot see and whatever all right I notice
the stock exchanges fine but you know if
they start using acronyms that you don't
know what mean then call that and say
what does this mean right and that may
be something specific to the business or
it may be actually a terminology that
was rooted in you know some developers
ages ago maybe in a previous job that
they had and they said oh you know we
use the mime types like why are you
saying mine types you don't know
anything about mine types all right
because we've instilled in them that
that's important
another offender is like treating
everything like an Excel spreadsheet all
right we want to avoid that we want to
try and figure out what the business
process is
if the business processes are we stick
this thing into a spreadsheet we send
the spreadsheet to someone else and then
if someone else handles that and turns
it into a nice printed PDF or something
right that's not really a business
process that's how they carry out the
business processes so we need to kind of
understand why this for the astute among
you who are versed in this thing called
domain driven design which is all very
popular these days in PHP anyway it's
been popular in other languages for
years this is called ubiquitous language
I'm very keen not to enforce on you ddd
concepts but this is a good one to pay
attention to so if you do any nothing
else but this this is what you should do
use business language so we need to
explore and discover and find what
reasons why changes are being made we
want to build a comprehensive picture of
what's going on all right don't just
accept that spec that says oh can you
add this crewel feature okay great it's
not how it works right we need to
question things we need to explore a bit
deeper we want to understand the motives
why are we doing this you know what
business problem is solving what do you
want to achieve and why and so on
we want to discover the intentions over
the business so then we can build a
model of it this is not a physical model
right this is a shared mental model
alright we're not playing games workshop
games at the moment we're doing software
so we need to discuss this and visualize
it even if for merrily right that's ok
as well we need to be able to distill
that conversation down so we can refer
back to it later whether that's by doing
processes like event storming you don't
have to do this but drawing things on a
whiteboard works beautifully right
whiteboards are greatly lit there's on
here you can write on them rub them off
and have a conversation you can all
stand around it right how many times
have you done that so many times all
right hopefully if you haven't try it
because it's so that conversation flow
is so dynamically and write down the
important things of course right but you
can use post-it notes you don't have to
follow event storming this is Alberto
Brandolini
technique for sticking post-its on a
wall you don't have to follow these
exact procedures just use post-it notes
however you want at the end of the day
it's all about that communication and
that conversation that you having and
then we can document it right we can
digitize it and these graphs and stuff
that you can build you can put straight
into the documentation and hey you've
already started documenting your
software and we haven't even written a
line of code yet whoa but businesses
change they keep changing
that's annoying so we need to be able to
plan for that so we need to understand
that businesses do change sometimes
drastically right
I've worked at companies a company one
before I joined Rove for two or three
years I worked there and then suddenly
the course of the business completely
changed and we work with it it was okay
it does happen right so your model needs
to be able to change as well with it so
you need to keep your documentation
up-to-date as well so when things like
that happen when changes happen have
more discussions write and update those
documentation and that as we know our
data documentation is not useful at all
so development this is the part we've
get out right we need to care about our
code right and I said it's not just
about code quality and code style and
things like that but it is a facet of
that style layout consistency structure
and things like that right think about
other professions plumbing you know dude
does a plumber leave sealant and mess
everywhere and bits of pipe lying around
after they finish their job hopefully
not otherwise maybe you got a crappy
plumber should tidy up after themselves
an electrician right same thing
do they just leave wires dangling around
so you can walk around your house
getting electrocuted no so why is a
programmer do we feel it's okay to write
rubbish
looking software that no one can
understand because
the next person that comes along and
tries to read that code will be like
what is going on here what was this
person thinking were they drunk it's
quite possible they were but hey yeah we
need to care about how things look
luckily most of this can be automated
we'll have a look at that so there are
only two things two hard things in
computer science cache and validation
and naming things and off-by-one errors
this quote the original one attributed
to filled Carleton and he's highlight
something very important isn't that is
relevant to the conversation we were
just having about planning because
naming things is really hard right it's
about a balance of being conscripted in
concise
for example simple bean factory aware
aspect incidence factory tells you
exactly what it is doesn't tell you why
this is from Sprint framework and Java
if you're not not familiar with it and
it's a thing and it's okay but it's
maybe not the best named thing arguably
all loader that's the opposite right
what is it loading why is it loading
whatever it's loading we don't know it's
not giving us any intent so there's a
balance and I've used the word intense
several times intentionally what we need
to ask ourselves what does this thing do
and why does it do it if the answers
aren't clear then we need to go back to
our domain model and we need to go back
to that planning stage and talk with our
peers the business stakeholders that
know what they're talking about and try
and figure out the answers if you can't
it's okay to give awkward names to
awkward concepts there was a talk from
the DDD book author Eric Evans which
sums this up perfectly in the talk was
about imperfection in software design
those who have adopted DDD feel very
dogmatic about it and they want to make
everything perfect
and modeled beautifully but Eric in this
talk points out that that's not the
point because business processes aren't
perfect right there will always be flaws
and therefore there will be or should be
flaws in your software so if it's not
quite quite figured out what's going on
yet it's okay to give it a weird awkward
name that you look back and think yeah
I'm still not sure but then one day it
might click and you think ah this is
where we were going wrong you can go
back to that and it's like a market to
say you know the waters are muddy here
let's fix this fix this later it's like
a to do right also helps to write to do
buy it yeah solid who doesn't know solid
okay cool
right I have to go into that keep it
simple just do it right as developers we
love in general I generalize a lot
sometimes I was like a real meta joke
and I didn't even really do it
developers have an overwhelming desire
to over complicate things right we've
read you know technically minded and we
overthink things and over complicate
them so let's try and avoid doing that
because you know what if we make things
more complex it makes it harder to test
it makes it harder to document we need
to plan it in a lot more detail and you
know maybe by overcomplicating we've
actually completely missed the point of
what we're trying to do so stop thinking
about like how many Redis clusters
you're gonna have and whether you're
gonna have a rabbitmq or a 0 mq because
it ultimately doesn't matter what
matters is that we're solving the
business's problems who's heard of
object calisthenics ok cool only a
couple there is a talk which I won't go
into too much detail here because
there's a whole talk about this talk by
Rafael domes some with Brazilian guy who
moved to Amsterdam
some time ago he's not that weird don't
tell him I said that Danny's have been
filmed sorry Rafael
object calisthenics talk in in it's
about trying to help reduce the
complexity in the code itself right not
necessarily the domain model in its
rules or rules you don't necessarily
always have to follow them but a good
practice I suppose one level of
indentation per method right so instead
of having this huge so this way for you
guys
huge load of indentation which you know
we've seen the Hadouken thing and not
jokes like that avoiding things are
things like avoiding the else keyword
that's an interesting one right and
that's taking into practice things like
return early and so on and actually
things like that make code more readable
in theory wrapping primitive types and
strings and so on alright we'll have a
look in a bit more detail in that in a
bit
one object operator which is basically
obeying the law of Demeter the principle
of least knowledge alright so this talk
goes into detail about what these things
are if you have no idea what I'm talking
about it's fine just go and watch that
talk I'll dig the link out for you after
ooh and you can have a look at it later
I recommend it highly avoiding early
abstraction is another good tip we're
told constantly don't repeat yourself
you know if you have to write the same
code twice than you abstracted away and
and things like that but there is I
think more nuance that we should apply
here there is a careful balance between
early abstraction which is when we've
done the wrong abstraction and the way
to overcome this is by looking at your
domain model and thinking is this model
clear about where abstractions to happen
and if not don't create the abstraction
right a good quote from a colleague of
mine code for your use case not your
reuse case that is to say just code for
what you're trying to do and stop trying
to think about everything that your code
could possibly ever do all right
well see if there's the next task you're
about to work on is something that you
need to plug into it and that makes
sense right but you're about to write
that code but if it's just an idea of
thinking
oh yeah that would be who maybe we could
you know have this abstraction so we
could do this in the future you'll never
get around to it because you've not been
asked to do that that's not the use case
of the code caring about your API and I
don't mean web services here I mean your
classes public API the thing that
defines in libraries whether there's
backwards compatibility breaks and
things like that and how many times have
we used a library and then suddenly this
method that we are using has disappeared
if you don't know what that is that's a
backwards compatibility break so the way
to overcome this is by making everything
private by default not protected you say
no not protected because protected is
still public API you can extend your
class and use that right so therefore
its public API properties can keep State
that's fine make them private but your
public methods should have strict
invariant types for the return for the
parameter type declarations and return
type declarations now they're
interesting quote about this object a
public method is like a child once
you've written it you're going to
maintain it for the rest of its life and
it's so true and that's why we have
semver right and then you have the
libraries that say they're following
cember but they don't and maybe this is
why most of the nodejs ecosystem is
still on zero dot whatever so we don't
care about backwards compatibility ah in
your face consumer so yes strict type
declarations so we you we should be
using strict types by default if for
those of you who follow me on Twitter
I'm sorry there was a recent debate
which I tried very difficult they're
very hard not to get into and I
succeeded recently there's EV was
discussing about how strict type
declarations were rushed and stuff like
that and but the point is is so many
libraries have adopted just using strict
types types and that's the right way to
go I strongly believe you may disagree
but that's alright we're allowed to have
differing opinions
right they matter for things like basic
things like ID introspection right it
helps you know what your your methods
expect and what they return and things
like that at the very basic level
they're visible in reflection if you do
weird things like that hopefully you
don't but it reduces that cognitive
burden one on your mind to say what does
this function want what does it give
back to me but also it allows you to do
this this thing called static analysis
right static analysis is this thing that
you may have may not have heard of it's
basically looking at your code without
running it and saying this code is good
or bad or this might code code might
break here or we might break here
you know this parameter should be this
but you're giving it this and things
like that right so I encourage using
this because you'll pick up bugs a lot
quicker something that we've had for a
long time is object type declarations in
PHP at least for parameter types we can
now return things have return type
declarations as well but using things
like value objects if you've never used
a value object is basically
encapsulating a value as the name may
suggest into an object and the object
has its own validation here so this is
kind of very you know it's the typical
example email address is another one you
know you're validating against regex
just to make sure it's looks like a
valid one but note that there's no way
of changing the value here ever there is
ways but they're really naughty and
don't do them the class is final so you
can't extend it the constructor we can
make it private and do it like from
string perhaps so you can have multiple
named constructors if you like but it's
roughly looks like this right so you can
cast it back to a string and you can
give it a string and that's all you can
do but every time you want a new value
you create a new object to go with it
and what this means is there's no way of
ever creating a new valid postal code
so value objects used in this way
give consistency in your code and it
allow you to set your expectations very
clearly for example this assigned postal
code method here if we give it a postal
code and try and instantiate a postcode
with the string one two three or four
five that's not what not valid for the
UK that will throw an exception if we
try to assign assign a postal code with
po1 one a a then it will work because
that's a valid postal code and if we try
and Plus+ it in number one two three
four five if we've got strict types on
that we'll throw an exception otherwise
it will actually just cast it into a
string which is just messy but the
assigned postal code method it can now
make assumptions like that postal code
is a valid postal code it will only ever
receive something that's valid so you
know we could put that into a database
and it will always be valid and when we
take it back out of the database we
stick it back into that value object and
pass it around and anything that expects
a postal code object will always get
divided one if it comes back out the
database and it's suddenly invalid maybe
you changed your validation or maybe
someone tampered with the data so
testing ah yes
testing we all know about testing right
um we all know we should probably be
testing better who is happy with the
amount of tests that they're doing
really I asked the question worded very
specifically because as PHP developers
you know we write code we hit refresh or
make the post of an API call whatever
we're doing right and that's testing
right
we don't just write the code and throw
it over the fence we test it first it's
just we do it by hand all the time so
who is happy with the amount of tests
they've written for their code okay
who doesn't write any tests all right
testing is not a separate line item
often I will get told my boss doesn't
give me enough time to do testing or my
client didn't want to pay for testing
and I'm like what you want to give them
something that's not tested my mind
doesn't comprehend that I've conditioned
myself to think that way of course if
you're new to testing and you've never
done testing before there is an initial
learning curve right so maybe your
productivity might go down a bit and it
will increase the quality of your apps
immeasurably it will catch bugs it will
catch regressions it will catch things
you never thought it would catch I've
written tests for code that I've written
and like oh that's really buggy I'm so
glad I wrote tests for that because
otherwise that could be in production
right and the sneaky way to overcome
that problem of loan my boss doesn't
wanted me to write tests because it
takes time and the best way of doing it
is kind of if you're an in-house product
and you know you're a full-time employee
things like that it's just start doing
it all right in my opinion and others
may disagree but in my opinion shouldn't
need permission to write good quality
software in testing is a key part of
that so if you're not delivering
software that has been tested and comes
with a test suite then you're not
delivering a good product it should be
an assumption right you know would you
buy a car and you know when you buy a
car you assume it's been tested at least
they've done a couple of crash tests
maybe not on your particular model that
you've bought on the particular one you
bought but you know that line has been
tested and they may pick a car off the
production line and crash it just to
make sure that all the safety features
work or something I don't know I don't
make cars I know how they do this thing
but I assume that they test them
right that my airbag is going to go off
if I drive into the back of something
it's never happened touchwood so far but
I hope it does all right
you're already testing as I mentioned
you know you manually testing stuff
every time you write some code you
refresh the page you write some more
code you refresh the page the error is
gone great all right so instead we just
need to automate that we need to write a
test to say you know these are the
things that this function is supposed to
do and do it and then it does it for you
so then you can get in the habit of
whether you do TDD or not which is where
you write the test first I don't care as
long as when you come to push that
change to your repository it's got tests
with it that verify that what you've
done works and we'll carry on working
does your boss or you or your team still
need convincing you just tell them it's
proven over and over again we will get
less bugs we will find less regressions
it will force us to design code better
and hey if you have that big legacy mess
which I mean most of us have worked on
this kind of thing before or maybe we're
forming a legacy mess now for the next
development I don't know testing on this
kind of software is still possible it's
a bit more of a challenge but I'll
suggest a way in a bit when it becomes
more relevant about how we might go
about that but testing in unit testing
in general right how do we go about that
it's quite simple on any your single
legacy software application you make a
new rule a very strict hard and fast
rule that no code gets merged into the
repository without tests all right new
features tests fixed bugs tests they
should pass obviously and over time your
code coverage will increase right there
is no point in trying to sit down for
like a week two weeks or a month or
whatever and let's all write tests for
all this existing code we've got because
it is probably the most mind-numbing I
thing I can think of doing Oh God
yeah don't do that who's ever done that
I have and it's really dull
it was very demotivating and it was when
I was just trying to learn testing as
well I was like that's the wrong way to
do it so don't do that if you're writing
a new application a greenfield project
hey you know what it's the same thing
you just make this rule no tests except
you're starting at the very beginning so
you're going to get hundreds on code
coverage to boot so testing as I
mentioned earlier allows you to spot and
reduce complexity a hard test to write a
hard unit test to write is the result of
complex code there's no two ways about
that really so you need to be able to
reduce the scope of methods avoiding big
procedural methods that do tons of
things break it down into smaller
meaningful operations atomic operations
write and use the naming from your
domain model that you talked about
earlier you know what is this thing
doing
oh it's sending an invoice well how what
steps do we do when we send an invoice
where we create you know we draw up an
invoice we add some line items to it and
stuff and break that down into smaller
things right that means something along
with your domain model so like this
single method which has lots of
complicated code in it lots of logic and
loops and branching code branches here
we don't want to do this right we want
to break it down all right using things
like object calisthenics which is that
talk from Rafael domes I mentioned
earlier I give the link later if you
need it first of all pick a better name
than just process because it means
absolutely nothing
use words that describe what the
business is trying to do like throw
stuff into the fire and complying
combining string yarn with fire things
like that and posting flowers to Spain
right it's a weird business more
complexity is more tests tests right so
let's think about test coverage
how do we get 100% test coverage anyone
take a guess corn how do we get 100 cent
test coverage it's possible but it's the
wrong question the goal is not to aim
for 100% test coverage the goal is to
aim for 100 percent of your domain logic
to be covered with tests that's
important that's the important part
right so that's the goal we should start
off with it doesn't matter whether we're
testing where the MySQL connects or
Mariya DB or Redis stores things right
right that's not a job for unit tests
unit tests let's start off with focusing
on the business stuff sending flowers to
Spain and throwing stuff in the fire
hopefully not the flowers otherwise we
wasted the money and another thing
another problem with code coverage is
that it's very difficult to measure real
code coverage let's have a look at some
code in this function foo we are doing
two checks if a is a well like our a if
B is B if if B is true will echo be
fairly straightforward method alright
hopefully we can follow what's going on
here and tell me yes or no can we
generate 100% test cover it there code
coverage using these two calls why is
that for always shake the head it will
go green for your right to shake your
head right because this isn't fully
covered there's this branch where a is
true and B is false signified by this
nice Purple Line where B is true and a
is false so that's the two calls we've
done here but there's actually two more
where they're both false and when
they're both true now X debug supports
this way of generating code coverage but
the PHP unit code coverage generating
display thingy too
or whatever it's called it can't display
it because how do we display this in a
way that makes sense to us it's really
really difficult so we haven't come up
with a useful solution for this yet it's
possible it's just not it's just too
unwieldly for us to be able to figure
this out properly so that actually we
need for tests because there are four
code branch paths that we can follow in
that method test coverage from leaking
yeah we don't want to leak coverage
everywhere what do I mean by this
using the aunt covers annotation on your
test test case will allow you to
restrict coverage to that one class that
you're testing that will allow you to
test the private API pet private API of
that class and bear in mind if there's a
private method that you can't cover with
the public API and writing test for that
then there's some weird stuff going on
in your code right you should always be
able to call private methods and cover
the logic in those by calling public API
over class so aiming for 100% test
coverage is usually impractical unless
you're writing from very scratch it's
also not that worthwhile goal right we
want to test the domain logic really is
what's important the point of a test is
to make sure that everything is working
so if your test is not performing the
correct assertions the new tests are not
testing so how do we stop this so let's
have a look at this example this is not
a useful test not all that useful I mean
the code is executed so we generate code
coverage
hopefully the problem is kind of obvious
here we're not actually doing any
assertions here so let's put some
assertions in right we maybe want to say
that the event listed on the receipt is
the same as the event we created that
we've got one customer on it and the
customer is the one we expect and things
like that right now it's a fairly
trivial example
but we can do better than that we can
test that our tests are testing we need
something called a mutation testing tool
all right there used to be two it used
to be a tool called humbug and infection
now there's just infection because
humbug got a bit difficult to maintain
infection PHP is a tool you can just run
and it will run your unit tests but it
will then change bits of the code and
then it will run the tests again and if
the tests fail that's good
because it changed the code it broke
your code and the tests failed if the
test still passes and you broke the code
then that's not good all right that
means that your test was not testing
what it's supposed to be testing have a
look at an example because that might be
a bit difficult to comprehend so we've
got ad right we know what does it adds
two numbers together and we've got a
test this is well the result is the
adding two and three right but I've left
the assertion commented out so that it's
not testing anything so if we run this
through infection it will create maybe a
mutation that changes the plus to a
minus hides now subtracting but if we
run the test if you sorry infection will
now run the test automatically and if it
hasn't broken it will say your test is
rubbish fix it if we uncommon the
assertion obviously the test will now
fail because it doesn't calculate to the
correct value all right and the nice
thing is infection PHP is pretty much
more or less something you just chuck
into your CI and it works
takes a little longer because it
obviously has to run the tests over and
over again multiple times it's a bit
more clever than Homburg used to be
which is nice because humbug used to run
the whole test suite change something
run the whole test we change something
and obviously that's a bit that's a bit
rubbish takes took some time so what are
other tests I hopped on about unit
testing for a while and there are the
kinds of tests right we've got
integration tests right that's where we
check that stuff happens in the database
properly and stuff like that there is
still value in there but you probably
don't need as many of these tests right
you don't need to use your real database
and things like that to check that often
maybe if you've got some weird massive
SQL query or you know you want to check
that the data you put into Redis comes
out looking the same and things like
that you know they're useful integration
tests because you're integrating with
your infrastructure that's what the
point of them are integration tests
aren't concerned with business logic
though right only concerned with
integration funnily enough and
behavioral test is another important one
right this is where we want to focus on
as well so units s and behavioral tests
are the most valuable tests I believe
and this is where we can describe the
business logic which is also how we can
document the business logic and that I
think is the most important part of
behavioral testing not that we're
actually testing and making sure things
work but that we're documenting how
things are supposed to work this is not
a good test
don't write tests like this if you've
never seen gherkin before don't write
anything like this okay if you have and
you recognize this kind of layout stop
it this is basically a very fragile UI
test and it's not very useful and it's
not readable to someone who knows
nothing about what a doc breath ipt -
FLD or a booking referent thing is mean
nothing useful right there's no meaning
there's no intent there's no figuring
out what it does unless you're a
developer and that's not the point of
this we're trying to document how the
business works not how the application
works all right so let's change it this
is a good test or this is better let's
look at what's good firstly I'm using
the free text area I've written a label
called policies right you can write
anything you want you can put some ASCII
art of a cat if you like probably more
beneficial if you write something useful
though I'm documenting policies or
business rules if you want to call them
that right boarding passes are only
available when you checked in for the
flight right if the customer can't print
a boarding pass maybe some airports you
know you have to check in manually
you can't check-in in advance and things
like that
all right so another big change is that
this scenario that we've written it came
contains no references to UI elements
right
no CSS no oh I click on this button and
things like that there's nothing like
that it's just describing what the
customer does the passenger of this
flight right we're describing the
behavior of what happens you know when
they when they've checked in for the
flight I should be able to print my
boarding pass bla bla bla right
additionally a bit more of a subtle one
is that we've got a given when and then
right and that's what should happen
don't have lots of wins and thence if we
go back we can see we've got a given
when then and then a when and there then
right that's basically we're testing
more than one behavior here which is not
what we're trying to do all right there
should be a predicate an action and an
outcome and that's it in that order
and finally and possibly most
importantly we're using a real-world
example here right maybe I've this
passenger is flying from Heathrow to
Miami on the 24th of May they've got
some booking reference and they've
checked in they should be able to print
their boarding pass but maybe for some
routes maybe if we're coming back from
Miami we have to check him manually at
the desk and print the boarding pass so
maybe that particular route on with a
separate example a separate scenario it
should say we can't print the boarding
pass and so on but the point of using an
example is that we can discuss that
right because the business stakeholders
can understand this right it's plain
English we know what's going on they
know what's going on so we can have a
discussion around it Oh
what if they fly from you know Prague or
something like that oh yeah we we don't
print boarding passes in Prague so okay
let's write a test or maybe we can
reword the scenario to say I've booked a
flight that flies from Prague when we
fly back from Prague we can't print
boarding passes and so on right
so why is this important I've kind of
said this already I gave you a spoiler
because we're testing behavior and we're
documenting those business rules as we
go along because they will stay there in
the source code and tell you what's
going on tell you what the application
does so if you get someone coming along
new to your code basin that says so
what's going on here it's my first day
I've no know I did get them to read the
tests these behavioral tests if they're
well written they'll be able to pick up
very quickly how your business works
because you've documented it right then
once we've written them we can go ahead
and automate them we can use this
magical funky tool called B hat all
right so so far in writing all these
tests we didn't even run B hat we're
just writing things down that's all but
B hat makes it easy to test them right
and there's two ways of doing this right
we can write it at the application level
we can write a UI test we can navigate
things in a browser but hey what happens
when we want to an expose an API No okay
well we can't click this CSS element or
JavaScript button or because there's no
HTML anymore okay so we need to write a
different set of tests for against the
API and then what about when we want to
write an Android and I are I Oh s apps
well there's a whole note do two more
test Suites we've got ahead now what I
recommend is when you're first starting
off with stuff like this actually test
at the domain or business logic layer
forget about the browser
forget about your handheld devices and
and things what you want to start with
is testing your domain logic and making
sure that works to start off with no UI
interactions means it's immensely fast
right I've written test Suites before
that like three hours to run because
they click in through things all the
time and it does it very fast if you
watch it if you visualize it he's going
very quickly but it still takes ages
right
so this is an example of two of them
right the bottom one using the domain
layer we're just calling methods on our
domain objects directly you know if we
want to display booking reference we can
retrieve the booking all right we want
to be able to retrieve the booking how
we display that is not important it's
just we want you know maybe you want to
check that there's certain elements
returned in that booking reference and
so on so we can see what's in there and
display it the top one is the UI test
you know you may have seen this kind of
stuff before you know we're clicking
elements we're finding a field we're
setting the value of it we click in a
button and things like that UI tests are
okay right and going back to the how do
we test a legacy mess thing this is
actually the first thing I would do
right if you have a project or it's
Orion in many cases this is the first
thing I would do if you have a project
that has no unit tests nothing and it's
a legacy mess and you know it's
completely untestable right a UI test
just one to make sure that the happy
path that the customer should go through
works right so we can book the flight
and we can print the boarding pass and
things like that right and we've got one
test there and that's great because
we're testing that business logic works
the code under that UI test make might
be horrendous but that's ok because what
we can do now is start refactoring stuff
underneath that test and re-implementing
things and changing things around and
when it when we do that of course we
write unit tests along with it and
they'll start passing and as long as I
that UI test that you've written still
passes that's good right we haven't
broken the key cut functionality yeah
and then you can write a couple more UI
tests maybe one for like a failure case
and things like that but the happy paths
are the important ones and once we've
got those tests going as I said we can
refactor underneath and add unit tests
and integration tests as we go along
like it was a new project and that's how
we would go about refactoring legacy
stuff
Automation is key to creating this
smooth workflow what do we do what
continuous integration is the answer
really every change must be tested in
continuous integration you run your unit
tests you'd be hard tests your coding
standards tests you run your migrations
things like that why well because
developers hate running tests manually
it takes time and we forget and it costs
money write tests cost money to run when
you're sitting there and your B hat test
takes that test suite takes three hours
to run you are wasting money so it's a
false economy to be running all this
stuff manually you need to pay a machine
like Travis costs $250 a month or
something like that for a couple of
executors it's so simple to set up
there's no excuse really if you've got
tests if you haven't got tests well
that's a different story maybe you
weren't listening for the last 20 30
minutes Jenkins yes there's Jenkins
right we can set up Jenkins if we want
it's open-source software I love
open-source software but it's not really
free because there's a maintenance
burden anything that you host yourself
is always a maintenance burden right
Jenkins likes to update quite frequently
so you've got to help to keep up to date
what about when it breaks who'd you
contact right at least with Travis you
can say oh it's broken they're working
on it let's play some ping pong or
something if you like ping pong I would
say that in like 99% of use cases stuff
like Travis and circle CI will fulfill
all your dreams and needs if you've got
really complex business requirements or
some weird Bank thing says we're not
allowed to let the source code out of
the building feel like that happens then
maybe consider Jenkins but honestly this
stuff is fine so what do we automate
it's very simple everything
alright unit tests behavioral tests
acceptance tests into n tests coding
style tests database migrations I bet we
don't have enough of those in our tests
in our CI runs from 10 builds new
JavaScript tests things like that make
sure that gulp or grunt or web pack or
yarn doing what they're supposed to be
doing and generating what you expect to
see I've even seen tests where it takes
screenshots and compares them with the
previous version right any kind of thing
plug it into CI environment because the
goal is this the red or green thing in
github we'll get lab or bit buckets
that's it you just want that green thing
if it's red don't merge it if it's green
you go to the next stage which is code
reviews code reviews are important for
education communication gatekeeping and
generally keeping the quality of your
software up so if anything I think this
is the most important thing of this talk
and I've left it to the last five
minutes to rush through it the reviewer
the code reviewer must absolutely have
Authority and supreme power to say don't
merge that it's terrible which is a
really hard thing to do in some teams
right because they will say well what
about when you know productions down and
we have to quickly ship a fix well if
you've written a test with it it should
be fine right it's kind of it can be a
hard ask a code review it must also be
quite experienced all right and I'm not
saying that inexperienced or junior
developers should not be reviewing code
they absolutely should be right but the
gatekeeper if you like or the
gatekeepers right should be able to
review this code right because it's very
important they've got the experience
they've got the years and you can only
build this up with finding out the hard
way there's no two ways about it
unfortunately so what do we look for
code style but most of that can be
automated right
PHP code sniff for PHP CS fixer things
like that so you shouldn't need to do it
but just keep an eye out for some weird
things where someone started writing
code backwards and weird things right
yeah let's not do that
also avoid refactoring style in features
so like where you're adding any feature
don't suddenly add a new PHP CS rule and
change all of the all of the files in
the project because the reviewer will
probably stab you in the eye so make
them small as well write small atomic
changes that's what it's all about don't
deliver one user story every time
sometimes you might need to make several
pull requests for a user story because
actually the user story might just say
as a user I would like to click this
button and the world explodes there's a
lot of parts to making the world explode
I mean I'm not speaking from experience
but I imagine there's lots of parts here
right so you're going to want to make
lots of pull requests small as possible
it's really hard to do this right I
still make some huge pull requests and
then I get slapped around the face and
say you make a big full request and then
I'm like I'm going to put pineapple on
your pizza
try to keep your changes focused into
the point composer versions right make
sure you've got recent dependencies make
sure you're using row security
advisories don't worry it's not
something I'm you have to buy or
anything like that you just stick it and
compose a JSON Rove slash security -
advisories and it will automatically
conflict with known to be insecure
versions or packages on composer it uses
the data from friends of PHP security
advisories and it's not fully
comprehensive but it helps alright look
for structure and good practices this is
kind of where experience starts coming
in a lot more right anyone can look at
code and say well that looks ugly but
it's a lot more difficult to say well
does this service class fully implement
all the interfaces so it can be final
does it have an interface don't just
create a final class without interface
where it needs
it right value objects don't count right
they're different are we encouraging the
best practices or conventions that we
use in the team and challenge those
conventions as well don't just accept
them as these are the rules we have to
follow them forever because if you don't
keep changing your rules and keeping up
to date then you'll go stale quite
quickly assertions for parameter types
can you use value objects and and so on
are your return types does it return
like a true a false or a string yeah
don't do that if you really must do that
encapsulate it in a value object so you
make those types well-documented tests
got unit tests if they got feature files
and so on I think we've done that one
documentation I actually encourage you
to commit your documentation along with
the repository in just a docs folder if
you like stick a load of markdown in
there tell people what this thing does
why it does it what business problem
problem it's solving and why have you
you've used some weird component
document things for your fellow
developers because they and you when you
come back to it later will thank whoever
wrote that documentation so when you're
reviewing code just kind of think do we
need to write make a quick markdown
document to say what's going on here
security as well I mean there's home
talks about this you know SQL injection
filtering escaping and CSRF and things
like that all right I won't get too much
into that but look out for security
stuff if you don't know what you're
looking for look for the OWASP top 10
that's a great place to start and then
you'll go down a big rabbit hole also
review are you getting the insight are
you understanding what the change is
maybe that is not conveyed properly in
the code or maybe it's over complicated
and things like that takes practice as I
said you know the more you do this the
more experience you'll get and the more
experience in general you'll be able to
say well like ah like three years ago we
did
this same kind of thing and it blew up
Las Vegas or something like that right
so let's not do that so you need that
experience to spot problems developing
ahead of time but honestly the real
skill is being able to communicate your
experience nicely you can be opinionated
as long as you can communicate
effectively and that can be difficult
because you need to be able to dissolve
disagreements without hitting each other
over the head with baseball bats because
you'll end up in prison some of this is
very mechanical black and white stuff
this is right this is wrong bla bla bla
bla bla bla some of its opinionated his
best practices right I've told you some
best practices which you'll probably
disagree with and that's okay but your
code is wrong your minds right finally
in um minus one minutes so I'm going to
do this very quickly deployments
automate them it's very straightforward
honestly if we're not automated that and
that what I mean by that is one click or
typing a command to deploy your
infrastructure right we shouldn't make
it complicated we shouldn't be having
this document that says to deploy you
have to do this and then go over to this
website and do this and then you have to
clear the cache and type this command
and things like that because something
one day if it hasn't already will go
wrong right so if we make a computer do
that and we tell it exactly what to do
every time it will do the same thing
every time and as long as you've written
it right the first time it won't make
any mistakes to implement this kind of
thing what do we do it's very simple you
take those steps that you do manually to
deploy whether that's uploading you know
running composer and then uploading it
to an FTP site just right they use a
tool that does that right there's tools
like deploy HQ which will do that for
you right even if you're using FTP and
so don't laugh because some people still
use FTP right is a viable way to do it's
a way to deploy things
the goal is essentially to always be
deployable so whenever you've merged the
code you should be be able to deploy
that straightaway in theory
Facebook's mantra move fast and break
things which is of course done so they
changed it in 2014
whether you like Facebook or not I wrote
this talk before all the Facebook stuffs
or whatever they still have good
technology right whether you whether
it's ethical or not is a whole other
topic
yeah but they changed it because they
kept breaking stuff and you know that
costs money breaking things cost money
sometimes millions of dollars sometimes
hundreds of pounds an hour whatever
right I changed currency there that was
weird
uh-huh but my point is if you are
confident in your pipeline so your tests
you have more tests you put more and
more tests in and you write better
quality code all the time you can do
things like continuous deployment way
you know as soon as you merge to master
it will deploy everywhere right so you
don't even have to click or type a
single command sounds pretty scary and
if you don't do this you might be
thinking well you know that that's going
to lead to deploying it 5:00 p.m. on a
Friday or bank holiday Thursday maybe
you deployed just before you came out to
the user group meet up tonight if you
did congratulations
hopefully it's not broken now but it is
possible and I've done this you just
have to have a lot of confidence in what
you're doing you've got to have the
confidence that it's going to work when
you deploy it and you do that by
increasing the quality better planning
and exploration to start off with it
starts way back there developing things
better testing more better testing
because there's always things you can do
better and making sure it's automated
and you have that red and green feedback
and you have a good code review process
that will always lead to better quality
software which leads to higher
confidence higher confidence you're not
going to break things when you deploy
that you are going to deliver stable
software and when you're doing that
you get a much higher frequency of
feature throughput oh we just deployed
five changes today great business
stakeholders happy you carry on getting
paid and you get hip happy customers
whether that's your boss or your client
if you're freelance and ultimately you
will get satisfaction in delivering a
great service a great product whatever
you will learn more and as you start
looking into things I've very briefly
covered today because there's a lot more
detail to a lot of all of what I've said
today right and as you look into some of
these aspects and I hope I've inspired
you to look into some of these aspects
you will become a better developer and
that's what we want thank you very much
folks Cheers</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>