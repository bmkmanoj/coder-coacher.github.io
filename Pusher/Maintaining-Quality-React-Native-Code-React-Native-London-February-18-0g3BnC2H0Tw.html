<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Maintaining Quality React Native Code - React Native London - February 18 | Coder Coacher - Coaching Coders</title><meta content="Maintaining Quality React Native Code - React Native London - February 18 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Maintaining Quality React Native Code - React Native London - February 18</b></h2><h5 class="post__date">2018-03-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0g3BnC2H0Tw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hello everyone and thank you for
coming so today I'm going to be talking
about how to maintain high quality react
native code using just different tools
and practices so before we get started I
think it's really useful to have sort of
shared understanding of what quality
code is so when I started researching
this there was many different opinions
what I've done is sort of boiled it down
to sort of three core tenants of quality
code that sort of makes sense to me so
the first one is just to make the code
readable to make it easy on the eye
not to bunched up not to spaced out but
most importantly just to have things
consistent so the goal is to have code
that you can just look at and not have
to sort of figure out why it looks so
weird sort of thing
and ultimately to have it we'll have it
in such a way that it looks like any
member of your team could have written
it so overall this just makes the code
easier to work with it removes that
barrier of what actually it is this
thing so partnered with that is just to
make it understandable as well so part
of that is using common patterns and
using those patterns consistently so if
you're using a library such as redux to
understand the common patterns with that
and use those patterns consistently
throughout your application this just
makes working with the code much easier
there's a much lower there's maybe a
higher barrier to entry to get started
but once you understand the patterns of
the project you can just get going with
it and the last one is just to make
everything the project of the whole
maintainable so part of this is just
having the right tools set up and in
place and having the project be well
tested so that it's easy to check for
regressions and this just means you can
move faster when you're making changes
and worry a lot less about am I breaking
something or have to manually go back
and test what's going on
so what if this stuff is important for
any project and realistically it's one
of the key indicators for success but
for me it's especially important because
a lot of the time I'm working as a solo
developer so I'm a freelancer and that
means a lot of the time as I said I'm
working on my own
so I don't have that safety net of
having a pull request open and someone
else checking my code and making sure
that the quality of its high it's all on
me to make sure that you know that is
the case so just a little bit more about
me so I'm based down in Brighton
so I've traveled up through the snow
today I started off as a mobile
developer native developer in an agency
and I worked there for five years
first with Android moving out to iOS and
doing bits of back-end stuff as well but
I went freelance about two years ago and
increasingly I've just been using react
native with client projects just because
it makes sense for the sort of projects
that they want to do so I've been using
react native for why thought was about a
year and a half now and doing many
client projects through them and
probably about eight different apps
through them and sort of evolving my
processes as I've gone along and
throughout that I've picked up just a
series of tools along the way just to
keep the quality of the code as high as
I can so I'm just going to go through
those some in different sections for
what the tool does and that's been sort
of short on time where we go relatively
quickly but hopefully it gives you a
good overview of the sort of things you
should be looking for and a basic idea
of how they work so first thing is type
checking so this is something especially
the first thing that I missed as soon as
I came over into JavaScript land so I'm
used to Java and I'm used to Swift where
the language is statically typed and for
me that was a just a massive safety net
for me just making sure the code that I
was writing is correct and when I came
into JavaScript land i sorely missed
that so after doing a little bit of
research I came across flow
so reason I picked flow was because it's
made by Facebook and it's used
internally with react native itself so
it works really well with reacting react
native and the way it works is that you
annotate your JavaScript with type
annotations at runtime there's no
difference it sort of gets gets compiled
away by the web pack these web pack
Packer so it's just a tool for you to be
able to use and as I said it's really
easy to use without native so best thing
to do is just give an example of when
this is probably going to be useful so
know that again so really simple
function here take a quick look at it no
need to shout out or anything just take
a quick look and see if you can find the
error in this code there again so
someone shout shout it out so yeah as
you said their possible customer could
be no and therefore when you try and
access the name property on it it's
going to crash runtime so this code is
completely valid it will work and
actually if you were writing this code
properly you wouldn't call it possible
customer you just call it customer which
would have masked made the error a
little bit less obvious so just to show
it what this would look like when you
start adding flow annotations to it so
the first thing you do is add in this
little comment at the top of the file
and it just tells the flow command line
tool that you want to type check this
file so it's an opt-in thing on a per
file basis so what we then do is define
the customer type so we say it's an
object with two properties name an email
both of which are strings and then here
we can just annotate the possible
customer parameter with a maybe customer
so we're explicitly saying this may or
may not be a customer so that's all
fairly straightforward and quite easy to
do when you get into the habit of doing
it and what this gives you when you run
this code through flow it will
explicitly give you
it's error so it will say cannot get
possible customer name because the name
property is missing on another and
define so it understands that this thing
might be no and gives you the correct
error message to say there's a problem
here so just to finish this off this is
how you'd get around that just check in
is this is this thing truthy or not is
it is it there if it is access the name
if not return something else so this is
quite simple example but flow is quite
clever in that it can do a lot of this
inference for you so if we were calling
this function with sometimes customer
object or what look what it's for looked
like a customer object and also
sometimes passing in something that's
potentially no it would actually figure
this out without as adding the
annotation so you can use this tool
without adding all these annotations
everywhere as well so oh yeah so when
you run it it just comes up with no
errors so the other nice thing about it
is it's possible to Inc to adopt
incrementally you can if you've got an
existing application you can as I showed
before opt in on a per file basis and
just start slowly but the real value of
it comes when you start adopting it
across your application so it's
especially useful for things like your
the structure of your Redux store and
the properties that are coming in to
components once you do that and you've
also got the typing in the middle you're
able to really easily spot problems
where you've changed your Redux store
but to have something that potentially
no but actually your component still
assumes that it's going to be always
there and it avoids a lot of these
little runtime errors so as I said we're
going to have to move through this
relatively quickly so I'm not going to
talk too much with each of these tools
about how to actually get going with it
but these are the websites that you can
go to so the flow website itself has
lots of good examples about how to use
flow and how the typing system works and
there's also a link there just and
someone's medium article that where
someone said how to use it specifically
with react native
so that's a really useful resource to
getting going okay so we've got type
checking but that actually doesn't check
everything to do with the to do with our
project it tests that thing for
potential runtime errors or potential
errors like that but it doesn't check
the sort of more nuanced things in your
application so that's where something
like linting comes in so what this
allows you to do is to check that your
code matches a set of rules that you've
set up and these rules are things like
not allowing variables to be unused so
not creating a variable and they're
never using it or using something like
creating a component that's potentially
not as optimized as it could be that
sort of thing so that's where linting
becomes useful just giving you best
practice sort of small code fix up sort
of things so for that my tool of choice
is yes lint so es Lintz a popular open
source JavaScript or Ekman script if you
want to get fancy where the es comes
from linter and the best way to show it
is just to show what it does is just to
show a really simple example again so
we've got here a react component with
stylesheet pretty straightforward but
with the EF lint rules I've got setup
there's actually four different warnings
or four different errors inside this
simple file so you take a second and
we'll go through them one by one and see
if you can spot any first okay so the
first one is right on the second line so
it's this import here actually we're
never using it so there's no need for us
to import it so really simple thing but
it's going to be able to flag that up
the next one it's going to do and this
this is completely valid but it's going
to flag up that actually there isn't a
style in our style sheet called text
there isn't one their search is going to
be undefined which is completely valid
with react native but probably not what
we meant to do an equally it can
understand the
button style actually is never used so
it Flags that up as a warning as well so
you can see with those two you can
potentially see there's an area where
we've just missed named something and
the last one is a bit more complicated
in that it's it's understood that this
whole react component can actually just
be optimized so this whole thing is a
component but it doesn't have any state
doesn't have any state and state
property inside it so actually what you
can do is just use a standard JavaScript
function and that's a nice optimization
and it'll flag this up for you even with
sort of more complicated bits it's able
to flag this up and these are the sort
of errors that don't necessarily matter
a whole lot on their own but when you've
got quite a large project it's sort of
the death by a thousand cuts sort of
thing if you've got a project where
there's a lot of unused variables or
unused functions or just generally dead
code that doesn't do anything without
some sort of warning to say hey this is
it might be this isn't actually used or
this could be optimized it's really hard
to spot especially in a pull request of
20 odd files so how many of these do you
think would just get through a standard
github pull request so again just for
completeness that's just showing the
code after the changes so removing the
alert optimizing the component and just
changing the name of that style so again
they're only minor fixes but added up
over a whole project it's surprising how
many you have we I had one native
Android project but we turned on the
built-in linter about a month into the
project thinking oh we'll just tie these
up and we were surprised to see there
was over 500 different warnings so yes
lint a little bit complicated to get
going with this the way it's structured
is that you've got the core of it which
is the command line tool and the rest of
it's made up of plugins and
configurations and all sorts of stuff
like that which is a little bit hard to
get your head around at first but the
best way to get going with it is to look
at the github page for the react native
yes lint plugin and that actually had a
good getting started guide for how to
install
yes lint itself and then the react
native plugin which also gives you the
react stuff and just the normal
JavaScript stuff so it'll give you quite
a lot out-of-the-box but what you're
able to then do is take those
recommended rules and customize them to
your needs so if something's a bit too
annoying you can turn it off or if
actually is not catching some errors you
can add those sort of rules in so yeah
really useful tool well worth looking
into for your projects okay so next one
is this this topic so this causes sort
of endless arguments between developers
so tabs versus spaces semicolons or not
etc etc etc it's all of those sort of
things that to be honest it's just not
worth arguing over it's just most of the
time it's a waste of time so what I
actually end up doing is using a tool
called prettier so the way prettier
works is it takes your JavaScript code
it parses it in the same way that a
compiler would but then instead of
running it rewrites your code in a
standard way so it's gonna be able to
take in any valid JavaScript code and it
will rewrite those files in a standard
way or be able to give you a warning
saying this isn't how we expected it to
be so it's a really nice tool because
well when I started using it there were
zero configuration options which was
lovely because there was no arguments it
was just a case of this is the way it is
I think now they've added a few more in
just to appease people I think there's
eight now I think the things like do we
have semicolons or not do use single
quotes or not but to be honest just
stick with the defaults it's it's really
not worth arguing over so what it also
does it can as well as running in the
command line it can also run directly in
your code editor so essentially when you
hit the Save button when you save your
file it will automatically reformat it
in the way it wants so that's really
useful because you can write code like
this that's really sloppy just hit the
Save button and it's formatted it in its
way and it's generally quite a nice way
it's you know there's some bits where
you look at it and go while I wouldn't
have done it
like that but you can start off with
something really messy even copy and
pasting code from Stack Overflow it
happens hit save and you end up with it
in a consistent style so it's still
useful if you're working on your own so
one way to use it is this have you built
into the editor itself another way is to
have it running on the command line to
give warnings or reformat things so nice
thing about prettier it's really easy to
get going with so if you're using the
editor plugin
it's just installer normal easy to plug
in and it just works the command line
side is just an NPM module yeah it's
really easy to get going with but one
quite nice thing as well is someone's
written an es limp plugin for it so like
I said the Esalen it's a little bit
complicated but you can plug prettier
into that so it will give you warnings
when the codes not formatted correctly
and actually you can configure es limb
to automatically fix problems that it
comes out with so yeah it just saved any
argument over code formatting which is
quite nice even with myself okay so
testing now basically everyone should be
doing testing there's sort of no reason
why you shouldn't be a lot of the time
it's just really useful for just
especially when the project starts
getting bigger just proving that your
code is still working once you make a
change just making sure that what you've
got you've got a high level of
confidence that that code is still
working and it just allows you to find
issues before they become a problem
so recently on a project so on
freelancer so I worked on a project mid
last year and the client went away
released the app didn't want a retainer
which happens and then came back to me
last week and said we now need to update
the app make some changes okay great
react native was then ten versions
behind I think which is kind of a
standard if you wait half a year so
having the tests there and having a full
test suite so being able to update react
native run the tests see what's broken
and then go from there was just so
useful
it's only once you actually hit a
problem where you've not got a test
suite and it causes you in must pain
that you actually for every project
after just to do it as a matter of
course and the really nice thing is
Redux and react code is so simple to
test so as I said I come back from a
native iOS and Android background
working with Java and Swift and testing
those platforms is an absolute nightmare
it's just not nice at all compared to
the way you do it with react and redux
code and the reason for that is the all
of the your code that you're going to be
writing or most of your code in you're
gonna be writing is pretty much data in
data rel so a reducer you pass in a
state and an action and it spits out
another state that's really easy to unit
test components are the same you pass in
properties and then out comes some JSX
or some whatever that actually turns
into and you compile it so that means
you can actually test each part of your
application in isolation so you can test
your react components you can text your
test your Redux reducers your selectors
if you're doing that sort of a pattern
and on its own that might not actually
test the integration between anything
everything but if you've also got type
checking set up correctly like I said
good flow at the start
that's essentially testing that you've
made you've written the wiring code
correctly so if you change the return
type of a Redux selector or a you know
reducer sort of thing the properties
that are coming in are gonna it's gonna
have the wrong value coming in and that
will flag that up really quickly so the
tool I use for this is just and again
the reason I chose it is it's made by
Facebook it's used in react native so
odds are it's gonna work perfectly every
time one nice thing about it it has
pretty much everything you need built in
it kind of goes against the normal
JavaScript ecosystem ethos of one tool
doing one thing it does the complete
opposite it's one
tool that does everything to do a
testing which in this case I actually
quite liked so it's got mucking built in
it can do spies it's got the matching
library built in it's got the sort of
general structure of the tests all there
and that's actually quite nice for this
because you don't have to spend time
configuring all these tools to work
together when actually it should just be
a tool that is helping you move faster
the other great things about it it's got
a really nice watch interface so you can
run just with - - watch and it can
pretty intelligently figure out what
files have changed and only run the
tests that are related to the changes
you've made so you're not waiting on
your entire test suite to run every time
you hit save and you can do fancy things
I only watching certain files or certain
tests named reg X is sort of thing and
again built-in stuff so built-in code
coverage so you don't have to figure out
how to use chocolate Istanbul however
that used to work it's just built in
just run it with - - coverage it gives
you a coverage report which is great so
you used to have a really bad reputation
probably about a year ago because it
basically turned on mocking by default
on everything so anything that your take
the file you were testing imported it
would just automatically mock it and
that was an absolute nightmare to figure
out because you just come out with no
no's that you weren't expecting sort of
thing but essentially they turn that off
and it's now essentially what you'd get
wejust is what you'd get with maca and
chai Jasmine Jasmine one of the two is
basically that all built in so just in
case you've not seen it before there's a
I've got a really quick example of what
a typical test would look like so they
describe blocks I just use to wrap
groups of tests together so we're just
in this case we're describing sort of
testing a UI reducer so a Redux reducer
so the first there is the it so the it
is the actual test itself is each test
case is an it statement and the way I
like to write it don't have to do it
this way just it should return the
initial State that's just the name of
the test what's going to come out where
there's an
and the tests themselves are very simple
so as I said this data in data route so
we've got our reducer we're passing in
the undefined which is what you get when
you first start up the application and
we're just passing in a random action
just the first action that comes in and
we're just going to expect that the new
state is going to match a snapshot this
a nice little trick that jest has built
in so what will happen the very first
time you run this code assuming you're
not on a CI server and it detects that
sort of thing when you're running on
your machine it will see ok this a new
state I don't have a snapshot for that
yet so let's create one and it creates a
file next to your test client your test
module which has whatever was in that
new state variable and it lets you know
this is what has been stored so it says
this is is this correct sort of thing so
that's all fine
next time you run the test it's going to
see that you've already got a snapshot
and it's going to match the new state
variable is it the same as the snapshot
I've already got if it is great the test
passes if not it's going to basically
give you a diff of what is actually
different with this object so that's
actually quite a nice thing and you
commit that snapshot along with the rest
of your career it lives in your
repository the benefit you get with that
is essentially you don't need to
manually write out expect the new state
to equal this object because in a lot of
cases you're just going to end up
duplicating you know duplicating what
you expect to happen in your tests quite
a lot and you kind of get the same thing
by storing that in the snapshot file but
letting it manage itself and if it
notices that there's a difference and
you think that's a legitimate difference
after you've seen the diff you can press
essentially if you in the watch
interface you press the U key for update
and it updates the snapshot so you can
really easily manage that as you go
along so it's a small thing but when
you've got lots of tests it's actually
quite useful but it's important not to
overuse it you can go a bit crazy with
the match the snapshots and it just all
goes a bit too much
so let's finish this officer there's
another test here just to make sure this
one's a bit more manual but still quite
simple so we've got a start state with
the app load it is false
we're basically testing that when we get
the app loaded action passing that in
and the start state into the reducer
that we expect the new States uploaded
to equal true so pretty simple testing
sort of stuff so as I said it works
really well with react native projects
you're pretty much set up ready to go
it's already got all of the
configuration you need in most of the
projects best thing to do is just go to
the official just website and just
follow the instructions there to get
going because yeah it's not worth having
projects that aren't tested to be honest
okay so all this is all this is all well
and good having all these tools but
running them out manually every time is
gonna be a bit of a pain it's gonna be
the case that you forget to run them and
when you do eventually run them
everything's broken and you have to
spend a lot of time fixing it up as you
go along so the best thing to do is make
sure all these errors and all these
checks that are coming out are checked
as early and as often as possible the
way I like to do this is to do it using
git hooks so this basically means that
when you commit or when you push these
tools are going to be running
automatically and if they fail you won't
be able to commit you won't be able to
push until you actually fix things up
essentially when you run npm install or
yarn install it automatically sets up
the git hooks for you and then you can
just configure what those hooks do
inside your package jason so it's really
easy to set up and the real advantage is
its set up automatically for everyone
who sets up the project because the
first thing you do when you do a git
clone is do an NPM install and at that
point it's automatically setting up
these hooks for you so as I said you can
configure it to run with different get
events so this is just a sort of summary
of what
package.json would look like so the two
change we've made is we've added two
dependencies with husky and a tool
called a lint staged and as I said when
you run npm install it will set up all
the hooks for you there's nothing else
you need to do and then the next bit is
just adding some NPM scripts and these
are just standard NPM scripts that you
can do with NPM run whatever they're
called but it's going to call these
automatically when you do certain things
would get so the two that I like to use
are pre commit and pre push so it's
going to do some stuff before I commit
things and some stuff before I actually
push it out onto a remote server so when
you do a when you do a commit so before
it actually does the commit it's going
to run this tool called a lint staged so
this is just configured down here and it
very simply just says that for every
javascript file it's going to run npm in
npm run es lint with the fixed option so
it's going to check the es lint is
correct but it's also going to fix up
any issues and as i said i've got bit
into prettier so at this point it's
going to be doing all the code
formatting for us so even if you're not
using the editor prettier sort of things
at this point without you even noticing
it's going to reformat your code and
then run git add to add those changes in
so you can write this means that the
developers can write their code however
they like they can leave the silicones
off put them on new single quotes double
quotes whatever and it will format it at
this point just before they commit which
is really nice the next bit it does is
when you actually go to push it's going
to run yarn tests or NPM run tests and
this I've just configured to run es lint
again just to make sure but also run
flow to do type checking and also run
all of the unit tests for gest so at
that point if any of those three things
fail then the push will just stop we
just won't push
and that's really useful because
everything that then leaves the
developer's machine is guaranteed to
have those three things passing now the
reason I've chosen to do this pre person
pre-commit is that es linen is very
quick to run so you can very quickly
just do git commit and the commits done
you hardly notice that it's doing
anything extra aside from a normal
commit it probably takes an extra second
which is absolutely fine the actual
testing so running all the jest tests
and flow the first time you run it takes
a little while to set up so that I don't
want to run every time I do a commit
because it's gonna break my flow
essentially so I only do that once you
actually push so just to give you an
example this is what happens when the
you try commit something that actually
isn't going to pass so the there's the
eslint errors so you start off with this
as the get state run commit it starts
off running the yes lint tool with fix
and it comes back with what is actually
quite a lot of areas in this case and at
this point the sorry the commit just
fails and it won't commit and you can
see that from the state here so it sort
of stopping you committing things that
are incorrect and the same thing will
happen if the tests fail when you push
that does mean that you occasionally end
up with tests that are failing when
you've already done a commit and you
have to then amend the commit that
you've just done with a dick commit - -
amend and you might see some people
online saying never do that but the
reason you don't do that is once you've
pushed and then you do an amend you're
changing the get tree so because we're
doing it in the pre push we're stopping
you pushing that's absolutely fine to do
because it's never left your machine so
I find myself if I've you know committed
something not around the tests yet and
then go to push and there's one little
error that I've missed out you just
occasionally have to do a little amend
to that commit so again this is really
easy to setup the Huskie github page has
loads of information for this yeah it's
really simple to get going with the
package.json that i've shown you is
literally what i
so it's really easy to get going with
it's one last thing to touch on is the
continuous integration side of things so
this essentially means having a remote
server set up to run through all of the
testing for every every change to your
git repository so the ideal thing to do
is to have it testing all of this stuff
but then for you to also be able to
create and release from that environment
so people can just say okay where we are
now release this to the app store that's
the absolute ideal and there are tools
that help you do this but to be honest I
don't actually use this tool because as
I said I'm a lone developer it's easier
for me just to maintain my machine and
do sort of setup everything on my
machine I do have scripts or help me
push stuff out if anyone geez Fastlane I
use that quite heavily so I don't have
to think about code signing ever again
which is so useful but here's a load of
options these are just some ones I found
when I was researching it as I said I
don't really have an opinion on which is
better than others I've heard some good
things about bit rise working well and
App Center which is actually a Microsoft
product strangely I've heard good things
about that being able to test everything
but also release from that environment
directly into the Google Play Store and
the Apple App Store so that's just a
quick guide through that's not good
that's just a quick guide through some
tools that you can use to maintain high
quality code so we talked about type
checking with flow and then linting that
code using es lint and we talked a
little bit about how you'd actually use
a tool like prettier just to remove all
of those arguments about code formatting
and just then running through a unit
test for gest and they're actually tying
all of those things together with
get hooks using husky and lint staged so
those are just the tools I picked up as
I've gone along throughout the different
react native projects that I've worked
on yeah thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>