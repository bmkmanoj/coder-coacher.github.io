<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Vue.js, Scaling Vue In An Existing Stack, March 2018 | Coder Coacher - Coaching Coders</title><meta content="Vue.js, Scaling Vue In An Existing Stack, March 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Vue.js, Scaling Vue In An Existing Stack, March 2018</b></h2><h5 class="post__date">2018-04-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Fwj5YYrufns" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">first of all thank you for having me
it's very exciting to see the community
growing here like by the dozens every
time like I think the last time we were
about 30 people today we're almost 50 or
so so that's pretty cool to just see
everything going here the second thing
I'm very sorry I forgot all my view
stickers at home I got a good bunch of
new used stickers and I forgot them
because it was a very stressful week so
I'll promise I'll bring it over the next
time and today at the honour of talking
about scaling view in an existing stack
I guess not everybody is like working
view full-time already and it's more
like okay we're interested in view we
heard of it it's kind of cool and very
often we have to challenge that we want
to introduce it to what we have already
because like we want to stay on top of
modern technologies in general and what
we realize when working with it working
in greenfield projects is a luxury we
very often don't have it's like there is
an existing application there's a lot of
existing code maybe even an old
JavaScript framework that we have that
we want to replace over time I hope
everything is readable the slides will
be kind of dark yeah I hope I don't know
how to turn off but should work anyway I
hope otherwise I'll give you all the
slides so promise me there's something
interesting on the slides and one thing
when adding something there's like new
tech to a stack is always a very heavy
investment from many different sites it
needs like they're all engineers to buy
and to learn the new technology to get
like okay view sounds interesting okay
that everybody needs to learn it you
personally need to spend a lot of time
on understanding the framework of kind
of thing okay this is what the thing I
want to go with because you will
probably spend a lot of time working
with the new framework that you're going
to you use and also on the backend side
it also very often needs an investment
on their side and a buy-in from the
whole company or the whole team at least
you're working with we sometimes tend to
forget that it's not only us working on
things it's like really a whole team and
it has a lot of implications on many
sides
that sounds very negative I know but we
also know it's a very necessary
investment from
a lot of companies now once that don't
do it that don't go with the tech in
general they are the ones that fall
behind to a certain degree because it
gets harder to innovate to stay
competitive with everybody else and yeah
so views luckily a very cool thing to
invest in and so and that makes the
investment very worthwhile I would say
the other thing is while adopting
something new there's also competing
tech running in parallel on your front
end probably like almost nobody I know
or so like they have the time to say I
do feature freeze in my application for
one year and just poured over the whole
stack to the new front-end framework
that I chose because like I have all the
time and luxury that's almost never
having you always have to do it
incrementally so there's always like
this little piece of challenge to say
okay what if view runs in parallel to
angular or to ember or to just a plain
chick Theory CoffeeScript stack there's
a lot of challenges coming along with
this one so I'll try to shed some light
on this in general the biggest question
we faced was where to draw the line
between those kind of competing
technologies - we're at it and yeah
there's a lot of challenges coming along
so hopefully we can tackle something
today in the talk and it makes some
clear pictures for you the other thing
that for example we realized that a full
single page app even if view is like the
cool framework to do single page apps
it's sometimes like not the really good
thing to do up front and sometimes it's
also not possible to go all in on a
single page app as well so the beauty of
view itself is it's a progressive
framework so you can add it piece piece
by piece and this is what we're going to
do so my name is Roman I'm senior
software engineer at Co chip we got
recently acquired by a bigger a company
called clout piece and you will reach me
on twitter at cabrillo and I'll coach it
as our company Twitter handle so Pete
please feel free to reach out to me at
any point if you have any view question
or so referees talk
hmm and why am I talking to you about
this today it's basically because I've
been there and we've done that we went
exactly through the same challenges we
had an old stack the was based on on
CoffeeScript and some jQuery it had some
angular unit so it was like a MS to a
certain degree I would say so we had to
real kind of adopt something new and
move forward along the way so yeah I
went a little bit hat we have this
tactic datapack off a script and also
the other challenge that we had didn't
have a lot of resources at this point
there was a very small company very
small team but we had a ton of users
using our application on a day on a
daily basis and for them it's also like
okay how can you stay competitive doing
this yeah and also it's a rails
application in our case so it was a very
back-end heavy system and rails
engineers are very opinionated about
their build pipeline or how to do kind
of front-end and yeah so it was a lot of
fun to kind of draw this line in the
sand to say okay we gotta jump over to
view and this is how we're gonna do it
so eventually we figured it out and
hopefully this gives you some hope if
you have the same battle to fight and
it's sometimes especially in the
beginning feel like it's you against
your team by saying you you're the
front-end engineer and the team is like
that the backend guys you're saying oh
no no that's all bad that the important
thing is you need to really have them on
your side to say okay it's important for
us to work together to get them on your
side and show in view how awesome view
is in general and eventually it will go
more hand-in-hand at one point and
that's very important if you want to add
a new tag to your stack or so that you
say you have everyone in on your site
the important piece we did was I said we
can't feature freeze cars like if you
stop a year or even a month doing
nothing on your application this is a
month you will always use to your
competitors this is a month you'll never
get back so you always have to stay like
very agile and move forward and so an
important piece for us was to split the
whole process in different phases
and say okay this is how we try to roll
it out and how to move forward without
kind of putting a roadblock in our way
the first important part is reduce as
many unknowns as possible yeah that
sounds a little vague or so but it's a
very very important rule that I can't
emphasize much enough sir so what do you
mean by reducing things the first I'll
decide on one language that you were
gone going to use for example we had
CoffeeScript and some JavaScript and it
was all a little bit over the place and
we said okay if we want to move forward
we're going to use the latest version as
JavaScript so we basically throw ACMA
script in there had a babel build
process we squeezed it in there it
wasn't very easy at this point but it
said okay this is very important for us
to move forward to have a better modern
stack so you can grow on and get rid of
all the unknowns upfront so we poured it
for example all the CoffeeScript files
over to JavaScript first the other thing
is remove all the unknowns everything
you work on and you don't know okay
what's going to happen if I change this
what happened with kind of like some
global variables or so that's always
very very risky so you should know
everything that you're going to do along
the way say ok like this feature it has
this requirements and this feature has
dis requirements otherwise it could be
very bumpy ride and while porting things
over try to also maybe refactor like
bits and pieces and refactoring a thing
that can make a lot of fun yeah this is
fun ok no it's really fun or so to take
ok this is how the code runs right now
now with all the things I learned in the
last year maybe or so I'll take the risk
and refactor it a little bit along the
way a small example what we did here is
we had like this was just a plain
CoffeeScript function that's basically
adding a click event and if something
was kind of sending a check request to
the server basically JavaScript it was
all over the place in our application at
this point the first step we did is
basically just ported over to JavaScript
this eliminates as we said reduces the
scope of languages so we have one
language that's all JavaScript so we're
in a better site already and by
refactoring why not go the extra mile
and say okay like a reduce even jQuery
at this point remove it you don't need
it for kind of working with a small
click event on an array or an element
you can use everything that javascript
has to offer for us we have the array
methods we can fetch directly in the
browser it's also ported there so that's
quite nice and yeah just handle your way
forward again through the next phase
we're ready ready to introduce view and
that's why we all hear about I guess
introducing view to the stack is
probably the most fun part for most of
us because we finally can work on the
thing that we're really we're looking
forward to but it's also a challenging
part I would say when we want to
introduce view we first should choose a
very manageable target we should choose
a small target that we can that we know
all the requirements off as we say in
every unknown that we have is a risk so
if you work on a new feature while
adding a new view that's like this it's
always happens so they like new things
new kind of steps and feature requests
come in while you're working it so
ideally take something that you know
okay this is how it looks this is how
the API works this is you know it from A
to B the whole feature and that's like a
very good way to introduce view because
this lets you focus on introducing the
language or the framework in this case
and not on the feature itself so define
one clear entry point for view on the
page and then also let's go simple up
front load view directly from a CDN we
don't need to go crazy right now to say
okay like we do all our web pack build
process up front as we heard views very
progressive so it allows us to do a lot
of cool things with just loading view
from a CDN the other thing is we could
serve my screen is so dark it's very
hard to read we can try to use what view
offers for us out of the box as much as
possible view comes with a lot of cool
tools that we can leverage and to get
really good results up front so try to
really use what view offers you
one of the first recursive here very
often oh how can I get jQuery run in
view it's always like try to understand
what view tries to do how it works
internally and you will very fast
realize okay there's no way or no need
for jQuery to interact with dumb notes
on the page in any way like view has
everything figured out it just takes a
little bit of a different approach there
so what do you mean by clear entry point
this could look as simple as this that
you have like your div tag on the page
where say okay like this is where we'll
add view to the page just called you
feature in this case it's like a Status
page indicator for us we were loading
the status page from their API and
saying okay everything is fine and our
back-end services are not but it's the
clear entry point where say ok this is
where we draw the line for view we'll
take over the script that we can
introduce afterwards is let's go as
simple as possible we drop in the CDN
link directly and say ok we're ready to
write view out of the box so what we're
doing we just instantiate a new view
instance we give it the element for the
view feature and we define for example
it's currently loading because we're
trying to fetch the status and this is
our template how it looks like please
don't get hung up this is a string
template for now it's like just for the
ease of using of course there's a lot of
conversations going on you should never
use string templates I think for the
ease of the example and for sometimes
it's still fine to use string template
so yeah it's a good start the next
question here Barry off met the
challenges we also faced this how do we
pass in data from the outside into our
view application or the code that we
want to do I saw a lot of really really
weird approaches there where you hook
into the view lifecycle in the kind of
internal methods that they provide and
then do a lot of crazy stuff and import
other ten libraries that help you doing
it it's very simple in view as well
leverage to view life cycle itself as
much as possible view office again
everything that it has so just dig a
little deeper what it does what I mean
by this
for example view has a before mount
method
so the lifecycle if you've never seen
the view lifecycle I should have
probably put a screen for dead in there
but it basically go through that you
have like it's a created instance or
created fires in a function there then
it can check if it's updated anyway then
it's mounted and before mounted so it
gives you a lot of options to hook into
the view lifecycle to say okay I want to
fire my own methods along the way in
this case before mount works just fine
why does it work what we do is the
element reference is a small piece in
view that gives you access to the
element to the dom node itself when we
have our template basically what's in
here if we run view and it's kind of
mounted then basically what we expect is
that the template is in part where our
entry point was so if we take the before
mount we can actually reference this
element and then we have the reference
to the old Dom node to the one that will
just reference up there and then just
read the data set URL off it and you
have it already in your instance and
then you proceed forward and view will
take care of all the rest but this is
the easiest way of getting like data
from the outside past interview instance
without a lot of magic so that's quite
simple sir no question okay yeah the
other thing like a little tip on the
side if you want to do like more
sophisticated stuff up front or so or
maybe like this element reference is not
the right thing to do for you right now
there's also this way in view mounting
something on the page by using for
example the mount option directly if you
say like it's maybe programmatically
cause you pass in even the name for the
function or it comes from somewhere else
so you can use the mount function if you
don't want to use the element reference
and the other thing that I would just
want to show here especially in the
beginning it's nice if a lot of things
come from the backend view allows you to
use kind of a script tag passing in a
template and use this as a reference
note to say okay that's where the
template come from we had this running
at one point or so just to move fast to
certain degree because we didn't want to
port everything over to scream string
templates and a lot of things were
coming from the backend as slim
templates and they look kind of quite
difference it was a little bit work we
try to say for ourselves in this case we
use the script tag there and just
reference it directly and that helped us
also do save time and proceed forward by
adding view so that's just a small tip
on the side I had it specially for you
hmm so then the next big feature that we
should do by adding everything is we
should probably improve our build
process that we're using we've seen so
far we added this CDN link and we also
heard that our rails engineers have a
very certain way of doing things we want
to take control of what's going on we're
kind of view allows us to do a lot of
cool things and we want to control every
aspect of building the application of
building like JavaScript and our client
side and in this case all I can say is
that web pack is very much your friend
if you have not worked off who is not
work with that wet pack so far well
minority that's don't feel bad don't
feel bad it's totally fine but it's very
good to delight and there's most people
know web pack that I work with it and it
just speaks for the tool itself it
became quite for standard why because it
handles a lot of things like really
really well it figured out the complex
pieces of building something gives you
opportunities to kind of split up packs
by default kind of lazy load up packages
and if you go to web pack route it's
usually a safe bet that you have some
support for what you're trying to do
eventually there
I currently feel that like rolling your
own web pack or your own Packer system
it's like a hot stuff to do now don't do
it it's so worth it take what is there
and that usually works very well so what
did I mean by this before for example we
in our application we have this very
small simple build stack and well it's
like the whole the JavaScript files they
were kind of like in one place and then
we did our rails application magic with
the asset pipeline and what it did it
that just compiled files did like a
little bits and pieces here and then we
serve everything down to the app yeah
well that's not ideal especially as we
add our view to the stack it was just
added here and say okay now it's kind of
part of the whole junk there and will
kind of be served
to decline that's okay that's okay but
it's probably another thing that
situation that we want to have because
as we serve we want to have control
webpack allows us to do this so let's go
the extra mile and say okay why not
introduce this build step in parallel
you can add your own view files use
webpack build your own build process
exactly matching what you need and then
serve it alongside the old JavaScript
that usually works work quite well the
important piece here is we look at the
build process aim for a very very clean
separation when doing though there's
there's some times like this neato and I
did this era myself it was like okay
there were a lot of Global's coming from
the old code and as they both were
loaded on the same page and I said okay
like the new web pack stuff comes into
view application was using helper method
there was available globally try to
avoid this as much as possible because
at one point you will diverge to a
certain degree and then you don't want
to kind of like update everything in the
old stack you want to have it in your
new stack so take this time pull it over
don't kind of use any legacy code from
now on cost Wepa goes the way we want to
go further and also what allows you to
do is like it's the perfect time for us
to introduce use single file components
if you have never heard of use single
file components it's basically a dot
view file that gives you access to a
template the script tag and to style so
it allow allows you to write everything
in one file basically that's quite nice
how does this look like a dot view file
could look something like this on top we
define the template what's ok we use the
templates index here and it's just it
looks exactly like HTML works this is
very handy to work with in a bigger
scale you had like you have all the
syntax highlighting here and at this
point even by using webpack and using
view single file components you would
even have the possibility to add
something like your own kind of template
language if you feel like you want to
use Park for example just add in a
reference to the language bug and then
you can use Park templates right in
there or whatever you prefer
the next thing is you just define your
script on there how it usually works you
export default and create just the
object
and view that view loader running
through webpack will take care of kind
of parsing everything off this view file
for you and put it into one view
instance that it can then use as
components or however you want to
consume it what's the nice thing and in
this case I just poured it over what we
had before and this is how it looks and
I think it looks a little cleaner than
just kind of everything meshed into the
page are you ready for the real cool
stuff first a dramatic drinking pause
let's build a single page app well
didn't you say an SP doesn't make sense
yeah I set this in the beginning and it
probably is still right
going full SP still doesn't make sense
if we poured everything over that's a
lot of a world of pain I would say and
probably not worth the time upfront but
why the treated as different SPS when it
happily there's a single page
application running as part of my whole
application eventually what I could do
is I can't have different pages and can
treat all this pages as your own like
single page applications for example I
have a subscription page everything on
subscription wise kind of logically
works together like all the plans do
when choose and kind of credit card and
all the checkout process maybe this is a
thing that works together that's kind of
like logically very tightly coupled why
not move this in a single page app it
doesn't need to know anything more about
the application than just like okay this
is I know how to do subscriptions the
other thing is apart like in this case
for us we have build lists of kind of
people contributing and running from
github directly they're built so if we
treat this as a single page app it needs
to know nothing more than this and and
so forth on so everything that's kind of
logically bound together let's treat it
as its own like little bit and also what
it allows us right now it allows us to
go full in on the view ecosystem it has
a lot of really cool powers for us
there's a lot of cool tools in the Buick
assistan like if we want to use a view
router at one point or so that's nice
but I would say the most important
pieces view X or Bewkes or however you
want to put
it's like just redux
architecture state management library I
guess everybody or who has not heard of
mooks
okay cool everybody's using it that's
amazing so let's see if I can still tell
you something cool let's see the
important piece here if we want to go
full in on the view ecosystem here I
have a nice block post from get lap for
them even get lab like they did the same
journey as we as ketchup and after one
year to have the block post like this is
what github learned in one year of kind
of adopting view and the first big thing
that jumped out to me was okay just used
buicks don't go the route of doing
everything like component based state
and the application said it's very very
painful happier state of the application
split up to multiple pieces and levels
and everywhere
that's quite challenging and there's a
lot of things that can go wrong
eventually so UX
out-of-the-box is a nice thing to add so
let's go back to a cool build process
that we did before and now we're about
ready to create this kind of clean entry
layer as we said we want to build
different SPS
so what we will do now is we define what
Patriot on you go either one package
from the web pack build or you get one
from the old one and that's what already
pays off to why we didn't poured
anything from the legacy base or used
anything from a global code base out
there upfront because we now have this
clean layer and it allows us to move
forward in a faster way and we have
pages that run really on their own in
the new complete new stack where we have
everything under view and that's quite a
good experience and yeah that's usually
a good way to go and the next thing that
is we could do by using webpack in this
process we could even start building
multiple packs along the way treat your
SPS as their own little bits and pieces
and the dependencies split it up in
multiple files and load one of them on
the page that make sense maybe this
reduces the footprint of your JavaScript
on the page
enormous Lee gives you a lot of control
and removes a lot of side effects that
sometimes happen so what did we do for
us was the the entry point again was
very important to draw a very clean line
what view will take over and what the
old application or in this case come
from the back end what we did here is we
created a helper method that was called
like view app and we'll pass it in for
example users the method under the hood
what it does is like it says okay I need
to load something your users so I know
which pack I need to load and it will
inject it on the page for you when you
render the page but that's all it does
is that creates this clear clean entry
point if you're more familiar with PHP
in this case it's a slim template and
peach bead could look something like
this like the important pieces just
create this very clean layer or a second
now the view app will take over so what
this allows us for example users will
automatically load the users pack for us
and under the hood it's like not a lot
of magic it will just print out
something like this you app HTML or so
however you want to build it in one way
but that's usually a very clean layer
that's okay
it helps you separate it in a very easy
way the next challenge was again we want
to pass in data to our instance so the
other important piece is we have a big
back-end system there's all the data
there and maybe we don't have the time
to build an API endpoint for everything
so that's a very good start to say ok
like let's just add everything that we
have on the page to the view instance
already if we have like the whole
collection of our users just pass it in
because that's the one we need on the
page and we reduce again the time that
we need to load the data afterwards we
have it on the page ready the other
thing if we want to pass in something
like a role just pass it in you have
another page you don't need to go like
crazy and pull everything out it's there
for you and magically what it does for
us it can it starts creating like those
data attributes and passes everything in
that we want to consume so what we need
to do now is basically we want to
Mountain View we want to add our store
because we learned ok when a
steady-state management should all be
done maybe X and then we pass in the
data that we created to our view
application
so bear with me that's maybe a little
tricky yourself but that's like how we
try to figure out so if you have any
questions feel free to ask at one point
or afterwards so what we did is we
created ourself a little helper function
a little helper kind of library that
allows us to mount everything on the
page in a very simple way so what we try
to do is we just import view X and in
this case just leaves low - for entries
and merge and the important pieces will
create an app function the app function
should then take care of like loading
everything on the page and automatically
kind of do the right things for us to
prepare it in a consistent way because
the less you have to repeat yourself the
easier it is to kind of avoid any
mistakes along the path so the next
thing is to do we want to use the view X
anyway so let's just edit to view in
this case and the next thing is we also
know okay this is the view app element
that was generated by our helper so we
exactly know how the entry point will
look like so just create the node
reference and this is how it will look
on the page let's go for it that's also
a right place to put in maybe a default
store if you have like some automatic
methods that you want to have available
on every page like we had some static
values that were passed on like
depending on some languages or some user
attributes we don't want to introduce it
in every single store file that we're
doing we just use the app function to
kind of like build it for us already say
ok this will be available in every store
on every single page app anyway and
that's how we do it and the next thing
is with just the custom store that we
will pass in we'll just be merged with
the default store in worst case we don't
need to create a new store on a single
page app because it's very simple but we
maybe want to have access to the Bally's
that we have in every page the default
store comes for us prepared already
let's go for it
the next thing is we want to pass in all
the data and in this case we want to be
a little smarter we want to do a little
bit more about - maybe I'm point to have
a lot of control over everything so we
try to use props yeah what we do again
we take the node we render over all the
data set like all the values in there
and we try to parse what's able to be
parsis jason and the other thing we just
try to pass
sit down and create kind of a props
object that will look very much like how
you would pass some props if you are
familiar maybe with view one there was
like this
I think props data property at one point
that was Mason mostly thought to allow
unit testing in a very clean way but it
was very easy to kind of abuse it to
passing data using props data and made
something simpler in this case we cannot
do this any longer that Kazi was removed
from view too so he only can't pass
props from a root instance to a
component and this place we create our
prop subject to go this route to follow
what view wants us to do anyway and now
it's an important piece is we treat our
view instance we call it app in this
case and we're passing the store
directly they would want to use on a
page and we try to use a render function
here just after it's like very simple
way of adding the page the app to the
page and the important piece here is
that's where we pass in the component
that we was the first entry point that
our app should load eventually and
passing the props to the component so
that makes it quite nicely to consume
everything and here we take like the
view instance and mount it to note that
we have reference on a page seems like a
lot of magic it's quite simple actually
and kind of it just allows you to do
everything in a very consistent way
so how would for example our entry point
in our pack file eventually look like
it's just as easy as we import the app
library we import our custom store for
example for users and we import our main
view instance that we're going to use
what's the users index file or how
you're going to call it and all we do is
kind of would pass an app say users and
users and pass in the store directly so
that's nice and our view file could look
as simple as this or say okay we a loop
of all the users the important piece
here is everything we pass before on our
view app in this case we can consume it
as props directly so this allows you to
even use like validation on it or ass
and default values if something is not
there so it gives you a lot of control
over what's going on and just makes CPI
consistent and very easy to maintain
yeah
the next thing is if your work we stored
there's like one thing I want to put in
cut like I saw it at some kind of
project that a review if you don't use
gathers yet I can highly recommend to
use gathers as much as possible there's
like this way of consuming a store
directly or use it as a computer
property in this case I would highly
recommend to use this store add gathers
to it as much as possible and then also
already think ahead and try to build
those getter system for you as clean as
possible because it was that before
whenever you have to do a lot of things
manually there's a lot of things that go
can go wrong or you have to keep a lot
of things in mind here's it for example
what we try to do is if we have a lot of
gathers and this is a very simple
example but like if your store is like
really large with a ton of different
stay it's gonna come from different
modules even what we tried to do is we
created something like in turtle gathers
that were just kind of prefixed with an
underscore that we say they are not
thought to be consumed from the outside
but we defined one that's called for
example curent that has like all the
important bits and pieces in there and
shares it for me so this allows me
basically on our component side we can
just map over to get us and pull the
current one in and this gives you also a
very clean API of kind of working with
even more complex stores in a very nice
way I'm not sure how familiar
everybody's with computer properties and
what's their big benefit but the other
benefit you get with it Gators are
internally also treated as computer
properties so that said if you have your
current one and something in there
changes it will automatically reevaluate
but if you have a more complex getter
function in there like these even is is
probably a simple operation because we
just slice an array but what we try to
do is we leverage the kind of the output
of the computer factory the cached value
in our Gator that we send down to client
and for more complex operations this
allows you also to kind of prevent some
re-rendering or some kind of
reprocessing in a very smart way and
then I would say the important piece is
if we have everything running that's
when you can get ready to scale as we
said there can be multiple single page
apps in your application
building and clean wait let's say if we
have like three different packs that we
end up doing if maybe you want to
consume some of them's multiple pages if
we're is something that's like rendering
lists what prevents me from using this
render list function on a user list page
or so and maybe also in the admin
interface to render like all the users
for the admin interface be smart about
you were using what you've built or so
and using view and all the single page
apps and those extra packs or so allows
you to really kind of be very fast and
quicker than updating things the
important piece there is prepare some
scaffolding and generate as as much as
possible if you do a lot of things and
reproduce what we did for example we
created a generator and rails or just
say okay generate an you view app called
settings maybe and what it does for us
it creates the pack filed the app file
and a spec file for testing already with
some boilerplate code filled in this
just allows us to get a very clean entry
point for every new page we do and if
you scale your team if you have multiple
people working on something this allows
you to be very efficient and will
prevent kind of failure or different
approaches at one point so this is very
clean also what I can only highly highly
recommend is everything that you do try
to back it up with a lot of solid
patterns and specs ideally we don't want
to five things breaking for us along the
way and if we follow this and we kind of
went through this process and we're now
at a point where it's say like we have a
lot of really good times ahead
we're really fast now kind of was
building new features whereas paralysing
was having multiple people working on
different features at the same time but
yet the code underneath is all usable
and everybody knows how the other piece
pieces work so that's really nice for us
and the big question in the beginning
for me was always why do want to add
something to the stack and this is the
things why it pays off for example we
had a lot of acceptance tests before
they were taking a long time and this
was like the amount that we need to
verify that everything was running on
the page
because you had no cleaner way of
testing everything running with
CoffeeScript and jQuery and you had to
verify like the simple pieces with
acceptance tests that's the only thing
that gave you assurance
now using view we can do way more things
in unit tests
and this shaped down a lot of time from
our test sheet in being able to ship
faster and having less like error-prone
eres running into pipelines the other
thing also by during this process down
Page Speed basically we were able to
kind of have two initially paid
rendering on one of our heavier pages
with a very simple stack and kind of
moving this way down from two seconds to
kind of 0.25 seconds so that's a huge
win for just like going way down up for
clean kind of architecture and using
this and that's it before it also allows
you to kind of scale your team to work
on different features at the same time
everybody can work on its own and
there's no way of like you're breaking
somebody's else's code or somebody
else's pages so it gives you a very
clean way of working on your application
the good and important piece for me is
you made it all very enjoyable going
down the route and why because basically
view is for me JavaScript just done
right thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>