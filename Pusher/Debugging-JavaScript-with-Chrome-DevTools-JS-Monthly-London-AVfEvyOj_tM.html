<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Debugging JavaScript with Chrome DevTools - JS Monthly London | Coder Coacher - Coaching Coders</title><meta content="Debugging JavaScript with Chrome DevTools - JS Monthly London - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Debugging JavaScript with Chrome DevTools - JS Monthly London</b></h2><h5 class="post__date">2016-05-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AVfEvyOj_tM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I want to focus mostly on summers
less well known features die inside of
dev tools but to begin with I'm just
going to go to the fundamentals and try
to point out some of the less well known
features in dev tools so the main
feature is allows you to pause execution
and then step through your code line by
line and that enables you to can observe
your code and see at what point things
start going wrong so at each point it
shows you they can load the variables
and you can see if their values Maps
what do you expect them to be or is
something different to celebrate point
you just click on the line number and
then next time that lines running in
chrome chrome is going to pause and give
you control about how you step through
your code instead of clicking on line
number you can also use a debugger
segment and that is the same thing as
clicking on the line number but you can
do it right in the editor without having
to find the right file inside of your
dev tools code in addition to showing
you the local variables chrome is also
going to show you the call stack which
is explained okay white is function
running so what were the functions ever
led up to this function being called by
clicking on the individual clocks call
frames you can see the local scope in
each function and those values are also
then available in the console for you to
work with in JavaScript a common problem
you're going to run into is asynchronous
code because every time you make an
asynchronous call you're going to use
all the context of why the caller's made
so in this example you can see we call
the render to do list function but we
don't understand why our to do this it's
being rendered the Chrome has their
checkbox in a sig trunk to the top right
and if you enable that chrome is going
to persist the oldest state and
information in the call stack from that
point when the asynchronous call is made
so in this case you can see that we were
calling initializing our app we were
loading some data and then because we
now have the data does the reason why
our to-do list is being rendered and you
can see in this example is you doing
timers and it's also using promises but
if you use something like an ad request
the asynchronous call stack also works
and
can actually go back up in a course I
can see why your Isaac request was made
with the parameters it was made with
another thing that's easy to miss is
that after you step over return
statement you can find the return value
inside of the go pane so in this case
it's just a simple value but it's
something more complex you can
right-click on it and store the global
variable so any local scope variable you
can put in the console and in there you
can then call functions on it or process
the data in some way and if you have a
if you log of an object to the console
you can also use stores Bob available to
access it and work within a better way
another issue you can run into when kind
of working with variable values in in
dev tools is wrapper objects so if you
try to display a backbone model or an
image with J's model chrome isn't going
to show you the actual contents of that
object it's just going to show you the
internal data so in this case if I
display this immutable de-ice object it
showing me all these internals for me to
address that I'm redevelopment to me and
it's quite difficult to actually make
out okay at what point where is match
your data the chrome of the feature
called custom object file matters and in
this case I'm using a tool commutable
dev tools and it displays not the actual
object representation of this object
instead is renders just the content
that's relevant to me rather than
displaying the mean to address internals
so once you've pause do you want to step
for your code and I think most of you
are familiar with the basic stepping
controls you can click resume to just
continue running until you at the next
breakpoint most commonly you're pro
going to step into over the current
francs from just go to the next line and
see what the next step in your code is
if you have a function call in the
current line you can also step into that
function debug it in more detail or the
opposite of czardas you can step out of
the function and just run until the end
of the current function return' go up in
a call stack and then pause again a
chrome has a few features at i/o you a
bit more control about how you start via
code a common issue is that you want to
exclude certain file from your code
and you can do that using black boxing
so in most commonly you're going to use
that with library code like jQuery or
underscore and in this example I'm
calling the underscore filter method
method to filter a an array based on the
parameter the function a callback
function that decides whether not to
include the array value in the new array
but normally if I try to debug my
callback function and step into this
filter call I'm not stepping into my car
back I'm stepping into all this and
Oscar J's code which is difficult for me
to understand it makes it hard for me to
actually find ok what point am I
actually going back to my own code but
if I black what the script by just
right-clicking and selecting black or
script the next time I try to step into
this filter call chrome is going to run
through all of the and Oscar code and
it's only going to pause again once it
goes inside a file that belongs to my
own application another feature is
restart frame and different from all of
the other stepping features because it
allows you step backwards in your code
so if you hit a breakpoint you can
actually read run the run the code that
ran before he hit it so for example I
have this packet a holiday cost function
and I'm pausing at the end of the
function and I can see well the cost is
not a number so that tells me something
inside of my function went wrong and if
I right click on the call frame and
select restart frame chrome is going to
jump back to top of the function and
allowing me to step through that
function again so I can step through it
line by line I can see well at what
point doesn't ever get introduced and
I'm running get a flight cost everything
is still fine but then when I step over
get halter cost that is where my arrow
is being introduced so again I can use
we start frame to go to a top of the
function and this time I know what
function is broken and I know which one
I want to step into so when I do that
you can see the problem is that I'm
trying to pass this value there isn't
really a number and that is why I'm
getting the not the number value and my
application is broken so restart frame
is a really useful feature but it's not
true time for debugging and has a bunch
of limitations so for example if you
modify a global variable that isn't
going to be reset
because Chrome doesn't persist all of
that state and likewise if you modify a
parameter value there isn't going to be
reset either one feature Chrome recently
added is called nurples here and the
name pretty well explains what it
actually does so for example you can use
it to disable debugger statement so if
you talk from to never pause an aligned
within debugger statement on it it's
going to ignore and disable that
debugger statement and later on we're
going to see another use case where you
can use never pause here at some point
while debugging you're going to run into
compiled code which is difficulty bug so
in this case it just minified code which
is very hard to actually see what's
going on but more commonly you're
probably going to use something like
babble in solution to that is source
maps or first of all if you don't have a
compiled code you can just click a
pretty fly button in chrome and without
having any other different ruling you
can just get some formatting and have a
better understanding of what your code
actually does but normally we do you
want saw snaps and fourth maps describe
the relationship between the code source
code that you wrote and the code that
your compiler generated so you have to
tell the compiler in this case uglify
yes that you want to generate a source
map and then the next time you try to
open your coat and chrome chrome isn't
going to show you the minified code in
more instead it's going to show you the
actually the original source code so
let's look at the source Maps file and
what it actually contains they're two
important things here once the sources
array which is it's a list of all the
original files and notice how chrome can
access the original source code and the
other is the mappings and the mappings
look kind of cryptic because there are
these alpha numeric values but really
each of these alpha numeric value each
this is an array and the array describe
okay in my compiled source code this
index this column this line in this file
refers to this other place in a
different in my original source code so
when you create a source a source file
when you create a breakpoint in your
compiled in your
source map code chrome knowledge where
in the compiled code you want to pause
forever actually in practice you're
going to run into issues with this so
for example in this case I'm trying to
set a breakpoint on line three but
actually chrome is moving a breakpoint
further down into two line five and
there are lots of reasons why that
happens because they are all these this
there is a difference between a code
that you are trying to debug and the
coder you wrote and the code is actually
running inside of chrome so for example
the reason why this particular thing is
happening is because my three different
statements to kind of add up the cost
again and again has been merged by my
compiler into one single statement and
that means chrome can no longer pause on
the individual statements another issue
is that chrome doesn't actually map the
compiled variable names back to the
original viable aims so in this case you
can see all those minified variables but
if you're using a babel probably running
into it that you try to back to the
value in the console or trying to hover
a value but actually chrome doesn't
recognize it anymore but as like an odd
that chrome doesn't actually it doesn't
recognize that value anymore because the
source map has specifically has this
names right we should really tell you
tell chrome what the relationship is
between the compiled variable name and
the variable name in your in your
original code but in practice none other
kind of major browsers are using at the
moment but if you try Chrome Canary at
the moment there is an experiment that
actually reads in that names array to
actually show you the original variable
name the last issue you have assortment
of this block boxing and there are lot
of situations where when you use it with
swath maps black boxing doesn't work
correctly and it can happen that if you
try to step into a black box file rather
than stepping straight through it and
ignoring it chrome is he pausing into a
black box file which shouldn't really be
possible but again this is something
that the reason it autumn issue for that
somebody at Google is kind of working on
to make it better
everything I talk about so far I kind of
seem to know your code fairly well so
you know a file and line number that you
want to pause on but in practice a lot
of situations where you're not very
familiar with the code either because
you haven't worked them that had to get
a bit of the code before or because you
think you understand the code that you
wrote but then you showed a chrome and
Chrome with a completely different
interpretation so for that Chrome with a
bunch of behavior based break points
that I'd like you to observe and
behavior and then chrome can show you
the code that was responsible for it so
for example you can say it went to pause
when an API request is made to a certain
end point or when the text of a button
has being changed and I want to
demonstrate these break points using it
to do MVC app so this is back when to do
mercy and it does the normal to do it to
do application things so you can add
to-do items and you can mark them as
done and specifically a meters in the
markings done functionality so the first
thing I want to understand this what
does it carry what does he actually
evangelist another ones when I changed
this done state and to do that I can use
in vendors in a break point so I go into
sources and on the left you can see all
the break points are currently activated
right now I don't have any but if I go
into vendors no break points I can tug
for him I want to pause whenever there
is exha given being handled so next time
I try to change one of these by clicking
on it
chrome is going to pause inside of the
event listener in this case you have
occasionally reviewing jQuery to
actually create the event listener so
I'm pausing in code and it makes it
difficult to find the application code
that I need to debug but this is a good
example where you use black boxing so if
I did like disable this file and
continue and then try the same thing
again
you can see this time I'm not pausing
inside jQuery anymore it's hiding those
two core frames and going straight into
my application code and if I step into
that line you can see all this really
does is when I click on this button on
this toggle it is changing the completed
value on the model that is used for to
render this particular to-do item view
so now I understand that click on the
button changes the model but by looking
at the app I can also also know that at
some point it dumped the model train
propagates to a Dom change and to do
understand how that works I can use a
Dom break point so I can find the Dom
changes actually happening so I inspect
the element and just collapse this and
then if you look at the the source code
and how it changes every time I activate
or deactivate an item the complete Exile
is added or removed and by
right-clicking on this I can like break
on and then attributes modifications and
in this case the attribute I'm
interested in is exhaust attribute so
chrome is going to pause every time that
attribute is being modified so now if I
do this again and change this item
chrome is going to pause it's still
going to go into jQuery but if I can go
up and go back to my to-do view and it's
pausing in the render function and it's
toggling in the class on my to-do view
element based on whether based on the
value of the model models completed
value if I go back up liqueur stock I
can also see that this still originates
from my original model change
one feature of this application is that
when I reload it all the data is
persisted so if I add a new to-do item
and we load the page that's still
available in the white chrome does it is
using local storage so if I go into the
resources tab and local storage I can
see that each individual to-do item has
a representation as well at the local
storage item with the data in it and I
want to understand how does the
persistence actually work what part of
the application code is responsible for
it but unfortunately chrome doesn't have
a break point allows me to pause when
our local storage data is being modified
and I can tree simulate that myself
using a debugger statement so I can use
this do this by overwriting the local
storage dot site item function and all
that I want to do is pause and I do that
with the debugger statement so the next
time this application tries to access
local storage chrome is going to pause
and show me what it's doing that so it's
pausing in third a little snippet and I
can see in the course dock this is the
set item call and in the course so you
can see this file a background local
storage which is a plug-in that handles
all the persistence so if I wanted to
for example replace my local storage
persistence where's the server
persistence I could just replace this
plug-in with different code and so I can
find out what code is responsible for
storing the data in a new place how that
works there was one problem with this
because if I now try to interact with
math it no longer works because I
overall I overrode the set item function
that my application was relying on so in
practice in a lot of taters he want to
store a reference to the original
function so in my new function I still
have my debugger statement but I'm also
calling the original function with the
key and the value that I want to store
and I'm returning the return value of
that and by doing that my application
can no longer tell the difference
between my custom function that I used
and the native local storage function so
everything is still working exactly the
same
because my application isn't impacted by
this change and you've seen you can use
a debugger statement kind of create a
custom breakpoint to put you back
certain functions that are called a new
application but you can do also do the
same thing for object property access so
if you have an object that's been
written to or or read you can pull it at
that point so you can use that for
example if you want to find out what
part of the code is changing your cookie
so that is just a document a cookie
assignment that you can pause on and
likewise if you have a behavior on the
browser where some code keeps changing
the body of scroll to position in the
wrong way you can also pause on that
using body of scroll talk one way to do
that is use an opt-in to define property
so you have your object with the stock
render body you have the scroll top
property and then you can pass in a
setter in a getter in this case all I
want to do is pass in a set of function
and then when body or scroll table is
assigned to you and when the school
person is assigned a new value chrome is
going to pause and show you okay what
what part of the code is actually one
foot for that and doing that has some
problem again because as before
now the original functionality has
stopped working so if I actually change
assigned body or scroll table now it's
no longer going to actually change its
global this is on a page and and you can
fix that but it can be quite tricky to
actually find the original set a method
that is responsible for updating the
scroll position so I've been working a
library called JavaScript break crank
collection and it just gives you a debug
property set function that takes care of
adding the break point and then also
call through to the original set of
methods or autography
that's like a simpler version which is
like debug scroll and it combines a
bunch of different things that can be
responsible for scroll change on the
page so if this position on the scroll
the scroll position on a page is
changing you don't know if it's a body a
small table assignment or a windowed
scroll to your window scroll by but
giving debug scroll all those eyes are
going to be combined and you can find
out
which is responsible for that change so
if you want to try that I have a Chrome
extension that kind of contains that
which is the easier thing to use I want
to talk about more about posting
exceptions because you're going to run
into some issues when you're trying to
use it so I tend to have an enabled most
of the time because it just make it a
lot more obvious when an error occurs on
a page because chrome is going to pause
rather than just showing an error inside
of the console but the first issue
you're going to run into is that when
you look at the console after pausing an
exception you won't actually be able to
see the error message there the error
message only appears after you click on
resume but clicking resume in you're
going to lose all your local debugging
State and so it's not a good solution
but luckily most of the time chrome is
going to show you the reason why you've
paused at the bottom of the car sack and
in the case of pause on exceptions it's
also going to show you the error message
there so you can find out what error
occurred at that line without having to
lose your state next error if you you
can run into is blobby exception
handlers so certain frameworks or test
runners are going to try to handle your
exceptions for you and show them to you
in a better way but that means when you
actually try to debug your application
chrome isn't going to paused in a right
place anymore and so in this case I'm
initializing my app and if my in the app
owner often fails and there's an
exception I want to report that
exception to the server so I know that
something went wrong in the client and I
need to look into it but that also means
I'm not like an porting in a right place
and makes it difficult to find where the
original exception occurred but if you
look at the the screen you can see
there's as posix the code exceptions
checkbox which tells chrome to pause on
every single exception that's being
thrown even if it is eventually being
handled in a try-catch block so the next
time if I try to there's an exception
chrome is going to pause but
unfortunately again it's not really
where I wanted to pause and that's
because my application is using
exceptions for control flow in some
places so in this case I'm trying to
detect whether
Stringer's validation or not and one way
to do that is just using the Dacians
path method and if it's facing exception
I know it's not Jason whereas if it
passes validly I know everything is fine
in that's Jason and and there's nothing
wrong with this behavior so application
is fully functional and this exception
isn't indicative of anything being wrong
in my application but it also means that
chrome is gonna pause here again and
again because my application is using is
Jason a lot but isn't actually a problem
so again and again I'm pausing somewhere
where there is no actual defect but
again this is something you can solve
using never pause here so if you can if
you tell chrome to new a pause in that
particular line and then continue you
can see the next time chrome is actually
going to pause in the particular past
line of the code that isn't actually
broke that it's actually broken and I
can actually find my actually defect and
I have imposing the right place and have
all the kind of local debugging state
that I want to have the last thing I
wanna talk about is remote debugging and
to understand that a good way to get
started is just to understand the dev
tools they're kind of separate form
Chrome desktop so dev tools is just a
web app so if you CSS HTML and
JavaScript to kind of build its UI
whereas Chrome desktop is kind of C++
application with v8 and everything and
the way this worked is there this is
WebSockets connection between the two
and the dev tools can say well I want to
have set a breakpoint as particular line
and then when that breakpoint is hit
chrome is going to send things like a
call stack or the local variables to dev
tools and dev tools is going to display
that and the fact that these two things
are separate means that you can actually
applies what you use on either side of
this interaction so for example using
remote debugging you can connect your
Android phone to your computer with the
USB cable and then enable debugging on
the phone and you can see all those the
pages that are open on your Android
phone and in dev tools select which page
you want to debug on on your phone and
if you don't have the right Android
phone available you can also do the same
thing using a virtual Android device and
this is my way you can
use dev tools to debug node applications
so this is a tool code no inspector and
if I run it it's going to do two things
it's going to run the node process with
remote debugging enabled and it's also
going to open a chrome window where's
the that's loading the there's loading
the dev tools and in dev tool then able
to connect to that web sockets
connection on my computer and get access
to the debugging data and in a similar
way you can swap out the dev tool
themselves so you can debug directly in
your editor and a bunch of editors have
integrations with the chrome debugger
protocol so it's a tool called
a plugin called sublime web inspector
and you can just use it to set
breakpoints directly inside of sublime
and it's going to show you all the kind
of usual things so it's going to show
you the call stack and a kind of local
value about variables but you can see
that in sublime isn't really build for
that kind of functionality because all
very text-based if you try something
like Visual Studio code you can see
there is a very similar experience as
you have in dev tools so if you want to
learn more I think the best resource is
dev tools test Foam enhancer which is
just a collection of tips but each one
comes with a gift that kind of explains
how this code actually works and so if
you want to find the links to that or to
the slides you can go to that URL -
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>