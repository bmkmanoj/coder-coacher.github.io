<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Do Not Yield to JavaScript Generators - LNUG - August 2017 | Coder Coacher - Coaching Coders</title><meta content="Do Not Yield to JavaScript Generators - LNUG - August 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Do Not Yield to JavaScript Generators - LNUG - August 2017</b></h2><h5 class="post__date">2018-03-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/O4BrIvib0Dg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone let's talk about generators
today how to write a simple a
synchronous code and in a beautiful way
I'm working with a full stack developer
at theater so theater is an agency we're
like doing web and mobile developments
and working for big corporates as well
as young startup we try to help them
implementing the solution using square
modeling here's my details also if you
want to give me a shout on either of
these social network feel free so what I
would talk today I would talk about
generators so first we're going to
details like what is a generator because
maybe some of you don't really know
exactly what a generator is then I will
talk about one one library called curve
which maybe you have heard of which
helps you to write asynchronous codes
using generators and then talk about how
ku is used in KOA so for those who
doesn't know core is a node framework
like Express so let's not generators and
what is the generator so you have
several terms I have to understand what
it is so first of all first one is
generator function as you know a
function is looks a bit like that it
looks like a classic function with a
star and a yield statement is to ever
return you can have several yields in
the same and so this is not a generator
this is just something I will define a
generator and to get a generator is also
sometimes called generator objects you
need to call that function so when you
call generator function you get
engineering two objects and the units or
objects will expose a next method to go
to the next step of the generator and
then since it's exposing this next
method generator is also an iterator you
might have heard this word before
so iterator and JavaScript is any object
exposed and next method so a basic
knowledge now of the terms to understand
the rest very simple example how would
you come to three using generators so
here I'm a generator function very
simple first yield one them to I stop by
returning three I instantiate my
generator by calling the function count
to three and then I call next three
times and when you leave when you when
you call the next election generator
get back an object that contains two
attributes first one is value and its
value is exciting exactly what you yield
it or returned on a second one is done
is a generator done if it's always equal
to force if you are yielding when it's
equal to true when you are returning and
you can return only once in a generator
now let's see how you can pass an
argument to the generator so here is an
example of a counter and if you can see
I'm doing a while infinite white rope
loops and infinite loop it's probably
one of the only place we can do that
safely
16:08 you are always posing so you can
easily like this is just me and my
generator will never end but it doesn't
matter because if I don't call next
function it's it's okay so here I just
want to I define my shoot increments
being the result of my yield and then if
I ask to increment I will just increment
the counter and I'm calling my generator
next several times the first time I just
start the generator gets the four which
is my initial value and then if I call
Jen next of true I'm setting increments
as true for the rest of the execution
then it's looping again and again and
you can see if I say gen-x of true
hammock actually incrementing the
counter and if I set false and not so
it's an all other really useful feature
when you lose narrator need to be
careful of what we call closure here is
a narrator I'm doing actually a map over
an array and inside a map and I'm using
a function of course and if I try to use
a yield it's not gonna work because
he'll is only defined in sign generator
and here my map I'm actually inside a
function so I can't come to the
generator so this vector is actually
broken so you need something need to be
careful about you can't really use
functional programming engineer mater or
actually at least you can't yield inside
functional programming now maybe
something that we this quite useful
because maybe I'm wondering how can I
use a generator one common way of using
it is to iterate through generator so
since you need to write or you can call
the next function so here my generator
is the second block you can see the
greeting generator I'm just defining the
name
the result of my yield yield such a
weird object containing one the first
first attribute being a function of
Sigma being arguments and I yield twice
first one I will get name is no
arguments second time I will yield
console.log with a string of arguments
and if you look at my iterate generator
function so what happens is that i do
again infinite loop so we just run until
generator is over and what I do is I get
back the dawn on value from the result
of the yields by calling Jen up next and
if I'm not done I will just use we
justify my next parameter for my gender
next being equal to the result of the
function call with the arguments so
doing that I will actually if you look
at the greeting generator again you will
see that name will be the result of get
name with no arguments and I'm sure it's
on very very simple and then next type
like next step I will console log hello
my name is the value of name so I will
see hello my name is brynjar so this is
this is maybe the simplest way of
iterating for generator by passing the
result of the previous yield to the next
step of the generator and so now we're
going to look into code so close the
library that will that is used to be
able to write a synchronous code in a
synchronous way because instead of
yielding functions and calling them what
you do is you yield from mrs. C so here
I have two function let's return
promises I'll get name on gate score
first one is off to bring on the similar
miss off to 12 my generator
I will first define my name the result
of the yield of get name second one
different score result of the kids call
of the name and then I will execute my
generator by running wrapping my
generator in Coke
if you give me a promise I mean like
promise not then I get the value which
will be the return value of my generator
and so it looks quite quite nice it's
really easy to read and release it to
like understanding you when you a new
even two generators but maybe like
there's some magic behind on this is
what we're going to look into now so we
try to live code on recreates code from
scratch so here we go this is exactly
the example I just showed you before
the same method returning pharmacist the
same generator so now if I run I have
get Bruno 12 exactly what I expected so
what's going to do it can I just remove
CO and we're going to define together so
Co is a function it takes generator
objects and it's returns promise I think
so it's like that new promise so if I
promise
resolve reject let to some stuff with it
so how I want to proceed I would like to
have relative starts my generator to run
but for that I will just call run of
ghent dot next is ready to start an
execution so now interesting part is
what is the next rent function that I
want to want to implement so sorry no
run function so the run function will
take one argument which will be the
result of the yield of the yielded value
from the next step of the generator
so it's an object containing value and
done and what do we do with that so if
if it's done with the easiest one to
start with
if it stops if it's done it means I'm
returning like value is probably like
the last value of my generators I just
want to return it it's my string at the
end so you want to return it
seven returns us to resolve value cool
now what happens if it's not done and
then value is probably a promise one of
the premier eaten by gate name again
score so what I want to do is I want to
do value dots then and then so we return
that and then I will go into one
unfulfilled so field function so what
happens when everything goes well on
fill fields
it takes one one argument with the
result of my promise and do something
with it and what I want to do is I want
to call the next type of a generator
with that's with the parameter being the
result of the previous service promise
for that I'm just gonna call run again
with gen thoughts next of results so
here if I don't do any mistake when I
run I go to the first type it will yield
some value with the return value of my
promise and I will inject it and
generator for the next step so if I try
to buy do any mistake apparently I did
brackets around odds suppose
still to get my brain or 12 say
something working but I still have a
problem I need to resolve that no
actually I resolved at the end okay
that's always the same so now what
happens if something maybe doesn't go
well doing doing your promise so let's
say now we'll change it with my promise
and here I will just get an idea and we
turn depending on the value of the ID if
I D equal equal 1 it from is resolved
else it promised got rid if I will
resolve this one and now and now my get
score will take the name of the
parameter then return different value
depending on the name
so if name is you know I return the same
thing else I will be checked simple one
inject an error so now if I run my
generator I need to instantiate a
generator with an ID so that Senna if I
take something else done once I take two
I should have an exception ok so I have
rejected define yes of course yeah
promise that's your rights
cool error ejection error so we get
exactly what I rejected so now wants
maybe code to be able to handle that so
for that we just need we need to be able
to handle something when you promise
doesn't resolve and so then we have on
failure and what want to do a non
failure is actually almost the same as
when everything goes well the only
difference is that instead of calling
next we want to call the third method of
the generator which is the way to tell
generator something once wrong you have
to write an error so pass it back and
now if I want to hum that no generator
function I can just do a try/catch as
classic synchronous programming catch
it's 95 to five minutes I'm still
rejected
it's scores rejected an error and when
UN gets going in the yields then
shipping on failure unfair I suppose
okay can we proceed then often define
okay that's probably why okay I guess
I'm lost in my life coding so I get the
easiest way to show you the solution not
that far from that far from it so the in
the same like same curve we have seen
the function with before if here we have
on the same same way an unfulfilled
function we have almost the same with
the return gen next of results on era we
return the throw so I don't see why
we're in a mistake that's probably a
typo somewhere and then what happens
next the next step once we handle maybe
is that if the generator is failing
itself so if I throw in the fan
generator need to be able to try catch
your run function so you wrap your
return run into a try catch and return
whenever you want to explain to the user
that's actually his generator is failing
once you should probably check his check
is code and so actually scan impressive
you see like rewrote comb in like 20-ish
lines and we almost have everything the
only thing missing compared to the real
code that right now I can only yield
promises the real KO you can you know
the kind of objects like values or
functions kind of things but well the
only thing have to do is complete this
if here and do all the other different
cases and you can you can have the you
can record the real code so if you want
to have a look at the the gist you can
go to my github there is the 20 line of
code and you can look at them to
understand details how it works why
would you use Co Co is kind of it's just
almost everywhere look at this is the
NPM package screenshots and there's like
3900 offenses and you can see some from
for like over here so this is probably
why we're gonna go to the next part of
my talk which is cooperation one because
the white version 1 because version 2 is
now using a single weights but version 1
is using generators so as I said before
quois
nodes framework very close to express a
stack of middle wires and
with expresses that each meter where is
a generator and this is an example of
the hello world from the documentation
so define want your app to use two
middleware the first one is a logger log
how long this request takes two to go
through and the second one is to return
hello world and how it works is when you
yield next you actually go to the next
generator so this first line of code up
in executes chilliest defined a new date
then going to the this body equal hello
world and then coming back to checking
how many how many milliseconds this
house has taken and how kawaii is
working so this is the next simplified
version of coin 20 now 20 lines again
and the important part here is a lot of
details maybe it's not that difficult it
takes me a little while to understand
but the important part is the callbacks
this is the callback of the HTTP node
server and what it takes it takes
request response as usual it generated
context the context will be shared by
all generators the generators will
actually only do one thing is to modify
the context to context you contain whole
information about the response the
headers everything you can imagine and
after that it's just one big from this
resolution so you just wrap in Co one
middleware and then you just do dot then
if anything went well you just return
the response with the body of the real
difficulty context and if there is an
error just console out the console error
what happens and no may be wondering how
what is there is this compose function
is compose function is actually taking
one of each of the middleware in your
stack and returning a super middleware
containing all of them and how they are
run if you look at this diagram so you
have the time in the y-axis and first
your starting for the middle one is
running instruction as soon as as soon
as you have a yield next next is
actually your promise it's actually a
coop from is next is next to narrate
next meter we are wrapped into code so
it will run the next generator as a
promise but next numerator is also
reading next which is also a promise so
it will go to the third generator that
will be run when the generator is over
the promise is resolved you come back to
the previous one the same the end of the
previous one is executed for my system
so when you come back to the first one
we can finish the grecian this is how
you create a stack of media we're using
generators so that all of them are
actually a simple promise that is
generated using code and now like ko is
using a sink awaits in a new version so
I think weight is probably liked a new
way of writing a synchronous code in in
in node in javascript in general but for
any for any reason URL stuck into an old
version of node because you have an only
fry structure you can update your
dependencies then generators available
since not 4.8 whereas synchronous only
for patients at one point six so
generators is quite an old speech run on
nodes and it allow you to do some very
powerful stuff and some time actually
you need generators you can't even use
only a sink awaits
I think final point into red X Tiger
photos from 10 developers you need to do
something about what you are yielding
you come to Douglas async/await I think
when you just to wait the forest to be
resolved before Co it works really well
so for Kauai also so then you can just
use ice in Kuwait instead that was all
for me today and if you have any
question feel free to grab me afterwards
rounded ear and all the tools piece of
code I shown you today the available on
github
it's fun to have a look you always
wondered how Co our code was working
if you're free to check out thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>