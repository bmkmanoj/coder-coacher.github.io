<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>ViennaJS, Javascript Engine Essentials for Developers, January 2018 | Coder Coacher - Coaching Coders</title><meta content="ViennaJS, Javascript Engine Essentials for Developers, January 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>ViennaJS, Javascript Engine Essentials for Developers, January 2018</b></h2><h5 class="post__date">2018-02-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SyIO2RzXs-Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hello I hope everybody can hear me my
name is Reina Hanukkah I'm in
independent software engineer and this
is already my second talk at this meetup
my first one was last June where I
talked about type safety in JavaScript
applications and this time I want to go
some levels simple namely to the engine
so the engine is actually the thing that
executes our JavaScript code and I don't
want to talk too much about the
internals although it might be it is
interesting and fascinating but this
talk is more from the perspective of a
application developer so somebody that
is using javascript to write
applications and there i think the
question is more how much do i as a
patient developer need to know in order
that the engine runs my code properly
and fine and i want to start with a
little code example so it's more or less
chrome the font size is large enough i
hope and as you can see i have here four
objects that represent characters from
Star Wars movie with the first and the
last name and I'm putting them into an
array which contains eight elements okay
just and I further have a function
called get name and I'm not particularly
interested in how this function behaves
and what I'm doing now is the time
calling this function 1 billion times so
that they get the decent number and I'm
for measuring the execution speed or
executed the time I'm using the the time
commands from the console object so I'm
running this script now and it tells me
that it executed in 1.3 seconds
which doesn't mean so far but if we
consider now that this script here is a
part of a larger application and the
objects are coming from a database for
example a schema less database then it
might be quite possible that somebody
adds a new property into one of these
objects so for example with this object
on we can add a property space a
spaceship and call it Falcone it's hard
to type with one hand so okay I'm
executing this code again and as I can
see we are now up to two seconds so this
is a actually a huge performance drop
about 50% and the question is why is
that the case one might argue that I
have added a third property to an object
that hold that two properties which is
50% more and it could be for some reason
the reason for this performance drop I
mean if I want to verify my theory then
it would be quite easy I only need to
add these special properties to all the
other objects and the performance would
drop even more so if I'm doing this now
and now execute the kill it again and
for some reason I am actually at the
performance where it was the first run
so this wasn't a reason in real life
the question is now do you really want
to investigate into this problem or do
we say okay if it runs to seconds not a
big problem
we we skip it and work on some other
tasks given that we do that the
application is still used further and
it's quite possible that other
properties are added so somebody could
start saying that Luke needs a job
property because he's a Jedi for Leia we
could add a gender property everything a
female and for obi-wan we could actually
add a retired property because it
doesn't do anything anymore let me say
it's true now if we run that code again
the performance even increases now we
are actually at 200% of our initial run
now the questions a starts again should
we deal with this or should we skip it
you to ignore it and let's say they are
users don't really complain so we decide
that we ignore this problem but what now
could happen is that somebody says well
actually a very important character is
missing here and we add Yoda and for
some reason we don't know the first name
of you although we only know the last
name so I'm saying okay
they also have to add a new object in my
array now I'm executing it now takes a
little buying time my laptop gets louder
so there is quite some work and for some
reason we are unfortunately up to nine
seconds so now I would say it's really
time that we investigate what went wrong
here and because we simply cannot ignore
this issue anymore
so I think it's time that we learn a
little bit more about actually the
engine itself and first of all the
question is what is an engine so as I
already said in the beginning the engine
is the part that executes your
JavaScript code true takes the source
code and execute it especially it
usually comes bundled with your
browser's and each profetas has their
own engine and so with google chrome we
have v8 Safari has a Java Script Akua
Microsoft browsers currently to have
chakra or chakra which is the open
source project and Mozilla has spider
monkey and you should not mistake and
the JavaScript engine is de-rating
right with the rendering engine this is
something completely different and
what's also very important you know I
mean usually Java Script is interpreted
and until the release of Google's Chrome
or v8 engine the engines only simple
interpreters so why saying that what has
changed with v8 well usually these days
all modern engines are equipped with
compiler and an interpreter so the
interpreter takes the source code during
the runtime it starts let starts to
execute it immediately and what is
special here is that it executes your
source code on the fly and with the
compiler we have the so-called
compilation phase weather
Bosco's is first in JavaScript it is
first compiled into machine code and
with a machine code that advantage of
the machine code is that you can execute
it directly so you don't need any
interpreter or the compiler anymore and
additionally the compiler can also make
some optimizations during the
compilation phase this is also very
important so the big advantage of the
compiler over the interpreter is that
the code execution is faster the
disadvantage is that it takes some time
because we have the compilation phase
and with interpreter it's the opposite
so the interpreter can really very fast
start up your application but the
execution itself is slower and the basic
idea with the modern engines is that we
want to combine both of the best of both
worlds so we want from the interpreter
the faster application startup but we
also want the fast execution that the
compiler can give us and how can this
work well considering in real real life
examples so let's say we have a web
application the browser is requesting or
JavaScript source code it doesn't matter
if the source code is minified or
whatever it simply is JavaScript and the
engine usually starts off with the
interpreter because we want that the
application starts immediately now
additionally the engine itself
now monitors what the interpreter
actually does and what code parts are
executed very often and the code parts
that I executed very often are also
called the hot path and usually this hot
part of the code parts became candidates
for the compilation so after after some
time with when the engine says ok I have
enough information we can now start with
the compilation it triggers the compiler
and since the compiler is only started
after some time and executes and exit
and compiles the
but the code parts that are used very
often you also cause the just-in-time
compilation what's important
interpreter still continues so while the
compilation is going on the interpreter
still runs so your application is still
executed but once the compiler is
finished the engine takes the machine
code and uses or executes the machine
code directly and skips for the compiled
code part the interpreter and as I'm
showing in this charge there are
multiple optimization steps and there is
one particular optimization pattern that
is very powerful and I think that we
should all know about and this
optimization step is called inline
caching and if I would have to describe
inline caching in one sentence then I
would say it's actually the trying to
create static types during the runtime
which is quite a tough task as you can
imagine and of course it's not very safe
and I also want to show how inline
caching is working by using our example
of the Star Wars character movies we had
before so if we are now looking at the
situation of an area it is when
interpreter is running we have all four
objects we have our functions our
function and these objects are equipped
with the property first and last name
and they are passed as arguments to this
function so what the interpreter now has
to do is since JavaScript is not static
typed you can pass actually each kind of
type object you want and the interpreter
Noah is the hard task to search for this
property and and if we think that in
JavaScript we have this prototype chain
and the proper
it can be somewhere we also have getter
methods we have praxis and other things
so this property lookup is really quite
an expensive task and therefore no
wonder that this that the execution is
very slow now with the release of create
something new was introduced namely the
concept of a hidden class and what the
engine or thus it tries to assign a
so-called hidden class to each object
and the criteria if objects share the
same hidden class is that they must have
the same properties but the properties
must also be in the same order and since
this is the case so all of our objects
have property first name last name first
image in the first place last name is in
the second place they all share this
hidden class the same in the class and
additionally on the function called
position side the engine now is
recording the parameters that are passed
to this function and records actually
the hidden classes that are executed
that are passed still as we are in the
interpretation phase the code is slow so
if the engine now decides that it is
time to compile this function get named
because it is called very often in our
case 1 billion times it passes the
function as well as the profiling
information it has onto the compiler
usually or in v8 it does not pass the
actual JavaScript source code but the
some bytecode it already got from the
interpreter still the compiler now has
first of all the function it has to
compile and it also has the information
how this function is used and what does
know it says ok I see that you are only
passing me this hidden class p1 so in
that case I actually don't need to
search
anymore for the property because I know
it's just there and I only returned it
because the engine or the compiler knows
already where the properties are in
these classes so the situation now looks
like following we have an optimized
function that also works works with the
hidden class and it doesn't need to look
up to look to look up the property
anymore this is how inline caching works
and this one's called monomorphic in
like ash because the function is called
with a single hidden class only so there
might be a situation and that's what we
experienced before that there are other
that there are more hidden classes so in
our case I have edited this property
spaceship to the object on now our
engine and said ok this is a new
property so it cannot be p1 anymore and
it has to create a new hidden class in
this case I call it v2 and and compiled
code or the optimized code now has to it
has to make some additional steps it
first has to check if the past object is
of type t1 then it returns the property
or it knows from view on already if it
is from p2 and this results in a slight
performance drop as we have seen in the
beginning about 50% in our example
saying this again and there is this
monomorphic type where only a single
headman classes passed I have here some
kind of duration we have two polymorphic
inline caching type and there it only
applies if the class amount is two or
four and execution time here is a little
bit slower but starting from fifth class
so if your function is getting more than
four hidden classes passed then the
England Nealon caches which is over to
the so-called mega morphic in
and and what what's done here is that it
actually really remembers the first four
hidden classes that are passed but for
all the other ones it has to look up the
properties in a more global map so it
still does not need to search for the
property every time there is a map that
this is all stored but still this lock
up my thought is quite expensive and as
we have seen this is where we went up
from 2.4 seconds to 80 so as we now know
what the problem is how can we solve it
just to verify again we have here are
five objects and then find as I've said
before starting with five objects you
are in a mega morph aching language
which is a drastic performance hit and
what I have to do now is that I am
actually or I have to drop the this
schema-less feature that I have from the
database what I have to do mean is that
there are many options but this is the
option I would prefer is that we create
a class person and we add in the
constructor of this class all properties
that are actually possible this right
now
spaceship so as I said I'm not adding
all Possible's possible properties with
this constructor and I'm assigning them
so I'm saying this first name this first
name and so on and since I think we are
already out of time I'm just calling the
existing solution so this is as it looks
if I would have more time to write it so
we have here or a constructor and we are
calling here or we instantiate in here
these classes and as you can see it does
not really matter if we are calling if
we are setting at the property to now
what's important is that the properties
exist and that they are in the same
order and if I'm executing this
counterpart then we see that we are
again at this speed phone of 112 three
seconds it's clear so far
and we come the final last slide as only
final twice as I have shown now is if
you can use classes instead of object
literals if you can't there are other
ways you can use object design but with
object design you have to be a little
bit careful since object design internal
it's the property sequentially so it can
be the case that that you have the same
properties but they are not in the same
order then you see another problem
furthermore user transpiler that allows
you to program the transpires javascript
but allows you to develop with static
types typescript might be a good option
for that and last but not least if you
interested in the engines it's quite
good to know what they are doing but
please
never try to outsmart the engine or
trick it in some ways it's always a bad
idea and by that they say think you own
targets</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>