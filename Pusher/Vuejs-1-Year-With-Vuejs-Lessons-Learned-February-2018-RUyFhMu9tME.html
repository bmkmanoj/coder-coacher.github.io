<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Vue.js, 1 Year With Vue.js - Lessons Learned, February 2018 | Coder Coacher - Coaching Coders</title><meta content="Vue.js, 1 Year With Vue.js - Lessons Learned, February 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Vue.js, 1 Year With Vue.js - Lessons Learned, February 2018</b></h2><h5 class="post__date">2018-04-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RUyFhMu9tME" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to this view chess
Meetup
I'm giving this kind of talk roughly
every two years
I gave one about angular about react two
years ago and now it's view because I'm
always like you maybe also of doing just
kind of jumping the framework bandwagon
in the JavaScript world and it's always
an easy talk to give in the beginning
when you just found out how you find
your way with the with the new toy you
got then it's just kind of a top which
just will showcase some of the things I
found some of them are maybe just simple
you might already know them but it's
just thing about talking about some
small things I learned during doing
about roughly for Lucia's projects in
the last year i'm manfred i'm full stack
developer I'm a freelancer since about I
don't know eight or nine years I was
running some startup companies you would
call it now from 95 to 2010 I made film
dot 80 and events that 18 the ancient
years but now I'm just running a helper
which you might see on my male domain
the vector ha and being a software
developer as a freelancer because I like
doing things and not managing people so
much okay I also might stutter hip it
because that's what I do so AFM cuts
just maybe sometimes stack or maybe just
choosing weird language well that's on
purpose
that's nothing to fear about just don't
be afraid okay yeah and then just dive
into this thing and it's just a lot of
many small little thing maybe just start
with something which is a just a kind of
more boring or straightforward thing
which you also might know and sometimes
do in your business corporate world you
have forms stuff you have things like
this where you just fill out forms and
what you always have to do
things like form validation which is
just a kind of a boring standard thing
to do but well someone has to do it so
it's kind of the thing what you always
encounter in your project and what I had
in here's when you googled maybe one
year HECO you found quite quite easily
one package it was revalidate it was
similar to other kind of packages I have
always also seen in other frameworks and
stuff it's always like you have you have
to mark up your HTML code and you just
define the kind of validations you need
and the rules you just mix them in the
HTML which is nice for simple
validations but when things get more
complex and you just need to do
conditional validations or just have
things which are a bit more complex then
it just ends up being a bit messy so I
tried that in one or two of my projects
last year but I wasn't just really
satified and with the later ones I
encountered a thing which you also might
know maybe has someone worked with it
yet Bewdley date okay one guy at least
it's really nice because the concept
here is you just set up the whole
validation set up and two rules in your
model space so you can just have in your
model you have simple built-in
validations and you can quite easily by
making and using your own functions make
a bit more complex validations and you
then I can then wire them up with your
markup that's a bit more complicated
than like it would be with the other set
up but the thing here is you have total
control here about what you're doing and
when validation is jumping in and what
not so you are on each input element you
can call the touch function the touch
method which
means you just tell the validation
system when you want it to revalidate
the content so this is just a simple a
simple input field up here down there
you would have something which is some
component which just makes an ajax call
to load data and here you will just have
to touch method called on the on change
event and what you get then what you
just what we scott just called all what
is you get in your component state you
get a three which just mirrors your
model the thing which you wanted to
validate and you get kind of life values
which tell you if the field valid is it
not valid which kind of of tested rules
have been have been met which have which
ones has been broken and you can tailor
it to your own needs
what's also fine is that you can then
also maybe maybe if we go up back here
what we would see here is sometimes you
have rules like if we have a form where
you cannot change some parts of the form
because it's filled in already by
someone else well then you just don't
send out these validation rules you just
remove them from the list of validations
and well then they are just not used and
this is just total in your own control
and you can always see which rules are
active and which are not when you look
into your state tree so it's kind of a
thing which is just really easy to
reason about and to see when validation
kicks in and when you use it so if you
have the chance to just use it in some
project that's the thing I was just
really happy with because that's just I
find a quite good approach of solving
the thing and then what I also found is
a kind of add-on package that's
just a helper which helps you that you
don't have to build all this heady HTML
code which displays the messages for
your validations you can just set up
maybe for your favorite CSS framework
for boom bootstrap whatever you can you
can just set your your your own template
and just say where the error messages go
just here one has its own style of how
to display the error messages and also
this is a way here how to be how to
easily override the built-in error
messages because this is also something
which you quite often need quite quite
fast that you just need your own
messages even if it's in the same
language but sometimes you just want to
change only some of them but not
override the whole part okay that's it
for my findings on form validation then
the same with with view xvx in itself
kind of a nice thing to have one thing
was just that's also maybe just a kind
of a straightforward thing to do but I
think this is what helped me a lot with
using all these valley validation things
for single form components it's like
don't bind the forms directly to the
Buick state just always check out when
you load the component first check out
the local copy of the Buick state you
are you are working on and be sure to
make this as a cloned version so that
means if you just make a reference to it
you might still change and still have
references to the to the View xtour
values which might lead to strange
things
what helps here also is to always run
the Buick store in that in
in your death mode just run it in the
strict mode because you will get warning
stand if you have kind of kind of
unwanted mutations in your state so what
i'm doing here maybe i'm going back is
when I'm loading my form component and
fetching the part of the state tree
which I'm well which I'm working on and
then I'm just making a copy of that and
this is what I'm then working with MF
form and also may be something which is
just straightforward but yeah it helped
me a lot and also which was really happy
with was I found my way that well you
fill out something and well you have
stuff but you don't in the old days you
would just use plain session values
where you would just store stuff on the
store on the server here it's kind of
very straightforward way you can just
use this plugin here and then it's it is
it is really easy thing to do that you
can just choose parts of your state tree
which should be stored in local storage
it just takes care of it you don't have
to do any of that it just leads to the
thing that not the whole state but parts
of the state which you wanted to be
persistent
they are just staying in local storage
and that was just something I just
dropped into my states and install set
up within a few minutes with a few lines
of code and it just worked well no
config needed only thing I changed later
was that sometimes it's it's nice that
you set your own cache key your own
local storage key because sometimes
you're messing things up when you're
when you're just maybe trying to have
several versions of your state on
on the same site that sometimes can be a
bit messed up but that was just really a
thing where I found well viewers just
makes this possible that things like
this get kind of just plugged in because
in the past days it was just a bit more
work yeah this is where we just have
been that was the strictmode thing just
don't keep it enabled in production
because that's a bit resource intense
and it can lead to performance issues on
your site one more thing I came along
was embedding SVG icons in the project
itself I also tried and managed to
handle several versions of doing it the
thing I ended up with was something
called view SVG icons it's a bit tedious
because you have to always you have to
give it a folder with your head with
your SVG files and you always have to
when you add new files to it you have to
pre - pre compiled JavaScript versions
of this has VG icons but it just passes
time and pre breaks them into kind of a
standard format and it also tries to
guess if you have several layers or
several shapes in your eye content that
you just can access them then easily
with your CSS so when you have a mouse
over hover effect you can then just
target only the inner outer part of the
head of the SVG and when you use it you
just import only the icons which you
need in your component and then in the
mark-up itself you just use the SVG icon
component
just render them in kind of in line
which is just something something
because as sometimes need a bit more
control about icons bit more than you
would normally have when you just do it
as a SVG image inclusion and in the
latest thing I just also found out that
the new version of font no that's a
thing I'm standing Willi with font
awesome there five version the new one
it has really a ton of icons it's really
ramped up with really a big list of
things and it's just easy to just find a
lot of stuff which you might use in your
own projects but what's nice is they
also have a kind of good integration
with you where you're just in a similar
way you just choose which icons you want
to have in your bundle you add it to a
kind of library and then you can use it
in any component in your your project
then just with the font or some icon
component it's a kind of a similar set
up but that's just when you don't want
to when you just want to utilize the big
amount of icons which just come
ready-made with font awesome so that's
this then just only a small thing I also
what you always just do is you shop for
component libraries and things which
just makes things easier for you when
you're just dealing with forms or date
pickers or whatever
first the old things I had to use
bootstrap styled components I first
started with a special branch of the of
the of the view strap plugin which was
kind of not really developed for you to
then nowadays you would have this new
thing called bootstrap view chest it
wasn't available when I looked at it but
in the end in my way in my own projects
I used
which is called you Riv it was kind of
kind of useful but it was still a bit
messy and a bit old I'm not so fond of
all these people
this puts their thing but it did his job
I also changed something they accepted
my pull request quite easily so I just
don't had to use my own compact version
too long but nowadays new things I'm
building with I'm just switching to a
CSS framework called Puma you also might
not have used it lately and they have a
nice component library here it's called
beautify and yeah it looks kind of
promising and I used it for some smaller
things and it was something which was
just was straightforward and kind of
easy to implement and also to adapt to
your own needs and okay then that was
the thing about all these little
findings and am/pm packages and things I
found then maybe I can just dive in and
just have a look at one of the bigger
sites
I built this viewed this year this was a
site I took over
someone else built it it was a flash
like Southside from such some kind of
media agency and they made something
which is really into kind of with a lot
of interactions here and you have kind
of stuff why you cast just can go
through go deeper into stuff and it was
something which they built with a jQuery
and a bunch of plugins and the full page
JavaScript together and in the end it
was just messed up and they couldn't get
it to work rest rather
responsively on all devices and so they
gave it to me then and I said well I
could do it but I could I would just
start over and just not do with all this
mess what you're having here because it
was really quite heavy loaded and it
just was really not easy to build and I
said well that could be something which
we could quite easily build this view
chairs and what the main thing here is
what we are having is we're having a
kind of a layout the engine inside this
is what you would see in here so it's
always kind of finding out how much
space all these contents here are using
first I was thinking about maybe taking
a physics engine which just computes
about how many spaces left and so but
that would also be a bit too slow and a
bit too much overhead in the end it was
just something inside which just
measured out how much space these text
components would need and it's just
three he arranges them in a way that it
works for that it just tries to utilize
the space best because that means the
main problem here was that you have this
circular thing which you cannot really
you cannot it has to stay a kind of in a
square like shape but only the content
around it has to just float and just
adapt to the different orientations so
that the whole thing also then works
kind of mobile and so and the whole
thing is still a full-page j/s thing
which is kind of which makes the whole
thing a huge page a huge one-page
application which sometimes would really
take a long time to load and in the end
what it ended up is just making good use
of the computed properties of view so
only when you change
something when you change sizes and
stuff some heavy computations have to
done have to be done only once and then
just the view computed style it just
Kasia stuff which which is which just
made it quite easy and what we also had
here is that what you want here is you
want this whole content to be available
to search engines as well the normal
thing would be that well I'm doing a
single page application and the whole
content would come with HX calls but
then I have to make a second version
what just make a kind of a way that the
search engines are able to just grasp
the content and what I did here is that
if you look at the source code of this
thing then you will find out that the
base content what you are having is just
simple HTML it's just something which
which which which which can be passed by
search engines but what you are having
here is that I'm picking up then this
this components of the page and I'm
converting them to view components in
other frameworks I was used that I can
just markup component styles and they
just get to life as soon as you load
your framework for instance it was
possible with angular 1 but here I have
found out that if you have nested
components and then the whole thing
would be running in the context of the
of the topmost component which just made
it not really feasible but I I found a
way to work around this whole thing by
just going in in TTL but by just using
the way that view also allows you to use
a render function so that you don't have
to use the normal template
approach in view so for instance here I
would have a render function which just
checks which class you are having in
your HTML markup and it tends loading
the specific nested component and it's
just passing in the HTML Dom elements of
the child component then and the whole
thing that worked so it just made quite
easy way how to to just make a basic
version which has all the contents and
the content is just passed in to the
components not via JSON it's just passed
in just we have normal HTML elements
which just makes it available for search
engines and also available for the
components then if you nest several
components which is with each other then
the whole HTML stuff it just doesn't
either it just it just just didn't work
this way it just it just it just it just
didn't resolve component by component it
just passed the whole thing in the
topmost component and then it said well
I don't know about this nested stuff
that's not yeah and and and this is what
I'm doing now when I'm doing it manually
now with this render function then I'm
just really making a new component and
just passing that in maybe a later
version of you will have that somehow
built in but I found it good that I had
at least the chance to take over this
process and just tweak it this is a bit
messy but it's only for the topmost
container components which don't do that
much and the lower ones they are then
just normal components like like
you would be used to this is just normal
stuff which you would have with
templates and stuff which you which I
know but the upper ones they had to be
done with these render functions also
there was something normally you would
just use a router here because what I'm
doing here is you can just still change
stuff in the URL or you can reload the
page and you're still staying at the
same space and and the whole application
is then going to this to the just to the
state where you have left where you want
to go when you open this link and but in
this case I just couldn't do it with a
normal root router approach because it
just is not pasting content it's kind of
a more complex application what I was
doing here is that I was just still
using the view router and setting up all
these standard routes but then there's
the thing where with view X or out the
sink you can sync the router just also
to review ik state and then I had
everything in the state and I can then
just watch the state and depending on
the state I can just open the view in
the way like you wanted to have so the
thing is that I'm just somehow lost but
the thing was I have the whole thing
here it's this that's kind of a stripped
down version of this full page parallax
scrolling thing which is used on all
other websites maybe two years ago or
nights not so common anymore
but this is now hooked up with this or
router variables so when you change
stuff and the thing has to has to move
into some some some weird things but now
it just works kind of stable so wherever
deep you are in the hindustan in the
side the whole thing is just loading and
just
going to the space where it's going to
but what we are seeing here is you
really have a lot of content and also
all this content here you can just also
go deeper you have a blog like feature
and you have just a lot of stuff and a
lot of components which normally you
would have to load in the beginning
because it's a single page application
and if you just do it with the normal
view set up and not using this router
thing you just end up having to load a
really huge bundle in the beginning
which just would be a bit to load for
basic page load and also if people just
want to go to the page and just rent the
car and don't look at all these project
things which is maybe just a bit too
much for them then just doesn't make
sense that they load all this engine
this block thing and this special stuff
so I was looking for a way to lazy load
content in view and do two web pack 2
this was really something which was kind
of straightforward
it was just not so hard to set up it was
just you had to set up in web pack the
way how their how the naming mmm the
naming convention should work for your
for your on demand lazy loaded bundles
and then there's one way which you can
google and find quite easily how to do
it and how to use it with view router in
this case I just sometimes needed
content to be loaded whenever you were
going here and just opening maybe some
kind of pop-up or so and here it hits
like you're going in here and then
you're just going and loading all the
content which just is loading then all
these blogging and social posts features
and this is just here done in a way that
you just use this syntax when you just
write not require when you
you just use the import statement then
webpack will just take everything what's
underneath this component and also all
components which are required by this
component and just put it in a separate
bundle a separate file which is really a
good thing because I could just strip
down the size of the initial peddler if
page load by I know 60% or something and
what I also wanted to do is I just
wanted to see how much space am I
wasting with libraries how much stuff
how much crafts is going in here and
there's a nice plugin which is called
that pack bundle analyzer I don't know
maybe some of you know just software
like like this for your own hard disk
which shows you which amounts of disk
space I wasted in which parts of your
hard disk this thing works quite similar
so when you would run it it would work
like this maybe we can just run it here
but we are we have to go to the other
page that's the Shamy engine run it here
and when you have it in your website
config then what it does it just builds
like it would normally do and after the
build process is done it just starts
local web server and it allows you then
to see how much space goes into which
part of your and and into into which
file so what what you would see here is
that's just the basic app bundle then
what you can do with repick easily is
also split out some stuff into a vendor
bundle and then what you would see here
is all these lazy loaded stuff which is
which is which is just put out into
several into separate files what you
would also see here is your still in
every lazy loading thing because these
are all forms they're all but himself
just loading this
a validation library so I could just
move this maybe in the main one but well
it doesn't make sense because the forms
they are really needed sell them so if
someone loads it loads one then yeah
well they will just load one one format
if the lot more well they can just keep
this code in separate bundle files as a
duplication which is no problem but it
was really nice because when you put
lodash in or just some other versions or
just if you have it just dump just any
NPM plug-in sometimes you end up here
wasting really huge amounts of space for
stuff why I just need only one or two
functions so it just makes sense to find
out where you're losing all your memory
so this was also something which with
which I found kind of really really
helpful in my case so then let's go back
to our thing here yeah this is how it
would look like yeah so that was just
what built in this year I built a second
thing which I'm just working on right
now which was also kind of nice to have
a kind of an undo feature which is just
something which was also really easy to
do with the Buick State thing that you
can just yeah just like you would have
also have seen it in redux or other
applications in the last year's it was
also just something which was easily
done with Buicks that you can just dump
in you are undo and redo functions and
you get that kind of straightaway for
free okay so that was the kind of the
second part a bit more messy part of
this just small overview and I think
when I'm going here to the next slide
then I'm on the same slide so maybe if
you want but not too tight we can maybe
step into smaller things which are just
maybe touched only
anything else yeah I was just completely
stopped beautiful</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>