<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How Stuff Works in C# - Meta Programming 101 -  Dot Net North - March 18 | Coder Coacher - Coaching Coders</title><meta content="How Stuff Works in C# - Meta Programming 101 -  Dot Net North - March 18 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How Stuff Works in C# - Meta Programming 101 -  Dot Net North - March 18</b></h2><h5 class="post__date">2018-03-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cnpFNUFRqjQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so metaprogramming C sharp so presume
everyone here seems its dotnet North C
sharp F sharp yep
excellent cool not going to explain any
of those things then we live in a world
where our tools and frameworks and
libraries are often built for us
especially internet we rely on ASP an
MVC
di containers unit testing tools IDs all
of the stuff the hums around our
ecosystem that we don't really think
about we just kind of benefit from these
tools are really really popular because
they solve what people see as the hard
problems you know got it's really hard
to write web frameworks it's hard to
write di tools so we have a couple of
them and all of a sudden we kind of
settle on one and we just get on with it
in this session what I want to do is
explain how all these big tools and
frameworks work and explain how they're
really not any different from user line
code are not any different from the
application code you write they're built
using the same languages the same
techniques as everything you're doing
your day to day job what we're going to
do is we're gonna break down how they
work MVC test frameworks containers
we're gonna illustrate how it's all
really just metaprogramming reflection
and hopefully leave you with some
practical tips of implementing some of
these things in your own code bases to
make your code a little bit easier to
use so that's me
I don't have very much to say about me
I'm a reprobate I've worked with some
very very large companies and I'm riding
on the coattails and my former glories
like everybody else really I used to be
the chief technical architect of the
company just giving the charity
fundraising platform did some work would
just eat a lot of stuff and publishing
but the thing all those jobs had in
common is they were all big web scale
net things especially at a time when
people were very very happy to say all
the time that doesn't scale although
it's not fast enough absolutely is
absolutely did that's my favorite photo
of myself I think that was naught one
five one ROM drunk in about ten seconds
after snorkeling in the Caribbean that
was my face of disbelief I've used it
ever since in a professional capacity
because I'm that much of a professional
so let's talk about metaprogramming
anyone know this is there we go not only
a great death metal song but uh an
ancient symbol depicting a serpent or a
dragon eating its own tail it originates
from the Greek language
order meaning tail and Boros meaning
eating thus he who eats the tail
it symbolizes self reflexivity
introspection or security especially in
the sense of something constantly
recreating itself for the eternal return
and encode that's basically reflection
so um let's see what wikipedia says
metaprogramming is before we actually
talk about it so meta programming is the
writing of computer programs with the
ability to treat programs as their data
it means that a program could be
designed to regenerate analyzer
transform other programs or even modify
itself while running in some cases this
allows programmers to minimize the
number of lines of code to express a
solution hence reducing the development
time or it gives programs greater
flexibility to efficiently handle the
situations without recompilation the
language in the meta program is written
it's called the meta language and the
language of the programs that are
manipulated accord the object language
the ability of a programming language to
be its own meta language is called
reflection I don't know who writes this
 honestly like really I mean they're
right it's an accurate description of
meta programming mouthful so in
plain English
reflection is all about writing code
that looks at the metadata of your
program at runtime the metadata in
c-sharp is generally the list of
available types interfaces your
application domain the names and details
of your methods the properties on your
types and in c-sharp to do this we use
the reflection API it's a meta program
so that's all the methods that hang off
the namespace system reflection hands up
if you'd use that namespace before like
quite common something you always
stumble into so how about if you've
knowingly use reflection rather than
just seen it but so mad people that's
good
how about people have done a lot of meta
programming in an any other language
JavaScript maybe okay interesting so
let's look at a really really quick
example of
metaprogramming be prepared really
really hard stuff super difficult super
difficult
I say example because I mean here's a
screenshot that I made earlier a year
ago because sometimes there aren't
enough willing bodies to sacrifice and
I'm not going to demo any of this stuff
live I'm not that stupid
so it's just about the simplest example
of meta programming in c-sharp that I
can possibly imagine the fun thing about
it is you've literally seen this all the
time there is nothing interesting or
clever or exciting about this whenever
you use the get type method exposed on
every single objects in c-sharp you're
using meta programming to ask the dotnet
runtime for the type definition of the
object you're calling get type from so
I'm going to say the word type about
three hundred times in this talk I'm
really really sorry
so from this type information you can
start to navigate the current
application domain you can retrieve
information about everything loaded
inside of it these two examples here
illustrate how it using any type at all
you can grab a list of all the other
types in the current assembly and how
from a single type parameter you can
list all the available methods you have
on that type so there's really nothing
difficult interesting or scary about
this the 101 really is that simple and
the funny thing about meta programming
is an especially reflection and c-sharp
it has a really really interesting
reputation for being a mixture of slow
hmm kind of true maybe in dotnet one one
days and difficult and dangerous and it
really isn't none of those things so
let's talk about why that is meta
programming so the type type in c-sharp
is a way of inspecting the type metadata
of an application while it's running so
if you're using the type type you're
metaprogramming supported by the type
system of the CLR it's meta program
because you're writing code inside your
program that inspects its own state at
runtime and like we mentioned before
that's called reflection and if you're
wondering how the type is related to the
reflection API you only actually need to
look at the inheritance hierarchy of the
type type system type in herre
from system reflection member info so
every time you use type anywhere in your
code you are unknown to you doing some
kind of meta programming because you're
doing inspection of your own code at
runtime it's part of the reflection API
so the type type is useful you've seen
it before even if you didn't realize and
the reason we're starting with this type
is because it's one of the more common
parts of the runtime that touches meta
programming and pretty much everyone
that's ever used generics or type
constraints has probably seen it and you
know maybe if I've said hey if you use
generics in like 2007 people might have
looked at their toes a little bit or
2005 in 2018 everybody understands
generics is working dotnet like this is
not scary stuff so type in c-sharp
offers an API for type inspection and by
using it and the methods it makes
available you can do things like list
all the properties on a type list all
the methods on a type list get a list of
all the available constructors on a type
along with their parameters getting set
values on a type check if a type is
abstract getting set members that are
hidden from you do to access modifiers
and most importantly you can create an
instance of that type so how many of you
come across activator before ok cool
we're going to go through an example of
that about ten times a bit interestingly
does anyone know of any way in c-sharp
to create an instance of a type without
calling its constructor gone curious yes
that not the answer I was going for
amazingly but yes you can you can do
that so interestingly there's another
supported API where you can make
instances of types buried in the dotnet
one one XML serialization code there's a
method I could forget what it's called
it's something like create an
initialized member and you can create
instances that completely allocate the
memory for a type and skip everything in
it super super dangerous never touch it
never use it except that one time when
it's really useful you desperately want
to super weird so type is one part of a
rich metamodel thank you
keep idea yeah yeah yeah cool thanks
computer scientists something like that
so of course it is of course it's part
of a rich metamodel the concept of a
mecha model has a lot of scientific
language around it but in this case what
meta model means is nothing more than
obviously the model of your model so in
the case of c-sharp the meta model is a
series of types that describes the types
and data structures of the application
currently in memory so you can spot the
C sharp meta model at a distance because
all of the type names of the metamodel
look the same pretty much member info
property info method info type info
parameter info of an info field in folk
instructor info method body because why
on earth would we want consistency
method base of course and local variable
info so there all the c-sharp meta model
and using the reflection api you end up
dealing with those types and then
writing code to react to the values in
the instances of them return to you when
you inspect other things in your code so
generally use the reflection API
starting at the current type or the
application domain or somewhere in your
code and you navigate around all these
properties and of the metamodel so god
but we've seen how the type class is
part of the C sharp reflection meta
model but let's look at a real simple
practical example of doing something
useful using meta programming so this is
about the most right example I can
possibly concoct so we're using the C
sharp reflection API is here to get all
the Assemblies in the current
application domain on the first line and
then we grab the type of each one of
them before printing the name of the
type to the screen I mean it's kind of
useless but it is something real there's
nothing remarkable whatsoever about this
code sample but that's a practical piece
of metal programming and we'll come back
to this example later and I'll show you
how you can actually do something where
you're going to use swore with something
that's simple so let's pretend I'm
actually running Visual Studio and if I
ran it you get something like this you
get a lot of stuff that you didn't even
realize was in your app domain that the
CLR hoists into every application when
it starts up but yeah it worked yes it
did
so obviously if this wasn't a slide deck
I bill to scroll through here and you'd
eventually me ought to find some useful
application types but otherwise that's
basically what application domain looks
like I must have done these slides when
they were trying to vote in Trump irony
so here's the interesting thing
Mehta program is the glue that holds
everything that you use together all the
libraries and frameworks that you use
and literally stuck together with meta
programming some of its built into the
runtimes like asp.net so how do you
think web stuff works there's some DLL
somewhere on a disk and there's a web
server and all that stuff has to be
glued together with code somewhere a lot
of it is the glue in these frameworks
that you use every day n unit x unit and
hibernate entity framework Nancy mock
all of these things make use of the
reflection ap eyes and as a result all
baked around metaprogramming so not only
is it useful to understand how those
tools work but how you can apply those
same practices inside of your own code
so let's take a look into some examples
of how actual things work so we can
understand the value of meta programming
in our code bases okay test frameworks
should we write our own test framework
why not like another hard
surely so does anyone have a written a
test framework before foolish man no of
course that anyone ever written a test
Runner may be more common huh
interesting so test frameworks are the
archetypical example of libraries that
are literally just meta programming
there's basically nothing else to a test
framework so if I said hey let's go away
and write a test run a friend unit tests
right now do we think we could do it
yeah I think we probably can so what the
test frameworks actually do so
right they they look for stuff they scan
for code so an unit x unit attribute
based stuff so the symmetric weights
they try and find them then they run
your code and then they see if it failed
or not
so without digging into the example it
just sounds like scanning some
assemblies calling some methods and
wrapping them in a giant try-catch and
that's actually not too dissimilar from
what tempering works really do in the
real world so this is one of my favorite
examples because I run it as a code dojo
and I often run it with grads because
they're the most scared of this and they
say hey we're gonna write test framework
in an hour and 20 minutes and they look
at me like I've just like kicked their
dog and I'm about to burgle their
mother's house but it's not that hard so
let's let's take a look at tests best
tests ever so what I've done here is I
borrowed the end unit syntax that's not
an end unit test
I just made an attribute called test
fixture an attribute called test there's
nothing any unit about it other than its
convention test frameworks provide you
with a trivial pattern to instrument
your code
so we've has anyone not written a unit
test before thank 2018 it's good
it's like a question for once every talk
and every year it got better and better
and better and so everyone finally
worked it out so you mark up your tests
using attributes like test and test
fixture and then a test run execute them
and captures the results all the
mainstream net frameworks are slightly
different in their form but almost
identical in their function they all
detect tests in n units example looking
for test fixture and test methods
contain inside of them they execute them
they report success or failure they're
nothing more than programs the fine code
and our methods awesome there is
actually a subtle difference actually
between X unit and an onion anyone know
what it is it's the unit of isolation so
in an end unit one instance of your
class gets created for every test that
runs inside of it which is why things
like setup methods and parallelization
of tests
screw up local variables actually kind
of bad xunit single instance of the
class per every test run it's the only
difference so any unit basically gives
you the shotgun you can point at your
legs irony the people that wrote x unit
were also the people who wrote any unit
and somehow they managed to it up
so badly that they wanted to do over in
their test framework so they completely
started again just really for that one
bug fix at first kind of funny so
there's a there's a test runner why not
so test frameworks have four core
concerns code discovery code execution
assertion and rules gathering and
reporting so let's just express these
concepts and c-sharp so there's
absolutely nothing behind any of these
methods at all
I just made some classes and gave them
some names it's just a sketch we've not
implemented anything so let's say we
have a class that finds things a class
that executes things and catches
exceptions and something that reports
results this main method is the backbone
of our test run our executable that's
just a console app cool so let's do some
discovery using metaprogramming so look
at how we use meta program take care of
the four core concerns of a test runner
we're gonna even make it run n unit
tests as well not just my fake test
framework will make it run the real
thing why not our finder is incredibly
simplistic it just reads the name of a
dll passed over the command line as the
first argument loads it into memory upon
construction and then once we have the
random dll full of junk in our app
domain we use some reflection ap eyes to
find some tests so in the real world all
the test winners do some crazy remoting
thing where they generate app domains
that they put the tests in but honestly
it's just a test runner who cares get
you there so all this really is single
line from an assembly getting the
assembly name from the command line
loading it into memory and we going to
test dll stored in a member field so
let's take a look at our fine tests oh
my god holy link Batman
that's fine it's actually not that bad
let's take a look at the three
statements we have here because there's
really only three things we're doing
first finding all the possible test
fixtures so from the dll we're going to
get all the types where any of the
custom attributes name starts with test
fixture ohoho there's any unit
compatibility and one magic string then
we're going to get all the methods by
taking all those test fixtures we've
detected and getting all the public
instance methods from those types and
then we're just going to return a list
of anything in there where the type name
starts with test cuz hey who cares why
not so so well first we're filtering on
fixture test fixture attributes then
were selecting public methods and then
we're returning anything with a test
attribute off the top of it really
really not very difficult and not very
slow and not likely to be buggy unless
any unit goes and renames their
attributes or something stupid like I
don't know fact theory something like
that okay so let's take a look at our
test executors so we're going to execute
some code using reflections so we've got
a class that can load a deer well with a
class that can take that dll on select
methods we're going to run so this this
is activator a couple of people in here
like half the room said they'd they'd
seen activator before so it's one of the
more tedious and obtuse classes in the
framework because it like it doesn't
take generic parameters and it kind of
looks like a piece of crap and it takes
a load of objects as a prac the API is
horrible but that's the joy of using
statically typed languages to do
something kind of dynamic but you know
it's activator whenever you see activate
you know it's a pain in the ass you just
get get on with your life and use it it
lets you make classes it'll pass on
constructor parameters and return you an
instance of the type that's all it does
so all we're doing here is passing the
type from the method info that we've
selected from our test so the method
info just describes those methods we
found with tests at
written on the top and we're saying make
me one
thank you say hello and make me one call
the default constructor make me one so
actually this is the X unit pattern here
we're deviating from X unit because to
run us test safely we're just creating a
fresh instance of our type every time
and all we're doing is we're calling
invoke on the new instance that we just
created so that method info is basically
a descriptor some metadata pointing to a
method in a type definition that is not
an instance of the type activator gives
us an instance of the type and then
using that method info we say hey this
this effectively pointer you've got here
on that type please execute this method
and then all we're doing is we're
calling our test result pass test method
if that line of code gets by we don't
really care about anything else
we're just saying I got I managed to
invoke the test I didn't crash let's
presume success if an exception is
thrown we return fail so let's let's
take a wild guess here maybe this
metaprogramming thing actually isn't as
complicated as you've heard there's
nothing sophisticated here we just
strung together a couple of methods and
let's take a quick look at the other
test result the test reporter class even
because I think you might find it really
really interesting this there's
something really significant we have to
do here yeah that's basically end units
console render does we're done right
okay
this class just takes a look at our
result and if there's an exception write
an X to the console like that's
literally good enough to plug into a
team city server and how to build
failure condition on the occurrence of
the letter X it would actually just work
so if we jump all the way back to here
we now we flushed out finder we flushed
out our executor we flushed out our
reporter so obviously fully featured
test frameworks have loads of other
concerns but its core this is literally
how they all work you notice we've not
really discussed assertions at all
and for the sake of brevity I'm just
going to say assertions are basically
out of scope of most of your test
frameworks they're not really important
you could write a bunch of if statements
and throw errors if you liked there are
tons of assertion libraries out there
most test frameworks come with whatever
the favorite syntactic pattern of the
author of that test framework happened
to put it at the time sometimes a bit
fluent sometimes its new the classic end
unit assert that and they tend to change
over time but the way you run your tests
are the same regardless so we're going
to consider writing an assertion and
ivory completely our scope here that's
it works so the difference between this
and any other real test framework is
that there's really nothing to them
other than framework detection and it's
funny I've just kind of said a test
framework is about a hundred lines of
code and then you go and you check out
the end unit source code and it's got
like 15 projects in there has anyone
ever looked at the unit source code it's
a marvel it's like a historical
archaeology trip through the history of
dotnet because you can see it supporting
all the different versions of the
framework you can see that the windows
like window see builds abbott s runner
that used to run an old-school windows
mobile phones there's like uwp versions
of the end unit runner that can run in
like sandbox taps and things like that
actually quite sophisticated but it's
cool all of that stuff all that dynamic
loading is wrapped around a very very
very simple and very very small thing
there's not really any magic they just
use reflection to detect cases create
classes execute them and check for
exceptions so there's a little bit more
complexity in a lot of in some test
frameworks so you've got some state so
you got setup and teardown but if you
actually think about what we just saw
executing a setup and teardown function
is nothing more than searching for a
function called setup and teardown and
calling it before and after each test
it's not any more complex than what
we've just shown thus the you know the
the actual language and the runtime
takes have all the heavy lifting it's
not like the test framework has to track
state or anything like that
so let's think about MVC frameworks they
don't get the visual pun what happens to
all MVC frameworks you end up with fat
controllers mmm
groan groan dad jokes for days and don't
have kids so mmm it's invoke Wikipedia
again because I love it
model-view-controller is my theater
voice not MVC is a software
architectural pattern mostly but not
exclusively implemented and user
interfaces on computers it divides a
given software application to three
interconnected parts so as to separate
internal representations of information
from the ways that information is
presented to or accepted from the user
good good pros traditionally use for
desktop graphical user interfaces the
architecture has become extremely
popular in designing web applications
said nobody ever I presume there's
anyone not as anyone not using MVC
framework before cool thank God
NBC is kind of ruined web architecture
there's a pub argument for you later
models using controllers so there's
nothing particularly special about MVC
at all it's really just a pattern for
organizing your code with a couple of
defined responsibilities anything that's
just a pattern it's perfect for meta
programming because really what meta
programming is is all about writing code
that detects patterns so we're gonna
look at asp.net MVC is a specific
example
so MVC simplified so how was MVC
writtens anyone remember the the myth
around it so MVC that as the story goes
it was a conversation between a couple
of the Scott's and Scott Guthrie cracked
out the first version of it on a plane
to mix in Vegas one year in like a
three-hour flight and I actually kind of
believed him it's not actually true it's
a gross oversimplification of how it was
written
but the first cut for a demo happened at
mix once as the legends ago so NBC is a
library that calls user code much like
test frameworks so what does it do it
binds HTTP to code it takes an incoming
HTTP request and inspects the requesting
URL based on that URL it finds a
controller that matches a route so your
two pieces are controlling a route and
it selects the most appropriate method
on that controller to execute and it
does so kind of like finding a test from
an assembly and finding a test method
and running it very very similar it
grabs the output of that method the
model and passes it into a view engine
the view engine takes the model and
returns something normally HTML unless
there's some kind of content negotiation
plugged in at the end of it and then it
can be formatted in different ways so
there's plenty of nuance in there that
we've left out of you know the real MVC
framework itself is much more
sophisticated especially in version near
300 or whatever in now but in the first
version of MVC it was nothing more than
this at all because it was written on a
plane so MVC was built on top of asp.net
originally and it's life it started out
as looking more than HTTP handler that
process requests so is anyone ever
implemented a HTTP handler before okay
actually quite quite a small number
you're lucky because it's kind of
tedious down here in the weeds in
asp.net certainly in the full-fat
framework Freenet core so HTTP handlers
and HTTP modules before them are the
lowest level of hooks that you can use
to build to host a website and I in is
so this is a basic handler which does
nothing more than write hello to the
response stream every time a request
hits that handler and we're going to
look at how we can take this and turn it
into an implementation of a micro MVC
framework so the way HTTP handlers work
is you literally have one line of
configuration in an app the web.config
file point everything to this every
single request this and every time you
request
your hosted website you'll just get
hello written out completely completely
trite nothing interesting they're so
much like we did with the test framework
I want to sketch out metaprogramming
bound to HTTP so we could start out by
looking at the first thing which is that
when our handler is constructed it finds
all the Assemblies in the current app
domain and then gets all the types and
then finds anything where the name ends
were controller and you know that's a
really really ghetto ghetto
implementation of MVC's type scanning I
tell you why it works right you
controllers probably am with the name
controller and that'll find all of them
in any assembly you can all those nice
features of MVC where you can have areas
and things that separate off all the
controllers one line 0 text well so it's
a simplistic approach but it'll do for
now we're gonna catch all of those
controller types into a list called
controllers so we can easily refer to
them without using reflection when we
receive requests so like I said earlier
reflection is really not very slow but
it is an order of magnitude slower than
not using reflection so if we can avoid
doing a big deep assembly type scan on
every request we should and then we're
going to take a look at our process
requests method here so process request
does nothing more than pick a controller
passing in the HTTP context the same
context you have everywhere else pick
some method create an instance invokes
the instance and writes a response very
very very simple mbc pipeline so this is
all really eerily familiar we've got a
method based on a context picking
controllers let's take a look at how pic
controller should probably be
implemented yeah yeah
this is this is simplistic as well and
it's funny how small is every time I
kind of amuse myself every time I see
how trite this stuff really is NBC is a
good example of meta programming being
used to bake conventions into a
framework and actually one of the things
that excited a lot of people when NBC
hit was the fact that it all just kind
of worked you know web forms was such a
drag for so many years that just the
fact you could trap drop a single file
in and a single aspx page and do nothing
and everything just kind of work based
on the name shouldn't have been a
revelation but it was I mean I don't
know if any you guys ever done in rails
it's fine if you're so guilty about it
yet we we owe everything to Rails modern
web dev owes rails everything without
rails we wouldn't be where we are today
even though rails today is like rails 20
super Enterprise Edition with 20,000
security vulnerabilities and no scale
rails completely changed the way
everybody built things for the web you
know without rails that'd be nice being
at NBC there'd be no Nancy that we
probably know Owen
there'd be no drop wizard in Java
there'd be no Sinatra in Ruby
all these things were reactions to were
inspired by rails and the thing that
rails really did well was sensible
defaults for everything so as time has
gone on MVC itself has become more
configurable and the hard-coded defaults
have given way to more complex
configuration but we're gonna go as
simple as best for this so remember all
those controllers we detected when our
module first started up what we're going
to use them here we reuse the
wonderfully hacky trick of just saying
find me the first controller where the
name matches the start of the URL
because hey why not simple
obviously you want some more
sophisticated detection heuristics here
in the real world but it'll do for our
example so then with a null check we're
gonna grab any controller called home
controller if we find nothing
effectively implementing the default
route from MVC otherwise we're going to
return the one we found so I mean that's
so astronomically simple and really
that's that's the that's all
table really does so add in a regular
expression and a list and you have a
root table real simple so let's take a
look at picking the method we're doing
the same kind of things here we're going
to use a call to get methods with some
binding flags to find all of our
controller classes and the methods
inside them and then match against the
incoming path and query string much much
like how we had a default home
controller in the controller picker
we're gonna have a default index action
if no if no action method is found so we
check the URL we look at all the public
instance methods we get them all we find
the first one where it contains the
method name if there is one we return it
if not we defaulted to index that's it
that's simple and as a result jumping
back to our module again you'll see this
there's really really little to it we
pick a controller we pick a method we
just invoke it and return the result
we're going to create an instance and
then invoke it so there's the observant
of you might notice that there's a
missing bit here this is not a full MVC
implementation at all
we're missing a model binder which lives
at the top which would basically sit
here that map's things from the context
into some kind of class or shape that we
can pass as a parameter to our method
that's fine that's the same kind of
thing again we find all the properties
on a model that we specify and we find
anything that matches in the HTTP
request we make an instance and we set
all the values now I'm missing a view
engine that transcodes this response
into something else so the funny thing
is we could take this and we could use
say the razor view engine from actual
MVC and just pass the response to the
Rays of view engine but the name of a
view file and it would still work but
while we'll need those bits for a real
MVC framework ironically this is
actually enough to build a ghetto clone
of web api which doesn't really have
many of those concerns so you can easily
see how the model bind or to fit in so I
mentioned we had one of those and we had
a directory store
should that look like that a food
controller and a home controller cool
and then we have a web config that says
any single request on any single verb
just just pass it to me thanks that's
real code just works like it shouldn't
really be that simple but actually he
did it's good that it is unfortunately
we have time to dig deeply into the
missing parts of the MVC framework so
maybe I was being a bit disingenuous
when I said an MVC framework was like a
hundred lines of code but the model
binding is little more than mapping
query string parameters into DT O's and
through these two examples
it's just startling how similar building
a test Runner and building an MVC
framework crudely is so the backbone of
meta programming is using your meta
model to inspect your code and then
usually construct and invoke functions
inside of it so we've got one remaining
example which is a minimal ioc container
in a single class I've kind of got two
more things to talk about really one of
them is a final example and the next set
is a bunch of tips and tricks that you
can bring into your own code bases so is
you containers has anyone not used an
IOC container before okay cool so got
one overhead you know what is V
container is perfect I'm good I'm going
to do the Wikipedia joke again just to
get through but that's that's that's
cool so so what wikipedia says if we
invoke it is in software engineering
inversion of control as a design
principle in which custom written
portions of a computer program receive
the flow of control from a generic
framework a software architecture with
this design inverts control as compared
to traditional procedural programming in
traditional programming the custom code
that expresses the purpose of the code
Wow
calls into reusable libraries to take
care of generic tasks but with the win
inversion of control it's the framework
that calls into the custom it's the
custom or tasks pacifica this is garbage
garbage I'm going to go home I think and
edit these Wikipedia definitions it's
not suck so hard
so basically ioc containers you
to give you your components so you can
use them in your code often using some
magic things that happen auto wiring or
other framework level magic and they
give you instances of your code to
execute so the core of a super simple
container without any posh features so
when I say posh features I mean objects
scoping I mean lifecycle control clever
dependency rules is little more than
that a method to create any old type and
then some kind of method to register
type mappings so let's look at how we
can build this trivial sketch into a
working container so has anyone ever
built a container before or something
like it you've done all the horrible
things I feel so sorry for you me too
it's like my own existential crisis so
so we have a container has a dictionary
a create a non-generic create a select
type and a four interface so that's the
best drill down into a couple of these
so what we've got here is a dictionary
of simple mappings what do I mean by
that that's I mean it's not very good
data structure just says for this type
give me this type and then we have a
mythical four that we can call from our
user line code where you pass it an
interface type and an instance type and
it will just stuff it in the dictionary
very very simple so as I said the
container has no features so you can
only put one thing in there for any
given interface and it returns this so
you can chain your calls to four and
it's got a register method and sorry it
doesn't have a register method the
register method in your code would use
it in in this kind of way so a new upper
container and then it's say for I my
thing
register my thing brilliant so there's
nothing more to a container than that
we're going to pretend and then that's
kind of it really really creepily so let
me work through this slowly so we're
gonna use a few bits of the reflection
API we've not seen yet yeah so firstly
for the tie
that we are asking to create our tea at
the top we're gonna get all of its
constructors and then we're gonna be
sneaky and find the one with the biggest
constructor so we're just gonna start by
picking the first constructor and then
it's right through and if any of our
constructors has more parameters and it
will select that so that means that we
will always provide the biggest
dependency graph to our to our type on
the Creator we then we create a new list
of dependencies for each parameter in
the biggest constructor we call select
type with the parameter type we create
an instance of the dependency and we add
it to our list then we invoke the
constructor it's all we've done is we've
from a type picked a big constructor got
a list of all the things and kind of
called ourself again and again and again
and again so this obviously is a
recursive call but what we're really
doing is just repeatedly running that
code let's take a look at how we're
actually going to do select type because
this is what method binding looks like
in most containers so this container is
actually super magic its auto wiring so
when you ask for a type it just
works beautiful actually or from the
assembly that the requested type is in
we're just going to grab all the classes
that implement it as an interface really
really simple and if we find nothing
we're going to throw an exception
because there's no registrations if we
find one thing we're going to select it
as the types of create and if there's
more than one thing we look up what the
correct answer is in our little
dictionary of simple mappings that's the
backbone of the simplest possible
container you could possibly write it's
like 70 lines of code and actually works
I think that's kind of beautiful because
there's lots and lots of places where
you're building software and maybe maybe
taking a dependency on a big framework
or a big ioc container maybe they don't
target your platform yet if you're using
a new version of net standard and you've
got a favorite container it just doesn't
work or you're in a scary new world of
Raspberry Pi you've only got so much
space on the thing you don't want extra
DLL
flying around or you're in dependency
management hell writing something like
this isn't actually a bad thing it's not
like it's hard to understand it's
basically two methods and it just
actually works it's super super cool and
they've been lots lots of things I've
worked on in the past where people have
had lots and lots of really really
tedious switch statements encourage you
if you've ever anyone ever used the
command pattern for instance and then
had to manually register everything
piece by piece by face this commands of
this handler this commands of this
handler garbage code like all it does is
obfuscate the meaning of your
application and what your application
actually does something like this while
it takes more than two seconds to pass
with your mind actually you can delete
hundreds and hundreds of lines of code
serve as the backbone for your
application the interesting thing about
containers though and whenever I talk
about containers always have to point
this out how many of you here have that
one registration file would like twenty
thousand lines in it of stuff yeah I
feel so sorry for you guys please don't
do that please don't do that I think I
think there's a slide about this later
me complaining about this so I'm gonna
move forwards and if not I'm gonna come
back to this point so that the magic in
here though isn't the same stuff right
it's the same stuff we're using to build
test frameworks the same stuff we're
doing to do MVC so let's talk about some
non framework or real-world examples the
real world got really really bad visual
puns so we've spoken about how big
things work in the.net ecosystem but
what about the thin end of the wedge
where can you sensibly use
metaprogramming today so as a rule of
thumb meta programming should be used to
do the right thing by default that's the
I suppose the takeaway you've got to
help your developers fall into a pit of
success rather than pit of failure
that's kind of the greatest benefit of
meta programming so let's let's think
about conventions in code so how many of
you have a convention in your codebase
just any convention at all
what kind of conventions naming so all
controllers ending controller all
factories end in factory something like
that cool so
so one of the most important things
metaprogramming from do for a codebase
has help you implement strong
conventions to increase predictability
in your application so it it's all about
taking away your category of stuff from
your code you use conventions to
solidify and codify internal patterns in
your application so let's take a look at
this very very synthetic example anyone
send emails in their applications like
everybody right we've all got the same
 amount of like horrible string
templating code or maybe you're using
razor and you've got a lot of files on
the disk and it's all garbage like it's
really all garbage and tedious so and it
probably started off for something like
this it's like oh if email type is this
if email type is this maybe you made it
a switch statement because you're
feeling really fancy but in this
synthetic example I've got a nightly
email in a daily email I've got a daily
template and a nightly template and I've
got like summer gee template thing that
takes the type smushes them together and
returns them out cool so we've all been
here before but those two if statements
soon become xxx statements and then
marketing want you know 30 different
variations on those 30 now you have 90
if statements and this thing just grows
and grows grows so let's not think about
the moment when someone typos unlike the
300th time the word template to be like
template and then all your production
servers you have to have two directories
with email templates in there and that's
the that happens in all code bases
and takes you ages and ages to unpick or
random runtime bugs so we can use meta
programming here to stop any of that
junk happening in the first place we can
forcefully implement conventional
approaches to template loading that's
all that code can we reduce down to like
that so consider this we've got some
email strategies the available emails
are made available as a collection you
could even calculate that using
reflection discover if you wanted to
find me all types that are inherit from
email order or end in email the type
name of the email is always the name of
the template so those things can never
drift away strong convention
there's no room for error the templates
location is always the same location no
room for error and there's no room for
repetitive code no one can make that
thing now 20,000 lines long by just
adding another template we would by
enforcing conventions like this and
these patterns you can you can make your
code more understandable to the next
person down you know conventions of the
reasons that frameworks like MVC
actually gain popularity like that's the
whole reason NBC was was seen as nice oh
I've got three folders models views and
controls it just works
simple nobody had to think about that
the fact there was a load of magic
metaprogramming happening under the hood
was completely transparent to the user
of their of the API entire popular
libraries exist that just do this thing
this is basically what Auto mapper is
it's a thing that does left-to-right
matching on name and type every ORM ever
from sequel table name to data structure
name left-to-right auto wiring
components I knew I had a thing where i
wailed on IRC containers I just cannot
even and I know so many people have
contain a wire up because every company
I've ever joined they've always opened
some program somewhere and opened the
900 line thing of bind food to bar food
to bar to futa bar 3 and you get got to
scroll down and you and as soon as
someone gets a binding wrong everything
is broken and you don't know how and you
basically just revert and try again
it's horrible always register by
convention so if I have a container
instead of doing that
I could just kind of do that and that's
a lot more complicated it is a lot more
complicated to reach class in all of the
assemblies and all of the types where
the class is a class and it's not
abstract for each interface on that
class register every interface to that
class
oh god that's scary I don't want a head
compile that but that code can never
grow whereas the other thing will
definitely grow every time anyone makes
a change or introduces a type so it's
worth taking that tiny tiny little bit
of intellectual overhead to solve a
problem that's going to happen in there
in the future it's about 1% more complex
but you can just get on with your life
and make software that works by
introducing a tiny little pot of
complexity we can protect code quality
with meta programming so let's say
you've got one of you've had one of
those discussions with your team right
where every class of a certain category
should follow a naming convention cool
so so all your factories now have to end
in the word factory cool whatever I
don't really care if that's the decision
it sounds a bit dumb to me but sure let
them let it be everything's gotta be
called factory so the thing about
conventions you stick to them perfect so
here's the thing about soft conventions
they're always going to get broken 100%
of the time you know there's this
there's this graph between
predictability and error error always
happens you can never remove the chance
of an error happening you can only
minimize the bad thing that happens when
the error does happen so so they're
gonna get broken so when Bob who was ill
the day that you decided all factories
have to end in the name factory when
when he sits there and he pulls his user
story and he adds his own class without
the factory suffix and people get really
angry and sad people should never really
get angry and sad about that and they
should really get over themselves but
Bob should also do the right thing right
Bob should follow the conventions so
it's not really a realistic expectation
for people to just know all of the
little decisions that you or your team
came to at some random point in time
it's not
possible but you know what we're
metaprogramming you just make the code
enforce this stuff so consider this test
here so what this does is it gets all of
the assemblies and all the types from
the namespace where you put your
factories and make sure every name ends
with factory so just like that if Bob
tries to check in is shittily named
factory and his bill breaks and he fixes
it before anyone even realizes what a
colossal failure of a human being is but
seriously if you if any significant part
of your code base uses metaprogramming
and this is important actually this is
almost the the downside you really need
to have tests to cover it as you start
using conventions these are soft things
we're introducing a category of runtime
errors while we're solving a category of
discovering and duplication errors
because all this stuff isn't found by
the compiler by definition
metaprogramming is changing the way the
program works at runtime so your
compiler isn't going to see this stuff
unless you write like clever Rozlyn
inspectors or something but I know that
clever so really just write tests
because I can do that you're gonna need
them so it's the point this talk why why
so I put this talk together for a few
reasons so the reflection and by
Association meta programming has a
reputation for being scary and it really
isn't and you use it every single day
maybe you only use the thin end of the
wedge but it's a useful tool in your
arsenal to simplify your code bases
reflection has a reputation for being
slow and this is kind of partly true and
dotnet one one it was really really slow
and you probably shouldn't use ever
other than one time when your
application starts up but we're not
there anymore all of the examples that
we've looked at here if they were to
ever get slow really really trivial in
memory caches would make their
performance near enough
indistinguishable from any other
approach you know we looked at that one
we looked at the HTTP MVC clone well we
just cache the controllers at runtime
because we didn't want to spider through
every single assembly on the disk their
application namespace in our application
domain
every single time a request came in nice
and easy don't be scared you don't need
to be scared of this stuff it the
performance isn't going to kill you but
the benefit in predictability in your
code base of strong conventions and
patterns rather than repetition and
churn you know don't think about meta
programming as a way to stop all the hot
spots in your code becoming hotspots so
it's a really good on there's a really
good book called your code as a crime
scene which talks about looking at code
from kind of forensic psychologists way
of detecting hot spots and following the
patterns of where bugs and bad things
and errors are introduced and there's a
whole bunch of stuff in that book
particularly about detecting where the
hot spots in your code are so the hot
spots in your code or the the bits of
your code that changes the most often
where errors are most likely to be
introduced it's like it's almost you can
see as your software flows towards its
or its point of bad internal
architecture because if you're always
modifying a thing that thing is not
probably the right thing for the job it
needs to be decomposed or changed or
something else has to take that place
and a lot of the times when you start to
apply meta program to a situation it
normally replaces one of those hot spots
and allows you to explode out the
various places that you implement parts
of those components and introduce
conventions to replace them so it's
important that you use this stuff in the
right places to solve problems in your
code base not just because it's cool so
it removes a whole category of tedious
repetition that you'd otherwise have to
endure and maintain it's the backbone of
our M's mappers frameworks the web is
the glue that holds everything together
and I really want people to see the art
of the possible because frankly loads of
really cool stuff uses this super good
but but you know here's the warning
right meta program should always be used
to make the obvious thing work not to
make the right thing totally not obvious
and that's the danger you know people
will rightly criticized the overuse of
meta programming as being too secret too
magical to mystery and as an API
designer it's your responsibility to
make them feel comfortable with it so if
you're designing libraries and
frameworks you've got to keep this in
mind so nobody ever complained about NBC
because model-view-controller
three folders model-view-controller but
you don't need a manual for that nobody
ever complained they understood the
magic they knew how the sausage was made
effectively they could understand it
even if they didn't know how it was
glued together but if you're a library
author and you use metaprogramming it
becomes a vital tool it helps you work
out what kind of application is
consuming your library how to adjust to
the different runtimes loading in
different components for different
scenarios you know if you look at
something like the Nancy web framework
has anyone used that okay cool like
Nancy's super cool by basically pure
dynamic web thing it's a clone of
Sinatra from Ruby but the great thing
about Nancy's it just works like you
basically have to type any code and it
works so it's often advisable to give
people api's that trigger the magic
rather than the magic just occurring
because that's confusing to people so
for instance if we have a class called
start on our library our magic start up
library you probably want a method
hanging off star called with default
conventions simply by having that method
in your API it kicks the user in the
head
now I oh there are some default
conventions here I wonder what the deep
four conventions are maybe I should go
and look up what the default conventions
are that's enough of a prompt to make
your API discoverable if your start code
just applied a bunch of conventions
blindly that we're not explicable and
there's no sign that they were happening
effectively random behavior occurs and
people get confused so as your code base
that uses metaprogramming grows what you
tend to find is that all the conventions
that seem like a great idea at the start
that you baked into your application
don't quite fit anymore they change over
time and that's okay for every order of
magnitude growth in your software the
way you build your software should
probably change as well that's totally
cool that's not defeat their success so
in my experience and especially if you
look at something like s pinna NBC
people start with hard-baked default
conventions and then they quickly turn
into builders which have methods like
start default conventions or replace
with your own or replace with your own
so you start to expose the convention
some modification the way to win
people's hearts and minds is by giving
people at least the illusion of control
or giving them some signposts really
where as magic libraries that just do
stuff that's really weird and seemingly
on obvious get criticized if any of you
have done any Java the Spring Framework
gets a lot of criticism for loads of
magic stuff happening you just kind of
you put it interface on a thing and it
changes the whole behavior of your
application and that's crazy it's crazy
because it's really really not that
obvious and it's hard to see there's no
obvious point of change so when you're
using this stuff make sure that you kind
of lead people by the hand when you
implement your own conventions so I've
shown you how things work hopefully
enough to kind of whet your appetites
and put some of the stuff in your own
code bases even if it's just to clean up
your tests to clean up your naming to
make sure some of the more tedious and
repetitive code that you have can be
reduced out and I think that's my law
bang on an hour thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>