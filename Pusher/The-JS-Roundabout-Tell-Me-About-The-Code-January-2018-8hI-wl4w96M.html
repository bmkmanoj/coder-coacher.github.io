<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The JS Roundabout, Tell Me About The Code, January 2018 | Coder Coacher - Coaching Coders</title><meta content="The JS Roundabout, Tell Me About The Code, January 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The JS Roundabout, Tell Me About The Code, January 2018</b></h2><h5 class="post__date">2018-02-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8hI-wl4w96M" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">first of all welcome thanks for coming
I'm Tom I work at immediate media I'm a
senior UI developer so my talk today is
about unit testing and I've named it
tell me about the code because it's
almost like a conversation with the code
when you're closer to the code when
you're testing so the idea is we replace
it we're replacing intentions so user
intentions developer intentions with
code assertions so I like make you stuff
I like making websites gain services all
that sort of good stuff I don't like it
when stuff breaks so the thing about
making things is if you get a really
good feedback you get really good
feedback from when you actually make
stuff not so much when it starts to
break so on in the like in the early
stages it's okay because it's like
projects are quite small so get any
working is quite quite fluid you get you
get to like a level you make a level in
a game or you make like a page on the
website it's quite small so if you're
making a single page application
generally the feature set is quite small
so the difficulty comes in actually
keeping the stuff working so successful
projects generally change over time so
if you were to make something quite
successful you might argue like have the
users ask you for feature changes those
changes often they can introduce braking
braking code so it breaks your product
and it breaks your webpages and the more
this goes on the wall added complexity
starts to mount up and eventually you
having a bad time so unit tests unit
tests a good a good kind of guard
against this sort of thing because
you've got you've got a way of getting
quick feedback so close to your codebase
so the idea might be that you've got
your so for example interface tests
you've got kind of conversation with
your code in terms of like you've got
something happening but it's so far away
from the code base that you end up
having like we're really kind of you've
got a bad relay so I'll kind of
interface text test take about an hour
and a half maybe two hours so
kind of long time to wait to find out
your clothes actually broke anything
unit tests are a good kind of cover for
this because you've got this kind of way
of testing small increments of your coat
so for example you've got like a search
app you can you can kind of test it
incrementally like small pieces so yeah
there the reason is why we do it
so yeah they live close to the code
modification cycle so any development
can start this up start like a test
suite run them and they should be quite
fast you can automate them so the good
thing about that is that you don't have
to really kind of do anything majorly
intensive to get this kind of stuff in
in place so we're just going to go we're
gonna go straight into what a unit test
might look like so this is an example of
what a test suite and test specs might
look like inside Jasmin so keeping your
tests maintainable generally means
keeping them readable you want to be
able to say okay here's my module that
in this case you've got greeting you
want to make sure you can say that you
want to make sure what the code does
what you intend it to do so you give the
specs which is the it blocks descriptive
names so in this case we've got like
should say hi or should greet the user
by name so from this you get really good
feedback from let's say you're here
we've got like a bit of a test reporter
here we're using maka like a maka report
we've got karma running in the
background so you've got yeah you've got
a pretty good readability here you can
kind of see what greetings doing yeah so
they said this this is basically what
you want to do in terms of keeping your
code readable another thing you want to
do is follow the kind of pattern arrange
act asserts when if you've got a test
you want to keep it as minimal as
possible so you don't want to test too
much stuff you want to kind of test it
generally why this we're talking about
having a bunch of stuff set up for your
preconditions so if you've got like a
test that is testing for a certain
username set it up to at the top of the
top of your test set up like an arranged
section so you've got like your object
being arranged and then after that you
act on a certain method or you act on a
certain function
feed the feats of information in there
and assert at the end and by that this
is ways is what it would look like so
here we're testing a function called
greet it does very little it just kind
of says hello name in this case we've
got like a test case that says so it's
so it's greeting should greet by name so
we've got an arranged area where we set
up the previous is which is the the name
we're feeding it into our act which is
greet so we're making a call here we get
an actual response that we get actual
return value back so at the bottom we've
got this kind of assertion by which we
send our assertion into aspect expect
and we maybe we set up a matcher so this
is to be hello Jean so so you want to
keep your test fast so yeah so slow test
don't get run Network calls a slow which
means the slower you will of your tests
are they just not gonna get run it's
going to end up like into interface test
or integration test where you can only
run them closer this build pipeline so
you want to keep them quite quite quick
just just to cover some more things
you've got time outs as well they can
slow down tests file system access or
database calls if they're on the same
system again and you're not mocking them
out they can also slow down tests so
we're going to move on to spies stubs
and mocks so this is a way of getting
around those initial problems so for
spies susp eyes are good for kind of
testing what your code is doing to stuff
that comes from the outside so in this
instance we've got a method called
invoke call back or a function call
invoke callback which all it does at the
moment is this is calling callback with
a couple of arguments so this is just to
keep it quite light in terms of what the
code is actually doing so here we've got
a spec that's called sweet called invoke
call back and we've got a spec that says
should invoke the provide a callback
callback so then we set up the callback
so we're arranging our stuff up front
we put this so this is aspires as an
honest sign on I'm using here the spire
goes into invoke call back and then once
it's been called so once we've acted on
the on the bond the function within a
certain things have happened so down
here we got some sign on it certs we
want to make sure it's been called at
least once so we check that a callback
it's been called once we also assert
this be called with a certain set of
arguments so you can also do this with
methods on objects so in this example
we've got like a class called greeter so
it's just a small little thing and
there's a constructor takes a name and
there's a greet function on it a group
method so again I've got a kind of a
arrange area up here where we're
constructing the greeter we're setting
up the spider to to the method of greet
on greeter and then we do then we act on
greet greeter so at the end of this you
end up there with so there's a couple of
a search here just to show we can get
out of it
the first assert is making sure spies
being called and you expect here is just
showing you that the underlying spy is
it still being action so it's not
actually it's not kind of just it's not
replaced it is still calling through
that's that's what sign-on gives you and
then we restore greet - what voice
original state was here again we use
these so now we're using stubs and we've
got a function called validator which
takes a data provider and we're just
doing some you know it's not really
validation but yeah some kind of
validation so here we have another
another test we've got a describe which
is the sweet goes through so this time
we're stopping out what we expect this
thing to return so at the moment we're
expecting it to return bad value so
we're setting up just to just a return
of a bad value the good thing about this
is you can test your kind of Erised
in your code here we know we're going to
fry our type error down here that's what
we're saying we're expecting so we just
wreck this validator in a method so
expect calls this and we expect it to
throw an error of type type error well
of the constructor type error and
expected error as its message mocks are
slightly different so with a mock you
can
mock's so here we got like an example of
a callback delay so all we've got is
we've got like a constructor and a
method that's called execute after we
pass it seconds and we expected to call
set timeout so what we can do with marks
is set up the idea of like controlling
time a little bit so we've got our kind
of here we're using a sign on fake use
fake timers so we have sets so the clock
is now replacing set timer saying of all
date and a bunch of other things that
could be used about timers and then yeah
so we act on this so you've got callback
delay execute after one second
we close the clock pin ticks down so
we've brought an eye nine eight
we're asserting that the callback hasn't
been called and it kind of ticks down
until it calls once so it says just so
you wouldn't necessarily assert a lot of
things in one function what kind of want
to assert one thing but it just
demonstrates the point that if you've
got time as in place you can kind of
make sure things are working the way you
expect them to then again we at the
bottom of this we restore clock so that
should set all the kind of set timers
intervals dates all back to the way they
should be so effectively we were trapped
we've got time travel in our code we've
got like so something that would take
one second to you without mocks to run
we now have yeah effectively you've got
milliseconds
similarly with fetch mock
do stuff with fetch so fetch makes a
call-out for the network we don't want
that so we can set up our fetch so we
mock out fetch we call the method which
is kind of returning a promise and then
we can kind of assert on certain things
like in this example fetch mock to be
called and also that the last URL we
used was a URL we passed in in our test
we also capped the file just in case
because you want to fail fast on tests
so you pass in the error message you
know just to give you a bit of
information about what's happened so
yeah starting up new projects I would
say you want to kind of think about gang
testing early because without that you
kind of you kind of miss miss a chance
yeah so get a test harness in place
confirm that it works by writing unit
tests make sure one fails and then make
that test pass execute a test run out
verify everything is working and then
yeah your any weights making unit tests
for your code so in this interests in
this kind of demonstration we've been
using karma so that's our test runner
Jasmine sign on so Jasmine is the test
framework sign-on is getting us all the
kind of spires the stubs the Mocs and
fetch mark he's kind of mocking out fish
so fetch API calls and we using maka
report for this beautiful report testing
legacy code so the problem with with
legacy code is there's kind of two ways
to handle it like if you if you go into
a project that hasn't got unit tests you
can either edit and pray which is the
kind of so this isn't as bad as this
this gif is leading to it's kind of like
sewing you you make sure all the stuff
you're doing you're kind of going
through the comb make sure all the kind
of areas that you're affecting are kind
of covers you're looking for all the
code make sure you're not gonna make too
many mistakes but at the end of the day
you're still praying like you're not
you're not got tests in place so it
still going to be like you know
it's a long shot the other is cover and
modify so this is this is a little bit
slower but it kind of it gives you in a
place where you can kind of say right
I've got tests around the kind of code I
am touching but you know you've got
tests in the place but the touching so
modifying it isn't as dangerous it's
still kind of dangerous because it
legacy code you don't really know what
everything is doing so but yeah I mean
is it's better than nothing
so yeah it's hard in Aleksey code is
hard to find seems to get this stuff
into sign-on helps a lot with that so
you've got kind of spies and so all the
kind of spy stubs and mocks are going to
help you there yeah so coloring is often
done with manual testing you know in in
our experience that is in this company
at the moment with legacy code and unit
tests won't catch everything so you've
got this so with interface tests
integration tests and unit tests you
kind of catch more see how you kind of
want this kind of idea of like you've
got unit tests as your base so that
you've got a lot a lot of unit tests so
you get really quick feedback that way
above that
get a few integration tests make sure
that you've got kind of like modules
working together as you expect
and beyond that setup UI like selenium
tests and stuff like that just to get
into end tests in there what you don't
want is to have an ice cream cone
because the problem with an ice cream
cone is you've got like so you are test
taking on time already so you just don't
want to you know you don't want too many
long running tests otherwise you're
never gonna know what your code is doing
you're never going to run the tests so
recommending reads around unit testing I
would say working effectively with
legacy code is number one for me if
you're working with legacy code tells
you a lot about how you integrate tests
that tells you a lot of our seams and
things like that
reliable jobs goods is good for getting
the test in a state that can be tested
and also clean code by obviously Uncle
Bob thanks a lot
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>