<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Adopting Modular JS - Front-end London (FEL) | Coder Coacher - Coaching Coders</title><meta content="Adopting Modular JS - Front-end London (FEL) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Adopting Modular JS - Front-end London (FEL)</b></h2><h5 class="post__date">2016-04-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aAn9CQGZuz8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">maybe aren't familiar with modular
JavaScript at all or what even that
means so I'll cover a bit of that but
also I've hopefully got some kind of
slightly more meaty juicy stuff for you
guys that actually already know about it
so that you know I'm not entirely
preaching to the converted pointlessly
so a little bit about myself this is me
I think I'm aged 11 there but you know
this is before you know you had time
coded cameras and stuff so you know
something around age and as you can see
I was kind of big into my tech you know
I've got Casio keyboard so that's how I
became what I am now and these are some
of the things that I'm interested in or
that I do in my job my job definitely
focuses a lot on best practice because
half of my role is kind of about
leadership and and understanding what
you know the industry does and making
sense of that figure into my team
I'm also got kind of a little personal
obsession with web accessibility I think
we should all be making products that
can be used by anyone and for the
keen-eyed of you out there might notice
that actually I've got gardening in
there it's it's true amongst all those
are the amazing neat Eric things I do
actually have an allotment so yeah I
work at a company called zone we are a
full-service agency we have offices in
London Bristol and now Cologne and
weirdly enough as of tomorrow I'll have
been there for four years so this is
something of an anniversary so without
further ado yeah what want to explain is
a little bit about what it is what
modular JavaScript is and why you would
switch to it if you don't use it already
a little bit about what the actual api's
are that are out there that you can use
what tools you can use to actually make
it happen and some of the ways we
actually go about where I work
implementing it because it can be a bit
of a minefield so what exactly is it
well let's maybe start just by looking
at the actual goals all of the kind of
api's that have been
produced over the last whatever five or
six years have kind of got similar goals
so yeah to encapsulate code there was a
good talk last time actually about some
CSS modules and that was you know one of
the big pluses of that was encapsulation
and having logically organized files in
a similar way to other languages the
languages obviously had this approach
for quite some time and also defining
dependencies that must load before a
module has execute that's really really
important and one of the massive
persuading factors for switching to this
so essentially you are ensuring that you
don't have that ridiculous situation
where you know you have a script tag
somewhere on the page and jQuery loading
as the JavaScript runtime or the browser
sees fit and then another bit of code
which relies on it maybe not loading and
actually having access to that so this
whole structure is to avoid that
silliness and finally to load smaller
more manageable files and only load them
when needed which some of the things I'm
going to talk about later in the talk do
better than others what it actually
really is it's a design pattern so you
know I suppose in lots of industries
where you make things you have different
patterns different approaches to imagine
in engineering and some of the
industries you have different ways of
organizing things that you can reuse
them so a sort of quick example of the
kind of things I'm going to dip into you
know having multiple files that are
maybe if you decide so organized in such
a way that you control them with one
single file there are other patterns or
complex ones but the whole idea of it I
guess in a way is to reduce complexity
and as nice old Brian Kernighan said
controlling complexity is the essence of
computer programming and if you kind of
wrote UNIX you probably know what you're
talking about
so this is how it used to be for us when
I started his own it was very much like
this so we had one one awful horrendous
single
normos file of like thousands of lines
of code in it and no dependency
management poor ordering if you could be
asked you might move some functions
around to kind of group them with their
buddies but generally no one could be
asked or didn't at the time you had
really weird close coupling and you had
loads of merge conflicts because
obviously if you have lots of big files
with lots of lines of code get or
whatever it is you use to version
controllers can have a nightmare
actually making sense of all that if you
have lots of Deb's working on the same
file so it was kind of like this for us
you look at file and what you couldn't
make any sense of it and now because
it'll be better so we might have on
maybe a medium sized sort of CMS driven
project 30 smaller files we have
complete dependency control so you know
any third party plugins any frameworks
and libraries we're using are only
required when necessary we have loads
less repetition like I used to look
through when I was tat leading I put the
project so you can look through the code
that we produced in are ginormous single
files and actually sometimes find the
same function doing the same thing
because one dev would have written it
and happily got it working and other dev
wouldn't know that it existed and
happily got it working and so it goes on
and consequently fewer bugs and fewer
merge conflicts but just to point out
with all these approaches you have a
little overhead and I'll come to why
that is later so now we've got a nice
you know nice warm feeling when we work
with each other you know that's that's
me so just a bucket or some evidence and
you should always have a slide like this
I think in a presentation at about you
know really full-on vertical text of
numbers say numbers cell stuff so Stack
Overflow absolutely tons of results for
people probably having loads of
headaches with modular JavaScript loads
of github repos loads of people have
tried to solve the same problem which is
great and loads of Google results if you
google it that's an astonishing number
of results half a million I guess maybe
some of it is kind of porn spam
stuff but you know it's a good number
and you know as a consequence thousands
of happy devs
and we've used this approach on loads of
projects so it's just a handful of the
clients that we work with it definitely
saved our bacon in a couple of
circumstances though the work we did for
Tesco I know SBB or recently has really
benefited from us being really organized
taking this approach so for those of you
that haven't adopted it already and I'm
guessing some of you have in fact let's
do a quick poll so hands up if you use a
modular JavaScript approach okay so yeah
just over half so I'll skip this bit no
joking this is why you would do it this
I would say you're gonna get more
manageable code you're going about two
separate concerns more easily one
advantage that is probably a bit
underrated but we've all had headaches
with is you protect the namespace so not
everything in the whole world is hanging
off the window and possibly fighting
with other things and you can leverage
open source packages more easily I'll
come to that in a bit but essentially
it's about kind of using things like NPM
or other ecosystems that exist out there
and you can do lazy loading and I'll
come to that shortly as well too
so if you had to sell it to your
colleagues for any reason or your boss
you know maybe they're particularly
stubborn I don't know but you can
definitely make the case that you're
gonna have a lot more easy onboarding
and handovers with other team members um
more easily have parallel work streams
because you know one person can work on
one module or one feature which could be
a module and another person on another
therefore you get more easy application
maintenance and yeah you get less errors
and debugging is kind of easier because
you're able to focus on the problems
that exist in one small area so in one
phrase that would be the cell it's
basically an investment if you don't you
haven't got a boilerplate or something
that is configured like this but a bit
of time in make it work and reap the
benefits so
the landscape this is the bit that fried
my head when I was putting it together I
have to say because there is quite a big
landscape out there however I'm going to
start off gently so the first thing I
think is worth pointing out is that
before we're kind of going into any of
the major api's there is a pattern
that's been around for ages which addy
Osmani has done a great job of
documenting which is called the
revealing module pattern and it's not
necessarily quints you know it's not
quite essentially modular JavaScript but
it's just a way of thinking about
JavaScript so we have a quick look at
some code I know it's a bit scary but
essentially you can have a module which
is just a self calling function and some
things in it there could be objects that
could be functions they could be
properties and you decide what it is you
want to return what kind of undoing
myself with my own shadow it's a bit
annoying and when you actually want to
run it you essentially you've decided
what you've revealed or not and you can
call it so one of them isn't going to
work and one of them is and you can
really have things that run privately
things that happen when you've loaded
that module but it's just a really
really simple idea do any elegant idea
that you just encapsulate something and
you decide what you make private and
make public and early on in
I guess the thinking about JavaScript
patterns a group formed who were
previously called server jeaious and
have since become common junior now they
create a pattern they actually wanted
this to be the kind of the tonic for
lots of JavaScript programming woes and
they were hoping I think that the
industry and maybe even JavaScript
itself would adopt their ideas and maybe
in a funny kind of way it did but they
came up with this idea and it was kind
of really I guess born out of
server-side JavaScript so node
essentially and it's really really nice
and and clean to look at and really
simple to use
it doesn't have any kind of wrapping
function or anything you can just decide
what you what dependencies your list and
decide what things you export as a
module funnily enough it does actually
work synchronously so if in a weird
situation you were loading a module
which it it could get but was gonna take
time to acquire it would actually
completely stop the browser from working
temporarily while it was thinking about
that but it's the whole sort of premise
of commonjs is it's some sub having a
short distance so all the files that
you're using are are in your application
and are easily accessible and therefore
you don't really have a problem with
that you won't notice it there is a
little bit of an example of commonjs so
as you can see don't need anything kind
of wrapping anything else you can just
decide what it is that you attach to
this module object which it gives you
and you know it can just be a
calculation it could be another function
and yeah it's really really clean and
straightforward and very nice and then
shortly after that came along AMD which
at the time seemed like the most
wonderful thing in the world I guess we
certainly thought it was and the whole
idea this was rather than the common jet
approach which is kind of about the
server that was about giving something
to front-end amps you know people that
work in the client in the browser and
designing a system that's not blocking
so when you require when you request
access to another module it goes and
gets it asynchronously so it basically
sort of puts the phone down
and walks away and goes and watches the
TV for a bit and then comes back and
says your module is ready now and but it
hasn't broken anything in your app which
is really nice
can be really nice but speaking of
wrapping functions it uses this define
wrapper and yeah that has its pluses and
minuses it's a bit ugly maybe and it's
yeah it's more of a boats so you have to
list the things you want to load and
then you have to list the things that
you might get back if those things
return something so obviously I'm using
jQuery here and
get back a dollar and then I can use it
and yeah it can get pretty messy we had
some really really fun times with the
AMD approach so even though it's talking
and supposed to have too much opinion in
it you're probably gonna get some you
know I basically I'm over this now I'm
over it
and I had to sort of shoehorn this in
because I think this is really
interesting example of I guess how weird
the landscape is so someone cooked up
this idea that okay we want to be make
be able to publish modules that use AMD
and CJ s and actually jQuery plugins and
and it goes on and on and so they made
this amazing thing called the UMD
wrapper which you can throw in the top
of your module and it's only really
really small and concise like this and
really easy to configure Wow I actually
contributed to a live in recent anywhere
I had to add this and it so wasn't fun
and the real gotcha is that if it uses a
node style thing like a command Jack's
kind of thing then all these paths will
probably work because things like moment
J s or es6 promises may exist on NPM and
that's great because it will just go and
find it will look it up by its name but
if it's AMD it probably won't know where
it is unless you've told it so so you
have to figure these paths yourselves
and anyway it served a purpose it still
serves a purpose but as Scott Andrew
says it's not a lie I mean no one said
it was a lie right but anyway it's not a
lie it works but it isn't compromised
he's actually the author of curl jeaious
which is a library a bit like require
which I'm sadly not going to feature in
this talk so apologies Scott so yeah
here we go dinner it's the slider one
was waiting for probably it's the one
I'm so excited to deliver yeah six
modules I mean es6 is the panacea for
everything right I mean yeah es6
or someone shaking the head okay well
I'm gonna go with it anyway
it's it's good for certain things right
but it's got a way to go so yeah because
of the proliferation of these api's and
because I guess there are kind of
managed by different groups and
non-standard yeah JavaScript adopted it
so it's actually an official part of the
spec now even though almost no browser
actually fully can implement it yet but
it's designed for the browser on the
server which is really really nice so it
kind of caters for both of those worlds
and the wrapping that I mentioned it's
implicit so you don't need to do
anything too fancy it's really really
concise I suppose and and kind of pretty
to look at there's lots and lots of
really lovely ways that you can that you
can import an export and you can do
multiple things at once you can rename
modules just using one line and I won't
go too much into it because I'm probably
eating into my own time infusing about
it
but some but yeah it's pretty smart so
just to summarize this bit AMD user does
kind of require and define paradigm and
it actually does also support module on
exports and exports so you can actually
with requiring with AMD environments you
can actually also write in the CJ style
I don't know if anyone's done that or
had much fun doing that but I can't
imagine it's particularly great cjh uses
require and this exports well this
module object and es6 just has a very
simple import and export interesting
though it does also have a system import
which again I don't think it's
implemented that well but there are
polyfills for it and it basically means
using promises you can you can load
other modules so you can do nice
asynchronous stuff and yeah conversion
so yeah I'm really really it pains me to
think of anyone who's had to do this
convert from AMD CJ CJ s you can do it
there's a couple of decent libraries on
github
I can't imagine is much fun and you can
go the other way as well so you can go
from CJ at AMD which I believe
SoundCloud had to do so they had load
the legacy code and they had
convert it so they used a library called
sweet Jas do it you can convert from es6
to Andy and CJ s confused okay good
which is kind of getting to the number
to talk in a way because is this
approaches is what we actually take and
is working really well for us
using the lovely babel trans pilot so
let's have a quick look at the loaders
so first up require which largely uses
the AMD pan but as i say can also do CJ
s and the nice thing about require maybe
is that it runs in the browser so you
you basically you can write a module and
save it and it will manage it for you
there's no build step and it can lazy
load things so let's say you've got
application where you've got loads of
libraries on one page you've got d3 and
I don't know p5 and loads of canvas
stuff loads of fancy stuff going on you
can just load the modules that you want
for that page without having to do any
fancy bundling and it's now got some
pretty decent community support because
it's been around for a while the cons
are using it the error logging is
terrible if for some reason you've got
one single name wrong for a module it's
not going to tell you that you can
basically kind of if you use it for long
enough you kind of get used to these
weird errors and you eventually figure
out what they mean or you make educated
guesses that's not fun and the caching
problems that's that this is a really
weird one for me even if you've got dev
tools open and you refresh it still
doesn't say always give you your new
code which is horrible the documentation
so awful in fact I'm gonna start there
I'm just moaning mmm so yeah one gotcha
one thing you've got to watch out for if
you're using it is this order the order
of the things that you're loading and
the order of the callback the the
objects you're getting back in your
callback they have to be absolutely
correct if this structure data was
before base game over so just want to
watch out for their next up browserify
which is basically born out of node so I
mean to check out that logo what a
stinker
horrible I don't know what they were
thinking but and it's just nothing to do
with notice it's not even you know
anyway so yeah with commonjs
that kind of someone saw the need to
bring all that node loveliness into the
browser and so they came up with
browserify which basically allows you to
take advantage of NPM and all the node
modules that are out there in that
ecosystem so pros for browserify as I
said earlier simple syntax you do get
some sensible errors it's got really
really nice documentation if you can
overlook the branding and with with the
help of Babel if I which is like a a
nice little plugin you can write in es6
and it will spit out CJ s for you so
yeah once more downside I suppose is you
need is there's a build step but then I
suppose lots of front end our Deb's and
generally using data managers tough to
do build step so so maybe not a big deal
yeah if you want to output multiple
bundles it's a bit more of a headache
it only supports CJ s and as I said
earlier it's synchronous it could be a
downside but I've not had a problem with
it and yeah just just to reiterate so
yeah got cheese I suppose he only got
 really is it and this is just a
general node got you is that what an
actual NPM module returns is like varies
wildly so if you're using this nice
handy ESX promised polyfill you've
actually got a you know you've got to
actually attach it to that particular
property some things don't actually
return anything at all which I suppose
happens in other situations but I
definitely had some some NPM weirdness
or node module weirdness next up web
pack which is by far the most powerful
of all of them I would say it supports
AMD and CJ s it's really easy to create
multiple bundles which kind of
ameliorates the problem of not being
able to do lazy loading so well it's got
a massive set of features so you can
kind of process images in it
do all sorts of fancy stuff
documentation is really really good
logos okay ships with its own server
which is pretty nifty it's basically
trying to take over the world really
it's it's a completely comprehensive
it's amazing and I sort of struggle for
some cons I suppose it's quite quite a
lot of fat to configure and there's a
bit of a steep learning curve because
you've got so much power and it's not
very prescriptive browserify does a very
sort of single purpose thing whereas
webpack kind of yeah as I say tries to
do too much and just quickly JSP M which
is kind of a new clean on the block this
has its own registry I'm going to leap
to that point because it's a really
interesting one so you can't just sort
of say JSP m install jQuery or go and
get it look it up and it supports all
the different patterns there are but you
have to pick one so that's one of the
cons I'm included that you actually have
to pick an API you can't mix them in web
pack you can which is really interesting
and the community is quite small and
some of the plugins aren't very mature
so really nice idea JSP m but I'm not
sold on it personally as I say no
opinion whatsoever so how do we actually
implement this so I think the most
important things to to assess first of
the performance of the actual product
you're making the maintainability and
the scale so if it's a really small
project then I suppose you know there's
no reason to you know throw all the big
tools at it you know you could just go
for the most simple and straightforward
scaffolded project that's not to say you
shouldn't use modular jobs get and just
saying that you might not need web pack
or something as heavy as that but it
depends entirely on yeah on what you
want to achieve and the shape of your
team I think is important as well okay
if you're a freelancer then perhaps this
doesn't matter so much if you're not
gonna have to hand the code over to
someone else perhaps as much so much but
what I've found is every time we've made
a new step forward or what feels like
forward where we've adopted a new
strategy to building web sites into
making our code more maintainable that
we've obviously got to educate the
they're less experienced people in the
team and some of the concepts in here
and some of you know the products like
require for example we start a great
documentation they're going to take more
of your time if you're the person who's
in charge of educating other people yeah
you're going to have to really put the
put the hours in and put the effort in
to make sure everyone's up to scratch
and you're probably gonna have to sit
with them occasionally and do some
really grim debugging so yeah make make
the time for the education the nature of
the app itself so if you're using a
framework like react or something then
it kind of starts to D couple lots of
the scripts and the views and things
anyway and it's got an a it's got its
own way of tackling I guess some of the
goals which this subject does and yeah
and if the application shares code on
the server and on the client then it's
maybe worth just picking commonjs
approach because it's kind of designed
for the server and can work in the
browser and you know if the project is
going to be around for a long long time
could argue that you should use es6 not
just for modular JavaScript but for for
everything and shaking heads out there
this time maybe not
but yeah you know it's if you want a
future proof it then that's the
direction that everyone is seemingly
going in I though I appreciate this an
effort that goes with that because you
have to transpile down to something that
browsers can understand so here's just a
quick diagram a simple diagram of how
you might manage a site how you might be
bundling it have a bunch of things which
go into two different modules which are
then only rendered on the home page and
you can sort of decide on the
architecture yourself as I say the
easiest thing I found for doing this is
either require or webpack browserify
does do it but it's a bit more stuff and
the tools that you can use to actually
compile and concatenate all these things
together and they do need to compile
because even with CGAs you need
something which is going to tell the
browser how to actually work with it so
gulp and grunt are the two obvious task
managers but you can
you want to use some of your colleagues
the server-side applications I
personally wouldn't no opinion so the
way we do it
zone is all modules are discrete pieces
of functionality they they are sometimes
a sort of trackable feature you know in
a project management sense sometimes
there's more than one module that
belongs to that particular feature in
the browser that is they always run
based on the presence of a data
attribute so we kind of don't use CSS
classes or anything like that we keep it
just to using patron tributes for
decoupling and we use source Maps
so with gulp and grunt you can create a
map of all the modules that you were
writing in so that when it actually
renders one bundle or one big file
you still know what you're looking at if
there's a bit more time I could have
shown a nice little screen cup of that
but you just have to use your
imagination sorry and headaches I mean
of course with these things that were
always headache so lots of times I've
we've had problems incorporating
third-party scripts so you might need a
shame or you might need to actually wrap
it yourself in that UMD wrapper or some
something to make it work properly
because not everything that's published
on the internet for Lena works with
everything else and keeping a large
project organized it takes a bit of
effort so you know consider things like
naming conventions and how you structure
your folders and yeah one last little
tip handling data so each module is
obviously encapsulated so you need to
think about how you're going to share
things that happen user actions and we
use pub/sub which is a way of listening
for a particular event you can use
jQuery to go to and we use promises face
and kind of stuff and we completely
avoid using callbacks as much as
possible so this is our stack so we
write in es6 as much as possible we use
gulp to manage most of our tasks we use
browser fri / babel defi to convert from
es6 to common j
and it works in the browser and this is
what we're kind of moving to so we're
going to adopt web pack and I'm sorry
that was almost half an hour big subject
though so thanks a lot</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>