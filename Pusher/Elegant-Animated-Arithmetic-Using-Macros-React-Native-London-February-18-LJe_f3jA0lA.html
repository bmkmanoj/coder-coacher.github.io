<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Elegant Animated Arithmetic Using Macros - React Native London - February 18 | Coder Coacher - Coaching Coders</title><meta content="Elegant Animated Arithmetic Using Macros - React Native London - February 18 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Elegant Animated Arithmetic Using Macros - React Native London - February 18</b></h2><h5 class="post__date">2018-03-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LJe_f3jA0lA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">earlier this month I built a package
that lets you do elegant animated
arithmetic with react native so a bit of
a weekend project and then medium
article and then then here we are
and I want to mostly spend my time going
going over the why why I built that
except apart from that it was fun and
and then then a little bit about about
the hop so just for walking for that
actually so quick show of hands who here
has used the animated API or has heard
about it
cool yeah so it's solid majority here I
think that's cool so I really want to go
very quickly over just the fundamentals
of why why animated is a thing and then
and we get to why my package is a thing
essentially so is anyone heard of the
term the bridge the the js2 Native
bridge in relation to react native yeah
cool so one of the key things about
react native just in general is that we
get to to render in JavaScript we write
components and they render out JSX and
then whatever we render happens and
shows up on screen through some some
native code so the the communication
mechanism between the J's side and the
negative side is called the bridge and
there is there's a lot to be said about
that but basically one of just the core
mechanics of a react native app is that
we render and rerender and rear ender
from state to whatever the the new UI
state needs to be and that travels over
the bridge as instructions for things to
then happen on the native side for
specifically things like
native style properties to be set and
graphics code to run and pixels to hit
the screen and this just happens over
and over and over again now how does
that really work with animations so an
unfortunate fact of how react native
works is that the bridge is slow it's
awesome it enables a lot of things but
it's just slow if you want and if we
want to animate at 60 frames per second
or whatever you know that the benchmark
is these days
then we rendering and sending new
instructions over the bridge is just to
slow it just does not cut it hence and
as most of you are aware the animated
API was born so with the use of the
animated API and again this this the
this can be its own talk just
introducing this this API and
unfortunately I don't have the time to
do that
but the key thing to to to note about it
is that it saves us from having to re
render we instead it reorganizing things
such that we can send instructions ahead
of time when we do render infrequently
you send we send the set up of the
animation and then it all happens very
quickly and very frequently on the
native side purely on the native side so
there's a native driver involved that
receives that description of the
animation and just runs a tight loop
churning up frames and actually setting
the native properties of the native
components things like all the visual
the visual properties opacity transforms
etc
now I only have one big yellow slide so
this this this is the one this is the
one to pay attention to what so that's
right
the the core API that this library
exposes is centered around and then
animated there's library that comes with
react native core API that exposes is
called the animated value class the
animated dot value class now that
represents a value that changes over
time that can drive an animation and
what the value is doesn't actually
matter so there is there is an actual
number that changes from frame to frame
but the whole point of this is that our
JavaScript code doesn't care on a frame
to frame basis what that number actually
is that is obstructed away and that is
the native drivers responsibility to
actually manage that value and we can
subscribe to callback so we can we can
occasionally know what the number is but
mostly things are structured such that
our JavaScript code or JavaScript logic
does not need to know what what's in
there now
this class exposes methods to do all
sorts of things one of them is to
control animations so we can start an
animation to to take a certain amount of
time and to go from a certain value to a
certain value saying going from zero to
one over two seconds and we can say okay
now start that and the nature driver
goes to work turning out 60 frames per
second of that we can also connect
physics-based we can start physics based
animations you can start connect a
spring model another nice thing is that
we can
we can link animate the value to two
live input from an event from the user
so so touch event scroll event etc we
can use that to drive animations which
comes in handy when we want to show
visual feedback or on an animation
another another major thing I'm going to
go yeah that major thing we can do with
animated or value is we can bind it to a
style property when we do when we do
remember we can use animated values to
say this is the property this property
of this component should be linked to
this value so whenever it changes
quickly on the native thread this
component and this property of this
component will actually change visually
so again capacity of transforms or
colors things like that and the third
area of the API which centers around
this class and and this is where this
talk is mostly is mostly concerned is
set of methods that let us interpolate
values to make new derived values and
more specifically to to combine values
in certain ways so we can and we'll show
an example in a little bit but one thing
that this allows is for us to add
multiply subtract etc between different
instances of animated values that we
have in our code and this comes in handy
when we want to to create more more
complicated effects we may want to add a
value that comes from from a time-based
source and a value that comes from from
a vector form an event source and we
want to do some calculation on them and
use the result of that to actually drive
you know the opacity of of the button or
the transform on on the other piece of
text and now we also may
into calculations on
animated values so let's look at one
simple very simple example if we want to
add two animated values in this case the
stored in variables called x and y then
this this is how we can add them
together we use animated dot add of x
and y and the result of this is itself
an animated value instance we can use it
anywhere we could use X by its own or Y
by its own so we can use these kind of
composite values a more involved real
world example this is modified from from
from an app that actually built this has
to do with kind of a circular animation
circular progress indicator with pulsing
animations yeah you should have seen it
it's a shame we don't have it in my
slides but so in this example phase is
an animated value and angle is just a
plain JavaScript variable that holds a
number it's a constant as far as we care
and this expression adds together phase
and PI times 2 plus angle divide all of
that by PI times 2 and returns the
remainder from from that division so
that that basically implements the
modulo operator now this is all really
nice I really do like this library but
by the way side note this is how you
this is what people use for keyboards
before they were there were key words to
program computers this is literally a
pair of keypad controllers that were
actually used for basic programming on
the Atari just thought I'd mentioned
that keyboards are much nicer so about
about these calculations with animated
values there are a few things that that
could be nicer about this basically and
and it kind of comes back to a point if
I can paraphrase something Matt said
when we when you look when you look at a
piece of code you you want to just
understand what it does kind of
intuitively
you don't want to spend time thinking
about why it looks weird so this really
ties into that so we're used as as as
coders in JavaScript for instance and a
lot of other languages we are used to
writing mathematical expressions using
an infix notation so first variable then
the operator in the second variable but
here we are forced to put the operator
first or what represents the operator
first we do add XY rather than what
we're generally more used to which is X
plus y now a more kind of nuanced point
is about types it's really not obvious
in this code what the types of phase and
angle are remember I said phase is
animated and angle isn't that actually
decides and dictates the the shape of
the code around that the shed the code
that uses these variables so we have to
use animated ad for phase but when we
want to add something to angle we use
the plus operator so this is just that
bit of imperfect economics I would say
in this API
and it occurred to me one weekend
earlier this month that it could be
better so what if instead of what we
just saw we could just say value equals
blah blah blah
X plus y something that looks a lot like
just X plus y what if instead of that
second complicated expression we could
just directly write it with mathematical
operators that we know from JavaScript
this a in in my eyes this the this is
much easier to read much easier to look
after all the time so yeah so it turns
out we we can do this and the package
that I built and we're going to keep
talking about allows you to do that now
to dive into how how this works
the just a bit or opportunity to get
kind of a better feel for it just a
quick refresher on tag templates in
JavaScript so again quick show of hands
who's who's comfortable with the concept
of es6 tag template alright cool
so template strings just those strings
where you can use new lines and you can
use you can use variables in etc then
that that just makes a string a tag
template like this one in as of year six
is it's actually much more powerful than
that it's a sneakingly powerful feature
of obvious six and a lot of new and
interesting uses of it are still coming
up because this expression is actually
equivalent to writing this foo the tag
of the template and the example of user
to tag template syntax foo is actually a
function it can be a function that does
whatever with the templates that the
fixed part the the the literal part and
the variable parts of the string that it
received
and it can return basically anything it
can return that something that's not a
string and specifically as in our case
it can return an animated value instance
so this you know so this is a just
JavaScript solution now going going back
to this so my package package I built is
basically it basically comes in the form
of of a template tag function that you
can use you can import and use anywhere
in your code and through a bit of
additional magic we'll get to in a
second this is exactly equivalent to
writing the the animated library code we
that we saw before so just a bit about
setting up with this it is as easy as
installing the package from NPM setting
up babel plugin macros if you haven't
already and you should if you're using
any kind of js2 j/s transformation any
kind of language enhancing modules you
should probably check out you should
probably check if they have a macro
version because this is much much easier
to set up you set up if you've ever set
up a build
if you ever edited babel config web pack
loaders etc that that stuff adds up so
the thing with macros is that you set up
the plug-in once that's potentially be
non-trivial set up to integrate with all
of your tools but after that you just
import macros off of npm and you just
use them and they just work so as
someone who has written babel plug-ins
and used a lot of Gradle plugins this is
much lighter weight and it's yeah it's
actually fun so you install so having
set up Babel plugin macros
just once per project and install having
installed the animated off macro package
you import
the tag function from animated of macro
and you use its lifelike we like we saw
before now the way this works is that is
actually twofold it actually yeah so
it's a compiler and we'll go into into
what that does but an interesting fact
is that it's actually two compilers so
to answer the question about performance
this all happens like the main way you
would use this as a bagel transform is
at compile time it's it's it's sweeter
than speech it yes but yeah it's kind of
kind of that idea just integrated with
the bagel ecosystem so it's the idea is
that import goes away completely
it doesn't even you know if you care
about your bundle size although in react
native whoo okay less about that but it
the package literally isn't there at
runtime and then there is no parsing
that happens in runtime it all gets
compiled as part of the babel transform
which is which happens anyway when
you're using react negative the tool all
there anyway so as part of that the
import goes away all the the fancy
syntax goes away and it's just animated
library calls so you get you'll get all
the benefits of the syntax with nowhere
and tying overhead essentially but I
said two compilers so bit of trivia
trivia is that I do have a version of
this compiler included with the package
that does have a runtime cost and that's
literally just for for demoing it on
expo snack so an expo snack I can't
actually configure Babel plugins so and
and then that was a really nice kind of
exercising the abstraction right writing
the same compiler for two targets one
that generates JavaScript code which you
would use in production and one for demo
purposes that that does all the heavy
lifting at runtime and
so so really quick run-through of the
actual compiler that's involved because
this is legitimately an actual compiler
of a very very small and restricted
language that a compiler nonetheless so
we start with the strings and
placeholders that make up the template
by like we saw these two kind of arrays
one of the of the constant parts and one
of the variable parts we process that
into a stream or a soup of tokens which
is just a linear kind of representation
of what comes first know what comes next
we'll see an example in a little bit
then we pass this token soup into a more
into a structured representation which
is an abstract syntax tree we applied a
set of syntactic syntactic rules to to
understand the structure of the
expressions from from the tokens and
once we have that it's really easy to
just traverse that tree once go through
all of the nodes in the tree and convert
them to the equivalent bit of JavaScript
that that actually needs to run for it
so to illustrate that going to look at a
very very simple expression which which
computes X plus 1 so the tokens here are
one place holder which holds daily X
variable one Operator which is plus and
one numeric literal which is one so
having extracted that representation
from the source we apply a rule that can
detect that this is a binary expression
with the plus operator which has a
placeholder as its left hand side and
literal as its right-hand side so it's
it's a tree it's a small tree but it's a
tree
and then that immediately translates to
the equivalent JavaScript which is add X
and one so we can see all all of all of
the nodes in the tree are represented
just embedded in a in a new structure in
the new format so where can this go next
I have my ideas and after I released
package some interesting Twitter
conversations started about crazy ideas
what can happen with this but basically
one one fairly obvious obvious thing is
that the actual language can be extended
there are more mathematical operations
that that can be represented like
absolute value and and other things
maybe kind of a full math library which
right now we can only do the really
basic arithmetic another interesting
kind of Avenue of exploration with this
is has to do with with integrating this
more tightly with react native itself so
taking advantage of the fact that that
this tool now exists exists maybe we can
make it output of a better data
structure or a better representation
that's more efficient to send over the
bridge or we can do some yeah and it's
kind of a whole world of compiler type
optimizations essentially we can check
which variables aren't being used all
the stuff that comes with with having a
bit of syntax available to analyze and
one thing that I found really
interesting is is a similar approach can
have other uses within react native so
when I stopped at animations so are
there any other places where we might
want to shift and of a micro program
over the
Ridge for it to have all sorts of side
effect or effects on on the native side
so people have mentioned text input I
imagine like very small event handlers
that that to to to to implement some
kind of effect that is just for which
just incurring the cost of the bridge of
bridge traffic would be too expensive be
too slow I had the idea of exploring
maybe canvas type API where you can send
a small canvas like imperative drawing
program over to them to to the negative
side and then have that executed really
quickly rather than sending instruction
by instruction so these are all ideas to
recap this is about an ergonomic way to
do animated maths it's implemented as a
babel macro and a compiler that takes
tag template literals as input and
there's probably more to come thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>