<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Haskell at Inchora: Uses of Haskell and FP in Inchora Technology - London Functionals - March 18 | Coder Coacher - Coaching Coders</title><meta content="Haskell at Inchora: Uses of Haskell and FP in Inchora Technology - London Functionals - March 18 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Haskell at Inchora: Uses of Haskell and FP in Inchora Technology - London Functionals - March 18</b></h2><h5 class="post__date">2018-03-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/xqS22zrzYvM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well good evening guys sorry about my
disheveled ex appearance but I was a bit
of a rush to get here
my name is Bay tre I'm trimming Cora I
just thought I'd do a talk about just a
quick one about some of the uses of
Haskell in that in Cora we have some
fairly large projects that we use
functional programming for I thought I'd
talk particularly about just some of the
stuff that we've been doing with it
rather than going into any details of
any of the actual technical
implementations so to give you a quick
overview the in choral group comprises
of a number of companies that were
brought together under a common vision
and this required the centralization a
lot of a lot of the technologies that
came with them we're going to focus
primarily on in kora home technology
today just to kind of keep everything
nice and brief so in kora home we have a
system called Sulu which provides a
tenant notification service so that's
when people move in and out of
properties they're able to be we notify
all the council's and the water
companies and the electricity companies
that people are moving in and out of
properties so that makes sure that all
the billing and everything is closed
properly and you don't get a bill for
people who haven't been there and all
this sort of thing this is a service
that goes out to a few thousands letting
agents and they enter the information on
here and part of the service that we
offer is a concierge service for the
tenants that are moving into the
property and what that entails is we
sort out their media for them so that's
setting a broadband and TV and anything
like that we sort out energy switching
as well and then any insurance
requirements they have so off the back
of a website we have a call center where
we have to call centres and end-to-end
the whole thing is controlled by a set
of Haskell programs so the main site
itself is built using your soap we use
the persistent and the SQL sorry sweet
SQL Ito libraries in order to do our
data bindings and we have a number of
integrations with agency software again
we're using this ode for all the api's
in Haskell and they allow us to build
the stable API as we also use that for
our evolving api's which
when somebody just comes on board who
has specific a it was specific API
requirements we were able to rapidly
develop them an API there we also use
scripting for JavaScript because we have
a number of things that happen
throughout the ecosystem of the business
which is where where we need to be able
to very quickly change the way that the
system behaves which we can't really do
with you know Haskell's very good at
this sort of thing but we can't really
do it by deploying lots of things so we
have a scripting system built on top of
the Haskell infrastructure then behind
the scenes we have the call center
management so that's the campaign
management which is how we take a look
at when we get new information presented
to the system new people that have come
into properties or people leaving
properties how do we work out what we
can sell them how do we work out when we
can call them so on and so forth we're
not based in London we raised all over
the place actually our main our head
office is in Farnborough and with
offices in Grantham Norwich and Glasgow
rosco then we have the adaptive dialer
which is when you've got multiple call
centres with multiple products you need
to be able to say to people okay this is
the next person you need to call and you
need to have to do that as rapidly as
mean and as intelligently as you can so
in order to support this we have a
dialer system again built in Haskell
which interfaces with the aver phone
system which allows us to control the
call centres and we have to call centres
which are the Grantham and the Glasgow
offices so there's a kind of quick
summary
obviously there's quite a lot of stuff
there so our problem I'm only covering
we'll take a look at some of the
scripting because it's quite interesting
with one of the nice things about
Haskell is that we can automatically
generate all our bindings for all our
JavaScript on our server side and we
don't have to we can rely a lot on the
type safety I also take a look at some
of the campaign management because
that's one of the interesting things
that high school that's is quite
trivially build
so using Haskell and JavaScript we have
numerous api's because we've got
all these lacking agent some of them are
very large letting agents and very
complicated in their big operations some
of them are quite small and so we need
to be able to build api's so what we
often do is we have the stable api's
which are written in Haskell and then we
use scripting on top of the Haskell
system using JavaScript which allows us
to build simple api s-- and the this
allows us to make sure that our
JavaScript scripts which quite throwaway
and quite easy to make they are
essentially combining her school
functions behind the scenes so that
makes that makes it but that allows us
to build quite complicated things back
room to go to node.js and run the risk
of having inconsistencies between for
instance the persistent system that we
use in the Haskell code in order to
generate our data bindings and then the
equivalent in the node.js we're able to
just do all there's one all part of one
system which works out quite nicely
we have campaigns and key management all
sorts of things like commission schemes
and so forth and all of these change
quite a lot they change really rapidly
we can have a new product where we from
inception to during life is you know in
a matter of days it can be very very
quick and of course the contact center
strategies which is essentially taking a
look at maximizing the conversion of a
contact center so you need to think
about you know when we're calling
somebody how often we've called them and
all this sort of thing these strategies
can change quite quickly and if we
wanted to deploy a Haskell program and
these these are quite big programs if we
wanted to change them and deploy them
for every single time we would just be
continuously changing server code and
constantly trying to deploy things and
we would never we would always have this
huge backlog so the other problem is
that we ended up finding that we had a
higher barrier for entry which was the
Haskell code when you're dealing with
things that are quite simple is very
easy to understand it it's a very
natural way of expressing a function to
use functional programming and you know
we're all functional programmers I'm
assuming and so we know that that's
that's the case is very easy to express
them but for when you get into
non-trivial programs and quite large
programs
that barrier for entry does go up it can
take people a lot longer to understand
any complex system regardless of the
language it's written in whereas using
javascript anybody can use javascript
it's very simple it's very simple
language so allowed us it allowed us to
let people who weren't high school
developers develop custom functionality
for the platform so that in essence is
sort of why we started using javascript
with Haskell and one of the nice things
about Haskell is that we have this type
system we have all this type information
about everything that is available so
we're able to automatically generate
bindings into JavaScript in essence
every single entity that we have in our
data model barring some particulars
we're able to automatically generate all
the in all the if you want to say
JavaScript classes the for every single
one of them all the prototype functions
and because they are essentially just
hooking into JavaScript code then
through an FF I for a foreign function
interface
we're in short that you know they're
only calling Haskell functions so any of
the i/o that the scripts essentially
perform is actually just calling Haskell
functions and the system we use to
marshal data between JavaScript and the
Haskell side is the a-sun library which
takes which is a lovely library for
transforming JSON and you know that
makes sure that all the data that we're
transferring between the two is nice and
nice and reasonably reliable a
particular JavaScript library we use is
one that not on many people have heard
about it's called duck tape the lovely
thing about duct tape is it's a very
lightweight JavaScript engine so many of
you heard of SQLite yeah yeah
so SQLite compared to like Postgres yeah
duck tape is like that too v8 so it's
very very lightweight and one of the
nice things is that plays wonderfully
into Haskell's lightweight threading and
because Haskell being functional has a
very lightweight green thread system and
duct tape each time we create a heap
allocation it's a couple of kilobytes
one of the things we can do is we can
say well we can just create these new
contexts without worrying
now running out of memory or resource
usage and that plays and so we're
essentially able to spin up a Haskell
thread which is very lightweight create
a whole new context for that thread and
then have this great big pool of
critical threads and contexts that
receive messages run sorts of scripts
and if they fall over it doesn't really
matter and so at that place quite nicely
and so duct tape was quite a good choice
for that
however as things progresses they
naturally do things get more and more
complicated when you create a scripting
system I should have known this it gets
abused and then it ends up being used
for absolutely everything so shot myself
in the foot so now I've got to look at
track record
which is for those of you don't know the
Microsoft edge browser it's their new
JavaScript engine it's very nice it's
very nice it offers a very nice API the
the other option of course is v8 but so
anyway back to Haskell so there's an
example use is there too much but
essentially the automatic generation of
the binding allows us to take a Haskell
function just like this one so this is a
this is a function that takes the idea
of an agent and the idea of a product
category it runs in our SQL monad we're
able to automatically generate bindings
against that and we can generate the
bindings in two ways or both depending
on what we want we can either generate
it whereas it as an instance function in
which case we're able to call it on
every instance of every object or are
able to have it as a static in which
case all of the arguments are
immediately marshaled so essentially
what we have is a great big file that
has a load of template haskell in it
which generates all these things like
the ability like the instance methods
for common things like loading and
saving from the database and then we
have every time we have our set of
controllers like this sort of thing we
have exports of those and again it's a
template haskell function which
generates all the marshaling and
everything that we need and it quite
simply looks at things like if this is a
function of it letting agents well we
know it's a function overloading agents
because it takes a lighting agent as an
argument and so it automatically
creating
Stan's methods and things like that so
the next thing I wanted to talk about
was campaign management which is one of
the interesting things we ended up
having to introduced into the system
there's no more JavaScript now you'll be
glad to know because inin Cora home we
have multiple product journeys for all
the customers you know primarily this
would be media energy and insurance but
if you imagine there's actually quite a
lot of concurrent things going on within
that for instance if we sell you if we
sell you an energy product well a year
later they may have a new set of tariffs
open so we then need to sell you and you
know we need to talk to you again
because chances are you can be on a
better tariff and the same with things
like insurance as well and then you've
got so things like what about if we ring
you and we need to ring you again couple
of hours later or maybe the next day or
all the appointment management so
there's an awful lot that goes into a
call center and we need to be a little
bit intelligent about how we do this
sort of things so the campaign system
was built to allow us to be a little bit
more flexible rather than just getting a
piece of data and putting it in a call
flow and that's mountais we need it to
be a bit more selective about some of
the stuff that we did with them and we
also needed to be able to do this at
various points within the lifetime so
for instance when we first get the data
when somebody has actually been
contacted when somebody has been
contacted and that has resulted in a
particular outcome all those sort of
things so for instance if we bring you
and we leave a message and then you
don't answer maybe five times well it
doesn't make sense for us to keep
bringing you and it's also illegal so
what we do is we send you a text message
to say we're trying to ring you because
you wouldn't know otherwise and all of
this needs to be triggered and there
needs to be a number of decisions made
about how we do this sort of stuff it
also needs to be accessible to contact
center management cause unlike the
scripting system which you know changes
quite slowly and is only ever used in
sort of extreme circumstances apart from
when they use it for everything the
campaign system needs to change very
very rapidly and quite a lot of these
campaigns the managers need to be able
to take a look at this sort of strategy
that they're applying and
yeah refinement by scripting we'll just
ignore though for now though so to give
you an idea of what campaign looks like
this is a really really simple campaign
they're built using a diagram system
which is in the management web web
interface the managers can go in there
and they can drop these nodes which you
go to look at and you immediately know
what's going on here essentially we're
looking at has the person had an
insurance call and was the offset from
when they're added less than or equal to
seven that's seven down there not zero
so essentially what we're saying is were
they added less than seven less than
seven days or less and have they had an
insurance call so that little campaign
they can put together and they can
either leave back and have it for
instance filling up a doll queue and
then associate people with that doll
queue and so people will start calling
the data that comes through that or they
could plug it into a text message system
or they could export it because they
want to do something else with it the
campaign's themselves do get very very
complicated I tried to actually fit one
of them in the slides but it didn't fit
and unfortunately I didn't understand it
either so there we go but the campaign
system is really quite it's really quite
quite I don't say elegant cuz it sounds
very very arrogant but it's quite good
fun so essentially what it is is they
create these diagrams which we know is
just a it's just an AST so that they
don't make they don't need to know that
so they create these diagrams and
connect them together and we essentially
get the data structure on the left here
i've grossly simplified for the sake of
convenience but what we need to do is we
want to type that because we want to
make sure that everything's everything
sane so that people aren't doing things
like well you know was the added date
less than how many calls that whether
they've had a call or not and all that
sort of thing because we want to make
sure that the things that things that
rational so one of the nice things we
can do with her school is to take that
structure on the left and turn it into
what's called a GA DT and there's a
generic algebraic data type so you've
got a normal algebraic data type on the
left there and here you have a
generalized algebraic data type yeah and
the nice thing about our generalized
a ga da
that we can capture type variables
within the actual individual
constructors and those of you that know
Haskell will see the silly the error
that I've made here which and those that
you don't these A's should have been T
so if you can just pretend that that's
what I've done it'll be less
embarrassing for me so essentially we
can build these structures up and we can
build them with a very simple function
that takes these simple expressions on
the left hand side and the result of it
is either a type error or it's going to
be time to you over a not though and so
in essence we're able to take each and
every one of the LM and each and every
one of the constructors here and map it
over to a typed variant and some present
marvelous then we need to generate the
actual SQL and each of these diagrams
essentially just turns into SQL because
we need to be able to run it against the
database
denne against the database is quite easy
we take our type two expression as the
first argument of our compile function
and we turn it into an x SQL expression
now the S Polito system has this
wonderful way of having values wrapped
inside expressions which complicates the
type a little bit but essentially we
just have a read of Mon out here which
allows us to press some environment
around for the compiler and we take our
type two expression and if we were to
have for instance the lead added note
we're saying you know when was it added
all we do is get our environment and
inspect the lead added field you know
using essentially lens like format so
this allows us to build build up the SQL
expressions and I gave a quick example
here if we wanted to be able to go from
a boolean expression to a list of
entities we could say select from this
is SQL Ito syntax and just use our
compiled function here so we use this
all throughout the system to allow the
management to be able to go in and say
actually I want something more than just
you know simple dropdowns I want
complicated diagrams because they have
all sorts of interesting rules going on
and so that allows us to very quickly do
this and to make sure that even if they
put too
a diagram wrong we're not going to try
and run against the database and they're
not gonna get nasty 500 errors the user
interface itself does have their allows
them to build those diagrams does
actually have a little bit of a if you
like a type you're calling it a type
checker is really really too generous I
suppose but it does have a little
version that just gives them a little
bit visual feedback when things go wrong
fantastic did I keep it under just under
30 minutes thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>