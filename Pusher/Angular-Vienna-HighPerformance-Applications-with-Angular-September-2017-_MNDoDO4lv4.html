<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Angular Vienna, High-Performance Applications with Angular, September 2017 | Coder Coacher - Coaching Coders</title><meta content="Angular Vienna, High-Performance Applications with Angular, September 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Angular Vienna, High-Performance Applications with Angular, September 2017</b></h2><h5 class="post__date">2018-01-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_MNDoDO4lv4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the topic of my presentation is about
performance tuning with angular and let
me introduce myself I'm an forget I'm a
train and consultant and I'm focusing on
the topic angular I'm doing nothing but
angular since it bans PETA in December
2015 and I'm also a Google developer
expert which means that I am connected
to Google and the angular team and from
time to time
I'm writing my last book was also about
Angola by the way it's the book with the
most ugly cover animal but anyway I like
it so let's start with a little picture
who knows this most not most some of you
it's a free 86 who knows the Intel 386
ok about the half the hero of my
childhood it is a home computer and a
nice thing of this Intel computer is
there was this - about button perhaps
you remember it and when you push this
button then the computer is twice as
fast of course the real use case of its
- was to make the computer slower to be
more compatible with the formal version
of it with the 80 to 86 and now the
question arises if there is such a
turnkey solution for angular and as it
turns out yes there is such a turnkey
solution for angular there are some
quick wins you can use to get a better
performance for instance you can do
bundling you can also - minification and
you can enable the production mode in
this cases you get a much better
performance when you run your code and
the good things about this is that you
don't need to do anything when you are
using things like the CLI you just can
create a production build and those
things get baked into it but there are
some other things you can do too
to improve the performance of your
application and that's what I'm talking
about here that's what the contents of
this talk is about I will start with
fleas loading and reloading we'll also
talk about performance for data binding
with ambush I will talk about ahead of
time compilation as well as about tree
shaking and I will also talk about
caching with service workers in addition
to that I will talk about suicide
rendering but first things first let's
start with the first topic let's start
with lazy loading so a good friend of
mine told me that I'm very authentic
when I'm talking about lazy things I
have no idea what he meant but I think
it was some kind of compliments don't
know anyway
what you see here is the typically
structure of an angular application you
have something like a root module that
is bootstrapped you have several feature
models perhaps one for each use case and
you have one or several shared models
and normally everything is loaded on
startup of course that influences the
startup time in a bad way and this is
exactly where lazy loading comes in then
you are leveraging lazy loading you just
start with one or with several modules
and then one by one you are loading the
other models your needs when you need
the first module you load the first
model when you need the second one you
load the second one and so on and so
forth so what does it take to make use
of lazy loading you just need a routing
configuration for it
normally when it comes to routing you
have a mapping between paths and
components when it comes to lazy loading
you map your path to a module that
should be lazy loaded then you activate
the route in this case when we are
switching to the route flights Angola or
the angular router boots loads this
flight booking model here
for this you're losing load children and
load children gets a string with the
name of the model file and you a pants
the name of the motor class to this
model file name the name of the motor
class would be here flight booking model
so that's everything you need to do to
get lazy loading to improve your startup
performance now of course the question
arises which route is activated when we
are loading this model and the answer is
you're lazy loaded model has a routing
configuration of its own and they are
you could you could insert a default
route a route without a path or a route
with an empty path and then this route
would be activated after the lazy loaded
model is loaded into the memory of your
browser I think it's a good time to do
some live demonstration I have prepared
a simple example a simple example that
is about booking flights and there is
this menu item flight booking and this
menu item triggers lazy loading for this
I have just included this route you this
route into my application with the name
flight booking and as mentioned on the
slides it points to the model as well as
to the model class and in addition to
that there is another important thing
you have to get rid of every reference
to this model within your main model
let's have a look to this here we have
my main model my routes model and here I
have commanded out there reference to
the flight booking model that is vital
because as mentioned this would prevent
lazy loading the reason for it is is a
typically bundling solution would follow
this reference and would put this
reference and everything that could be
reached from this reference into the
main bar
and of course when everything ends up in
the main bundle lazy loading doesn't
make any sense so for this reason just
comment out any reference to the lazy
loaded models okay let's do some
Diagnostics you have a question deep
linking absolutely works so you can jump
to a supper out of your lazy loaded
model let's have a look to the network
tap let's trace the files that are
downloaded into the browser
I am reloading Hume my application a lot
of bundles are loaded bundles and other
files then let's clear this and let's
switch over to flight booking and now we
see that our own bundle for flight
booking is loaded this own bundle is
called after my model it is called
flight booking model chunk so I think
this shows that lazy loading really
takes happen here at raw back of this is
that the lazy loading procedure takes
some seconds during runtime when I'm
clicking here the first time at flight
booking we see this nifty loading
indicator ok I've stolen it from some
website but this also shows that the
user has to wait when he or she triggers
lazy loading this is the drawback of
this procedure and this is exactly where
pre loading comes into play pre loading
means that models that might be needed
later are loaded after the start of the
application and this in turns means that
when the model is needed actually it is
available immediately what does it take
to go be pre loading you just have to
define a pre loading strategy when
you set up your routing configuration
here I'm calling route 2 motor four
routes to set up the routing
configuration for the routes module and
as you might know this method takes a
second parameter object with further
parameters for their routing and sterte
parameter we have to go brief is the
parameter pre loading strategy here I'm
using the preload all moto strategy
which means that every model that could
be lazily loaded is loaded when the
application starts up so as a matter of
fact when we are using this first of all
the application stats they use a C step
location and after this after the
application can be seen by the user
after the application is interactive
angular starts to preload all the other
lazy models and because of this those
latency models get available quite soon
ok so much for lazy loading and
pre-loading let's talk about another
thing to speed up the performance of
your angular application let's talk
about the on Bush optimization technique
and for this I just want to start with a
little demonstration as mentioned my
application allows to book flights and
here I can search for flights for
instance for flights that go from
Hamburg to Graz which is the city I am
living in and then here we have a delay
button and we push this when we push
this delay button just the first flight
here is delayed so when you look at the
first flight we have something like 0 43
and when we push it again we have 0 58
and when we push it again we have 114
and so on and so forth perhaps you've
notified the animation I have put into
this application this isn't because I
want to show you how animations work but
this is because
I've tried to visualize that change
detection mechanism of angular every
time such a cart blinks Angola is
checking this cart for an change and
here we see even though just the first
flight is delayed Angola checks every
flights for an change and this can leads
to a bad performance when everything is
checked all the time
normally that isn't a matter at all
coz Angola is generating source code for
these checks and the source code can
handle some hundreds thousands of data
bindings but in some situation this is
just too slow especially in situation
where you are triggering change
detection on a regular basis for
instance when your mouse move event is
triggering a change detection event on
the regular basis then you are need then
you need something else something like
this on push change detection strategy
then it comes to on Bush you can lock
down specific components for instance
here I've locked down my card components
which means that Angola is keeping then
for change detection Angola will only
check them for changes then Angola is
not defied that there might be a change
and what's not the fight means I will
tell you in some slides first of all
let's talk about how to activate this
optimization technique for components
this is the most easiest part of this
you just have to set change detection do
the strategy on Bush when you're using
this then angular locks down the
component and then Angola is just
skipping this component for change
detection now of course the question
arises what do we need to do to notify
Angola about a change within this
lockdown components and there are two
answers for this
the first answer sounds easy at first
but it isn't the first answer says just
changed it bounced data just changed
data that is bounced to a property via
an input binding and the second answer
is notify a bound observable so let's
have a look at the first answer here in
this example I have in my parent
component an array of lights and of
course this array consists of several
flights and those flights are passed
down to their flight card components and
now to notify angola about the change we
have to change those flights but to gain
a good performance angola isn't checking
whether the first property of the flight
change the second property of the flight
changed the first property property of
the flight changed or the fiftieth
property of the flight changed angola is
just checking whether the whole flight
changed angola is checking the object
references here because of this angola
can quite easily find out where a change
occurred it just checks whether the
object references changed and this means
we aren't allowed just to modify a
property we have to exchange one object
for another one some people are calling
this immutable data structures when the
object itself can't change but the
object itself has to be exchanged by
another object here we have a
demonstration for the second answer F
gave you
we could also bind an observable within
the component in question with the async
pipe in this case the async pipe
subscribes for this observable and the
async pipes just triggers change
detection every time the observable is
coming up with a new value so let's look
at a demonstration for this
I have a tiny secret for you
I am not changing the objects here the
flight objects I am exchanging the whole
flight references
every time I'm pressing delay a new
flight is generated and you fly it with
the new date because of this I can
easily activate on Buechele let's do
this I'm switching to my flight card
component flight - card dots component
and here I'm activating that change
detection strategy on bush let's save it
let's wait for their compiler and for
the bundling okay and let's go back into
our application I am searching for
flights and then I'm delaying the first
flight and as we are seeing here just
the first card is checked for and change
because just the object reference of the
first flight has been changed by my
application of course we can have a look
their flight service flight dot service
would be the name of this
okay this is my delay function let's go
to sin mode and I'm doing this procedure
step by step it's a bit too long I think
you could save some lines of code here
but I really wanted to do this step by
step
to emphasize on what their idea is
behind exchanging the object reference
first of all I'm grabbing the current
flight's array I'm calling it all
flights then I'm grabbing the first
flight of this flight array I'm calling
it all flight and then I'm taking the
date of the old flight which is just the
ISO string and I'm passing this date
with the date constructor
I'm calling the result of this all state
then I am calculating the new date the
new date is the old date plus their
milliseconds for 15 minutes and then
then I would use default angular when I
would go with modifying properties I
would do something like this I would
just modify the date property of the old
flight but as mentioned before we aren't
allowed to do this because we have to
exchange the whole object reference
because of this M news I'm using this
nifty syntax Ian this nifty syndics that
comes with typescript I think 2.1 or 2.2
this is called a spread operator for
objects here I'm just creating a new
flight and this new flight gets all the
properties of the old flights all the
properties no not all the properties
because a little property in the north
of runs now because a little property
here is reluctant and has been exchanged
and this is the date so as you see using
immutables is a bit harder is a bit more
verbose than just modifying properties
but it isn't that difficult as you might
have
imagined of course I want to stick with
immutables because of this I'm not
modifying the existing array I'm just
exchanging the existing array and again
for this I'm using the spread of Parata
operator for arrays the new array
consists of the new flight as well as of
all the other unmodified flights of the
old array again I'm using the spread
operator here
it's the spread operator cause I'm
spreading all the items from the old
array into the new array not all the
items all the items beginning with the
index position one yeah and then I'm
writing new flights back to my flights
property because of this Angola just
needs to check whether the object
reference for the flight array has been
exchanged as well as whether the object
reference for the old flight for the
first flight this year has been
exchanged so this idea isn't that new to
be honest perhaps there are some rekt
guys beyond view to be honest we have
borrowed this idea from the area of
react there are quite similar concepts
that would be possible in this very case
that's a good point in this very case it
would be enough just to exchange the
object reference for this one flight but
when I'm doing immutables I like hits 2
to immutables
at least for the whole use case I don't
want to mix immutables with mutable
scuzz in this case I have to think too
much what Angola is doing during change
tracking and so on ok and as we've seen
here just a first cut here brings really
like this could do this all the day
okay yeah yeah for the next Tocqueville
consider this okay one important thing
is when you go with on Bush this isn't
an all-or-nothing strategy you can use
on Bush just for selected components you
don't have to use it for everything
as mentioned I don't mix it with in the
use case but as a matter of fact you can
just use it for a use case that needs
additional performance some people are
saying hey I want to use on Bush and
immutables and observables all the time
and in this case you should have a look
at a Redux pattern and at some Redux
implementation for instance on the
implementation and she rx store which is
a Redux implementation with angular in
minds it has been created of according
member of the angular team okay so much
for this let's go on with the next topic
the next topic is about ahead of time
compilation perhaps you know Angola is
compiling HTML templates in any way to
JavaScript the idea behind this is that
Java scripts can be faster evaluated
compared to HTML and for compiling this
stuff to JavaScript there are two
approaches the first approach is called
just-in-time in this case you are
compiling at runtime when the
application starts up of course this is
delaying your startup procedure and then
there is ahead of time compilation which
means that the HTML templates are
compiled to JavaScript during an
additional build step and there are some
advantages of course when it came to
when it comes to a OD the obvious
advantage of this is you get a better
start up performance of course you
needs to compile within the browser so
you'll get a better performance at
runtime but there are also two
additional none that obvious advantages
of ahead of time one of those is you get
smaller bundles co-ceo tones needs to
include the compiler into your bundles
in this case you don't need the compiler
within the browser
cause you are compiling without the
browser touring their other compilation
steps and the compiler is quite a big
thing the compiler has about the half of
the rest of the core framework
it has about 300k so you can just save
this 300k by doing a ot and there is
another advantage that isn't obvious at
first side tools can easier analyze the
whole code of course when the whole code
just consists of typescript or
JavaScript it can be analyzed in a
static way more easy and because of this
you can detect unnecessary code within
your bundles within your frameworks
within your packages and then you can
just remove this unneeded code from the
bundles I think every framework has some
lines of code some classes that aren't
used by your application and of course
those classes can then be removed you
also call this tree shaking you are
shaking a tree so that the unconnected
branches of this tree are falling down
when I talked about a OTE about a year
ago I had to talk about how to configure
your build tasks to do a OD that was a
tricky and ever today we can just use
the angular CLI the angular CLI comes
with a pre defined compilation step as
well as with a predefined compile and
build task and this task contains a OD
all you need to do is to create a
production build and beneath the covers
angular is using the AOD plugin nowadays
this will change they have not a plug-in
core but currently we are using the Ã¤Ã´t
plug-in and this IOT plug-in is part of
the NBN package ng Jewell's backpack and
as the name implies and she tools web
pack is just add on for backpack and
that's why you can use it with outs the
CLI do when you just have an vanilla
backpack built you can use it with your
backpack backpack build - so let's have
a demonstration for this I've compiled
my application twice when I've prepared
for this talk I've compiled it once
without a OD and once with a OD let's
start with not a OD built 50-buck built
life server entry file index.html and
here we go and now let's go into the
developer tools there is this nifty
performance stack and let's measure the
start performance of this application so
as you see this takes a moment no it's
it's just an ordinary application which
is built for debug purposes so it's
really a typical build and as we see
here this took about seven milliseconds
seven seconds seven thousand
milliseconds yeah
and when we look at this diagram we see
the browser is executing most of the
time this yellow task so what is this
yellow task about this yellow task is
about scripting we see here and when you
guess what this scripting is about what
would you say yeah it's about cheat its
about compiling here we see the compiler
in action here we see that the compiler
is just compiling down the HTML
templates to chava script on startup so
it is always a good idea to repeat such
measurement perhaps we get a slightly
better performance it won't beat that
further but it could be slightly better
the second time it's about seven seconds
seventh and something 7.5 or something
okay so much for the debug build let's
start with the brought action built
tough goes down let me double check here
this is the production build and here we
have the bird let's reload this
No and let's have a look at this and we
see we are ending up with four seconds
so let's repeat this
yeah now we are ending up with three 3.5
seconds so as you see we managed to to
save 50% of our startup time so I think
my application is fetching some metadata
from the web and as my internet
connection isn't the best here this also
takes some seconds when we look at the
network tab there should be a call to a
discovery document somewhere yeah here
they open ID configuration okay so much
for this so I think that shows that
everything of us should use ahead of
time compilation in production and that
also shows why cheats compilation is not
allowed at Google they have to go with a
OT there there was some Corrections on
there you don't have to do it on your
own they are using that back currently
and that works since that back since
version 2 is doing tree shaking and it
gets better and better if it but the
question is a good one because I have a
nice information for you when you are
interested into tree shaking when it
comes to tree shaking there are some
challenges and the biggest challenge is
that most reshaping tools are quite
conservative that means that they are
just removing codes when they are sure
for 100% cos they don't want to break
your application of course and the not
nice part is that very often they aren't
sure so that means that tree shaking is
nowadays not as good as it could be the
tree shaking tools have a hard time to
find out what really can be thrown out
of the bundle but there is a good
message for this the angular team worked
on something that is called too
Angola built optimism and this angle
appealed optimizer rewrites the compiled
code it turns out that it just needs
some tiny modifications with the
compiled code to make the code more tree
shakable to help those tree shaking
tools to find out which code is needed
and which code isn't and this is
currently in beta and experimental but I
hope that it will land in the CLI soon
when you look at the current beta
version of the CLI you can try it out
nowadays and I have played around with
this I did some experiments and I found
out that these results are possible when
you look at this slide I think you see
what's there potential of this build
optimizer of course the gains differ
from brought check to brought checked
from libraries to libraries from
packages you have downloaded to packages
but as a rule of thumb pukin can say
about a optimization of 50% is possible
I have found this number out with
several scenarios so as we see tree
shaking is a huge deal
we just needs to help the tree shaking
tools to find out what can be removed
more easy when you want to read more
about this when you want to find out why
those modifications help the tree
shaking tools just check out my blog I
have written two blog posts about this
the first one is how to use it and the
second one is about what it does beyond
stickers
okay so let's go to the next topic the
next topic is about caching with service
workers and first of all we have to talk
about what service workers are and the
answer is service workers are just
background tasks within your browser you
can compare them
to a linux demon or to a Windows service
but as mentioned it runs within your
browser and it is installed by an web
application and the browser can activate
and deactivate those background tasks
on-demand what has this to do with
performance well one exercise one task
they can do is caching and for this they
can do something that sounds quite
interesting
they can intercept every request of your
website and then after intercepting
those requests they can decide how to
respond to this request for instance
they can respond with the cache which
can be quite fast or they can respond by
using the network by going out to the
network and by fetching fresh data an
important thing about this is that there
is the same origin policy in place that
means that a service worker installs by
the domain a cannot intercept requests
for the domain B otherwise that would be
quite dangerous that would allow for
security attacks and because we can
write the service worker as a JavaScript
we can implement some interesting
caching patterns that haven't been
possible in the past caching patterns
like cash only which means the script
just takes the cache or network only
which means this grip just takes fresh
data from the network we can also
implement something like dry cache first
and when nothing is there used the
network as well as try Network first and
when the network isn't available or is
quite slow then take the cash and as
mentioned you can control this caching
balance cause the source code of this
service worker is up to you using
it's partly true
currently there are free browsers and
since some weeks we know that
serviceworker will land in h quite soon
and also so far results that they will
have serviceworkers they announced it
some weeks ago that was a really good
announcement for everyone who is using
serviceworkers or progressive web
applications progressive web
applications is this umbrella term and
serviceworker is the central point of
this progressive web apps that can be a
good idea and it could be another
caching padania you can also try to
raise conditions and take the results
that is the faster one and anyway when
it comes back from the network you can
cache it using service workers directly
is a bit difficult because there is this
low-level api for them that isn't much
of fun but fortunately there are some
high level api's abstracting service
workers and one of those high level API
is work box it's quite new it's directly
from Google or at least from some guys
who work at Google and it allows you to
write service work in a very easy way
here I have the source code for a simple
service worker that is doing caching the
service worker is importing work box
then I'm instantiating my Rock box
Service Worker and then I'm crapping do
caching strategies the network for
threats strategy and the cache first
strategy and then I'm setting up two
routes the first route is for angular at
E where my Web API runs
here I'm using Network first because I
want to have fresh data and I'm
accessing my Web API and the second
route is for their rest here I'm just
using the regular expression points
which means everything and here I'm
using the cache first strategy so that
means everything but my butt calls to my
Web API are processed with cash first
after this I just have to load this
serviceworker into my application and
then I get their performance their
performance gains of caching let's have
a demonstration for this first of all
let's have a look at this example here
that is not using service workers and
here I'm just simulating a slow Network
slow for eg and here I'm reloading this
and as we see free Qi or slow Fritsche
isn't a fast thing you need a bit of
patience when you are using a slow for
Ichi connection it took about three dot
sixty five seconds until that ohm
content loaded and overall time it took
was seven seconds so let's retry this
now it took a bit longer
so perhaps you can remember these
numbers or let's just do a screenshot so
this is screenshot for poor-man's and
let's switch to our serviceworker build
the application you started
let's reload the application and let's
have a look to our application tap here
and here we see that a service work is
running the service worker with the IDE
for for free free
okay so let's simulate a slow network
connection it's low for eg and let's
reload this
no it wasn't much fastest a true so that
somehow a pity because it should be
faster now as we are using service
workers
let's go offline it should also work
when we aren't connected to the web for
some reason it really takes also free
second as mentioned it it should be
faster now but I am offline now you are
seeing that I am indeed cashing that I'm
indeed using my cash let's try it again
with Cleo cash
okay for some reason it isn't becoming
faster but it should but a very nice
aspect of this is let's just quit our
server and when we reload our
application we see that everything still
works cause as mentioned we are using
our cache that is controlled by the
application okay interesting
so much for service workers so when I've
prepared for this there was really a
performance gain no idea by
there isn't a game now okay let's come
to a last topic let's talk about
server-side rendering perhaps you are
wondering why we need server-side
rendering because now we have
client-side frameworks we have angular
that runs within the browser so by 2 we
have to go back to the HS of PHP and so
on and to two server-side rendering well
it's all about pre-rendering the first
page of your application you want to
deliver it more fast to the user and
this is about startup performance the
use of things he sees it's all about
displaying the first page in a faster
way and this is especially important for
consumer apps course consumers and
patients when they have to wait a bit
longer they are moving to the next
competitor there are some nice
statistics for instance when you have a
delay at Amazon for just one I think one
or 100 milliseconds I think it was 100
milliseconds then the cross amount goes
down about 1 percent and 1 percent of
the gross amount of Amazon is a huge
thing I think so you see the first
impression startup performance or at
least their Percy
startup performance is important when it
comes to customer applications angola in
version 4 comes with a baked in support
for server-side rendering and for this
it comes up with this method here it is
called random module factory and random
module factory just gets the model
factory of your routes model the model
factory is what the AOD compiler
compiles out of your model file you are
writing and you have to pass the
contents of your index file the contents
of your index DB of your index.html not
index DB and of course you have to pass
in your URL and after this this method
is just starting up angular it is
rendering the page in question the
routing question and then you get back
the whole source codes the HTML code for
this pre-rendered page within this 10
function so this is leveraging promises
as you might have seen and now it's up
to you what to do with this string you
could save it into an HTML file or you
can just wrap a server process around it
and deliver it out to the user and when
you do the later one then you can of
course implement server-side rendering
with this strategy to speed up their
perceived startup performance of the
first page also for this I have prepared
and sample so let's switch to my sample
that is using server-side rendering
let's shorten the prompt let's go to the
distribution directory and here I have
just prepared a main server bundle which
has been compiled for server-side
rendering
I've also wrapped a server-side node
process around this which is calling the
method we've seen and now let's have a
look to localhost 80,000 oh 8,000 yeah
and perhaps you have seen for some
seconds we saw their bird server let's
test this with a slow network connection
for instance with slow for eg
it takes some time sometimes sometimes
some time we see the word server on the
left this is the result of the
server-side pre-rendering and after some
seconds after the Chava script code has
been downloaded executed and so on
Angola kicks in on the client-side so
what you've seen here is what
server-side rendering is about it is
just about bridging this gap between the
time when the page arrives in the
browser and the time when Angola kicks
in when the application gets interactive
and of course this is a positive thing
for the perceived performance of the
user I'm really emphasizing the word
perceived cuz the application isn't
getting interactive more quick it is
just there it is just displayed in a
more fast way is it's also important
with IOT both addresses different things
cause in both case when using a ot or
not you have to download of course the
JavaScript bundles you have to execute
the JavaScript bundles perhaps the
JavaScript bundles are fetching
additional data from the server angola
has to kick in angola has to do
client-side rendering so this is also
important when it comes to IOT for a
consumer application you would combine
of course both it would combine
server-side rendering with iot yeah with
lazy loading yeah it absolutely works
together
loaded nested paths in that way that's
true is it possible to do everything on
server said no this isn't a goal of this
implementation the the goal is just to
bridge the gap of course you can do some
things without JavaScript here for
instance navigating from menu item to
menu item would work without JavaScript
as everything is also server-side
rendered but things like working with
forms or other things working with
drop-down fields and so on isn't
supported when you don't have JavaScript
so the main goal of this is just
performance for consumer apps saying
this I wouldn't use server-side
rendering for business apps because it
is also bringing some additional
complexity into plate and because of
this I just would use server side
rendering when I really need it yeah
yeah yeah that's a good point when you
have a business application that is
publicly available and where you have
all these things like see Odin
server-side rendering is an important
thing when it comes to internet
applications behind the firewall stuff
then it just increases the complexity
yeah good point
thank you
you need some JavaScript back-end
process which calls note chess in DubLi
but there are also wrappers for instance
currently there is a wrapper for net who
is doing dotnet okay yeah yeah it is
using asp.net core and they are they are
using something that's called angular
services and what does angular services
- it is starting a JavaScript process
nodes process within asp.net to just
start angular yeah
it's that's a solution you can also go
with both with an asp.net back and/or a
topic and or a PHP backends and you can
use in addition to this and nodes back
and just for pre-rendering so no one
prevents you from just using two
backends okay so much for this
so there are also some challenges when
it comes to server-side rendering one
challenge is that you have other
conditions on server side where have you
seen it on server side there isn't a
document object model of course and for
this you have to take care a good but
good workaround for this is to use
separate services one for the server
side and one for the client side you can
also use the renderer which is a dome
abstraction with in Angola the renderer
does the right thing on both sides on
cayenne side and on server side on guy
inside it is leveraging the document
object model that home and on server
side it is just writing into a string
and you have to take care of effort but
vendor libraries cause those firt but
vendor libraries very often use the dome
directly or they are using jQuery which
in turn is using the dome directly that
won't necessarily work on server side
but I have a good message for you with
Angola 5 they are introducing a
server-side dome simulation and this is
simulating the dome at least badly on
server side so the hope here is to make
more firt butty
libraries available with server-side
rendering they can't of course simulate
everything but the hope is to make just
more possible on the server side ok so
much for this but was there a question
yeah template bindings works out of the
box yeah Dom manipulation Orban services
are accessing like say local storage or
the window object or the location object
and so on in this case it would be a
good idea to have two implementations of
your service one for the server side and
one for the giant set are there other
questions so far
okay when you are interested in to the
topic performance tuning then I have a
nice link for you I have made a block a
DP at medium a column at medium and this
column is pointing to several of my real
blog posts about performance tuning yeah
let's try this out don't here we have
some hyperlinks and perhaps when I say
hey I want to see how pre-rendering
works what I have to do what I have to
configure when I want to do server-side
rendering you'll find an article here as
a matter of fact most of these things
are quite easy but you have to configure
a whole bunch of aspects and you can
read about those things here within
those articles
so let's come to the conclusion as we've
seen there are some quick wins there are
some turnkey solutions for performance
tuning like bundling like minification
like the angle of production mode and
the good message is the angle of SIL is
doing for this then there is something
like lazy loading and pre loading which
allows you to improve the staudte
performance there is something like a ot
and tree-shaking which also allows you
to increase the starter performance and
in turn it is shrinking your bundles
there is something like caching the
service workers which should in theory
also haha in boost your data performance
there is something like on bush with
immutables and observables which boosts
your data binding performance it is just
necessary when you have to do change
tracking on a regular basis for instance
when you are triggering the change
detection procedure within a mousemove
event and for consumer apps I would
recommend server-side rendering so
that's all here you have my contact data
when you have further questions just
write me an email or just send via
message on Twitter and of course you
will find all my material between my
block in some minutes and then you can
try out the examples for instance also
the example with the serviceworker
it should as mentioned bring a better
performance
perhaps you try it out and you tell me
so thank you for this and have a nice
evening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>