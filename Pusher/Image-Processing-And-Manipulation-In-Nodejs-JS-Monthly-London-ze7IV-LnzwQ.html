<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Image Processing And Manipulation In Node.js - JS Monthly London | Coder Coacher - Coaching Coders</title><meta content="Image Processing And Manipulation In Node.js - JS Monthly London - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Pusher/">Pusher</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Image Processing And Manipulation In Node.js - JS Monthly London</b></h2><h5 class="post__date">2016-06-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ze7IV-LnzwQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is al and you almost got to
try the pronunciation just called me al
it's fine I'm going to talk today about
image processing in nodejs and I know
it's not a very natural subject for
JavaScript just in raise of hand anybody
has done here image processing in
JavaScript before cool what did you use
to do that well Watson I don't know what
some hints but alright yeah what did you
use okay yeah did anybody here use an
NPM module to do our image processing
yeah
image magic very very good all right
image magic cool cool
so I'm going to basically present here
my module but it's not just about self
advertisement I'm going to also show you
why I developed this module and why
image magic was not in good enough for
me basically so about two years ago I
switched from PC to Mac I bought my
first Mac which is this one here and I
was looking for a nice image viewer and
I didn't really want to pay for anything
you know it's not kind of the open
source thing you know to pay for stuff
and I couldn't find any good Mac program
to do image being so I thought it would
be a nice opportunity to develop on
myself and back then there was something
called node WebKit does anybody know
what it is all right so it's basically a
way to build desktop applications in
JavaScript and there is a similar
project today called electron so if
anybody has worked with the github ID
atom it's built on the same technology
basically so it's a way to build desktop
applications with JavaScript and that's
what I started to do I thought I'll
build an image viewer how hard can it be
you just need to read an image from the
filesystem and display it to the user so
that's what I did and it worked out fine
for dealing images basically you just
need to read the file and then render in
render it on some
a settlement right but the next step
would be to actually edit that image for
example resize or crop the image or
whatever and that's where I got a little
bit stuck so I used the developers best
friend Google so I asked Google how to
do image resize in ojs and the first
thing Google gave me is GM so the guys
here who used the image magic before
they probably know what it is and it's
basically an NPM module to do image
processing so let's do a small example
can you hear me without the microphone
by the way yeah
all right cool so I already know I don't
have internet here but I already
installed a GM before so I'm going to
show you what happens when I try to use
it so I fired up node can everybody see
the screen properly do you need it
bigger
no it seems to be fine right so let's
require GM and there we go we have an
NPM module here the way it works you
give it an image and I have an image at
the same folder I run this program for
and then you specify some operation for
example resize the image and then you
write the image to disk so let's call it
output dot JPEG and you give a callback
function to know if there was some error
and let's print there if if it's there
okay so could not execute a graphic
magic image magic whatever so Google
gave me a start but then I realized I
actually have to read the rid me of this
thing so I go - yeah that's we saw and
that's the readme and the first thing on
the readme is getting started and they
say I need to install image magic and
remember I was new to Mac meant them and
they said I need you something called
GRU or homebrew I have no idea what it
is right it was basically my first day
using a Mac so I said no no that's too
complicated let's go back to Google and
on the third result of Google Stack
Overflow to the rescue how to do image
resizing without image magic perfect
that's exactly what I need right so I
went there and back then the question
was empty there was no answer basically
so a guy asked the question and nobody
answered it so the question that you see
here is actually me that's my name and I
answered about one month after I saw the
question and that was the first version
of my module I thought it's impossible
that nobody has done anything like this
before
now just for the background my problem
with imagemagick was that you have to
install external dependencies on your
system before you can actually use the
module so it's not enough to un p.m.
install GM you actually have to make
sure that things are installed on your
system before you start using it so if
you use a Mac that's great you have
instructions on the roommate just do
brew install image metrics you're done
with what if you use Windows or Linux
god forbid so that's why I thought there
must be a better module and an easier
way to work so I went where all
developers go when they are seriously
stuck and that's the nodejs mailing list
and we started the discussion there what
to do in this situation where I don't
want to have any external dependencies
on my system and I just want a pure no
no js' module
do image processing and also they told
me there's nothing like that right now
so I saw the reason need an answered
question on Stack Overflow a discussion
of the nodejs
mailing list I figured it's a good
opportunity to start working before I
continue I want to show you an example
of how it works and then we can go a
little bit deeper into how I actually
build the module okay so the way it
works is now I don't have internet
working here so I can't show you the
actual installation process from NPM but
you have to trust me that all you have
to do is npm install LW IP that's the
name of the module and then it runs some
NPM commands compile some things and
you're good to go you don't have to
install anything else afterwards so the
way it works basically is you open an
image and in the callback you get an
error object and an image object so
let's put the image object as a global
variable all right
okay so we have an image object now
let's say we want to rotate that image
so we do image dot rotate and we want to
rotate it by thirty degrees and have a
yellow background while rotating it and
again you have a callback with an error
and an image and now we rotated the
image and we want to save it to disk so
let's do image dot write file and call
it output dot JPEG and we're done so
let's check it out
now we have output dot JPEG here I'll
open the original image it looks like
this
does anybody know that image by the way
all right so that's the standard image
processing image example that everybody
gives everywhere there is a story behind
that image which maybe I'll tell you
later in the bar but let's see the the
output first so that's the original
image and the output we expect it to be
rotated with a yellow background and
there we go
right so it works and we didn't need to
install any external dependencies to do
that we just need to do NPM install of
the module and we have an image
processor in nodejs now I'm going to
show you how it was built and some of
the challenges involved and if you have
questions just stop me and I will answer
as I talk right you don't have to wait
for the end to ask any questions any
questions so far
oh so an image I'm not going to go too
deeply into the theory of images right
just very simple stuff an image is
basically just a collection of pixels
and it's a huge array so a 10 megabyte
image a 10 megapixels image will have
roughly 30 million values because each
pixel is represented by three values red
green
blew right so those are just integers on
this but we don't deal with just images
as arrays we use image codecs and we
need them to store images efficiently on
disk or send them over the network
because if we had to actually send 30
megabytes of data it would be too much
so we use codecs to compress the images
in different ways and different codecs
work in different ways and codec exists
for about 30 years I think the gif codec
by the way I say gif some people say
jiff I don't know what you what you like
to say but the gif codec exists I think
from 1989 so a long time now and all
those codecs are written in C++ not in
JavaScript so that's how an image
probably looks like in memory if we can
actually see it just an array of pixels
and codecs take this image and do
something with it some codecs are
lossless like PNG for example they just
take the pixels and they compress it
just like zip is doing and PNG and zip
actually work with similar technologies
gif is also lossless but JPEG is a lossy
codec which means it loses some data in
favor of saving space so what's the
point of all this I want to show you
what it takes to develop an image
processor or at least software that can
handle images so we talked about codecs
and we talked about array of pixels in
memory and now we need to tie it all
together and even I haven't even told
you yet how it all relates to JavaScript
right so the general process is this you
take an encoded JPEG image you need to
decode it using the JPEG codec then you
have a big array of pixels in memory and
then you want to do some transformations
on this array for example you want to
rotate this array or resize it or blur
it or whatever so all of those are made
of transformations you do and then you
get any array of pixels and then if you
want to save that to disk you need to
use the codec again to encode this array
of pixels into an image the most popular
projects right now is a jpg PNG and gif
live so those are screenshots from the
webpages of those respective codecs and
as you can probably guess coding
developers are not really good web
developers otherwise those pages would
look much better than they are but they
are very good at writing C++ code and
they have been doing this for a long
time with that we set about 30 years now
my point is that those codecs are well
tested they are used everywhere in the
world almost every project that needs to
use gif images uses the official gif
codec and they are all written in C++
and that's a little bit of a problem
because writing an image processor in
JavaScript now you need to interface
with C++ code and you need to learn how
to do this that's not really trivial so
sure you can for example say I'm going
to write the entire JPEG codec in
JavaScript from scratch but that might
not be a very good idea and I know some
people are trying to do that but it's
really hard first of all because JPEG is
a very complex codec and because the
fact that JPEG exists for so many years
in the C++ versions mean that means that
it's already tested and people already
use it everywhere so why not reuse the
same thing so the next step of
developing my module was to understand
how to actually write native code to
interface with nodejs and that's the
main point of this module it's not like
the modules that use image magic which
basically tell you install this
executable in your system and then the
JavaScript code just spawns an external
process and uses image magic to do the
processing my module actually compiles
native code and interfaces with
JavaScript by exposing the native code
which is reeling in C++ as JavaScript
method
first we need to take all those native
codex JPEG gif png whatever in there C++
version and implement on top of that
ways to manipulate images like resize
the image of crop the image or whatever
we want to do all of this done in the
C++ side what we want to expose those
functions to JavaScript by raise of hand
did anybody hear about what v8 is the v8
engine oh so I need to really briefly
just explain its the JavaScript engine
behind nodejs right every line of
JavaScript that you write in node goes
to the v8 engine it interprets it and
runs the logic behind your program the
nice thing about the v8 engine and other
JavaScript engines as well is that they
give you a way to write native code and
expose it to the JavaScript developer
the thing is that since no js' first
released there were so many versions of
v8 and so many ways to interface with it
that it became really complicated now if
you want to expose native code to v8 you
need to make sure it's backwards
compatible with every version of nodejs
sense node zero point ten for example
which has been a few years now luckily
for us there is a really nice product
called native abstractions for now and
you can look it up it's on github and
it's a bunch of smart people which
basically wrote our C++ header files
which contain macros and functions and
templates and classes that encapsulate
the differences between the different
versions of v8 and allow us to write
native code for JavaScript for nodejs in
a very convenient way and let me show
you real quickly how we can develop one
of those native modules so let's say we
want to create a very simple native math
module and we want to use it like this
native math it's an object which
contains math methods methods for
example the sum method
and we're going to run it like this just
give it to numbers and it would return
the sum of those methods the point is
that we want to write C++ code to
actually do this and expose this
functionality to JavaScript so if we
were to write a C++ function to do this
well did anybody here write C++ code in
the past year for example all right cool
so it shouldn't be really complicated
it's basically very familiar syntax so
let's create a new file and call it
native math dot CPP
okay so we have we want to define a new
function call some let's call it some
native and it takes two arguments a and
B and it simply returns the sum of them
now if we were inside JavaScript ideally
we would want some way to interface with
this new function which we just wrote
and remember this is the C++ function so
it's compiled and run natively later by
our specific machine and we want some
way to access this function on
JavaScript so if we were writing
JavaScript code the next thing we would
do is to define a new javascript
function let's call it some Jas which
receives two arguments a and B and
returns uses the sum native function
that we wrote before as the result right
so this is ideally how we would write
this glue between C++ and JavaScript
unfortunately this would not work now as
a node.js module we will just do module
dot exports dot sum equals sum j s so
let's comment this out for now and just
to save some time I already wrote the
glue code for this so we don't have to
spend too much time writing it from
scratch and it looks like this so we
have the native sum and we have some
ways to build JavaScript functions from
within the C++ code and this is exactly
how we do this we don't have to take too
much time to read this but basically
what it means is that we create a
JavaScript function from the C++ code by
interfacing with the v8 engine so those
lines that you see here are basically
creating this new function and it's
equivalent to what you would write as
regular JavaScript code and if anybody
is interested I can show you in depth
later how it works exactly and those
lines over here are the part where we
export the module as a node.js module so
again I don't want to spend too much
time reading it but just to show you it
works let's compile this
so this went now through a compilation
step and the output of this compilation
step is that we have a build folder and
a release folder and inside here we have
a new file called native math dot node
which is basically just a static library
what window sorry dynamic library what
Windows users would call a DLL this is
basically it and this is the file which
we can require directly from nodejs so
let's try that so let's fire up node and
let's require this file so we have
native math module we take it from the
build release folder and it's called
native math dot node so here we are
requiring a natively compiled dynamic
library which we attach to the node
process and then we have the C++
function we wrote before exposed to the
JavaScript developer and indeed we have
native math it has a sum function and we
can use it just like any other
JavaScript function it gives us the
answer right the major difference here
is that this function actually doesn't
run through the JavaScript interpreter
through v8 but it runs through natively
compiled C++ code and there might be
some unexpected results for example if
it was a JavaScript function and I do
here 2.1 instead you would anticipate
that the return value would be 3.1 right
but c++ works with types and we did a
typecasting of the second argument to an
integer and indeed the result is free so
it's not actually run from the
JavaScript interpreter it's run from the
C++ side so that was a very short
example an exercise of how the module
actually works so in this short exercise
we saw how we can interface with C++
code and how we can expose those
dysfunctionality which we write in C++
to the JavaScript
developer and you might ask yourself why
is it even important so like we said
before writing image codecs like JPEG
and PNG in JavaScript is very
complicated so we want to reuse the
already written C++ libraries and also
the algorithm to manipulate images like
resize crop the images whatever we
already have very good success class
implementations I'm not saying it's
impossible to do it in JavaScript I'm
just saying it's already done in C++ and
written to C++ and it would take a long
time to actually do this in JavaScript
so that's basically what I did in my
module I wrote a native module for
node.js which takes those codecs which
we saw before uses them natively but
exposes their functionality to the
JavaScript user in a convenient API and
this is how it looks like we already did
this example before basically it takes
an image opens this image rotate it 45
degrees and then write it back to disk
and what's happening in the background
it's like a ping-pong between the nodejs
eye and the C++ side so when we do open
the image it goes back to the C++ side
reads the file from disk loads it into
memory decodes the pixel by using the
appropriate codec JPEG in that case and
then stores the pixels in a memory
buffer and brings it back into the
JavaScript side as an image object next
what we actually want to rotate the
image again goes back into the C++ I'll
accesses the memory buffer manipulates
the image in however way we want to
manipulate it and then brings this image
back to the JavaScript side and finally
when we're writing to this again same
thing just encode the image back the
pixels back into jpg format and write it
back to disk and that's a result right I
chose not to use Len adjust my skin in
this in this case but it works what I'm
hoping to do next with this module is it
seems like there is a lot of demand for
it you can check out the github repo
later and there
lots of demand for new features and
people submit poor quests and things
like that so first of all I'm hoping for
more people to participate and maybe try
to take part in it some of the things I
want to do is even explore the option to
implement some of the things in pure
JavaScript and not even do C++ code
anymore and make it even more
lightweight but you can check out the
github repo later and see what other are
the things people asked for that was the
presentation and I hope you enjoyed it
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>