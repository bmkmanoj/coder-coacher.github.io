<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Heresy! Combining Type Systems with PHP - Josh Watzman | Coder Coacher - Coaching Coders</title><meta content="Heresy! Combining Type Systems with PHP - Josh Watzman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Heresy! Combining Type Systems with PHP - Josh Watzman</b></h2><h5 class="post__date">2015-11-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uCCvsF0nMPo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the mic looking everyone can hear me it
sounds like it is um so yeah uh good I
guess good afternoon now um thanks
introduction my name is Josh watzmann I
work on the hhi vm and hack teams hack
is facebook's dialect of PHP notably
including a strong static type system
and that's what I'm here to talk about
today that the heresy of combining type
systems of PHP the sort of things we had
to do in order to make such a
combination hang together and the things
we had to do in the implementation in
order to do that at Facebook scale so
I'm going to be dividing this talk into
three major parts the first part is
going to be an introduction in tin to
hack and PHP for those of you that
aren't familiar with either or both of
the languages then I'm going to go
through a bunch of examples of idiomatic
PHP code and talk through some of the
things we had to do in order to
correctly type code that people were
already writing in PHP when we wanted to
convert it over to hack and then finally
I'm going to go into some details of the
actual implementation of the type
checker which is this separate o camel
system that we have that actually
enforces the type system in the hack
language so some background on hack as I
said earlier it's a dialect of PHP
developed at Facebook it is strongly
statically typed but it is also
gradually typed that means that there
are places where you're expected to
write type annotations such that the
type checker can enforce them statically
but if those annotations are missing
that's also legal and the type checker
will just assume that you know what
you're doing at those places and let
anything pass through this gives it full
interoperability and backwards
compatibility with PHP most of the
language looks a lot like PHP and so the
hack type checker just views PHP code as
completely untyped hatke and this makes
it hang together fairly well enough that
over the course of 2013 we actually
converted Facebook's tens of millions of
lines of code in its front end over from
PHP into hack and hack has been running
facebook com since the end of 2013 it's
been been in production for a long time
now it is unfortunately a terrible and
ungoogleable name for a programming
language I won't go into the history of
how we landed there it seemed like a
good idea
at the time the language has lots of
other cool things in it notably
including collections and async
functions and and on and on and on I'm
not going to touching on those things
today this is focusing on on the type
system you can go to hack lang org in
order to see the details of the language
the one time is the HH vm project which
has facebook's just-in-time compiler for
PHP and for hack that's available on
github here and the type checker for
hacking is part of this project so this
is all open source if you don't check it
out so look at a background on PHP for
those of you that aren't familiar it is
a very dynamic scripting language for
web development it has an
extraordinarily loose type system and I
can barely even say type system with a
straight face when talking about PHP um
it's all enforced dynamically in stone
couple of strange ways it has a bunch of
holes in it I'm not gonna go into the
details of all of that basically PHP is
a dynamic scripting language we're
adding static types onto it and I'll
call out specific gotchas in PHP um as
they become relevant in some of my
examples so here on the left this is
what some PHP code looks like the syntax
should be familiar with anybody that's
done any sort of C or alcohol derived
language it's all kind of the same PHP
files notably start with ? less than
question mark PHP to indicate as a PHP
file and then I have two functions
defined here an increment function that
does what you'd expect takes a value in
adds one to it and this function f which
calls increment with the value of 42
prints that out and so if I were to
invoke F here I would print 43 to the
console as you'd expect here's what the
corresponding hack converted code would
look like on the right it basically
looks the same again hack is a dialect
of PHP and the idea was to be able to
convert cleanly from PHP n to hack the
major changes or that we've changed the
opening tag to HH to tell the hack type
checker this is hack code we've added
integer type annotations on the
increment function the it's explicitly
annotated now to take and return in an
injury that's probably what you intended
anyways when you wrote this on the left
and we've just made that explicit and
then the function f it doesn't return a
value so in the sea parlance it returns
void and all the rest is the same
so a couple things to note about this
that there are immediately obvious the
first is that this local why in the
function f there's no type annotation
there there's no variable declaration
for that matter we do local inference in
order to know what the type of all of
your locals are I mean including
generics when they get there the
annotations are only required and in
fact only legal at function boundaries
function parameters function return
types and class members outfit numbers
the second thing is that the three
places that i have written annotations
here they're all optional this would
still be legal hack code on the right if
i omitted any or all of those and in
fact the only reason that I've written
them in here on the slide in the first
place is for illustration purposes and
so that the code on the left and the
right doesn't look identical but it's
legal to leave any of them out and the
type checker will just assume you know
what you're doing so PHP unfortunately
the images that show up 20 on the slide
here this is the famous iconic double
Claude hammer of PHP built by a guy
named ian baker off of a rant someone
else wrote called PHP a fractal of bad
design PHP gets a lot of flack it
deserves most of the flack but there are
also a lot of really good things about
the language that that I think and in
facebook thinks has served us really
well the first one is its request
isolation model when you start a request
or a script execution in PHP you have
nothing except the code that's executing
there's no global variables no global
state any of that must be explicitly
loaded from the file system or from the
database and at the end of the request
everything is thrown away in anything
that you save must be explicitly
persisted to the file system or to the
database to memcache whatever this means
you've got no pollution of global state
it's a really nice mental model in order
in and to work in when doing web
development the other very nice thing
that it has and the thing that was most
important for us to preserve in hack was
it's really fast iteration cycle PHP
doesn't have a compilation cycle it
doesn't have a type checking cycle when
you edit code you save it in your editor
you go over your browser and refresh and
the changes are visible immediately
there's no latency there and so when we
were adding a type system onto this it
was very important to us
to design the type system and design the
type checker such that we maintained
this really fast feedback loop and
that's sort of at the core of a lot of
the way we've designed a lot of these
things but but PHP is PHP it's a sort of
thing that inspires people to build
literal double Claude hammers um and so
type systems in PHP are kind of a heresy
leading leading to the the title of my
talk you know that the hard core PHP
folks are you know sort of view a strong
static principal type system as you know
what the heck are you doing you got
types in my PHP and the other hand
you've got you know the academics you
might be saying what the heck are you
doing you've got PHP in my nice pretty
types um which are both true um and so
the system is really fun to work with
but if it seems to hang together pretty
well and at least at Facebook and from
what I've talked to from folks outside
of Facebook people seem to like it but
it does mean that there's a sort of one
key overriding theme to this talk into
the language which is important enough
that I've made it obnoxious word art
animation out of that pragmatism um hack
is what you get when you try and
shoehorn a type system onto PHP it's
really good ideas from the literature
and from academia of how to do type
systems and how to hang these things
together but apply it in sometimes
unpleasant or unconventional ways in
order to make it work on a really
dynamic language and a less principled
language like PHP but it works it runs
Facebook's tens of millions of lines of
code in folks outside of Facebook other
companies are beginning to adopt it now
people seem to like it um so now for the
second part of the talk no review of the
hack type system in it and some examples
of idiomatic code so some things to keep
in mind i'm really good living on this
list the most important one and it's
kind of a weird one is that everything
is only one step away what this means is
that we aren't doing global type
inference on hack code that's what i
said earlier we require annotations at
function boundaries require in the sense
that if it's missing we just assume you
know what you're doing and don't try to
infer it it's allowed to be missing but
we won't try and infer it that means
that a function f calls function g in
order to type check function
we all need to look at the signature of
function G and not its body um this bah
gives a few interesting complications
later but has a bunch of nice properties
that sort of make this whole thing work
but it is also fairly pervasive through
the way that type system works so it's
important to keep in mind the next year
thing are the pragmatism that over lies
the language in in typing code that
already exists we wanted to convert
Facebook's PHP front end in to hack and
so we're converting code that already
exists and so we had the type code that
already exists and design type system
features for that so this means we have
lots of features to just let you write
idiomatic code and some interesting edge
cases that we inherit from PHP and the
way people write PHP code finally for
those of you that aren't familiar with
deep type systems don't worry there's
going to be no inference rules and no
proofs in this talk this is the only
greek letter that appears here it's just
as a joke um we we care like Facebook
and the hack team do care that there is
really solid theory underlying the
things that we're doing but we're trying
to build a practical system that we're
deploying to Facebook and so we don't
want to spend the the months or years
that would take in order to sit down and
then formally prove the system correct
that's not really what we're after here
so that's not what I'm talking about we
care about correctness and care about
fixing bugs they become apparent just
just not the huge formalisms that's not
the space for in nothing wrong with that
just just not what we're doing here so
again this part of the talk on looking
at the type system features by way of
examples of idiomatic code so the first
one is how we deal with scoping um PHP
doesn't have that variable declarations
and it's really nice if you want to know
what what things exist so here's an
example of some PHP code or sorry this
is some hack code but it's idiomatic PHP
you just poof the variable X into
existence by writing to it and so we
would like to know that X exists when
you return it and this example is really
simple whenever you use the X as an
lvalue you right to it and so we know X
now exists and we can track that minutes
of type integer variables are just
introduced by writing to them this is
really simple it gets slightly more
complicated whenever you have code like
this um notice X is not defined or
written to before the if block and so
we'd like to see that since X is defined
in both branches of the f we would like
to be able to use X when you fall out of
the f so we can say X is defined here in
the true branch it's also defined here
in the false branch we do what was on
the last slide in route to figure this
out and then whenever you come out of an
if-else conditional you can see
intersect all the variables that are
defined in both and so we know X exists
when you pop out again nothing
complicated here but it gets one step
more complicated wherever you have code
like this something that interrupts the
normal flow of execution a we call this
a terminal branch this else here it
throws an exception if you land in the
else you can never get down to this
return and so we need to know X is
defined here we need to have a notion of
terminalia T so that people can write
code like this it turns out this is a
fairly common pattern that we see at
Facebook so we need to understand this
that this is terminal and so we don't do
the intersection there just what's
defined in the true branch it is to find
after the conditional nothing terribly
complicated um but it gets a little more
interesting when you start doing these
conditionals where the type isn't the
same on both branches and you need to
start figuring out the crux of the issue
is what is the type of the variable when
you pop out of that conditional how do
you deal with type inference with
implicit subtyping which is what we have
here for those of you that are familiar
with with the literature on type systems
solving this in the general case with
global inference is actually undecidable
so how do we make it decidable what do
we do again here's an example of the
crux of the issue I have a conditional i
define X it's going to have type A i
define X here it's going to have type B
so so what's the type of X when you pop
out of here and in particular when I
return X is that legal to use X as a
thing and so to sort of get an idea of
why this gets undecidable pretty quickly
you know what is the right type for X or
ay and B sub class and super class in
one direction or the other is thing a
superclass of both where does thing fit
in do a and B implement some common
interface maybe thing is that interface
or some super interface of it maybe they
implement like 15 interfaces in common
so what do I pick for the type of X and
so the answer is we don't arm we
we say that X is unresolved of a and B
we delay the decision X is sort of that
the superposition of both a and B and so
um when we hit this return X that's when
we to continue the analogy collapse the
wave function when we resolve the
unresolved we can see that either a and
B both work for returning a thing or one
or both of them doesn't so we can delay
that decision until we hit the type
annotation of thing and the existence of
the thing type annotation is what makes
this tractable and in fact decidable if
that annotation is missing we just throw
our hands up and go you're missing
annotation you must know what you're
doing again everything is one step away
we're not doing global inference so we
don't have to solve the problem in the
general case we can just delay it like
this again for those of you that are
familiar with type systems and
programming languages this unresolved
might look sort of like a union type and
on this slide it's behaving largely like
one ah but it turns out that unresolved
doesn't quite behave like a union type
now and let's look at some examples of
that um so first we talk through this
code for those of you that aren't
familiar with PHP this is a function f
that returns a vector of mixed vector is
a is a hack collection like the c++
vector um and generics and hack work
much like they do in most languages so
this vector is allowed to contain
elements of type mixed mixed is the name
for the super type of everything in hack
so anything is a mixed this is a vector
of anything here I create a new vector
with this syntax on the first line and
then this V bracket bracket is a list
append in PHP and in hack and so I'm
appending the value one and then the
string high text to it sorry hi test um
so you can see sort of looking at this
code this should be legal this vector
I'm saying is allowed to contain
anything and in sand strings are both
anything um so how do we deal with this
um what's the type of the vector when we
first create it um how are we inferring
this generic and so we say this is a
vector of unresolved of empty list it's
some superposition of something that we
haven't decided yet and so when I stick
the integer n I say wells unresolved
events and then when I stick the string
in now it's unresolved of int string and
then when I return it I can see that
okay
turn mattress vector and then I can
check the unresolved against the mixed
and to check the unresolved you say int
and string both work for mixed
everything works for mixed and so you're
good so this looks a little less like a
union type this unresolved is allowed to
grow and grow and grow but here's one
more even more interesting example of
how this really doesn't look like an
unresolved anymore this is the same
example is on the last slide except
instead of returning the vector I'm
passing it into another function this
function m in technical terms i'm using
it in a contravariant instead of a
covariant position which is extremely
important because i can do the same sort
of inference here but I've got to be
very careful when I pass it into the
function m this vector of unresolved int
string says this only contains int and
strings but the vector of mixed the
dysfunction M takes it as a vector of
mixed and so it could put things into it
that aren't instant strings it could put
some boolean into it or whatever you
want and so whenever we use this
whenever it hits a type annotation
whether in a covariant and contravariant
position although it only really matters
in this example here in the function
parameter position whenever we hit that
we have to actually resolve and collapse
the unresolved so the type of the vector
actually changes as a result of this
function call we resolve the unresolved
we collapse the wave function to
whatever the annotation was in this
parameter it's now actually vector of
mixed the unresolved goes away we don't
know what happens to it anymore other
than what that put that typeset um as an
aside for those of you that are familiar
with with the way Hindley moon or type
inference works uh I'm alighting all of
the type variables here this is actually
like vector of alpha where alpha is
unresolved of empty list and so on and
so forth like the system does work as
you'd expect for Henley mon or type
inference it just isn't terribly
important for the purposes of this talk
so I'm alighting all the type variables
I'm so flow sensitivity um we just need
to understand idiomatic language
constructs one of the obvious ones um
the most important ones is no ability
thankfully when PHP had its bare bones
type system everything was not nullable
by default they had a very bizarre way
of making things nullable we made it
very nice by just saying int is not
nullable but ? int is nullable the ?
makes something a level and so this
function takes a nullable integer and
once we return an honorable integer it
wants to do it as you'd expect here by
checking for null if it is not null use
that value and if it is returned some
default and so the type checker needs
top needs to understand this in
particular it needs to know that X is no
longer a nullable aunt it's just an int
whenever you hit the true branch of this
if it needs to understand no checks like
this um not particularly complicated
just we had to go through a bunch of the
idiomatic code that people write to
understand core constructs like this
another one being instance of I won't
belabor this example but we do a similar
thing with instance of to know that this
on X is of type I but when you check
instance of see when you land in this
true branch it's now see and you're
allowed to call things that are on
ceunon I excuse me so this gets one step
more interesting and more complicated
whenever you hit member variables um so
here's a similar example to my 12 slides
ago with a nullable int it could instead
of being a parameter it's now it's now a
member variable um it's potentially
nullable and we want to return at a
fault value if it is null and just use
the value if it isn't and so you'd
expect this to work this is how you'd
write it in a pneumatic PHP and this is
a matter of fact it works in hack but
we've got to be a little bit careful
here this arrow X it isn't a local and
so we need to basically promote it into
local scope as far as the type checkers
internals are concerned such that we can
change its type and so this is what we
call fake locals so we promote this
arrow X as if it were kind of a local so
that we know that type has changed from
nullable to not nullable and then allow
people to use it but fake locals are not
quite like normal locals because they're
not local
so this is a type error in hack and the
only thing I've done is added a call to
the function foo here in the middle why
why is this an error why is this bad
this is why we could have another
function over here called gotcha that
resets this arrow ex back to know and
again since our type inference is purely
local we don't know what the heck foo is
going to do it might not have it might
have another reference to the current
object and call gotcha on it and reset
it back to null between the time you do
the test and do the usage so anytime you
make a function call we have to throw
away all the fake locals such that we
can get cases like this correct it's a
pretty pessimistic approach to it it's
kind of painful to get a lot of
questions about it but it's what we have
to do in order to ensure correctness
while still being able to type this
idiom at all so another thing we had to
deal with in this type system since
variables aren't declared since
variables can change types is how do you
deal with non local control flow with it
with exceptions in particular so let's
look at this example I have this
function that wants to return an integer
I eventually high ridge inul II have
this X which is a float then I
particular lines then I say that X is 42
now it's an integer then I frog blast
event core now X is still integer I
return it that's legal and and 0 is
clearly also an endurance of this code
works however this isn't a try-catch
block elminster reticulating splines or
frog lasting the vent core either of
those could throw an exception and land
me here and I have no idea when that can
happen and so if I do this if I return X
instead of the constant 0 I need to know
what the type of X is I could have
landed there from here or here like I
said a minute ago so what do we do what
what is the type of X here that this
should be an error and so how do we
track that and what we do is actually
for every local we're tracking two types
I've been showing you just one of them
which is what we call the current type
but it's actually a pair the current
type and the list of all types this has
ever been in the current scope and so
what this looks like is when you say x
equals three point one four we say x is
a float but the list of all types is
unresolved of
float it's another sort of super
position type and unresolved type then
when you make it an int we say it's
unresolved a float and int and so when I
go down here and return X the current
type of X is int and so this is legal
here but when you land in a catch block
since we don't know where you came from
we have to use the list of all types and
promote that into the list of current
type or into the current type for for
reasons that are lost to history we call
that integration that's the function in
the type checker to figure out the
source code and so X now its current
type becomes unresolved a float int and
float it is not compatible with intent
of this code gives an error as it should
one of my favorite bizarre things that
we do that it has to do with a similar
problem it is the loop fixed point here
is some pretty perverse code I it turns
out this is not just an academic example
this is distilled down from a bug we
actually had reported to us by a real
product code that we were mistyping it
because we weren't doing this properly
um the crux of the problem is that the
types of these variables like keep
changing each iteration around the loop
right there initially all integers but
every time you do one iteration of this
loop they might become a string and so
we have to do a similar trick we're
tracking unresolved types and keep
iterating the type checking of a loop on
until we hit a fixed point of what what
the types might be and so we know that
depending on how many times you go
around this loop which we don't know
statically um it could be either an int
or string and so we have to assume it
could be either one um in order to get
this right arm startup trying to thought
this is a really annoying performance
problem we've had to rewrite this code
several times you can imagine once these
get nested I think our original version
of this was like exponential time which
is what a naive implementation will be I
think we have it down to like cubic or
something I don't know it's still not
fast that's better than it used to be um
here's another look through this really
quickly another example of something
you'd like to work but but doesn't right
now two interfaces foo and bar on each
interface respectively this comes in is
one interface
and so I'd like to be able to call foo
regardless of what happened in the
middle but because of the way we
implement that the type changing here I
won't go through the whole reason for
this uh making this work properly this
end up being on result type um
unfortunately if you talk to me offline
I can go through the full example uh the
gist of it is we would like this to work
we need something called intersection
types in order to track that it that
it's both things we could in principle
add them but they distribute over
unresolved types and so when we try to
implement it it got way too slow there
are various clever things I think we
could do in order to make this example
not be so painful and we just haven't
gotten around to it yet um but it's the
sort of thing it's like we would like
this to work but we can't it's too slow
we need this to work at Facebook scale
and what are the annoying compromises we
had to make
too slow
the type checking is too slow I'm I'm
happy to address questions on at the end
and I can go into more detail that if
you like ok so now moving in to the the
final part of the talk which is on the
the implementation of the o camel binary
that actually enforces this type system
when we do type checking I'm believe
implemented it is in five phases the
details of the exact what's going on
here isn't super important um I just
want to run through it briefly um we
parts everything into an AST then we
build something called the global
environment which is basically a set of
all of the functions and classes that
are defined we need that in order to do
what we call naming which is resolving
all the names that exist on generally
dealing with scope and massaging the AST
into something nicer then one of the
most important phases or declaration and
typing declaration goes through all of
the the named bodies of the functions
and extracts out with the signatures of
the classes and the methods that are
defined so we know there's a function f
that takes an integer and returns a
boolean then typing uses those
signatures in order to actually do the
type checking of the bodies of
everything um so I've blown through this
quickly enough that it probably isn't
necessarily obviously think about this
um this has been carefully constructed
so that it's trivially parallelizable in
particular declaration and typing is
where you can see this in order to type
check the body of something you only
need the declarations at everything else
you don't care what else is being typed
right now we've extracted the
information we need during declaration
everything's only one step away you only
the signatures were not doing global
inference and well that means we can
multiply that computers have lots of
CPUs code has lots of functions wouldn't
it be nice if we could just dole it out
when it turns out we can structure the
system such that you can do this the
annotations of the function boundaries
are what make this tractable the arm
phases themselves basically or just
synchronization points in in the
parallelism where we farm out a bunch of
things the computations are done and
bring it back together now you form out
a bunch of things using that data
um each phase only depends on data from
the previous phases which makes this
actually really nice now the type
checker is implemented or no camel
people that have used Oh camel arm
threading and o camel gets kind of
exciting my personal opinion the opinion
of the team at the time I think the
opinion of most Oklahoma programmers
okay mo has a thread abstraction and
it's completely useless I shouldn't say
completely useless it's not at all
useful for what we want to do here I
believe it is concurrent but not
parallel or like ones and all sorts of
issues with the garbage collector when
you try and make it parallel um it
wasn't suitable for what we're doing um
I hear there's work on this hopefully it
will be in the future but at the time
that wasn't so if you can't use threads
in order to multithread um what do you
do so what we ended up doing so the next
obvious thing is using fork use multiple
processes now you have no shared
anything anymore which is actually kind
of a nice monitor program in nothing's
shared uh but now you like do need to
share data like these a STS we're
building up how do you share data the
obvious answer and what we originally
did was using IPC we used like I think
UNIX domain sockets something like that
you serialize a bunch of data shove it
over and deserialize it on the other end
um we did this for a while it does work
excuse me but it turns out that you end
up duplicating a whole lot of data
there's a lot of complication because
now you have the processes aren't
homogeneous you need to have some that
are like holding on to the data that you
communicate back and forth to um it's
kind of a pain both conceptual
implementation was so if you don't do
that then what do you do and this is
sort of a weird answer or our tech lead
ended up thinking of this there are a
pair of flags you can pass to the unix
in map system call map shared map and on
what that does is say this region of
memory give me this region of memory and
when I fork map the same physical frames
into my address face each time
effectively it says this region right
here is shared between the forks um just
like you'd have just like everything is
shared in threads there are various
other ways of doing this
we use a map so that means you can map
this region you can fork all of your
workers and now they have this shared
space to play around with their o camel
garbage collected heap is still separate
because we forked everything it's just
this one region that we can manage with
some special code some special c code
linked into the binary that makes this
work so so what is in this region is a
shared luckless hash table it's shared
among all the processes by the way I'm
going to start using processing thread
interchangeably at this point you
understand what i mean it is thankfully
immutable data it is these a STS and
other computations that we've done but
it's still a luckless data structure
with a wad of very exciting C code
managing it um which leads to things
like this you can't see segmentation
fault core dumped here on my slide um
but that's what it says so like for
people that have done lock lifts data
structures they are very exciting and
very fun to implement and have all sorts
of bizarre concurrency bugs so how do we
manage this um it turns out that this is
tractable for us uh because there are a
bunch of nice and variants that we can
have over this shared luckless hash
table because of the way we're using
this data and what we're doing I'm gonna
go through some of the invariance and
it's worth keeping in mind that they're
sort of obviously useful for for hack
and for this type checker but they also
turned out to be just as useful for for
flow which is our type system for
javascript that we open sourced about a
year ago it's actually built on the same
o camel base same code these are
surprisingly widely applicable so the
first one and probably the most useful
is that one thread and one thread only
will ever be touching the hash table
when you're doing a delete you don't
have to worry about concurrent reads and
writes with deletes um because the
deletes only happened whenever you're in
criminally updating state and you can
sort of synchronize everything and say
like I am invalidating this part of the
hash table I'll talk more about
incremental note later this gets rid of
like the nastiest class of lock lyst
data structure problems people that have
studied them at all um it's always like
concurrent inserts and reads aren't easy
but they're fairly tractable they're not
conceptually
art and like you know whenever a
professor gives a lecture on this he'll
spend five minutes talking about uh this
and then he or she will spend like the
next 45 or 50 minutes talking about how
to do deletes and so we got to just
throw the whole problem out the window
which made us very happy the next thing
that we have the next two invariance
come down to basically whenever you're
reading and writing data at the same
 and hash table even if two threads
have computed it it is equivalent data
and so it doesn't matter who wins the
race to write it and read it and
furthermore if someone's writing well
someone else's reading as long as they
either get all the data or none of data
it doesn't matter when they see it
because if they don't see it they can
just go off and recompute an equivalent
version of it it becomes a performance
problem but not a correctness one and
and so um if you're inserting and
reading we don't really care when the
read becomes visible to an insert from
another thread now if you've really been
paying attention you might be asking me
right now but wait I said that the
phases only need data from the previous
phase when am I ever reading and writing
to the same slot in the hash table and
it turns out what I said about the
phases isn't quite true in one place
that turns out to be actually really
important and make this come up when it
comes down to declaration and
inheritance hierarchy is for performance
reasons um whenever we want to do a
declaration of a class we'd in line the
declarations of all of its recursive
super classes into it whenever I call
the class Foo function f when I want to
look up the signature of F I don't want
to have to traverse up all the entire
inheritance hierarchy of F particularly
since HP has something it's not quite
multiple inheritance that we model it
that way in the type checker called
traits you can go up pretty far on
without that deep of inheritance
hierarchies before you might find it so
we need to inline all of this this means
that when we're declaring you know cat
we need to declare male first and to
declare mammal we need to declare animal
first so you can inline these all the
way down and so you can get these
problems in the type checker if one
thread is told to declare cat one thread
told to the clear dog cat might see male
doesn't exist that might say that animal
doesn't exist and dog
somewhere in the middle of doing all of
this maybe you know the cat threat is
finished doing mammal by the time dog is
trying to see if mammal is there and so
you run into this these contention over
the same slot but thankfully like I said
there's equivalent data so maybe cat
will or Walt have written the data from
mammal by the time dog tries to see it
and so it doesn't matter dog may have to
go off and recompute it that would be
too bad but it's a performance problem
not a correctness one similar things can
cause concurrent inserts but again this
one isn't too bad its equivalent data
one of them wins the other gets dropped
on the floor oh well to that the one in
variant that we do need and that we
didn't know for about nine months after
we implemented this and that led to some
really fun bug bug hunting is this one
that within a single thread once you
write data into the hash table that
thread does need to be able to read
either that data or some equivalent data
back it's not permissible for a right to
not be visible to the same thread and if
you go back to thinking on how we're
doing the in letting this does make
sense if I'm trying to do cat and then I
do mammal when I come back to finish cat
after having finished mammal I expect
the data from mammal to be there but we
didn't realize this from up nine months
which led to basically a bunch of
methods that were supposed to be in
super classes just not being available
in subclasses very rarely very randomly
the race window for this was fairly
small so it was a pain in the butt to
track down eventually we did squash this
one all it was the last major
concurrency beaucoup we had my favorite
my favorite part of this anecdote is
that the way we solved it involved an
unfortunate busy loop there's probably a
smarter way but the busy loop worked but
we needed to explain to the compiler
that we're waiting on memory here um and
so there's an as ambala tile in the
middle of our nice pretty o camel type
checker that makes the whole thing hang
together so I've been looting to this
thing called incremental mode once we
have this type checker it's nice and
parallel but Facebook has tens of
millions of lines of code it takes about
two minutes for us to type check all of
that code and that's not too bad for the
size of the codebase people that do c++
that's like really great the thick our
compiler for this code doesn't even link
in two minutes um and so like you think
two minutes is great but it really it's
a no-go for the engineers that we had at
Facebook working on the front end
they're used to the fast iteration cycle
that that they were they were used to
with PHP where you can save code and
immediately see its results a two-minute
latency in there would mean that they
would basically be relegated to like an
offline lint job or something which is
not we wanted you you want the immediate
feedback of a type system on when you're
like working in Haskell or something
like that immediate feedback is great
that you see like you did something
wrong like very immediately and so
became a fan T of incremental mode the
realization is that we have tens and
millions of lines of code but when
you're changing something you're
probably changing about five of them and
so we can have a server sitting in the
background that has most of its state
that's using the linux kernel's inotify
subsystem to figure out when files are
changing and can just update it stick
from there and that the recomputation is
very small so we have to know somehow a
dependency graph that shows up really
nicely a dependency graph such that you
know when file a changes what do you
recompute the way build this up is
actually really simple we just know that
when every type checking function f
function f calls function g you have to
load the declaration for g and so the
process of the limit declaration adds an
entry into our dependency table that
says f depends on gene then whenever the
file containing g changes we know
everything that's in a file we can look
up all those functions get the reverse
dependencies and go and recheck all of
the reverse dependencies and again
everything is only one step away so if f
calls g we need an ng changes we need to
recheck f but we do not need to do it
recursively we don't need to recheck
anything that the calls F because the
signature of f hasn't changed um if f
itself hasn't changed um in this makes
the whole thing tractable at this point
you know the hard part is related toning
what changed that's just a whole bunch
of thinking very carefully about the
problem most of it actually isn't that
hard the hard part has to
you with again the way we in line
subclasses and declaration there's a
couple of gotchas they're the most part
this is surprisingly straightforward so
that's all I have prepared um the
conclusion is basically pragmatism
pragmatism pragmatism teksystems PHP an
interesting intersection here some weird
features in our language and a fun
implementation I'm happy to take
questions now I believe we have a few
minutes okay um did you would asked
about yeah sure
um so the questions about polymorphism
in particular typing the identity
function um I d of x equals x as an
example yes so um we're not doing any
sort of polymorphic sorry that's not
quite true we mostly don't do any sort
of polymorphic inference right if you
write the identity function then you
have to write its signature um in order
for us to know how to type it if you
don't add type annotations then we just
throw our hands up and go I assume you
know what you're doing anything is going
to work you can write a type signature
for the identity function using generics
it's just i D of T you know where where
X is a tee and your eternity um and so
we're able to properly use the generic
once you've written it down but we're
not trying to infer it i'm at function
boundaries like that there is a syntax
running generics and defining inner
engineering classes yes that they are
available in language and fairly
powerful the question is did we
encounter generics and a lot of actual
code um yes and no there's a lot of
generic usage at Facebook um but it's
unclear how much it actually should be
generic as opposed to some other
language feature um vivi so yes there
are a lot of things that should be
generic um what lots of like helper
functions like that to come up a lot a
really good example of something that is
generic but it's not clear if it needs
to be we have a generic object
superclass that knows how to like load
things when database and for bizarre
historical reasons that I will not go
into the type of the identifiers that
you use in order to load an object can
be one of several different types you
might think it's supposed to be an
integer primary key that's what it
usually is but it can be other things
and so the obvious way of doing this is
that the superclass is parameterized its
generic parameterised over the type of
the key um but the thing is the way that
the type of the key um is defined
uniquely by the type of the object that
you're loading so for example status
updates are always loaded by an integer
ID and photos um historically just as an
example we're always loaded by string
key and so it's not really generic in
the norm
sense since we have a lot of these that
are like this where generic suppose we
parameterize such that the caller sort
of determines this is a vector of enter
a vector of string based on how you use
it but that's not the case here the
subclass uniquely determines which one
it is so we have a lot of generics that
are like this I'll make it's very
unwieldy very quickly because anything
that uses that class has to be
parameterize more and more and more
again if it wants to be generic and so
the feature that we added it's been in
the language for a little while we
haven't really talked about it much just
because we haven't like written up the
docs for it I'm something we call type
constants um which is stolen from a
feature in Scala who which might be
called type constants as well I see you
nodding I don't be the name of it one of
our other engineers like designed to
flush out this whole thing um the gist
of it being that it's sort of like a
generic and that it's a type parameter
in the superclass but it's not a generic
the subclass fills in the whole of that
type parameter and so a lot of code this
currently generic is being moved over to
these type constants to reduce the
unwillingness because that's really what
they want it anyways is opposed to
generics so very long would an answer to
your question simple answer is yes and
no I think I've so got a couple of
minutes and your heads into questions
okay so your question yes yes at a very
high level flow is similar concept for
JavaScript um they are trying to do more
in the total inference space than we are
I believe flow is not only strictly
local no don't quote me on that I have
helped some of the implementation bits
was that it's not yes they are not doing
they're actually not even doing Hindley
modern inference they're doing something
a little bit different I am not
qualified to speak on it a veek is the
guy you can like google there he's done
talks about how how flow does this
some of the codebase Bashar yes there is
shared code between the two projects
it's mostly the infrastructure stuff
that I was talking about in the last
part of the talk how we we share data in
the phases and do parallelization um it
is actually the same code underlying out
okay i'll be around throughout the
conference if anybody has any other
questions or its to chat i'm happy to do
so please grab me thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>