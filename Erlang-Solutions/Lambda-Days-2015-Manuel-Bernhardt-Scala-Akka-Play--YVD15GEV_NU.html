<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2015 - Manuel Bernhardt - Scala, Akka, Play (...) | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2015 - Manuel Bernhardt - Scala, Akka, Play (...) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2015 - Manuel Bernhardt - Scala, Akka, Play (...)</b></h2><h5 class="post__date">2015-04-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YVD15GEV_NU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you all for coming so what I would
like to talk about today is rather
introductory so I want to talk about
reactive web applications on the JVM so
i will also talk about skala I can't
play but that's going to be the second
part of this talk so I read somewhere
that a good presentation should have an
agenda so here is the agenda for today
first I'm going to talk about the why
and second I'm going to talk about the
how a few words about myself I'm a
freelance software consultant i live in
vienna in austria here you can see me
scuba diving in the Danube ah that would
be great no we don't have Turtles there
and I'm like organized also the Vienna
skala user group and for most of my
career has been doing web stuff so web
applications from the backend servers to
front end and for the five past years
have been working with tea with scala
akka and play and so shameless plug here
is i'm writing a book on reactive web
applications it's supposed I try to make
it a pragmatic book so if you don't know
much about reactive things it's trying
to give you all of the tools that you
need in order to write these kind of
applications so the Y first part it's
actually the wise it's not not just one
reason here so the first reason is it's
2015 so what did we expect to happen in
2015 anyone knows this flying cars and
you know that you know return to the
shooter is the future is I already in
our past it was a 16th of februari or
something so and we haven't gotten the
flying cars i mean i'm personally rather
disappointed what we got instead are as
many core cpus so this one here has 72
cores it's not anymore multi-core even
its many cords like many many cores and
what's interesting in the space is that
there are many small players there are
many different hardware players that are
building these things so for example
example the
adaptive a perilla is a board you can
buy for ninety nine dollars you get a
board with 12 cores on it and so what
hardware people told us a few years back
when they said sorry guys we can't cram
more chips did we have to go we can't
give you more gigahertz we have to go in
and have more course that's actually
really happening so this is a bit of a
you know when we predict what's going to
happen with our hardware resources you
may remember or know that Bill Gates
said that 640 kilobytes of memory that's
dad it's enough right I mean he was a
little of what's the ironies and Leah
struggles of all people a few week
December think last year he said that
end users are fine with roughly on the
order of four cores I don't know I think
we'll find a way to sort of use these
for tours and and complainant and end up
with 32 128 cores and uno thousands of
course in a matter of a few years and
users yeah end users and so that's
coming um many cores are there also
what's there is we don't write
applications anymore seldomly have
applications that only run on one
machine so we distribute everything is
in the cloud if you look at what many
many applications are built is that they
will rely on services they will
outsource their concerns to specialized
services such as you know s3 for storage
images there is cloudy nary different
services for emails etc etcetera you
don't build all of these things on your
own what to do is you use something that
someone else did and spends their time
on specializing so you connect and the
way we do this is by using the cloud so
I will see
so that was supposed to be a movie here
but nevermind and yeah so nobody
understands the cloud it's and so what's
the cloud I mean this is not the cloud
definitely not this is an IBM z13
mainframe with 10 terabytes of memory
and 141 pours at five gigahertz which is
great if you can afford it but few
people afford it who afford it it's
mostly people that have a legacy system
banks insurance companies and who cannot
are very afraid of porting their legacy
system to anything new so they get these
things but that's not how we build
applications how we build applications
now is more like this it's like we have
the servers and racks and we connect
them with you know cables that's what
and then we scale out when we have more
load and we scale back in you know and
we have many notes so if one failed it
doesn't matter because we we fell over
right that's how we would like to think
that it is but in fact it's more like
this it's yeah it's a big mess it's a
that's the cloud it's a network so um I
have a background in telecommunications
I can tell you that behind the scenes
people are busy trying to fix things all
day long and it somehow it works it's
amazing and networks are hard they fail
all the time there is this blog series
called the Jackson series on a fear com
if you have a chance to check it out
it's a kind of describes what happens to
many different technologies when the
network fails and how they just don't
work anyway so um you may have heard of
the H fallacies of distributed computing
you know what we think how it works that
the network is reliable there is no
latency etc etc all of these things that
you slowly discover when you build an
online system that's just not true and
then we have the cap theorem which
stands for crumbs which says that you
cannot both have consistency and
availability under network partition
that mostly affair that also mostly
affects database systems because you
have to make a choice do I let my people
we were let my users right and then at
the end when the network comes back
together I have a merge problem or do we
just say sorry you can't use the system
but in my users aren't really happy and
this is really a hard problem to solve
many very smart people spend a lot of
time on this that we have taxes which is
a series of or family of protocols for
getting to a consensus when we have a
network that may be a bit unreliable we
have secure S stands for command and
query responsibility segregation which
is a way to actually scale out and deal
or it makes it possible to actually
scale out and deal with massive writes
and reads and and then we have cool data
structures the crd tease that that sort
of make it possible to merge back after
you had a a partition so these things
are there they and we start to use and
to see them actually in technology
that's available online really
complicated things but so there is hope
however who is watching Game of Thrones
here no yes yes so you may have you know
winter is coming so that's that's winter
here this is this part here is winter
that's according to Gardner we will end
up with 26 billion connected devices in
2020 that's in five years and someone
will have to deal with these things
someone being on the server side if you
siemens just launched a dishwasher that
you can access with your phone I don't
know why you would need it but it's
there it exists we will have fridge that
will talk to your microwave or you know
tell you when to buy what and all of
this data this is going to generate a
lot of traffic of course but also a very
large amount of data so there is a ninja
line is doing a talk about the data in
the other room so what spark which is a
technology for dealing with vast amounts
of data
it's you know this is something that I
think is going to be really big and
interesting and on a side note here this
is my router at home and this is an
actually host name it's a question mark
and then there is another device here I
have no idea what it is so these things
they come online all the time I want to
go offline they come back I don't know
where they are in my flat so my
prediction you can quote me on this is
that by 2020 everyone will have a bunch
of lost things in their flood that are
online and nobody will know what they
are that's one of the side effect of the
Internet of Things I think it's
frustrating to have things in your
network and you don't know where they
are leave me so before 4th why now is um
is that actually if we if we take all of
this into consideration we have a
problem and the problem is that we have
tools programming tools and techniques
that aren't really fit for for working
and the setting with many chords and the
distributed setting that's from Apollo
13 and actually they had to fix this had
to fix this in order to get to breathe
again so what happened is we have been
rain washed to use imperative
programming with mutable state global
mutable state and to use locks so the
problem with mutable state here is an
example my drawing skills as you can see
our yeah so so so we're the car it
starts at position 0 and then we mutate
this position we have it moved to 10
that's easy right that's okay now things
are getting a little more complicated
because we have two threads that run
apparently we have a first thread that
is moving our car and our second thread
is reading its position and then the
question is what does the second car the
second thread see does it see it at zero
or a 10 yes yes
it depends it's great we love it when we
program and we don't know what's going
to happen right I mean that's in
determine is one of my favorite things
to work with usually that means there is
a blog and some user will come and
complain so what do we do how do we
solve this how do we fix this
synchronize yes me luck ah we use locks
that's great there is just one problem
is that only Brian gets gets them right
that's what we've been doing in Java and
oh it has worked so well every time I
have to work with more than one thread
and I have this feeling that I'm going
to get a life lot or a dead log or
something they're hard to reason about
and they're not really a solution there
a workaround because what happens is
that there is a problem with the
conceptual model in which we approach
all of this and also when you use locks
you're going to get a high performance
cost especially if you're really into a
performance and you really have a you
really concerned about speed and all of
this synchronization all of this
communication between threads to get
things right is costing a lot of
resources and time so what do we have in
object oriented languages as they're
implemented in Java is that we have no
notion of time right the language in the
language specification nowhere does it
say that there is time and no where do
we when we program the word do we
specify that we we are actually doing
something in a certain order or we don't
talk about time but there is an illusion
of time because you know the car before
who have one line we kind of expect the
second line to run after the first line
which many cases is true but when you
run when you were concurrently then
that's not and it's not happening
anymore so much things can just change a
bit in a random order so we have this
broken conceptual or model and it only
makes sense yes it does work sometimes
if you're local if you make changes
locally and you
a safe space and you mutate things in
this safe space and nobody else can look
at it and that's great but only at some
point you will need to connect to the
outside world and talk with other people
and when you have this situation then
you run into a problem so this is even
getting harder if you sort of work with
different machines then this problem is
even getting increasingly more complex
so to recap here yes many core cpus are
here they're not going to go away I'm
pretty sure in 23 years we'll all run
with 32 cores on our phones and what so
nuts you know I don't think this is
going to go away we may wish it away but
it's there to stay and the second thing
everything is distributed we do cloud I
mean that's just how things work these
days ah so we have the internet of
things that's going to come and smash
our servers into small pieces if we
don't get ready for it and then our
traditional or the things that have been
taken for granted the techniques that
have been taken for granted day they
don't just don't work in the setting so
what do we do that that's the second
part now the house and again it's not
the how it's the house its many
different things that we can do in order
to get things to work in this so in
theory and we can use all first of all
functional programming which kind of fix
to the theme of the conference we have
something called the actor model which
are all we talk about we have an
invented server model as opposed to a
threaded server model for doing for
taking care of incoming requests and web
application and stateless architecture
we also have two great things event
sourcing and wrecked extremes I won't
have time to talk about them but these
are two very interesting approaches and
so what I want to do here now in this
part is sort of link these concepts and
you
technology to as an example of how and
they can be achieved so for functional
programming I will go and talk a bit
about Scala the actor model is going to
be Baraka the server evented server and
Status architecture is with the play
framework and then the other two things
event sourcing there is a sub-project of
acha acha persistence i'm writing a
system with it right now it's really
nice kind akka streams is a
implementation of directive streams yeah
so let's get started with functional
programming so scala how many of you
know Scala know about that it is yes
anyway first short recap here we have
Martin order stated from the école
polytechnique fédérale de Lausanne in
Switzerland and he invented it it was
first released in 2003 and there is a
company called type-safe that provides
professional services around scala the
plague framework and acai more things so
the design goals of Scotland the first
one was to be fully interoperable with
Java which I believe was is still a
killer feature because that means that
you can run skala code from Java you can
run Java code from Scala so you can
easily integrate scholar and an existing
project you don't have to rewrite
everything it cuts down boilerplate it
is a very smart type inference system
and that makes for much nicer and eat
your code and it's both a purely
object-oriented programming language and
a functional programming language you
can start writing your object oriented
classes and song and then slowly
transition over to functional which also
is very nice one thing it actually
really I mean this no pointer exception
everyone knows these yes null pointer
exceptions is something that in the past
five years since i started to only work
with scala I've not seen so often and
when I saw it it was some Java library
that threw up a nullpointerexception
because by using the option type you
actually if you
consistent about using it you can really
get rid of this problem and the last but
not least it's been designed around the
idea of many core programming a so a few
core concepts i want to quickly go
through here and in terms of function
program we have immutability as opposed
to mutable state mutable state we have
functions and higher-order functions and
we have the idea of composing functions
in other in order to transform data
immutability this is a car which has a
brand I hope you can can you read this
is a brand and a position so we start
with a DeLorean at position 0 and then
we don't change this car anymore it's
not going to change once we have defined
the car we cannot change it if we try to
change the scholar compiler will tell it
tell us it's not possible what we do
instead is we copy the first car here
and then we copy it later on and it
moves so we take snapshots of reality we
have one value we can share it and the
person that's or the component of
whatever is going to work with it can be
sure that it's not going to change under
the hood so we remove this in
determinism the card position 0 is
always going to be a card position 0 so
what we do it in fact we copy we we take
snapshots and that's how we how we deal
with changes there Pam yes and then we
have higher order functions so this is a
this is a higher-order function here we
have a list of users and we partition
the users according to a criteria we
look at their age and we say that users
that are older than 18 or they they're
going into second place here and the
ones that are ya anyway so we can
rewrite it like this it's called a
function literal minds gone and it's a
function that takes a an age and that
returns a boolean and then what we do is
we take that function and we feed it as
a parameter to the second for this
function here so that's the definition
of the higher-order function
on one of the definitions is that it's a
it's a function that takes a another
function as an argument and this is it
disappears simple but it's actually very
powerful because what do we do with this
is that instead of moving data around we
move behavior around and that's quite a
much different way of thinking so what
we do is we transform data using these
higher-order functions we don't mutate
if we transform it so we start with our
users here we will just filter the ones
that are older than 18 we fetch the
addresses and then we sort all of this
by city and we end up with a list of
addresses that are sorted by city but
our initial list has not moved we
haven't touched or changed anything what
we did is simply to to transform it and
sort of extract what we need from it so
what we it's like playing lego you know
Lego blocks you build small pieces small
pieces and then you compose these pieces
together to do something increasingly
more complex so this is a an example and
I don't want you to look too much on the
coal I'm going to quickly go over the
slides you may notice that there is a
similarity between these slides here we
always do more or less the same thing
but we have different types in here
that's the skeleton that we use it's a
for comprehension and what we have is
really is these types that we can
manipulate in the same way option which
is a type in skala that says there is
something here or there is nothing
future which means there's eventually
maybe going to be something in the
future and try which is a way to sort of
catch exceptions on the fly and what we
do with this or what this is good for
it's dysfunctional composition is these
data structures
they implement monadic operations it's
like this wha yeah but it's not that
complicated it's just a set of data
structures it follows laws it you know
implements a few laws and once you get
it the great thing is that once you get
it once you understand that oh this is
there and you know this is a model then
you can work with all of them the same
way you get all of these tools for free
once you understand how one of these
works and that makes for a nice code
easily more easy to read once you
understand it it's not that scary it's
it's it's okay um okay that was my short
take on functional programming now I
want to quickly talk about actors so and
akka so the short history here is that
we have the actual model em in 73 by
crawl Hewitt and that sort of described
this actor model wearing you have actors
that communicate by using messages and
it's actually based on physics and
quantum physics I didn't know that until
recently when I read a bit more about it
is that what he said is that he looked
at physics sort of describing how the
world around him works and sort of tried
to put that in a concept or model and
then in 86 and there was the first
release of airline and you know where
Joe I'm strong at Eric song and then
they kind of didn't use it for many
years and then they rediscovered it and
started using it and then they have this
switch that had an availability of 99 so
that's 31.5 569 milliseconds of down
time per year that's just that's
amazingly good in terms of its not going
it's really robust I tell us for really
resilient robust system and in 2010 that
was the first release of acha comes from
sweet
and it's inspired by the actor model and
in my opinion its object oriented
programming done right because you do
have your object and you do have mutable
state but it's all in a safe place
inside of the actor nobody else can look
at it unless the actor wants you to and
I will explain just how this works acha
also happens to be a mountain in Sweden
and you may notice that there is sort of
a similarity between the logo and the
mountain I don't know did I was told it
that's the case but there may be and so
I thought I should mention it all right
so actors these are lightweight objects
tiny tiny like with objects you can have
millions of them running on one JVM and
what they do is they send and receive
messages they send messages to each
other and they receive them in a mailbox
actors can have children and then you
have a concept called supervision we're
in the parent actor is responsible for
the child actor whatever they do wrong
they have to deal with it so let's take
an example we have Luke on one side then
we have Darth Sidious here and Darth
Vader they each have a mailbox they also
each have a you know a funny-looking URL
here that's called the nectar reference
and Darth Vader is that well they're
seniors is the supervisor of Darth Vader
and you can see here invaders Act
reference is that the below Sidious in
the ark ok anyone does did anyone not
see episodes 5
okay just you know just don't listen and
close your eyes now because I'm going to
completely spoil it for you yes because
that's a relation here yeah Vader sends
that message to look and what does Luke
do okay but later did not wait for a
reply that's important here later just
send this off and then didn't wait right
and then eventually Luke got the message
reacted to the message and replied yeah
it was not really happy or thrilled
about it a bit of code here so we have
this revelation of father ship that's
our message it's an immutable message
that's important you should not send
mutable things around you should only
send immutable messages around and then
Luke is an actor because he extends this
actor right here and in the receive
method we see in case of real evaluation
of father ship we kind of are very sad
in order to get a look we as as the
actor system which is the kind of thing
that holds all of the actors or takes
care of them for an instance of Luke but
what we actually get here is not the
actor itself for an instance itself is
the actor reference we get this thing
here it's like a phone number now when
you call someone you don't grab their
phone and call it you get the phone
number and take that and use it in order
to talk to someone so that's the idea
here you get OOP you get Luke here and
you send him it's this ! sand means tell
the relation of father ship and that's a
fire-and-forget kind of operation just
send it out and I forget about it and
eventually is going to come back and and
react to the message or not supervision
so here we have usually Darth Vader
comes in and there's many stormtroopers
around so we have Vader also an actor
and he is asking his actor context
doctor context each actor has a context
which kind of says what helps them to
interact without outside world for a an
actor of type stormtrooper but with a
router a router is this thing here here
we have a round robin router with eight
instances and round robin just means
that whenever Vader will send a message
to this router it will reach them one
after the other round in a round order
so that's how it looks like usually and
then a very essential part of this
supervision and said that's because the
first part is how do we define the ERP
the second part now is what do we do if
a storm trooper has a problem because he
found some Maronites in the way well we
define a super vision strategy it's
called and the supervision strategy is
there to you know declare the behavior
of a supervisor in case something goes
wrong with one of their kids so here we
have a one for one strategy and there is
also all for one strategy in a one for
one strategy if one child is a problem
we will do the same thing for this or we
will just deal with this one child in an
all for one strategy should a
stormtrooper have a problem we would
restart all of the stormtroopers so what
we do here is in case of any kind of
exception we're just going to log it and
restart but it's just one of the things
we could do what we could do as well we
could say okay doesn't matter resume
continue we don't care about this
exception we're going to assume that
it's fine or we say stop we don't want
you anymore so depending on the kind of
failure we build a way to deal with
mistakes so what happens in there when
you program with actors instead of
trying to catch mistakes or errors or
whatever failures inside of an actor you
just let it
load and go boom I mean the mantra of
akka is let it crash so what you do is
you just say I am an actor I don't care
my supervisor will deal with my failures
it's a very very different approach
because an interesting one because as
program is we kind of sometimes things
that we know everything and we will
think about everything but in practice
we don't we always forget this one case
where things could go wrong and that's
something that's that's the lacka does
is that it it embraces the the thought
that things will go wrong anyway so
let's rather than trying to fix
everything up front as in defensive
programming let's make sure we are able
to repair things when one after they've
gone wrong okay now the third how is is
about invented servers and stateless
architecture in play so play it's a
model you control a framework it was
inspired by Ruby on Rails Django and
Symphony and it was developed in Paris
by a company called zanuck City back
then now they called infinity i think it
was first released in 2009 it was i
think the first Java framework that had
this rail ish feel like really did this
kind of Ruben really feel in Java and it
was quite successful for a reason I
believe and then in in 2012 there was
the second version that came out and it
was an entire rewrite and the core was
rewritten in Scala so the design
principles of play is the first one
everything is compiled of course you're
sure your controller sources are
compiled but also your javascript is
compiled with the Google closure
compiler your URLs are compiled should
change our URL and you didn't adapt in
your new words it's going to blow up you
can refactor links
and your style sheets are compiled your
react Jas stuff is compiled you have
extensions you can plug things in so
what happens is when you use play and
you make a mistake it blows up at
compile time not at runtime and that
makes for a very productive experience
because you end up having much less
errors at runtime and then later on if
you didn't test correctly for the users
in the second point I'm going to talk
about it right now and the third one is
if you look at a play controller yeah
it's just a collection of functions from
request or response it's not exactly a
function but it has very much this feel
that's what they wanted to achieve to
make something it's very functional a
controller is just a collection of
function and then last but not least it
has a share nothing approach which means
that the session in play is on the
client side it's not on the server side
you mean that if you want to pan out and
have more nodes you won't have the
problem of having to replicate this
state across these nodes because the
state is on the client and it doesn't
matter if I know disappears because then
the client just fetches another node and
they can continue with it all right so
what's so special about play so this is
the model called the threaded server
model and that's what Tomcat jetty and
other web servers application servers
use and it's a bit like a train station
where you have many tracks so tom cat
when you start tomcat by default it as
200 threads are located in the pool so
you have 200 tracks and then there is a
station chief the acceptor thread in
front that I whenever there is a train
it will decide ok you go to track 5 you
go to track 7 etc sort of redirects the
trains on tracks and that's fine until
all the drugs are full and if they don't
leave fast enough then trains start
queuing up and if they
be processed fast enough then you have
large queues large delays and really
unhappy travelers and this is exactly
what happens and if you've seen a tomcat
server died it's exactly what happens it
just you don't get anything back from it
if you have a front end server in front
of it you may get a timeout exception
from that 1503 effect but tomcat the
server itself will be completely
overwhelmed and dead so an invented
server works quite differently it's like
a waiter in a restaurant you have many
tables in a restaurant and you have only
a few waiters you don't have one way to
per table unless it's a really really
fancy and posh restaurant but most of
the time you have one or two waiters in
the restaurant and they run around they
come to your table they take your order
they go to another table take another or
run back to the kitchen come back etc
but what they do are very small tasks at
each table they don't wait there for you
to make up your mind while you look at
the menu they just say ok I will come
late back later and why and that's how
an event it's over worked it will not
hog on a thread while its processing
something it's going to use asynchronous
calls all the time and that way it can
be much more efficient play by default
will start with the amount of course
play will have as many threads web
worker threads as you have course so if
you have a quad core server it will have
four worker threads fall of your
requests and there are benchmarks that
they made like on a Mac like this one
you get hundreds and thousands of
requests per second just by using this
asynchronous model and not hugging on
resources blocking a thread no locks so
also using this approach means that
there is less memory because one thread
on the JVM you have one megabyte per
thread so if you have 200 by default on
tomcat you need 200 megabytes at least
and a few months back still I think you
could start play with a 16 megabytes of
of heap that's not a lot 16 mega
life is like what we are not used to
this anymore but that's what it enables
so we have much better cpu utilization
because we don't have all of this
overhead of context switching and all of
this locking and we have much that
enables much higher throughput so to
recap the house functional programming
yay with the newt ability higher-order
functions and composition the actor
model as a means to build complex
asynchronous programs in a safe manner
that kind of resist a failure then we
have invented servers and stateless
architecture in order to build web
applications and web architectures that
scale out and scale back in and last but
not least but this this party and won't
be able to talk much of a little with
event sourcing and the reactive changes
which is something really interesting I
think we're going to hear a lot more
about this in the coming years as an
approach to building and large
applications and interesting
applications and I think that's yeah so
the small summary two things I want you
to remember is that many cords are here
many for many core processors are here
and they're here to stay and distribute
the systems are also here to stay so
this is something we just should accept
and we should get ready to adapt some of
these use some of these new tools and
techniques in order to make use of these
changes in how we build applications
that's it I think yeah thank you very
much you have any question
I have a question that they have to
reason because of which I'm afraid mmm
asking this question first of all you
didn't mention about I mean you didn't
talk about you know something if and
second one this question the answer is
probably a topic for I mean one hour
talk or something like that but it is
healthier how do you deal with eventual
consistency if you are using it on
something and see us do you haven't deal
how how do you deal with eventual
consistency so in events or saying what
happens is you have your rights going in
one side and then you have an event
stream and the event stream gets piped
through another system and other
database which you then query and while
these things pipe through you see less
you see you have a disparity between
these two worlds and if you develop
Twitter or Facebook it's fine because
even if your consistency is ok because
nobody is going to care if your tweet or
your thing is going to have a little bit
of delay if you work on an accounting
system you have or a bank or a
reservation system i'm building a
reservation system right now then you're
going to have a problem because if
you're short of seeing something your
account is out of sync you're not going
to be very happy so the way I'm solving
this pragmatic alee there's an Akha
cluster you have all of these actors
here in the middle and you have an in
memory model wherein you have your state
that's that's there and for slow queries
where you don't care about the
consistency you use the normal query
model with the replicated database but
for things that need to be live you go
in Korean memory that's ok so to you
don't have any assurance that I mean
you're using in Hungary model
right so yeah this is some kind of cash
right this is your actor system yeah
service but do you have a guarantee that
even that occurs you know already
succeeded look like that well you only
change your state when the event has
been saved and you come back and you
save you you change your state according
to that and messages are queued up so
you cannot have something that comes
before sort of list nuttin you actually
have it's not so much share state
because you have it in one actor in one
place so it's not so much shirt they
have to yeah you have a bottleneck there
but that's that's true but in practice
this doesn't have I mean the in practice
if you design your system well then
you're okay in the case of his system
i'm writing right now i know there is
going to be a lot more reads than
there's going to be rice so I kind of
can use this applies it about the euchre
send the message and cable to the slide
where you assign leave a message this
one do with the cold is it goes how the
code okay let's lay low you can send the
village is that it is there like a real
cold please don't need the center to say
not coming from Vader in the current
version of vaca so that's a good
question current version apakah you can
do this and the sender is going to be
there implicitly akka is going to take
care of it and whenever you receive like
you have a receive method here I could
go in here in the receipt mentored and
say sender and sender would be the
sender of the message there are there's
a new API that's called type actors
that's coming out now and in that one
you actually need to have the sender
part of the message
with that call what what would be the
center in this one and that's here out
of here that would be something if we
were running this into in the wild like
this there would be some anonymous
temporary actor that would be created
but what a proper example would have
been Darth Vader selling this because
then yeah another visit you said many
good things but is there anything that
was like a debugging debugging gets
debugging gets more complicated in the
system that's for sure because yes so
it's more you have to look at blogs and
it's it's more tricky to debug that's
why are active streams which is a layer
of abstractions on top of factors is
very interesting because it takes care
of hiding all of these low-level things
and which can be quite confusing as if
your system gets more complicated if we
could sail dislike what do you in the
receipt block in response of you know
getting a reveal fellowship message we
want to send one and how do you test it
how do you test that yeah you would
there is a mock there is a test to have
accurate call the thing if naka test kit
which lets you sort of pretend to be an
actor to mock an actor and you you would
probably want to test look in this case
right you would want to check if Luke is
actually replying check it look it sends
a message back back to me then then I
have a test chef actor and I can see
what this guy receives so there is a
test kit around that's quite it's very
nice to test actor system that works
right now
play actors yeah I am not aware of play
actors actually I know that there were
scale actors scale actors they've been
deprecated they've been deprecated and
then kind of replaced by a vaca yeah
yeah and to the best of my knowledge
it's like gone okay just to see if I
understand you right so with the event
sourcing you the vlog events when things
have been ever no worries before so how
event sourcing means that first you have
before the sourcing you write the event
and when the event has been written to
the journal and it's somewhere in a safe
place then you will change the internal
state of your actor okay so you did
before and if it was your trade of the
other yeah I think we need to finish you
can still catch my role in the hole and
during the day so the biggest for the
idea if you have questions is company
thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>