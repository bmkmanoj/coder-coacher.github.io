<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Embedded - Episode 3 : Concurrency Revisited | Coder Coacher - Coaching Coders</title><meta content="Erlang Embedded - Episode 3 : Concurrency Revisited - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Embedded - Episode 3 : Concurrency Revisited</b></h2><h5 class="post__date">2012-05-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HjbNyA1ASkE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi welcome to the third episode of
Erlang embedded in the previous video we
mentioned that we would be looking at
distributed Erlang on this video but we
haven't received our extra raspberry
PI's yet so we thought we would play
around a bit more with concurrency today
I have ed from also promoting solutions
with me hello he has prepared a cool
demo for us pushing the limits on the
point so without further ado ed take it
away
hey so last episode Aamir said Erlang
was good at spawning processes and today
we're going to demonstrate how many
processes we can get away with spawning
on the Raspberry Pi in reality so the
demo consists of spawning a ring of
processes which we call relays and
passing a token around the ring a
hundred times so here you can see that
the token is passed in this slide you
can see the token being passed from the
initial process to the next and so on
and each time that each time the token
completes a full revolution we toggle
the LEDs state so if the LED is on we
turn it off and vice-versa
in the previous video amir showed the
LED module which used asleep in order to
blink and here the LEDs blink at the
rate of two full revolutions around a
ring and so to begin with we will spawn
full token rings which correspond to the
four LEDs on our breadboard the red LED
represents the rate of revolution of a
token ring of size 1,000 which means
1,000 processes will be spawned and the
token will need to complete 100
revolutions before terminating the blue
LED represents 10,000 processes the
green 25,000 and the white 100,000 so
here is what it looks like when we run
the demo
you
we also attached a logic analyzer to the
output pins of the Raspberry Pi to see
their toggling rates of the pins and
here's the waveform we observed you can
see that the first row ie the first
process ring toggles that's a very quick
rate because it only has to send
messages through thousand processes
whereas the last one has to send
messages through 100,000 processes
therefore it's a lot slower these run
concurrently so we have observed that
once the execution of one ring was
complete the message passing rate at
other concurrent rings was much faster
and this is clearly demonstrated by the
last row ie the last ring you can see
it's toggling at a much faster rate than
it started so thanks for watching to get
in touch with us if you're interested
you can find the code that we have used
for the demo at the github repository
linked below until next time cheers
Cheers</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>