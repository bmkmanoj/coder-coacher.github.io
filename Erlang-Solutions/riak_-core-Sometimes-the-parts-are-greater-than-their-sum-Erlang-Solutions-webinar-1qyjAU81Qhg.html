<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>riak(_ core) - Sometimes the parts are greater than their sum | Erlang Solutions webinar | Coder Coacher - Coaching Coders</title><meta content="riak(_ core) - Sometimes the parts are greater than their sum | Erlang Solutions webinar - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>riak(_ core) - Sometimes the parts are greater than their sum | Erlang Solutions webinar</b></h2><h5 class="post__date">2018-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1qyjAU81Qhg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and welcome to the erlang solutions
monthly webinar my name is Logan will
excited I'm the VP for the Amir region
here at lying solutions today's webinar
represents a continuation of a series of
webinars we have been running in and
around topics to do with Erlang elixir
and related technologies today we will
specifically be talking about react CRO
and also about Almaty nerdy B we will
explore how the two solutions and the
two technologies interact together and
what the similarities and the
differences are between between these
two distinct products now as with any
live event please do excuse any
technical difficulties that we may face
today but to start by telling you a bit
about allowing solutions we are a
products and services orientated company
completely dedicated to Erlang and
elixir and solutions based on the beam
we work with companies and individuals
fostering Erlang fostering elixir
fostering the beam we hold conferences
globally and work on projects across
industries we also develop products
based on Erlang and the leaks here some
of them you probably have heard of our
Mongoose I am messaging platform which
has been widely used in social media
financial services gaming and so on and
our one bot o am monitoring and
management technology for Erlang and
elixir systems now I'm truly privileged
to say that our speaker today is Heinz
keys who is truly a technical visit and
a technical lead at Project fifo we're
very privileged to have Heinz joining us
and talking about react or and talking
about almaty nor DB just to say that you
are very welcome to post questions
throughout the duration of this webinar
you can use the chat facility on the
webinars interface to do so our speaker
Heinz will answer as many questions as
time allows at the end of the webinar if
any questions do go unanswered you will
see my personal email in the last slide
of
Hynde his presentation you can use that
to send us any questions that have gone
unanswered in writing and we'll
obviously answer all of these after the
webinar now if you use Twitter have a
look at the following hashtag so hashtag
erlang solutions talks our team will be
tweeting live throughout the duration of
the webinar and you are esteemed members
of the audience are very welcome to
contribute from your perspective I would
now like to hand over to Heinz who will
be glad to start us off
good evening afternoon everyone first of
all let me say thank you for having me
and I really hope that all of you get
the chance to take something interesting
with you today so we'll be talking about
rear core and its place in data bases
and distributed systems and before we
start off with the content I want to
give us a quick look at their gender so
you can follow along and know where we
are in the global scope of things
we'll start with defining a few goals
for today so that everything you hear
can be put in proper context and you're
not surprised or disappointed about
something missing or something said that
you wouldn't have expected will then
introduce to data bases react and
dommatina DB those will be the two
examples we use to look at what react
core can give us and the features and
possibilities we get with the system
will then take a peek under the hood for
operations performed on react and
Tomatina DB this allows us to see how
those databases which are fairly
different use a common core framework to
achieve vastly opposite results in many
places with that done we'll take a look
at what real core provides to those
databases and the possibilities that you
have with it and some of the other
libraries so let's talk about our goals
this is not going to be a technical deep
react or and distributed systems in
general are a huge topic and we couldn't
even scratch the surface if we want to
go into the details it would be bit
over-the-top for the next 30 to 45
minutes what we are going to do is we
want to look at some examples of real
core and we are doing this by looking at
how does used and the concepts that can
be realized we
library now I said before I want to ask
you to ask questions whenever something
is unclear I'm pretty sure we have a
very diverse audience and the experience
you have with react react or dommatina
to be is very different from person to
person and I couldn't possibly cover all
the ground and give the needed detail on
every aspect without totally blowing the
time frame so if something is too
unclear for you please ask and we'll try
to answer it at the end of the
presentation now let's go into
introducing our two databases react and
dommatina DB this is not about how they
are operated how to use them this is
about the concepts so here we go they
have quite a few commonalities first of
all most databases are eventual
consistent and since this is a bit of a
pet peeve of mine I want to lose a few
words on what eventual consistent means
in this context too often I have
encountered situations where you men
mention eventual consistency and people
get scared that it means your data will
be wrong all the time it's not quite
correct if we are talking about
adventure consistency what you should
imagine is that most of the time your
data is consistent only in edge cases
and when something goes considerably
wrong this eventual comes into play and
some of the replies might not be
consistent both systems are based on in
dynamic attack sure but fear not I will
not show you the dreaded and famous
reoccurring which i think is usually
part of every presentation that touches
react or react or and it's important to
know that those systems are not based
not new inventions they are based on an
existing and well proven technology
there's a wonderful paper on this which
is the Amazon dynamic paper
and everyone who is truly interested in
learning the depths of this concept is
welcome to read it there will be a link
to it in the last slide both the
databases have the option to grow and
shrink dynamically which is not all that
common and databases today and while it
is not necessarily important for code it
gives a huge operational flexibility
that you are not bound to handle
charting in this kind of stuff in your
application but just can add it to your
database it lets you plan easier and let
without having to perfectly scope out
the amount of hardware you need by just
adding or removing notes as time goes
furthermore the database is horizontally
scalable which is also quite important
when it comes to planning you do not
need to tell your application about new
notes you join rather that adding you
notes will just improve the overall
capacity in both computational time and
storage of the whole database so those
are the big commonalities between them
at ena DB and react let's look at some
of the differences
starting with react react is an
incredibly versatile database there are
numbers over numbers of use cases you
can use it to store commands in a block
you can use it to store shopping cards
you can use it to store user accounts it
is a general-purpose database so you're
not set to anything this comes with the
fact that it allows for complex data
which makes it easy it's not a simple
key value store in the sense of that you
have one key and some opaque value to
the database react understands quite a
few different data types
some of them specialized for eventual
consistency they so-called CRD teas
which amongst others are sets so sets of
data which are nested may
which are counters and they let you
build an application with react
understanding some parts of the data and
of structure which helps a lot
react prioritizes data availability this
in many places really important you want
to know that when react tells you your
user account has been written that you
will later on be able to get this
account back and not be told by the
database hey it's not here now there is
a grain of salt eventual consistency
means that it will only eventually tell
us there again not during normal
operations but in edge cases that can
happen but generally when react tells us
a tree has written the data react has
written the data and it is safe that's
really good peace of mind to have in a
database
react cares a lot about predictable
latencies as well so when you make a
query you can be pretty sure that it
will be answered in about the same time
every time you query it this helps for
planning on capacity to understand how
fast you are the code needs to be to
give you years or certain performance
now those are the general specifics of
real that's surely a bit more but we'll
focus on them because they are in
contrast to some of the decisions that
were made when building the mattina DB
so the second or two data basis is not a
general-purpose database
it is incredibly task specific the
mattina DB was built for one purpose and
that is monitoring by a time series
storage of operational metrics when I
talk about operational metrics generally
think that it is for example the CPU
usage of a server they occur on a
regular basis on a fixed interval once a
second once every 10 seconds whatever
you use for your monitoring they always
have the same data type so they're not
really be oh do we know the one type of
data and those numbers now it's not
always numbers so it can differentiate
between a float integer or not written
number so in
but in general there is no complex data
types here it's just a number or not
enough no while react prioritizes data's
availability the big priority for the
Matina Ruby is rather different
it is ingress availability what this
means is that for operational metrics
it's more important that a vast majority
of your metrics arrive then that you get
clear confirmation that every single
time was written now that sounds a bit
off but if you think about it if you
have one second of CPU usage not written
the importance of it is rather low
usually every operational metric is
looked at a 10-second one minute hell
one hour window and aggregated over it
so a single missing value does not
really have that much effect now this
couples a bit with a higher throughput
the next point and since it's very much
mitigates the chance of data loss in
trade-off for general availability of
having some metrics reading now another
thing that'll be heavenly features
throughput over latency and that makes
sense if you're using a monitoring a
large set of servers it's more important
that thousands of servers are managing
to write their data then if it's written
within one milliseconds 100 milliseconds
or even a second so this implies some of
the trade-offs to give you a feeling
when I'm talking about high throughput
here it's not 10% faster we are talking
about one to two orders of magnitude
compared to other systems going back to
the ingress availability why dropping
one point is not so bad if you have 10
times more points anyway you still have
9 points not 8 points more than another
database if you have a higher throughput
ok so
now we have had a general look at the
two databases we are talking about today
and some of the design goals involved in
them which impact the decisions made in
their implementation next we'll look at
something
reading writing in those databases we
will start off with Rijeka
please understand before I go to the
next graphic that this is not meant to
be 100% correct the whole algorithm for
reading and writing is a lot more
complicated than what is shown here but
once you see the image you will
understand that I am NOT going into full
detail so this example is for reading
data from react with a configuration of
N equal 3 and R equals 2 that means all
data is replicated to 3 hosts and for
successful read we require two of those
hosts to reply so let's talk about the
little boxes at the top for a second
before we go into the arrows the user is
you or your system the API would be the
HTTP API or protobuf API provided by
react to which you sent your request the
FSM is a finite state machine piece of
logic that handles how the read is
performed and interacts with the other
components behind the API the ring
manager is a component from react or
that keeps track of how you ring how
your database is shard it over all the
systems that are part of your cluster we
have three sets of proxy and note here
the proxy is a little piece of code
actually very interesting piece of code
inside the react or repository that
handles amongst other things and most
importantly load so this piece of code
decides when it's actually ok to keep on
sending data and keeps your actual node
protected from overload the node or more
correctly node is the implementation of
your database logic that gets chartered
over your ring
so over your cluster so now that we have
a general understanding of those
wonderful little boxes let's talk about
the arrows so rate starts when the user
sends a request to the API saying please
react
give me the user Heights he wants to
login I need to know if he can ya API
gets the requests and decodes it and
then it starts a new process the FSM the
FSN will be handling now all the logic
it starts off with asking the Ring
manager hey can you please tell me how
my cluster looks who would I need to
talk to the ring manager having all this
information hands it back to the FSM now
we have now the information of the whole
FSM and we note what data we want to
read so the FSM continues to build the
query plan which means it will figure
out which notes in our replicas hold the
data now if we look back up we have a N
equals 3 so we know 3 notes will hold
the date now in this example it's note 1
2 &amp;amp; 3
mostly because those are always present
when you have an N at 3 it could be
other notes but at stick reserves so
what the FSM know does that sends a
request to the three proxies which are
responsible for the notes so it sends a
request saying give me the data for the
user hides from to proxy one that senses
on to note 1 to proxy 2 which senses on
to know to to proxy 3 which sets on to
note 3 now if one of those nodes would
be overloaded the proxy will tell us hey
stop we can't do that try again later or
perhaps you can continue because we only
need two replies now our notes do the
work they look in the database on disk
or in memory and figure out is there a
queue signs and what data is there for
him so they will reply we see in this
example that they do not need to reply
an order this is actually really
important as it comes into play when we
are thinking back about the latency
since you only need two over the nodes
to reply in
which happens to have higher load in our
example note to can reply a bit late and
you still get a good low latency and a
dependable latency on your request so in
this example note three replies first
despite being the last one getting the
message and then replies note one now
the FSM now has two replies which if we
look up the r-value of two is enough to
let the user know what we found and the
FSM replies back to the API and that
goes to the user saying hey here is your
user rights now what you do with the you
lines it's up to you but the FSM is not
quite done yet since we asked three
notes we are going to get three replies
back so for the sake of the example no
two had a different idea what Hinds is
this is one of the parts of this
eventual consistency perhaps while Hinds
was updated the last time no two words
down who knows now what the FSM does it
compares those three replies and finds
out well one is different let's repair
that this is called the read repair now
if we were smart and start our users in
the C ODT the magic is completely
happening in those status sir datasets
and can be automatically repaired there
are other methods but that would be
going too deep now the repair request
goes back to the node true proxy and
then goes back to node 2 so this is an
example how react would read data next
up we are going to look at writing which
oddly enough looks a bit simpler than
the reading this is because we don't
need to take care of repairs in this
place the same as with our read example
we have the boxes at the top there are
no difference I'm not going to go into
detail we have an N value of 3 the data
is stored in three places and we have a
W value of an R value this time of two
again the W value just
the r-value specifies how many nodes
need to confirm a right before we can
say it is successful so in this
installation it would be the same as the
reads now let's start from the left
again and could say we had a new user
and let's call him Frank so you had to
use a Frank and tell the API please
write this user the API again decodes
your messages and starts the FSM this
time two different SSA FSM it's a write
ever say no to read everything but a lot
of the steps are the same so it will
start was asking for the ring and the
ring manager diligently will reply with
here is how your cluster looks now using
this information the FSM can figure out
which notes are required to handle the
data now it's a query plan even so it is
the right given that the system itself
react or doesn't know it is a right it's
still constantly the query the same as
with reads we sent the request to the
proxy proxy one proxy two and proxy
three all those given there's no valid
situation continued to hand them on to
the fee note itself that doesn't work
and wanted us sure that it will store to
disk it's going to confirm the right we
see again because I was too lazy to
change the arrows note three replies
first note one reply second and then the
FSM knows okay we have two writes
confirmed so we can tell the user your
data is safe finally the last night or
two replies and we are done with writing
data now next up let's look at the same
on dommatina DB nope
I will start with a writing on this side
because it is the it is a very different
from react well the reading is pretty
much the same and I want to have your
memory fresh about the writing we just
talked when we're looking at how
dommatina to be desert now you can
already see this is a lot longer than
what we saw on the react side we have
the same general configuration of three
replicas and right value of two so two
needs to be confirmed now what you might
see if you pay close attention to our
little boxes is there is no FSM here
involve part of the optimization for
throughput is that some of the safety
nets and some of the safety measures are
removed in down at ena DB and it handles
stuff more direct another thing you will
see is that we don't handle one right
here that is because dommatina to be to
perform higher throughput batches rights
so what happens is the user writes its
CPU its memory usage disk i/o process
time you name it there are millions of
metrics you could problem right and it
keeps sending them at a quick pace
especially was monitoring usually those
happen in bursts and then a teener DB
sense of such general purpose can take
advantage of this knowledge so it will
collect a number of writes and at one
point the API will say okay we have had
enough now you've sent us quite a few
writes let's actually persist so just as
react it asks the ring manager hey can
you give me the class layout and that
will reply now here's the next big
difference but now we'll patch those
writes up so all the writes and go to
node 1 will be batched into 1 right
going to node 1 so if you have a
thousand writes happening in one of
those batches and a ring size of say six
four notes you are at maximum during 64
oh right not a thousand and that can
save considerable time at the expense of
latency
since the write itself was bigger it's a
thousand divided by sixty four messages
instead of just one but that will take
longer but it will have a higher
throughput now looking at this it goes
to the proxy again and not only for note
1 2 &amp;amp; 3 but all the way up to node M so
we will create 64 write requests at a
time and then wait for them to come back
now there's no confirmation you're going
on to the user which goes back to the
fact that we do prioritize the germinal
ability to write metrics over confirming
for every write that it was done come
done correctly no I think this gives a
very good idea how prioritizing
throughput of a latency affects design
decisions next up we look at reading and
reading is nearly the same between
dommatina DB and react the user sends a
request the API starts an FSM the FSM is
going to ask the ring manager where can
I get my data and the ring manager
replies you built a query plan which is
slightly different here since we might
need to ask more than our three notes or
actually do more than read one read
request if we are reading over a large
timespan but for simplicity we say all
the data we need is within one time span
and not charted over multiples so we
send three requests to the notes again
and get the replies the same as in react
two replies will be enough for our
system to tell the user here's your data
now when the first reply arrives we'll
do this same read repair process with a
slight difference donatina DB has an
understanding about what the data that
is stored in it needs
this additional knowledge lets us do
some tricks just like for batching while
reading we know that data is time
indexed and we know that the most recent
data being slightly off might not be a
inconsistency but just in the leaving of
messages imagine Note one and two got a
write request for just the last second
before they got the read request note
three on the other hand got the read
request just after it got the write
request so there would be a slight
difference one-one second out of date
and if you're reading frequently which
in metrics you might to show your
dashboard you would get a storm of read
repairs on every second so what vanity
under B does it says if your data is
very recent we don't read repaired we
only read repair data that's in the past
to cut out those few seconds of possible
inconsistency which would then be fixed
later on on later reads so if our
difference in this example would lie
beyond this threshold of this data is
too recent to repair we would get repair
and the same way as in react we would
rewrite our data and now have consistent
data over all three nodes so we have
seen how those two systems work when
reading or writing data we have seen a
bit about the trade-offs that happen in
the design of either system and where
the priorities lie now I want to show
you a quick idea what are all the
components that go into it now please
keep in mind this is just a small step
ssin react itself has a lot more
components and dependencies but I want
to give you a general idea how its put
together so we have the database react
and it has react or a react AV the key
value stores one of its main companies
but there are others like authentication
and a few more KB itself then uses react
or to do a good
bit of us lifting but in addition to
that it has other components that has
the FSMs we talked about the Regent
Ryder has them it has a Vinodh
implementation for storing the data the
note we send messages to is that it has
a API model which handle the API it has
multiple data stores to store your data
for example level DB or bit cask now
this is how react in a simplified view
is built looking at the Matina to be it
is less general purpose and more
specified so it can be built leaner but
we see a lot of the same components in a
sense we have react or as a big block of
it but on the orange side to the right
that's very different we have the metric
Vinodh instead of the key value V node
we have a different API instead of level
DB and bist cask we have something
called M store and each store and io
node it's all different I want to give
you quick since I promised to talk about
other libraries which is really really
only a short moment and I want to talk
about the little green stuff see there
is fall soon which offers measurements
and performance metrics for the data
base layers logger which is my absolute
favorite logging framework in the world
it is brilliant and I use it in every
project I ever built
there is click which is a CLI tool which
uses the configuration that cuttlefish
the config file management provides and
all those make building this
applications really valuable and all
those are in a way part of real core now
last but not least what of all this does
react or give us one of the big features
that react or provides to build this
databases is custom imagery the whole
handle ship of mentorship the whole
handling of membership joining or
removing notes dealing with a note that
we know is down replacing it that is all
provided by react or does not eat to be
implemented in react or dommatina dB
all administrative tasks like
show me my notes show me my ring where
is the stage all this is handled by
react or as well so neither dommatina to
be no react needed to implement that a
lot of the monitoring in the sense of
both performance to a degree and uptime
and reliability it's done in react or we
know where the v notes are down we know
which notes are down assuming we can
handle with it react or comes with
something which is called metadata it is
a mini built-in key value store which
builds react and dommatina they be used
to store information about packets
groupings or keys that doesn't need to
be implemented again in either of the
databases at hand of distribution we
have seen the proxy which routes data to
the note that's needed we have we
handled failures so if a note goes down
react will out react all will
automatically route the requests to a
note that is up and save you from doing
this yourself it also provides a lot of
abstractions the V note which increments
the storage or the logic note of your
application is just a module that react
or takes and then puts on the server
where it leads to be you don't for you
is entirely transparent what happens you
say please send a command to the V node
Andrea core knows where this V nodes is
it routes the data there it handles data
going there and at the end of the day
they going back to you which is really
really saving a lot of effort and work
now there's a proxy so load sharing in
the case of overloads
to keep your system healthy that's also
all obstructed away into rear correct
doesn't need to be re-implemented the
whole concept of having a command that
is sent somewhere it's implemented in
react or and doesn't need to be
reimplemented by you so all in all if
someone would ask me today what is react
or the easiest and probably most correct
answer would be it is a framework
build distributed systems not only
databases but distributed systems in
general everything that you could
abstract in a dynamic fashion react or
is a brilliant tool to build with okay
that would it would it would be it for
my slides here is the promised link to
Aladdin's email address along with some
other links there's the link to the
dynamic paper if you want to read in it
there's a link to react in case you
don't use it yet there's a link to
download 10tb and there is a really
really good book that is open source
which if you're wanting to learn about
react or is worth reading so I put the
link here for you it's a react or book
it's not written by me so that's it
thank you all very much and if you have
some questions please ask at first of
all Hines let me say a very big thank
you on behalf of us and I'm sure all of
our attendees for a very inspiring talk
on react Co and also on Delma Tina I've
certainly learnt a lot and you know
we've used Alma Tina and we our core on
customer projects but it's fantastic to
get your more detailed insights although
as you said this was just scratching the
surface now I'd like to formally open up
the question and answer session
this is the part of the presentation
where all of our attendees are welcome
to pose questions using the question
interface on the webinar please post the
questions that we will answer and answer
them in in the order in which they were
received but just to start with the
questions that we've already received
first of all Heinz it's a bit of a
general question but how do you actually
start with react or how would you
recommend the person starts with we are
cool
starting with react or there are two
things who do I would start with the
react or book because it's an incredibly
good right there is also a blog post
serious
called tri tri tri which is really good
to read which is what I started off with
myself when I first built a react cyst
react or system today I would go to the
book there is a late in the book is a
very simple key value store as an
example and having examples at least for
me is always a very very good place to
start with because I'm learning by doing
so I personally would go to the book
read it
copy the simple key value store
experiment with it break it break it a
lot because I kind of break things and
then learn from that fantastic
Heinz thank you for that now as
questions are pouring in just to say
we'll try and order as many questions as
we can but again we can only have a
limited amount of time to answer them in
so straight on to the next question
Gonzalo from our audience is asking what
type of advantages do you receive by
storing immutable data on react call
what advantages I get from immutable
data and one of the advantages of
immutable data is that you only have two
states of data you either have it
written or you don't have it written so
in the case of misko's interventional
consistency in the case of an
inconsistency you always know what the
right answer is because the right answer
is
Barriss data if you have two conflicting
daters that just simply can't happen
so the repair phase in the rete repair
if we would look at the to read examples
is trivial with mutable data you have a
situation where you suddenly have two
states of data and it can be tricky to
decide which one is true and which one
false systems like c rd T's help with
that but even they have a significant
overhead so basically the knowledge of
what is correct and what does not gets
trivial when you have a mutable data
also when it comes to disks they really
like not to move data so having a
mutable data means you're only right and
only a pen twitch disks and computers
surprisingly really like if you have
mutable data you have to rewrite it you
have to delete it you have to in the
worst case overwrite it and there's all
operations with a rather costly this
immutable data those operations do not
exist so you have effectively either
write only or even an append-only
situational disks which for writing is
really really what you want Hines thank
you for that that's a very comprehensive
answer now moving straight on to the
next question
we have one of our attendees asking is
there a community managed implementation
of react Co that is compatible with
Erlang version r20 no there is one for
our 19 and the there is a lot of work
going on in the react and react or world
right now I'm pretty sure everyone
remembers the set fate that befell bash
Oh and but quite a few people including
erlang solutions bet365 the National
Health Service have stepped up to take
on the role there and modernising react
and in a factory a car is a big big part
of what's happening there so while there
is no community driven pair like 20
version there is a community driven
early nineteen thirteen and soon there
will be error long 20 version because
that is one of the things I think they
are planning for the 300 release of
react please don't quote me on that
wonderful thank you mine's greatly
appreciated now final answer as many
questions as we can we'll move straight
on to the next one
one of our audience members members
Sergio is asking can you list
another type of applications asides from
database type products in which react
core really shines
and yes I can everything that requires
distributed computing so doing the
horrible self marketing because those
are sorry those are the systems I can
talk best about and the main product
that project Pfeiffer produces is the
cloud management software and that is
written in react or on top of react or
so that is not a database at all it is a
system that manages virtual machines on
multiple hosts and every component in
that the web front-end the triple a
systems authentication authorization and
accounting as well as the whole business
logic all runs on react core and that is
a huge advantage and one of the things I
like to do when people are looking at
that is that you can take down a whole
logical node and everything will keep
seamlessly running which is a real shock
compared to other solutions where you
have the magic host note that handles
everything that goes down you have the
lengthy and manual process to repair it
so everything where you can chart your
logic into multiple places even if it
doesn't do storage is really really good
if you want to build on react or
fantastic finds thank you for that can I
just move right on to the next question
if you don't mind let's go
in the world where we hear about a new
database every two three weeks you know
why why another database how would you
kind of put the case for reactor core so
to speak and requires wonderful to build
purpose specific databases and I
personally hate rewriting things that
already exists so before I start at
dommatina DB I did check if there are
other solutions which provide the same
requirements and they're simply we're
not with react or it's possible to build
a database that fits exactly one purpose
and by that can outperform general
databases by orders of magnitude so if
you have a very specific use case where
you need a database for and really
needed to shine at this particular thing
react or is a wonderful tool to do that
you get a lot of the groundwork up
donatina DB was the first version was
written during air it was called Erlang
user conference then so pretty much in
three afternoons the first kind of
working solution was there and that just
underlines how easy it is with tools
like react or to start a specific
database and I think that is where react
or really shines is general-purpose
pietà bases are great but sometimes you
need this little edge you just get when
you know exactly what your database is
doing wonderful Hines thank you for that
now this next question ties in nicely to
what you've just said because we've been
talking about use cases that react is
particularly good for and some use cases
that react particularly shines in but
the next question coming from Thanos
fallacies asking can you tell us more
about em store in East or and how you
can actually take the decision to go
down this particular path and how do
these solutions interact with block code
I can repeat the question if you like no
I got it but thank you and so react
users level VP and bit cask s storage
those storages are great for general
purpose a general purpose key value
store on disk em store an eStore are
just like dommatina to be purpose-built
for one specific application
and again it comes from knowing the data
Easter is a bit of an oddity so I want
to quickly handle it because it is just
a start to handle mostly ordered events
and it is not excel as exciting as p.m.
store pretty much just adds files heaven
in pens to a violent has an index and a
second file of all of other words M
store is more interesting since it is
specifically built for ingesting metrics
and taking advantage of how discs work
so we know that our discs like
sequential reads and writes versus
random access so it's level they be
features random access for reads quite
heavily since it needs to jump around on
a file to get all the data if you have
multiple keys you need to read em start
a it takes the idea that metrics come in
a fixed offset so in a fixed interval so
it stores a metric point in a specific
point in a file that simplifies reading
and writing to a mathematical operation
which calculates those offsets without
the need for algorithm or logic or C's
which makes wide efficient at reading or
writing those files and comes especially
into play if you are not using SSDs and
have large amounts of data for example
if you're monitoring a hundreds or
thousands of systems and kind of want to
use the old spinning rust disks because
they are just so much cheaper per
gigabyte I hope that answered the
question
yeah it certainly does yawns thank you
for that now again we've talked about so
many things that we our core is good at
can you tell us a bit about where we are
core is actually not particularly useful
and not particularly good yes M I think
it's always important to know where
something is not good to make the
decision to not blanket use it
everywhere
and we're core gets a bit complicated
the moment you want strong consistency
there is a strong consistency part
inside of RIA core but you lose a lot of
the advantages and the niceties that the
eventual consistency gives you basically
it might be okay to use it if that is
like a edge case in your system but if
you're going for something that requires
strong consistency I would not pick
react or as a foundation to build on
okay Hines thank you for that again to
try and honor the large number of
questions we're receiving we'll move
straight on to the next one one of our
audience member asking how does and this
is really interesting
how does downloading your DB compare to
react time series also time series data
in mind yes M so react I'm serious is a
beautiful product but it handles more
general use cases again it's built on
the same concept as react that you can
have complex data it implements a subset
of SQL on top of a eventual consistent
key value store and that in itself is a
incredibly interesting idea and it's
wonderful to store event like data so if
you have for example want to record
every time someone visits your website
or every time someone clicks on a link
and that true in a sense is time serious
data since its time indexed with an
event and react or no sorry react es
offers a very interesting approach to
that and having a distributed SQL like
system that uses time indices to query
your data dommatina Derby on the other
hand focuses heavily on this operational
metrics where you know you have a fixed
interval of metrics and only a timestamp
value in there and a timestamp as index
so it is a lot simpler when it comes
- your dater it works for less use cases
but in those use cases is able to be
significantly faster than react es would
be on the other hand if you have a use
case where you do not have this very
specific characteristics which is fixed
interval one number values then we a
react es actually lets you do that and
lets you do that efficiently while
dommatina DB doesn't provide any
capabilities in that area
wonderful Hines thank you for that now I
think a question that needs to be
addressed with everything that's been
happening is you know with the demise of
bash Oh what future do you specifically
see for react react or and the related
react database products so there is a
wonderful open slack channel where all
the people that are interested in the
future of react or react or or its
branch offs and the libraries can join
now anyone asking this question I would
suggest join that Channel and instead of
taking my word for it see for yourself
it is active and wonderful um so I have
no doubt that react and react or and
everything related to that will strive
and grow actually might have been a good
thing since over the last time it was
very hard for outside contributors to
contribute to react or to better react
and that has to a degree change is now a
lot easier to get more people working on
it and I maintain a fork of react or for
that reason because it was impossible to
get some of the changes I needed back
into the app upstream repository for
react or now it is a lot more likely to
have those changes implemented they are
not yet because I have one horrible pull
request I am
very ashamed of and it is a mess because
it grow over three years but I'm a lot
more confident that some of the changes
I required will go back upstream versus
before so I would say it's going really
well for react Heinz thank you for
answering that question now if you don't
mind I'll give a brief answer to that
from our perspective no - Marshall have
obviously cease trading all the react
customers that they were serving have
consequently lost react support but I
would really reiterate what kinds has
just said react has an increasingly so
an incredibly vibrant community we as a
company erlang solutions some of our key
partners and customers using react in
its different incarnations are
absolutely committed to the future of
react and are working with the community
to ensure that future through ideally a
fully open source product now just to
say that if you're using react at the
moment and if you're finding yourself
stuck in basically running into
obstacles then obviously the community
that Heinz mentioned is here but if you
need professional support then we here
at erlang solutions provide anything
from working hours working day support
to full 24/7 support coverage so
whatever type of help you need with
react we can absolutely extend that help
so I'll just move to another question
and we can probably slowly wrap up with
that Heinz you've talked a bit about
this but could you just reiterate what
kind of system would one use react Co
for exactly okay any system that has two
properties a it needs two well I go back
on that otherwise it becomes the Spanish
Inquisition Jo that has some of the
following properties it can be a
consistent so you are not required to at
any point in time get the same answer
from every note so if you're okay with
eventually getting the right answer in
some XK tsa's you're good and second you
have the ability to shout your work so
your work never requires the entire set
of data you're working on but rather you
have some kind of combination between a
key and a bucket that you can use to
chart your work off third you are going
to spread your system over multiple
physical hosts and know that you will
add and remove them and some will fail
and some will survive if you do not have
more than one note there's no need to
add a system as complex and react or to
your software finally you do not require
to handle storage you can build a
message queue on react or you can build
a pop subsystem you can build simple
logic where processing power is
scheduled on different notes on react or
that all works so the whole it is a
database is something you don't require
to be to react or to be useful for you
so basically a you okay with eventual
consistency and if you're not one person
sure what that means in your case I
suggest talking to someone who has
little experience be you are using more
than one note and plan to scale out see
you can chart your work whether it's
storing data or processing data or
sending messages as long as those three
things are ticked react or might be a
really good solution for you Heinz thank
you for that completely agreed so
basically stay on the right side of the
cab theorem so to speak depending on
your use case now I'm sorry to say that
we have to finish here we've received a
lot of questions some of them we will
have to answer in writing
as time is upon us so to speak I would
really like to once again thank Heinz
for an incredibly inspiring talk both
react or and Alma Tina DB are
technologies that we've seen widely used
across sectors and where for example in
the case of dommatina DB we've had
customers coming and praising its
incredible performance so I'd like to
thank many many many times as well all
of you who have joined us for the
webinar thank you as members of our
audience please join us again for our
next monthly webinar and I should say
that the next webinar will be holding
will happen on March 28th on that
occasion we will have the Eric Stedman
from eternity blockchain talking about
eternity and the topic of scalable smart
contracts interfacing with real world
data now please note that the recording
of this webinar and the presentation
that we shared today will also be
emailed to all attendees and will in
time after that become available for you
to view on our corporate website as well
at wwl and - solutions.com thank you all
once again Thank You Heinz and we look
forward to seeing everyone on our next
webinar thank you all for listening and
thank you a lot for having me it was a
real pleasure</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>