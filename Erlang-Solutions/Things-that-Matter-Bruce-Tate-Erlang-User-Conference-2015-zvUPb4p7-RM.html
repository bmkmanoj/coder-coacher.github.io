<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Things that Matter - Bruce Tate - Erlang User Conference 2015 | Coder Coacher - Coaching Coders</title><meta content="Things that Matter - Bruce Tate - Erlang User Conference 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Things that Matter - Bruce Tate - Erlang User Conference 2015</b></h2><h5 class="post__date">2015-06-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zvUPb4p7-RM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">not really starting at so and you know
some people were kind of panicking
Ronnie to sit down but I was looking for
a metaphor for you know things that
matter to so we were in the Ericsson
building right and in the Ericsson
building they had concurrency just
nailed down i was i was thinking earlier
workshops that i had attended you know
there's a gender discrepancy i don't
know if you've noticed looking around
the room but there's a gender
discrepancy and you'll have women's room
in men's rooms and you just can't put as
many people through but this had a
mixed-gender restroom so erickson got
the concurrency perfect right but then
there were the doors so the doors you
know they so you know Monica walked up
and she she said you know you can't use
that that that handle you know if you
turn that handle the one with a big
shiny green sticker you know that that
you know I don't read Swedish but i
think it probably said pull me please if
you if you pull that handle you would
empty the building right the fire alarms
will go off and then they have to kind
of empty it and she said well you know
it's a locked door you know that would
open it but it's a lock door you can't
use that keypad either i can't give you
the code there's a badge but the badge
might be on the floor and then so i
finally got the badge go activated the
door and then pull pull pull no push
Bruce you know so I'll push that you
said okay you got to be through in five
seconds you have to shut the door really
fast and then if you're not through in
five seconds will empty the room right
so what a great metaphor for Erlang
right so the concurrency is perfect but
the entrance door is a little bit off
right so this talk is called things that
matter for those of you who don't know
me my name is Bruce Tate I wrote a book
called seven languages in seven weeks
I'm a bit of a language geek and over
the time of writing that book in the
sequel I've gotten to meet a couple of
language creators josee in the front row
that created elixir Robert and Joe that
created Erlang but also some other ones
and a long long this process I have
noticed that these people got an
ordinate number of the
decisions everyday decisions right some
of the early decisions and it really
kind of perked up my interest and I
wanted to talk about this subject and
see if there are some lessons that we
could apply to our day-to-day code so
the first thing that I noticed when I
pull this talk together is that things
that matter are kind of hard hard to
quantify in fact they might even change
over time let's not Joe or Robert over
there and sometimes they're actually
pretty obscure you know is that
breakfast or is that is that really
Jesus there I told this story right so
the things that mattered to Erickson
were concurrency but not necessarily
getting through the door right so the
first thing that I want to talk about is
the first thing that happens when you're
actually trying to solve a problem the
incubator what's the thing that brought
this invention to be and if you talk to
different people you get different
answers for example with Ruby it's a
language that that people don't love in
this community but but if you've never
coded any Ruby the people in that
community love their language there are
a lot of things that are fun to use and
there are a lot of things that work
right the first time that you try them
it's not until you actually start to
scale that things start to break but if
you look at the incubator this project
was a hobby and when you ask mats what
is it that makes Ruby so special what is
that that makes it's something that
people love he said well I first built
it to amuse myself and I hoped that it
would amuse other as well and then and
then if you ask them why or what is it
that you like most about Ruby he says
aller like the way that it makes
programmers feel and one of the things
that we can learn in
any new community is how the Ruby
community was built in the first place
there's an acronym men Swan it means
Matz is nice so we are nice matts is
nice so we are nice and it's it's a
tremendous testament into the man is a
creator that that he answers languages
that he's humbled that he's kind that he
invites him visitors and one of the
things that that happened is this kind
of created this this close-knit tight
culture of developers that that really
help to accelerate the adoption of the
language how many of you have actually
seen a language called elm how many have
actually used it in anger so what did
you notice about the adoption in Elm
anybody what are some things that made
Elm especially accessible did you think
it was whoo-hoo hands up again if you
use down how many of you thought that it
was a particularly accessible language
haha wow so that's not a that's not an
answer I expected to get so normally
when I asked for hands among Elm users
one of the things that the notice first
is is how accessible how easy it is to
get started with the language and once
again it's part of the incubator it's
one of the things that Evan was trying
to solve when he created the language in
the first place so this is what he said
and he said many functional folks have a
way of saying extremely interesting and
useful things in a totally inaccessible
way right and his mission in life was to
fix this and it wasn't just a
programming problem it was it was a
problem of trying to look at the world
in a different way of trying to take
these academic lessons from functional
programming and apply those into a
programming environment and to him
the theory is not enough it's not enough
to be theoretically better elm wants to
be demonstrably better and I think that
if you look at the overall experience
when you're when you're getting started
with reactive programming functional
programming these are inherently
different things but they're
dramatically simplified within the Elden
language if you look at the Lua language
which is a pretty special language for
embedded systems Lua was created to
solve one simple small focus problems
and that's the problem of being a good
configuration language and actually when
I started putting this talk together we
gave a panel some of you were there in
San Francisco and some of the panel
members were josee and and Guido who
created Python and Robert birding who
obviously created or help create the
Erlang language and John Hughes and John
briefed us on the history of haskell and
talk to actually pretty frankly about
the process of what was in his head when
they were going out to create this this
academic language for functional
programming so he said that one of the
things that was really difficult for
them was that if you looked at
functional languages and you looked at
languages that had eager evaluation like
Erlang there was really academically one
language that everyone could point to
that was ml and if you were working
within the ml family of languages you
were pretty lucky because you had a
common language to talk about things and
reason about things but on the lazy side
they weren't so lucky he actually said
that there were as many languages as
there were researchers and there was one
language in particular that they were
all watching and that was Miranda and
the Miranda language was was actually
private and they approached the
david Turner the creator of Miranda and
said can we use this as the research
language on the on the lazy side and he
actually said if he said yes there would
be no Haskell today so he said that you
know from an incubator perspective they
had a target to point out they said that
our goal was to be not Miranda but like
Miranda if you look at closer closer the
goals were very specific we've seen many
lists dialects come and go this one had
a very specific goal wanted to be a lisp
for functional programming symbiotic
with existing platforms read the clr in
the JVM it since focused primarily on
the JVM but designed for concurrency so
it's pretty interesting that this list
of languages if you ask the creators
what they wanted to create they could
tell you very concisely let those with
those things were and if you look back
across that that list of languages that
early incubator very much defined the
experience of the language just for fun
I wanted to do one more
this is literally from the first
marketing statement from the first
marketing website that job ever put out
and then I thought hmm and I didn't know
what to think and then I knew what to
think right so think about the incubator
okay the second thing that I want to
talk about is the community and the idea
of the community to a programming
language especially a new programming
language has changed over time this is
what I mean so thank all the way back to
all the way back to the 50s those those
of you can you know check your history
books for those who can know there's the
Fortran and COBOL if you think about
this time all of these things were
stacked against the creation of new
programming languages there was a pretty
small population of potential users
there was a relatively small pool of
problems that we'd imagined that we
could solve with programmers there was a
relatively fixed access or controlled
access to information about the new
programming languages and the investment
for creating a new language was actually
very very high and then if you think to
the next generation go down to the go
down the travel down the path of history
and think about the next generation
major generation of programming
paradigms into object-oriented languages
so at the same time that Erlang was
created we had a relatively small
explosion of object-oriented languages
but so some of the things were the same
information was still pretty tightly
controlled for the most part the
investment for a new language was pretty
heavy so you'll see that all of these
languages were mostly commercial
partnerships and that were relatively
expensive endeavors but the population
of programmers had grown and the number
of problems that we were solving with
computers had grown pretty significantly
right so the economy the shift of the
economy has changed so the idea of what
a community is has changed but if you
look at this list and think about the
commercial investment that's behind
every single one of those languages and
then contrast it with this list the
story is very very different right all
of these languages started as pretty
small individual teams all of these
languages are on or on somebody's radar
for doing significant things some less
than others but all of them have
achieved some level of success and if
you look at it there's a reason that the
that the way that we view community is
different than it was just just ten
years ago right so we still have a much
larger population of programmers and a
bigger set of problems that we're trying
to solve but information about those
languages is freely accessible in fact
we saw a talk this morning about the
publishing industry and the struggles of
the publishing industry and one of the
things that's changing in that space is
that the Internet has made has made
collaborating on languages and
collaborating on the documentation and
and information about those languages
much easier and so the corresponding
investment has gone way down and the
tools that we have available to
collaborate on languages has gone way
down so from an incubator perspective
from a community perspective the
investment that's required is much much
lower and we're seeing more languages
thrive is
as as a side effect but one of the
things that means is that you have a lot
of competition on the language base an
accessibility matters a lot so we talked
about the community that matt's built
when the Ruby when the Ruby language was
created it still wasn't tremendously
popular right out of the bat but it did
get enough of a controlled a nice
healthy incubation period where we could
build a kind community to the point
where somebody found it built the rails
framework and one of the things that the
original rails team got right was the
accessibility there were articles about
how to build a blog in five minutes
there were tools for there were there
was a there's a package manager for
delivering software there were tools for
building for building things very
quickly and integrating Ruby and the
overall build system the tooling was
beautiful for new users and the
community was primed to support those
new users as as they emerged and
actually many of those lessons are being
heated in the elixir community so how
many of you were here last year for
Garrett Smith's talk on why the cool
kids don't use early right and how many
of you stayed in the same room for four
Eric's talk about about the tooling
around the elixir platform it was a
pretty stark country was it was a pretty
pretty interesting symbiosis between
those talks right so almost all of the
of the things that were barriers for
adoption from the tooling perspective
we're we're being handled were being
addressed by the people on the elixir
team and the reason is that there's some
experience from the Ruby community
actually in
that elixir team and I'm not saying that
we want erling to be to be another Ruby
but I am saying that we can watch some
of the lessons from the Ruby community
as far as language adoption and if you
look at so I mentioned elm-in-elm as a
language that was pretty approachable
this is one of the things that I mean
when you go to learn elm if you were log
on one of the things that you'd see is a
big button that says learn and when you
press that big button that says learn
you have examples if you press one of
the example buttons you might see one
that says chart and you see some code on
the left-hand side and then you see a
result on the right-hand side you can
change the code press compile and then
you can see the results change on the
right hand side right so there's no
barriers for adoption there I can sit
down I could start to learn I can start
to experiment with them and make a
decision about whether this is something
interesting to me or not right off the
bat so I think the lessons are 21 know
who your audience is and second pay
attention accessibility really matters
ok the next point that I want to make is
that good language designers are
opinionated it takes stance right and
sometimes the stands are about something
minor like syntax pardon the bad pun
continuing a bad pun so one of the
stands that I might take is that syntax
might make users more productive and in
fact you might might not be surprised to
know that Ruby builds in a lot of syntax
and and takes this case to this
individual stand and it does shape the
shape the overall experience in the
language right there are some other
syntax bets that I can make
I don't have to take this one is if I'm
to make a unified stand one of the
stands that I might take is that syntax
must be simple for example if you look
at small talk or closure you see a very
simple very clean syntax or you might
decide to go a little step a half step
further and say that syntax must be
profoundly simple in uniform right so
data and code is the same thing I oh
really is a prototype language with very
much the same simplicity in the syntax
tree or you could say hey wait a minute
this besaid that most of the value from
from a clean syntax has come from data
and code represented in the same thing
you might say we'll wait a minute that
gives me value within the syntax tree
but I can have a beautiful clean and
simple syntax tree and gain the same
advantages even if I have a significant
amount of sugar in my implementation and
that's the bet that's made from elixir
okay you might make another bet you
might say that syntax have has a
profound impact on the language from a
market share of perspective right and
we've seen that a couple of times in
Java and JavaScript in fact we've been
as a programming industry we've been
dominated by cee cee like sin taxes for
30 to 40 years these are some of the
other stands that we've seen languages
take through time so Haskell decided
they wanted to be a functional language
but being a functional language wasn't
enough they wanted to be a lazy
functional languages they wanted to be
pure because the academic study was more
valuable in a pure space when they could
talk about when they you can talk about
functional programming
with everything stripped away they
believed that static typing could be
beautiful and in fact you could actually
see some of the things that came out out
of of this so Haskell had had this thing
called type inference and we've seen
type inference before and out of type
inference came this this desire to to
simplify one particular type of
inference and so they built something
called a type class and the type class
became one of the coolest features of
this new language that was based
understand that they took nothing erlang
is a language that we all love because
some of the stands that were taken early
on in the evolution of the language make
them currency simple in fact when I see
Java developers read Erlang for the
first time many of them nearly fallout
fallout of their chair and they say well
wait a minute you're creating objects
you're creating processes like I create
objects your this is what message
passing is supposed to be like right and
this is what the concurrent system that
they were no condition to think of as as
something that was inherently
complicated and you know my shirt has a
stand right keep calm and let it crash
have you guys heard about the story of
Francesco and his team getting onto the
plane when they're all in this fresh out
of the San Francisco conference they had
to let it crash t-shirts on I think
maybe that's it that's the sweetest
thing you know Erlang ok Volvo's ok
airplanes not so much right so elm I
think it's a great language for taking
Stan's Elm that builds in the
theoretical ideas of reactive
programming to something too and takes
those ideas to the browser right and so
Elm shares a little bit more history or
a little bit more
what motivation with the airline
community they both believed call backs
up so I think it's important to make a
stand so the last thing that I want to
talk about today is the idea that that
languages need to be able to adapt they
need to be extensible and the way that
this happens can vary widely from
language to language but the way that
this happens strongly shapes the
character of the language that you're
working in high so if you think about
inventions through time some of those
inventions are built on by other
inventions all right the gear to the
wheel to the printing press electricity
to the transistor and if you think about
it we're trying to accomplish the same
things in code we want to take simple
pure idioms we want to sound surround
those with common abstractions so they
could fit together in greater ideas that
can be shared across time or across
problem spaces right
and if you look at the capability of
meta programming then there are levels
of meta programming there are things
like parse transforms and Erlang or by
code and enhancement in Java there is a
much more dangerous but fun form in Ruby
I don't know whether to laugh or cry
here read that for a little bit I'm
redefining string redefining Neil Neil
class and redefining object on the fly
opening up the concert at class dumping
whatever right into it that I want so
that I can do this common thing right
you know there's a more extreme form of
the same thing right so for those of you
who haven't seen it before this is Lisp
code means add one to two it's also a
lisp macro this version can be executed
this one won't be executed and so you
could treat that code you can reason
with it just like you were reason with
the program right and you can change it
and you could dump whatever stuff in
there that you want to write is that a
good thing is that a bad thing what it
is is a stronger abstraction we're
letting the user run with scissors and
the philosophy that you use is going to
be pretty dramatically different here's
an example in Erlang how many of you
have written code that looks like this
well most of you right this is a task
right so I'm spending something out as
I'm doing some work spending something
off and then waiting on the work a
little bit later on right that shows
days code indian food on the way thanks
guy in elixir we're able to distill
those ideas into something that's
a little bit more focus right so I'm not
taking saying that macros are good or
bad but I am saying that there are a
higher level abstraction that lets me
lease reason about things in in a higher
level way it's an idea it's an invention
that builds on another invention so we
can look at a couple of abstractions now
there's a pipe operator the pipe
operator basically means the same thing
that it does in UNIX you can take the
input for one thing and or the output
for one thing and channel it into the
input for something else ok we just
talked about macros think of that as
mail merge per code and the mail merge
for code it essentially lets me it
essentially happens at compile time so i
can change the definition of the
language on the fly and that's a good
thing and that's a bad thing right
there's something called def protocol an
elixir also and def protocol lets me to
find the types of things that i can do
the types of functions that I comply to
apply to a given data type so that if I
have something like innumerable types a
collection i might say if it can be
enumerated then I can do this set of
operations on it right so when I combine
those abstractions I get something that
looks like this so maybe I have a set of
widgets right like a filter through them
or map through them the syntax doesn't
matter but what does matter is that
these might be list methods but it might
be piping streams through that where
this is eager and this is lazy but the
things that I build on top of that
continue to work right so that's the
protocol so when I mix pipes protocols
in macros I can do something like this
maybe I have something really expensive
that's happening in the stream maybe
what I'd like to do is something in
between these steps that packages all
the stuff before up into a process or
maybe what I'd like to do is packaged it
into something more sophisticated like a
process farm or maybe that process farm
is sophisticated enough that it needs to
be managed right so this is the rising
level of abstraction that that's really
what higher level abstractions are about
some other examples haskell we talked
about the idea of types being beautiful
types being very important to the
language one of the things that you find
in haskell is a type class and the type
class can be extended in a beautiful way
Elm we've talked about reactive
programming and reactive programming is
very complicated with traditional
languages but if you raise if you raise
input output to a higher level of
abstraction if you make it look like a
stream which is which can be looks like
a function to other other lmap is then
we take these these complex ugly
architectures on the browser and they
become much simpler and much cleaner or
if you think about Julia the scientific
technical computing language that raises
the level of abstraction for working
with technical data to the point where
you can do things to to a single cell or
rows and columns that are distributed
across a network or idris where you have
classes of types but the types can be
extended with code so i can have a
vector of em and a vector of n and
adding things together gives me a vector
of n plus n alright so i have type
safety with code encoded in the type
itself and I notice when I was building
the examples for Idris in the seven more
languages book that I found myself
thinking more about the types than the
programs and most of writing the
program's was done with completion I
would just fill in small details and
sixty to seventy percent of the program
was filled out in in the code is that
the right way to think about programming
I don't know but it's different and it's
a programming paradigm that's changing
the way that I think because the
language is adaptable from the the type
system so I want to wrap up to save lots
of time for questions and comments
probably more comments and questions for
this talk right but I want to talk first
about I want to first remind you of the
of the messages that we've talked about
the first one is the incubator matters
know who you are the second one is your
audience matters know your customer the
third one is um you will make a much
better product if you focus and take a
stand and the last thing is that the way
that you enable the world to extend what
you're doing will shape your success or
your failure questions and comments
questions over here Michael phone
is it on
did you guys get the comments there were
two comments 1 is that writing languages
is hard and I wholeheartedly agree and
i'm really not advocating riding a
language to solve problems I'm sorry
that wasn't clear that's my mistake the
talk was talking about looking at the
decisions that language creators have
made and learning from those decisions
so thank you for that in the second ok I
see I see so creating a language allows
me to extend or creating a macro allows
me to extend the languages the language
on the fly and that can be difficult to
understand and difficult to maintain and
that is absolutely one hundred one
thousand percent true right so when you
have a language it allows your users to
run with scissors and your users heck
this idea of letting users letting even
language creators run with scissors is a
dangerous one and you can argue that
that this feature has suppressed or even
almost killed Lisp over the years right
because there are so many variants of
lists that are popped out but the
languages that have macros built in our
building with higher levels of
abstraction so those languages tend to
progress very rapidly so what I'm saying
is that it is it's a double-edged sword
you know if you talk to the closure guys
they say the first rule of macro club or
macro club is what what's that say
louder the first year rule of macro club
is don't use macros right and there's
some audiences I could say that too and
they would shout that back to me right
and then right after that the closer
guys say but if you do but if you do
this is this is how you do and the good
that can come of it so great comment one
hundred percent agree it's dangerous
it's useful to so other questions or
comments yes
you guys get that comment and so they
should be used on this in the same
spirit of the people who would design an
erlang behavior now I think that that's
a great analogy and in fact if you look
at the overall ecosystem within a
language it's only the top few percent
of the people in a language that that
right macros right so but it does enable
me to do things like like create a
language that's more expressive for
solving particular problems like process
flows and you know the example that we
walk through where maybe I want to pipe
things through a single function right
now and expand that to two processes or
process farms or something manage with
OTP in the future and in fact the the
illicit core thing the core team they're
working on interactions like that so I
didn't do this this part of the talk
justice if you want to see see much
better much better view of that part of
the talk at Enzo's a stock at what time
tomorrow 12 12 10 its can somebody look
it up for me 11-50 almost almost
shortchanging if i buy 20 minutes any
more questions comments insults thank
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>