<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2015 - Tristan Sloughter &amp; Fred Herbert  - Rebar3 | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2015 - Tristan Sloughter &amp; Fred Herbert  - Rebar3 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2015 - Tristan Sloughter &amp; Fred Herbert  - Rebar3</b></h2><h5 class="post__date">2015-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/v_boPIY9y-8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright thank you everybody for being
here today's talk is rebar 3 I'm Tristan
slaughter that's Frank Herbert from
we're both from Roku you probably know
Fred from learn you some Erlang great
book if you haven't read it read it and
we're going to be talking about the new
build tool we've been working on rebar 3
yeah and one of the quit well let me
start off with since so many people
raise our hand there the first time
they've here they're here is how many
people have not used a rebar right so
your ills saying in some ways yeah so
good like a who wear yeah who here has
had issues with rebar as it yep better
this isn't this is an easy sale then so
yeah it actually turned out to be an
easier sell than I thought when we
started the project of essentially
blowing away what was in rebar except
for some very core components I was
worried but it turned out to work out
pretty well and allowed a full stream
the it's going to go away so rebar
introduced a number of really useful
things to the erlang development
community it was it was portable and
convenient you could just it was a nice
grip that you could just put into your
repo so anybody that downloaded could
start building right away it wasn't a
complicated Meg file or confusing to
install sinann it just worked once you
had it and he was developed by very
smart people at bash oh and they're
building very complicated applications
and releases so it had massive amounts
of features and test Suites and fairly
good documentation but it basically had
run its course like all good software it
ends up getting rewritten that's what
happens and maintainer ship was handed
over to
Fred and I at Heroku from dash 0 and we
initially were just sort of maintaining
the rebar to try and try and try every
bar to and it was problematic uh the
well I mean one of the first things I
did was close hundreds of tickets I
think that were over four months old and
people were upset with that yeah many of
them were still valid but there was like
a hundred fifty of them open and we had
no idea where to start so we just closed
everything that was old and if it was
important we would reopen them again
turns out that maybe 80 tickets were
closed for good that time so help ended
up being good for us yeah good but it
showed there was a problem in maintainer
ship over the years that it wasn't going
places that needed to go and features
like update devs were simply completely
broken and they weren't going to be able
to work in the current structure of how
rebar worked so we knew we needed to
start from a new place and rebar 3 had
some main objectives we started el whip
of we want to make files were everywhere
everybody has a make file for the rebar
because you have to do rebar get depth
compile all this stuff to do anything
that actually works al number of
features like dialyzer aren't there
anymore so you have to have a make file
to have your complicated dial at your
command we want to get rid of that so
you still might have a make file for
compiling your seat code if you have an
if or something or if you have a really
complicated program structure you might
even have a Java in there and stuff so
you might have a make file but for the
majority of use cases you should not
need one and should not have one we also
went with OTP or nothing it discovers
your applications and it builds them and
it knows what they are whether they're
dependencies or they're just your
project apps that you're working on no
traversing into all the directories to
say hey what is this should I compile
this is this hour long is this a
protobuf is this whatever no OTP
structure
on the app's build them we wanted to be
so easy in that sense that there's no
you know if a command like compile needs
dependencies it will get your
dependencies you don't have to it won't
just complain because everybody hates a
tool that says hey you needed to run me
to install dependencies person right
well if you know that why aren't you
just running it for me just do it you're
yeah you're a computer and predictable I
think predictable is the most important
one that we really focused on and rebar
too had a problems with is that we
wanted predictable builds that would be
reproducible everywhere and that was a
major problem especially with update
depths and and well anything because
everybody used master for their
dependencies but that and extensibility
and but predictability I think is one
thing we're going to really hammer on
I'm afraid we'll talk about more in a
minute so the roadmap we are currently
at alpha 2 so we've been at alpha and
we've had a number of fixes go in it's
looking pretty good I mean we've got
packages comment st unit all the good
things dialyzers back so it's definitely
usable and people are using it we're
using it at Heroku so it works there's
going to be still a number of bugs so
just opening issue we're fairly fairly
responsive on IRC or just on github so
hopefully we'll get any kinks worked out
soon and we can introduce beta and
finally get to a final release which the
ultimate goal would be to the rebar to
compatible with plugins so any issue
with you know proto buffs or any thing
we ultimately took out because it wasn't
a core of compiling an OTP app is there
it's ultimately very hard for us to
maintain features do not use and we're
going to have a very bad service bad
features bad implementations if we do it
that way so everything that we
personally don't use in any of our
projects like that we've taken out and
we expect plugins to replace them so
yeah what about
sir dependencies sort of dependencies
we're somewhat working well with rebar
and somewhat working terribly so one of
the problems we had well there were a
bit verbose so we have this simpler form
that's now introduced you still can
depend on something and get with a good
protocol get with HTTPS we kept
mercurial in place HTTPS and ssh all of
these are seen as equivalent so you
don't have the problem of trying to
update a dependency but because the
format of the URL change everything
explodes all the time now this is a
simple format which is it's not the one
we recommend and actually if you use one
of these you're going to get a warning
telling you to please one of these so
instead what we want you to do is use a
where's my hand here huh so you can use
a reference that points to a direct hash
you can use a tag directly for that to
point out one of these over branch
specifically and each of these I mean
can be mute can be mutable except the
reference itself so every time we do a
check out and lock the dependencies we
extract the underlying reference so that
the next time someone builds it from the
lock file that we now billed
automatically it's going to have the
right revision that you won't unless
someone went and deleted that stuff and
those are really important for updates
because if you simply put a tag but you
don't put that it is a tag we don't know
if the tag or a branch so doing an
update we don't know if it means you're
actually wanting to go somewhere else or
it needs to stay the same it's really
important to have those if you want
source dependencies to work correctly
right yeah we we don't really support
anymore the one where you just replace
the entire bit here by just master with
the name of something well we do support
it but it you shouldn't expect good
results from that we want to keep it
because of backwards compatibility such
as these features so rebar to had all of
these things where you can put a version
delegates or a dependency or both and we
supported them we don't support it
anymore in that we accept the format but
we just ignore it entirely rebar 3 has a
change in that we don't give a crap
about your versions that you use it's
purely for people the real thing we
currently ignore it no reason to bring
it back that we've seen so far but yeah
we just ignore it so that all existing
libraries or most of them at least that
Don dependency or proto buffs can still
build and kill you can still be used it
would be very very hard to drive
adoption on a project that kills the
entire open source community that we
have so far yeah library versions are
held so I mentioned that rebar doesn't
use versions we don't trust them and the
reason is simple is that instead of
having a new tool that we apply to the
community and then people subscribe to
it we come into a community that already
does everything wrong which is the
airline community the branches we have
our bad the tags we have or bad the app
files versions that we have our bad
they'd honestly match together it's
possible you have the tag v 1.0 point
one but inside the f file it's still in
0.9 it doesn't have the v the format is
not the same it's absolutely not usable
and it's hard to really describe what
would be a canonical version for us to
use on an source file and if you go into
places like mercury olive branch and the
tag is somewhat vague as a reference you
can have both but so it's really really
hard the semantics and taxonomy are not
clearly defined in existing projects
people can do whatever version they want
and nobody in the community has told you
before to please use semantic versioning
a lot of us are trying to do it and we
still do it wrong but we're trying to do
with and we can force people to do
everything and please revisit all the
versions of all the libraries in the
world like people have suggested we do
that and I just told them that I don't
have that time to do with it Tristan
doesn't it doesn't have it either so we
just don't care about that so we say I
don't have a life or that I don't have
the time oh really ah yeah that means we
don't do semantic versioning and every
time people ask us if we're going to do
it the answer will be no just as an
example we decided to go into hex p.m.
because it's part of the package
management we do Tristan is going to
talk about that and we looked into the
900 956 libraries in there and only 100
of them have a version that is not zero
point something and semantic versioning
a version below zero point something
means that you cannot infer anything
about the version you cannot use it to
match anything
if you don't do that well technically
you're not doing proper semantic
versioning submitting version he also
tells you that if the app is in
production it should be one point zero
point zero so what we have is either a
community that generally doesn't have a
lot of Production apps or community
doesn't respect semantic versioning even
if they have that as a policy so we just
don't trust versions we don't just
programmers were a terrible breed of
people we just go without it yeah so I
have that little eggs as someone who
puts a lot of code in production that is
not one point oh yeah I mean with all
the time ourselves are you gonna do uh
what's my I forgot where I was fetching
dependencies yes so instead of actually
doing stuff we have missed recorded in a
dense never do live coding it will
always fail recorded right right okay so
we are in that file and we declare
dependency in that case it's cowboy
would have given tag is going to be
really simple there's a package in there
that we have that we know is in there
it's going to cover what your son's
going to talk soon so we have these two
formats we save a config file you can
ignore everything else that's in there
it's for different demonstrations oh
yeah forgot idea to do that good thing
it recorded it let's swim yeah yeah we
add the dependency in the file itself so
that we're going to be able to build
stuff with a little bit later but yeah
and then we're going to call it just
rebar 3 and you'll notice here that it's
in the actual system path this is
something we want people to start
possibly doing a bit more which is stop
bundling rebar in every freaking
dependency because at some point you
build a release that has 50 apps and you
have 50 copies of rebars and only one of
them is being used so if you have a
rebar 32 ship with an application make
it in the top level one that shipped the
system not in all the smaller ones if
you have plugins and stuff like that
there is a way to configure it so it
gets bundled with everything and it's
going to be fine so we fetch
dependencies this is super slow because
it was my connection back home it's a
bit slower than here maybe sometime
internet farther away in Canada so you
see here
cowboy was being fetched entirely fine
cowboy depends on collie Ben ranch and
doesn't use a notation for branch or
whatever like that we get the warning
and then it compels the other code
compounds all the dependencies in order
and then my app is built what's
interesting is that we have this
application structure that we decided to
use because we're very very fed up with
rebar just putting everything at the top
level dependencies having to maintain a
annoying ignore file everything is in
underscore build so when you go in there
there's a different building all the
libraries that we have compiled are
going to be in that one and then it's
done everything else is in the top level
you just have to ignore that directory
and nothing else any questions about
that yeah meant to start at the
beginning like if anything seems weird
or wrong bring them questions now we'll
have Q&amp;amp;A at the end but does that don't
wait if something strikes you is very
wrong yep so conflict resolution
everyone here has had what we call the
mech hell sooner or later where you have
all your dependencies are running tests
and you all have a proper version of a
mech version of a cowboy version and
everyone depends on a slightly different
version and rebar to explode in your
place and tells you that there's a
completely resolve it and you have to go
and fork everything put them all on the
same version and try to fetch them again
it's a terrible experience overall so
because we don't give a crap about
versions anymore we're able to do lever
order traversal which means that when we
fetch your dependencies we started the
app at the top and everything that comes
back as a duplicate we show a warning
but we don't download anymore that gives
us something that is entirely
predictable so if i have this
application in pink anyway and then i
have the dependency a and a dependency
baby in order a is going to be fetch p
is going to be fetched i'm going to look
at the child at the children of these
applications then i'm going to look at
sea than a d1 and i'm going to build
them and fetch them at that point c has
a dependency on d 2 but d1 which is the
first version of the as already been
downloaded at the level above so what we
do when that happens we just don't
download d2 we show a warning and
whatever see would have had at the
bottom there that would have been a
cycle could have been
detected because we do cycle detection
now to avoid rebar going in the loop
forever but it doesn't happen because we
never needed d2 if I really really
wanted to have D to I can just bring d 2
when the top level of my rebar file and
just because it's higher in the ER key
is going to resolve the conflict
automatically and what is interesting
about that is that by doing this we have
allowed us to fix for good the upgrade
feature that now works and is
predictable the thing that everyone
would just blow where their depths and
redownload all of them every single time
is gone for good and I can't say how
happy I am about that so I'm in that
file I'm people actually clapping
upgrades work that's how far behind
we've been with tooling yes in that case
I'm trying to update cowboy to a new
version in the dependencies I had and
moving from one point zero point one to
something else I have the upgrade
comment for that if i try to a great
ranch it tells me that i can't do it we
cannot upgrade transient dependencies
because it doesn't make sense those are
dependencies that i have never specified
in that project the only dependencies i
have specified in my project are at the
top level so if i want to upgrade a
dependency i have to bring it at the top
level or upgrade a top-level dependency
so in that case i'm updating cowboy is
giving you the same warning the new
version of ranch has been downloaded
every other I dependency I had has been
left untouched insane and if I remove
transition' dependencies and the
structure explodes it gets to work fine
yes does this apply to version numbers
or to get your lsat well so the version
numbers that we use are to fetch tags or
branch or references and what we do is
use the underlining reference so when we
have a tag version or something we
compare the tag version that is now in
the config file you have with the hashes
that are on disk in the app that has
been fetched and if the differ and the
app has been specified to need an
upgrade we upgrade that otherwise if it
resolves to the same comment we don't
need to touch it it hasn't changed right
so if you're da tap file has version 1
and
you say do an upgrade and master that
you now relied on has gone forward and
commits but now says 0.5 that's still an
upgrade because we assume that nobody
puts the right versions and anything
yeah so right it checks that so what
what it considers a diff it considers a
change between your lock file and your
rebar config-if that remote changes and
it sees what it needs to do yeah so it's
going to check and it will it will
simply get the new version that you've
set instead of what rebar to would do
which I don't know if anybody even knows
probably just blow up yeah so that's
your girl mechanism and so far we've
been able to use it without a problem we
have an upgrade mechanism that finally
works which is pretty cool because I was
tired of four done no I don't know if
anybody else I've never used the upgrade
depths because it just never worked for
years yeah and then it use it once and
then you find out that it doesn't work
and then you never use it again and then
I we were developing rebar three and I
was working in on a project at work and
I was like nine I need a new version of
this like let me try this and I ran it
and it worked the lock file was updated
and everything by golly we've done it
it's alive so yeah we uh we mentioned
packages you don't need to rely anymore
on get repos unless you absolutely have
to I mean I think that's always
important thing to have it like just
never not have the option to fall back
to some either bleeding edge or just
some random person's git repo that they
never bothered to make a package out of
even though you could do it yourself so
a new syntax that Fred actually already
shown
stealing my thunder in his presentation
that just a name and aversion the
version actually does mean something
here but it's not you'll notice there's
not going to be any like greater than or
less than it's used in the same way that
versions are used in the source
dependency resolution acts and
everything but the first one you find is
the highest level is is the winner so
you can simply say also cowboy and it
will give the newest but here to say
cowboy one point 0 point 0 0 and it will
get it and right now they are their
source dependencies and as I mentioned
package versions are for humans not
rebar 3 so it won't care much about
that's just about identifying the
package yeah the endless Sun there is
that nobody does version rights so we
decided not to trust anyone with
versions like nothing in rebar uses
versions except as an indicator of what
restores to fetch ultimately but there's
never any conflict resolution that uses
that it's simply a reference of this is
a unique snowflake so you want this one
you get it yes oh so back to source
dependencies we're on package
dependencies now but now so it actually
it doesn't every time what it does is
but if you want to do like an upgrade
because it is the the Shah in the lock
file it will check if those have changed
so if you say do an upgrade and in your
rebar config you have master set it
checks that ok those have changed I
should do an upgrade yeah all packages
go into your project directory we're
keeping the same a basically sandbox
environment that everything that's
installed to underscore build and that's
what you work from yeah so if you're
actually using rebar there's a couple
useful command packages will list all
the packages that are available
if you do this today you will get a
whole bunch of elixir packages that will
not install I mean they'll download and
they'll fail to compile if someone wants
to write a nice plug-in that makes a
that not a problem if you really want on
a lecture package that would be awesome
saying the update it will update your
package index an important thing that
I'm very strict about is it only goes to
the internet if it absolutely if the
user asks it too so if there's so
running compile will go to the internet
because the user is asked to compile
something that it told it these are the
compiled dependencies and they are on
the internet but other than that it will
not except for like update which has to
will fetch the new registry and change
what packages are available and all this
is based on hex p.m. from Eric right
there a really great it's an it started
as an elixir package manager and we're
hoping to combine forces for the greater
good and fewer work less work for
ourselves because we don't have to write
one from scratch yeah we're also lazy
yeah well yeah it'll be yeah they've
done a lot of great work in whatever you
think of a lick sir they've done around
a great great working tools not just in
package managing the building that is
great to be able to unite forces and
really move this along we've done the
same for releases with hex RM that uses
relex and we've been communicating to
try to make that as good of a
combination as we can which I'll be
talking about it in a little bit right
now it's all a source beso still when
you get your package it compiles it my
dream world is binaries which I found
has been the greatest pushback from the
community on which I found odd like if
you have an OTP app I want an OTP app
and its beams I rarely have special
different compilation for certain apps
the that matter so that's an interesting
one I think if we provide it as an
option it's going to be good I really
hope that that would make all beam
languages be able to work together
because you could still get an elixir
project and never have to worry right I
can build it and you could get a rebar
to project and not have to worry if it
builds with rebar threes slight changes
in configuration because it would just
already be compiled list anything it
would be portable at the same time would
just be faster overall question from
chatted where do we store the fees I was
thinking in the distributed hash table
like Bitcoin mind I put in the block
chain but uh uh well right now I mean
it's the same Eric's already been
working on some of this for hex it's all
stored right now in s3 but I mean it's
an interchangeable storage layer but yet
right now packages are short nestor e
and the beam ones would be in the same
place yeah but yeah I mean there's
obvious different buckets and stuff like
that keys they're still work on going
for that and you can use packages and
source dependencies at the same time in
the same project that's why they use the
same resolution rules and at the same
time a source application will always
have the presidency over package
application yeah yeah skip that point
yeah yeah that's an appointment yeah
Zack if we will be able to say no action
on the one debated at the top level yeah
you need to put it on the top level if
you want that that's the override
mechanism we have you want a top level
you want it to be taking percentage you
put at the top level because otherwise
rebar 3 just goes through sewers
dependencies and then package
dependencies to fetch what is not there
yet it's gonna be the answer always too
I mean I get it to fetch this one have
you tried putting it at the top level
and yeah I mean eventually will be nice
if more people end up moving to packages
we won't need to worry about that and
source will always be there but if we
had to flip that
ken ism at some point there's never a
way to get back to source dependencies
yeah I think it's an important point to
mention to make sure the transient
dependencies are still overridden by
source dependencies so if you're using a
package cowboy you can have a specific
source ranch and that will be used and
it won't be overwritten by the binary
package but you'll still get that binary
cowboy but yeah overall if you want to
configure something specials it goes
into your top level of configuration
file so at that point you just put the
dependency you want there and you get
the same result so yeah what about the
test depths we mentioned our friend make
a few times there's propert is kind of
the same you saw in the little screen
cast recording thingy that we have this
kind of big blob in there and this is a
new configuration element that rebar 3
understand that is called profiles and
the profile lets me specify particular
overrides forgiven runtime environment
so I can decide to run my operations as
a production compilation step with
something and then or a production
release and then relax will stop will
start including everything you know TP
and my stuff if I want only test I can
override the dependencies and specify
that I want mech in there and what will
happen is that we have the fancy pants
on tour rhythms that let us merge these
prop lists in a way that seems to work
all the time see I never be repeatable
yeah it seems to be repeatable we
haven't managed to do approve by
exhaustion yet but so far it seems
pretty ok ish we're waiting for quick
checks from yes / 2 yeah bit so yeah so
when you run a command as a profile you
do it like that you have rebar 3 as prod
release rebar 3 as prod comma another
word release so if I have special
compilation compile options or release
options for OS X compared to I don't
know linux or windows if anyone uses
windows with that it's going to be able
to fetch the particular options put that
in your stuff and make a special bill
that's adapted to that this is something
that we always found extremely painful
with rebar too we can do it with an
environment variable but that one
supports only a single profile and then
when you call rebar compile it does it
something interesting also is that some
commands are
able to say I always want to run with
this profile so comments like comment a
story unit will specify that there was
they running tests comments so if you do
rebar CT is going to know in advance
that it needs to fetch mech even if you
hadn't done it before and then it's
going to be able to go run the actual
test with all these dependencies in
scope the other thing we added one our
other rights so one problem that comes a
lot with rebar too if anyone has dug in
that is that some tuples are inevitable
in all your dependencies and some are
not in your configuration and you just
have to know them there's no quick way
to do that so when you wanted to
override something you had to remember
whether it was inherited and if it was
not you needed to for the dependencies
and do all that kind of stuff so we got
rid of all the inheritance that we have
my default and what we do instead is
have however rights so we can decide
that for a given applications i want to
add a piece of configuration it's going
to be adding it to whatever merging
mechanism we have if you have it with
another ride instead it means that you
want to replace it some things you
cannot unset so you need to really crush
the value that exists you can do with /
dependencies or for all of them so if
you want to really just override a given
option you don't liken it one and you
can do it and if you want to run I don't
know the lagger bars transform over
everything you can do it also so we
authorize like that we're able to crush
all the configuration of transient
dependencies that you need to actually
update I'm and showing them we have
another pretty small screen cast there I
think there was an important point of a
number of things that the configurations
stayed the same with rebar too but a
number of things that rebar to you some
people might have worked around because
they were annoying or intricate features
that worked for them in certain
situations are going to be some of the
pain points and upgrading but we have
features to make those more explicit and
more repeatable so yeah so for example
right now we still have the same file
here we ever relax that by default is
going to be in dev mode it will not
include the runtime system when we run a
production compile it kind of compiling
that we usually
generate wanted and ship into production
then we can override the dev mode and
all these things but for the regular
development you have you can have very
fast releases that work an explicit way
a simple way so we can also add a few
profiles there that one is going to be
adding the mech dependency to the tests
like we do in pretty much any project
what is cool about that one is that will
stop shipping mech and production which
I found pretty appealing in general
instead of having an entirely duplicated
rebar kind of thing that you run just
for tests and then you put it to a
makefile not need it anymore well if
you're building releases you wouldn't
get back in production anyway but so
yeah I'm a bit confused with my comments
when I do that so yeah at that point I
just compels a test I had no tests to
run it verified a dependency found that
mech hasn't been fetched before is
installing it and what we do here that's
fairly interesting is that everything we
had fetched in the default profile we
now transfer to build in a different
subdirectory still an underscore build
but everything is symlink so we don't
need to duplicate it on every single run
we do it's being reusing that but still
giving you a different environment so
when we look at the whole thing we have
the default profile that's at the top
here of the screen and then the test
profile just sim linking to that the app
is compiled in you for the top level and
mech is added specifically in that one
so each sub profile has it sound stuff
it can have it sound plugins all the
bills are independent like that and if
you use a comment like rebar shell you
will be able to have all the things in
your path according to one so you can
have a shell for your test cases or
shell for everything regular and all
these comments take care of these
profiles so yeah I felt angry at rel two
before if anyone has read the chapter
about many people have felt angry but
yeah it would you can talk about your
chapter yeah my chapter is like here is
how you do a real up easily with
relative or something and it's a 27
bullet point list don't want that
anymore I I found it easier to not use
rel
and just use the direct tools than to
use rel tools so we wanted to get rid of
that and some people might have heard of
relics which has been being used by
people that use rebar too and it's a
little fault release builder and like
our leg make so that's what we did rel
tool is no longer officially supported
by the rebar it obviously can be used as
a plug-in or as a standalone but we
believe relics as a future and not just
because I work on it because it's better
oh it's really since realex came out
people started building actual releases
and it wasn't just not like the people
at Bass show it and yes / Lewis Anderson
than two or three other people like
since relics came out people actually
use releases and we wanted to keep that
going so that's why we made that
editorial choice in the tooling of rebar
3 right if both in providing in some
cases a limited feature set compared to
rel tool it provides also some more
useful feature tools like dev mode which
simply links to the built applications
so you can compile very quickly and you
don't have to rebuild your application
to test any changes you've made your
release is built it links to it
recompile you're good to go and useful
ones have some good documentation in
support for cross compiling of you know
point to this is an earth that's
compiled for San OS I'm building on Mac
but I want to include this Earth's in my
release so I can deploy it and it'll
actually it'll build your tar file it
includes all the node tools so a number
of features that were unique to rebar to
and not a relative like no tool and
other functionality it gave you is
included through relex and they've been
thanks to the community not to to me
been drastically improved from what was
first introduced in like no tools they
work so much better and
in more obscure cases so it's really
come a long ways and this is a great
example once again Fred kind of stole my
Thunder I do that all the so we have a
rel X you can also you can put it in if
anybody's use it already they're used to
relic stock config but no reason to do
that you can put it right in your rebar
config and define what your release name
is which apps you want to include we're
going to have dev mode because our top
level default profile is obviously
development that's what we're doing we
don't want to include er it's because
what's the point in copying that when
we're just developing and we want the
extended star script that's just the
node tool stuff all the fun goodies when
you don't just want to start your
release but you actually want to do more
complicated stuff running in production
but it's still useful for even
development and then we have a profile
for prod that turns off that dev mode
because we need to have the actual
dependencies and not symlinks and we
want to include Earth's in this case
because it's more useful for deploying
you don't have to install Earth's
beforehand you had screencast around you
want me to put them on yes I do yeah
dimos that's my laptop and it's a
french-canadian keyboards with Tristan
is not able to use that working American
company this is like my security feature
number one Greek to me want a template
first and go with a template first yeah
so we updated all templates these are
kind of slow but that might be good
we'll see how this goes Fred slow when
he made these so rebar three new that
lists all your templates to give you an
overview and when you ask exactly for
the template you want to use it'll give
you some of the variables you can / set
and things like that and so we
introduced well actually I want to point
out really quick the sea make one that's
an important one because we don't we no
longer have a seat compiler call out
stuff in rebar itself run the sea make
template and it gives you a make file
that will build your
if with no changes unless you have an
extremely crazy example you continue yep
that one is slow the thing is I when I
usually work I tie it may be a 50 type
it was a minute so I have to be super
careful when is because you have a
french-canadian keyboard that can
explain it Liza's alright so we're
building a release project with a
certain name and it gives us the
directory to hold our top level project
we have some apps and we have a rebar
config which I think he'll so first yes
this is the same project we've been
using a type over there the yeah this
shows us the the relics configures in
there doesn't matter we'll see it back
right there because now you owe now we
go now we go to actually building it
where is it really the tarball there we
go we're very prepared are we on time we
actually are we've been working on this
for months there we go so we're right so
now yeah we have the project and we're
going to look at the rebar config the
show that the release the configuration
is in inside there and it's much simpler
than anything you've seen in rel tool I
assume even though we have a number of
common features now we can just simply
build it and make sure it's compiled and
make sure all the dependencies are there
and it creates it and we can also now
quickly create a production tar which we
see we just linked because we already
have those I guess we had an extra recon
wait oh that's the example application I
build and it already edited the entire
thing we just show during casting the
wrong order right so so now that in
which that includes Earth's and we have
a tarball that's deployable and it's
right under our build prod for the
profile release and name of it directory
there's our tall bar ready to go yeah
and that's ready to deploy so that's how
simple releases we have tried to make
um really I don't know how we're doing
it time so his debt it additional
features we've got a website with
documentation and we really yeah this
was super important for documentation is
a feature anyone who says otherwise is
someone and never want to work with
templates have we shown them common test
II unit is in there we've got a doc xref
the shell is in there clean early DTLA
script eyes dialyzer there's a few more
show the website yeah I'm going the
websites so you don't just think it's a
hub just the thing you can download a
nightly from there we've got access to
documentation and really it's something
we're still adding there's a really easy
getting started basic usage for
configuration this thing like that all
of that isn't they'll building output
format released target systems how to
build that when we mentioned the
dependencies everything we showed in the
presentation we could have just gone to
somebody else's presentation and read
the website it's all in there how we
resolve conflicts things to do how that
stuff work it's all explained we've got
tutorials to write plugins because
really I don't want to maintain
everything all the time and neither does
tristan so you write plugins please how
to do them and really the plugins maybe
I'll take a bit this time to show that
yeah we are really really simple with
the video instead it's going to be a bit
simpler and then we're gonna go with Oh
beige exists stop trying to be plugins
all right it's going to be simpler that
way so this is using a plug-in I wrote
for a demonstration that's on a website
so if you want to add a plug-in for any
project in your rebar you really just go
plugins and it's a the name of the
plugins provider to do there is a get
source file it works like any other
dependency in thats it like it's on the
branch master on bitbucket and if i call
to do which is the command its
registered rebar knows about it fetches
the thing you don't have to download
them even if you don't use that common
rebar knows that it needs to fetch all
the plugins before it proceeds forward
with the building of the project and
then it runs the plug-in tells me that
in the application I have to do
somewhere in there
so if I go yeah typo again
french-canadian help to do automatically
every plug-in we have has helped that is
included linked and integrated into the
system for whatever we do the plug-in is
stored in a specific profile in this
case it's a default profile it has its
own source file and we're going to look
at what a plug-in looks like so what we
have here really early on is how you
started plugging we have three callbacks
in it do and format error that's the
only thing you want we have the
dependencies which means that for this
plug-in to run I want all the
dependencies to be fetched installed I
don't want them to be compiled
necessarily because I only look at the
source stuff all these dependencies that
you can have our documented on the
website if you want to build a plug-in I
choose the name I want to have the
module if it can be called a example on
how to call it and do everything and
then please run yeah the documentation
is in there I call add provider and that
makes it work the do one is really based
on that simple function column we pass
in the entire state of rebar there's
documentation again about how to use it
or how to extract all the application
but for example project apps here tells
me that all the applications are the top
level the user applications are not
dependencies I want to fetch these in
that case its source depths because I
don't care about packages in that one
and for each of them I run something so
really that's a plug-in that won't go
over every source file by running the
function over them format error is
simply outputting stuff and that's it
this is a plug-in you hosted somewhere
you put into your project and anyone is
really contribute a really cool feature
we added with plugins though and let me
get back to slides because we had a bit
of time they're coming behavior we have
added out namespace so if you are in
charge of a language like la fille like
Alexia like a theme like anything like
that or you have a suite of tools on
Heroku we have a suite of tool we could
want to create rebar projects
automatically you can give a namespace
to your project and then you can reuse
the commands that already exist so la
fille compile can define it sound
compiler it can call the default
compiler that we have we can use it
sound at least you have your entire
a suite of tools we're all having to
have the comment LF you compile LFE
something it just compile you can run
them and everything like that it works
with profiles it works with anything and
it's just an option that you said at the
beginning that tells you I operate in
this namespace as a provider so if
someone at some point wants to introduce
features to upload packages you can have
the package name space and then package
create package update package sign and
all that stuff and we don't have to care
about it which is really a great feature
in my opinion yeah before we're done and
go to questions we really really want to
thanks I give thanks to the original
rebar contributors because we use some
of the skeleton for that a lot of this
stuff some of the code comes for that
Alistair's 11 rewrote most of the e unit
and common test Suites he wrote the
cover source coverage stuff which now
works really really easily James fish
has handled the dialyzer integration
still finds a lot of bug Erika's than
the hex p.m. work omari garden yes ian
has been someone at work who did a lot
of trial with stuff made early versions
of a lot of the providers we have Kelly
McLaughlin someone on github that keeps
finding really tricky bugs and we're
super thankful for that and a bunch of
other early users so yeah I think that's
it for rebar 3 any question yes sack
does it only supporter Lang 17 no we're
going two versions back and instead of
doing like rebar to which went back as
something like ar-15 or are 13 or 13 are
13 we only want to keep going two
versions back and eventually move
forward because it's something want to
be able to install globally and
eventually used in your features for
ourselves I think it technically works
on our 15 but we won't accept patches
that complicate code in order to support
versions more than two back right we
don't want the rebar code to become
legacy because we want to support legacy
code in it basically any other questions
oh okay so would it be easy to ever get
depths that gets them from a cash right
now the way it works is that to make it
easy to add new formats to fetch depth
there is a kind of internal interface
for that I think we would need to have a
specific get provider and we couldn't
even just call it get c4 get cash or
something and that one could
specifically save a local do you mean
any dependency not a get dependency but
to get any dependency like a package or
get or mercurial that's already been
downloaded so why don't we store it
somewhere yeah it's a future as a
feature I always have in mind where do
you put them is and how do you make sure
the user knows that when they've run out
of disk drive it's because they have
secret packages somewhere it hasn't been
a priority so far but really what we
have as a feature for fetching a package
it's really give me the version give me
the lock hash I want to save and give me
the package and so I give me the content
itself so whatever you can put in there
there's nothing that tells you go
download it from that URL city again
here's a source give it to me and if you
want to override that to use a local
cache it's probably fairly easy to do
the other yeah the other problem that I
always ran into with that one is with
packages that have a version number
that is fairly simple with get I mean
you have to make sure you have the ref
you probably want to go based on that
and then it's it's a little more
complicated when its branches and stuff
like that you want to like shot you want
to make sure it's actually like the
version they want yeah but we're
packages as people move to that it's
probably going to become more simpler to
have a cache locally that you just oh
I've already got cowboy one use it
there's a lot of new behavior in there
also and as we said we wanted
predictability so before adding these
features that I think are not vital but
are very very nice to have you want to
make sure that basic behavior is at
least stable and predictable for
everyone because after that it's a lot
of different bugs to try to fix yes is
there anything that needs to be done for
incompatibility with mix I haven't
touched a Jew mean running mix or team
competitive we've I mean they don't work
together yeah mix in the sense of one it
would be good if there was a plug-in
that would use mix to compile elixir
depths that was usable from rebar 3
that'll be nice it would be nice for
nicks to be able to use rebar 3 to
compile and like hex for example they're
still work to be done there you can't
yet upload packages and stuff like that
you still have to use make hex or mix
through Hexter mix but we're gonna have
time for one last question so fight to
death for the last question I see three
people which one I don't know okay you
kept your hand longer in the air you're
more motivated you get we already talked
to you earlier
what you would like in on my library so
it's on the features I mean you don't
need they're both rebar config the both
rebar config so the elements that are
rebar three specific are going to be
ignored by rebar to when the elements
are bar to specific going to be ignored
by rebar three so the source format you
can for dependencies you can specify the
same thing the arrow ops format is the
same you're going to lose the usage of
profiles if someone goes back but
usually should be both backwards and
forwards compatible nifs and proto buffs
are an exception you will have to use
the compile hooks and different stuff in
there with plugins but yeah plugin usage
is not going to be exactly the same
because they don't have the same
interface and all that stuff but mostly
dependencies and everything else should
work fairly straightforward for the vast
majority of projects you hope to make it
easy enough to upgrade that everybody
just does it pretty quickly they should
be able to do that because they both at
least try to support OTP applications
you might have to change your config to
make sure it's rebar to compatible but
you'll be able to use it in rebar 32
have a little bit musically right well
thank you very much and uh</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>