<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tech Mesh 2012 - ClojureScript: The Essence of Alchemy - David Nolen | Coder Coacher - Coaching Coders</title><meta content="Tech Mesh 2012 - ClojureScript: The Essence of Alchemy - David Nolen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tech Mesh 2012 - ClojureScript: The Essence of Alchemy - David Nolen</b></h2><h5 class="post__date">2013-08-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3UdpwKKUbe4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so the name of this talk is closure
script the essence of alchemy so I think
everybody is well aware javascript is
quite ubiquitous these days in fact if
you're trying to write portable code for
mobile devices a lot of companies are
opting to do like native shells but in
the app itself you're actually writing
HTML CSS and JavaScript and that you
know I think everybody kind of knows i
mean people really have computers now
for the internet i mean you know they're
you know there are some desktop apps
that we use but the internet is
basically the essence of computing and
if you're going to talk about internet
we're talking about browsers and the
only game in town is JavaScript so
JavaScript as as a lot of people may
know I've heard was invented in about
creating about 10 days right so that
means in 10 days you don't you don't get
to make all get all the design decisions
right that you would like to as a
programming language designer and an
honest honestly JavaScript had very
modest goals in the beginning right it
was actually intended to be used by
non-experts to do very simple things I I
don't think Brendan Eich ever thought
that people would write twenty thirty
forty fifty a hundred thousand lines of
JavaScript and that would actually that
would really be the way that people
build web apps like we do today so it is
this is actually an old idea that the
essence of this talk is you know we have
JavaScript and which is a has some nice
things but has some things that are not
so nice and so a lot of people said well
maybe we want to leverage our existing
tooling for example Google created
google web toolkit well that lets them
do is that they have many many Java and
Java engineers not so many JavaScript
engineers so they can use Java they can
use the same layout tools they whatever
they have in Eclipse and so on so Google
web toolkit was kind of this first steps
to say well we can compile Java into
JavaScript because it's semantics you
can simulate a lot of semantics of Java
in JavaScript Google
also has this other new project called
dart which some of you may have heard of
dart is particularly interesting because
they sort of came out was you know it's
a custom vm that only runs in chrome and
they created it and sort of the idea was
they're going to move the web for it now
the likelihood that any other browser is
going to adopt chrome is dot the dart VM
is quite small and in fact in order for
this to really work they have to be able
to compile down to JavaScript and that
actually created some interesting design
decisions that they had early on that
they had to change right by needing to
compile down to JavaScript they had to
tweak some of the semantics specifically
because of issues around efficiency and
so this is a pretty interesting to me
because I think I think more and more
languages will target JavaScript as a
compile target and it's is commuting to
see what trade-offs you'll have to make
in your language Microsoft jumped into
this into the compile the JavaScript
game with typescript so typescript is a
superset of JavaScript so an untyped
JavaScript program is completely valid
typescript but they add sort of class
syntax sugar and a fairly sort of
straightforward type system you can
gradually type your programs if you like
and also you can also provide type
annotations say somebody gives you an
untyped library javascript blurry
library you can actually add annotations
to the library as a separate file and
that's pretty interesting then you have
sort of more grassroots projects compile
the JavaScript objects like coffee
script which is quite popular with young
developers and coffee script is
interesting in that you know it sort of
is like Ruby Python s sort of whitespace
sensitive syntax it sort of has a much
more convenient way to write lambda and
so on but again it doesn't really try to
diverge too far from JavaScript
semantics you have other another growing
popular compiled JavaScript language
called Roy which sort of tries to bring
some of the things from statically typed
languages into into JavaScript again Roy
does have does try to not veer too far
away for
javascript semantics because again he
wants to be able to compile his name is
Brian McKenna he wants to compile a
readable JavaScript similar to the
strategy that CoffeeScript takes towards
the JavaScript that's generated so all
the previous languages I said it
actually sort of the compromises and the
language that are quite large again
they're not trying to step too far away
from JavaScript so closure secure
closure is quite different from
JavaScript right the semantics are
actually radically different we it does
not a try to adopt mainstream
programming practice at all so that
they're going to be a lot of challenges
here in getting something like closure
to target javascript efficiently enough
that anybody would want to use it so I
just want to talk about the challenges
first off if you're going to target
JavaScript whatever language you're
going to design you have to really be
serious about the cost-benefit ratio
because what are you imposing on the
potential adopter of your language you
are writing a compilation step to
whatever they're doing right so your
language has to provide significantly
better semantics like much much better
such that the cost of having to go to
this whole rigmarole to use your better
language is actually worth it it needs
to absolutely needs to interoperate well
with the host sometimes you people you
see people do these JavaScript languages
that try to protect you from things in
the dominance and so forth I think
that's not a great idea a closure is an
advantage here because closure was
always designed even on the JVM to be a
hosted language something that's
becoming more important is that you
really have to have a sensible debugging
story so you have the sort of ad hoc
CoffeeScript or or Roy approach where
you're just generating readable
JavaScript that's one way but I think it
really needs to be better than that and
the story here is improving because
chrome for example has source maps and
firefox has source maps and that
actually allows us to get line and
column information for every symbol in
the your programming language and map
them to symbols in in the compiled
JavaScript so you'd be able to set
breakpoints and step through your code
not the generated JavaScript another
thing that's big
is you need to be able to reach the
performance of the host whoops so this
sorry this one is a pretty interesting
because I think this may put some
restrictions on what you can do so host
limitations obvious one javascript right
now currently is single threaded there's
not much you can do about that you can
just throw that out the window a lot of
a lot of the things that people cool
things that you're going to hear about
here really to concurrency you can't do
in javascript another that big
limitation is numerics so dart has had
to sort of punt on this as well
javascript only has 64 bit floats right
that's all that it has it's also source
only you often hear people talk about
yeah I would it be awesome if you could
compiled on the bike code but the
reality of having this send things over
the network I mean that just does not
going to work and some languages design
choices just may be a challenge
challenging to implement efficiently
hopefully what I what you get from this
talk is that I think it's pretty
impressive I think the sort of
collaborative work has been done on
clojurescript to really get something
that really feels like closure in the
browser so it's sort of a challenge are
there other sort of more radical
paradigms that are possible to implement
efficiently in the browser think may
perhaps languages that emphasize
messaging or laziness like Haskell so
host benefits the reason you want to do
this again is that you have some
language that you like in this case
closure and we want to be able to reach
all these technologies that javascript
is capable of reaching right it's our
only way to get there things like HTML
canvas WebGL web body of WebRTC these
are all really exciting technologies and
these are things that can run on phones
like a run on browsers without the user
having to install anything they just
have to have the browser another thing
is interesting is longevity javascript
is a bit odd and that the there is now
an interest in making it better but for
about 12 years nothing was going on
right we're using the same version of
java script that we were using in two
thousand but that's actually a good
thing right we have a stable thing to
target the other thing that's nice is
that there's also really unlike a lot of
technologies that we use where the sort
of floor key
moving underneath us a vendor
competition actually moves towards
standardization so you know Apple
creates html5 canvas Firefox adopts it
right finally we have in an IE but you
know it's a slow process but we're
actually it you know it's not like the
thing we're right android vs I us it
just keeps fragmenting right the web is
like something real like you know it's
moving towards fragment moving towards
consolidation not fragmentation and this
is I think something that as programmers
we like so this is a real image I
imagine in four or five years that
there'll be many programming languages
in the browser this is I have this is
like some source mapping work and I can
actually inside chrome see my original
closure script source files and you know
eventually i'll be able to set
breakpoints in step through it but this
is a big step i would love to see things
like you know a perhaps tricked version
of haskell and you could you could you
know debug it right there like that
would be pretty awesome so i'm not i
don't need it I don't think I need to
introduce closure too much to this
audience it's a dynamically typed Lisp
it did target the JVM and now it targets
a JavaScript as well it was introduced
july 21st 2011 rich aqui came out with
it then since then its ad development
has really taken off we have 51
contributors now there are some
contributors in the audience which is
really cool and so I want to talk a
little bit about how what some of the
design decisions about how close your
script works in wanting to compile
decent JavaScript so one thing that was
controversial early on that I think a
lot of people don't really understand is
that Google closure compiler which is
the optimizing JavaScript compiler is
actually a critical sort of step in the
compilation pipeline and this is a big
deal for lots of reasons one of the
biggest is that dead comic dead code
elimination is extremely good there I
don't not aware of any other j/s
optimizers that do dead code elimination
as well as Google closure compiler this
is critical for closure because closure
has a very large standard library it's
like seven thousand lines of closure
that gets compiled into like twenty
thousand lines of Java
script you absolutely need to have
extremely good dead code elimination the
other thing is that closure is a list
right so people right Mac rooms that
generate tons of code right you need
something like like Google closure
compiler to control that the other thing
that google closure does that's pretty
awesome so that we don't have to write
multiple passes for this kind of thing
in our in the actual closure compiler is
in lining so for example javascript is a
statement oriented language right it's
not an expression oriented language Lisp
is expression oriented if you're
familiar ubi ruby is also expression
oriented it's not statement oriented the
only way to get sort of expression
semantics in javascript is to create
closures right it's to create a function
to wrap the statement that's the only
way for this to work but that's horrible
right because in JavaScript there's like
allocation semantics you know allocation
semantics around riding closures inside
your functions there's a huge
performance penalty Google closure will
just lift them out will lift that
statement out intelligently so we're
able to preserve expression semantics
without complicating our own
optimization passes does obvious things
like constant folding and again
minification which is critical when your
target is proud web browsers and mobile
devices and the other thing that's
really nice is that it has a large a
library of battle-tested jas I mean
Google probably predict you know
produces more JavaScript than any other
company in the world so not handled so
when it came out there were still a
bunch of things that we weren't
optimizing that Google closure can't
optimize for us because we have
different semantics than JavaScript
right there are certain things that are
closure specific that have nothing to do
with javascript that we need to optimize
if we can and Google closure will not do
this these include things like rest
arguments we have multi aritee functions
we have keywords we often use keywords
to it to extract properties out of
associative data structures you know
things that Google code that is not
relevant for JavaScript we have a type
constructor called def type right and
when you do it you actually declare all
what are called protocols and this is
actually static information when you
construct
type there's a bunch of type information
there right we can actually flow that
information through your source and
optimize call sites because we have that
information available so these are
things that we have to handle also
things like boolean inference so in
JavaScript zero is false the empty
string is false so everywhere because
that's not true in closure closure there
are only two false values nil and false
so everywhere that we do a test we
actually have to call out into a
function which tret tests that the value
is truth e in enclosure that's a huge
performance it especially in any
critical path imagining f this F hey
having to say zero is less than one and
we have to call some other function to
guarantee that we're going to get some
usable value out of that so one thing
that we added is boolean inference so we
actually add tie pins which are a part
of the way that closure works and in the
compiler we infer that we don't need to
do the test numerics is something
actually we don't address because we
still haven't figured out how to do it
so we're lucky in that all the genius
engines actually of course try to hold
onto intz as long as they possibly can
otherwise the performance would suck but
we can't guarantee we can't really truly
say that we can represent integers
enclosure script we sort of just pretend
very hand waving but it works out
performance wise for us so I want to
talk a bit about switch gears and talk
about data structures so closure is very
influenced by this book I mean in some
sense there's a sort of meme and the
closure community called data all the
things I mean closure is really about
data's and data and functions we closure
programmers are dynamic programmers but
pretty much everything else that you
heard about in this conference we
believe in we may not we might might not
care about static typing but pretty much
everything else that you'll hear from a
functional programmer closure really
truly believes it and that's data and
functions so when closure script first
came out right closure programmers love
the data structures they're really nice
they provide good performance and yet
they're immutable and so when it first
came out richa key only did
copy-on-write and this was just for
expediency reasons right he wanted to
get something out to the community and
the community could take it over and
there was a lot of skepticism Earl
I was like you know is that even
possible is it possible to do good
persistent data structures if your
target is JavaScript and a v8 really
really chain changes the game for this
kind of type of thing v8 is very very
very good the the the fragment that's
optimized about v8 does this very well
and really the thing that's killer about
v8 is the garbage collector I mean it
just runs circles around javascriptcore
which is a pelada and spider monkey
which is Mozilla's product just just to
show some benchmarks so here I should
have a benchmark where I construct an
array with 1 million items interest I'm
just appending them mutating the array
and then I have a benchmark for doing
the immutable construction of a vector
and then I benchmark a very sort of a
local mutable optimization that closure
has called transients you notice we're
actually faster it's faster to build
transient vectors enclosure script on v8
then is to build mutable arrays and that
may be because of optimizations that
Google closure oh sorry v8 is willing to
do because we actually have fixed we use
fixed sizes we use arrays of 32 elements
and and the thing is that that's really
that performance is great because really
when you're doing browser programming
you're dealing with a DOM and basically
the DOM is I oh right right if you have
to touch the Dom that's pretty slow so
this is good that we're showing really
good performance for these persistent
data structures because we're saying the
cost is not high right the benefit is
high the semantics of you know immutable
data structures right functional
programming and you're not paying to I
have a cost so I could talk all day but
it's more fun to show some code so here
we are um this is actually running in
Chrome so everything I'm deming deming
to you is running in chrome so this is a
very lispy thing to do we actually use
the browser as an evaluation environment
right so we actually compile the
JavaScript on the fly we send it to the
browser it evaluates and we and we show
the result back out in the repple here
so I'm actually compiling this on the
fly evaluating in chrome and getting the
result back
already you see we can do things that
you can't do we have some notion of
modules right closure has namespaces and
that's pretty awesome so I'm just going
to show some basic things like right
false is false short nail is false ok 0
is not false the empty string is not
false a small victory but a nice one
another one that's that's that this is
big which is that javascript has no
sensible notion of scope it's bad it's
horrible so I just want to show you that
we've we actually have the semantics of
lexical scoping so you're here i'm going
to make an atom it's the mutable
reference type enclosure i'm going to
i'm going to have a for loop here where
I create closures and I stick the
iterator that the current value of the
iterator variable inside right so I'm
just going to side effect that thing in
JavaScript if we actually mapped over it
and force and force those thunks we
would get 444444 right this is what you
want to see this this is actually burns
nearly anybody that does any javascript
programming because it's very normal to
have a for loop construct some Ajax call
backs or what have you and then you run
it and then suddenly none of the values
make any sense so the compiler
intelligently closes over any locals
that we need to this is also another
small victory but I think pretty
significant so again data all the things
if you saw if you saw the talk this
morning sort of having something like
type classes is pretty sweet so closure
doesn't do doesn't have it's precisely
type classes but does have something
called protocols and allows us to do the
kind of generic programming that was
demonstrated this morning so for example
I can get the first thing in a list I
can get the first thing in a vector I
get the first thing in a set I can get
the first key value pair in a hashmap
and I can get the first character in a
string so generic programming we have a
large set of data types and we have a
uniform way with working with all of
them I can loop over the contents of a
vector and I can print them all out in
the same way that I can lu
over the contents of a hashmap and print
print them all out as well hopefully you
can see that okay so the other thing we
have in this been mostly I talked think
I talked about this but we have sensible
notion of equality right so in
JavaScript you really have no nobody
uses the equals operator unless you're
just checking for identity and enclosure
we don't do that we want to know that we
you know we program with values and it's
very useful to compare two values and we
don't care that whether these things are
the same in memory we care do they
represent the same value and we can do
that sensibly and it's just built in
here's comparing to ash maps and yes
they're equal a fund something that's
kind of fun that you probably won't see
in a language like at least like Haskell
is that collections in enclosure our act
our functions themselves so for example
i can create this data structure which
is represent some address right and i
can actually use that data structure as
a function right hash maps enclosure are
functions of their keys so I can take a
sequence of keys and extract out a
sequence from the address right so I
want to get the city and the zip and you
can see I have them right there I just
want the city or I want it i want the
zip first right and so on another thing
that's nice is closure doesn't have
pattern matching but it does have
ubiquitous destructuring saudi
structuring is a way to take some data
structure and extract out some value
that you actually care about so here i
say give me the middle element of that
vector but it's recursive i can do this
add you know as much as i want i can
extract out the first character in the
middle value we can go even further
there can be a map hashmap there I can
destructor the hash map and extract the
first letter of for that particular key
and this is pretty great right so again
this is sort of showing that this is
very different from what JavaScript
programmers do which is sort of create
some mangled monstrosity right this is
emphasizing programming
data closure has a lot of nice features
for dealing with data a little thing so
this was a chant this was a bit
challenging to get right MultiAir DF
ends so here we have a regular function
which will compile down to a regular
JavaScript function but we have to do
something special in this case right we
want to dispatch based on how many
arguments you get and JavaScript does
actually provide a reified arguments
object right where you can actually
inspect which organs for pass the
function but that there's a performance
there's a performance cost associated
with that and we don't want it we don't
want to pay for that because multi arity
functions pervade the closures standard
library so there's a little hack just I
want to be able to cook call the
compiled function and let's see that
takes 162 milliseconds and this is the
multi dispatch so this is showing that I
can call the particular arity of that
function faster then I came and call a
regular JavaScript function and this is
probably because your various tricks
that goot the Google closure compiler
can does with this code okay so some
life it's a little bit of live coding so
so one thing that I want to talk about
is it there's there's a whole sort of
process we're trying to transform
closure to JavaScript but once we get
closure into the browser we really can
do something great for the user which is
the user is also able to transform the
browser into a more ideal programming
environment so here you see I can grab
the div on the page I can make it blue
and make it big make it small I can
apply out a CSS web transition where
this gets really fun and that's not that
exciting we're just mutating the Dom
whatever and it's actually it seems a
little bit more of our boats than what
you did in JavaScript but what if we
decide I actually want all HTML nodes in
the browser to be safely extended to
function to be functions I want them to
be functions I want to be functions of
their attributes in the same way that
hash maps are functions of their keys so
I've just I've just extended HTML
element so that now HTML elements are
functions I can map that HTML element
over a sequence of strings and extract
the ID
the class right so so this is great
we're eat like now the programmer can
transform the the browser environment to
be something that's more malleable and
more fun to work with we can also do
that we can also there's another
protocol which again it's like it's a
bit like Java interfaces but really more
like Haskell type classes where called I
look up which is the associative
protocol and so now I can actually take
that same HL element I can do structure
its key right so I can extract the class
and I can get the first character off
the class which was spin spin was that
carrot was that the CSS class that I
added to make it spin so and if anybody
has questions you can stop sorry didn't
say that early if somebody has questions
you raised your hand it will address
them so let's get back to the slides
okay so so let's talk about now that we
have something that looks basically like
full-blown closure in the browser what
are the fun things that we can do so
closure doesn't ship with pattern
matching but we can add it because we
have macros so something I did actually
a year ago was I ready a really great
paper by Luca Marrone Jay who is a camel
person and he's written some really
great papers on riding off to my
optimizing pattern match compilers and I
read it and the paper is great and it's
it's easy to read because he doesn't
talk too much about the types he just
talks about the algorithm and the
algorithm is really great it sort of
takes the semantics of lazy pattern
matching and shows you how you can make
a gorilla my can simulate that and
what's cool about the semantics of lazy
pattern matching is that it produces
really really nice trees whereas you see
there are many paths to get to match a
certain pattern if you do a night naive
pattern match compilation the doing it
with their algorithm produces a single
path right it's the same same match but
there's only one way to get there and
it's pretty short only four steps so I
on this fellow Ambrose sergeant last
summer we worked on this and this is
also pretty fun so I don't know if
you're all are familiar with red black
tree pattern matching
but this is the red black tree pattern
match which actually was broken for a
long time Tom Kristensen is in the
audience and he helped me debug this but
so this is exactly like what it would
look like in Haskell right except what
right it's like we were able to write
the pattern very succinctly and so I'm
going to is this is this balanced and
it's not and I get back a balanced I get
it back a balanced node this one is and
we get back to know that that we gave it
and how fast is this so so this is what
we put a lot of work into efficiency so
this is not the fastest way to do this
we could write custom red nodes and
black nodes I want to show that the
persistent vector performance is pretty
good and the pattern match performance
is pretty good so we were able to call
that half a million times that's not bad
one second ah so so one other thing I'm
going to show is logic programming so I
invite you to come to my talk tomorrow i
will talk significantly more about logic
programming it's a a passion of mine I
how many people know prologue here in
this audience ah this is this is great
you know you're at Tech mesh when this
maybe people raise their hand so if you
know prologue prologue is really great
for solving puzzles no it's actually
good for a lot of things but it's good
to demonstrate its power with a simple
puzzle and the famous one is a zebra
puzzle it appeared for the first time
December 1790 62 and it looks something
like this it said who owns a zebra and
there are 15 sentences and they all are
about five properties of five houses and
there's the properties are who lives
with the nationality or the person that
lives there what do they like to smoke
what type of animal do they have what do
they like to drink and what's the color
their house and so it goes you know
there are five houses the Englishman
lives in the red house the Spaniard owns
the dog coffee is drunk in the
greenhouse and so on and it ends with
you who drinks water and who owns the
zebra right in this great book Peter
Norvig the paradigms of artificial
intelligence Peter Norvig actually shows
you how to write prologue and interpret
a prologue in common list then he shows
you how to write a compiled prologue in
Common Lisp and he points out that the
naive like brute force search of his
space involves about 24 billion
candidates and it and he shows that once
you've got this really nice compiled
prologue and Common Lisp he was able to
solve it on decent hardware in 1983 in
about 17 seconds so I'm going to show
you how fast we can solve it using v8 so
oops actually
so that benchmark is for calling zebra
100 times so we can we can solve it in
14 milliseconds which is pretty cool
right this is this is this is this is
something you can run in your browser
like we this is a we should be thinking
very differently about the types of
programs we can construct given that we
can write in higher-level languages and
we have our computers are just so fast
now I mean I think we still tend to
think in a very old-fashioned way about
the types of programs we can write so
here we find out that their new region
must drink water because the middle
property is is the drink and the
Japanese man owns the zebra so if you're
interested in this again come to my talk
tomorrow I'm going to talk a lot more
about logic programming I sort of
implemented a version of a system called
mini Cameron that's described in the
reason schemer if you've heard of the
little schemer Dan Friedman worked on
look the little schemer if you're
familiar with Haskell I'm sure you know
who Oleg Kiesel yob is this book is
really amazing i love it it's really
cool it basically shows you how to embed
prologue something very similar to
prologue and about 200 lines of scheme
which is pretty incredible that's that's
really tiny so types so I'm gonna so
summit so Ambrose who I collaborated
with on on the pattern matching stuff he
actually works on the thing now called
typed closure which is sort of taking
some of these great ideas from typed
racket to add types to closure to
actually type closure so I don't have a
totally cool demo but this is still
pretty interesting
so what this what this does is that here
he's given this function a tight right
he's saying that we're going to union
nil and it's going to return some some
value boolean CLG hcas and so what's
cool about this right is that he had to
modify his his type checker only
slightly right only a tiny change had to
be made of to his type checker to check
clojurescript because clojurescript is
not a dialect right clojurescript is so
close to being closure that just happens
around on JavaScript so I believe Ike
yes so if we can you run this code we
see that the type checker runs on that
namespace and close your script and it
emits a bunch of of type information
that was collected and during the type
checking process so anyways hopefully
you enjoyed this presentation and
convinced that javascript is actually a
pretty awesome target for for much
better languages than JavaScript like
you I think you can write really great
languages and JavaScript can be a really
good target the thing that I'm
fascinated by and this whole enterprise
has got me excited about is that we need
we need to explore efficient
implementations of different paradigms
that target JavaScript so that we can
find sort of new implementation
strategies right a lot of this just
requires people to say i wonder if i can
get laziness to be fast on JavaScript
you see people often do these naive
thing where you have hundreds and
hundreds of thunks and it just doesn't
work right people have to if they're
going to try to do that they have to
come up with new ways of implementing
that particular approach to programming
language design the other thing is
javascript is not likely to go anywhere
it is not it's not going to go anywhere
and you have to we have to ask ourselves
do we still want to be programming in
JavaScript 10 years ago 20 years from
now that's all I add questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>