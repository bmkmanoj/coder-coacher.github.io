<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Svetlana Filimonova - Property-based testing in a Scala project with Scala Check | Coder Coacher - Coaching Coders</title><meta content="Svetlana Filimonova - Property-based testing in a Scala project with Scala Check - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Svetlana Filimonova - Property-based testing in a Scala project with Scala Check</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7LtDjRVSkPo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so yeah I I work for ThoughtWorks
I'm a developer result works and thought
works is a consultancy company we have
lots of offices around the world and I
am based in Sydney Australia that's why
I have such a Russian accent everyone
speaks like that in Australia I am
currently engaged with this client
Commonwealth Bank and the whole thing
which I'm going to talk about today is
connected to the experience of working
at this company they have a very strong
engineering team and I learned quite a
lot about functional programming and
working with Scala with these people so
today I'm going to talk about property
based testing and well in the last
couple of years I started to love
functional programming I just loved all
the concepts and I love that many
mainstream technologies they started to
adapt some really good ideas from
functional programming like how we deal
with nulls and exceptions with some
either and option moment we have
monastic compositions with collection
pipelines with Java in Java Script and
in Ruby we have functions as arguments
and lots of other really good things but
when I started to work with Scala one of
the most favorite thing for me was
actually like property based testing and
unfortunately I I haven't actually seen
property based testing used in
mainstream languages like Java or
JavaScript or Ruby and I don't I don't
understand why because I think it's like
the most under appreciated practice from
functional programming which people
don't actually think about in mainstream
technologies for some reason and in the
last couple of months I've been
traveling a lot in Europe and I've
attended a lot of conferences and I
heard so many talks about property voice
testing so I'm doing another one and I
think it's just like
don't when he talks about this thing is
just barely enough so how many people
actually use proper service testing
well this talk is going to be quite like
introduction Eric talked about the
concept itself and some some buttons and
practices we used in my team so I'll
just start from like what is property
based testing so let's say we have this
function sum which accepts two arguments
integers x and y and it gives you the
result of some of these numbers so the
opposite of property based testing is
well-known example based testing in in
example based testing he would write
something like that he would be like
well I want to validate that with the
given zeros sum the result of some will
be 0 and if I give 0 and 1 the result
will be 1 if I give 2 and 2 the result
will before and as you can see the input
for this functions was invented by me so
I sat down I thought about the use cases
I thought that well this are the use
cases we want to test and there they are
right so in property based testing I
would instead of supplying examples I
would provide the type of the input I
would say well for all x and y's of type
integer i want i want my son to produce
the sum of element X plus y all right so
as you can see like basically I'm saying
that sum equals equals x plus y well
imagine this is alternative
implementation of some not the actual X
plus y all right so let's let's have a
look at another very important function
from math square root right the first
thing you the first thing you like think
about square root is like the square
root from X multiplied by X is equal to
X right
and this is my property this is my
statement and I want it to be truth
right I think it's fair enough and at
the same time I haven't thought about a
lot about like HK says I haven't thought
if it can actually work on that so I'm
just gonna run it and well I got some
errors right so basically my test failed
after zero pass test basically none of
the tests passed and the first argument
it failed with was negative number
well obviously because like the square
root from something is not going to be a
negative number so it's okay I can I can
fix it I I can I can change my statement
about about that and I can say that okay
the square root from something echoes
absolute value of this right and then I
can run test again and it fails again
but you see it's actually a different
different error the different value it
fails on which gives me different kind
of idea of like well something is wrong
still wrong but the previous error is
fixed so you see there are two lines
okay so there is original one and there
is an argument underscore zero right
so the original one is the big one right
so this value is was the first one which
made my test fail so how it works is
Scully check generates this values and
it finds the first value which makes
your test fail and then it stops it
stops generating anything and it starts
shrinking so the shrinking concept what
it does it actually literally shrink
your input basically it is trying to
find the minimum value which still fails
your test right so here that was the
original value and that is the shrinked
value so Scholarship found for me that
this value was the minimum value which
failed my test right so scholarship
provides
scotchy provides some sort of standard
standard instances for generators and
shrink as well so you have a shrink you
have like algorithm on how to shrink
integer values and it is provided by
Scala yet so you can that's how it looks
like so you can ask can you please give
me like shrink for integer and let's we
can try to shrink some integer right and
it gives you back a stream of values
right and it looks like that basically
it literally tries to find the minimum
value which makes your code files fail
so that's how it failed again right so
when I shrink it gave me this weird
value 46 3 4 1 right and like what what
is that and then you start thinking then
well the maximum value of integer is
this right and when you multiply these
two magical numbers it's not going to be
int it's going to be integer overflow
and it's something that you haven't
thought about when you made a statement
about square root when you multiply well
this is a signature of multiplication
function right it accepts integer it
accepts another integer and it gives you
integer right what it actually says that
for any integers when you multiply them
you're gonna get integer back but in
fact they are lying to you they're liars
because it's not gonna give you integer
all the time and that's what we found
out with this property voice testing
right so we can fix it as well we can
apply condition on the proper on on on a
generator right
we can ask Scala check can you please
give us a generator for integer like
here
normal generator but could you please
also verify that when we multiply those
two integers it has to be defined and if
it's defined we want this property to
hold
and you who it passed yeah so the next
thing the next thing is actually very
important
it's about validating your generators
right so it doesn't really matter what
you generate it doesn't really matter if
you're using standard generators or your
own customized generators of data it's
always a good idea to verify what
exactly has been generated for your test
and Scotch egg gives you this
opportunity you can collect oh sorry
you can collect the value it will give
you a stats on what actually has been
generated and if you've ever looked here
I you can see that 35% of the values
were generated it's minus 1 then 1 and 0
it's not actually it's not actually a
good distribution of integers I'm
expecting from this property based test
what basically it says that I only
managed to generate 3 values and I'm not
really happy with that and one of the
reason for that is condition is because
of the condition so how it works is
scholarship gives you a generator
standard generator for integer then it
you me I'm trying to apply a condition
asking that multiplication of those two
integers has to be defined right and how
it works is Scala check just gives up or
scholar check doesn't actually try to
give you a big range of values it just
like gives you a very small range of
values and this is kind of downside
which we we found out at our project
also conditions sometimes if you add
extra things like let's say I wanna I
want to generate an integer value
I want the multiplication of them to be
defined and I also want this value to be
more than 0 and if you run this test you
just gonna get an exception saying well
I couldn't do that I just give up after
like you know 67 pass tests basically
scholarship couldn't
we generate you the whatever you ask for
and it is all because of these
transitions so basically the condition
for this property is too strict that's
how they said I am not sure exactly why
it's happening but that's the case right
now so the alternative of like how we
can work around this problem is to use
our own generators right so instead of
using arbitrary of integer you can just
provide your own generator saying okay
can you please give me a generator from
minus 40 something till like plus 40
something and giving the custom your own
generator the result of collected data
is more satisfactory right you see yeah
and the test still passed cool so so far
we did a scholarship property for square
root which is the most important problem
in software development
then we did some shrinking and we
actually know what shrinking is now I
think shrinking is quite interesting
concept I will talk a little bit more
about it later and how we actually used
it or to be honest not used it at our
project we have laid around with
restricted and conditioned generator and
created customized generator and the
most important thing we actually
validated the input so the most
important thing about what just happened
for me was that I was able to discover
each cases I was able to discover the
fact that a square of square root is a
positive number and I was able to
discover about this thing called integer
overflow I didn't have to know that
before I actually started testing and
probably those kind of issues like
square of a fruit is a positive number
probably every person should know that
but we're just people so we're gonna
forget
at some point so yeah property based
testing for me is all about discovering
edge cases instead of like inventing
them or remembering them now I want to
talk about sorry now I want to talk
about Chan so this is the hugest concept
in Scala check it's actually the idea of
how to create generators right so Jenn
Jenn is actually really cool thing first
of all it's a Monat and because it's a
moment it's also an applicative and
because an applicative it's also a
functor and because of all of these you
have really nice patterns of using of
usage of this Jen right so it works like
this so let's say we ask Scala to give
us like a standard generator for
integers so you can get a samples and as
you can see it doesn't give you the real
value so it gives you a values wrapped
inside of option moment it means that
sometimes a little way it will fail to
generate you values right and we
actually saw a good example of that when
Scala check gave up to generate our
values right so let's say we have a case
class customer which has like an own
name and age we can use a monastic
composition to create a generator for
customer because Chan is Amanat and you
know what is the best thing about Mona's
the best thing is about monitors you can
compose them so basically it means we
can ask Scala check to give us standard
generators for string and standard
generator for integer and we can just
compose them and create a customer and
thanks God Scala has full comprehension
because that looked just horrible so
this is how like normal kind of
generator will look like right
here is a little bit more complicated
example so let's say we have a customer
with optional insurance right so some
people have insurance and people don't
have insurance right so for the
generator to work we need to provide
another generator so we need to tell
Skyler check how to actually generate
insurance right and here we are using a
little bit different button for
generating for creating generator for
insurance we are using functor because
we're just getting a standard generator
for string and we are mapping on it
which is cool so that's how it looks
like it would look like with melania
composition again so here we're not
actually creating a new generator we
just ask in spell check could you please
find already existent existed generator
for optional insurance I'll give a start
right so there is another pattern of
creating generators applicative because
it's a moment it's also an applicative
right so you can do that right you can
take standard generators for strings
integers and the generator which we just
created for insurance and you can do
applicative composition and you can
create customer like that right so what
is the difference here nothing it's just
it's just syntax there is no actually
difference it's really up to you it's
like I think it's a matter of taste here
in this particular case and I'm not sure
like there are people who like this more
probably because of this like look at
how beautiful it is however there could
be a difference so the main difference
between magnetic and applicative
composition is that when you compose it
as a more nut you can actually compose
moments which depend from on each other
right
here we have an example of when we asked
when was Scully check to generate us
insurance not an optional insurance just
insurance right and then we create a new
generator which depends on the output of
that generator right and this is this
can be only done with no magic
composition you can't really do it with
this beautiful syntax thing and actually
there is a difference between doing it
like this over actually asking Scala
check to give you optional arbitrary of
optional instance because of the
distribution what I've noticed is when
you when you create an arbitrary of
optional instance of optional something
you cannot get I think you're gonna get
about 10% of nine and nine and 90% of
sums but sometimes you want to like
50/50 right and in this case you're
gonna get 50/50 but the main point was
just show you that like sometimes there
is a reason to use melodic composition
yeah and I don't really see any reason
to use applicative composition maybe I'm
wrong it would be nice to hear any other
opinion right and there is this thing
called Scala check shapeless which is
really nice library you can just add
this library and it will generate all
the arbitraries for you and it also will
generate you shrinks shrinks is like the
kind of algorithms of which will tell
scull check how to shrink your result
right when it fails and you can get the
instance of generators just like that
it's very very easy the only problem
with Scully check scholarship shapeless
is it will just generate you this so and
it's it's useful it's useful that's how
you want to start to write your property
based test you don't really want to
start to write test by restricting or
adding extra conditions on your
generators right you want to see all the
possible inputs right and
then after you see failures you want to
decide if you want to actually add extra
restriction on the generator so that's
why probably it is a good idea but at
the same time right now in my court
majority of the generators for like
complicated models they are custom Li
created I can't I just can't use
Schafer's generated generators which is
probably not a good practice probably
it's a sign that something is wrong over
there right so I'm restricting and
reshaping generators right so this is a
as I said you will end up doing that
anyway
ideally of course you do not want to and
obviously I think the reasons are quite
obvious right let's say if you have a
case class person which has like name of
string and age of int it tells everyone
that it's string and and int it tells
all the other classes that this customer
may contain any integer and any string
right but once you restrict your
generators you're not or you're not
testing your application against these
types anymore so basically you're doing
the same as Scala G it with
multiplication function you're basically
lying link to other court about your
types so all right so we saw already
that you can restrict your generators by
adding some sort of conditions at the
beginning with this double rocket thing
here right or you cannot actually just
create your own generators right that's
another that's another alternative what
else you can do you can yeah you can
still that yeah you can create your own
generators who is a monadic composition
and if you want to modify them you can
actually just use copy
let's say we have this optional
insurance right then we want to create a
generator without insurance we just want
to like all the customers which don't
have insurance let's say this is our
valid input for our test case right then
it's really easy you just get a standard
generator and you modify it like that
right so generator also provides these
two tivities which is such that and
retry until so such that is just an
alias for this double rocketing which we
already used right so basically the
downside of such death is that you may
receive this give up after something
exception right I think the reason is
because how its implemented is basically
using the original generator and then it
tries to verify the condition and if the
condition doesn't actually satisfy it
just fails the generation right and then
you have retry until and retry until
creates a new generator it gets the
first generator and it tries it asks
this generator to generate values again
and again again until the condition is
satisfied right
besides that Chan also provides really
nice utilities you can use to create
your own generators you can let's say
this this is quite cool you can just
choose between values it actually gives
you a range for all the numbers you can
also use one of one of is well yeah
generating optional values is one thing
but you can also use it for generating
in lumps also for string let's say if
your customer for some reason just can't
have names containing Chinese symbols
you can use alpha string you have
numeric string which only has numbers
you have you can have positive numbers
you can have negative numbers and there
are like loads of other utilities
available in
John just quite cool hmm yeah shrinking
again yes I can
any questions so far no okay um maybe
later
so shrinking so shrinking is provided by
Scala check for some standard types like
string and integer and tuples so let's
say you can you want to shrink a hello
world string it's gonna literally going
to try to shrink this string like that
right so you're gonna get hello world
and stuff like that right but it's gonna
get a little bit more complicated for ya
this is sorry this is double example
also provided basically you asking Scala
check can you please shrink couple of
string can in and yeah it can can you
don't need to do anything for that right
it gets a little bit more complicated
when you have a like your own custom
case class right let's say you provided
a generator for that and then you have a
property so here we have optimal
proposition with like name and score and
our property we are saying that well all
optimal propositions should have
positive score right and once you run it
you see we only have one line here we
only have one error saying it failed on
optimal proposition with this value with
this score right it didn't actually even
try to shrink the this case class right
so what you can do you can provide this
shrink for optimal proposition and you
see how many how many how much code
actually I had to write and this is just
using a composition of standard shrink
instances so I'm using standard shrink
for double string and in and I'm just
constructing an optimal proposition so
that's how you shrink so basically the
shrink optimal proposition you just need
to shrink a couple of string and in and
to be able to do that I have to write
all this word called
and of course when when I run the test I
would I would get two values here right
so get original and I would get the
shrinked one and before that it was just
only one right so obviously I can see I
can see the benefit I can see the
benefit of it so it's very it's easier
to see that okay they it fails on the
minimum input of zero Yeah right you can
also do shrinking with Scala check shape
of scholars check it as I said it
provides it provides generators for all
the case classes I mean it will generate
it for you but it also will generate
shrink instances for you as well but
it's not what I'm trying to say it's
it's not gonna get so easy if you have
restricted generators if you if you want
if you want to if you have a modified
generator for for optimal proposition
which just generate strings containing
alphanumeric characters which just
generates integers in a range of these
and discs then then you're shrinking
stance is not gonna work so you have to
you have to modify your shrink instance
as well and there is no correlation
between your generator and shrink so
basically you modify your generator and
there is nothing to tell you that hey
you forgot about your shrink instance
actually and at the end you can end up
with some fail failed test which will
give you like original value and then
shrinked value which doesn't even make
sense so I guess that's one of the
reason we don't really use shrink
instances on our projects really often
right I also want to talk about this
thing called testing testing pyramid
anyone heard about this I hope like here
most of people hurt right so the idea
it's quite easy it's basically you write
lots of unit tests not that many
integrated integration tests and like
very little end-to-end tests
like happy pass right so when you think
about property based test what we were
trying to do in our project was well
obviously to write all the unit tests as
property based tests but at the same
time we wrote all most most of the
integration tests as property based
tests as well and I actually think that
it's way more beneficial to have
integration tests as a property based
test because there are so many moving
parts and I know it's very expensive
it's very expensive to write this kind
of test we spent lots of time of writing
them and basically every time something
changed you can study you can spend lots
of time to maintain this test but at the
same time for some reason when people
write example based tests on integration
level they just forget about age cases
so when we when we write unit tests we
just we are really good at age cases we
we're gonna test all the all these zeros
and Loused values and exceptions which
are even possible but on the integration
level for some reason we just like do
happy paths of stuff like that and it's
amazing how many actually age cases
which is covered by doing property based
tests on integration level let's say
simple things like databases actually
like generating some some generating
some entity inserting in today's based
selecting it and checking that is the
same value we found lots of box like
that yeah that's called round trip and
during the the work at this project I
found like couple really couple of
really useful patterns and I think round
three round trip is the most amazing one
it's very simple basically let's say you
have a string you reverse it and then
universal back and you climb that it's
the same string surprisingly this
pattern covers a lot of test cases in
the commercial applications
first of all is just data transformation
let's say you have a data transformation
which transforms into a different shape
and then it transforms back it's quite
easy right but another one is Jason we
all probably do Jason conversion
converting one object into Jason right
so here we have a generator for Jason
object of a special shape and then we
are claiming that for this generator if
we create an object out of this
generator and then we create a Jason out
of the subject we want this Jason to be
the same as the one which was generated
also really useful and it discovers some
weird errors with dates of first of all
nulls for example when you create a JSON
object out of empty string is going to
be now I'm not presented so basically it
helps you to achieve some consistency
another pattern another usage of this
pattern is probably database the one I
already talked about so you generate an
entity and then you insert this entity
in the database then you select it back
and check if it is there another user
for pattern is invalid input so when you
generate arbitraries you don't sometimes
you forget about invalid tree invalid
data right so here let's say you have a
CSV parser right and you can have a test
which would get which would get an
arbitrary of invalid CSV files and it
will just check that well it will fail
all the time and I found that having
generators will generate invalid input
is quite cool it it also helps you
discover what's going to happen with
your application if it's invalid just
basically making your application files
safe there is also a thing in Scala
check where you can generate function
I haven't found the usage in my
application or for this functionality
but the title looks cool maybe if let's
say you have a more like a function
which you don't care about and you tend
to mock it maybe you can use a generator
for that so here let's say we we asking
Scala check hey can you can you please
give me a function from into string and
the cool thing about it is you can you
can provide this function while the same
values and the result will be the same
right and if you provide different value
the result will be different yeah it's
kind of interesting so expects to and
scholars check that's what we use in our
project that we found it's a it's a very
nice combination I guess the reason is
because we still have example based
tests we can't really use we can't
really do all the tests to be property
based tests and spec still provides
really nice support for that so yeah so
I'm done with Scala I want to talk about
other languages do you have any
questions about like what you just heard
yeah
I will talk about it yeah but it's a
good question it's a very common problem
so sorry I can repeat the question the
question is how do you prevent yourself
from reemployment in the same logic in
tests as this was in production code
there was actually a really nice stop by
I don't remember the name of the guy he
was talking at Scala dot
the conference happened like maybe a
week ago I and he did talk about it
actually yeah he gave a really nice
example on how to deal with this problem
but yeah there is a tendency when you
when you write a test property based
test you there is a tendency to
re-implement the logic for example you
you created the function for quicksort
which takes array of numbers and do
Indust quick sort of it right and if you
think about how would you test it with
property based you would generate an
array of numbers you would sort it and
then you would assert that it's been
sorted the same way as your new function
right so you would have to re-implement
sorting right but the only difference is
you don't have to implement the solution
you just need to implement a solution
right you don't have to implement the
the quicksort and i guess that's one of
the thing and none of the things is what
we do in our project we just split our
input into different cases and I it's
it's it's hard to explain I I can show
you in the example later any more
questions about Scala yeah
we found that it is really slow went
with with like database we wanted to run
our tests on real database because we
use Oracle there is no point to pretend
that we using in-memory database it kind
of loses the point and it was so slow
because we would actually well erase and
recreate databases every time we run the
test and we just started we just changed
a little bit our patterns of using
running this test we would reuse our
databases which is not as clean as you
would imagine but at least we're not
sacrificing the quality because the
other alternative would be to change the
parameter called minimum run minimum
test right so by default does 100 tests
you could change it to 5 you would
sacrifice probably quality a little bit
but it will be fine with the speed but I
don't think we ever I've never I've no
no just and I'm not just it to be slow
on like a JSON round-trips
because it doesn't really involve
anything kinda
however it is really slow on compiled
time like once you have a very big model
and lots of generators it's just
impossible to work especially if you
work in IntelliJ IDEA and expect expect
it to help you to like write code it
doesn't because just too busy compiling
stuff yeah any other questions
yeah because I really want to talk about
other languages I have fun alright so
the reason I want to talk about other
languages is I still want to see
property by stating like as adopted
practice and mainstream technologists
and you know what pretty much every
mainstream language has a has a scholar
cheque has a property based testing
library Java and Ruby and JavaScript
like anything so here I'm gonna show you
some Ruby I used the library called
variety I don't think it matters which
library I use because the library is old
no one supports it
and I'm sure we already created like
hundreds of more property based test
libraries but anyway so this is another
important problem of software
development fizzbuzz so here in in Ruby
it's also quite easy with this library
you could have do something like I want
to define a property of integer and I
want to check it and I expect you know
if it's divided by 3 and 5 I want to be
fizzbuzz if it's dividable by 3 I want
to fees and then bus and this easy right
and here's what you are talking about
basically I just really meant that the
whole solution right it looks exactly
the same
so this bus is not actually a real
problem but it does happens in
production so what I would do in
production I would actually separate
this into three or four different test
cases 1 2 &amp;amp; 3 &amp;amp; 4 and then you wouldn't
have to actually implement it and then
you would provide different generators
for those 3 inputs right so the first
generator would be all the numbers which
are dividable by this second and etc
like that and this is rust yeah this is
not one which I won't talk about I don't
really I don't really know rust but
there is a property based testing
library in rust as well I'm not actually
climbing it's a mainstream maybe it will
be at some point so anyway there is a
function called peas and it takes two
numbers integer and integer or something
like that and it gives you back optional
your size so it's just a multiplication
it's an alternative multiplication
it's called peasant algorithm you
probably don't know it it's fine so how
would I test it right
I will ask quick check to check this
property called passant is the same as
multiplication right and the shape of
this property will be a function which
accepts two numbers and give me a
boolean back and
then I will define the property itself
right it accepts two numbers and gives
you boolean back and then the property
itself right so when I invoke my peasant
with these two numbers right it has to
be the same as original rust
implementation of multiplication easy so
it is possible in rust as well that's my
point
I guess that's the end of the talk I
don't really have any conclusion I don't
really want to say that writing property
based test is about quality
it doesn't actually guarantee inequality
it just gives is any other like test it
just gives you support and I think
property based test gives you even more
support so no conclusion just just want
to ask you to like go and do it yourself
in your mind stream languages or like
non mainstream languages thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>