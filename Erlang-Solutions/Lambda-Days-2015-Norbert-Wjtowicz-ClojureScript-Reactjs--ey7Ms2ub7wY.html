<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2015 - Norbert Wójtowicz - ClojureScript + React.js (...) | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2015 - Norbert Wójtowicz - ClojureScript + React.js (...) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2015 - Norbert Wójtowicz - ClojureScript + React.js (...)</b></h2><h5 class="post__date">2015-03-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ey7Ms2ub7wY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Oh hopefully you've all had your coffee
because we are going to go flying
through this first hands up
who here has some exposure to web
development in general raise your hands
awesome that some kind of web frameworks
back Bo and angular or you guys just do
pure native okay functional programming
who here has done functional program
that was a trick question this is lambda
days and closure and you closure people
are okay sweet you guys can just go I
mean you have nothing to learn here so
if none of these things interest you you
should go to the other talk because I'm
sure it's awesome and it's about Erlang
so who is this guy and it's so light it
actually is completely invisible awesome
so hopefully my slides won't look like
that we'll see how that works
so who is this bloke and why is he
talking to you so I've worked in a
variety of industries that are very
different from each other and I've
worked in a variety of Technology stacks
that are very different from each other
whether it's object-oriented functional
very low level assembly and so forth and
over time I've gained some you know I've
gained some perspective I've figured out
some things and one of these things I
figured out is first of all I am NOT a
front-end developer as far as you know
graphics and Photoshop is concerned I
run away as if it was a plague and even
though I produce a lot of JavaScript a
lot of CSS I don't consider myself in
front of élber and I would never hire
myself as a front-end developer on top
of that it turns out that I'm not as
very strong backing developer either now
I admit I I've seen lots of scary things
and I have developed a sense of smell
for good and bad code so I have a pretty
high squelch filter if you've ever you
know write a pull request from me but on
the other hand I know a lot of people
who are a lot smarter than me right like
I've come to accept that so the way I
fight this battle that there are a lot
of smart loves smarter people in me is
my forte I turns out is figuring out
what people's problems are and solving
them through software like I have a good
knack for drilling down to the root
cause that someone is really fighting
with and I'm proposing a software
solution well because there's only
smarter
people than me working you know in a
similar field I have to cheat I have to
figure out a way to you know be better
than them and the way I do that is I
figure out what is the best tool for a
job so basically I use stuff that most
people don't use because it's a way for
me to keep up ahead of the curve keep a
head out of people that are smarter than
me and that brings us to this talk today
because here I am talking to you about
closure script because closure by itself
is a really fascinating language it's a
really well-designed they have they
chose some very pragmatic things they
made some very pragmatic very cool
choices and it's really nice how well
they embrace the jvm but we can have a
discussion you probably will over beers
later weather closure Erlang Scala or
Haskell for example is the best suited
you know language for a specific problem
to solve and so that's closure but the
thing about closure script this closure
script and react Jes they basically blow
the competition out of the water there
is nothing quite like it for the front
end so it becomes a no-brainer to talk
about and start working with this stuff
so let's talk about web applications and
Isis if eclis say applications not
websites we're talking about big complex
monstrosities right that we want we keep
pushing more and more logic into the
front end so in the beginning there was
jQuery and jQuery o is awesome because
finally we solve browser and consistent
problems and we could finally just start
building things without worrying about
what specific browser is gonna be
running on and it was brilliant because
it let us build bigger and bigger things
but that basically turned to jQuery soup
right because at some point we were
building these crazy things and the lame
the technology wasn't keeping up keeping
up with the things we were trying to
build with it so then we came up with MV
star right MVC whatever there's a bunch
of them and they all basically are the
same thing and this led us build bigger
application than we could with jQuery
but basically what happened is we
repeated that cycle we started building
bigger bigger things and now we have MV
star soup and I have seen some of these
monstrosities and they are insane trying
to maintain this code I'm just checking
the time here so basically I have a
feeling we're sort of and we were sort
of affected by Stockholm Syndrome we are
these frogs boiling very slowly in water
and the project keeps growing in
complexity keeps growing in complexity
but because it grows very slowly we sort
of just keep adding on to the project at
some point we realized that we went in a
very wrong direction but it's too late
to come back right and we keep doing
this over and over again I imagine if we
were thrown into that big bucket project
from the beginning that was boiling
water we would jump out but because the
projects tend to grow very slowly in
complexity we don't really notice it
until it's too late so let me introduce
maybe a different way of thinking about
web applications and instead of models
views and controllers let's think about
a rendering and events because when you
when you come down to it these are too
primitive axioms that need to be in
every single web application you need to
have some weight of rendering things
because otherwise what's the point and
it turns out that as far as browsers are
concerned events are the only way to
figure out that things are changing so
we can just build up on these two axioms
just check my time so I want to see how
fast we're going oh it's sweet
so our first superhero today our first
superior today is react yes who here has
played with react yes who here has heard
of react yes okay so for quick summary
rate this is Facebook's open source
library that's a rendering that's
basically a better rendering engine than
what we currently have and I want you to
forget everything you know about react
GIS in the sense of forget about flukes
and relay and graph QL and all this
other stuff that Facebook is pushing out
I want you to think about react.js as a
very primitive black box that's just a
better rendering engine than what you
have currently so similarly to how v8 is
a better JavaScript it's an optimized
JavaScript engine for your browser
react.js is their new optimized
rendering engine for your browser right
and in order to have a you know sensible
discussion here we need to we need to
have the same mental we need to build up
some mental models so we understand each
other
so the first mental model is what the
guys at react were thinking when they
were building this thing because they
took the idea from video games and how
video
and that video games are designed in
such a way that you have a hardware that
renders for example as sixty frames per
second and that's your critical code
section you can never let that slow down
because people will notice that graphics
just you know there's lag and all these
other things
so that's your critical code sixty
frames per second whenever the the
hardware isn't doing exactly that
it has some CPU cycles for you to do
stuff in application and that's the only
time you have time to do things in the
application so we're gonna start
building web applications in exactly the
same way our browser is rendering at 60
frames per second our application is in
a different let's call it a different
thread and the only way we can
communicate with the browsers to react
yes we can never touch the Dom exactly
we can never touch the Dom in the Dom
doesn't know anything about us
everything is through react.js it's a
brick wall a second mental model that I
want you to sort of envision is that
everything flows downstream or if there
are some Americans around there's
there's a much more vulgar version of
that so you have a data model and then
you have some code and your code
transforms that data model into a
virtual Dom and the virtual Dom is just
a different data representation of what
you would like the final browser
rendering to look like oh yeah sure
better sweet okay so over here now over
here yeah so okay the data model it
converts your code into a virtual
representation of the DOM and then
react.js takes over you do nothing more
and rear JS figures out what you wanted
to render and it figures out what the
browser is currently rendering and it
just basically merges the two concepts
so if you want a more specific more
concrete example let's take some data so
it's a vector with a hash with a tweet
and some string and you have some code
that transforms that data structure into
a different data structure which is what
you would like your HTML to look like
and that's the final output of your
application the react.js takes over at
this point and figures out what is
currently in the browser and it figures
out how to make that the second part
look like the third part
and you have absolutely no input in say
into this and the reason for this is
when you for example change your data
for example you add a second tweet and
your code generates a brand new webpage
because of the because of the fact that
you don't know what your browser is
rendering you can't tell it just add a
second list element to the list right as
far as you're concerned you're rendering
a completely brand new page and the
beauty of react.js is they have a very
good dipping algorithm that figures out
what really has changed and figures out
the optimal way of doing batch updating
of your entire application to render it
in the browser and everything flows in
one way right so this is just a
different way of looking at the exact
same problem I want you to just keep
this in mind because we're going to come
back to the later so you have some data
the great one is your virtual DOM and
then that's a real browser closure
script next here over the day I'll just
talk about data representation it turns
out closure script is brilliant and you
know data and converting data from one
thing to another but if we want to talk
about closure script we'll get it how
about closure
what is closure well closure is a list
yeah but closure is a list that gives
you all of these crazy things and what
does it have to do with closure script
well it turns out closure script is
exactly all of those exact same things
except the Interop is with JavaScript
instead of with the JVM now I want this
to sink in for a minute for people who
are right now developing application was
a CoffeeScript and underscore.js or with
typescript or a dark look at all this
functionality you get for free this is
not just pretty
syntax sugar these are completely new
semantics that let you think about your
applications in brand-new ways and you
get all this for free and this is not
some you know crazy dream this is
something you can go home and build
production apps right now it's crazy
that we're not all program and closure
script right now it's just crazy there
must be a catch what is the catch I'm
sure you know you often hear about all
these languages they give you all these
cool things but then when you sit down
to actually do something with it it
turns
that it's a nightmare I'm sure that's
exactly what happens here so in order to
you know sort of disprove this notion
and we're gonna build a hello world app
first we need to address the elephant in
the room the elephant in the room is
that this is closure and so it has
parenthesis and you need to deal with
this I we're all adults here
and this is something you have to deal
with it's a list
it has parenthesis if this is the thing
that's blocking you from building much
better and complex applications then
you're in the wrong talk seriously I'm
not even gonna try to convince you
otherwise
but let's say you're a little more
adventurous and you actually want to try
this out you need to have some
understanding of how closure or syntax
works in order to understand the slides
so this is your 30 second introduction
to closure that's a comment that's I'm
shaking that's a function evaluation
then this is a way to define a function
this we're defining here a profile which
is a hash with some key word strings a
vector and a set this is some syntax
sugar for pulling data out of a hash and
you know setting a new data on the hash
and then that last example in the bottom
which can is barely visible here is a
little example of how destructuring
could work you know also nice syntax
sugar we've got a little we've got a
little time so is there any questions
about any particular syntax here what is
so funny okay I'm just gonna move on
because shout out any questions you all
know closure I have no reason to be here
I can go home sweet so close so you've
got the syntax down but any real
programming environment has a little
more than just syntax so let's introduce
boot any Ruby developers here hands up
or have played with Ruby at least okay
so boot is like RB n plus rake plus gem
file plus bundler all rolled into one
was a cherry on top so for anyone who
hasn't done Ruby basically this is a
first of all this handles your runtime
environment so
it figures out exactly which version of
closure and closures computer want to
run and it runs into the sandbox it
figures out all the dependencies you
listed and make sure there's no
conflicts and you know bundles all this
together in order to run it and then on
top of this it lets you build your own
custom tasks so though it let's see it
gives you a way for example for you to
define what it means to build a
development or production version your
own application and deploy it right so
it does all this which is awesome and
there's a huge asterisk to boot because
line is the de-facto standard in the
closure community it does exactly all
those same things but it has a very
different internal implementation now
the reason why I'm going to talk about
booting not line is boot configuration
fits on a slide align does not and the
second reason is that today maybe not
tomorrow but today if you're interested
in closure script but you have not
already drank the kool-aid of closure
you just want to get started boot gives
you a much better ramp of experience for
just closures good programming right if
you just want to go from zero to hero
boot is something I can explain it in
two minutes and you're good to go line a
little more difficult but there's
nothing wrong with line so go ahead and
use it if you want the other technology
that we need to have is a wrapper for
the other thing we need to have is a
wrapper for react.js so in this case
we're going to use rum and again huge
asterisk omen reagent are both very fine
libraries and they are far more mature
so I've used both of them they're really
good and the reason we're going to talk
about rum is first of all it has very
interesting semantics I'm really excited
about and the second reason is because
of those semantics it can emulate omen
reagent so using just this one library I
can actually talk to you about all three
and you can decide which one you want to
use later on and rum is definitely very
alpha right now so you know just saying
oh very good question so why do you want
to rap react.js first of all because
react.js the API is very it's very
object oriented so it it creates very
non idiomatic coding closure I mean
there's no reason why you can't do it
all
all those libraries do is basically
write a couple macros that wrap the
react.js
library right so it's something you
would have done probably in your code
anyway because it's just it doesn't look
very pretty if you just keep using the
object-oriented version in your code
everywhere so if all these libraries at
some point they people were using the
API specifically and just started
writing their own helper functions and
so that so basically this is what turns
out but the nice thing about it is as
we'll see after that after you wrap just
the nice better syntax you can add
additional semantics that you would have
hard time doing if you just use standard
react what an end of the day this is
just pure react code right is there's
just nice wrappers for it so you need
four files to write a production closure
script application so anyone who has
ever done you know built or ran rails
knew or you know built any kind of
backbone project or anything you don't
believe me but all you need is a HTML
file a CSS file and that's totally
optional by the way an actual collage or
scope file and the buddha build right
then I mentioned that's going to help
you set all this up the HTML file is
just you know right now it's a classic
html5 skeleton the most basic thing you
can do there notice that there's no
mention of closure script or different
runtime environments or anything the
only thing you really have is this div
id app where we're going to mount the
application into boot figures out at
runtime and injects the proper script to
make everything work whether it's a
development or a production environment
this is a basically a whole world of
closure script we have a name space
below core we require the rum library we
create some data so we have a post with
a title and author and we create a
render we create a react component so
Ramdev c is a macro that takes what
looks like a closure function
and wraps it in a react is it basically
it creates a react component class and
creates a constructor for it and
implements that as the logic of that
class so this is if you export this out
this actually looks like a react.js
component class that you can use outside
of closure script per se in this case
this function just deconstructs two
pieces of data from our post and creates
a block code text and the last thing it
happens is we mount this so a rhumb
mount that's the component I'm
interested in and that's the part of the
Dom where it should be mounted into and
should be rendered build that boot so
what we have here is we basically set a
source of HTML so that's where all fries
are located we include the dependency
we're interested in this case we're just
interested in closure script react and
rum and we include a bunch of helper
development plugins basically so with
this we're gonna get some Co GS GS which
is a way to pull which is a neat way
you're pulling additional JavaScript
libraries like momento or whatever else
you need you have Steel J's for apples
so you're gonna get a browser of the
repple apple browser you have boot
reload which is going to reload your
code anytime anything changes and boot
HTTP which is going to serve your files
so you don't actually need to have a
server running they should be server so
those are the helper functions we get
and the way boot works is these are
defined as tasks and tasks are something
that on the one hand you can use in your
code as a function and on the other hand
you can run it from the command line as
an option so if you don't want to keep
running the same commands in the command
line you can basically compose using
functions right because this is
functional programming
so you basically compose a bunch of
tasks I call this build dev and then I
use build dev as a part of my dev thing
so when I run boot dev in the command
line it basically starts watching all my
files for changes it serves all the
files it creates a ripple from my
browser it builds the entire project and
it will auto reload via WebSockets
whenever anything changes so
what just happened in five minutes we
basically got a setup that's probably
better than what you're currently doing
your front end because on top of
everything else that's cool about it you
have outer reloading via WebSockets
right so and you have an actual browser
repple that's not this is not this is
not no js' this is a rebel into the
browser in your Chrome so when I for
example add one to the string to closure
script tells me that's not a good idea
but it's JavaScript so it'll return a
result and if I tell it alert hello
an alert pops up in my browser because
this is connected via WebSockets to my
actual browser running session right so
this is amazing for development just for
you know quick prototyping so we've got
a whole world and it's great but let's
talk about you know building big
applications right because that's why
we're here so rendering I guess you can
you can explain it as you have a data
bottle and then you have a data
transformation and then there is no step
3 because react.js takes over but in
fact and and the thing about react.js is
if the data transformation that comes
out of it is the same as what's in the
browser then react.js is no op it's not
going to do anything but it turns out
you can do even better than that because
if you know that nothing has changed you
can actually tell it not to even run the
data transformation because there's no
point because you know nothing has
changed so the thing about ROM mix-ins
is they can you can specify logic of
what it means for things to change and
each project is different and that's why
ROM doesn't tell you what you should be
how you should define changing state it
says here's this mixin you know API do
what you want with it so an example of a
very basic mixin is Rama static we made
our next superhero enclosure which is
immutable data structures are persistent
if you will and if you have persistent
data structures you can abuse it in the
following fashion you can say that
you're creating a label that's a static
and Static basically says that
this thing never changes unless the
arguments change so when you do label
hello and you do label hello again there
is no actual rendering because the text
has not changed right it's the same
string as far as persistent data
structures are concerned and this is
actually even faster than if you do
react native because closure script
gives you that guarantee that this is an
immutable data structure it turns into
an O of one operation it's it's checking
pointers right this is better than what
you could get out of out of standard
JavaScript at my age is so rum reactive
that's another kind of mix and we can
talk about and by the way this is
exactly what reagent does so if you want
to use reagent this is what you're
thinking of so reagent basically it
leverages clojurescript atoms so what
are atoms closure has a couple of nice
semantics couple different tools for
talking about concurrency and sharing
state and one of the things is atoms and
atoms are a way of talking but you know
basically sharing commutable sharing
figuring out a way to share state
between different components that's
independent of each other and it gives
you some nice guarantees for example you
can do atomic updates that are there are
free of race conditions and on top of
that you get some nice API is that you
can actually for example watch for
changes on an atom and trigger which
will trigger some some events so an
example of how you would do this you use
this in the front end it's for example
you create an atom called to do which
has a title hello and you create this
component item and basically you say
that this item this component is
dependent on changes to this state and
whenever this state changes I want you
to re-render magically and then you
mount this as a to-do and then every
time somewhere in the code someone
modifies this atom this component knows
to re-render itself right you've
decoupled that information another cool
trick you can use with atoms is
sometimes you there are components that
are separate but they need to share some
state and it's sort of it's it's local
state to them but it's it's not within a
specific component and so atoms are a
nice trick for solving this problem for
example
a text field and you have a search
button those two pieces those two
components share a piece of information
which is what the user typed in and a
night with a nice way of doing this is
wrapping this in a closure and the
closure shares an atom called Val and
the input box reacts on this Val and
resets the Val and the input and the
button can read that Val at the moment
the user clicks on it is that clear
awesome you guys are the best
no questions from cursor so this is what
umm does almost a very different
philosophy oh I only has a tendency to
say the way to build big applications is
to have one big atom that's your just
entire world state and all of your
components figure out what data they
need from that atom this has some very
nice properties when you build a system
this way one of these properties is that
you can start thinking about changes as
not passing an atom around this huge big
state but you can think of it as chain
as a stream of diffs a stream of small
updates another nice thing about this is
that you can actually dump Oh dump your
entire state right you can serialize it
you can sterilize it to local storage
you can send it over the wire and then
you can for example load up a new
browser and you see the exact same thing
that user was looking at because the
entire application is rendered from that
one big state another nice thing that
you get for free is you get basically
infinite undo because undo basically at
this point means that when something
changes you don't lose that old version
of the state you store it somewhere
right and because yes question we're
talking at the we're talking at the
browser level right so we're talking per
session yeah but that's not that's not a
problem per se because if you got to do
multiple users there are ways around
that right yeah but yeah true I'm
constantly thinking of the browser right
this is where I'm at right now single
thread one user so undos are basically
for free and and the the best part is
because of immutable data structures
they're actually very cheap you don't
waste a lot of memory to store all these
additional
so that's what ohm does but there's one
problem with with this with this
approach and the problem is that
basically all the components get this
reference to this huge piece of state
and they need to know which information
in that state is relevant to what they
need to render so this creates a very
crazy coupling between what the global
state looks like how much each component
needs know about it and cursors is a
solution to that problem and the way
cursors work all the way on the bottom
here is basically you say this color
thing that label is interested is inside
AB settings color and it creates a
cursor reference to that part in the
state so when someone changes color
label gets updated even though it
doesn't know anything about the fact
that it's information is in app settings
clear less nodding than last time okay
so those are some of the built-in makes
ins you get with with the library but
the thing is because of the semantics
you can basically build your own and on
top of that really nice thing is you can
mix and match so within one application
you're going to start using different
versions of this render on change
mechanism for different parts of the
code base because for example your your
primer your your main app maybe is a
reactive but then some parts are courser
and then some parts are static and then
some parts are completely different
right you can write your own stuff what
does that mean write your own stuff well
simple example is rough something I call
rum delayed here's the problem you have
to solve you have a post like a tweet or
a blog post or whatever and has that
string posted X seconds ago X hours ago
now imagine your use cases you want that
to always be true so as the user is
leaves the webpage open you want to see
that thing ticking correctly and
updating itself well since you have a
granularity of one second the most
obvious solution is just to every second
check if I need to rerender this but
that's silly because once you have it in
days you have a granularity of days you
just need to know that neck
today check if I need to rerender this
so this is something that creates a
local state and a very specific
mechanism for rendering but it's very
specific to the view there's no reason
why the rest of application needs to
know that something like this exists so
this is a perfect example of where you
would create your you would create a
custom mixin for this write to explain
this situation another much crazier
crazier thing is data script who here
has heard of data log so this is data
log one of the one of the things about
one of the let's say popular
applications they don't log right now is
it's the query language for the de Tomic
database so it's a query language is
similar to sequel right to some extent
and it has very specific properties
about how it works I don't really get
into it but the thing is you can
basically start writing your views as
queries on some data so data script is a
port of the data log query language to
JavaScript so you can actually have an
in-memory database in your browser and
you can query information against it and
on top of that you can create views that
are not dependent on state like an atom
they're dependent on when the quit when
this query would return different
information that's when I want you to
rerender itself and the beautiful thing
is data log is reversible so let's say
you load up a bunch of data and then
over WebSockets you start getting more
data right and then at the moment that a
WebSocket comes in with more data you
can actually reverse all of the queries
that are on your views and you can
figure out which views potentially are
affected by this change without actually
running any of the queries it's
brilliant but it's crazy why would you
do that right well here's here's a use
case here's a common use case this is
github issues with rails code but this
is a very common scenario in our let's
let's call it business applications
these days and the issue is that you
have a list of things and you have a ton
of filters right and your requirements
are basically anytime I need
here changes you need to change this and
on top of that the query the recurrence
usually become crazy like for example if
you select a specific milestone on that
author drop-down I only want you to show
authors that are actually legitimately
in that milestone so you know you have
tons of different states that are
affecting each other and the way this is
usually you know this way this is
usually implement this is what github
does is every time you do something here
it sends a query to the backend that has
all of these different parameters as
query params and the backend basically
has all this logic of what the front-end
should do for specific situations and it
returns a JSON back of what things you
should display but that's silly it's
silly because rails issues which is a
pretty big project has what six and a
half K six thousand issues let's say
there's ten thousand let's say there's a
hundred thousand issues on a huge github
project if you take all of that data
just as raw tedx of you know like the
titles and all the different labels you
can sort by we're talking about a couple
hundred K of data maybe a megabyte you
could just load this up once into your
browser and basically render all of
these things using a query which is
insane which is much faster than
anything you could do just counting the
round-trip time to the server and back
you know I'm not even talking about the
fact that you no longer have to
implement front and logic on your
back-end you don't have to have some
crazy endpoint just to do this thing
right because this is basically just
this is just view logic nothing more and
if you think this is just crazy
dreaming the guy behind data script
wrote a hackathon project called a
ChaCha and basically this is a this is
like one of those you get badges for
different kinds of commits and things so
this is this project the first time you
load it up it's about a Meg of data I
think right now where they just keep
adding more and more rep O's to it it
loads up all of the repos all the users
and everything and whether you're
looking at the page of all rep O's or
you're looking at a specific rebel page
or you in this case you're looking at a
specific profile page all of this stuff
is rendered in real-time all this is
done by querying right we just load the
raw data into the browser and then we
render all these views using
query language events so we've covered
1/2 of the equation and then 1/2 of the
equations rendering now let's talk about
events because as as brilliant as
everything I've been talking about is we
basically solved the problem of we have
a data which is some domain data right
its domain data which we figure out how
it should be rendered for example one
domain data can be render into you know
ten different things and then we render
into the browser but the problem with
you know front-end development is it's
all about events it's all about changes
that are happening
it's nothing is static everything is
dynamic so the question is how do we
handle all of these changes how do we
handle these events from Ajax from
WebSockets from user inputs from
JavaScript events from thousands of
things you can think of right now right
that are generating events what is this
black box that's gonna help me tame this
beast and return a simple data model
that I can use well it turns out korie's
sync is the answer that closure gives
you for this problem so what is Cory
Singh first of all how many people have
played with query Singh or have heard of
it
awesome you people are in for a treat so
one thing that cory singh is it's a way
of thing of writing asynchronous code
that looks and feels synchronous here's
an example let's say I write an infinite
loop that returns a value 1 every 250
milliseconds and then on top of that I
write two more infinite loops so I've
got three infinite loops running already
and then I write a fourth infinite loop
that basically figure that takes this
data that I was generating and you know
renders it in some fashion how does this
work in JavaScript you know I remind you
that JavaScript has no threads silence
sorry there is not there is no even clue
in JavaScript there is the way this
works is go is a macro and the macro can
parses your code figures out what is
asynchronous and turns your synchronous
looking code into a set of callbacks in
the case of JavaScript because
JavaScript doesn't have threads in the
case of closure to either do it threads
or or it'll do either threads or I'll do
parking threads or a loon or it'll do
callbacks right like green threads and
so forth it depends on what you want but
in JavaScript you want threads so
basically by default it'll do callbacks
so basically you're still writing the
same callback logic you would do in
anyway in JavaScript because javascript
is all about asynchronous coding but the
thing is you hide all of that complexity
of handling and basically babysitting
all these callbacks you can write code
that looks synchronous but that behaves
asynchronously
I want this let the set in for a minute
because I want you to think about how
you would write this in JavaScript
without this kind of syntax you would
use promises yes there's there's some
things that promises can't do that Corey
Singh can but I think we can get into
that later but even with promises it
wouldn't look this good we're just sort
of like promises right yeah so what else
is cory sink well when you have a hammer
everything looks like a nail
once you learn core async everything
looks like a cue everything looks like a
cue seriously I can't stop thinking
about cues let's say you have a
requirement and your requirement is that
we want the user has some input search
and I want you to search the web image
in a video API for this query and return
the result but I'm only interested in
the first result you get back on top of
that we want this to be fast so the
first time you do this query and you get
back a result stored in the local
storage and the next time I user
searches for this thing
fetch you from local storage available
and on top of all this I want this to be
fast if you can't figure if you can't
deal with this in one second I just want
you to give up I
I'm gonna go to plan B now think about
how that code how those requirements
would look in JavaScript where you would
have to handle all of those callbacks
and that callbacks are dependent on each
other because it's not enough for an API
to succeed it needs to succeed before
any of the other ones succeed this is
how this code looks like in closure
script right this is not pseudocode this
is what you would write you would write
a bunch of queries and they would all
right to the same channel the idea is
that web query when it gets back a
result it pushes it down to this channel
C and all these other ones do the same
and then we have a second channel
timeout which is and the way timeout
works is it creates an implicit channel
that after one second will return a
result onto that channel and then
there's this magic method called alt +
alt basically says give me the first
result from any of these channels and
ignore anything else it does exactly
what you wanted you know it doesn't it
says it does what it says on the box
basically right so this is the kind of
stuff you can start building like these
are the these are the primitives these
are your new language primitives so
imagine what kind of new complex things
you can requirements you can start
thinking about when these are your
primitives right so it turns out that
chorusing because of these things is
really good at decoupling code because
once you have channels you start
thinking about component modules as
components and the components the way
they communicate with each other is via
channels so anytime anytime I have
something that wants to do something I
give it a channel I say when you're done
with it just push it on to this channel
and I'll make sure that the right people
will start reading from this channel
when they're interested in this so
basically that core icing solves that
problem that we were talking about right
now for something completely different
we're 40 minutes so we're pretty much
right in time I knew I wasn't gonna be
able to cover lots of stuff and I don't
want to keep you from lunch so I just
made this one slide that says this is
all the stuff that you need to learn
because it's awesome
but that I don't have you know exact
spot maybe if you want to you know waste
a little bit of lunch I can probably go
into a couple of these if you really
wanted to
so transducers are super awesome they're
a really nice way of thinking about
there's something it's like innumerable
squared it's a new way it's like that
it's like that what a numeral should
have been from the beginning and
CoreLogic is basically a prologue clora
matches pattern matching reactive de
react native is what's going to
hopefully come out soon and it's gonna
be awesome right because then i'm gonna
be able to do this on the mobile as well
i'm gonna be able to apply all these
crazy things i just told you about
Senta is a really cool library if you
are basically if you want to write a
closure backend and a closure script
front-end Cente there's a lot of the
boilerplate for you so it you know has a
way of figuring out Ajax and WebSockets
and all this other stuff so it does
everything for you if if if you're
basically committed and you don't mind
that coupling between the two transit is
the library you need to be using if
you're doing closure script and you're
parsing JSON or anything else it's just
a really good library and it's much
faster than parse jazz and the parse
JSON the default one that comes their
closure script because it uses native
code from your browser and leaving is in
close is a implementation of Stuart's
here as components but it's one that it
works with closure and with closure
script and basically leavin or
components or components are a way of
talking about even bigger systems it's a
way of comparing systems a much much
bigger applications into these systems
that are independent of each other and a
way of figuring out for example which
order things need to start in what is
the coupling between them and so forth
if you're if you're like me and you
really like haskell for example and you
want types prismatic schema and closure
typed are two very different I employ
men tations ideas of what it means to
create more type safe closure code right
so that's something you guys should
really look into and two real huge
notions from Ricky simple versus easy is
a really great talk you needs to see it
and thinking about accidental versus
essential complexity is also something
that I want you to have
on your radar that's pretty much it on a
more personal note I've been playing
with this idea of basically bringing
closure script to more people like this
talk is one way of doing it I did a
lambda lounge talk which is very very
different it was live coding and I'm
doing a talk and wrote Slav soon which I
think is gonna be very very different
from this one because why repeat the
same thing right
but except for that I've been working
I've been playing with this idea of
building something of a more of a bigger
course I guess like a lot more a lot
bigger thing that sort of takes you zero
to hero and talks about what it means to
build big things and clojurescript
so if you have some thoughts about
things I've said or things that you like
to see or if you just like to find out
when things are happening either you
know find me at the conference ping me
later or just follow me on Twitter or
something
that's all I've got or any questions yes
yes unfortunately I do not and this is
sort of I was talking about with this
with this thing I'm sort of putting
together but it's not live anywhere yet
yeah
yes what happens with time out when all
these other queries are still running
one more time louder they will be
canceled and actually all these queries
are running because all of this code
gets run at the same time pretty much
right because remember the goal block
basically says do this thing
asynchronously but keep writing code
right so this this this code will will
basically spin up all of these processes
and then exit because there's nothing
that says what well in this case all
says wait but if the alt was in there
this would automatically exit and all of
those processes would just spin off and
they would die at some point
that they usually will run because
because basically the HTTP query was
already made but basically the response
from that at that point when it when it
when it comes back the guy basically the
code will say I don't care about you
anymore
yes right so to answer your question
about the github thing where is that one
of the first of all if you do if you do
it the way you're saying that you page
yes of course the pay two dates but
that's because there's an initial the
results but the round-trip time to the
server and back is gonna be slower than
if you do it in the browser if you have
all the data and the other you had a
second port to your question I lost it
Oh stale so the way with this is
implemented for example this is what our
cha-cha does is the first time it loads
a page it'll load up all the data it
knows about and then it keeps a
WebSocket connection open and whenever
data comes in it'll get that over
WebSockets right and then because and
then it enters that entire process of in
Cory sink Cory sink figures out what
data has changed and then react is
automatically renders your page without
you even knowing about it
it's imagining I know it's awesome
right so the question is basically how
does you know compared to Facebook's
approach so the thing about flukes and
relined so forth is those things are
sorted there because they have this
problem that they don't have immutable
data structures and things don't flow
one way you can simplify a lot of the
problems just by making sure that things
always flow one way so your question
about how do components communicate they
don't it always has to go from the top
so if a component wants something to
happen somewhere else it for example
trigger some kind of event that gets fed
into the core async and then it trickles
down right so you can always if you
always think about it going down a lot
of the problems get solved now as far as
a relay and for example flukes it turns
out isn't it wasn't as great of an idea
as they thought it was and that's why
they're introducing graph QL and graph
QL is actually a different sort of idea
on this concept of data script of data
log it's the idea that at some point
we've realized that the way we did this
doesn't scale so we want to go back to
the idea that we're gonna have one big
storage mechanism and each of you is
going to write queries on this in this
database and it just so happens that
that database is also synced back into
the into the server and there's
absolutely nothing that stops us from
doing this enclosure this is actually
how I usually design this stuff so I
will have like something like that one
data source the views are dependent on
data source whether through atoms or
through you know like querying language
or whatever and then when things get
updated for example you create a new you
create a new post or something you can
for example then filter that back to
automatically
rent render itself so in order to render
itself you need to say make this add
this post a list of posts and then I'll
render itself and then except for that a
second event will fire that says this
post got added I need you to make a
communication in the back and validate
it make sure it's okay right that's a
separate thing it's it's a separate
channel it's separate communication if
the back and then comes back and says no
you couldn't create this you don't have
permissions for it it it's not a side
effect basically you just create a new
thing that says this thing that I added
is no longer valid to remove it and then
it just and then because you're removed
from datasource it also get trickles
down and entry gets promotion view yes
yes but like for example sometimes you
have a state in a component that's not
relevant to this to the application so
that's okay right like things that are
specific to is a component like local
state for but anything else it needs to
go through the data model and since it's
always trickles down it's really easy to
to figure out how things are working by
the way I didn't mention it but it
should be really obvious how easy it is
to test systems that are designed this
way because you can basically test how
quarry sink is going to update a data
model as a unit test completely separate
from rendering and you can test
rendering completely separate from how
events modify data right yes
using those tools I don't work on
projects where I wouldn't want to do it
as far as frontin is concerned in the
sense that I like I like building very
complex front-end applications and it
works perfectly for that another thing I
didn't mention is first of all is
Facebook's react is pretty I don't know
how we're doing with time we've to go
yeah let's just talk over beers later
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>