<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Graham Crowe, Anders Danne - Embedded Erlang Development - Erlang User Conference 2015 | Coder Coacher - Coaching Coders</title><meta content="Graham Crowe, Anders Danne - Embedded Erlang Development - Erlang User Conference 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Graham Crowe, Anders Danne - Embedded Erlang Development - Erlang User Conference 2015</b></h2><h5 class="post__date">2015-07-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/REZ93dZZ5uA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you very much as you're on my name
is understanding or understand or more
international I will together with my
colleague Graham girl described an
embedded product from airline from Exxon
where we use airline and we will divide
it so i will first talk about what it is
and then i will talk about the
implementation how we use our line and
then gray and we'll talk about the build
process in more general sense okay first
over to Hong Kong let me see this is
Hong Kong and I want to set show you the
context where this product is used so
this is you can see here symbols for the
base station see in Hong Kong and there
are different types of base stations
it's a nice view and if we go down to
let me see the street level we can go
around look around and yes you see see
for example here is one yes that's one
base station covering in a small smaller
area with dense traffic and we have
other types of base stations for example
oops
this one up on a rooftop which covers a
much larger cell with both gsm white
Bam's CDMA and lt 2g 3G and 4G and if we
open up the door seal this cabinet you
can see all the equipment in this base
station and this is the place where this
airline unit can be used so now you know
all about mobile systems so back to
Stockholm can step back I did it go
okay and we if you're looking inside the
base station but the main units in the
base station or the digital control unit
and the radio unit and also other parts
for transmission and power and lots of
things and but these are the main and
between these we have a link the green
link here with a normally fiber link
with a protocol with the acronym cpr IE
and it can be a short distance just in
few meters or up to some kilometers
depending on the base station
configuration and CPR I it stands for
common public radio interface at it
standardized for the number of bit rates
but normals the bit rate is 10 gigabit
and over that link you carry the radio
baseband data but also control and
management seeing signals and also
synchronization so we can configure a
base station with a number of these
control units and a number of radio
units and we can have between them we
have a number of these fiber links
depending on the required functionality
and capacity in need but in some
configurations we run out of connectors
for the links and maybe you want to
split one 10 gigabit into two to several
two and a half gigabit links or you want
to combine to use one or you from to
control units and that's why this or 50
free which is a name of the product was
developed and
this is it the card will we're talking
about it's called basement or 50 free
which i'd say at it can be located in
different types of base station
configuration and number of sizes of the
boxes we have now been running into live
for several weeks in baltimore and the
only significant problem so far was the
race riots and our staff had to stay at
home for three days due to the curfew
but eventually they got an escort from
the national guard so they could install
the equipment this cpr i switch it
started as a prototype a while ago and
joanne stone and i were asked to write
the control logic in ireland since i
wanted to drive that ended this smaller
type of embedded product and the
prototype was successful and later it
became industrialized and as I became a
product here you see the free vice man
back in 89 Joe to left and Joe and I
have worked together now for some years
in different prototyping projects and at
what we met already in 80s I was member
i was not working but i was member the
cs lab board the computer science lab
board so actually I I paid for part of
the budget after time and from CS lab
and I think it was a good investment I
think you'll agree with that
I was working at the erickson research
at that time and and follow the creation
of our language great interest and I
also used it in several research
projects this is one example it's an
cordless switch control unit for
cordless switch which we prototyped in
order to test our line and I present at
least in Yokohama at the International
switching symposium 1992 and you
recognize me here to the left I suppose
other prototypes we used to erlanger was
the first 3g prototype in a GU project
called coded ok enough about me back to
the product this CPI or ice which has 60
fiber porch and inside we have free
layers on control at the bottom we have
the FPGA in the hardware handling the
fast data transport and switching or and
for controlling that we have a layer
written in C and on the top we have the
control logic written in Erlang and it's
it's you need several types of competent
for this young every mean it let's say
you need one person seldom has all these
competences and universal need people
who are skilled in embedded Linux so
it's teamwork to do all this one of the
first requirements we had was to check
was it possible to use our line in this
small box I mean if you install our like
it it use about 150 megabytes on your
disk and this
button product we were told that a
requirement was too we should use less
than 10 megabytes for the airline OTP
and the application so we did some work
can talk only some of their with EP
modules which the STD leaves a compiler
kernel and social and then we also
stripped down the debugging information
from being able to be bought and we let
we came down to six megabyte and the
application was less than what is less
than one megabyte and would appear
erlang is about five of these so that
was pretty ok in this product I know
Graham will talk more about this build
later ok if it take a closer look at the
airline layer we have used these type of
middleman processes which are proxies
between the Erlang port and the external
world so we all mess old communication
between LA and see is its and/or error
between the Erlang and the other called
the controller control units for example
or using a message common message
transport protocol and all these
different types of links we have a
number of protocols the world legacy
protocols we had to use and extend for
this Apple this box and we had also take
to specify a number of new protocols so
all of these were are specified in XML
and we were lazy and made a code
generator that generates airline encode
decode paul tsongas corresponding see
encode Depot code logic
so everything is through messaging to
the other parts
now something more about implementation
openly when you have telecom equipment
or embedding equipment you have get the
requirements specified as message
sequences which is easy to understand
which normally shows the main sequence
of events that you should follow or
implement and the question is how to
transform this into running airline code
again the first step is you can
transform this into a state machine so
each each incoming message gets you
state transition and this is one way to
transform this message sequence but they
also normally often you don't have any
unnormal sequences specified or timeouts
or lots of things that are missing is
this sequence diagram and the next step
is if you want and you want to transform
the state machine to our line then you
can for example you can write a pro have
one process with free receive closes do
this or you can have perhaps one
receives closeouts and state variables
so you can come can we don't know the
state as a machine and when you have
requirements you need to implement other
sequences as well in the same process
and it gets messy if you try to merge
the state machines and
you will get blocking if you're waiting
for signals and other sequences count
around so then you have to be clever and
divide this maybe you can't have one
process maybe you probably need more
than one process and you need to think
of you can't have many states if you're
not allowed to block so many ways to do
is it depending on the application you
have so this is how we did it in this
switch at the lowest level we have this
middleman processes which transformer
external protocols to our line signals
we didn't do all the encode decode
business and I am above that we have a
number of protocol processes they may
have once connected to their links they
are in one main state the whole time so
they are never never blocks events
coming from the inside or outside and
then about these protocol process if you
have the sequence processes which are
started one for each new sequence and
they are actually also in two parts we
have a composite from a procedure on top
which is a main it's a series of
function calls which follows so seek
message sequence and then we have they
called a number of atomic procedures
which do the communication with a
protocol processes and these atomic
process also handled timeouts and errors
that can happen so in this week we can
get quite readable code from civic canal
you recognize the sequence diagram in
this sequence
okay okay that's good structure but you
will have problems anyway you perhaps
you can get featuring interaction
perhaps wonder the sequence one is to
set up a link and then the sequence two
is to tear down early in camera if they
have happen at the same time or nearly
at the same time you have a clash and so
you have to handle these types of
interactions as well but it's this it
makes it readable and also quite easy to
add new functionality I also my advice
is to check the memory you use you have
to check that its tail recursive so
because these will this may be with
health around for years in the loop so
you need to take care of the memory have
yes well to summarize we yep we did
succeeded to use our line in the product
and it became a real product which we
will be sold soon lot number and airline
is not so surprisingly a suitable for
this type of embedded system as well
we got high productivity we were not
managing involved in the airline part we
should try to avoid low-level program if
it was needed maybe some of the Seaport
the functionality is see what could have
been done in our line but that's can be
done later or maybe some seaport should
or the vice versa maybe also the
architecture is important you should you
should prototype it early on test we did
some experiments early and rewrote the
code several times and a memory is
important to you as you so it's possible
to drink them are lying footprint quite
substantially and performance it's quite
ok this in this application there are no
real performance requirements it we use
in the fpga handles all the fast data so
the control is not so it doesn't need to
be so quick and the quality has been
surprisingly good the complete product
is field trial has in Baltimore as a
mansion has gone unusually well I heard
and normally find some things when you
run for the first time in the field but
this time he has worked very well and
the Earl importers it has had very few
bugs in a beef with ours any dates
that's so easy to fix them and find the
problem
oh okay that was the end of the first
part so now I'll hand over to Graham
deploying an hour an embedded airline
system how hard can it be yeah she turns
out that it's my opinion it's it's not
trivial as they ought to be and I'd like
to talk about a case example instead of
talking specifically how about how we
did in the are 50 free I want to talk
about an example using the same
methodology that's been used in the are
50 free and in order to do that I need
to have a brief talk about auto tools
something called yocto then I'll go
through the the case example and I would
like to talk about why i think it was
quite difficult why it's quite difficult
to deploy an air an airline system and
then summarize on discussing some
possible ways forward there where we can
alleviate this problem so i think in the
presentation this morning ball deal made
a mention about you know auto tools and
there's a horrible thing and yeah you
either love it or you love it and and i
think the altar thought is quite product
quite difficult to kind of start using
but once you overcome their the barriers
to it you start to appreciate it
particularly for building embedded
systems so for those who are not
familiar with all turtles it's otherwise
known as the canoe build system it comes
with this sir components auto conf
automake libtool and some canoe lib and
it's very very very very good for really
building systems that should be deployed
on a unix-like system
so why should you use all totals well I
think if you're going to if you're going
to write C code and you want that
deployed on a unix-like system there's
lots of benefits of all turtles you get
portability you provide the altar tools
ensures that your code adheres to some
sort of coding standard konoka not
coding standard such that your run from
a user's point of view you have a
standardized kind of make I PE API if
you like such that that you get kind of
very regular make rules like you know I
suppose most people here are familiar
with the idea of like downloading a
component configuring it making it and
installing it and you can make make this
that makes a tarball you can do make
check to sort of run some tests that
might be packaged together with the
component and lots of other things
there's loads of benefits so yocto yocto
is a an open source collaboration
project that provides a set of templates
methods and tools for building embedded
linux linux systems if you're interested
in building embedded Linux systems you
should take a look at your tone and it's
the Yocto project provides something
called pokey which is the build system
and this poky build system is based on
something called bitbake a bit bike is
written in python and it provides like a
generic tast engine that kind of can
understand a subtle metadata and figure
out the dependency chart of the metadata
and figure out an order of execution to
sort of build your complete system so
essentially you have a set of sources on
the on the on the left a set of metadata
you hit go and you create images or or
and packages
in a bit more detail this picture kind
of shows what what kind of happens / /
component if you like you fetch sources
from somewhere whether they be tar balls
or whether they be a git repository or
CVS repository or whatever you can apply
patches to them if those components
don't quiet here to some requirements or
have some bugs or something you can then
apply the standard configure make make
install this is where it's really useful
with these components that here to some
standard like all turtles or possibly
even see Mike or something like that and
thereafter the octo build system makes
packages of your components and what
that really means is a package is
typically split into four things you get
like a binary package documentation
package debug package and development
package star actually on your on your
image at your deploy in production you
had actually only used the binary
packages but if you have bugs maybe you
want to add the debug symbols to run gdb
it's very convenient it provides a very
sophisticated build system so the
package splits then and then you could
choose to use rpm packages or the Debian
packages or whatever and those package
feeds in the end are used to deploy or
populate a root filesystem so that's
quite a lot of information now not to be
confused with other kind of tools like
em I think docker a lot of people talk
about docker and there's puppy and a
chef's I think these these tools are
very good for server type Linux images
and things like that but this the yacht
so is specifically focused on embedded
Linux systems where you want to have
customized Linux image
that perhaps it hits a small memory
footprint which is a requirement of the
are 50 free and this build system it
provides the ability you you're
automating the entire production and and
it's reproducible and it can lead to
very assist efficient system level
builds I mean very fast so a case
example so I've made a made a case
example I've actually posted this on
github so you're free to have a go
yourselves this hello application
doesn't do anything special wit dis
prints hello to a log file every 10
seconds so has it so it's a demon if you
like and I just wanted to sort of
demonstrate how such a trivial
application can can still be quite
difficult to deploy the other thing with
the system is that the intention is that
when you boot the the image that the
airline system would be part of the
initialization systems that would be a
demon the demon will start automatically
so there's the URL to if you want to
have a look there's some readme
instructions they should work they work
for me I hope it work for you and
essentially what we have here is the
pokey build system provides some a set
of metadata that split split into free
layers so this is what you get for free
from the pokey build system the the octo
project also suppliers other metal
layers there's one for raspberry pi for
example it provides a broad support
package for deploying on a raspberry pi
image and there is actually a meta rare
lang layer that some guy in Brazil has
developed and it's pretty good actually
so I've used that
and then I've created my own layer atop
my domain specific layer now this is
quite a noisy picture busy picture what
I'm trying to really sort of show here
is that on the image itself they're 164
files are deployed to make up this
system I guess you you're familiar with
the stuff on the right here we were
going to have like the colonel
application and the standard lib
application that being filed associated
with them airline runtime system and my
hello world application on the left here
will it with their some bone shell
scripts to kind of bootstrap this into
the into the system 5 initialization
functionality so what we have actually
is during the start in runlevel free
this s75 hello OTP system will be called
and that will call that that's a soft
link to call this hello OTP system and
then that in itself cause these two
scripts if the hello starter hello stop
so that follows that as a convention for
these type of scripts I have to have a
start a stop and status and kind of
thing and and this softening is made by
by body up by the pokey build system
they have support for components that
are also tools compliant and i also have
a class for supporting his update our CD
so you get all this for free and so what
i wanted to really come to quite quickly
was what i consider to be quite
difficult and
so there's a I don't think I'm the first
person to make this observation but the
Erlang OTP packaging is honorific it all
comes together in one big bundle and so
there's no real distinction between the
runtime system and libraries and tools
and applications it's all bundled
together that's quite convenient I
suppose because you can just download it
and have a tool chain in your
environment but when it comes to
deploying in in a system where we have a
limited memory paper footprint that
becomes a bit inconvenient because we
need to we need to sort of we don't need
the whole lot if you like we'd like to
do a bit more cherry picking airline OTP
itself the the build system yes it has a
configure scripts and make files but
it's not really also tools compliant as
such it has a own kind of homemade
handling of cross compilation and I
think the reason why it's not that the
consequence of it not being all turtles
compliant I think might explain to some
extent wire airlines OTP is not
necessarily as ubiquitous as it perhaps
ought to be in many linux distributions
because i think if your are also tools
compliant you provide it's very easy to
make packages rpms or Debian packages
and what not and therefore it's very
easy for distributions to include it in
in the life cycle although I mean yeah
of course some in on ubuntu for example
you can do sudo apt-get install air lang
and you'll get a version i think it's
our 16 these days but i don't think it
gets updated regularly because i think
they have to go in and do some manual
shoehorning in some places and these
problems they propagate further down the
chain like this meta airline layer I
talked about souls a lot of the
packaging problems of airline so that
there's this guy I can't pronounce his
name but he has made a great
contribution actually
this matter Erlang layer is pretty good
he manages to take the airline OTP split
it into lots of smaller packages so you
get like a package for standard lib
kernel and whatnot etc under he's done
one minor mistake in my opinion it has
created a package called airline gets
but it doesn't contain its it contains
the the preloaded beam files which is
not particularly useful because they're
actually part of the airline runtime
system anyway they're at their kind of
embedded into the into the binary
already but that but that's a thing we
could very easily fix they're also the
the metal layer has to take care of some
non-auto tools issues by solving to make
it work for cross compilation which is a
shame one of the other good things about
this layer though is that it has
included some tools in in the metal
layer so you get access to rebar summit
called relics which is very interesting
actually actually and something called
Elwyn it that I've only used once but
that kind of replaces the regular in it
binary under the spin on a Linux system
to with this air when it so that you
only start literally airline more or
less on top of the colonel so some auto
conf insights now this guy remain he he
made a presentation in 2006 where he
talked about whole load of airline
specific autocom macros and well I I've
been using them for the last two years I
think they're very very useful and now I
don't write any airline code without
using the writing a configured I see in
my for my application and I kind of
depend on it now
unfortunately if you if you use some of
these microbes in a in a highly used
case like in cross compilation you
discover there's some errors so not the
not all of these macros unfortunately a
cross compile safe for most people who
work in only on x86 64 sure you're not
going to find these problems but for for
the embedded community is a major
problem so they're also make now if you
want to mean quite often an airline
application will come will be packaged
together with some C code for whatever
reason and if you want that learning
application to be portable it's um it's
pretty good idea to use also tools
because then that will take care of the
subtle differences between very empathic
systems and Varian architectures and I
think unfortunately there is no rule
there's no current support for airline
code itself and I have an idea that that
we could actually think about writing
some also make primaries that can help
us because I think right now in the
airline community there's there's this
air Lang door mkay filed is Loic as
written Richard Coulson has written one
as well and I think there's a lot of
good kind of make rules there that would
be if a good idea in my view if we could
kind of bring them in to also make those
those good make file snippets and to
kind of promote reuse by that by other
means so in other words you could have
like a oughta make primaries that that
compile your airline sources two beams
your weather are going to support yak
and leaks and ASM one and all the others
and also perhaps put generate some
automatic rules for running dialyzer for
example all of this could actually
become we just were we need to design it
of course
that's it but I think there's some kind
of way forward there and that would in
my view simplify building and deploying
airline systems a great deal so in my
view I mean I would like to obviously I
mean I love airline having it's a it's a
great language but I think there are
things that we'd I would like to sort of
see improved and I'd like to see airline
OTP unraveled a little bit to have
separate life cycles to different parts
of the current delivery I think and the
consequence of that would be well the
metrorail lang layer that I talked about
earlier would be much much easier to
maintain it'd be much thinner much
easier to understand I'd like to see
some kind of documentation of a
recommended packaging and distribution
way of working i think there's there's
no in my view there's no real consensus
on how airline code or airline libraries
and applications and systems ought to be
ought to be done there's different
solutions as the rebar solution the
rebar free and whatnot but i think
they're good i think if you don't need
to cross compile but if you need
cross-compilation then then if it auto
tools can actually be our friend I think
we need to we need to go in and fix
these Erlang also com of macros such
that they are cross compile safe where
and we could also do with fixing the
metal layer for airline at the moment to
improve the package splitting so that's
me done actually so Cuddyer any
questions we have time for two questions
and before we do that we had to change
the mic with the technician so
30 seconds to think about the question
so sort of question okay so the question
was about upgrade and actually upgrade
in the are 50 free is performed by other
means and and that and that's done by
uploading new image putting that in a
new partition and then pointing to that
partition and rebooting so it's a very
hard upgrade if you like sorry yes it
was send it down for an operation center
down to the god
yeah I remember large number of years
ago that we had the system called
mobility server i'm sure you remember
abilities earlier if i remember the
military server it was on the 68000
processor I think that we had I'm not
come up i think it was eight megabytes
of memory we had on it can anyone else
remember eight minutes i think he was a
mega byte array around what we haven't
it which means that the president is the
system is 150 megabytes has increased by
oh sorry yeah which means that the whole
thing is actually increased by a factor
20 during the end that number of years
is that sort of 20 / about 20 years
that's quite fascinating is very
interesting but why it's got so big I
mean is it bloatware what what have we
done
I have to disagree with some the second
part of the talk a little bit because I
I did several and several size l and
deployment in embedded space and I don't
think it's hard to deploy what I saw
from the slides but maybe I am I
misunderstood mainly you got in trouble
because you're losing linux quite
possibly yes but because it's I on
freebsd it's easy and very lightweight
and built-in okay I'm sorry yeah it off
in the summer years i think it's
difficult to deploy in an airline on an
embedded linux system it be more
specific here with this i agree okay so
you called the devices switch but is it
really a switch or just a multiplexer
well it's both you can take it's a
timeslot sequence of packets coming in
and you can switch them to different
porch so it's a it's switching but it's
where you don't change you switch that
open you said right so it's like sort of
drop and insert functionality on an
optical type of connection then you run
it for a year and the same right
configuration for psychosis so the total
number of messages going on from the top
down to this thing is like into the fpga
is there's a whole bunch to start with
and then there's like one every week or
something and then there's some stats
flow yes supervision but it's not much
okay
which is the art were used for this
device the cpu for the embedding what is
which is running on an arm if that's the
Nazi warm up oh yes thanks right before
the other side gets mad let's give it up
for understand and grin crow</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>