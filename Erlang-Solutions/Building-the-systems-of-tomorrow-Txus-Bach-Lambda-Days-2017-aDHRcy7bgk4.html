<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building the systems of tomorrow - Txus Bach (Lambda Days 2017) | Coder Coacher - Coaching Coders</title><meta content="Building the systems of tomorrow - Txus Bach (Lambda Days 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building the systems of tomorrow - Txus Bach (Lambda Days 2017)</b></h2><h5 class="post__date">2017-03-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aDHRcy7bgk4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Who am I first question you probably are
asking when I was talking some people
here with some people here and there's a
lot of people macademia and they are so
you know you double with Idris are you
from to an address or like the academia
general so I I started introducing
myself as a rogue industry person so an
energy person gone rogue that's trying
like tanks outside of the industry a
little bit but then immediately a friend
of mine came up with a better name
literally mediately just two minutes
after independently typed and the thing
that's my my new twitter name so this is
Germany and it's Cologne specifically
and in Cologne this program called a 2ll
was a several project that started to
manage unemployment payments so quite a
sensitive quite a sensitive thing and by
the first to generate 2005 it shipped
with a lot of deadlines select late
night and it was due to send 1.3 billion
euro to more than 2 million households
in Germany so quite a big quite a big
project and the poem is before the first
payment was sent there were some
problems German account numbers are 10
digits long but some of them are with
shorter and you're supposed to Pat them
with zeros to the left like you would do
with any number but the system was
padding with jeers to the right so some
of the account numbers were invalid and
they never got the payment we're talking
about unemployment checks like it's
important to get these people need them
to live but there was a bit of a scandal
and the government issued some emergency
cash so that keeps people could eat then
they started printing checks instead
they said oh the system doesn't work
with these transfers will just print
checks because checks always work and
the street name in the in the form for
the address the validation was too short
and some german street names are very
long as you might imagine so they got
truncated and some of the checks never
made it either by july two thousand five
the system have been running for
71 and they found several bugs among
which for example the system had been
registering the users incorrectly with
the insurance company so that was a
massive headache for the insurance
companies a lot of bureaucracy and extra
work and then by September nine months
after they found the mother block so the
blog was that the system had been
transferring 25 million euros a month
extra to the insurance companies that
wasn't really really good to the
government said like we need to shut
this down like this doesn't work and
that was the end of it this is Knight
Capital Group which in 2012 it's an
investment group that lost 440 million
dollars in 30 minutes and how they
managed to do that is the system started
buying stock high and selling it low so
that obviously was bound to not work at
all you already know this and 2014 Apple
go to fail yeah well the magic of not
having curly braces in this statement
yeah doesn't need much more introduction
hardly I'm I'm hardly the first person
to talk about heartbleed in this
conference and one of the consequences
of it is that in 900 social insurance
numbers were stolen from the Canada
Revenue Agency thanks to this box and
also by the way in openssl between 2006
and 2008 the random number generator was
broken so what who knows what what else
hackers have done with this stuff but
both are not only about losing money or
disclosing sensitive information which
is bad enough some bugs are way more
terrible than that cities Panama City
and between two thousand and two
thousand won a radio therapy machine in
a hospital started emitting more
radiation to patients that it was that
it was advised and these patients went
over a year of treatment and seventeen
of them were dead because of over
overexposure to radio
asian Toyota if you've heard of Toyota
unintended acceleration it's a very soft
describing buck that mix your car just
start accelerating for no reason and you
can't override it in any way so between
2000-2010 this box costs eighty nine
days and fifty seven injured and it was
a big scandal for Toyota this is a span
air plane which in 2008 is trying to
take off but it subsystems weren't ready
to take off and they would have learned
that but the the monitoring system was
hijacked by malware so they never
learned about that they took off and
they immediately crashed killing 150 for
people so I'm preaching to the choir
here but my point is correctness matters
it does matter it's no longer about you
know being efficient or having more
elegant programs or anything like that
it's really software is in our lives and
it's only going to be a more important
part of them so correctness does matter
the first question that we should ask is
why are there so many bucks it is
because we don't know how to program
maybe or because I processes are not
ideal or their deficient or our tools
are not great well because I'm not a
very good craftsman i'm going to start
blaming our tools and the main tool that
we use every day is our programming
language and and when i say our i mean
the mainstream sort of most people's
programming languages they're very
primitive and they require a lot of
discipline and cognitive power the
problem is our processes however
well-intentioned they can't enforce
discipline they can incentivize it but
they can't really enforce it so you know
that's not really good enough our users
like just an incentive to to do well and
when it comes to cognitive power our
brains are very easily overloaded and we
have a lot of trouble thinking about
probability and other kinds of firm sort
of things and one of my favorite box in
the brain it's called illusion of
understanding and that's something I'm
victim off all the time when
which is you look at you look at a
complex system maybe an architecture
diagram or a piece of code and you feel
oh I get it I've read it a little bit
and I know how it works and how the
pieces fit together and I could maybe
rewrite it that's the first thing you
think oh yeah i'm going to rewrite it
because i already understand it or i
could build another one I don't know a
similar thing but then it turns out that
it doesn't work and you were really
really convinced that you understood
that thing so I could I could point you
to lots of research papers about this
issue of religion of understanding but I
think the best thing I can show you is
an art project by an italian artist i
think his name is John Luke Domini I
think he made the velocity pedia how
many people know the velocity yeah yes
well in the village superior this artist
asked a bunch of people from different
ages different backgrounds to draw a
bicycle a common object that everyone
has seen owned and basically it's just a
common object everyone knows it so
everyone was really confident they could
draw one so they drew one and like yeah
I know how it works and then he turned
these drawings into 3d renders and the
funny thing is that the 3d renders show
so obviously these bicycles could never
work as bicycles and here's one example
these bicycle cannot have a human being
on top of it it just won't work this one
is pretty nice as well with the frame
sort of the crossed over Alexis pretty
cool and what my favorite by far is this
one with the whole frame on one side of
the wheels and that's a double tape of
cut it's pretty fun check out the
velocipede it's really fun in teaches a
lot of our flaws of human beings another
problem that we have on writing code is
that we scatter it with implicit
assumptions we have them in our head
maybe we don't even know that we have
them
and they're hard to remember because
you're not really aware that you're
having these assumptions then obviously
they're even harder to communicate to
your peers because they're just you
consider them shared context but they're
not shared and many times they're just
plain wrong so you're convinced to them
but they're wrong and they prove you
wrong at production or at 4am so it's
not the best best time so many of our
languages are based on the turing
machine which is the theoretical
computation model that yeah it can
compute everything that is computable
but it is very primitive and it doesn't
give us a lot of tools to think about to
think about programs and reason reason
about them a little bit more formally so
I considered a double-edged torque and
I'll come back to this later but of
course we're at lambda days and we know
there's a different tradition called the
lambda calculus yay which opens up many
more possibilities to leverage more of a
systematic reasoning about our programs
and stemming from the simply typed
lambda calculus there's type theory for
some logics and there's a lot of tools
to think about program the Turing
machines maybe it's just not developed
enough the theory around that maybe I
don't know so how many people here use
typed languages everyday fair fair
amount and keep your hand up if you also
write theorems and proofs ugly ok well
I'm going to prove you wrong and no pun
intended but you should have kept your
hand up all of you the reason being
these two gentlemen Korean Howard two
talented people ha happy in different
degrees and they came up with this they
discovered this this fact that two
different summaries of formalisms on one
on one side proof systems and on the
other side models of computation were
equivalent there was an equivalence one
to one equivalence between one and the
other so to understand what this means
let's review a little bit of
propositional logic
propositions AB&amp;amp;C they send for
statements say it's raining or I'm happy
conjunction is raining and i'm happy in
conjunction or an implication is a bit
draining then I'm happy so this is very
basic but we're very interested in a
flavor of logic called constructivist
logic which comes from a flavor
mathematics or constructive mathematics
and the difference between that and
normal mathematics is that in
constructivist mathematics you can only
prove things by construction and never
by contradiction which means if you want
to prove that an apple exists you need
to come up with an apple and show me if
there's no Apple then I can't it's not
provable that exists whereas in normal
mathematics you could reason your way
around it and say maybe well if an apple
didn't exist then this bowl would be
empty and this one is not empty so an
apple must exist so in a way this is
this fits really nicely with our models
of computation because sorry because
we're interested in creating things and
passing them around and sort of these
having these values pass around and
these are really proofs but we'll see
we'll see that in a minute so this is
the curry hard correspondence it's I
mean I guess it's a bit longer than that
but this is the use essence types of
propositions or programs are proofs so
for example a type integer is the
proposition an integer exists and a
program of type integer let's say the
number 8 is the proof that an integer
exists because if you have the number 8
then an integer exists it's obvious so
this simple idea turns out to be really
really powerful let's have a look for
example with with more real things like
apples so this type apple means an apple
exists and for every different apple i
can make that is a different proof that
an app elected so if i made a hundred
different apple values those are
different proofs in all of these in our
type theory they would type text because
it's it's sure that this Apple is a
proof
this proposition it gets more
interesting went with function types a
function type is that claim is a claim
that if an apple exists then a list of
apple slices exist and so it corresponds
to implication the idea behind this
though this seems like a bit far-fetched
like it's not automatic that even Apple
exists a list of appliances exercise
resist so the proof that this is true is
the process of slicing an apple if you
couldn't come up with a process of
taking an apple and slicing it then this
would be unprovable it wouldn't be
provable but of course it's probably
pretty easy to slice an apple and then
this function would tie check so this is
a very very powerful idea and basically
it means that types can represent the
arbitrary mathematical for position and
if you supply a proof or a program of
these propositions your type checker can
check that you're right proof is right
and convert it to executive of code and
then run it so then you have a program
and if this sounds like a more
principled foundation than shifting
around bits of memory and incrementing a
program counter somewhere I don't know
it's not for me to say but the future
will tell I guess that there's a catch
there's more than one catch but this
this is one of them are types is there
too baby then they're no good because
they are very very vague propositions
that are really easy groups with
practically anything so we really want
them to be very precise and we reach
this precision through the concept of
cardinality so a type has card analogy
which is the number of values that I
have and here's a claim that higher
culinary leads to more box why because a
type such as inch for example a 32-bit
Inc has 22 the 32 different values which
is over four thousand million values and
all of them must have text but you're
probably just interested in 11 valley or
a few values so it's very easy to just
come up with a wrong value and it will
type check a boolean for example has 22
different values and it's a slightly
better type or easier to reason about a
string has infinite infinitely many
values because it could be infinitely
long and if you start with lists of
things then it just gets really crazy so
this I worked out the other day and I
don't know any much so I sort of it's
probably wrong but it seems to work to
capture the Cardinal energy of a list of
the length n of X s if you know the
cardinality of X and basically you can
see that it's a ridiculous ridiculous
number so and usually lists are infinite
as well which doesn't a potentially
infinite so doesn't really doesn't
really help let's see a most recruit
examples of integer four thousand
million possible rotation string
infinitely many personalization and this
is this is just no word so you better
avoid using these types as much as you
can remember the cardinality of your
types they're easier to reason about so
how do we go about minimizing
cardinality in practice in our programs
every day program let's take an example
slightly controversial example which is
appending to lift this function offense
to disturbance or that was a tight
claims now the cardinality of this is
huge like look at this 2 to the power of
32 times infinity +1 this is a massive
number like market so you could come up
with that many permutations of the
structure basically returning an empty
list a list of three trillion won a list
of 48 whatever you want at least of
random integers why not um let's try and
prove it a little bit so we have
generics that help us a little bit
because the offending list is not has
nothing to do with integers so we want
to get rid of that and attract the type
integer variable and then you have this
okay so two lists of eight and research
elusive a that's slightly better
slightly better not really that much
better
you can still take the you know the
first time I'm on the list repeated
infinitely and then interleave it with
the second element of the second list or
whatever you want and these all these
implementations are tight check but
they're wrong so yes this is a bit of a
problem but we have another tool in our
tool belt dependent types let's look at
how we would look with your pen inside
so this is would be this sword is wrong
list should be vector which is an index
list independent type study you could
see that it takes a list of n eight and
being the length of the list and a list
of MAS and then returns a list that the
lengths are the length is n plus M now
this is already way more constraint
because you need to respect the length
and just I mean this still give you can
have a handful of implementation thought
I'd check potentially many as i'm going
to show you something so that you're at
ease with this the idea that if you get
your types more and more more precise
which with the pendant as you can get to
really extreme depths of precision and
your type then at some point the
cardinality can be really low even one
so when the cardinality of a function is
one there's one implementation and the
compiler can help you just write write
it out you don't even have to write it
that's what happens in Idris sometimes
when you're really really good with like
really concrete type so let's let's have
a look and I did a bit of exploration
with Idris in in this in this area and I
started with this function of hands now
so this is the correct implementation
looks nice elegant really short type
checks and it's also correct and now I
try to trick it and say ok I'm going to
write an implementation that is wrong
but a tight check so for example is not
really append which just replicate the
first element for this before the for
the length of the list it's doable this
site X but as you see it's a little bit
unclear isn't it I have to pull out
these implicit power meters here
to bunch of stuff it's still doable but
well then I tried what happens of you if
you enter them is supposing the same as
M plus n so what happens if I just make
a function that prepares instead of a
parent that should be quite easy right
it wasn't that easy so I'd like to do
this and I ended up having to put a two
different proofs one of them I call dot
does a bear in the woods it's right
here which basically for two numbers
left and right it proves the left list
successor of right is equal to so
Scherzer left plus right which for me is
really obvious but it was digitally
believe it it's really hard to
either ease into things using their
truth and you have to always prove the
stuff so yeah I managed to do it but you
would agree that this looks fishy like
this is not a ship it plus one pull
request kind of thing so that doesn't
mean that always the correct
implementation of the simplest and lysis
that's a that's server coincidence but
in my short experience deliveries if
this is the case that usually if you if
you write really complicated code it's
probably not very right but that's not
true of everything okay so enough of our
cardinality there's another thing that I
think why powerful when it comes to
correctors in our programs and its
totality it's another touch of the curry
house correspondent here so if you have
type let's say a function set take
something and returns an int and you
know that the function is toto that is a
pretty strong promise that that thing
will return an int in a finite amount of
time but if it's not total the promise
becomes look if I ever return I will
return an int maybe I'll look forever
and you will never know he'll just wait
or maybe I'll crash and I won't tell you
I'll just crash but it's not then I'll
be terminated don't worry well that's
not great so you want your functions to
be total so that your type actually
promise what they are meant to promise
now if you take this idea to the extreme
you get to total functional programming
which is funk funk of ramming with only
total function and yes this sounds a bit
weird it's interested find totality is
it has a fatality checker that obviously
doesn't really check totality because
that's that would be equivalent to
solving a halting problem but it has
someone with restricted totality
checking and if it can tell that your
function will terminate it will tell you
yeah its total if it's not sure it will
say not now turtle just in case but it's
quite smart and it's based on this idea
of termination and productivity so
sometimes it's obvious that a function
terminus doesn't recur doesn't do
anything it just terminates but
sometimes it produces a finite prefix of
an infinite sequence in a finite amount
of time that's still productive it
doesn't work it returned and you could
call it again with more work and it will
keep doing stuff so this is a valid a
use case and in this case the totality
checker will agree with you will say
this seems determinant it's a productive
productive function so that's fine with
this trick you can end up writing
programs of Edwin has talked about it
remember it either creative Idris has
talked about running systems this way in
in some talks and even model servers
which are endless computations of state
so you handle the request and another
another another you never you never
finish he models it this way as a basic
as a stream of i/o actions and then you
just do a little bit of work and the
trick is that then you end up with the
program with all total functions except
one function that gives it let's say the
few it causes the fuel to keep handling
requests which is the only function that
is not total but that function is like
this small and you know you know what it
is so with this trick you can basically
write in only total functions which is
sort of equivalent to saying that you're
really not programming a turing-complete
language
because Turing completeness is overrated
I think so you should give it up until
it was really hard so you really need it
then you can use it general recursion
all of the stuff so what happens if you
know not everyone has a nice type system
like an address or you know like type
theories are formal systems and days
they have things that are not
expressible in them so something you
won't be able to express or there will
be too costly or you you're using Ruby
and there's no type system so what can
you do well if if you can't reach it
with math science that has always been
there it's pretty good you approximate
you gather a lot of evidence and you
just approximate your it's not going to
be a proof or it's going to be a lot of
evidence that that theorem is true
that's what property based testing is
forum thing is a great tool that
basically covers everything that you can
do in a formal system so as a bit of a
recap logic works so you can't you can
rest at ease and curry house
correspondence is a great way to think
about your types and your program
exclusive is better than implicit that's
really just preach to the choir and you
need to aim for lower lower cardinality
in all your type because they basically
constrain the number of implementations
of all type check and total function
parameter it's an interesting a little
bit experimental because as far as I
know there are not many languages that
support that as a sort of first class
paradigm it is one of them and you
should definitely check it out if you
haven't and well if all fails I've done
that myself you can design your types in
a rich logic such as a dress or Haskell
or Scala whatever your whatever floats
your boat and then poured them to a sort
of less expressive logic where whatever
language you happen to be working or you
can generalize the unit test into
probably based fast and it will make a
lot of people happy
so there's a lot of ongoing research and
all this stuff and this is quite i would
say new but it's quite new and the idea
is to build more robust predictable
intake systems yeah that's the goal that
we share so this is by no means the only
way and types are not the only way
either testing helps and you should keep
doing it but i think this approach is a
little bit more systematic and very
promising that doesn't mean it's you
know it's the best but it's I think it's
pretty promising and interesting in any
case we we can agree that if we need to
build you know the stuff tomorrow the
robot that will run everywhere now
bloodstream and everything we need to do
better but now however it is so we need
to find ways to do better and I think
one of the one of the ideas is to
recognize that we don't know how to
build software it's only been like I
don't know about 6070 years and that's
like nothing so we really don't know
much and it's good to keep sort of stay
on the lookout for better ways of doing
things and which I'm sure you have no
problem with that sort of approach and
so yeah always keep an open mind and go
build some nice software thank
thank you now really the time for
questions hi I would like to ask you if
during your research you have seen some
practical applications / dependent types
because as far as I've seen or googled
I've only seen natural numbers and
vector sizes so there are the few
examples which everyone gives but I
never seen any real application or use
case Thanks okay um so first of all I'm
from the real world yeah come definitely
definitely not as you know a research or
anything to like I approached it was
from sort of a very practical semi
practical perspective and I think a
great way like it didn't really click
for me until I read this book edwin's
book which is really really practically
oriented I thing and you you start
building projects that you would say oh
I actually would build this in whatever
my language of choice and the things you
can do in this in this logic are just
crazy like this is insane I didn't know
this was possible so I recommend reading
the book and I think that that
definitely gives you an idea of the
practical really practical application
including for example dependently types
big machines to model work clothes and
things that you think of us very
stateful and you know things that you
would necessarily think of dependent
types for but it's really great
okay any more questions don't be shy
come beside we have some time
and how do you deal with boundaries like
where you have actually to you know I
store your types in database or that's a
great question great question i had the
same question and this is also explained
in the book and basically the idea is
when you when you have to know something
at one time like a user enter something
or you get something from some file or
whatever there's this boundary in which
you make a decision like for example if
you have index list you need to know
that a list is a size 4 for example at
some point you say okay I expect a list
of size for a little bit like you're
passing something and you say okay this
is a list of size 4 and then if this is
the case then what you get is a proof
that the list of sight is real tight for
and if you don't then you get a prove
that it isn't and from there the type
system can work so you work with those
probes in the type system and sort of
this boundary from runtime to actual
proof to the set sigh system of use is
where the decisions made so you still
don't know what's going to happen at
runtime but you know whatever happens
you you know all your logic is
consistent with the case
hey can you give some here's some advice
about how to convince people that I used
to writing unit tests that property
based tests are good well I guess like
I'm not the most educated person to you
know like it's their sort of a yeah I
guess in our bubble is a bit of a
self-evident thing but I understand that
sometimes you talk to people so my
colleagues may be there I think the
problem is that and my problem sometimes
is that you can't really come up with a
property that you want to test so you
haven't really thought about what you're
testing too well and what you have is a
couple of ad hoc tests and you know that
those are supposed to be the thing but
you don't you don't see the general
property and I think that's a specific
of a problem but the approach of taken
is if you can see the property then
don't worry about it like when you write
another test it will it will hurt a
little bit because you're writing a lot
of tests and you'll be like oh I think I
see the property that I'm trying to test
here and these tests are just like ad
hoc stuff and then you generalize it
only when you actually see it but that's
it it's also a seeing a matter of
practice and the more probably based as
you write the more that easier it is to
think in terms of probably based I think
so Tibbett of a catch any to situation
so I don't know I don't know what to
advise you but yeah I don't know maybe
talk talk to your call share some talks
and you know maybe they'll be convinced
so I didn't start in reading that book
of London problem probably equally
excited about a few are um I've been
wondering about one thing that I
couldn't solve yet probably you cannot
answer me that um when you do something
like creating types from Judah inputs um
like one of the things that you there's
really cool but it was that you can like
read some machine readable schema which
is in a file
example in a type r at runtime yeah but
that must mean that your types are
actually visible runtime right so
normally in programming languages when
compiling the types disappear they are
not in the compiled binary anymore um
you know where thats that border between
the types that still exists at runtime
in a needless program and which don't um
something I've been thinking about and
which I couldn't forget that's a very
good question and I had never asked
myself this and I think it's a
religiously but I have no idea how so I
guess you'll have to ask some of the
address developers they probably could
explain and I'm interested in knowing
how it works I never thought of this of
course some of these had to have to fix
a runtime</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>