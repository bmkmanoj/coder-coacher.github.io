<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Property-based Testing is a Mindset - Andrea Leopardi - ElixirConf EU 2018 | Coder Coacher - Coaching Coders</title><meta content="Property-based Testing is a Mindset - Andrea Leopardi - ElixirConf EU 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Property-based Testing is a Mindset - Andrea Leopardi - ElixirConf EU 2018</b></h2><h5 class="post__date">2018-05-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/p84DMv8TQuo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so probably based testing
that's what I'm going to talk about
today my name is Andrea I move the mic
yes I mean the licks record team I've
been working with on property based
testing for the last few months I work
at a company called weed maps as in weed
weed like weed and ID so it mashes like
it's like Yelp for weed so you can just
yeah it's a church story so in places
where it's legal legal I set into the
mic so they have like reviews for
dispensaries and you can find
dispensaries close to you and doctors
are prescribed and you're gonna review
weed that's yeah that's it
it's it's a really great company so I'm
working with licks there we have a lot
of elixir going on we're running in a
lot of new stuff with elixir and we are
hiring so if you want to come work at
weed moths which surprisingly doesn't
include weed I mean this is true you
would love to program like any other job
then just go to weed not slash careers
so let's start talking about testing so
basically why do we test our code with
us because if there are no tests then we
have not a lot of confidence in our code
we don't have a confidence in changing
our code because every time we want to
test something we have to do it manually
and it takes time and it's error-prone
so we're not confident in doing changes
we're not confident in our codes I know
we're not confident in doing additions
so we do testing of our code so that we
get confidence gained confidence in our
code basically and with tests we're
basically more confident that when we
change our code it won't break that non
regression cases are covered and that
everything works and we don't break
anything and probably the most common
way of doing tests or the most diffuse
way is unit tests and unit tests are for
testing like small amounts of code and
they usually look something like this at
least in elixir so you have a function
sort that takes two
list of integers and sorts - list of
integers and the unit test for that
would could look like this so you would
test for example an empty list you would
test sorting a sorted list and your test
sorting and unsorted list annex and do
expectations on the results and we this
can be referred to it can be thought as
example based testing because you're
basically just checking the bunch of it
for a bunch of examples your code works
so you're just checking them for example
friend list with 1 2 3 then the code
works as I expected you can also think
of this as table based testing so you
basically have a table of inputs and
outputs inputs and expected outputs and
you just run your code through the table
so you feed it the inputs and you assert
that you get the expected output back so
you need tests they're really good for a
bunch of things because they're easy to
write there's usually straightforward to
write they are really good at covering
stuff like regressions and non corner
cases like in the sword example the
empty list would be a known corner case
because it was a list with no elements
in it so it's really it's really easy to
cover those non corner cases because you
know them and it's also though art to do
a bunch of stuff with unit tests for
example finding unknown corner cases
because you don't know them so you don't
know how to express them and you don't
know that they're there and and with
unit tests it's also really hard usually
to express properties of your codes so
if we if we were to look at the sorting
unit test that we saw earlier it would
be really hard to tell the dark sort
function is a sorting function except
that it's called sort right because I
mean it's a simple function it's a
simple example of course but you can
imagine cases where it's really hard to
tell what a function is doing just by
looking at unit tests for that function
so enter properties so properties are
much harder to write but they are more
they can be more powerful in some cases
so basically how properties work is like
this
introduced a bunch of this stuff
yesterday but I'm gonna just go through
it really quick so you take a bunch of
well you describe a bunch of valid
inputs to your code you describe
describe the shape of valid inputs to
your code and you define properties that
your output should have for those valid
inputs to different properties that
should always be held as long as the
input is part of the valid inputs and
then you basically feed the valid inputs
shape and the properties of the output
to a testing framework that will be
responsible for generating a lot of
valid inputs at random and then running
them through your code and asserting
that the output has the properties that
you expect that it held the property
holds the properties that you expect it
to old and basically the test so the
testing framework basically tries to
prove you prove you wrong tries to find
an input that you said it's a valid
inputs and that doesn't hold the
property that you said they should old
so for all examples I'm gonna show I'm
gonna use stream data which is the
library I've been working on for
probably based testing in Aleks here and
it's what's gonna it's gonna be in
elixir 1.7 you know so let's start with
the same example as before which is sort
in the list so this was the eunuch eight
at a unit test we had for this so let's
define the valid input cell this or can
take write the validly inputs are just
lists of integers any list of integers
is a valid valid input to our sorting
function and let's define their
properties now that this the output of
this should have so the output of this
sort sort function should still be at
least it should still have the same
elements as the original list so you
shouldn't order loose elements and it
should be ordered so that's the basic
properties some basic probably this week
we can think of and the actual property
for this would look something like this
so you basically define the values shape
of inputs by saying okay list of
integers or valid inputs this is a
generator we're gonna talk about this
later
and then we say I'm gonna bind this to
list so the list would be generated at
random on every iteration then I can
sort the list and have a sorted list and
I can assert the properties that I
described so I get kind of said that
this is late
the same elements is the original list
and that it's sorted so this is how it
would look like if we were to do
test-driven development so like stop
write this test and then write an
implementation we could start with this
implementation so this satisfies two out
of three properties because the output
is a list and it's as the same elements
as the original list but it doesn't it's
not of course sorted right so at some
point while generating the random it
links lists of integer integers the
property based testing framework would
generate something for example like this
right so list that is not sorted so this
is a list and it has to say if you
sorted it will have the same elements if
you sorted with the function I just
showed it will have the same elements as
the original one because it will be the
same but it's not sorted of course but
it's it's a bit hard to tell that this
is not sorted or I mean imagine that
this was a more complex problem and a
more complex thing but this is not the
simplest list that shows that this is
not sorted right because there's like
large numbers that it has more numbers
than necessary there's negative numbers
and this is all useless to the property
that it's not sorted right so what most
priority based testing frameworks do and
including stream data is that they will
shrink the input that fails to the most
to the smallest possible input that
still fails the code so it will try to
reduce the complexity of the failing
input so that it finds something in this
case like a list with just two elements
1 and 0 which are very small integers
and they still show that the list is not
sorted and the function that doesn't
sort the list would break for this as
well and it's release you see why right
it's real easy to see that this is not
sorted so this is the whole like
property based testing how it looks like
and now when I talk about a few things
there are generators so how generators
work then I want to talk about a few
patterns that you can use to write
properties and come up with properties
for your code and then I want to talk
about stateful a little bit about
stateful property based testing and then
about the research we're doing currently
in stream data and the future of stream
data
so let's start off with generators so
just that said a bunch of this stuff
yesterday in the keynote but I'm gonna
just go through it quickly so generators
are just basically infinite streams of
randomly generated data so if we have an
integer generator for example and we can
take four elements out of it it's just
gonna return four random elements
they're not guaranteed to be unique
because you want to combine generator
it's usually so uniqueness is not
important at all it's actually good that
the values repeat but so this is an
infinite stream I can take as many
elements as I want as I mentioned
yesterday this grossing the elements
growing complexity as I keep getting
them out of the of the generator usually
so that the property this is done so the
property based tests are can grow in
complexity so that every so that dot
data grows in complexity when you're
testing it input grows in complexity and
generators are composable so someone
asked yesterday how do you compose
generators or you create your own
generators and that's through
composition so we have other generators
like one-off in this example that take
other generators and compose them into
new generators so for example you have
the integer generator the float
generator if you wanted the number
generator that generates integers or
floats you could use one of an integer
float and a widget on integers or for a
random and then we have other functions
that change the output of generators for
example map is the simplest one it just
takes a generator and then a function it
applies the function to every element
generated by the generator so for
example if this generator would be a
generator for non-negative integers
it would just be integer which generates
an integer but then we have we mapped
the absolute value and that they were
always positive or or zero and we use
composition quite extensively in stream
data itself as well so for example the
string the ASCII string generator is
implemented close to this so we just
take an integer in the ASCII range so
that's a skew range over there
and then we'd be lists of this integers
and then we map the list of string
function over this little over each list
so basically we convert the list to a
string and then we have strings and so
the reason why we want generators to
compose of course is to create more
complex generators but it's also because
we can't use stream functions on
generators if we use generators in
property based testing because if we do
for example stream stream dot map on a
generator it will work fine with routing
values out of the generator but it will
not keep shrink ability so if you want
to keep shrink ability you have to use
stream data functions so that
composition also keep composes shrink
ability so in the example over here for
example you would the shrunk value will
still be positive you will never get a
shrunk negative value because the
absolute function would be mapped to the
shrink shrunk value basically as well
and it's nice to know I think that the
whole like Jews I mentioned yesterday
like we try to do it is in a very
functional way where we have very small
primitives and build a lot of generators
on top of those primitives and it's just
I just want to show quickly what they
are and to ones that I think are most
important are the constant primitives
and vine filter computed composition
function and basically the constant
generator just generates the same term
every time you invoke it so you can use
it to turn a term into a generator
basically and the bind filter possibly
creates a generator from generated terms
so you have a generator it generates a
value and you use the new value to
create another generator so you bind the
new generator to the old generator
basically and this is a very contrived
example you can look at a little later
in the slides but basically we're having
an integer generator and then we're
binding a function where if the integer
is less than zero we throw it away so we
generate one more and if the integer is
zero or greater than
I returned another generator which is a
list of integer where we map the
function with it adds an integer so
basically we generate lists that are
where all element of integers where all
elements are greater than give me an
integer basically that's that's the idea
um so this is as far as generators go
now I would like to talk about pirate
patterns which is a very like hot topic
I get a lot of questions on like how do
I write good properties which is a
really hard thing to do because of
course it takes practice but it's just
hard to come up with properties and hard
to get into the mindset of property
basing and I would like to show some
patterns that can help in when you're
writing properties for your code so the
first pattern that I like is circular
code this is a really easy pattern to
spot and it's whenever you have code
that looks like this so will you have
some encoding function that encodes a
term and then you have a decoding
function that decodes e encoded the
results and you're back to the original
term so this is really easy to test with
property based testing because you're
gonna have a test for example this is
for JSON encoding which is exactly this
case and this is taken almost verbatim
out of the JSON code base from me how in
the elixir team and basically he's using
property based testing to do exactly
what I said so you he's generating
strings and then is encoding those
strings with unicode escaping and then
asserting that decoding the encoded
string goes back to the original string
and me.how said that this helped and
this kind of tests helped a lot well
building JSON and he found bugs and I
mean I'm sure my house code sucks
so there would be bugs anyways but at
least probably based on testing health
and this is like circular code pattern
the Oracle model pattern is a real
another really really common pattern and
which is where you have your code and
then you have some other code that does
behave the same as your code and we call
that Oracle code or the the Oracle and
this can be an older system sorry it can
be an older system for exam
that your reimplemented that your
rewriting and behaves the same way as
the new system or it can be the less
performant implementation of your of an
algorithm for example that you know it's
correct because it's much easier to
understand but it's way less performant
so in those cases you do something like
this where you just assert that your
code behaves in the exact way of as the
Oracle code does for all valid inputs to
both codes and an example of this that I
used recently is when writing an HTTP to
client and as we do include some Huffman
encoding in it and there's enough fun in
code encoding library in Erlang that I
couldn't years but I used it as an
Oracle when testing my implementation so
I just basically generate any binary and
I test that my implementation behaves
except includes the exact same way as
your long implementation so another
pattern that I like and I heard this in
a YouTube self that is linked at the
bottom of the slide is use doing smoke
tests with property based testing and
this is useful because often you have
like a large system and you don't know
where to introduce property base testing
because you can only introduce it maybe
at a very small level a very low level
and it's really hard to know where you
have to where you can start using it so
smoke testing you can use property based
testing to do smoke tests so an example
could be you have Web API HTTP API and
you know it can only return one of these
codes it can only return either
221 if something went well or 400 and
404 if there was an error so what you
can do to smoke test this basically is
to do a property based test where you
generate random HTTP requests and then
you perform those requests on your
system and then your cert that the
result the response the resulting
response has the status that you expect
basically so what you're doing here is
you're ensuring that you don't get any
unexpected things which is really the
point of the smoke test so you're not
ensuring that your system works
correctly of course because you could
generate a response that is supposed to
return 200 but it returns four
for and this test would pass anyways but
at least you're asserting that your
there are no or at least like you're
gaining confidence that there are no
HTTP requests that you can craft that
will break your system in unexpected
ways so it will let you let you return
like 500 or other status codes that you
don't expect and I think this is really
good to like start using property based
testing in large systems so take like
big chunks of the system and just
ensured it like do smoke tests and
ensure that nothing unexpected happens
even if you don't know if actually
correct stuff is happening inside
another pattern that I want to mention
really quickly because it's really
simple is to use to be very slow I mean
very quick in CI so it use a very few
number of iterations when using probably
based testing in local development and
bump the number up in CI a lot so for
example you would have something like
this in your configuration where you say
if I'm in a CI environment I want every
property based test every chat call to
run 500 times so to generate 500 random
inputs and test all of those otherwise
if I'm locally developing locally I
wanna just to create 25 random inputs
and this is really good for you so you
want a fast feedback locally you want to
be fast when developing so you wanna
test run really fast 25 input is still
enough that you cover the like space of
inputs I mean a list in in a well enough
way and then you run tests local locally
a lot of times right so every time those
25 inputs will be different so you're
still ensuring that you cover like
enough inputs so that you know you're
not bringing anything but on CI you can
bump that number up because you don't
care about the time that CI it takes to
run your tests and you can try much more
many more inputs on CI and then the last
pattern that I want to talk about is
it's not a pattern it's just advice is
don't drop unit tests when you want to
work with properties so properties I
think the properties and unit tests are
and to work together they're meant to
live together unit tests are still
really really good that a lot of things
that probably the desk can do so for
example they're good and no one corner
cases so we start to cover non corner
cases with properties because you have
to kind of force the corner non corner
cases to be generated when it's much
easier to just basically have unit tests
for them their unit tests are really
really good for regressions so if you
have variation and you have the unit
test for it it's better to have a unit
test for it because you don't know that
your properties are gonna generate the
same regression unit tests are good for
spec examples as well so we enter when
you have a specification like Huffman in
the example before there are some
example and it's good that you test
those exact examples I think on the
actual on as unit test so you test those
specific examples and then your
properties for all that other stuff you
want to check on your code and this is
an example from yesterday's salt from
the sources I got asked something like
this I think at the end of this talk and
I don't think he gave an answer because
I don't think he understood the question
but so the idea was that you have
something like these string contains
where you you have a property that
string contains if you concatenate two
strings then this returns true for both
sub strings and someone asked like how
do i how do I do a negative case for
this in the property so if I make string
contains returns return true all the
time this is going to pass easily right
it's good just gonna work so the idea I
think is that you pair this property
with another test which is a unit test
basically and it just tests actual some
actual data so that you know that like
I'm missing a refute here sorry but
there should be a refute for that
testing that's something that is not in
the string is not in the string right so
if you pair the property the tests the
general property and that a unit test
basically confused that the property
actually doesn't hold for invalid inputs
they live together and they give you the
basically the best of both worlds so
you're kind of sure that it works for
or invalid inputs and you're sure that
it works for valid inputs all right so
this word a bunch of like patterns you
can use to when coming up with
properties as I said coming up with
properties is inherently hard I think
because we're not used to it but it's
very beneficial because it doesn't only
let you write properties and test with
probably based testing it also forces
you to think about your code in a way
that you're not used to and you think
about where what are all my valid inputs
and border what are some properties that
should always always hold and you'll
find out that oftentimes the property
base testing framework will find inputs
that you didn't think we're valid or it
will find inputs that you thought were
not valid but it actually should be also
you have to change your code and it will
help developing software not just by
testing it but by changing your approach
to testing it as well so I would like to
talk about safe field testing now which
I just want to talk about it because we
don't have anything in stream data yet
but stateful testing is so is if you
notice everything that I said until now
is actually stateless property base
testing so we're only generating data
and it does basically doesn't have state
we're only generating terms and then
using those terms most of the times
though you have in your system you have
some kind of state you have some
stateful systems like it could be a
chancer ver it could be a cache or
anything like that so those systems are
stateful they have a state and probably
base testing is really really good at
testing those kind of systems testing
stateful systems so the idea behind for
a stateful property base testing is that
you start with a model so you model your
system in a way that you can express in
your code so that's referred to as the
model and then you have a bunch of valid
comments that you know you can execute
on your system and then you will execute
them on the model as well and check that
the results are coherent that they're
expected so the model is usually just
the state plus a bunch of state
transformations so the state can be at
the data
structure their transformations are
transformations that what you do when
you execute a comment on the state and
then you have to update the state to
reflect the comment that has been
executed on the stateful system so this
is a state a bunch of straight state
transformations Commons they're a bunch
of calls so so they can express calls to
your system or Commons that you execute
on your central systems plus a bunch of
preconditions that are used so that you
don't execute comments in states where
they should not be executed so for
example if you have a cache and you over
a gen server you only want to excuse the
common when the genes are raised up and
that would be a precondition on a
comment that the gene server is up so
you only generate sequences of valid
comments another idea is that you feed
these comments and the model to the
property based testing framework and the
verb is the base testing framework would
generate a bunch of comments and then
run them both on the model and on the
stateful system at the same time and
then every time it runs a common just
check that the stateful system property
of the state full system is reflected in
your model so that's up to you of course
decide which properties and how the
model represents the system but that's
what the probably base testing framework
does and if there's something that goes
wrong it's really really useful because
comments and the common list will shrink
just because they're generated from
generators probably based testing
generators so the common list would
shrink and it will try to find a minimal
way and minimal list of comments with
simplest possible arguments that if you
execute them on your system they will
really produce an error that you found
through your model and I just want to
give a quick example on this that could
be this is something we're discussing in
the stream data repo and in the team and
we're using this as examples for now so
I thought to use just the same example
so which is just getting a setting
setting keys you ready so we want to
test that was ready sis capable of
getting and setting keys and in our case
the system that we want to test this I
think okay and the model that we use is
just a map because it's just a key value
store just as much as Redis
for purposes so we just use a map to
represent ready in our case and then we
have just two Commons which are get a
key from Redis and set a key to a
specific value so the implementing the
Commons for the model is really really
easily it really easy because they're
just since it's a map we know that like
getting a key from a map is just a map
get and setting a key on a map is just a
map put so this works we can implement
this just fine and then this is just
like of course it's a made up API
because we don't have any VI yet but
this is how it could look like so I
wanted when I want to generate comments
I can say ok the Commons are one of
these comments and each common is gonna
be for example the get command it's
gonna be get and one of the keys that
exist so we have the model on the first
line we know the model and the model is
in map and if we get the keys from the
map we know that those are the keys that
are supposed to be in Redis because our
model perfectly reflects Redis so we can
get the keys and then we can say for
example a get command we get one of the
existing case a set command can be just
set a random binary to another random
miner he said it set a key which the
random miner into another random binary
or set an existing key to a binary so
the last one would be set existing as
semantics go and they could look
something like so the actual state
transformation and assertion that
everything work would look something
like this so if you ever get common you
never be not changing the state because
you're just reading from ready so you're
not updating your model but it could
look something like this we do ok check
that this getting the key returns an
okay result and then check that the
result is the same as the result that we
have in the model for the same key so
basically I want to check that when I
get a key from Redis and I get a key
from the model that they're the same we
should all should always be true and the
second comment we don't care about
asserting anything when we're setting a
key but we care about updating the model
so this would be a state transformation
so when you set an existing key to
something then I update the model and I
replace the key to something in the
model as well so that basically they're
always in sync or
at least the model behaves how I want
red is to behave and then I can check
that Redis behaves that way so stateful
as I said sexual property base testing
is really really really powerful and
it's been used a lot in that it's a lot
of success stories that you can go read
and they're really interesting and one
that I really like is one about leveldb
which is I think a Google database for a
key value storage and they used property
based testing on level to be a stateful
property base testing on level DB and
the first found a sequence of 17 calls
that would create ghost keys in level 2b
and this is like a minimal minimal case
that reproduced it so the property based
testing framework found a single 217
calls that we would like the smallest
signature could reproduce this which
means like a human could probably
wouldn't have never found this or if we
would have stumbled upon the same error
it would be with a much more complex
sequence of calls to the database so
they solve this and then they run
property-based us again and then if on
sequence of minimal signals of 33 calls
now which is like twice worse but it's
the same principle and then they fix
this as well and these are like it's
really really hard that you find this
like a human finds this thing so it's
like really shows that like fuzzy
testing and random testing and and
shrinking them can bring like great
results so this is about it for probably
prostate 'full property based testing
we're working on defining an api which i
think is one of the artists part like a
easy to use API first stateful probably
based testing I don't want to start
working on this soon it will not be in
the version of stream data that is
included in elixir or in so it will not
be in 1.7 but we'll work on it and it's
gonna be ensuring that at some point
because it's like too useful to miss and
then I want to talk about the research
we're doing in stream data so the first
thing I want to talk about is what does
I mentioned yesterday which is trees so
trees are really hard to implement and
generate because they
really hard to generate with good
distributions basically so if you have a
tree that looks something like this
where you have a tree that is either a
leaf or a topple so it's a binary tree a
table of two trees and we have functions
like size and depth to help analyze this
tree so if we generate a lot of trees
these are the data that I got with that
tree so if the generation size is 10 for
example the average size so average
number of nodes is only 5 and the max
depth is like 2.5 so you like it's
they're not deep the trees and the
generation size if it grows the average
size in max that don't grow like as well
as we would like to so for example the
average size for a generation size of a
thousand it's just 22 when the depth
really really grows really slowly so
either we have small trees or we have
very flat trees or we have deep trees
that don't have a lot of nodes where the
nodes are distributed in a very vertical
way so where this is a as you said this
is really hard problem so we're working
on reading papers to to try to fix this
but for now it's I mean it works but
it's it's not the best implementation
and the other thing which I'm really
really excited about is to basically
combine stream data and dialyzer so this
is actually a candidate to be a google
Summer of Code project this year so and
there's the there might be a student
working on is which I'm even more
excited about but the idea is that we
want to have two things the first one is
to have generators from dialyzer types
so if you have something like this type
timeout which is a built-in type which
it's either the atom infinity or a
non-negative integer then we want to
have a function so this is this is not a
real API but we want to have a function
or something that takes the type and it
will create a generator out of that type
so it will create a generator from the
timeout type and this would be roughly
equivalent to something like this so it
would be either infinity or a
non-negative integer so you would be
able to by itself to turn the timeout
type into an actual generator that you
can use in your tests and this would be
all red
really cool because we I mean we have a
lot of types already defined in elixir
and defined in text is easy let's the
syntax is really easy to use so it would
be good to have automatic creation of
generators from types but things are
more even more excited about would be to
use this to build on top of this some
automatic type spec property checking so
basically right now we have types FAQs
which look like this and we want to
build something where the stream data
goes in and says okay this function
takes a timeout so I know how to
generate timeouts because I know how to
generate I'll to create a generator from
a type and then we want to say okay now
just feed timeouts to my phone and I
assert that the result is either okay or
error so we would do this automatically
from the spec so it would look something
like this they're generated code will
look something like this so you have
checkol that anytime I'll check the lens
I'm out basically if you pass it to my
fund and the result is either okay of
error for for that spec so to do this
we're so that we're missing basically
checking that something is part of
something of other type so we don't know
yet how check if something is okay or
automatically that's what what we will
be working on mostly but this is I mean
this is huge because it's smoke tests
for free right so you're not checking
that you're not checking that my phone
behaves correctly but you're checking
because it could be returned okay when
you should return an error still but
you're checking that my phone always
accepts valid inputs and always returns
value outputs and this is really really
big
especially if done automatically because
you don't have to do anything except
spec your function which you might
already be doing so we're really excited
about this I hope I hope the google
Summer of Code project goes through and
we can make this happen
so in conclusion just a few parting
words property based testing is really
nice too for a bunch of thing the first
thing is to find obscure bugs because it
will generate weird data that you would
never try yourself and it will fit it to
your system and find weird bugs the
other one that I really like is that it
reduces input to a minimal filling input
so it doesn't just create
very weird data that could break your
system it will so take that weird data
and make it less less weird in order for
you to understand why it broke the
system in the first place it's very good
at finding specification areas as well
so not just bugs in your system but as
you say mention yesterday as well
finding bugs in protocols and finding
bugs in what you think your system is
supposed to take what you think your
system is supposed to output or take or
don't take so these kind of things and
then is really good at covering a very
vast input space because say let's
generate a random every time you're on
and you run the test many times so over
the time you're gonna try a lot of data
against your system so you gain more and
more confidence that your system behaves
correctly so as we said this is gonna be
in a look through 1.7 so I'm really
excited it's gonna be in core because
it's means that it will be really
accessible easy to use it would be well
documented and it will be just there for
you to use it so for now though just use
stream data so that we can make it
stable enough that it's in core and you
can start benefiting from it now then
use probably based testing anyways if
you're not an electric programmer
there's implementation for everything
there I know there are for Scala Java or
close your long Python JavaScript
there's pretty much for everything so
it's not this is not a little extra
thing so if you join use elixir you can
use probably based testing anyways and
that's it
thanks for the talk
I was wondering what's the difference
between the distasteful testing that you
showed at the approach when you can just
generate different things and use
pattern matching to call the function
that dynamically or just send a message
to the join server because I don't know
if there's any difference and maybe I
missed something
um so I'm gonna try an answer to the
question that I understood but then you
can talk to me later if the question I
didn't understand the question about the
idea what is that if you want to for
example you can definitely generate
random messages to send origin server
and that's gonna work without site full
testing the problem is that usually the
problem is that you don't have a model
to check against on every step so in
every comment that you take okay to
comment at your issue so it's really
useful to have that built in different
framework and then it's really hard to
generate valid lists no it's not really
hard but it's hard to generate valid
lists of Commons that you can execute
one after the other and shrink that in a
way that they remain a valid list of
comments so that's where the fateful
property based testing would help and
but I mean I think mostly it's just a
matter of a good API that expresses the
tests and the properties well you know
I so I was wondering you mentioned that
property based testing is really good at
finding inputs that are accepted but
shouldn't be how would you how would you
kind of code that how would you
recognize them because you're if you're
asserting on function returning true
then how do you know that yeah in many
cases you can't recognize that like
you're testing more inputs on you should
but in many cases as well you test an
input that you didn't think your system
should take or that you thought your
system didn't take and it takes it and
it actually behaves in a weird way that
it's not expected and that's how you or
I mean or either it breaks or it just
behaves in a way that you're not you
were not expecting it to behave and you
kind of guess it then thing but what it
would was invalid or or is valid you
just didn't handle it basically do you
get some sort of output in that
situation or do you kind of have to
guess that yeah you would have to guess
yeah yeah we have known to one for like
this kind of stuff I mean you would just
have to get depending on the system yeah
oh thank you hi thank you for the part
about patterns because that's really
useful and while you were talking about
the smoke test especially I was thinking
like how does the shrinkage work if your
system is a little bit flaky so I'm
gonna answer and I quit question which
is like what if the food system went
ringing fails for another reason is that
a is that a yeah so you it comes up with
an example input the system fails and
and you start to try to shrink but then
you can't produce the error while
shrinking like does the shrinker become
confused
so the shrinker so first of all it will
not look for the same error he will look
for any error like going going down on
the data right so if the data if there
are changes so for example if you
in that case you'll find a state like a
response status that is not in those
four so you find an input that causes
that right then it starts shrinking in
and at some point it finds a exception
is raised so no the response is returned
at all it will still consider that an
error and keep going so whenever the
test doesn't pass so assertion fail or
an exception is raised
so whenever the test doesn't pass it
will consider that as a failure and keep
shrinking on that right and if it
doesn't find any error when shrinking in
just reports
I couldn't shrink anything I mean this
is like this is the smallest state it
tries to find that it doesn't try to
find the smallest data it tries to find
a smaller date-date a smaller version of
the data that cause of the input the
cost of failure and if you can't it just
reports the like original one
all right okay thank you so the last
thing you said about generating
generating property tests from from tile
specs what actually is the difference
from just running the type check like
what what extra do you get by doing this
you I mean if dialyzer worked perfectly
you wouldn't I wouldn't change anything
but alright dialyzer is weird to run and
this is a dynamic language so I mean
it's good to test it for like actually
running it and yeah that's it I guess
yes I understand the value of testing
but in our system the test might take
more than half an hour and sometimes an
hour to go through the whole system what
would you expect the performance
degradation be if you start applying
this so the performance of property
based tests yes it's terrible because
you're like doing a lot of tests so I
mean you it's not so if you have one
unit test you're doing one unit tests if
you have a probably based test you're
doing what that one unit has a lot of
times and on top of that you're
generating data and you're generating
data is shrinkable so the performance is
not it's not the best but so that's
that's why I suggested that you keep the
number of data that you test locally
very very low so that you can only test
a few data locally but many times and
then use stuff like CI for running a lot
of generated test cases basically that's
that's my suggestion let's take one more
question
thank you for the tuck you said about
smoke test and request generator and I'm
wondering if the request generator
generates like totally random requests
or can i specify for example the list of
endpoints or oh the the example where I
used a randomly generated HTP requests
were was really made up so there's no
HTTP request generator in existence that
I know you would have to write that
yourself based on your on your system
and yeah you would have to provide that
yourself okay thank you
I'm right thank you everyone Thank You
Andrea that's giving unwrap close
inaudible close
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>