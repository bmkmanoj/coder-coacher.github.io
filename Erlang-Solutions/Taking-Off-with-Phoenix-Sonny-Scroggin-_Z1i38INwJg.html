<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Taking Off with Phoenix - Sonny Scroggin | Coder Coacher - Coaching Coders</title><meta content="Taking Off with Phoenix - Sonny Scroggin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Taking Off with Phoenix - Sonny Scroggin</b></h2><h5 class="post__date">2015-12-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_Z1i38INwJg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone thanks for coming my name
is Sonny spragga and I one of the core
contributors the Phoenix framework
project so here to talk to you today
it's going to be kind of an introduction
so hopefully those of you who are not
familiar with this project already will
go away understanding more there I have
a ton of slides so save your questions
till the end if there's time if not i'll
definitely be welcome to answer
questions over you guys afterwards so
all right so Phoenix Phoenix is a
framework for building modern web
applications API backends and systems
it's written in group turning an elixir
so you do get beautiful syntax
give me a very productive tooling and a
fast and efficient runtime thanks to
robert byrd in here the beam so I
Phoenix didn't say NBC style pattern
framework so you can get models games
and controls for separation of concerns
should be very familiar to those of you
who have experience with other MVC
frameworks like rails or python django
crime we have channels which is an
abstraction for doing real-time kind of
data in your application so talking to
web sockets or singing events doing
pub/sub is in the server and sending
broadcasts out to your other listeners
it's very easy to test so it's also
really fast so anybody that's familiar
with writing tests and Ruby on Rails and
you have to spin up the server slow and
it takes a thousand years to run your
tests in Phoenix and elixir in general
it's incredibly fast so and of course
with Phoenix there's no compromise I
think someone was saying earlier that
you know you have these great tools and
we were super productive and your other
frameworks and stuff but then when it
comes to running this stuff at scale you
start hitting walls and with Phoenix you
guys up the beam you really don't have
those problems you don't have to choose
high productivity or high performance
you get both so probably heard maybe
some some stories but Phoenix is pretty
fast so how fast is it this is a some
benchmarks that were produced this is
several months ago
see Phoenix up here is at zero 13.1
version we're just released zero hour
one point zero point four yesterday so
this is a little bit old and we have
done some improvements so these actually
should be faster now so this was done
against other frameworks and other
languages so Jin is a go framework
misread our new underneath plays from
Scala and of course these are very fast
but Phoenix has been able to perform and
obviously Phoenix was also a benchmark
at a lower version and see the
performance actually increased no
Express cluster martini is another go
one that's actually not as good
obviously so not run trails so and later
on the slides if you want to check this
out or just there so Phoenix is an OTP
application and it basically just
provides functionality for your OTP
application and then so you can
obviously start/stop independently of
each other gives you all the flexibility
so Phoenix is not in itself doing all
there's actually it's built on top of
the shoulders of some of these really
really awesome libraries and so it's a
multi-layer system very modular and
flexible and plug is a simple
abstraction for dealing with web servers
it currently uses cowboy which is a
erlang HTTP server and it's very small
lightweight fast and we also have ecto
which is a DSL for writing query for
interacting databases so getting started
hopefully the
is ok so we have a mixed ask or I'm
sorry it makes archive that you can
install with this one line say mix
archives on installing into this address
and it will download the latest version
or the tag version there it will ask you
if you want to create it so generating
your app we have this mix task will fix
phoenix w you give it the name of
gravitation and it will generate a
scaffolding or a skeleton of your
application structure then it will ask
you if you want to fetch and install the
dependencies say yes then it will go
ahead and run npm install which download
some note jas libraries and this is
optional
brunch is a note Jas has set builder
tool so when you're building web
applications you also have CSS
JavaScript and all stuff and probably
the best tools for building javascript
is probably a JavaScript library right
so we pull in those you can also when
you're generating application you can
pass dash dash no brunch and it will not
install those dependencies so you if
you're just building an API back in
that's going to be dealing with JSON
stuff like that you don't need the front
end this and you can totally those off
so everything is fully customizable
configurable thanks to the added review
it will also run mix tips dunk it which
will get the dependencies for from hex
which looks at package manager once that
done once that is done print out some
instructions or further why do I denotes
yes let's let's hold off on the comments
until it happens so then after we're
going to see me into the my answer x-ray
run a mixed ask kyle called echo def
create i'm going to create a database
which is here and and then we can start
the server so there's an option pics
being spot server or what I like to do
is I like to run it in wicking
interactive elixir console so you can
just say I exps mix and give a game
stuff server which will then start up
your web server it starts up the whole
application and starts the endpoint with
web server turned off so that will start
cowboy on localhost 4040 obviously
configurable and then voila do you get a
nice landing page to start up so in the
server logs you can see the process of
the
request so it was a get request to slash
which is the root debug message shows
tells you what's actually going on in
your application you have a handler
that's handling the specific requests
and you can see down at the bottom there
that your request was sent in 889
microseconds so Phoenix is incredibly
fast when it comes to rendering
responses and we see why that is later
on this is the file structure that you
start with and we have the most notable
ones are the config directory which
holds all of your configuration for
different environments so you can have
different configurations ultimate
production if you have a QA server
testing and stuff like that you can have
files its specificity of those we have
the lib directory and what goes in here
is generally your OTP specific
application things that are going to
deal with supervision trees processes
that need long long the running stuff
then we have the web directory the web
directory is for all of your application
code that does not mean to me that
doesn't hold any state so all of your
controllers or web requests that are
just handling requests as they come in
and this is separated out specifically
because we have a code reloader for in
development when you change the file you
don't want to have to restart the web
server before all the picks up all the
changes and then of course we don't want
the live stuff to actually be reloaded
as well so they're separated for that
concern and of course it's a very
important directory is the test
directory I hope you guys write tests if
you don't write tests elixir makes it
very easy to write tests so the web
directory contains as I said all of your
web specific stuff so you have channels
controllers models you have the router
which ross requests in traffic static is
for your static assets javascript CSS
yeah templates which are your actual
HTML files that gets interpreted and you
have views which are modules that render
the templates the lib directory holds
the endpoint which we'll discuss in a
bit the repo which is for the database
and my app which is where your actual
OTP application lives which starts a
supervillain tree the test directory we
actually come with several tests helpers
that will help in making testing various
so if you run a mix test then you see me
actually come with four passive tests
already which also gives you kind of an
idea how to start testing we have
several different mix tasks that are
available with Phoenix and if you just
list those out there you can find out
what they do we'll go into some of them
a little bit later so plug if you
remember back at that list of benchmarks
plugs at the top so plug is actually the
library that is really we're writing on
the shoulders up and it's a very simple
abstraction that allows us to model a
request response cycle very very simply
it's one single data structure and
tips on that but basically it's a
specification for constructing
composable modules to build web
applications and so plugs are reusable
modules or functions and they're built
to that specification so plugs can be
written to do pretty much everything
authentication rendering your video
templates and so forth and of course the
previous slides provides adapters for
HTTP web servers and the one that it's
built with that comes with support for
on the box is cowboy so the plug
specification there are two kinds of
gloves there are function plugs and
modular plugs a function plug is a
function that receives a connection and
a set of options and it must return that
connection and this is its tech
signature so clunk on gotti that's the
plug struct and it receives some options
and it returns think on this is an
example of function plug it is a
function takes the calm as the first
argument and some options in this case
you don't care about them so we ignore
them and then we take the con and we
pipe it through some other functions
that also follow the first specification
which is you get the you get the
connection you maybe do some
transformation on it and then you must
return the connection so Mazel plugs are
slightly different twist on it's an
extension of a function plug and it
expects that your model or implements
these two functions so you knit one and
call to admit one takes any term or long
term or
let's turn and it Eliza's these options
of course it could be and call to will
take the connection and the options that
are actually initialized is in the unit
call and generally a nit is actually
handled at compile time and so you can
do your initialization of the options at
compile time and then those compiled
options are what is being sent into your
plug plugs call to motion this is an
example of the Jason header plug but
pulled out into audio plug as an exact
same thing and this is the data
structure for the plug com so it is a
struct elixir and it has these different
teas and different values that you can
use they're all four different different
things so we have a request fields which
like you have host it's a method of the
request needs to be murdered for it
again post or put you have path
information all this kind of stuff that
you have access to when dry tune will
receive a request and build response you
have vegetable fields vegetable fields
or stuff like cookies and request body
things like that where you need to
actually read them from the web server
with what the web server has given you
and these are vegetable fields because
by default are not fetched for you and
until you actually exclusively fetch
them and that is for performance reasons
if you don't give a rip about the body
because of a particular requests you
don't need to try and read the body if
you don't watch it because that's more
expensive so response people's go you
have the response body character said
response cookies and headers and the
status and so all those
sending a response we have connection
field so signs is a is an area in the
connection where you can actually place
it's a it's a map and so you have keys
and values and those keys and their
values basically become variable
assignments throughout the like
templates and things like that you can
use these for your own kind of variables
or values that you need to keep track of
through the connection cycle and of
course there's also private fields the
private field is used for frameworks
like Phoenix and various other libraries
so there are three main plugs in Phoenix
so maybe endpoint the router and we also
have controllers which are closed the
endpoint is basically the start of the
boundary of the requests that come into
your web application and it's the
interface for the application provides
to the underlying web server so overall
an endpoint has three responsibilities
provides a wrapper for starting and
stopping the endpoint provision tree
defines the initial hello pipeline which
we'll get into in a bit and it hosts web
configuration this is an endpoint we
have essentially it's what's called a
pipeline will get to what that is bit
but this is a plug and it also specifies
other plugs each of these are so in this
case we have plug plug static which is a
module plug plug plug the static is the
module name and then this keyword list
here is the options that you are
initializing
with so that compile time these options
will be compiled in with an igg1 and
then at runtime it will be passed in to
this modules call to we also have this
code reloading section here so this this
has only turned on if you have set the
flag for reloading code which is
generally only in development so it
shouldn't be on production and this sets
up a WebSocket that will tell your your
front-end a could change go ahead
yourself so we have live reload built in
so it's really nice for front-end
developers and you're testing feature
and you want to change them code and
automatically have a browser refresh so
some other plugs that are any errors
Club parsers which parts the body based
on request so it's a URL form like it's
a form submission will go through URL
encoded or multi-part file uploads and
we have JSON parser automatically some
other plugs here for some various things
and then we have sessions for bringing
cookies and storing cookies and all have
stuff we have cookies are signed by
default and also verified so you know
that there's a tampering happening with
cooking values there's also a flag or an
option here that you can add which is
causing Krypton's or encryption salt
which will if you have that in there
then your cookies are actually encrypted
as well so it's not turned on by default
because it's obvious is more expensive
and you don't need
and don't follow and then lastly we plug
the router and so the router is
basically responsible for routing
traffic to other parts of the
application so we have set of macros
that allow you to generate routes that
dispatch out to other controllers and
actions and these macros are generally
named after HTTP verbs so we can get oh
look patch dilip etc you also have some
other ones that you'll see and so this
is an example of a router we have this
scope macro that allows you to set the
scope of a route so in this case this is
the route so the slash and my app here
is just an alias so that you don't have
to always prefix your actual controller
with my apt pagecontroller so get /
pagecontroller is the module that will
it will be rabbited and then index here
is the function inside of that module so
we also have this macro called resources
and resources will generate a full
restful style routes for for that
particular endpoint so you'll have an
index a show a update destroy etc
there's also obviously the non really
restful ones which is like edit and knew
what those are obviously necessary and
then we can also we passed a block here
then we can also nest resources
and other so the router actually
leverages pattern matching so these here
end up getting compiled into this here
these are just the function heads so we
at compile time you end up getting all
these function definitions generated for
you and then at runtime the beam takes
over and does what it does best and
actually just pattern matches on the
result on the request and just the right
thing so it's incredibly efficient most
other frameworks obviously like trying
to use like regular expression natural
and all kind of stuff it's a lot sloped
so they spend thirty percent of their
time trying to figure out where we need
to route the request how to say
Phoenix's fast so something like this
this flash ends up here's the full full
function definition we take the Conn
pipe it through a couple of plug
functions put Tings pipe lines and the
route which is a function anonymous
function
the controller and then we pipe this to
functional browser and I'll explain that
later on how that works the router also
has mixed tasks so you can't say we sell
routes and it will generate a big list
of all of the routes that are finding
for application the ones on the left
here are the helpers this is names
reverb there's no pattern of the route
look like and then module little handle
it and the function that will coach so
pipelines pipelines group functions
together and to handle common tasks so
this is kind of familiar most of us in
programming we have functions that take
you know we have this thing that we pass
in the detest or like get to read it
inside out backwards so it's not very
friendly inner line you kind of dude
this have a thing where you have these
temporary variables that you have to
pass around which is okay because if you
end up removing or adding anything here
and got to find all the pieces changed
all that but really what we want is
something kind of like this where you
could just type output one function into
the input of the next and so with Hanks
we have the pipe operator so you end up
with something like this give the
connection I'd through the endpoint pipe
that to the router custom controller and
then we end up sending the response so
yeah I mean really that's all you're
doing it in web development we get a big
giant screen from the from the request
we parse it out we do some stuff with it
and then we end up at the end turning it
back into a string to sent to the client
and so this is just that function pipe
so right routers also have pipelines and
so we can define a pipeline here like
this and pipeline is just a plug but it
allows to define other plugs within it
so
and say what accepts and this will
ensure that it sets up the ability to
handle HTML requests or even have JSON
plug fetch session will fetch the
session from the connection as that is a
vegetable field you can't have access to
it until you action fetch it so we fetch
the session fetch flash which is
messages that you can put in the session
so if you want to display a one-time
kind of message to user we also have
some other things which are useful for
protecting submission form submissions
and putting other secure browser
Henderson so to use it pipeline you in
your scope you can just say pipe through
and give it the name of a pipeline that
you want to buy food and this can be a
list of pipelines so you can have the
browser pipeline and then you can also
have like if it's an admin in scope you
can also have like an admin pipeline
that will automatically check to make
sure that the current user of the city
that signed in is actually an admin and
do some things like that so generators
this is a very useful tool especially
when you're learning you can generate
different scaffolding for your
applications to get up and running
really quickly and you have several
different generators here we have 14
channels we have gin gin HTML which will
generate files for an HTML based
resource it will provide you with
templates and the ability to create
forms and all kind of stuff and we also
have JSON or just to giving an API it
will open wake some of the other files
we have generation for models which will
be our modules that
interact the database they hold the
database schema and all that stuff so we
wanted to generate a post resource for
creating blog which is stupid but you
know it's a good example so mix gin HTML
you give it the name of the model which
in this case we can post you give it the
generalized version which would be the
name of the table and also generally
your your route endpoint and you give it
some attributes so we have a title the
default value of any attribute is a
string so we don't have to specify here
but the body is a text title so we say
colon text that will end up generating
all these files for us and then we have
some steps for the user to add resources
to the router so we do that plug that in
there Robert then we're on the migration
sit mix active on my grave which will go
ahead and create the table in the
database and have columns and all good
stuff and then if you visit / posts on
your application you'll see this page
automatically for you you click the new
post button you get a form you try to
submit the form without putting anything
in and get validation errors and you can
fill stuff out correctly and submit it
you automatically get from its basic
create read update destroy all automatic
for you and we get some buttons here for
showing
resource editing so controllers which is
our third and final plug basically here
controllers also have pipelines as well
we can plug other foot plugs in and
those will happen before or hitting
these actual index for these actions as
we call and one note here is that this
this we actually have a macro that
allows you to add a guard to each plugs
so you can plug it only win the action
which is the function that's going to be
dispatched to is in this list here so
create an update so this scrub params
ensures that if a form is submitted that
if it's submitted with blank values that
those blank values it turned into null
values and so that way you can do it
works well with the data validations and
the bottle so explaining all the actions
here we have the index which you would
do get a hint to slash posts which will
list out all of the posts so we're just
reading rating all postal the database
and then we're rendering this is for
showing a single action you can do
pattern matching on the route params so
we get an ID from the from URL which
will then pattern a chair in the Rams
and loves for a very nice
of your route params the new we won't
get into a de facto stuff which is the
database which is all this change set
stuff there's just too much information
to cover in this short period of time so
but this is basically I enjoy it's
really simple and all this code is
what's generated for you so if you run
these commands to follow the slides and
afterwards you can see almost
regenerative and similarly this is the
Edit update and the delete action so
views and temperance we have some
frameworks kind of like combining where
I can ruby-on-rails for instance of view
is your temple and they have separate
modules and stuff for four helpers and
stuff like that and we've actually
separated them out of you is responsible
for rendering and template and a view
also provides helper functions for using
templates it also is what is Nick
spinning so fast renderings beats
because the templates are actually
compiled into function calls so if you
create a template at a specific path at
compile time that that string gets
created into the function call that will
work for that very fast so so this is a
view we have a post view we can say we
want some helper functions for like
showing the title we want to chase the
title it's a bad example but
we can pass in the struts that the model
is a post model if you get here and then
you just match on the title and Casey we
also have render like if you're
rendering JSON for instance render and
it's a sign you'll get a map of your
signs that are currently available and
post should be in there and we can
create a return of map and that map will
they need encoded into JSON so you can
else did it have these nice functions
called render mini which will take your
posts and it will call show that JSON on
this view viewmodel which will then be
this render function here so render
which will then actually take and you
can specify the keys and values of
market street so the cool thing about
this is it's very explicit and there's
no wondering about what am I rendering
what day am i render which is probably
probably pretty natural to most of you
in your functional program this is a
template so called eex which is embedded
elixir and it gives you you have regular
HTML in here but you also have these
tags which will evaluate elixir so this
is an example here of using the title
helper function that we provided in the
view file and we're just passing into
post which will then use the
post-op time to render it out with a
string so the last thing we'll talk
about as a chance channels alliance with
route hub sub events to channel and
handlers in your application so my
default Phoenix provides support for
both web socket and long pole and any
it's actually pretty extensible you can
create adapt you can create your own
transport routes for everything so I'm
going to transport or XMPP or Co app or
any of these other protocols very easy
to do that we there's there's several
other things that they belong hex p.m.
or left rabbitmq for instance and so you
can handle all that we have the channels
are similar to controllers but they're x
direction so once you send the data to
the client in a tiny p2 and have you
shipped with Phoenix jas which is a
JavaScript client so to use some use
channels you can use the socket macro in
your endpoint and path and module that
will handle the socket and the socket
you can specify the channels so it's
kind of like namespaces and routing for
channel data so we say rubes colon star
which the wild card so you think that's
sent to a channel that has this prefix
will automatically build and be handled
by the room channel you can plug your
your transports so this one supports
both web socket and long falling baby
and we provide a connect function and
there's also a TV vegging can reference
later so in this case when you're
connecting you can do some validations
to make sure that the user is
authenticated and it's done episode in
return the socket you're good to go
channel you can also ensure that people
can actually are authorizing a
particular channel different data and
handle here so there's a joint function
which takes the channel name and this
would be like groom's mom me or have
multiple join clauses as well for
different different rooms for instance
then will receive the message and socket
use need to return okay socket you've
got also handle in handle info sorry
which will handle messages that are sent
to it directly so this is just all OTP
stuff so in here enjoying we're sending
ourselves and after join message so that
we can actually
set up it's just broadcasts on the
socket these are injured so somebody's
joining you can broadcast out to
everyone say hey listen joining and
other things like ping handle and then
we also have handle in so handled in
there's also a hand out which will allow
you to filter messages and stuff like
that handling it's an event so a new
message takes them it's the message in
the socket and then of course you can
handle that by broadcasting apply or
swimming so Phoenix Jas this is
essentially how to use it um this is all
es6 or GS 2015 whatever name they
finally finalized on the input socket
from phoenix and then you would say let
sake you suck it give it the route path
which is what we set up in the end point
you can set up logging and stuff like
that on there as well then you can
connect with the socket give it some
parameters for your connection you can
also do tokens and things like that we
have a phoenix about token which allow
you to ensure that the person that's
trying to authenticate is supposed to be
able to with the socket you can create a
channel and with that channel we can
join and Chris McCord has done some nice
things to to give this JavaScript some
like kind of pattern matching results
here so we're saying receive and
sea glass shatters ignore console.log
some stuff if you're receiving okay good
go and then there's the after which will
handle tiles you can also set up air air
handlers on the channel and stuff that
happens and then pushing a message you
can use channel don't push give it the
event name and the payload so we'd like
something like user and then the body
and then handling channel incoming
messages on the channel is very similar
here so when you receive a new message
then we will see that and then do
something with the dog or whatever so so
that is that is pretty much it we have
some really great guides if you go to
Phoenix print morgue I I imagine that
the guides are so good that didn't want
to sign up for three day Phoenix
workshop so yeah so
one question boo boo rock you it is it
possible to override generators for
example generator fiction about
generating less using filters out I want
to give me over yes yes again you can
actually add your own templates within
your product and you can actually use
your own custom templates anchors I
think there's probably some guides on
okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>