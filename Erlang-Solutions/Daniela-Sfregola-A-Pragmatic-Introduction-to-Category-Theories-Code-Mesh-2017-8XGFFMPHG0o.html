<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Daniela Sfregola  - A Pragmatic Introduction to Category Theories - Code Mesh 2017 | Coder Coacher - Coaching Coders</title><meta content="Daniela Sfregola  - A Pragmatic Introduction to Category Theories - Code Mesh 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Daniela Sfregola  - A Pragmatic Introduction to Category Theories - Code Mesh 2017</b></h2><h5 class="post__date">2018-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/8XGFFMPHG0o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi guys I'm Daniela this is gonna be a
fun talk I do apologize if you guys were
expecting a mathematical introduction to
category theory this is not it so we're
gonna have fun there's gonna be code
because I'm not a mathematician I code
for living and that's what I love
don't worry too much about the code it's
gonna be online try to follow the
journey that we are gonna have but first
a quick question who has done or he's
able to read a little bit of Scala code
okay cool perfect
most everybody cool this is not gonna be
a disaster then awesome so um so why am
I talking about this stuff so when I was
a uni functional programming wasn't
popular at all it did exist but nobody
was talking about it
there was a course in lambda calculus
but the teacher was kind of traffic
raiding it was optional I didn't take it
so when I started my career
object-oriented programming was the
answer there was nothing else out there
and Dru was Ganga for know all the
patterns by heart and that's a right and
then I start doing Scala and functional
programming in general and I would say
with stuff so I really wish I was a
mathematician but I'm not right and I
say that in a good way right because
every time I have functional programming
right but every time I go to a
conference or I took two people they
forbade me some terms and I'm like okay
so the initial impact is quite tough but
the good news is like
it's better right so because of my
background and I will assume the back
it's the same background of many of you
guys when I see a formula it's fine but
I don't get it
I will look at it again and I will
probably still not get it and maybe I
like the fourth or fifth time I will
finally get it but that's not how my
brain works my brain first looks for a
metaphor it's just how I have been
trying to think of so I'm gonna give you
my view on category theory and why it's
super cool for us programmers and I'm
gonna try to explain all these concepts
in a way that I believe it's
understandable for a programmer okay so
but first of all are you a little bit
this little disclaimer
you don't need category theory to break
a code right you can see right really
good programs without knowing anything
about category theory and also you don't
need to knock the great theory to break
functional programming functional
programming is kind of simple
don't use mutability and use P functions
right you don't need to know the inside
out of category theory to do that so why
am I here because it's cool and when I
finally understood it was awesome so I
managed to understand why we were
structuring things the way we were and I
believe that my code got better so
that's what I hope I'm gonna show you
today is that by understanding what's
behind our code can be better than just
using the tools so the first thing that
I would like to talk to you about is why
do we care about category theory right
and the first question is how do we
reason right because
we we have a brain how does our brain
works our brain is is like a machine
right and that is exactly what
programming is right teaching a machine
to do something so for example right you
guys probably took the chip this morning
so I took for example the district line
so I knew that I had to go to the
station and then take the district line
that exit and so on and so forth
but what I was doing that I wasn't
thinking about okay I'm gonna contract
my muscles and move my feet because I
have to walk that right so even the
human brain basically does two operation
the first one is splitting the task into
smaller tasks and the second one is to
abstract out all the things that don't
matter because we know how to work right
we need to think about it and there is
exactly what category theory does right
so category theory doesn't care about
the objects only cares about the
interactions between objects in the
specific is the study of how things
compose okay and category theory it's a
scary term so if you don't really like
category theory you could call it our
theory right and that's it
you are gonna summarize that arrows are
the thing that we always talk about we
never talk about the objects okay but
nice to simple
so what's a category that is a category
so octillery is two objects what are
objects of comment on that in a second
and something let's call it Harrow that
connects two objects so we have a clear
definition of an arrow but what is an
object don't know it could be anything
it could be a chair it could be a type
but it could be a person it could be a
flower mathematicians are really vague
on what an object is
is because they have to do a way tougher
job than we have as programmers but we
know that most of the time when we
programmers we use category theory most
of the time the objects are types and
the arrows are functions okay and we
have a few rules that will will drive
our game the first rule is composition
it means that if I have an arrow that
goes from A to B and then I have an
arrow that goes from G from B to C then
I know I can automatically create and
you are that is called G after F okay
everybody with me so far
yes cool and then the other law is that
there is an identity law identity law
means it's an arrow that stars and
return at the same point okay and
obviously when we compose it it doesn't
it doesn't really change the result and
the final law of our game is my favorite
one is associativity not gonna read the
formula you guys can read it by yourself
but basically what it means is that the
black path and the green path are
equivalent okay really practical terms
you guys see that we have parentheses
these little basically tell us that we
don't care about the parentheses
why don't we care about parentheses
because we have better things to do with
our life right a lot of complexity in
this way goes away right we are
abstracting out with things that don't
matter so again this is our game we're
gonna see it over and over again and
believe it this is all there is to know
about category theory you have a
category and a
I agree it's something that has an
identity composition and associativity
laws okay cool so this is something that
we do all the time as programmers right
we don't call it category but we know
what it is so for example we can define
a function that is called size that goes
from a string to an end and then we call
define a function bigger than two that
goes from a mean to a bull and we know
that we can combine those two to create
a new function that is called size
bigger than two okay and obviously the
same is for identity we can define a
function that basically does not fit so
let's start a little bit talking about
interesting bits so the simplest
categories that you probably guys can
think of is the category with only one
object so again the rules are identity
composition associativity and this is a
graph right nothing fancy is kind of
cute yeah and turns out the
mathematician don't call a category with
one object because it's too long
they call it mono it so you obviously
have rules that can be expressed in
mathematical formulas but hey we are
normative addition so for us rules are
just test that we can write okay so you
can it's intentionally small you guys
cannot probably read it but it is that
you can translate these mathematical
formulas in property based tests that
will basically guarantee that for every
implementation of a mono a that you
create the mathematicians will be happy
okay doesn't matter what they are right
they did all the proofs we trap
but let's see a little bit of a
practical example of why we care about
what Amano it is right so so let's
assume that we choose a definition of
composition for example we define that
composition is the operation sum and we
want to represent the arrows as integers
we can then pick an identity in our case
would be a zero right so the identity
law is respected because no matter what
we do with the arrow zero when we
compose it with another arrow we still
going to receive the same arrow back and
composition is the way we can create new
arrows so for example let's assume I
want to create a new our own and let's
call these our or for what I could do is
take our rule free take care of one
compose them together and what up
I haven't URL let's assume I want to do
it with five right we're going to take
the arrow for an ro1 and compose them
together so this is a really simple
representation and all the possible
natural numbers that we can have in our
program and this cool but we like to
express this in code right that's what
we are interested in so in scala we have
the concept of type class it's just the
contract saying that if you want your
type to be called in this case mono it
you need to show me how to do this so we
said that am honor it has an identity
that is just a value and it has the
ability of composing things together in
this case means that giving two
instances of my type I can produce one
okay this is normal Scala code that you
would write every day
you're not using any rocket science
feature of the language and you can
probably do that in other languages as
well I know you can do in JavaScript so
it must be must be possible in many
others so this is an example of an
implementation of a mano it for end
where compose is just the operation sum
and the identity is the integer 0 we can
obviously do that for many types
another example is for example string
where you can take the composition has
the concatenation of strings and the
identity has the empty string
ok everybody with me so far
cool and now let's start with the funny
bit oh and I love this first category
with one object right
with more than one object so far we have
seen mono it is category with only one
object but obviously things are a little
bit more complex at that what happens if
you have more than one object so for
example this is a category with two
objects a flower and a triangle and we
have arrows between term and we have
identity errors right but what happens
if we put them in a box you guys
probably have seen these little magic
toys that we receive in the welcome pack
basically that's it so you take your
flower and you put it in this little box
you take your triangle and you put it in
this little box and you map the arrows
that you're having the original category
into the new category that you just
created right and exactly like these
toys you can look inside but you cannot
open them you can change the content
somehow but that's all you can do so how
would you represent this again we need
to represent two concepts the idea of
putting the original objects into a box
whatever the means and so we need to map
all they are
of the original category into the new
category another way of looking at this
is saying I'm gonna add some context to
my original category meaning that okay I
have my data but now I want to give you
some extra information about my data for
example box could be be careful the data
Meyer might not be there or you know I
could give you zero more examples of
this data or this data could explode any
second right and in Scala we do this all
the time so we have option that in our
analogy will be a box that my or minor
contains value we have list than my
contain zero more values we have tried
that it's something terrible the first
exceptions we have future that it's a
box that is going to take a while to be
completed and so on and so forth
but you know mathematicians they don't
call it category in a box they call it
factor and as usual we have rules
notice the rules are always the same
identity composition associativity the
formulas get a little bit more complex
but I think we can still manage so what
I've done is there a code spit all those
formulas and I have translating them in
property based testing where the tests
will verify that the laws are respected
okay but if you wish you could see this
problem from a different angle you can
see well if I know how to transform a
flower into a triangle
and I have a box of a flower then I must
know how to transform the box of a
flower into a box of a triangle because
that that's the law right otherwise it
wouldn't work right but the magician's
told it is possible and again what a
functional programmer does is just ask
for an implementation with a type class
and that is exactly it so you can define
a type class functor has a function map
that takes a box of a and a function
that transform an a into a be another
way of looking at this is that I have my
little toy I just need to transform the
content of my toy without opening so I'm
basically in the pile applying the
function inside of my toy okay cool and
to show you that this is possible with
many many languages that have a decent
type system I'm not gonna use the
standard option type that we have in
Scala
I'm parented my own so this is just an
algebraic data type you just say that
maybe is something that has two possible
statuses either has some value just with
the value or is empty if you guys are
familiar with our school
this is stolen from you basically if you
are familiar with Scala is just a sum of
a value or not okay it's just to prove
that I'm not using any crazy feature of
the language and this is an example of
an implementation for maybe the idea is
that I have my box and I say if I have
an object if I have a value inside my
box there's great I just apply the
function to the value that I found in my
box if my box is empty sorry bro
nothing I can do I'm just gonna return
the box as it is okay
that's a functor in category theory okay
but let's do something a little bit
trickier what about this situation right
because ideally we can put whatever we
want in a box right so we have a feeling
that this could be solved right because
we have all the elements but remember
the only thing that we know how to do so
far is how to apply a function into a
box and these kind of situations where
you have two boxes that are independent
and needs to be somehow combined
together mathematicians called call it
applicative so it's two boxes that are
completely independent and for some
reason we want to put them together and
we have a few rules a little bit more
than before
but the three amigos are their identity
associativity composition so all good
and salmon's before no need to worry too
much about the details it is possible to
translate all these formulas into tests
to make sure that we see respect the
rules of our game so basically what we
want to express now is the idea of
combining values together there are in
the box and the idea of once we have our
result to put it in a new box and what
our functional lazy programmer would do
try plus so this is the definition of
applicative in scala so you have a
function that is pure that is just puts
the value into my container
and then you have a function AP that
basically combines the two boxes
together notice that I am extending
functor in terms of Scala that means
that every applicative is also a functor
and i can do that because if i have pure
and if I have a P I can implement map in
terms of AP and pure okay but life is
not it's not it's not so simple right so
what happens if instead of having a
function that goes from A to B I have a
function that takes two parameters right
well what do you do in this case I'm not
talking about two boxes anymore I'm
talking about three boxes and
unfortunately in Scala that's the
solution so you create 22 functions call
AP AP to AP three maybe four maybe five
maybe six up to 22 to resolve these kind
of problems unfortunately that's a
limitation of the Scala compiler and
this is an example of a working
implementation for our container may be
so pure it's just a constructor so we
just say just a and for ap the idea is
that you want to see what's inside the
boxes if both the boxes contain the
values awesome smash them together apply
the function and there you go you have
you have what you're looking for but if
any of them is empty or both of them are
empty sorry bro nothing we can do so we
just return the empty box okay
everybody with me so far cool and now
the really cool moment box in a box what
happens if that happens right so we we
have seen what map is is the idea of
changing the
side of a box the what happens if the
function that I use to to change the
content of my box returns the box itself
I would end up with that crazy fact that
it's a box in a box so so far the things
that we can do is create a new box
you take the content of a box and
smashing things together two independent
boxes together we don't know how to
squash the boxes like fuse the boxes
together so this is basically a new
problem that we need to solve so how can
we move from two little boxes like this
to just one box and believe it or not
taking with a pinch of salt so if you
are a mathematician that I know I'm
sorry but this is basically the concept
of Amanat mourneth is just fusing boxes
together and that's a right that that is
all okay so you have a set of rules
again same as before because we are
still taking the power categories so you
have identity composition associativity
and we can verify those rules by just
writing tests okay and we are functional
programmers so we are lazy boom how
would you solve the problem okay now you
have a type class that is called monad
that has a new function that is called
flatten it basically tells me how to
solve my problem there is how do I
transform a box of a box of an A into a
box way and because this operation of
flooding is fairly common in Scala we
have an alias that we call it top
it basically means do a map first and
then do a certain okay that's a so for
me it's really weird because before
studying category theory I thought that
Monod was well that that's gonna be the
awesome bit to learn but actually it
turns out that the the interesting base
is actually the factor the idea of
saying okay I'm adding metadata on top
of my data that's really cool
fusing boxes yes is cool but you know it
it's not that cool but why do we
programmer care so much about monads
that's why so this is just again what
happens if you apply a math up my
piece map and then you do a flattened
basically through a flat map you can
move through a box away to a box of B
and from box of being you can move to a
box of see basically what a moment allow
us to do is to sequence operation in the
same context so there is extremely
useful because if you can think of a
program it's probably we are going to
imagine it as a list of things to do
like step one to this step two to that
and so on and so forth so is the idea of
sequential sequential ax T putting
things in a sequence okay and if you
know a little bit of Scala that reminds
us of a for comprehension when we learn
Scala they just show it they show us
that constructor and they just say don't
worry it works it's cool it's thick
sugar don't worry but they don't tell us
hey that works because we are working
with monads okay but we do that all the
time it's like less than two
overlearning Scala okay
but turns out that mana is a little bit
more than a functor so if you shuffle
things around a little bit and if you
are into ASCO you probably you probably
know the fine of shuffling things around
so the ASCO community initially
implemented model has functor but then
afterward they realized that it was an
applicative so if you are willing to
change the functions that you leave as
undefined so if you are willing to have
pure undefined and flat and undefined
you can implement all the other
functions using those two and that is
super powerful because it means that
every Monat is also an applicative so
this is an example of a monad for maybe
so pure is the same of what we have seen
before so it's just the putting a value
in the box so it's just just away and
flatmap
is okay so if I have if I have my
container contain something then I'm
just gonna take the value and apply the
function remember the function returns a
box itself right so easy peasy and if I
don't have a value to apply sorry there
is nothing I can do with it okay
so we are almost there so a little note
to explain the difference between
functor and endo functor right so we
have seen DDO functor has a way of
mapping between one category into a new
one so you can see the flowers and
triangle that they're a bit as a
category that is usually called the
source category
the box with the flower and the triangle
with the flower that's another category
that is called the target category but
if you think about it we are programmers
right so with our box all we are doing
is that we are mapping an object type
into an object type and functions are
still functions from types right so
turns out that programmers have a fairly
easy job compared to mathematicians and
every time a programmer talks about a
factory it actually took about endo
functors and the functors means that the
source category in the target category
are the same okay
and now the sentence that scares me for
like one year and a half
mouna dismal read in the category of egg
hunters
how many people have heard that okay
everybody so this sentence was the old
motivation of me starting styling
category theory because everybody was
very simple it's just a morning the
category of the and the factors and I
couldn't get why so there are two words
alighted in that sentence it's mono it
and the functor moderate we have cinema
is the idea where you have an identity
and then you have the ability of
squishing things together with a compose
so you give me two elements and I'll
give you one back and the factors it's
basically the same as functors for us
it's just the idea of changing the
content of my box without opening so if
you guys remember the definition of
Monnett was two functions pure and
flatmap
that map is just a combination of two
varies map and flatten so there you go
you have a mono it because you have the
identity that is pure and flatten that
is the idea of composing things together
and you have a new filter that is
because it has a map okay so that is if
you are a mathematician probably you are
gonna be screaming inside right now
forgive me but that's that's a
simplification but it's a good certain
point cool so what we have seen so far
our category theory is a mathematical
branch that study how things compose
what are things we don't know we don't
care
ma night is a category that contains
only one object and for us is extremely
useful because because allows us to
reduce things so it has the idea of
giving two things give me just one and
you probably have seen it around as a
way of reducing a data structure into a
single element like reduce the list into
maybe just an end okay and we have seen
functor functor is the idea of having
modifying certain values in two specific
contexts applicative is the idea of
having independent independent values
that are combined together in a context
and Monod is just a way of putting
things in a sequence okay so I'm gonna
scare you off a little bit we just
scratch the service so that is
the mapping of all the type classes that
we have in cats
there is one of the libraries that
implements all these principles and we
have covered four of them so there are a
lot of things that we still don't know
that we have to discover my latest
addition to my to understand list was
pro functor optics if you know what they
are
please come and find me and spring it to
me because it looks cool but I don't
know why yet but you are probably going
to be a little bit confused bombarded by
a lot of information if you have to
remember something about this
presentation remember that
so what category theory is trying to
tell us is forget about the details just
reason on how things compose that is the
only thing that matters and if you guys
want to know more those are the main
resources that are used while I was
starting with category theory the first
one it's a talk by fear water that I did
the lambda world it's the category
theory for the working occur it's really
cool it goes through wall algebra to
decide our product co-product partage
did a series of videos on category
theory there are new tube free to watch
they are awesome he also wrote a lot of
blog posts that the community has
decided to put in a PDF and the
community produced a book on it and they
are really really cool if you guys wanna
have a look at the the mapping of all
these have classes that we have in cats
that's the link but the first place
where I started to learn all of this was
in cast documentation there is
documentation of this library where they
provide really practical examples of how
to use all these concepts
so the slides are going to be online
from my Twitter account so is the code
so thank you very much for listening and
if you have any questions I'm here thank
you
do we have any questions don't be scared
I don't bite a question could be I'm
gonna explain you pro functor optics
later a lot yes yes sure so the question
is so models are for sequences
concurrences how do you express that in
category theory the way I would do it is
that I would just represent it with a
particular type of moment so yeah we've
honored
so am honored allows you so the question
is how does the sequence represent
represent concurrency so often what you
want to do with concurrency is to
represent things that are running
parallel so the idea is that I would
represent each process with a Monat and
then because am honored you can put it
in sequence I will just use a Mona oh my
god that's disturbance I'll show you
I'll show you an example of stage but it
is the Mona it is the most powerful
representation that you have of for side
effects so for example di opponent will
be a deal where you can represent
yourself effect and when you at some
point you need to
merge everything together you can use to
either do it sequentially or in parallel
but that doesn't answer your question so
all I have a chat with you off stage
during lunch and it's a little bit
complex but yeah awesome question
any other question nope okay thank you
very much guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>