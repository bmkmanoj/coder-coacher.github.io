<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building a Messaging and Service Protocol - Jeremy Ong | Coder Coacher - Coaching Coders</title><meta content="Building a Messaging and Service Protocol - Jeremy Ong - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building a Messaging and Service Protocol - Jeremy Ong</b></h2><h5 class="post__date">2013-05-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/e4xMop80Hkg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so the talk is a little different than
what's on the web like this actually
when I submitted the takut it ended up
morphing a lot as I approached this talk
so if you were confused a little bit
this is what the talk is it's called
building a real-time game back in from
scratch in particular how we use erling
and why and I work for court games
incorporated we're a small like game
studio startup based in cupertino so
pretty close to here my name is Jeremy a
little bit more about who i am i'm the
i'm you can find me a jemi wrong on
github some of you may know me by
panache tarski on IRC you know I hang
around power rolling and power lalage a
lot yeah some of you are waving let's
see okay so what are we doing at court
games we have a new real-time game
that's set to launch soon very soon in
fact it's real time is 3d we're
targeting the tablet at first although
we're interested in expanding this game
to you know go to other platforms to as
well this is the interesting thing we've
been in active development on this
particular game for about five months
with only three engineers so one of
which was a server engineer so you can
get an idea of already like you know how
how powerful erling has been in order to
get us from you know where we started
with just like a prototype and a bunch
of sketches on paper and stuff to you
know a game that's of what I think
really really high quality especially
considering our competitors and I'm
gonna be showcasing some really nice art
that the art team has put together for
us throughout the talk oh and we're also
starting to expand the team now as our
needs get more heavy as we approach
launch so loose game description what is
the game about what is it like
so actually before I go into this how
many of you guys play games at all or in
general just so I can get a gauge all
right so we have a bunch of gamers here
how many of you guys are familiar with
tactics games so tactics games an
example would be like final fantasy
tactics advance wars you know strategy
games that are played on a grid
typically and the canonical example is
chess like chess is a sort of an example
of a really old traditional taxi seem
right so we put a twist on the tactics
game and the twist is that people are
executing actions in real time so that's
an important thing to understand about
our back and infrastructure we're
supporting people talking over
persistent connection sending action
simultaneously and routing and doing all
that kind of stuff so what do what do
players do players by an upgrade units
there are going to be a lot of units so
there's a certain like CMS aspect to the
back end where we have to like manage
user accounts and manage user data then
of their army other the units that they
have they choose some of them and they
enter the matchmaking pool and then it
get matched up with other people and
this is how they interact they interact
by talking to each other or through
matchmaking or actually playing the game
or something like that and they interact
directly with the server to make
purchases modifying their inventory you
know typical stuff that you would expect
any game to require so why am i giving
this talk well part of the part of the
reason is because game programmers you
know typically come from a certain
culture of object-oriented programming
and rolling is you know slowly making
inroads into the gaming industry like
just yesterday I was talking to people
and now when I tell people that we're
using Erlang you know the response isn't
like oh you're using our laying and
you're in games like that's weird
usually the response is now Oh Erlang
seems to be really taking off in games
or I'm hearing that a lot more now so
part of this talk is to sort of help
bridge that gap of understanding the
other reason of course is that early
plays very nicely with games for
particular roles now that's very
important this talk is not supposed to
be
a erling is amazing like everyone should
use it because you know if you're
listening to this talk or you're
homeless Ning or you're here right now
chances are you already know a lot of
that and but you know we're interested
in talking about how to get started
let's say you're at the very start and
you're just like I want to build this
real-time system black you know and if
you already know this one interesting
thing that hopefully you'll take away
from this talk if you're already very
proficient at erling is just a different
way of thinking about erling or a
different way to help people who don't
use Erlang or don't use functional
programming understand what you're
talking about and why this is
potentially suitable for the application
so this is how the pitch normally goes
you know people say low latency stateful
share nothing all this stuff and people
at this point they usually sometimes
roll their eyes or if they're you know
they're a long time C++ programmer and
you're like yeah I have all the
performance I need in my c++ bag or my
seabag like why do I care about what it
is that you have to offer you know or
they just don't believe you let's do a
little possibility right there like
Erlang I'm sure it's great so I i take
the analogy a little a little further I
say imagine that your real time server
applications are nails another
programming language is our kind of like
this they give you a set of tools with
which to build your application right
and within their there is a hammer you
know and that is that is the thing that
they will use to you know build these
real-time server applications well what
is Erlang I don't think erling is a
loose collection of tools I think erling
is a nail gun and again like sometimes
if a person is a skeptic like myself
they'll be like like wife like why in
particular is that or they won't believe
you or they'll you know write you off
there are a few important things to
understand about this analogy though
which is that there are many wrong ways
to use a nail gun so if I just tell
somebody or let's say we have a bunch of
cavemen these are the C programmers
right I'm a see programmer so I like see
let's say the C programming are like
cavemen and they all are really
proficient with hammers and chisels or
their this programmers or whatever if
their list programmer and you want them
to hammer and nails they'll probably
take the hammer and chisel and build a
nail gun and then use the nail gun to
hammer and things right but if you gave
them a nail gun and they've never used a
nail gun they've never seen it before
they probably wouldn't plug it in or
charge it first they'd probably take the
thing look at it and then just start
whacking the nail with it like this
because they don't understand right
there's a the early model this is so
different than how you typically program
in the context that you're usually used
to that there's just they just don't get
it I guess and this part of this talk is
to try to help communicate you know why
it is wise or lang so suitable you know
and for the people who don't really get
it you know how do I get it and how do I
start using it okay so I was trying to
think of a lot of analogies for what an
erlang system is like and since we're at
the erling factory you know I said it's
actually very similar to a factory let's
use that and see see where that takes us
this Factory has a few peculiar
properties has cheap 24 7 min wage
workers you know that these cores
they're constantly working the scheduler
just constantly working it's very little
downtime right we have factory machines
right you can kind of already if for
those of you who know Erling a lot
they're already building that mental
model for yourself how this is working
and when these machines finish their job
we just throw them out or if they error
out we just throw them out and replace
them so this is kind of a weird factory
we have build orders warehouses that's
like the disc repairman blueprints and
well when I looked at this I was like
this is a very peculiar factory maybe
people won't quite get it if I show it
show it to them as a factory I think
it's more like this they're laying swap
shop so maybe after the talk we will
make a big petition we should have the
ER links wet shop 2014 next year okay so
how does analogy work well blueprints
and instruction manuals they're there
your code that's how you describe how
these running
processes work right all these run loops
and everything they're used to start
create and run these factory machines
and this is important if when i first
started programming early about a year
ago i didn't have that conceptual
understanding of the difference between
a module in a process because all the
examples out there you know they
typically have a very tight coupling
between the two of them so this is an
important distinction to make and the
machines of course are that are the
processes there are the things that do
work and one property of this Factory is
it's super easy to create new ones and
when they finish we just throw them out
like they've done their job already so
these are disposable machines I guess
they have conveyor belts right an
example machine that you can think of is
like the quiznos like sandwich creator
that's exactly what an erlang process is
you know just it's just waiting for you
to put like ingredients on the bread and
stuff and it'll go in it will do
something in this case heat it up and
then you get a sandwich on the other end
and it's sequential so the conveyor belt
really conveys that idea forward let's
look at an example we have this because
I'm a machine baby a function which is
just a receive block right and notice
that within the receive block when we
send it high it calls a different module
so like a different blueprint if you
will to execute functionality and
different module and I've got the keys
baby you know the difference here to get
us machine is that this is stoppable
it's not an unstoppable machine to
continue the National even further we
have sweat shop floor space right we
can't have as many machines as we want
at any given point in time we have
repairman they fix your broken machines
and the way they fix them is why their
repairman is they just throw them out
create new ones and the workers now this
is where it gets a little interesting
and people start losing the mental model
or losing the grasp of how it is that
erling works right so you have a
scheduler
and all he does is he just runs around
to the different machines and you just
flip switches right and there the
scheduler like these guys run around a
lot right there never focused on like
one machine at a time they don't wait
for that machine to finish before they
go on so I think Vernon gave a talk
about how this worked and some other
people gave a talk about how this work
but the scheduler I think is one of the
things that really sets erling apart
from other languages and if you're just
coding a project enrolling for the first
time without really understanding this a
lot of things can potentially go wrong
in the way that you structure your code
so I think of them as hopped up
sweatshop workers you know they just
they are really plagued with age ADHD
and all sorts of you know like they just
can't concentrate on one thing at a time
but for Erling or for our applications
real-time like users serving serving
applications this is exactly what we
want and I'll go into this little bit
more later oh of course we have power
right the machines require power another
thing people who take their OS class or
whatever in in their computer science
degree they know that you can only power
one machine procore at a time right and
it's up to the these workers to go
around and just unplug and plug in power
to designate where the work should go
and or link doesn't discriminate every
machine is going to get the same waiting
and how how much wattage they get I
guess and inner links case they get
exactly 2,000 watts or 2,000 reductions
and then they unplug it and go to the
next guy right so given this analogy or
this mental model if I was to build a
game back in from scratch you know how
would I start thinking about it or how
would I approach this problem well
obviously the first thing you have to do
is like specify what our requirements
are what is this thing actually trying
to do right this is so far the same as
any other application and then it
immediately becomes different than the
C++ world or the you know the Java world
now we're trying to make sure we have if
we had to imagine like our system and
like there are different parts of the
system different work that
to be done I can think about how I would
subdivide that work among actual people
you know if I had manual labor at my
disposal and they had like pencil and
paper and they could compute these
things you know how would I split up my
job and of course this is how we split
up things into like separate processes
separate machines so we describe all
these occupations now again very
different from the normal case we try to
map with each up applica sorry
occupation we have up the OTP behavior
that really describes what we're trying
to do now if we can't define an OTP
behavior that makes sense of course we
have to like write our own right or not
write our own OTP behavior but write our
own behavior in general this is about
like the kind of machine it is is this
machine something that just sits around
and replies to request in which case
it's a gen server or does this machine
have many many states you know then it's
an FSM right but after you do all this
it writes itself essentially and this is
where I really found the expressive
power of Erlang useful for us and
getting the application out as quickly
as we did so I'm going to talk about
architecture so what does the back and
do it does all the things you would
expect and here's the interesting part
some of you guys may leave at this point
but we some of the game logic the game
simulation itself is powered by a
c-sharp runtime that's mono running in
UNIX part of the reason why the logic is
housed in a separate library is because
we want that logic to be shared between
the client and the server itself like we
need that shared component in case the
client actually needs to do something
predictive within the game itself or run
something in single-player mode you know
so it really helps to have that shared
dll that can be accessed from both
languages but Erling still does a lot of
hard heavy duty work which is all the
routing that happens in between the
player itself and the specific thread
within the specific runtime on the
specific machine that has to compute the
result of that player's actions
and of course we have to see what's
actually happening so performance
requirements so unlike a website when
when a user is interacting with a web
page right and a user clicks on the link
the user is ok with waiting like they're
not okay with waiting too long but
they're a little bit more okay with
waiting as opposed to if they were you
know tapping a button on an iPad
application when I tap that button the
user doesn't have that cognitive
understanding that this is not this is
not like a native application that isn't
interacting with the server somewhere so
we need those button responses to be
fast right the other thing about a user
playing a game is that typically they do
all their actions they do all their
stuff and then that are gone right all
their actions are pretty clumped up
throughout in like little short segments
throughout the day if they log on
multiple times in a day so response
times should be relatively load and
sensitive what this means is that if the
server gets more load or there are more
people interacting with the server I
don't want each user to start
experiencing more variable response
times now a lot of the mobile game
applications out there right now they're
built on a framework like rails or
Django or something like that where
they're just handling HTTP requests
right and what happens if a user has
like a very very hard to compute request
for whatever reason all the people
behind him in that execution mode they
timeout right or they they're stuck
waiting a really really long time
because whatever thread was handling
this queue just can't get rid of this
guy fast enough so we don't want that we
want every user to experience like you
know high quality connection so this
diagram here is like kind of the mother
diagram to explain what is actually
happening so on the left over here sorry
this isn't going to work oh there's
light this is like the iPad
we use cowboy so cowboy will spawn a
single process here the websocket
handler and the client will communicate
to the WebSocket handler using either
text or binary and afterwards the
WebSocket handler you know it talks to
any of these services down over here it
takes it modifies the state stores it
back in here the service also persists
the change to the database and this
stuff on the top that stuff is stuff
that interacts with the game runtime
itself so the stuff above the line is
very very involved and probably could be
like an entire talk in itself there's a
lot of multiplexing layers that happen
like each referee there on the top they
managed their game with whatever players
are connected with that referee so that
thing handles all the disconnects that
happen reconnects it buffers data that
should be sent to a disconnected player
all this work the referee then in turn
talks to this runtime interface and
there could be many of these and each
runtime interface maps to a specific
mono runtime or C sharp runtime
externally and that talks over TCP so a
lot of this talk will just be about the
stuff below the line which is how we do
this sort of state threading and
management because it's a little bit
more applicable for what most games are
and probably the stuff above the line if
you're writing your game it might look
just entirely different and also the
stuff at the top we've wrote fairly
recently so who's to say if it's like
the best way to do it so if you zoom in
to the bottom side this is what it looks
like the iPad sends some module function
and arguments the cowboy handler the
cowboy handler sends the state to some
module executing that function and it
returns the change state state Prime and
it flushes it out to the database
adapter so let's say we have this
factory model or the sweatshop model of
how our lang should work or earling
system should work in our head
so here's a simple exercise should this
module that execute this function be a
separate process or should it be just a
library module that this handler on the
Left calls right so this is an
interesting question and I think when I
started programming with Erlang I always
hear it's fast because it's asynchronous
it's fast cause it's asynchronous
everybody talks about deferring work or
just everything is asynchronous so part
of me was like oh yeah I should just
make this thing some separate process
that will just take these requests and
process them and then send back the
reply and then the user the cowboy
handler it's always free you know it's
completely freed up it never gets tied
up doing anything right of course this
turns out to be very bad this is not
what you want at all but if you don't
understand the scheduler you might not
understand why this is the case so yeah
not usually no you don't you don't
actually want that to be the case and
why well when a user execute an action
in a game or they perform some sort of
thing like they buy a unit or something
they don't usually want to do anything
else they're not multitasking they just
want to know that that thing work or not
before they go on to do other things
that's for the most part one example of
a something that isn't like that that
should be handled asynchronously as they
enter the matchmaking pool you know they
just click play and then they expect to
expectation is that now as a player
you're in the matchmaking pool you're
free to do other things and you're not
thinking about that anymore right but
for everything else you know everything
that where the user expects to reply you
want that to happen sequentially so the
principle here is to let the user
process do most of its work and this is
in an architecture where every user has
their own process with their own /
sistent connection so part of the reason
is to let the scheduler allocate
resources fairly so imagine we're all at
at a supermarket right we're all the
supermarket and one of the most
frustrating things for me when I go
grocery shopping is first that I'm
actually going grocery shopping but
let's say I get past that
and I'm there and I have as a bachelor
the four items that I want I don't know
what those four things are but there's a
guy in front of me with a huge carload
of items right now the right thing to do
there is obviously for the cashier to
say no no this person here with the four
items should come forward you know after
spending even though like just looking
at the other guy's card in the case
where we're always deferring work to
process these willy-nilly without
actually thinking about where the work
is actually being executed this would
kind of be like the guy in that with a
huge shopping cart he takes some of this
items and he hands them out to other
different people to to buy those items
does that make sense so what's going to
happen now is that the cashier who's
sitting there he's going to look at
everybody's cart and he's not gonna have
any idea of like how to actually make
sure that each particular user which is
currently mapped to a particular process
gets the same fair share of CPU time
right so by making sure that each user
process does its own work you know the
guy who wants to buy all this stuff or
do the expensive request on your web
server he has to he's going to wait a
little bit longer you know but all the
guys who have small requests they get
handled fairly because again the
scheduler the guy who's running around
the factory flipping on machines and
flipping them off he's doing them you
know exactly as he normally would right
the other reason is because if these
actions are important like they modify
data you have to think about how your
state is remains consistent right if the
work is being pushed around then you now
have to struggle with potential
conflicts like if one operation that
should depend on another one happens
before right but serializing this is the
easiest way to do it so as long as we
have the user process doing all the work
that modifies that users data it's
always going to be consistent you know
it's like a quorum in a database or
something the other reason is we can
isolate errors so if the user process
if the user sends some bad data do it
you want to be able to pin down who that
person was right consensus are if there
is an error it means that you know you
just got some garbage from somebody who
is either hacking your client or doing
something funnier is weird so you want
to know where that's coming from and you
want to let die you just want to
disconnect that user let them reconnect
if you want to he can retry but clearly
something is wrong but if you have a
central processing place where you're
deferring this work you can't do this as
easily you have to you have to do
certain things or you have to use a
try-catch god forbid right I try not to
use that at all if possible in meyerland
code I'm going to go into some other
architectural principles this is the
architect of the game it's not perform
operations in memory so in the
application that we have existing right
now we don't do this where it's a
stateless application and what I found
was that most of the day that you
transfer in the actual request itself is
very small it's just a good I just want
to do this action with these parameters
right and then the return message is
just yes you did it right or no you
didn't do it and most of the data was
HTTP headers you know it's like
kilobytes and kilobytes of HTTP headers
and it's just you're just wasting
bandwidth you're wasting time parsing it
so this is where the persistent
connection helps and the other thing is
that you don't want have to keep on
hitting the disk every single time
especially given that we know that the
user is going to have all of his actions
contained within a certain amount of
time instead of having the separate
caching layer just make your application
stateful just have the the state of that
user in memory for that the amount of
time that he's connected so we want to
use sessions we read runts write
multiple times I think this makes a lot
of sense there's no reason why I have to
repeat the work of this user who's
clearly doing actions you know very
rapid fire right now interact
with his application I don't want to
redo work the other thing is when you
perform operations in memory if you've
never written in a stateful application
before things get really messy and
there's a reason for that right the
reason is because when you operate in
memory and you need to persist a disk
you typically have to do everything
twice almost you can imagine if your if
your data is very structured on on the
disk or you have to go through some
complex querying pattern to write that
data you also have to do something
similar in order to write that in memory
so your code at the end of the day for
each of these functions it could just
look horrible like you're doing
everything twice in every single
function so before you go out and run
off and make your staple application
amazing you know make sure you think
about how how the transformation works
between your in-memory representation
and also what's what you're
representation is on disk and if you can
constrain that to a simple function or
something that can like either compute
some sort of difference or something
that will then write the the change set
to disk like that would be ideal right
ok the next architectural principle one
dirty model to find them to bind them
etc what I mean by this every single
foreign dependency if you can try to
make sure that there's a single entry
point to interact with that foreign
dependency and there are a number of
good reasons why this is and like you
know this is something that you'll get
if you're a C++ programmer when I
construct an object that interacts with
the database or something like that I
should send in the database adapter or
the connection to the database in the
constructor of that object because we
want to be able to test our code right
we want to make sure that we can write
unit tests for these functions even
though they interact with some dirty
source like a database but my unit tests
should not interact the database at all
the other reason is because it's easier
to swap them out your database isn't
working for you you want to use a
different database now well you only
have one place where you have to change
like just a few functions you know and
then you
or in the case of interacting with the
c-sharp runtime that's the other place
we have a foreign dependency right sock
like TCP isn't working for us we need to
switch to some other transport layer or
we want to use file descriptors now or
vice versa you know again you only have
one module you have to swap out or
modify so very very powerful to do this
and once you do do this it's good to
really take the time to actually mock
out that library otherwise like half the
reason why you're doing in the first
place is to kind of lost and this takes
effort unfortunately but it's good
practice it's totally worth it you
should do it in our case for we use mec
to mock most of the Erlang modules we
also have actually mocked the client and
the other end points too and we do that
using this web socket client that I
wrote next principle is to modernize
your servers so we try really hard when
we wrote our application to not make a
machine special unless it really really
made sense for that machine to be
special and it's pretty easy to go down
and be like oh yeah we're going to have
this machine which will talk to this
machine yadda yadda yadda yadda yadda
what happens is that you get into these
situations where in order for this
machine to start I need this machine
running and then for this machine to run
I have this and that and this dependency
tree becomes a deployment nightmare and
i'm a i'm a developer I'm not a oh I do
a lot of DevOps to which the sysadmin
stuff but it's not what I really want to
spend my time thinking about so if it
doesn't if you don't need this kind of
like topology just don't do it in our
case we run you know cowboy to spinal
these connections and we just run the
same Erlang release on every single
machine and right now except for the
database layer all the machines look the
same so scaling horizontally this since
she just run a simple script with
ansible or fabric or chef or puppet or
whatever your favorite thing is and
you're done it's also I'm sorry it's
also very easy to set up on a new
developers machines like these are the
things that developers don't really
think about like how do i scale my team
or how do I make it easy for a client
engineer to
the stack if you wanted to interact with
it right we have to think about these
things because those are the things that
will really slow us down in the long run
we also do this minimize cap in Murphy's
lawless exposure so cap for those of you
don't know it's just the theorem that
says you can only have two of the three
consistency availability and partition
tolerance in a distributed system so we
try not to make things distributed if we
can if we can help it right because if
it doesn't need to be distributed you're
not subject to these constraints
otherwise you have to start thinking
what am I sacrificing here am I
sacrificing the availability of some
component to certain subset of users in
the presence of a net split or whatever
right I don't have to deal with that if
I don't you know if I don't have to
Murphy's Law something's going to go
wrong with your setup simplify it as
much as possible coordination is hard we
know this another point early erling
supports hot swapping you know for those
of you don't know that's just where I
can take a running production machine
and swap code with it and I think we
should use it especially if you're in
the business of writing stateful
applications where your users are
actually physically connected to your
machines at a given time I read a bunch
of like there are a few articles I think
that are like yeah it's like curling is
hot swapping as a pain or whatever I
don't think so actually like I think
it's very doable it is a sloth of
documentation but there are tools out
there like rebar that make this a bit
easier and once you do set it up and
have the pipeline running changing code
which is a better experience for your
for your users in general especially if
they're like playing a game right now
they don't wanna be disconnected
randomly right just do it so given that
you're doing this let's suppose you're
already doing this of course we have to
test this right we have to make sure we
understand the implications of every
change and we have to automate because
this is this is a headache to do
manually so just take the time write the
script and you're done this is an
interesting one so if you come from like
object oriented world when you write a
function you tip
we provide that function with just
enough data for that function to do
whatever necessary work it needs to do
right so all those services that the
websocket handler interacts with there's
kind of like what I naturally gravitated
toward when i first started was you know
if i'm adding a unit i need to know like
the user's inventory and what unit he's
trying to add right but i don't think
this is necessary in early just past the
state variable and you'll see this in
all these OTP behaviors right it's just
the thread variable the state variable
gets threaded through the entire way
part of the reason is because one we
don't have to be worried about the
function that we're passing the state
into modifying all these crazy things by
some accident some weird crazy thing
where this pointer is now pointing to
nowhere and we get no reference
exceptions or whatever right because
earling gives us a mutability we can
trust the functions that we write and
other developers write a lot more than
we could in an object-oriented world the
other thing is that the person executing
this function should not have to know
how to take the user state in memory and
you know chop it up just to decide what
information to give the service and then
you know insert the response back in you
know because now now the work of doing
this this function that the or request
that the user had is split across
multiple pieces right ok so let's look
at an example so the key thing here is
that most applications you take a
request from the user and somehow you
have to map it into earling world right
you have to map it into some function or
another you have to call that function
and then you send a reply this is just
what literally every server application
does how do we do this well the the
request comes in as json right and we
just subtract some module function args
from it and we just call it it's
literally as simple as that that's how
the mapping works of course
this should scream like all sorts of
security problems to you because you're
like executing some crazy are arbitrary
code right so we've been an extract MFA
we have some thing to make sure that you
know the module is a safe module to call
and the function that we're calling
actually is a real function that's
exported to the user to run but this
mapping is super easy and extending the
API is also really easy so all the all
the functions look like this they have
some function name ad unit in this case
and they take two arguments the state
and then a list of arguments all of them
do that and why is this easy to wrap our
heads around or if we had a right new
functionality and provide more request
types to the user I mean kind of is has
to do with bone ads right like this is
in fact a monad you're lifting this
function up you're threading the state
through you're doing a bunch of
reductions and then you're binding the
result back so this is a standard
interface basically and it's very simple
interface that any developer can use and
look at this and be like I understand
what's happening here the other
principle is to make sure you
standardize your protocols so I think
MFA is really easy to use over the wire
people understand it this is for like
the things that need to be sent us text
or need to be readable in the log or
something like that and everything else
all the binary stuff use some sort of
serialization protocol and a lot of my
thunder got stolen by jose talk you know
this morning but this is really nice and
I'm a huge fan of like thrift protocol
buffers those kinds of services because
when I want to establish that contract
with the other person I just want to
hand them a single file here's a profile
you know what to do with it or you know
they gave me a profile profile I know
what to do with it protocol buffers for
those of you don't know it's just like a
standard way of describing messages over
a wire and there are a number of
libraries out there erling is one of
them that provides the way of
translating that profile to native
erling records which then you can use in
code
and yeah for interoperability like
talking between erling and c-sharp
erling with whatever I really like this
so some tips for building an erlang
system this is actually all okay this is
all contained on the next slide the only
purpose of this is to make some cheesy
pun about spear tips so here are the
tips do the right thing and the sub
front that parenthetical expression here
is to actually do them because x
developers we all know that something is
good to do but we don't actually do them
for one reason or another benchmark
benchmarking is really challenging
actually and I'm still trying to work
out how are the best way to do this is
right now the way we benchmark is we
just kind of record a game and then we
just replay it across many many
different processes calling calling this
other remote server or something this is
hard because one what we're trying to
benchmark is stateful meaning that the
state of the user actually matters and
also it's hard because if we change the
logic now the game that we've recorded
might not be useful anymore so we're
still thinking about this but it's
important to do log tests actually use
your tests one thing we find is that we
write our tests but we don't actually
call them and if and then we push the
code and then later on we were like oh
we actually broke all sorts of
functionality so the key here is to make
it make it so that your test run very
quickly if your test run fast you'll run
them more often you'll catch bugs faster
but for the system tests the slow
running tests make that like a separate
script or some things then you can call
that on a nightly or an hourly basis is
supposed to every single time you change
code document type spec coming from C
and Haskell and C++ to Erlang was kind
of scary for me because I'm missing the
safety net of this static type checker
so dialyzers saved my behind many times
now definitely use that and just to
shout out to a bunch of the libraries
that we use some of which we've either
contributed to or wrote those are
started with an asterisks
yeah and so in conclusion when you're
designing your applications think like a
ruthless sweat shop owner like it really
helps to have that mental model of how
these machines work and conveyor belts
or whatever it is that you need to
correctly utilize the contracts that
erling provides you and I really do
think of erling as like a DSL for
writing these real-time server
applications you know also if you're the
one erlanger at your company you're like
one of three erlanger is at your company
feel free to like teach other people
what's going on I think a lot of times
we just kind of say hey erling is great
but that's kind of where it stops but it
is a really a different way of thinking
so try to communicate that out and of
course the last thing is don't do these
things literally we don't condone you
know sweatshop ownership and that's it
thanks other
yeah mm-hmm yep
yep you have to learn how to use the
code upgrade function right that's so
those kinds of changes aren't taking
very lightly obviously that's why test
test test is you know very strongly
emphasized there because you are playing
with fire in a sense right for the most
part when you're when we're utilizing
hot code upgrades or something that's to
like fix something that's broken another
one way you could do it is just too if
they're not in a game right and you're
not changing like game functionality
then you can just kick the user if you
want right if the game if they're
already in a game you saw that it's
talking like one version of the game
runtime right we can actually let those
games finish and then drain that
particular runtime and spin up a new
runtime with the new version so that new
people entering in the game talk to the
new runtime so that way you can kind of
like tie over the problems a little bit
better but yes you do have to think
about it but for us I think it's worth
it because you know the user is really
the most important thing at the end of
the day yeah thanks
so personally I use something I call a
library called set up first wrote two
scripts and stuff like that and i also
have a function there that allows you to
reload an application and it will
actually generate an upgrade script on
the fly and evaluate that so it follows
all the code change procedures but it's
it's just a sort of a quick way we use
it to reload and upgrade
oh yeah yeah I mean they're set up I
know rebar supports that as well you can
do it yourself too with you know rel
tool or you know if you were ambitious
but yeah those all those all those
layers of code that you know right
exactly you don't want developers
mucking around with that sort of stuff
yeah excellent cool sure sure so the
question was like how do we handle
security you know users are malicious
users and they'll do all sorts of nasty
things we've had the hope they run the
whole gamut on our other games you know
users doing bad things so the first
thing is users actually authenticate so
the websocket handler itself is a mini
finite state machine it has two states
pending authentication and authenticated
and before the user is actually
authenticated you know they can't do
anything also within the extract MFA
function if we get something we don't
like we that like an exception gets
generated that process just dies so the
user would have to reconnect again we
also use we also use SSL so people can't
that usually like reverse engineering
thing we have control over the client so
be a little bit hard for them to
actually be able to spoof real requests
to us that actually makes sense or maybe
as a company hopefully we won't we're
not too valuable enough that somebody
that was sufficiently motivated would
actually go through all these steps do
it and later if we did get bigger so
that those people cropped up we would
just throw more money at the solution
probably but
it's good question thanks a lot so one
last thing I wanted to mention our game
is about to launch soon so if you like
games and you want to try playing a
real-time game that's built on Erlang
and C sharp and stuff feel free to fill
out this survey if you have an iPad 2 or
later we'll just we'll send you a binary
and then you can stall and try playing
against other people and of course we're
hiring like you the talk would be a Miss
without that point so if you're
interested in working on Erlang or
you're working on games in general feel
free to email me or talk to me all right
thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>