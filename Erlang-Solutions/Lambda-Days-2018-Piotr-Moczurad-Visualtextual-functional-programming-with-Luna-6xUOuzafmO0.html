<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2018 - Piotr Moczurad - Visual-textual functional programming with Luna | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2018 - Piotr Moczurad - Visual-textual functional programming with Luna - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2018 - Piotr Moczurad - Visual-textual functional programming with Luna</b></h2><h5 class="post__date">2018-03-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6xUOuzafmO0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for coming and I am aware that
this is right before the lunch so I'm
trying not to starve you I mean Luna may
be many things but you cannot eat it yet
so if you're interested in fetching the
slides for your computer here's the link
here the QR code so very quickly what
I'm going to talk about first I am going
to outline the problems in software
development as we see them and this is
not going to be anything new or
surprising but still this provides us
with a nice background for you know next
I'm going to show you the the visual
textual programming using Luna as the
example next we'll see a bit of a
technical overview of Luna as the
language and then some of the lessons we
learned while implementing Luna in
Haskell and lastly I'm gonna tell you
about the state that the project is in
currently
okay so let's dive right in
so as you know we ask the humanity are
producing huge amounts of data and the
rate at which we are producing the data
is constantly growing I have attached
this this chart which shows the size of
the data and zettabyte that we produce
and this looks like an exponential
growth right so to pack this intuition
up I have a fun yet not really
scientific fact so in years 2014 and
2015 we have produced more data than in
all the previous years combined right so
this this is the exponent ality and
better better still in 2015 we were only
able to process around 0.5% of the data
so that's a lot of unharvested potential
for you
but this all leads to to creation of
lots of programs lots of software and
what was worth the software is becoming
increasingly increasingly complex this
is something that we heard about in the
fantastic keynote today so so this this
growing complexity is a problem as the
programs are becoming harder to
to comprehend and actually I'll risk
saying that right now we have trouble
understanding some of our creations and
if you want a simple example look at the
meltdown inspector bugs we've got the
processors which are insanely complex
and yet we were taking them 100% for
granted right they just work and then
they turned out to have a massive hole
inside that's causing losses right now
so to help us deal with the complexity
we are using we are using tools but
there's a problem so the tools
themselves are quite complex and they
require learning they incur some
cognitive cost and when you're
programming there's there's yet another
problem so when looking at the code it's
really hard to tell apart the layers of
abstraction it's it's really hard to say
what the implementation detail and
what's the actual merit of the business
logic so I think you can raise your hand
if you have ever refactored your code to
make it look nicer and then that ended
up messing business logic great yeah
that's that's kind of my point and to
mitigate this a bit we are drawing
diagrams but I don't know anyone who
likes drawing diagrams and this is a
burden and this is something that feels
like it could be done by a compiler
maybe automated okay the next problem is
that the programmers in most of the
industrial settings are serving as
translators from the domain knowledge
that the domain experts possess into the
code right so the programmers wouldn't
like to learn as much about the domain
of the problem as they need to and the
domain experts wouldn't like to really
learn programming if they don't have to
but we have this huge communication
barrier because when you think about the
operation of a software venture there's
programmers speaking code
project people speaking the language of
the product there's business people
speaking money so they cannot really
communicate easily but it it's even
worse imagine two teams of programmers
and each is implementing a service and
one of the guys asks the other
hey what what does your service do and
the others like oh sure here look at the
code is it obvious I mean not really you
cannot really tell there's there's no
there's no easy way of understanding the
code just by looking at it so what can
we do to to mitigate all those problems
well the answer would be Luna or other
visual textual programming and I think
one remark is in order I am NOT trying
to sell you a silver bullet that will
magically make all of your problems
disappear I would much rather talk about
a proposed paradigm shift right we
proposed a different way of approaching
software development so right now let's
take a look at what Luna actually does
and we have prepared a demo that's
pre-recorded because I don't feel
confident doing live coding with the
levels of stress I'm experiencing right
now so you're taking data from an
endpoint then you are extracting the
JSON from their response parsing it into
a nice data frame this is our way of
visualizing like multi-dimensional
nested data mm-hmm you're looking up
some stuff you're filtering the list and
this is this is one of our use cases we
were visualizing all the trams in Krakov
life so we just want to get the
positions from the from the stream and
now we thought okay this functionality
is complex enough we just collapsed it
into a single function now it's just
this this simple node and we proceed
with the processing to
to transform it into a form that our map
visualizers accept and if you if you
look at it we can visualize the data
that flows through our system at each
step so we have this live insight into
the data we know what we are doing but
at the same time it's not like working
with say Jupiter notebook when your
visualizations actually get in the way
of your code we can do something on the
side not interrupting the main flow of
data so this is what the data flow graph
is about and we are think that ask you
know what what's the difference between
this and I mean insert data flow
language X we try to be a truly general
general-purpose language and some data
flow languages tend to be simply an
overlay over a set of predefined
components that's not it that's a it's a
full programming language ok now just
wait a few seconds until we are able to
uh-huh get the visualization so those
are all of the trends in Krakov just to
make it look nicer we will collapse it
even further and I will talk about this
feature more because it's insanely cool
we should have put some music in the
background yes of course you're I'm
running into the future a bit but the
colors are the types I mean we color and
code the types
tadam all of the transom crackles thank
you I see a guy who recorded that sits
in the front row here so she should get
all the credit so the thing I wanted to
touch upon reiterate is that we provide
adjustable layers of abstraction and by
that I mean each node is composed of
other nodes apart from the primitive
ones so if you think something is
complex enough you can collapse it into
a function and then just view it from
the distance so you abstract away all
the implementation details
a-and they don't get in your way anymore
it's the communication is much easier so
that's the process of doing that and you
can enter it again to work on the
implementation detail then zoom out but
onto the coolest feature of Luna Luna is
visual textual language right now we
were only focusing on the visual part
but hey everything you do in the graph
actually is reflected by code you create
a node and the line gets created but
actually it works the other way around
so if you type something it's reflected
by the graph so if you have attended
yesterday's Q keynote those two
representations would be isomorphic okay
so what are the benefits of this
approach well first of all you get
something that I like to call manageable
complexity it's it's so much easier to
write correct programs quickly when you
actually can you know view the
abstraction on different levels and have
the clear layers of abstraction this and
it's more it's a more natural way of
thinking about the programs processing
data so you end up writing more correct
code more quickly then the next thing is
that this this pipeline is it's really
how how people tend to think about
processing data about data flowing
through subsequent transformations so
this is what it should look like at
least in my opinion and the
communication barriers that we were
talking about they are pretty much gone
the the products people can inspect the
program at the very high level using
those those very abstract operations to
tell them more or less what the program
does and focus on the on the business
logic and then you can have a programmer
dive right into the implementation
details and for example I don't know
tune and FFT using the the textual layer
which should be better for that right so
everyone can choose the wrong view of
the system okay so now on to the more
more technical side of the presentation
so first of all the way we this is we
were designing this language was was was
very particular because well the the
dual representation was one of the very
first assumptions that we were making so
everything we do is every feature we add
needs to work good in text but also
needs to be nicely we were we need to be
able to visualize it nicely and it needs
to be intuitive to work with in the
visual in the visual part of the system
and that means that we have certain
requirements that when you're then when
you're writing a purely textual language
you you don't have so this influence is
our textual design as well so I I often
get asked is Luna dynamic or is it
compiled where this paradigm is is
inherently dynamic because you are
writing the program
you are processing the data as you are
adding more notes you're effectively
creating the program so it's it is
dynamic though we can use compilation to
to compile some commonly used parts to
to cache things and to generally
optimize the performance and yet with
all the dynamic stuff going on we are
leveraging the benefits of the static
typing because we want to be able to
guide the users so that they cannot you
know do nonsensical operations the types
are there to help
so our type system what is it like it's
I must say it's heavily influenced by
the Haskell type system which we really
like but at the same time we we think
that half of type system are like the
user
ergonomics some things are more tedious
than they should be and we really like
the idea of objects I'm not gonna go as
far as saying object-oriented
programming but objects are cool but we
also like algebraic data types and if
you don't know what those are
I'm gonna show in the next slide but we
also think that you know you you need to
have the accessors you know like scope
to their own class and what I mean by
that is on this slide so here you have a
simple implementation of a data type
that has two constructors and this is
the the algebraic data type I was
talking about and on the left you have
the implementation in Luna on the right
you have the implementation in Haskell
so you can see that we do support like
full parametric polymorphism
just like Haskell does so the food takes
the parameter a which can be anything we
do support multiple value constructors
so this is the some type that Philip
Weller was talking about yesterday and
we do support pattern matching because
we think it's an awesome way of of
deconstructing our data yet well our
ADT's have then
object II twist so think about what you
need to do in Haskell if you want to
name the two fields in the records the
same and here I'm talking about vanilla
Haskell because I was made aware of some
recent additions to GHC that will allow
you to do this to some extent but in
general you would need to create a type
class right how many of you actually
know Haskell cool awesome so so you're
you're aware of this problem well in
Luna it's it just works out of the box
like it would in Scala or or in Python
you just write the name field in in both
data types and you can use it very
intuitively what's what's more we
support row polymorphism which makes
working with with accessors really
intuitive
despite the fancy name so imagine a
situation like this we're creating three
data types and two first ones have the
name property the third one has the name
method but this shouldn't be any
different right now
we are defining a function which says
well give me anything and I will give
you its name property so this you know
this makes some assumptions about the X
right so well let us create some some
variables of those types I may or may
not have been watching friends at the
time of creating this talk anyway we can
use get name property on each of the
objects right so we are passing
completely different types to this
function and yet it can somehow make
sense of this and remember we are a
statically typed language so this
phenomenon is the role polymorphism
because the type of this function is
actually this and this is a pure script
key way of writing this that you may
have seen on this conference and in Luna
you you'll never have to type it I mean
part of it being visual means that we
need to be
kind of implicit and helpful about the
type so you don't need to know that it's
this under the hood you just can use it
like you would in Ruby or Python so now
this tiny operator that I think deserved
its own slide so one we mark this dot is
the Scala dot the java dot is the
accessor dot it's not the Haskell
composition dot but we have two flavors
of the dot one is with the spaces around
it which makes it behave like this it
just applies this function to everything
it finds before the dot but there's also
this cramped version of dot that sticks
the operands together and it just
applies the the function the accessor
the method to the to the nearest operand
it's it's tucked together with so this
sounds pretty simple yet it allows us to
write cool code like this on the in the
example it I mean you don't really need
to use parentheses anymore and it allows
us to chain the calls in a very elegant
way I don't know if your if you like
what you're seeing but I bet you can
actually tell what the code does right
even without really having any
experience in Luna so that's the very
intuitive semantics of the dot right so
the next nickname so the next thing I
would like to talk about is how we
handle computational effects in Luna
because well as we said we we are a
functional language right so first of
all we really like laziness we think
it's cool it allows you to write
beautiful and elegant abstractions just
like well think laziness in Haskell so
for example the data types are lazy with
respect to their fields so if you see
the Foo data type here it takes
something that well is it's an i/o
action
it will in this line it will not print
anything because it's it's lazy
it's a tongue then functions do not
strictly evaluate their arguments and by
the way in Luna if is a function as
anything else so this means that in this
example if we were to have strict
evaluation of function arguments this
will actually print both right because
it would look look at its arguments it
has three arguments the condition the
true branch and the false branch and it
would evaluate all of those but that's
that's not what we want right since we
were lazy we're not doing anything
unless explicitly asked for it so this
if basically works as you would expect
yeah so we're using the the coal by call
by need mechanism to which can well save
us some time
in different situations well but all
that said we do have a strict twist in
our effect system and this is partially
due to the fact that you know the lines
of code correspond to the nodes and then
there is actually some magnetic magic
going on under the hood but a good
intuition is that if you have a line of
code it will evaluate okay so will it
will not get lost and it's quite easy to
to actually force the evaluation of
terms so in Haskell sometimes we need to
do a little magic to do that in Luna
this is intended to be really intuitive
and I'm gonna show you some examples
well the lazy data type fields we we
mentioned in the example here we're
wrapping the the function reading from
standard input in a just value and it
does nothing nothing is read it's that's
nothing but then we're calling get to
extract this value from just and it
needs to actually evaluate the read so
it will read twice right just as you
call it twice then the function
arguments we have
Khan's function that that will just
returns first argument and it will not
print anything right if it was eager it
would print hello but it's not and to to
show you that the dis approach that we
are taking is is really intuitive
consider the implementation of the cost
function and the sec function
everyone knows the sec function in
Haskell yeah so this cost will just give
you the first argument completely
ignoring the second while sec will
explicitly invoke the the effects
associated with with the a value and
then give you the second value so
something a little magic in Haskell and
Luna that's that's that's quite simple
so this this also means that we can
distinguish between like pure mapping
and effect to mapping so think map and
map M in Haskell the first map will do
will just give you a list of unevaluated
actions while the second one will
actually force evaluation of each action
and do pretty much what you would expect
in such case right so so actually print
something and if you if you look at our
source code and see implementation of
each and map the difference is pretty
much the same as the difference in
between constants SEC so this all
revolves around the same idea so I I
promised to tell you about about the the
lessons we learned while using Haskell
for a quite big codebase and quite a big
project I I don't think I need to
convince the the audience here that
Haskell is really awesome
so it's typesafe right the the compiler
does a lot of work that you would
normally in a dynamically typed language
or even in a more weakly typed language
you would need to write unit tests for
which nobody likes
so this
this Spurs you some work it's really
concise it's really clean it has this
mathematical cleanness to it which which
we really enjoy and then you have this
cool feature that pretty much if you're
doing refactoring in Haskell you just
change for example the function
signature and then fix compilation
errors one by one if you when you're
done you're done think about you know
constantly grepping for stuff in in
JavaScript or in Python and ending up
breaking production code either way
that's really cool well the Haskell also
has the dark site so the the said
laziness of of Haskell and the non
Turing machine model of evaluation right
it it's like lambda calculus translated
by the compiler to the to run on the
Turing machine it may be hard to look at
the Haskell program and say huh I know
how fast this runs sometimes it's really
unintuitive and then Haskell programs
may be hard to benchmark again you need
to you need to make sure that everything
you benchmark actually evaluates because
GHC is a aggressively optimizing
compiler and in general it it's keen to
to conclude that you don't need a value
and just optimize it away so to that
extent yes you you sometimes need to
fight laziness even when I don't know
doing something like a debugging print
in a pure function can be tricky yeah so
we are using ght Jas to compile some of
our Haskell code into Jas so that's
there can be tricky mostly because the
resulting Jas code is quite large
I mean think of encoding the Haskell
runtime system in J as every time you
compile the program so that's that's
quite large also when we are building
our con
Sibley sized Haskell code base it
consumes a lot of resources and a lot of
time especially if you're keen on using
house template Haskell you get large
compilation times and some surprises
okay so one educational example and if
you're an experienced have - programmer
this this probably will be boring but if
you're just starting then this may be an
interesting code so do you know what
this code does it's it's quite
straightforward we have this unsafe and
impure operation that reads a file
arbitrarily named and then returns the
tail of this file so all of the lines
except the first ones and we know that
pail is a partial function so it will
fail if you fetch it an empty if you
provide it with an empty list right so
well s we are good programmers and we
are aware of that we are constructing a
function that will extract I mean that
will wrap this this unsafe computation
and basically well catch any exceptions
and if they occur we just return unknown
right 100% safe awesome called rest
assured nothing will happen so we are
using this to wrap the unsaved and pure
computation we are extracting its result
and we are trying to print it to the
console okay question 1 what happens if
the file does not exist ok anyway he
wants to answer well actually it will be
ok right because we are catching the
exception and the exception will be
thrown by read file catching any
exceptions everything is fine but what
happens when the file exists but is
empty well exception right buttocks but
one that is not caught but by catch any
crashing your code and you may think now
let's trivial code right but this code
wrapped with some additional logic host
a code that I myself used to crash
production so yeah I learned some
Haskell so why does it crash well
because a tail that's returned here it
it doesn't actually explicitly throw an
exception it it returns bottom it
returns undefined so with just flows
through the safe get and through the
catch any because if you know there's
nothing there's not an exception and
only when you try to actually access
this value it sees
whoa it's undefined okay let's let's
throw an error so you can you can write
this exact same program maybe changing
one character or for two to make it work
like you would expect so first of all
you can return here using the dollar
exclamation mark which is a strict
version of application of the function
which will actually force the evaluation
off the tail and will encounter the
undefined then but you can also use
catch any deep which will go through you
know like all all your code and evaluate
all the actions right to the bottom and
it again will encounter the bottom and
report an error okay so let me just tell
you you know ending what's the state of
the project we have just open source
Luna and you can check out github
accomplished Luna two to see our github
organization there's quite a few
repositories but I will be safe in
assuming that the ones prefix with Luna
something are the ones you need to take
a look at and we do welcome any
contributions so so so please take a
look at the github there's some work
that we are doing right now and that we
will continue doing first and foremost
work on performance this is this is one
of our main concerns but also FFI so we
would like to bind different languages
and I think the roadmap is first we need
to bind Haskell then C then - then Jas I
think we were able to make first calls -
to Haskell like yesterday we would like
to make the type system more expressive
because right now right now it's very
user friendly but 100 percent implicit
we would like to allow you to to have
you know more control over the your
signatures and we are working on a
larger set of libraries and this is
where we are counting on on community
support in the first place so I
encourage you to get in touch with us
the information github org also our
website and the chat which we are you
know it's pretty active I mean we do
have a vibrant community so you might
want to check this out for like larger
questions there's the discuss the forum
and I think I need to mention that we
are hiring we are looking for a project
manager for DevOps and probably for AJ
as magician so so do reach out to us we
were happy to review any application and
we are based here in Krakow
so it's like walking distance from here
yeah thank you very much hope you like
this
thank you very much for the explenation
now you know what we are talking about
it's we have plenty of time for
questions so please go ahead
oh thanks for the great introduction
Luna is really a technology that we
should keep an eye on I have a nasty
question and sorry for that if I would
like to put together an application that
if you say data flow and data flow
processing I would think about neural
networks
I would like to train a neural network
to do some crazy face recognition for
example I would like to deploy it to the
server with four GPUs for training and
deploy it to the mobile phone on the end
user running the recognition evaluation
part on the GPU sub processor and the
application can I write this whole
system for example but I would do today
with tensorflow
in Luna and is it in the scope of Luna
and if it is then we can accept such a
full coverage sure this is actually a
complex question because the answer is
in few parts so yes I mean the last
question yes the the the goal of Luna is
to be kind of like the the language zero
so like the language for all of your
programming needs right so yes you
should be able to do that in Luna if if
we are successful in doing what we do
right now
then binding to stuff like tensorflow
this is my we do focus on providing FFI
because right now it would make little
sense in you know rewriting neural
network libraries in Luna although
there's some community effort I mean
guys are creating neural nets in Luna
right now but I mean not tensorflow
scale right so expect the bindings
really soon and once we have the
bindings to to Haskell and to see like
the set of libraries that you will be
able to use is is huge right and then
there will come Python which will give
you you know pandas
by Karis everything so yes then about
the deployment part again yes I mean
part of my PhD is to turn Luna into this
go to platform for server less computing
so in general we aim to you know we
would like to be this for this use case
to be this glue language that you know
you have several services scattered and
deployed and when you really would like
to see how the data flows between them
that's yeah that Luna should be good for
that I have two quick questions
you weren't specifying the type
signatures in the in your code
now is it possible to add them there is
an ongoing work on that that's part of
the making type system more expressive I
was trying to put it mildly
and that one what's the runtime of Luna
like does it compile - Haskell
eventually and you like I don't know J
okay so we are reusing Haskell runtime
system but we are not compiling -
Haskell per say we have our our own
compiler but but yes we are reusing
Haskell runtime system alright hi can
you give me an idea of the error
messages error messages in Luna yeah Oh
didn't I show that okay so are you
interested in the visual part or the
textual part both yes cool so I'm gonna
start with the visual part mm-hmm so the
error is a node with like red crossing
and with an error message displayed
under the node but more often than not
if you have an error in one node it
propagates to other nodes because they
they cannot make sense of the often note
that you know of the data that flows
through them but is it's flawed so it
kind of nicely propagates on the graph
and like the nodes are like with this
you know I think
yes and the end the textual error
message our think GHC error messages but
formatted nicely and striving for more
user friendliness how how strong is it
tied to its to this ID this UI I think
it's running on electron when I tried
yes so the front end is a add-on plugin
and there is some community effort to
actually detach it from from atom so I
think you should follow the the forum
and the chat because there's some work
around that right now it's tight pretty
closely because I mean we needed to
start with something but we were working
on decoupling it does it make sense to
at some point have something similar to
ipython notebook where you you sort of
you compile it you you draw all your
graphs and then you provide it in a
readable form on a web page without
needing to compile it on the fly when
the user I mean it's just we have some
some J s on the front and that's that's
the we compile Haskell to DJ s but at
the end of the day that's J s so it's a
matter of once we decouple it from Adam
we are pretty much free to put it every
anywhere we like
is it possible to use yes precaution is
it possible to use the recursion and how
you visualize it yes it's definitely
possible it's it's part of the question
that we got at the at the party
yesterday
how do we visualize functions well think
of a node with you know it's just like a
function to which you don't provide
arguments right so the node has its its
ports standing for its arguments so if
you don't actually attach it attach
anything to the port you get a partial
function
alright partially applied function so
then you could please know this kind of
like you see that it being attached to
the to the input expecting the function
so the recursion is something like that
I mean except for the node calling
itself it's it's it's implicit I mean
you you don't have the looping arrow if
that's what you're talking about now
yeah and second question is is it
possible to reuse functions and how they
also visualized how example benefactor
function is used in several places yes
so the function view like when you when
you enter a node representing a function
it's basically the same data flow that
you would normally have with concrete
values except that the source of the
data is some abstract port and the the
output is another abstract port so in
that respect visualizing functions is is
pretty much same as visualizing you know
actual actual code if that's clear
actually if you if you want to if you
want me to show you how Luna works in
real life after the talk you're welcome
to come okay I've got like that's a
short question would it would it be
possible to kind of play
playing in a small slow motion the data
flow I'm asking from the point of view
of LabVIEW LabVIEW which is a purely
graphical programming language created
by National Instruments I spent six
years working it and I think Luna is
fantastic and this is basically
something that you know if it works in
future is going to basically kill
LabVIEW I think but would it be possible
to kind of play what would love you
allows you to do is you can you can play
in slow motion and you can see what data
type what's the values and it's kind of
like a debugging feature so first of all
yes we do have the D visualizations
under the notes so well we have some
examples that you know if you attach a
constant stream of values into a node
and then display its visualization you
actually see it appearing on the graph
so so that's that maybe the inspection
you're talking about probably's yeah so
that would be on our website I think you
can see a video showing you precisely
that I mean visualizing okay just the
last two questions right have you had
any bugs from getting map and each mixed
up or does the compiler catch it sorry
have you had any bugs from getting a map
and each mixed up or does the type
system catch that no bugs that I know of
or do they have different types under
the hood yes but I mean I don't I cannot
think of a use case where I actually
mixed up each and map okay I want to ask
a question about the geology between the
visual representation and the textual
representation do you preserve the
spatial properties of the call graph in
the text version of the program special
of the text No so when you show in the
you're talking about graph to text and
from text yeah so if you like ordered
those notes in some neat way then you
then looks nice and then you switch to
code and then you will lose that nice
order I know yeah first thing you don't
ever switch to code those two are just
live alongside each other so you never
actually switch between the code view
and the text view because this is
something that happens on the fly and so
to that extent you you never need to you
know retrieve the visual visual part
from the code because it's just always
there but the second part of this answer
would be we keep some meta data in order
to to preserve the the layout of the
notes but the third part would be we
also have some efforts in order to you
know layout the nodes nicely if if they</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>