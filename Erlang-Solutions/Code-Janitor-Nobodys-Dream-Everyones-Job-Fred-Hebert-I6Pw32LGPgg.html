<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Code Janitor: Nobody's Dream, Everyone's Job - Fred Hebert | Coder Coacher - Coaching Coders</title><meta content="Code Janitor: Nobody's Dream, Everyone's Job - Fred Hebert - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Code Janitor: Nobody's Dream, Everyone's Job - Fred Hebert</b></h2><h5 class="post__date">2013-04-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/I6Pw32LGPgg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right so yeah my talk is co janitor
nobody's dream everybody's dove and how
our line can help so yeah has managed
usually have that presentation slide I
can skip it d action is because I'm from
Quebec so if you have any problem there
standing you can interrupt me ask
questions or whatever I've been working
before for relying solutions adhered
technologies and I now started at Heroku
and I'm also the guy who works in the
airline shell trying to get history to
work for the last few years and still
failing in general maintenance is the
price to pay to earn the right to write
new code who here just by a show of
hands hates doing maintenance work yeah
that's still a good number of hands who
here really really loves it you've got
two guys okay right and two people out
of a rogue I don't know where maybe 30
or 40 maybe less than that I'm really
bad at counting but yeah that's a very
very very small part of the people who
really really love to do maintenance and
most of the time it feels a bit like
going through a forest of old code
cobwebs and just trying to fight all the
monsters in the dark and everything and
it's very very kind of boring work and
we have to think as a develop as
developers if only two people in the
room really love to do maintenance how
much of our work in general is
maintenance well it turns out that
because of many many papers what they
find out is that when you build a new
system thirty percent of the time you
spend on developing it building it doing
the specifications and when there's just
building it and seventy percent of the
time is maintenance so what this means
is that everyone here in this room in
general will hate seventy percent of
their job or at least not be the party
like and we still really like developing
and whatnot but most of it is boring
stuff we don't really care about it's
also boring so that companies don't
really care about once you ship it yeah
whatever it's just seeing the budgeting
is and what not and we kind of expect
that yeah the first thirty percent are
really really important you put your
good programmers and that your best
people architecture you
resources in there and in the end what
it ends up being is that sixty to eighty
percent of the actual money spent on the
project is going to be spell maintenance
anyway so right well most companies will
do is you they'll get their best
programmers write in new systems and
then they'll send them right other new
systems and they you take the interns
and then you comers and you send them
doing maintenance and it turns out that
most of your budget and most of your
operational costs aren't going to go on
the people who have no experience that
you're giving them most of the work to
do on the life type of product it's kind
of a bit stupid but where does the time
go basically when we think of
maintenance people think of usually
solving bugs are the types of
maintenance that you have is are
basically divided into four categories
you've got the corrective maintenance
which means there is a bug we need to
fix that you've got the adaptive
maintenance oops I hit the microphone
the adaptive maintenance which basically
means of the environment changed let's
say you just updated your chicago bus
install and what no to our 16 b and now
you're parameterize modules are gone
well you need to do some maintenance
work to be able to keep going with that
you're updating your databases you're
talking to new clients or third parties
that change your AP is you need to do
maintenance in that this is adaptive you
get the perfective maintenance I'm
dealing with some kind of a blog
platform because blog platforms are the
perpetual example and at some point
people say well no biet nobody really
uses RSS anymore I want to have my share
button and Twitter or whatever so you
need to adapt in general to the
technology and perfect whatever system
you have according to the needs of
people and maybe in 1996 you are fine
just being able Bubba shticks but at
some point then you needed to be able to
publish images publish videos being able
to edit stuff have multiple permissions
and whatnot and as people use your
system you need to perfect it to go with
the youth people have about it in the
expectations of your software and then
you've got the emergencies someone
tripped over wire or kill something and
one example I like withstanding systems
in the 80s where they receive the
support call about well someone just
drove into the data center and knock the
server over and they said oh is that
still running they said yes but we want
to know if we can put it back up without
breaking stuff yeah that happens there
was more emergencies there are things
you have to do about maintenance so
there's a la there's a bunch of other
five of them I mentioned to hear Dirk of
lemons law the lemon made a few papers
in the early 80s and then revised them
in the 90s regarding software
development the general costs you have
so the first law is a program that is
used and that as an implementation of
its specification that reflects some
other reality undergoes continual
changes or becomes progressively less
useful the change or decay process
continues until it is judge and more
cost effective to replace a system with
a recreated version so basically a
you're right software that's simple does
the right thing and if you leave it that
way even if it was perfect the beginning
it will be useless in a couple of years
in a couple of months it will depends on
your users they'll get used to it you'll
create new needs the environment is
going to change or maybe they're just
the program is going to be big enough to
influence and impact the environment it
evolves in and basically make it make
itself useless so you will need to have
change in there and you have according
to lemons three times three types of
programs you'll have the type s which is
basically a program that's according to
a strict specification those will be
mathematical theorems formulas that kind
of thing you've got the P kind of
program which is arbitrary quality so a
chess game would be that the rules of
chess will not really change ever
however the quality of the game of chess
will entirely depend about who plays it
the environment suits in what you target
audience so if you play for newcomers
then you need a different kind of AI in
your chess game and if you do it for its
for professionals and then you've got
the abstract programs and those are the
programs there is no really good
definite rule it's never going to be
solid and those are the vast majority of
the programs every one of us is working
on so you think well what I'll do is
I'll just change the program is it
getting that's going to be it's going to
be fine and there's a second law which
basic
says that an evolving program that you
modify just keeps the Torah reading in
structure until it becomes impossible to
maintain so a program is never going to
be useful for ever so you need to change
it but the more you change the program
the harder you make it to change so the
more you touch the code the less easy it
is to do and unless you take very very
specific steps to do that it's going to
cost so much to fix or upgrade the
program you're just going to give up in
a writer second system which usually
fails because it's a second system and
generally the problem the problem there
is complexity and complexity is a purely
human problem if the computer gets a
very very very hard program it's still
going to execute it it's not going to
complain until it's technically wrong so
the problem is purely human this humans
don't understand the program they have
to take time to understand it and
whatnot and so when will you do
maintenance and you have this big
hairball of a program that needed to
evolve but nobody really took the time
to understand what it does before
changing it you get into something a bit
like that and those are statistics that
obtained from a few papers usually the
time it takes to understand what a
program does over a lifetime of a
program see that in the maintenance time
it will be something about sixty percent
of the time of maintenance will be spent
trying to understand whatever the
program is doing given that maintenance
is about seventy percent of the timer
project you can have up to more than a
half of the time that a software product
exists more than half of the time you'll
spend on developers will be the flappers
trying to understand what the hell the
system is doing that's a very very big
problem it's not even about how do I
build the stuff is how do I even read
the code how do I know what the program
is doing and we don't know how to do
that even instant in this day and age
it's kind of the same thing we're just
all terrible writing readable code and
we still have people who are saying well
you need to have self documenting code
and you need to have this and you need
to have that in the end is still
terribly impossible to maintain customer
of money is all our own fault so where
do we go to find information in general
well the source the source is Jesus of
finding information it's always right
because it's what is in production and
seventy percent or seven in ten
industrial development groups will note
that the code is the main information
source you don't even go to to two
co-workers you don't go to documentation
you don't go to whatever you write in
the code and find it then you're going
to cool workers co-workers as the second
stores the only reason they're the
second source is bad because usually
they've been to the code before you went
so you can skip that step but usually
the main source of information of
co-workers is still the source and then
you've got tools that would be knowledge
bases bug trackers and then fourth
position will be documentation will be
wiki's could be inline comments could be
whatever and the main reason why people
put documentation solo is usually that
its side are not there or it's outdated
and I think everyone here has dealt with
documentation where this is the case so
yeah airline can help so I really just
I've run a poll online at probably a few
of you over time Evan stirred I've got
170 developers who participated in the
poll and this was one of this was a main
question in it apart from just figuring
out who is whom and you are hired to
take over an existing airline code base
and based on your experience what do you
think is important for you to feel
comfortable enough to say that you own
the code base that you have the UH your
don't you have the owner of the show of
the code and basically the first one is
use of source control if you don't use
git svn mercurial whatever nobody's
going to want to work on your code it's
over 80% developers judge it absolutely
essential the second one is having
managers that give you time to work on
the code and this isn't surprising when
you consider that over half of any
software projects time is going to be
spent trying to figure out what the hell
it's doing if you don't have time to
adapt to the product you're never going
to be able to understand it and maintain
it in the first place the third one is
kind of surprising this is the respect
of OTP principles by using behaviors to
answer very supervisors applications
Jennifer Sam and Evan teenagers once
you're done with that you get into the
presence of tests come and test the unit
quick check proper trick whatever you
can think of documentation at a higher
level I split documentation in two
sections you get documentation at a
higher level here then you've got the
documentation so that our comments in
code and there's a difference in there
and how people perceive them
documentation the higher level is
initially more important to airline
programmers in general familiarity with
the problem bombing is ranked a bit
lower and then you've got the others
co-workers ability to have called
trackers and whatever what's really
really really important interesting
about that is that nine of the top ten
results in there are not Erlang specific
they're just general good practices that
are going to be good at any language
right source control having time having
tests having documentation having people
who know the thing knowing the topic
those are general things that people
will find very very important this then
raises the next question why the hell is
OTP judge to be more important than even
having tests or even having
documentation or even having co-workers
or even knowing the problem the dumbing
problem that you're working on this
means that you give a OTP programmer
who's used to do web development to go
work in some kind of another embedded
software or whatever it is say yeah sure
I'm fine as long as it's OTP and this is
kind of something special that you might
not see in most languages so this raises
a question about why OTP matters and the
idea here is the importance of behaviors
obviously because that was the top
result so we've got three components the
workers the supervisors the applications
and I think most of you are kind of
family familiar with the concepts the
workers you have the message dispatchers
that will be the Jenny vent you've got
the data managers could be jet servers
you've got you independent agents that
could be the Jennifer since you've got
the supervisors and supervisors are
really the wonderful thing here because
when you put processes in the supervisor
if you're kind of implicitly declaring
what depends on what how they should be
started how they should be stopped how
they should crash
and what are the direct dependencies and
one very interesting thing is is just
really how they should crash because
what other programming language or
platform that you know that that asks
you how do you want things to fail both
languages you work with or most tool use
you you will use will tell you well how
do you want to prevent things from
failing you want to type check them do
you want to run some kind of static in
the list so you want to have tests
you're lying is kind of just saying well
now it's going to crash anyway I mean I
know that everyone in this room is kind
of dumb in all different ways and one of
you is going to make a mistake and it
might be me and whatever so it's going
to fail how do you want it to fail and
you have to think about that is
something that in general when you're
doing development you don't think about
then you've got the applications that
take all these workers that you've
decided how you want it to crash and
then you make them into bigger entities
that you just nesting to one each other
and then you can say well that
application depends on that one in that
group of workers and you can think about
them at a higher level and what's
interesting is that OTP is being used by
people in pretty much any domain and
they force a common development pattern
on every single programmer there's a
focus on protocols isolation
dependencies and well thought out
crashes everyone who's using Erlang an
OTP ends up thinking about how they want
their applications to crash if they're
doing any kind of right so usually
maintenance is going to be some kind of
Jenga thing rack you start with the
tower and building tower is really
really fun and easy you just do what you
pile up the block it's fine and then a
manager a customer or whoever decides to
tell you well I want to replace that
blog and I want a blue one instead if
it's at the top it's not too bad but
then if you've built everything as a
nice tower of abstraction and someone
want to tell you well you need to change
the block at the bottom it becomes
really like Jenga you have to remove it
very very carefully and swapping the new
one without having the tower topple over
and then if you've got three or four
people working on the program at the
same time it's very very unstable and
difficult to do and really programming
in this day and age is still like
building towers and buildings and
whatnot but with Jenga blocks that's
what we're doing as a programmer in
general and what would be nice is to be
able to do it with Lego blocks where it
just kind of
snap it replace stuff and just close it
in there and they're fixed together in a
way that doesn't fall over every time
someone touches it and you have just one
guy who has the permission to check the
comments or whatever because otherwise
who knows what's going to happen so you
use protocols protocols in general are
nice that's what makes the internet work
and everyone knows that the Internet's
kind of tends to scale the advantages of
protocols will be isolation every
component will be communicating with
message passing by isolation everyone
has its own state they're independent of
each other you cut the cable I'm still
my own entity and I'm fine I'm just not
able to communicate with anyone message
passing means that yeah I'm not sharing
anything that's core to whatever my
component is I'm just able to send it
over and these two things together
already are kind of nice because you
know that there's nothing connecting you
to the other part and there's a strong
possibility that it's not going to be
there it's going to be slow its going to
be missing its going to be unreliable
and as soon as you have protocols as an
idea about how to build things you start
to building with the idea that stuff
will fail because it will for real and
so you end up having defining
abstraction answer you've got TCP that's
out here well you have possibly that
ordering tend to be wrong it's going to
fix it for you you've got bin torrent
wire that's so funny that's a different
protocol and you've got HTTP and God
knows everyone's tunneling everything
over httpd stays and get me to look at
allowing an OTP and you see the same
things the isolations of processes you
see the message passing and then the
applications and the behaviors are the
things that use the protocols if any of
you has as any of you looked at how Jen
server is implemented Thanks time yeah
there is a gender Earl module and
there's a call function that's being
used by everything and the supervisor is
a server itself and another lying you
basically have this very basic idea that
you have synchronous called synchronous
calls you need to monitor you have links
and whatnot there's this kind of
protocol about how you should set up a
communication with an another process
depending on how you want to talk about
to talk with it and each of the
behaviors as it sound kind of
protocol on top and all you do is
configure it to send a message it one
this is kind of similar to what you will
do over HTTP where you'll set a
different kind of header oh this is
intended for a type of server that
understand Jason this is one for XML
this is time for whatever another line
has that kind of isolation and protocols
and you think of failure from the get-go
so you get this kind of application
where I've blurred the name on purpose
and I generated that from a script took
15 minutes to write graphviz from app
files and that tells you the arky of an
OTP application and I give you this code
base and I tell you well the component
right here is the one I want changed
well to see how it's used you're
probably going to start from the top of
the top of the list there and just go
down to whatever uses it and how it's
the Pentagon and you're able to easily
know what depends on what in that matter
and you will know that this application
right here where it doesn't directly
depend on the one on top so if the one
on top changes you still have these
layers to absorb the change in between
so yeah if this is if you've got this
kind of isolation refactoring kinds of
comes for free because I can just swap
in that component as long as I keep your
right protocol in between them I'm free
to go they just need to speak the same
language some general that will lead you
to something like that yeah
modifications without relying an OTP if
you think of it OTP lets you have
partial rest arts because you kind of
expect your application to fail from
some level it can fail in production
that's what you wanted in the first
place you want to be able to do that so
you can have partial rest starts you're
gonna have cooled upgrades that was sort
of in the virtual machine itself there's
an awareness of risk and failure modes
of a system because every supervisor
that you've written had to think about
how do you want stuff to fail and do you
want to trap exists or not from top to
bottom you have this idea that the
artist stuff is going to fail and are
you able to survive it so basically your
language you the kind of sliced bread of
development you have all these
individual components you can turn them
on and off and change them individually
and do whatever you need what is nice
from maintenance standpoint on top of
that is that you can understand systems
from afar it's using all domains so i
told you about people using it in cars
and I there's this guy Pierre some of
you have met him he's in Germany in his
testing automotive parts using our line
go TP there's people using it
advertisement people using it for web
servers or people using it for you name
it and there's a quick understanding of
any system structure based on that and
this is all due to application metadata
and sometimes it's also implicit in a
bit so yeah the application metadata I'm
looking at things like that in just this
graph I'm able to see what's the central
component where the business logic is
going to be the business logic everyone
can guess is probably going to be at the
top here and it's certain part in that
section here right just see that it
depends on everything that's the one
that just pieces stuff together and so
that application doesn't directly depend
on that one but that one does the
bridging between the two this is kind of
easy to do it gives you a strong
separation between all the components
Joe Armstrong said at some point the
problem with object-oriented code is
that you want banana the banana and you
get the monkey with a jungle that comes
with it right it's easy to do what
you're going to get with that one any
dependency graph will show that to you
the thing with airline is that because
you've got protocols it's fairly easy to
just remove anything and you don't need
to steal the interface from the other
library what the protocol is kind of
implicit that's a message you send its
dynamic you don't care that much about
it so you look at replacing an
application any of these and all the
ugly code that you'll have in the
application can be constrained to that
bunch of processes of there it sounds
supervision tree which is definitely
nice there's a paper that was written
that basically say is that if you have
to change more than twenty-five percent
of a given section of code you're better
to throw it away and start from scratch
if you change less than twenty-five
percent of it just rewriting it will not
introduce that many bugs but
statistically speaking if you write more
than twenty-five percent you're
introducing as many bugs as rewriting it
from scratch so if you can constrain
your code and your modules in a way that
you can just throw them away instead of
Ryu
them all the time it gets pretty easy to
just rewrite all the new components save
times and don't really have more bugs
than anything else if you had to do
major rewrites so the isolation
everything is definitely good well we to
help understanding we have the standard
patterns right and before I get into
that I want to mention the idea of
reverse engineering I've been talking
about the code for a little while now
and we kind of see usually in reverse
engineering is a thing that someone does
when they don't have the manual and
whatever on a black box and you try to
do but the same thing usually at any
kind of systems like this one if I just
show you a repository with nothing in
there you don't have any manual we don't
have it read me you don't have anything
well its ears to figure out what's going
on and so this begins the step of
reverse engineering you just look at the
code and you trace that kind of tree
mentally you start with the top level
supervisor that started a virtual
machine and you go down and you say yeah
that's a supervisor that start that kind
of worker that kind of worker and you
just kind of piece it in your mind
create an abstract model that you
understand yourself and then you rebuild
it and this is where you re-engineer the
system after having reverse engineered
it first you formed an understanding you
deconstructed that and then you make a
new understanding out of it that can be
applied to refactoring the system and
making it work and this is yeah made
easier about by standard patterns you've
got servers finite state machines and
plan their supervisors and applications
and when you deal with patterns in other
languages I like this image this is
patterns in other languages all right
another language is there ahead of
everybody and provides us their own ways
to deal with pattern it's always messy
and then you look at a piece of code and
you'll see that on stack overflow in
many websites there's a piece of code
and someone asked what is that design
pattern and then you have 500 posts
about people saying well this is a kind
of dependency injection no I disagree
this is not dependency injection this is
a container and whatever and then you've
got the factory factory factory factory
joke that everyone knows about and
you've never seen a factory factory
factory that people were used right it's
always a custom implementation to the
fact
refectory factory factory how come is
that the thing is that all these
languages have haddock patterns they're
just a high-level description that sent
a manual somewhere in a book from the
gang of four whoever you decided to read
that day on the internet and everyone's
just reimplemented them and then you
have to make demands of bridge yourself
between the two and say oh yeah that
class or that bit of code is there
that's pretty similar to a single tone I
guess a guy was trying to write a single
time and in Erlang you don't have to do
that you look at the module it's written
gen server yeah it's pretty damn easy
and then you look at it and you have
your interface you have the main server
loom and then you have the private
functions I haven't seen many Gen
servers that don't respect that you see
your supervisors you'll have the start
link you have the init function you'll
have whatever thing you don't have to
look for it the egg is already broken
for you you don't have to understand
what the pattern is and nobody is
reimplemented gen server all the time
while the rabbit in queue there guys did
once but yeah see how that went but yeah
so yeah everyone uses it and this is a
very very good point right i mean the
libraries do not clash with the language
in the semantics we've had people in the
track this morning Jeff and cliff
mentioned at some point that when they
had to break during extraction for
performance one of the problems they had
was the destroyer to have problems with
using any kind of libraries they wanted
to have in general as long as you
respect ODP you don't have that problem
if you go look at people using nodejs or
twisted in Python or whatever people
trying to do invented frameworks you'll
find out that they have to reimplement
all the libraries of the language to fit
within their own model and they'll do
that any time you have a different kind
of paradigm they're trying to insert
into language whether it's logic or
anything you cannot reuse the libraries
because they break the kind of
assumptions that they made about how the
system should have been built and in
other line you don't have that right ODP
is the extension of our line itself you
start with the idea that failure will
happen message passing isolation ODP
adds nothing about that it's just really
the generalization of patterns that
people have been programming there's
nothing that you will there's barely any
library you'll use online that's
OTP application that won't fit into your
application unless it's really really
really not appropriate for the kind of
work you have to do who here uses lagger
as a logging library for an example I
bet all of you I think I cannot about
12-13 hands don't work in the same
domain area you don't need the same
lager but you're able to adapt it that
way because everyone can use anybody's
library and pretty much any domain if
they need to and that's a that's a nice
thing because yeah everyone is basically
working on making the same core better
and if you're working on web development
and I was trying to help make lag or
better in whatever job I was doing
before then you benefit from that and if
you were trying to make whatever library
I used better like I don't know the
header parsing of the HTTP stuff in
there Erlang OTP stack then I benefited
from that even if I'm not working on it
directly and that's because everyone
uses the same kind of libraries the best
example I have in mind is I think was
who have added the optimizations when
you set a monitor before sending a
message and receiving with the monitor
inside of it then it just placed a
marker in the message queue and then you
did you didn't have to scan the whole
male books anymore that was a very very
useful optimization basically killed
rabbitmq gen server to nobody else
really needed it after that and nobody
needed to change your code base nobody
needed to install the new chancellor
where they just had it out of the box
because everyone was using the same damn
thing and everyone benefited from the
same optimization that's useful and that
helps to with reverse engineering as I
said because everyone is using the same
patterns everybody's going to see the
same kind of code and you don't really
have that many things to fit in right
you're going to see a gent server what
are you going to expect it's a worker
that's going to receive messages and
send data back and maybe synchronize
some things I'm going to see fsm what is
it gonna be well it's going to probably
receive evans and rejected react to them
you're going to see a Genevan well it's
going to have subscribers and do stuff
is gonna have a supervisor was going to
catch failure and your start them and
that's really most OTP systems have
these things and you don't have to think
about well this factory starts this
thing and then that
dependency injection is about that other
kind of pattern right there on the side
so what is the guy trying to tell me
right you just get into the pattern you
get it and whatnot and sometimes that is
not even that's not enough so you've got
tracing just get status as modules this
trace which you can start any OTP
process and trace it you've got dbg
you're able to have the debug info cliff
mentioned the memsaab stuff that lets
you monitor memory on the node you're
pretty much able to inspect anything you
want in Erlang and we've seen that in
the top right before hear about
analyzing any kind of statistics you
have about Erlang and pushing it very
very far to be able to understand your
system in a way that's usually not
possible and anybody running an airline
system is able to do that so yeah what's
the importance of time given by
management over the knowledge that
someone has over OTP this is one of the
results of the poll I like the most you
see that when you don't know TP a lot
you think that it's essential to have
time from management and it's always
kind of essential but if you look the
fifty percent bar is about at that point
and when you really really know oh d p
well it's a continuing trend you no
longer feel like you need the time to
adapt to a system and remember that
figuring out what the hell the system is
doing is over half the time you're going
to spend in any software product and
everybody here is sometimes mentioning
gains in productivity and whatnot and
that's probably use reason about it if
you fall in an erlang system and you
have to maintain it most people who use
it and no OTP will need less time which
means that you're going to cut and
optimize the biggest expense you're
going to have in your project in your
development time when you're in
maintenance time that's really cutting
right at the core for something
absolutely useful and the results are
there of course those are self-reported
results and maybe people who like OTP
are really proud about it and lie all
the time I don't know yeah so there's a
correlation with experience also someone
who doesn't know TP is likely to have
less experience as someone who knows OTP
I mean everyone who started with Erlang
without the wing OTP had more experience
after they knew it so necessarily
there's some kind of value there whatnot
yeah in general the more you know TP the
less you need time to
up to a system as a personal feeling and
remembering a little graph I had with
the bars at the beginning this is
massive massive kind of game there's
plenty of problems that will you'll keep
having with ODP still we've been talking
about Q's blowing up the whole day
libraries and version clashes and
everyone probably had to deal with that
at some point if I just go back a bit to
my bit too far that one you can see that
I have well this application here that
one depends on it that one depends on it
that one depends on it and if any of
these sets the dependency is a different
version I'm in the world of pain because
now I have to update all three
applications to make sure they agree on
the version they want because Erlang is
not able to load two versions of the
same applications or two versions of the
same module at the same time it's just
not how it works it's a very very tough
problem to solve and I'm certainly not
clever enough to do it until it's done
this is always going to be painful for
maintenance because you want to add a
new component and all of a sudden this
little isolation that was pretty and
beautiful and everyone liked it is no
longer super easy to do because now even
if I'm just changing that part here I
might be changing this part here and
then forcing to push the back in to
change back to this one and this one at
the top and this is a strong problem
that we have in terms of maintenance if
we're able to find a way to isolate from
that that's definitely going to be good
this is the kind of problems you'll run
into in distributed systems in general
right just imagined as those are web
services with different api's and this
is the same thing if everybody agrees on
the API web services are great you just
pull them out replace them you add a
proxy in front of them who cares and
inner line you're able to do that that
within a single note but when all the
aprs are different then it becomes a
nightmare to maintain and you need to
update all the different parts to agree
together and that's definitely going to
be a problem in their line and it's
going to be the same with interfaces or
whatever you've got no name spaces and I
just don't just mean modules right other
things that I've names inner line you've
got ideas tables you will have the
process names themselves you'll have the
modules as mentioned you will
have database tables if you're dealing
with amnesia with debts or whatever and
the names are going to clash all the
time you should not very very careful I
think everyone when they started using
airline try to create the user module
right and they started the vm would no
longer boot and why well that's because
our language sister the user module at
the central point to do all the I 08 the
system if you don't have that nothing
works so lame spacing is definitely
something that helps you isolate all the
components that we don't have in there
like that would be nice package
management that's still part of handling
dependencies being able to figure stuff
out it's kind of ridiculous that every
time you want to test something or get a
new thing you have to use rebar and then
download the entire history of the
project even if it has a JVM checked in
at some time in the last five years you
have to download the JDM to be able to
wrote the 20 kilobytes bit of code
internationalization localization those
are always difficult in your line you
don't have the library to deal with it I
hope that our 17 are a team with utf8
support at least gets gives us a bit of
stuff for the strings but everyone knows
about the terrible calendar modules
everything that has to do with dealing
with time time zones is absolutely
atrocious to do and I just hope that
nobody ever asks me to touch that
because it's everyone has to deal with
that knows how terrible is I'm still in
the end yeah what EP systems are pretty
solid I'm just going to let that little
one play
right salua CP system in general a solid
they're relatively easy to understand
the more you know TP you're able to
understand them you're able to modify
them as they run you're able to handle
them in any way you want are easy to
inspect and all the steps I have to do
with understanding code which is reading
the source is made it well if I've just
goes very very very far back to have my
point there look at this thing let see
ya so for the code the thing that
happens with the code at that point
everyone using behaviors that's kind of
cleared out your it's easy to get a top
level understanding of whatever the code
is doing very very fast you look at the
standard structure of everything in any
implication co-workers well that one is
kind of a bit in the center not sure but
everyone you ask my IRC on the mailing
list will use the behavior is in the
same way so the whole part of a
communicating about sub components it's
kind of taken care of tool knowledge
base and whatnot for the tools we've got
very very good tools and when story i
have about that we had a file descriptor
leak in a survey we had and basically
the server ran out of memory and what
you found out is that the file is not
closed and it cannot be deleted and
clean from the system and so we look
into the OTP application we're running
and i go look into this clog the disc
lock module and you're able to go in a
live system that's currently about to
crash and you go into the supervisor i
want to see where is the syslog module
in charge of holding stuff so i just
explored the sis luxury you just get
status there's and jen server in there
you get process info and you can see the
links and whatnot and where it goes you
compare it to the data that's inside and
you say oh there's an EDS table that's
attached to that you go reading the 80s
table and you're able to see there is a
match between a process and the file
descriptor so you go see the process and
you just type it in the shell and give
me the information on that process I can
see that it's still running it's running
cowboy code at that point it's still
answering request because I can count
pull it a few times over the over the
course of something I'm able to see yes
it's still receiving cowboy requests so
I'm thinking well this is just a problem
a very very long process so I kill that
one
I know that the OTP structure is able to
absorb that I kill it the file is freed
and then you're able to just keep going
you see ya oestrous reclaim that so
there's a bug there's a process that's
too long lived and I've been able to
test in something like 20 minutes just
inserting the system running it in
production testing it and even if it
crashed it was not that bad anyway
because it will just have been restarted
and you're able to do that in Erlang and
when you compare that to most programs
you have a crash dump or core dump and
you fire up GDP and you try to just
imagine what the system was like when it
crashed and you have that one snapshot
and you try to figure out what the hell
went wrong and you do that in OTP and
you get the live system to test with
finding bo is being able to understand
what the hell is going on it's fairly
easy and it turned out that the problem
was that we misconfigured cowboy and
forgot to give it a max keep a lifetime
and we have requests over a single
socket that could last five days which
meant that you will accumulate a
truckload of empty logs that no longer
we're needed and yeah you just put the
keep alive you restart the cowboy server
the application is still running
everywhere everything was processing is
still alive I just reloaded Cowboys it
took the new configuration there you go
the application when you have basically
no downtime at most it looks like a blip
in the network and that's it you
maintain the problem diagnose the bug
and fixed it it took less than two days
from the time the bug would discover to
fixing it just by being able to inspect
the system as it ran which is something
extremely valuable that we don't have
all the time in any other systems and
that's fairly valuable if you consider
the time it takes and the opportunity
cost of not being able to work on that
and what not ah ok I'll do clapping for
me in the other room yeah so if you want
sources the slides are going to be
online for every kind of statistics I
mentioned the program's lifecycle lots
of software from lemon in 80 there's a
new version that was I think in 1998
when he updated it software maintenance
by Jared oak and phora and yellow to
pronounce that name it's basically a
survey paper about 80 others papers it
is a great great one software
maintenance clarity in code give me a
few numbers Paul results that's the pole
I had and the number about twenty-five
percent code reuse is not on there
it's a analysis of errors and reuse
oriented development environment that
was done at NASA so yeah here's a
shameless advertising do we have any
questions no questions huh oh yeah do
you have any questions because if you do
have questions I actually have goodies
to give which include the books for the
actual yeah so if you can think up of a
question or maybe just a story about her
or line helps you and you can have done
it otherwise yep well do we have anybody
on the OTP team directly oh alright so
I'll try to crack an answer that yeah
there's a talk tomorrow in general I
think we've seen attempts to add
behaviors that didn't go exactly over
too well it's definitely possible the
problem I see with having a pool that
generic is that pool properties are very
very hard to predict what you especially
need so pool boy is great for a lot a
lot of people I had written discount I
think I presented it last year that was
good for different scenarios and then
you've got different metrics and
different people what they want is more
of a work queue and whatnot Jay Nelson
had worked on Jen stream that could be
seen as a kind of pool where it pooled
resources and sent them into a single
stream so any other pool I think it's
still very general enough and nobody
really agrees on it enough to have a
very solid behavior until interim until
adding true for them or having so many
knobs that it's impossible to really
maintain it easily it could be done I
think but you'd have to say this is a
pool for this very specific use case and
it's not as generic as you will have for
Jen server for Jennifer sim or
supervisor where you can see anybody
anywhere can use it
no no it's not been yeah yeah this
that's relaying an ODP in action they
decided that Jennifer stem is not good
enough generally speaking I like
Jennifer sent a lot and whenever you see
someone with jenn suhr or every time in
the state there's some kind of thing
called state again where there is a
processing or whatever an atom that
tells you what it should be doing right
now that's a sign you should be moving
over to a gen fsm and the OTP in action
book basically says you don't need
Jennifer sent because you can just have
that little variable that you keep track
of yeah they're kind of wrong because
the Jennifer sent will have the things
like global events that's Jennifer seem
to I think I can't remember who wrote it
though I think it was yeah the problem
there is with Jennifer same in general
is that you don't choose selected
receive on the events you have and so
you have this very complex event matrix
where you have to care about all the
events that are out of bound for the
current state you're in and this is a
big problem with Jennifer Simon that's
because it's based on Jen server and
just inputs everything you have in there
and I think Jennifer sender was Jennifer
some too sorry I was just die aggressing
in French that's terrible I jennifer's
him do I can't remember who wrote it was
it off I think it was whole figure and
basically what it does is that it ah
someone said something oh yeah that's
possible there any way that there's an
implementation of it that lets you do
selective receives and the advantage of
that is that you only have to care about
the events that are relevant to the
state you're in right now and that makes
the complexity a lot lot lot lower than
just having to handle all the other
violent events and making sure that
nothing crashes and whatnot that's the
main problem with Jennifer's him to
Jennifer stand in general yeah Oh point
if sm does the one by all
yeah all has plaintiff ascent so does
the one I probably had in mind for that
one yep there's a very very long and
complex chapter in the book already
about Jennifer's am doing a trading
system I I think that I'll take a break
from writing books for a little while
but yeah Jennifer sim can be interesting
i would not write a book only on
financing machines in erlang though
that's kind of really really restricting
yourself yep oh yeah I think dialyzer
the thing is that when you have a given
type system that you plug into a
language the type system has given set
of semantics attached to it right so if
you go into the henley miller type
system that you have in high skill o
camel or ml derivative in general that
one will be a type system that will try
to prove out of all doubts that there
are no errors or type errors left in the
system and Erlang as it is I mean you
could know I is it that way but it will
not work on existing programs that
assume that errors are possible and that
you can just mix the types and maybe
version of the code in the future will
be able to run it and so dialyzer the
way it works is that it used something
called success types and Success types
basically say well you know we're not
going to change the semantics of airline
we're just gonna have a type system that
tries to find errors and if it's not
sure it's not gonna complain it's only
going to complain what you really really
really knows there's a problem and
that's what it does and that's why
people expect to add something similar
to Hindley Milner are always very very
disappointed like oh the type system is
not catching all the errors in my
program I have something for myself this
is terrible and yeah I mean it could do
it but you will need to change the
semantics of your language it will be
very possible to use any kind of type
Stan you could go for union types you
could go for dependent types or whatever
if you had the right notation and to do
it before compiling but most of these
would end up changing the semantics of
the language and the brilliant thing
about dialyzer is that it works on
existing programs and it's
not going to complain about code that
works in production or if it does is
going to do because you made type
annotations not are stupid generally
speaking the saying is that dialyzer is
never wrong and most of the time and
very very in create dialyzer and then
after a few hours are reluctantly said
yeah well dialyzer you were right that
was my problem it's just not very nice
about telling me what I did wrong
anything else alright so few people West
question can go fetch a book and just
forget to go in the room and just
distribute it and you have a car you
have a car you have a book so that's
about it so thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>