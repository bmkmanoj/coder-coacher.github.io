<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Sequential Erlang III by Simon Thompson | 5/13 of Erlang Express Course | Coder Coacher - Coaching Coders</title><meta content="Sequential Erlang III by Simon Thompson | 5/13 of Erlang Express Course - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Sequential Erlang III by Simon Thompson | 5/13 of Erlang Express Course</b></h2><h5 class="post__date">2017-11-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/90Roa4Cbrdo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right what we'll do in this final
section on sequential Erlang is to talk
about runtime errors different kinds of
errors that can be created and ways in
which those errors can be handled what
we'll do is run through a sequence of
examples that show these sorts of errors
that you can get a general class of
errors we get to what are called match
errors there is pattern matching in
Erlang that describe that decides which
are a number of function flaws is it
executed or a case expression and so on
and it's possible to get an exception
for no function towards matching what
we've got here is factorial first Clause
applies to positive numbers the second
to zero so if we apply to a negative
number no clause applies and so what we
get is an exception error saying no
function calls matching math factorial
minus 1 here we've got a function with a
deck a switch which switches over the
value of n being minus 1 or 1 so if we
apply the function to 0 we get an
exception due to that at a match failing
there is no K stores which matches 0 so
we're getting accurate errors for these
for these functions in the similar case
if we have a case an if where we switch
on whether n is less than 0 or n is
greater than 0 if we apply the function
to the argument 0 we're going to get an
exception from an if expression and
again what you see here is is the error
message we get back in the shell is
precisely describing that property
now finally pattern match is a very
general process so it's possible as you
see in the example here to bind a
3-tuple
to the variable tuple and then to try
and match that variable here to a four
tuple and what we have got here is an
arrow you see quite often it's a no
match of right hand side value and that
generally says that a pattern match has
failed that can happen because the shape
of the the pattern you're trying to
match doesn't match the expression on
the right hand side it can happen
because your rebinding a variable
because remember you can have bound
variables in patterns
unlike other other languages with
pattern matching so if you write x
equals 2 we'll stop and then you match
on x equals 3 the the error that you'll
get is a it's a no match of right hand
side value it's bad match covers a
number of programming errors other
things we can get is if you have a
function which works over a list for
example and you apply it to a an atom
you'll get what's called a bad argh a
bad argument exception you see that for
length length expects a list it's been
given an atom it's possible to call the
function that isn't defined and that
will give you a message saying precisely
that that function isn't defined it's
possible to to try to add a an atom to a
a number what you get there is a bad
argument in an arithmetic expression so
those are the sorts of errors that can
get created in evaluating an a lying
expression the question is what can we
do about that how can we handle those
expressions what we're going to cover
here is the the original airline
exception handling
called catch a lot of legacy airline
code will use this this exception
handling mechanism more recent code may
well use the the try catch mechanism
which I'll show you an example of at the
end of this discussion but what we have
here is catch captures apply to an
expression and what it will do is as
that expression is evaluated it will
trap any exits caused by runtime errors
and what will happen is we will return
the tuple which consists of the exit
Atem together with a reason for the
runtime error that has occurred so
that's the catch turns what would be an
exception in the shell which called this
should cause the shell to to to die what
we see instead is that a concrete value
is returned as a result of that catch
let's take a look at an example the
reason we're using self here it's a bit
it tells you the identity of the current
process and it returns a thing called
process ID this is stuff that we'll talk
about in the next section the reason
we're looking at it here is it's showing
us when it's showing us when in fact the
the process behind that that's running
the shell has died and has been
relaunched but let's just in command 1
you can see that we're getting the ID of
the the the shell is 28 now if we call
the function list to integer on a list
oh and E that will fail because is
expected here is that the string and of
which makes at the list is a digital
string string of digits so this fails if
we called catch what we get is this long
tuple returned which begins with exit
and then you see a tuple which describes
the exit the error in a lot of detail
because it's a bad argh
it's the tag for the tuple and then what
you have effectively is a stack trace
calls that have led to that bad aaaghhh
error so we get a lot of information
information back from that and you can
see that calling in command 3 calling
self we still got the same process
running if now you call this two integer
we call it make the same function call
but in the shell what happens is that an
exception has been called we get the
error message saying bad argument as we
as we heard earlier but what you see is
that that actually killed the shell
process and it's being relaunched as a
different PID 33 so the the first the
court exception returned an ordinary
value the the lead be uncaught exception
killed the it was handled in the in the
shell and relaunched the shower so there
you see the essential difference between
the court's exception and their nun
called here's another example of a bad
Aris error dividing one by zero you get
a bad RS just a little piece of of
syntax which is frustrating you need if
you're going to bind a court value you
need to you need to bracket the the
catch as you see it there so if you
write x equals catch one divided by zero
you get a syntax error what you need to
do is bracket that hole the call to
catch you can see in letting come on to
the one that's that's failed you get you
get the same effect as we got just
calling that expression now the errors
that we've been catching so far are
errors caused by the evaluator it's
possible to raise your own errors using
a throw primitive and that effectively
gives a non-local exit to a function
call and execution flow it jumps in the
first catch in the execution stack a
typical example for this is perhaps
you're in your deeply within a tree
representing a piece of syntax or XML
tree when you encounter an error you
don't particularly want to unwind all
the all the stages that you entered you
just want to say oh I failed just give
up
so that would be a typical example of
using you throw an exception at that
point and expect the next level up you
would catch that exception and move on
perhaps to processing the next tree I
think we can see an example here we've
got an ADD function which tests the
value of y test a value X and then
returns the sum and what test does is
when X is an integer it returns okay
otherwise it throws an exception and if
we catch if we call the function add
with an integer and at Adam we get and
catch the exception we get a non integer
coming out of that if we catch if we
throw the exception bye-bye and catch it
we get bye-bye if we catch the the call
where the exception isn't raised we
simply get the ordinary the ordinary
value back and if we throw an exception
without catching it we've got an
exception which has to be handled by the
shell so I think there you see the
interaction of catch and throw and it
can be used as part of ordinary
arithmetic processing you can see if we
go back to line 1 what we've got as a
result there is
a tuple and at some point what we'd have
to do is deal with that error tuple and
perhaps convert it into an into a a
number that could be returned to whoever
is calling this this version of add
before we conclude what I want to do is
talk about try-catch so let me show you
an example on the board what we see here
we have an expression of this form we
have an expression which we evaluate and
according to its value if it matches
pattern one will it will perform body 1
it matches pattern to body 2 and so on
but we can also say if it raises an
exception of a particular sort we will
we will perform this recovery code so we
might have pattern 1 there pattern 2
there and so on so this gives us a
structured way of dealing with code that
might raise an exception if it's not if
there isn't an exception raised by that
we would deal with the value in this way
if there is an exception raised we deal
with it in this way and what's nice
about the code here is we can
distinguish between different kinds of
exceptions we can distinguish between
erroneous exceptions like bad aaaghhh
exceptions which are thrown by
programmatically and then exit message
which we'll find out about more look
more about later on in the in the in the
in the course so here we've got this
rather more structured way of dealing
with things so we can be sure we can
distinguish it especially exceptions of
different kinds in this way and we also
get the we combine that the ordinary
handling and the exception handling into
a single construct which is more
flexible and more integrated than than
the
okay well that concludes what I wanted
to talk about with exception handling in
fact that concludes the overview of
sequential Erlang what we've talked
about here is first of all built-in
functions and libraries so the
infrastructure if you like that we work
is provided by the system the existing
system and the manual pages and
documentation that described those we've
also talked about the general control
structures for these sequential aspects
of our line about how you can act
perform different alternatives according
to case pattern matching based or
if-then-else
we've got guards and a particular
restricted syntax that you can use
within guards and we've got recursion
which gives looping which gives
iteration it's a general control
construct for which gets used throughout
airline programs and also we talked
about some of the runtime errors that
can occur and ways that those can be
handled using catch and throw and just
recently in these in this last example
how you can use try catch to combine
normal and and exceptional behavior
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>