<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2018 - Jarek Ratajski - Beauty and the beast Haskell on JVM | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2018 - Jarek Ratajski - Beauty and the beast Haskell on JVM - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2018 - Jarek Ratajski - Beauty and the beast Haskell on JVM</b></h2><h5 class="post__date">2018-04-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Sc5xzyDWU64" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today's presentation was not about the
trunk in fact mostly but about Etta so
hostile for the JVM and the first thing
I want to ask who here knows Haskell at
least to the point that can implement
simple algorithm I quicksort people
nachi ok that's cool
who knows JVM means SCARA Java to the
point yeah great who knows both oh
that's also great ok so this is the
thing that might be quite interesting
so Haskell for the JVM and yeah first
about me my name is eric letovsky that's
my twitter if you treat me you can
really throw me on this presentation
that will probably probably displayed I
don't know even how to disable it I love
programming since I wrote something like
for the Commodore 64 great machine and
even now you know my mind is spoiled by
basic I think you know in this
imperative basic with global variables
and all that stuff once you learn it you
can never unlearn it and I work as an
anarchy tact for ingenious company in
Switzerland if you want to if you ask
think what is the an architect the first
thing is what is Software Architect and
the one of the definition is the guy
that brings order to your project so I
bring chaos heroes and it's the reason
for that if you have too many architects
and they are too smart there is hardly
possible to do anything and you have to
fight with that with chaos so that's
what I'm doing if you if you are in need
of an architect's that's me now a
company ok we are done only do here's we
also do things for banks and insurances
I am general developer since like last
century but with the functional health
somehow you know I was seeing so many
problems with the this basic imperative
approach that I was slowly bought by all
this functional things and I'm even was
exposed to Haskell in 90s was very
briefly
ok so original the problem of
eita think is that there are a lot of
people they love Haskell and however
when we go to the typical company you
know hey sorry no way another production
that's how it ends and then you do Java
because it's fun yeah so are there any
solutions so I will show you something
that I'm ashamed and proud of it people
call it I write hostile with Java
that's my typical everyday program in
Java and as you see if you are Noelle
with Tuscaloosa fault flat map and all
that stuff it's yeah it's kind of a Java
however I'm using for instance list that
is that it's in other package that's not
the standard Java least that's immutable
list so it's like yeah resemble
resembles a little bit haskell way of
writing things that's not real sorry I
just skipped couple of slides and so
that's one way most of you probably you
know this way right Haskell using Scala
especially with Scala Z it's something
that is even quite fun and then there is
like quite strange possibility right
huskers using Haskell like who would
think about it so and then deploy it to
JVM and then even cooperate with Java
libraries or whatever you want and so
there is a company type lead that was
like founded I don't know year ago or
something and they basically their goal
is to create Haskell implementation that
works on the JVM and provide commercial
support for it so it's basically to
solve this business problem and mmm
however I'm not associated with my plate
at all
sorry and even I had to put this
statement I'm not an experienced Java
developer but I'm not experienced
Haskell developers so might be that I
did something wrong you if you see
something correct me I was learning
Haskell while learning ETA so I knew
Haskell before but
very very simple things even IO monad
was scary to me so you know how bad was
that and okay but that's right my best
I've been quite experienced with for
instance benchmarking Java programs and
feel like that so I know the details and
the bytecode so I used this knowledge
here and by the way we talked about
something that is not fully finished
okay it's like a 70% finished product so
of course not everything works perfect
perfectly but keep that in mind so very
briefly about ETA you see like some
sample Haskell code then you like
quicksort by the way there is test out
there because it's not real quicksort
who knows why it's not real quick sort
why exactly so by definition this is
this looks nice on a presentation but by
definition the real quick so works in
place doesn't allocate a lot of arrays
or whatever lists so it's it's not a
full it's kind of a fake quicksort but
it's okay to present it how beautiful
the Haskell is that's like example
number one we learn and you how to call
it you just use etta main HS for
instance if the file was called like
that then you there is a jar created or
recently it's called run main jar but
you will find out and you call it as a
normal Java program and you and you see
the result this is cool
this is easy however you write anything
more complicated with Haskell you
probably know either stack or cobol or
things like that so cabo is in term if
for ETA they've written something called
it las and it's basically cable and it
is it uses the same file format with
couple of extensions that are needed for
Java but if you put normal couple
project and run in a class it should
work and basically that's the way how to
run it and that does the standard way so
who knows couple yeah great so if you
see that you will be like at home really
everything is the same just the name of
the common stain and I won't show you
all the features of ETA I just tell you
this page called it
- which basically is for explains how
you play with it
all the things even basics of Haskell
but the tooling and etc this evolving
documentation page are really well done
how it looks and covers the basic topics
so I was going to tell you more about
interesting things that you will once
see in the first couple of minutes and
on the on the pages so my research more
or less so why is it is so special
because who knows other implementations
of Haskell on the JVM Fraga there is
something called forget existed for a
couple of years and but it's different
so what's different for ETA is basically
GHC so it's this the most common Haskell
implementation that we know and whatever
works on JC should work on on ETA that's
the goal and how it's done because ETA
might be considered kind of a back-end
for jhc what is the back end who knows
this STG machine okay
so brief explanation if you compile
Haskell code with GHC
there is a intermediate step where the
sources are translated to something
called
STG machine and SDG machine is kind of a
minimal language good enough to support
functional languages so it's kind of a
minimal functional machine and what does
what GHC do-- creates this source as you
can even debug them you can see them STG
source it looks like for instance this
is a kind of a simple machi you wouldn't
recognize it that the first look but
after all you'll find it that it's
really Fibonacci implementation we've
generated symbols it doesn't look
readable but it's just kind of a source
code and then in the next step after
creating this Haskell GHC creates a
negative code it's like two steps and
what it does it uses the same that's
official names find that spinless
tagless g machine and basically you can
even consider STD
LLVM or a bite was specific for Haskell
that's like in this intermediate step
was as what netted us it replaces the
second phase STG to the bite
coordination so a normal Husker
generates native code in that case you
will have generated the byte code for
the JVM so that's that's how the great
compatibility was achieved and how the
byte code looks like that's a typical
byte code for those of you that doesn't
know it's like kind of a generic
assembly code now there is nothing if
you know assembly will quickly
understand the the byte code how it
works it's so ok one thing though GHC
it's that was my lesson I always thought
Oh Haskell it's so clean so pure
language but it's only when you start to
do something really you'll find that oh
kamandalu using so many c imports or
whatever it's not that pure anymore but
yes for for a real projects you
typically want to do things faster than
you have mutable arise even whatever and
then you use things like like imported
functions from the from the C code and
even the base packages for GC like
string manipulation whenever they use a
lot of cycles and then it's the problem
what can in that case it'll do so what
does Eeta all these base packages are
replaced so they're basically all the
places where there is a C call they
replace with a corresponding Java
Virtual Machine function basically for
all the standard C functions there
exists something in a JVM that does the
same and you see like for instance float
dot HS is replacing is replaced for
hitter for a compatibility it provides
good enough compatibility so well who
knows what the heck ajiz just alright so
very shortly dependency management for
Haskell if you use because in a typical
project you don't want to write
everything on your own not everything is
a base on a models that you that are
provided with Haskell
you want to use some libraries quite
come some of them are very popular and
there is a hackage so like registry of
packages
the facto standard yeah there's a lot I
even put here till the letter B you see
how many and attack can use that that's
cool so ETA basically Anita you can
because it uses Kabul you can read you
can define that you depend on any
basically a hackage package however some
of those packages use see imports what
then so they have special projects by
bleep package and it's on a github where
they have patches simply for existing
like this is example for a text package
they have a couple of lines that say
please replace those sickle with Java
calls that are like corresponding this
solution isn't perfect for sure because
for every package library finally
probably you would have to okay for
every that uses some native C imports
you would have to provide that that's
not very scalable especially if there
are new versions created but it works it
is like I don't know maybe they will
generate one day this automatically at
the moment this is the way they do it if
someone asked to to asks to have some
support for other package and it's
needed to provide something they simply
add it you can do it even on your own of
course
so what is also important you know that
in a Haskell we have energy HC we have
lot of this die different compiler
extensions that you have to use
basically all I've seen I don't know
that many I don't even know most of them
what they really mean okay I know Bank
patterns like I read a little bit all
those appearing here that's from my code
but I haven't seen any that wouldn't
work and basically I by the definition
because of this statistics that most of
them should work okay so the summary of
this part I would say that in in ETA
Israel you are as close as you can you
can be with GHC Haskell
so the most people are on the JVM so if
you have like big sources written in
Haskell that already work in Jade she it
should be not much effort on mostly no
effort at all to port them to you
compile them with ether I can't
okay I'd create a test that you know out
on some snippets from the internet small
projects but never seen any problem real
so I had some problems I will display
describe later with my experiments but
yeah I will tell you why so now we will
dig a little bit into okay there's a
spying problem sorry optimizations that
it had us so one of the something that
we may call boy mantis who knows what is
a bad boy or man test for a compiler so
who had heard about it okay it's a
nothing that that's new less like it is
from 70s even think it was defined by 10
or so in while the Algol was still
popular one of the biggest problems was
to do recursion if you go into the
function that the arguments are local in
the function and not not Goble it's kind
of the and basically he defined that at
the moment he realized that lot of
simple compilers for algal can stand the
test so if you use recursion
they basically mix local variables with
global and because that was like huge
thing to provide local arguments for the
functions and so that recursion
resistance might work so with key that
I'll define it as a bore boy or men for
a compiler test and for functional
languages such kind of a test is if you
can do tile call optimization basically
if you can't do that if you don't
provide that oh the real functional
programming might be tricky and not that
efficient so let's talk about knife
fibonacci implementation you know this
that's one of the worst implementation
but okay it works for every like review
you have sold
good to know that but you can rewrite it
because this to use tail call
optimization on that it's not that easy
I will show later what to do but we if
we rewrite it like this who knows this
trick
oh sorry again have some we have yeah
this is very easy by the way that's my
second trial program in Haskell Annetta
written release oh and now I wanted to
check if tail call optimization work
basically I knew it should because I've
seen that they say that they support it
like so yeah and then I got okay and by
the way in Java it looks like this okay
so I know Java I know how to do
recursive Fibonacci so by the way how
much do you think Java can stand it
doesn't have tail call optimization how
many iterations on the reasons on this
machine
that's Java 64 right depends of course
it did yeah but just guess what kind of
numbers no more I was surprised actually
hundred thousand we are more or less
between hundred thousand and million
it's like finger you can expect on a
typical JVM you ran ok it exactly
depends because you can even set how big
the stack is so of course you can make
it incredibly big but the problem is
first this stack sizes are common for
all the threads so you make this big
your machine especially if it uses
multiple threads will be like incredible
memory consuming so you don't want to do
that in Java mostly but what about eita
how much distance in that case so I run
this for a verse tupid example and i got
this result and that was like oh my god
i just written one of the worst-hit
Bonacci implementations in my life
it's really convincing and the thing is
like do you know where the problem is or
do you see where I'm a drizzle back here
I just tell you - this is very important
for the story I spent like three hours
here analyzing where I made the buck
because I was really I'm not really
experienced Haskell developer till the
moment I run GHC compiler with the same
code and I got correct result
normal Fibonacci you know in that moment
I realized the bug is probably not in my
code
but dissing it ah that's quite
discouraging because you don't run the
compiler for the first time you're so
happy and then you have that kind of a
buck accidentally the peers that I
really hit the neck kind of edge problem
of the compiler of the optimization so I
posted the buck and basically I analyzed
I did some analyzes for the guys for
from ETA what was the problem server I
compiled the bytecode
I won't show you the data determined we
don't have that much time I will tell
you what this bytecode says basically by
the way there is a while loop
maybe so there in fact the worst I'll
call optimization done because we have
while loop that's exactly this this
place we have everything looking
correctly master is you know this
imperative programming with variables
you see the error now yeah basically
this code the implementations didn't
take into consideration that we might
kind of a swap or assign values so if
you do it this way basically the sum is
assigned the new sum and then free sound
like this previous sum gives the sum so
we have like that's how it made its made
exponential so maybe for those of you
that don't see the problem the solution
for that okay you probably it's not easy
to read but it's like from old comic
typically solution in the imperative
programming is just to swap two lines
and then it works so if you swap two
lines then it starts working basically
because you have you have dependency on
the variables there so that's that's how
to fix it now the problem is to fix it
in a compiler and basically my
expectation was those guys will fix it
for me but they've seen opportunity I
said initially is it probably no because
I don't really know how scary you know
you've seen my like skills in haskell
fibonacci and thinking about fixing
compiler of Haskell
written in Haskell while learning
hostile seems to be like oh my god and
then I even seen those things like code
Jen Mona's basically that's the moment
that generates byte code behind like
that was my like feeling at that moment
but all I spent like mouths digging into
WebSphere spring cold whatever this
cannot be worse than that so that's you
know I was totally surprised it took me
only two nights of my life but I was
able to fix it it's like I was even
shocked after how I said hospice
probably the most relatable language
because I was previously like fixing
boxing in a Java compiler Java Virtual
Machine I was in the things that are
more common to me and I wasn't that fast
so basically I fixed that back that was
with of course with the help of a
Haskell main developer with item in
developer who he was by giving me a
feedback and some hints it worked and
finally okay maybe I will show you the
result just to show you how good it is
how good I made yeah so that's if I call
here it was run Fibonacci you will see
this ridiculous number it's called on
100,000 you see how big number was
generated but it works it is a real I
I've checked it it really works so we
have tile
optimization although the level that JVM
with normal calls supports on this
machine and we are this means it passed
the boy or man test okay so I will go
back to the presentation okay there are
a couple of other things for instance
this is just a thing if you don't want
to rewrite your algorithm there's Finke
called trampoline it basically works in
any language that you rewrite your
recursive algorithm using kind of
objects done and continue and basically
you have external machine that runs it
and basically in a Haskell
there is a standard way of using this
continuation monad and the code would
now we go back to the original fans the
implementation of Fibonacci when you
have kind of like two calls but we do
have a mono monadic way and then we run
it with this and then we have it however
for some reason that it's not known to
me that much in a in ETA we have to use
this supplementary function that's not
this is not in the GHC it's called
trampoline and then it really works
perfectly with a bigger numbers of not
not hundred it's not a problem but
median is a problem so they have couple
of one built-in feature this is like
kind of a goodie that they provided to
make it efficient so it's it's already
quite quite nice when I well when we
think about performance we can think of
more like generic things so I will show
you first of all there was today I
talked about benchmarking benchmarking
is hot it's very it's really you have a
lot of pitfalls you can fall in and for
Java in the Java Virtual Machine they've
created something called jmh serve Java
micro burning meat micro benchmark
harness and this tool that helps you to
create a little bit better benchmarks
that might be quite accurate I didn't
really do it professionally I used J and
H however I didn't really had a good
test
up all those conditions all the result I
show you like kind of you know more or
less accurate but don't perfect I this
is not finished product there was no
like reason for do that so what I
measured is this quicksort for instance
naive quicksort in ETA versus knife
quicksort but more or less the same way
written with immutable lists on a java
with something very very by the way if
you have to write Java use this
favorable aerosol immutable collections
it it is almost like Haskell okay there
is the wrong way but still better than
standard okay however I also use the
kind of a real quicksort for ETA that's
a I found this sauce a summer on the
internet so basically copy paste I
wouldn't be able to write something like
this on my own
even now yeah but this is a real
quicksort for a Haskell that works on
GHC and by the way real quick salt for
Java oh that's kind of a simplification
by I wanted to test it the really hard
versus just the best implementation
that's provided by wave library okay
that's the result more or less as I said
you see that it is slower on that case
in we look at the quicksort the naive
one you see it's more than twice as slow
for the real quick sort it's a little
bit better
it's like 60% or 70% it's hard you know
it's it's not accurate however you have
to keep in mind that I used it in with a
jmh benchmark which runs on a Java and
what's here for instance I copied the
results from Haskell to the Java there's
additional step so Haskell eater had
more to do because I had to translate
Java list into Haskell list so this this
result is even quite ok and by the way a
couple of weeks ago it wasn't that good
they all they do very good progress with
performance so the other thing that was
reported on the on the issue list of the
ETA was something called 12 Queens
problem I don't really know this
someone just posted this and told that
it's very slow on ETA even though on GHC
it works way better on a flagger it
works also way better so I tried to help
and I posted what's the problem problem
was for instance not optimal bytecode
and couple of stuff I didn't really do
any fixes here but recently like a week
ago the developer of ETA written to me
that he optimized couple of things it
should be better right now so I ran it
like yesterday at the moment to my
surprise ETA was better in that in that
kind of a micro benchmark done Fraga
which is like this is a great progress
in a couple of weeks it's still way
slower like comparing to GC however this
benchmark was done very very wrong way
because I it's even for the both ETA and
frigates very unfair because I take into
consideration JVM start and all that
things that shouldn't be really done
what I just did something quickly it's
more or less shows at the moment where
it is it for me it's okay previously as
far as I see from the issue is it was
like kind of a minutes for ETA so and by
the way I have don't have witness slides
I still know couple of things that can
be male can make it a faster if they are
implemented still the bytecode is not
perfectly generates the generated and
sometimes
quite often JVM refuses to compile it
into native because yeah so this
bytecode is kind of scary I won't
compile it I will run in interpreted
mode which means very very slow is the
problem is still there and they don't
use the they are compatible with Java 6
they don't don't use I never invoke
dynamic which makes some things faster
so there are two easy kind of easy goals
that will make that faster I can say how
much faster but measurable faster 20 30
% I would guess
ok now that to the point of a Java
interoperability how how we cooperate
with Java so basically in etta you can
in
for any type to the to the Husker this
way like this is java.awt color and then
we can can import any function and this
what you see at then is something called
Java monitor a couple of ways to import
the functions you will see that in the
ETA tour so I don't want to cover this
but basically you work with something
called Java Mon a few you know Java is
unsafe it's like new tables so we hide
it behind monitor we can by the way use
still I own one out but fancy ways is to
do it with a Java monitor the first
parameter is basically an object class
so something that you have as this in
Java okay so you can also export so any
functioning okay not any but functions
that export Java objects those basic
lira or integer strings can be exported
as static functions you have to jump so
there are different ways how you can
cooperate with Java so one of the ways
that I think it's the most like targeted
right now you have everything in Haskell
you just want to deployed it on the Java
infrastructure so they've written
something called W AI servlet which
means we part our application as a
servlet deploy in the Tomcat JBoss
whatever all this you know very very fun
in nice application servers are
something called VAR war so w AR and
it's there and then it was basically al
Java is like kind of only run thing for
you of course you can run it as a
standalone project which is not that
typical for a Java
still but you can do it there's a
different way I did you define all the
classes your domain in a Java and then
you import it in a Haskell and then you
manipulate like write your business
object business logic with a Haskell
with the ETA so this is a kind of a
strange way by the way a hint if you
heard about Java beans you basically
don't have to use that anymore and I
have something called that poem check
punk check is my like standard check for
every framework I use can you implement
pong with that
so for a language because the the reason
for that is this pong was implemented in
1973 and my like I do a statement if you
can't do Punk with something it's not
ready for 2018 because it's not even
ready for 1973 so that's my like pass
check if something is really sensible
it makes sense to use it okay so sorry
it's just a moment I will go to the to
my machine yes that's not easy on the
screen I'll just show you my Punk so
basically this is the this way all the
all the sources all the classes
definitions objects are in the Java and
we do only manipulations I will show you
later in a in a ETA and it works just a
moment I just showed you before there is
even kind of a login to the screen oh
thanks cuz you're a shit well was so
nice so this is a real multiplayer but
by the right front end is written in
scala yes but I'm here it's implemented
only back-end with the rest service okay
so I have to skip to the player - okay
and bounce the ball okay I did it
almost however I think the dimension of
the plan of this of this is not
calculated correctly okay I won't show
you much by basically this punk works or
maybe there is a back I don't know what
like that I will can fix it now we I
can't do it back in a hospital that's
what I believe okay so we have this and
a couple of funny things so how this is
the Java object definition by the
weights is I'm using final variables and
everything so this is immutable
structure
I have annotations that make it easy to
to sterilize it to JSON and back and
even to the database whatever
so all these features from Java I can
use because I have Java objects and then
I import like definitions what fields of
order and everything into into hospital
and then I for instance define because I
object that was called gain state so
basically where is the ball what our
players what is the score and then I
create in a Haskell function that is a
from a game state with kind of integer
that's like time that passed random from
Java which is my random generator what I
use and then IO new game state and it
works so you've seen that funny thing I
learned while doing that linguistic
determinism so that your language kind
of limits what you can think of like in
there's this joke about ya guys thinking
how many how many words the the the the
people from suburbs use for grass or
something like that for long okay
nevertheless it's like I get this this
in the code of on Java so basically this
Punk was first written in Java
that was my Punk check for a Java and I
those two function basically they were
like checking if the ball hits the
puddle of one player or the other has to
score basically they're in the most
important function and both of them were
kind of a similar by the structure but
they were different for every line so
you see there is some kind of similarity
you would like to unify it but they are
different and I in Java I've never had
time to like unified it get rid of this
kind of a copy paste in the moment I was
writing this function in Haskell
instantly I found okay I'm not really
sure but it looks like I can use lenses
here because basically where is the
first player where is the second player
how to modifying them in kinds of
scholar so it's like you just think
differently in the see opportunities you
wouldn't seen in a in a Java for
instance so by the way however I still
were looking at this Haskell code I
would see it's called I would call it
somehow hava because you even by the
times I'm using you see that I'm really
I like to write a lot because of my
experience I like the big names I would
even give the bigger one but it wouldn't
fit the screen so it's like even my high
school code now still smells like Java a
little bit and there's other way of
cooperation with Java what if you want
to be very very clean and you want to
use data structure from from
skill like mmm you have like everything
defined in Haskell and Java is only
controller I will show you such case for
instance game of life I've defined it
that the game of life has Sal with a
core the roles that are displaying that
is and then there is something called
stable pointer by the way the same way
works in a GHC the cooperation with C
code so there's basically the stolen way
of cooperating and then there is I have
this function like from the game of life
you know come waking of life I can from
any state create another state this
whole whole thing is done in a Haskell
the Java is only like making the cost do
it now for this state and in Java all
those states look a integers it's kind
of a handle to the current state so let
me show you that like I will now that
that's gonna be funny
because I don't even know where this is
it's not this code this is which code is
this life job okay so I will just show
you how it works because it's nice so
this is the game of life where all the
logic and for instance is written in
Java in in Haskell and Java has on the
culture I can go do like next step and
then even drawing on this is written by
Haskell calling the functions on on Java
bitmap like and then at the end of the
Java bit map created a buffer buffered
image and we have like this funny game
of life written in I don't know hundreds
of lines of Haskell and it works it
works quite fast quite okay so you
should see even some colors combination
later clashes okay so we have like a
couple of ways that we can work with
okay I will stop this or I will just go
to the presentation okay so a couple of
problems I had if I am using a lot of
Java objects this kind of a tedious to
import all of that to to the Haskell
like every fraction I have to import so
if I have a typical Java object like you
know hundreds of
functions it means hundred of impulse
however there is a tool for that it
doesn't work perfectly at the moment but
it's in the development so it will
automate this work the way of this
passing state between Haskell and John
Rivera this table pointer that was
something I spent a lot of time and
finally when I posted what I need as an
issue
the developer of ITA's sent me this
solution
so now way maybe it will be in a
documentation in a figure or something
like that because it's really quite a
nice feature meantime I found another
bug that I had to resolve with exporting
function that was also very critical in
the compiler with a generating bytecode
funny because there's some kind of a
stock problem mismatch in the stock
funny thing is a Java Moniz so you know
working with Java as the monitor I like
it
however it's I think it still misses
documentation so maybe one thing that
people ask me is typically at a versus
Fraga so surely at this moment I can
sell Fraga if you had some experience is
more mature for sure it's already frog
that has couple of years in their
operation with Java is eyes way easier
Fraga it's like okay well maybe it's
just easier with Gigi with it I it's not
that nice I will want to give you
details but basically that however the
Fraga will probably will never be close
to GHC so if you don't have any Haskell
code you have not really experienced
Haskell developers Fraga might be better
solution for you to just do kind of a
Greenfield but if you have experienced
people you want to use documentation you
want to use hackage you already have a
code base in a Haskell then probably
flag is even no-go it's too many to
adapt it to be working especially
compiler extensions and things like that
so then G it is way way better and the
I'm just finishing slowly so the thing
is is it a for you so this M the
in the state of the eternal the version
is 0.71 point something and it's not
production quality at the moment for
instance there is a third very like how
to call it
very nasty compiler back that I
published kind of a MMPR to that that's
somehow solving but no one can explain
why it's solving even I the problem so
it's not accepted but however it means
the still you can find especially if you
do some kind of edge cases you might
find problems so however if you think
about going to production with ETA just
ask tightly I can't say anything about
it when it's be it is going to be
released officially what kind of
commercial support you may expect they
want to do that I have no idea about
conditions but if you want you are
thinking to go into production for sure
you have to do that at the moment it's
nothing that you know millions of people
use that it works no if you are
Haskell developer and you have this
problem you want to deploy on JVM yeah
try it now
it should be fun enough and easy for you
it's just no brainer you typically
install ETA you even run the same
project with it last instead of the
cobble it should work if not typically
this is something stupid and small to be
done you may ask the developers of it
you may ask the community of it I will
show you later and if you are Java Java
developer and want to play with
functional programming it's also very
nice way because you might use any
typical Haskell examples and they will
work for you and you can learn Haskell
and that's how I learned at the moment I
consider myself at least so so Hospital
programmers know not total not anymore
after like two months about it a
community that's is what is cool this is
a very very small community very small
very small I don't say it's wrong men
its couple of them but one of course
Rowell is like the main developer he
knows everything other like kind of help
him around and do useful things
however this committee is great like
they have guitar and other tools they
are everything you have links on an
ether page you go there you ask the
question and like I want mostly our you
get a answer that helps you really so
they helped me however they are so
helpful that I was kind of encouraged to
help to like you know react on this was
this positive energy so that how I was
involved in the ether development a
little bit at least in a terminal of the
small bug fixes and you can help this is
really nice thing to do you can even
help it away exactly as me learning
Haskell and use on a Haskell compiler
what could be easier to do Olin and
that's my statement a future of Peter
and functional programming in the
business that's a one way we can do that
we can achieve it we can teach our
colleagues functional programming you
can show with them it works on our
production that's that's in your hands
thank you
can you comment on the interoperability
with Scala instead of Java so ok simply
it works
the guys that exactly I would say even
more people do that if you if you can
export it to Java of course it can be
used in Scala and vice versa and there
are example projects with SBT config and
everything that do it that show it it's
a no not a bigger problem at all ok
there is a high I have a quick question
because my understanding is that each
tablet was founded by a couple men and a
woman and they both are involved in the
development of the of the language so my
what I see but I might be wrong the
mostly there ah he's like involved in a
development and the woman is like mostly
involved in a marketing all that stuff
but I don't know these guys that's my
impression sorry like I haven't analyzed
which lines were coming from there does
it preserve laziness yes yes so in fact
I haven't shown that one of the slides
before like let me go very quickly it
works the same way how you would expect
so now if I go very very to that point
of showing you the code that is
generated it generates closures that is
basically like a state of lazy
computation and it works everything on
that let me show others exactly you see
here that's a generated function so for
every value in fact have a closure that
finally at the end is evaluated so it
exactly works this way like totally lazy
and Bank patterns if you don't want to
laziness also work so it's like like
this ok thank you
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>