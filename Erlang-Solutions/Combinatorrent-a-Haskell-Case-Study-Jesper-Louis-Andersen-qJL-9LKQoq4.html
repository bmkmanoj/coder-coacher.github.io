<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Combinatorrent - a Haskell Case Study: Jesper Louis Andersen | Coder Coacher - Coaching Coders</title><meta content="Combinatorrent - a Haskell Case Study: Jesper Louis Andersen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Combinatorrent - a Haskell Case Study: Jesper Louis Andersen</b></h2><h5 class="post__date">2012-06-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/qJL-9LKQoq4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so if it was the overhead projectors
because it's a bit unstable yeah so I
might have a jump here and fix it later
I'm going to talk about a project I did
couple years ago or coming to target it
is a Haskell well
so coming to time is written basically
for that specific hazard implementation
which is the GC implementation the first
chicken horses in 2009
it worked about two and a half months
later the basic idea is that we
implement something an avatar like that
is we read them in most of the urban
semantics transactional memory in
Haskell and that is a conscious decision
so there's other kinds of ways you could
do this in a school and that's very it's
a very important one to me I'm basically
copying what there's about four thousand
point one so the question is Joe did I
do this because I have previously
implemented at all in line or was it
just that this so I have I I need now
you I'd really like mrs. Matthews I'll I
really like the idea of having lots of
processes we visiting each other that is
I believe this this is my car feeling it
is
do it and don't really believe in the
other kinds of way of doing it so it was
basic just focusing on how queer get
this kind of dynamic process for me how
good I was
I wasn't knowing person at that point in
time so I did the only thing first I
might get this one and then I actually
went back and redid some of the other
parts because of this I get another so
the acknowledgments here are that this
is not only my work thou pupils in there
that has done civil comments in this
project so I'm going to mention them
because this is the merit that we use in
both right
this is merit so it's important to
mention which people have helped you
doing these things so I did it did it do
it well I have a wall that says normal
standard system programming language to
a given proficiency you need to
implement something in it and it has to
be done with Fibonacci doesn't count
that's because priori before you look at
the language you might be able to lean
at the semantics between after soon
second see yeah like that I don't like
that but then doesn't implement a queue
how do you even solve this kind of
problem so after you've done such things
you might have an idea and then good
Chinese original problem so I don't you
go out there is fake I think so now I I
don't think they they are finished it
but I'm not sure so it might be the case
that definition that out there is a half
implementation research coming trying to
be shorter than u-turn at this point in
time that was the others are clients
there's no limitation on this one
because it's this something is wrong
there that there has to be something
wrong either with the way I make showing
it or something because that amount of
lines is more than the speech wasn't
this big short code so something is
wrong with her
it isn't the same teacher said the
reason the Java client is a large is
because they do a lot of stuff in other
kinds of things they are added on a
pictorial so that's it but I don't think
that they really I think it'd still be
more even though if I were spare to them
a certain kind of sense that they would
probably would be more than the others
but not so extreme right yeah
I never done it that takes more time
right you have to go into the : d gonna
figure out what exactly are there that's
because so the dark pieces are that some
of them depend on external diapers
so these turn lighters are the dark
pieces yeah perhaps so this is bitter in
one slide what are you doing
well the first part is that you have a
try and fire which provides identity and
integrity for a area of bytes
essentially so it is a fingerprint for
the array of bytes the goal is to
transfer that area bytes from some
clients to other clients it's a content
distribution problem we need to
distribute that area fights around
around the different points the ones
that wants it needs to get it from those
that has it the second part is discovery
that either you go to an HTTP shop or a
tracker and you obtain a list of all the
other parties that wants this thing or
in a gopher distributed hash table and
make the same query in order to get the
information who it also wants this kind
of thing and then when we have discard
the other peers the other guys they
neither have the final wants to find you
do an exchange phase when you connect to
them run a separate binary wire protocol
against them and you use that to
exchange small pieces of the whole array
and the trick here is that you
essentially paste the basic idea is that
you use the identity thing to try and
fire to check integrity amongst these
peers whenever you get something from
them you use that interpret this thing
to make sure that you actually got the
right stuff so
doing this in hostel Congrats Appel ISM
are two different things they're not the
same
many people conflate the two and say
that they are the same but they're
really not the reason is that
concurrency has to do with expression
how do i express non-deterministic
behavior in my programs parallelism has
to do with speed
I want this faster I want this with the
180c I have one higher fruit in my
system and Haskell is interesting
because it has it is essentially a
research children it has many different
approaches to either pecan currency or
parallelism or perhaps both in a
combination so they have or they have an
eval Pomona's as something core
strategies repack separate our libraries
that allows you to do heavyweight
computations one of those allows you to
use the GPU to compute stuff but we are
not going to use that because that's
parallelism and not concurrency and
we're trying to solve the concurrency
problem so I basically jump onto the STM
system so that is a software
transactions basic idea is that you have
a transactional very evil you can
operate on that atomically
so you can say say I'm going and you can
actually do that for multiple variables
so you can say read that very write it
there and do it in an atomic transaction
and that allows you to build channels so
now I have essentially two threads and I
have a channel between them Americans
send messages or that channel in one
fret to the other so that is what I use
as a basic primitive to build up the
same act alike it's not really access
because you have channel so it's more
like a CSP like instruction or what this
missus religious thing and the reason I
need channels is because enhance call
everything is statically typed so I need
to know the type of the channel so that
is the reason for why did your
construction of having channels
it was preferred to say
during construction waste process is the
thinking of message engine right so this
is basically the quick overview of
different frets in the Haskell thing and
it's a hyper graph that tells us whom
communicates with whom and it's not
important to take anything from the
picture it's just a picture right
there's nothing in there you have to
understand necessarily then of course
since we are looking at the line we have
a process hierarchy that is essentially
the supervision tree Haskell has a
concept of an Asian Cronus exception
that is I can send an exception from one
thread to another and have the other
thread getting that I use that to
implement implement links centuries so
in order to link to processes that use
agents exceptions to make that happen
so I wrap a process just that if it
crashes then it'll send an asynchronous
exception to his supervisor saying I
died so now I can begin building this
kind of construction of things which I
want these two things to get under
hypergraph trust this tree is called a
high Biograph that was actually some
research and pie graphs by robin milna
who's dead now did most Robin did most
of the standard ml work back in the days
this lady as he was interested in my
graphs it's quite interesting to see how
you can map Haskell or early actually
the early process of mantas onto my
curves that is actually pretty
interesting I'm good to mention it here
what is it that makes it cooler still
doesn't ask well Haskell is one of the
kings of abstraction you can write very
abstract very such synth programs in
Haskell because the language is a strong
it has very strong type system it's very
expressive and it's not a proof
assistant so you cannot make proofs
about real proofs about your program
you get very close so that is your types
well now if you exploit them the right
way in code invariance about your
progress in other words if your program
passes type check are there certain
classes of errors that cannot occur in
the program in the anyway the types you
which I tend to call it is what printed
types do you have in the language and
how can you construct new types out of
them so think about burling's
binary there string or the lists the
integers of the float and Haskell has a
pretty strong types of meaning that they
have many different kind of primitive
types you and use you can build up more
complex types from and then there's a
good community and of course there's a
Haskell version of a quick check which
is pretty nice so parts of this thing
you're gonna be trying to find is
actually quick shipped so the protocol
parts a quick check and stuff like that
because that is how you check that your
protocol in code and protocol decoder
are actually working the right way so
another really cool part of our Haskell
is that this do you see implementation
is the state of the art compile and it
produces very fast programs so what
happens is that rather than having to
need an if for a bit far a lot of things
that is rather than have to put into a C
program that does it you can just do it
in Haskell and you can get a full speed
of C in Haskell so that means there's no
gap between oh this has to run faster so
I'm going to implant it and push it down
and go into implemented in C knowing you
don't need that we just implemented in
Haskell and then be sure that the
compiler will optimize it for you
that that is actually very helpful
because it also means that there are
concurrency primitives can be in at a
lower level right they can now have
concurrency Princes that is a level
lower and they can hang on many of the
high level constructs in Haskell
because the language is faster so they
do not need to have as big a C runtime
behind it much of the networking stuff
much of the IO stuff is
in pure Haskell in Haskell and that is
an advantage and utilizes as well and
the other thing is that since you have a
good compiler that actually optimizes
for you it means that abstraction is
building abstractions in your programs
to understand them better that's easier
and the price tag for doing so it's not
as high as it would be in in savoring it
also means that if you build combinators
that small functions that combine other
functions that's cheap because the
compiler will optimize them for you so
the takeaway here is having a compiled
language actually helps because it means
that you're not paying for building in
abstraction in your code it's aesthetic
a statically typed language so that
might sound like like a bad idea but it
has type inference so you are not
writing the type explicitly the compiler
figuring out the types and then it fills
in the blanks so to speak you can write
a type but then it just checks it
usually you are not writing very many
type space new code because Italy very
most at work
there's very little boilerplate at the
time I really have to write in order to
make things work
due to this inference and there's a lot
of clever tricks that can be played on
this type thing so I have some examples
for instance in Berlin we have a rakish
module so we can garden we can compile a
regular expression we could run a
regular expression match against a
binary say and we have an option this
way we say we want back any binary or we
want back and list of indexes the
offsets inside the binary where we have
matches or we can say we want to string
back now in in Haskell what they do is
that they have this nice concept called
a type class so they say we have a type
class of possible return types from a
regular expression match so that means I
don't have to explain explicitly what
return
I want I just assumed that I get the
right kind of answer and I just go on a
program oh it was a binary I've wanted
so I just programmed in the code as if
it was a binary and it'll work because
the compiler can figure out oh that must
be a binary by inference and then go in
and say do I have an implementation that
corresponds to the fact that this is a
that it returns a binary so that means I
don't have to in many cases here I don't
have to explicitly tell the system what
I want out I can basically just make the
type system figure it out for me and
then use that thing as a as as if I had
it and that is good because it means I
can change the implementation later
without having to change this if I
decide that oh I didn't want to binary
I wanted to straining instead as the
match output I could just use a string
there and I didn't have to change any
part of the other part of the code it
will just work because the compiler
would figure out oh he's requesting
another time so I need to use this kind
of construction instead if you want to
know more about this to do about type
classes in Haskell you can do it a lot
of these things and it helps because it
simplifies the amount of code and things
you have to write so another example of
using the type system is that this
software these stuff that transactions
are what is called a MILNET in Haskell
so rather than explain what a Moonen
deals I'm going to explain what it does
what it does to your code is that the
type system can guarantee that we cannot
by accident do something bad with a
transaction the only way we can solve a
transaction is by running it on a
function called atomically that
basically execute this transaction so
I'm using the type system to protect my
code in certain hours in this case a
wrong use of
transaction so those are the kinds of
things you might must have in mind when
you program this language is it's nice
that you use these tricks to make sure
that you're not do not by accident make
a mistake in your program here is an
early certified Erlang receive message
thing inside each aren't so this is the
Erlang btran version so essentially what
it does is it it decodes a message on
the wire between two peers and here it
gets a peace message which is just a
number it's a single byte that Keys
macro is a single pipe with the given
number for the peace message then it has
an index that again and then some data
so it's part of a transference of the
thing we want what this bit right thing
and then we just decoded into a piece
something the same code in Haskell looks
like this so it is much larger it's
about the same size
okay we need to decode the verb the
first piece explicitly first and then if
it's seven it must be a peace message so
the thing there says construct me
essentially the same as this thing here
says construct me a piece Topol where
the first element is a 32-bit word the
second element is a 32-bit word and then
i have all of the remaining stuff there
so this essentially construct it
both decodes and constructs the thing in
one go now what it is this is the
interesting thing that thing is known as
an applicative functor it turns out that
parcels like these can be written as
positive combinators positive
combinators can be made such that they
fit into a specific scheme and that
structural scheme is known as an
applicative fonta so essentially if we
look at did we get back that
that operated there and the operator
there and the other grader there they
are part of an implicit function their
rules their operators unlimited
functions this thing works they
basically they are like a an abstract
it's it's they are abstract operators
that work on all application functions
so as soon as you know what they mean
structurally you can use them in any
etiquette fountain the program so it's a
vast generalization of what this program
does and here they're useful passing but
you can use them for all kinds of other
things so that is a very nice
abstraction because to the seasoned
Haskell programmer when he sees this he
knows exactly what's going on because he
knows that oh that is an app ticketed
and it must have these kinds of
structure that kind of structure which
is operates on so I I can just and then
everything is way easier because you
have some prior knowledge about what
this code does another interesting thing
is that go back to this thing your own
version there is an implicit assumption
that what we get is a binary because we
have matching on a binary so it must be
a binder we've got in here this thing
has no assumption that it was it it is a
binary it could be a binary but it could
as well be an AO list and in fact this
thing works on io lists or the
equivalent of a nihilist so I can work
with any kind of data type for which
this matches and works and I don't have
to change the code the code stays the
same but I can use it in an iOS context
if I want and that is very neat and you
don't get that an early you cannot get
this thing at all and you have to change
you have to run and I noticed a binary
on it first now it's a binary now I can
match but that means copying that means
extra work here I can just work directly
on the IO list because I can hide the
fact that
working on a nihilist and I do not need
a couple so there's something here I
think if you to breach it O'Keefe's ash
like patents proposal and implemented
that fully you would get this but that's
just the case I have so so that I being
used out of it but make sure that yeah
yeah you could write you you could write
it differently but then then exactly so
there's a lot of different ways of
writing in that might solve it but still
there's some kind of limitation here
when I do a binary patent match it has
to be you in a binary this thing can you
can write on the particular function or
that works and Jason structures or
another kind of input that that it
doesn't have to be a memory for B string
do binary pad matches this range why not
and that kind of makes sense right
so that's possible I mean have support
it's much harder to pull all the neurons
because it does not have the same kind
of expressive machinery so Hanna and I
got most mostly B's so mono voice I was
going to give him whatever example
because more examples the tool so
Marmite is a mathematical definition
it's what it is it is a set and then
some operator that operates on the set
the operator must be associative meaning
that the order of the parentheses does
matter
there must be an element E and E set
which we call the neutral element and it
must have the property that if we use
the operator with the neutral element
its it really is neutral with respect to
the operator so a good example is if I
have two strings and I concatenate them
so the set of all strings and the
combination operator forms more light
because if I have some strings and I
concatenate them I get a string and the
inter string is now the neutral element
here because if I concatenate
the empty string train is drink they get
the screen so that matches that another
example is the integers and a plus
because zero is now the beautifully
lamented if I add 0 to anything I get ya
so some it's so many just since I did
math right you're right if you should be
really precise useless it should say
that the operators closed on the set it
might be implicit yeah because you're
running the operated on yeah so here's
an example of how I use it in
combinatorial this is yet another
express expression example so what you
do is when you do a handshake against
the pier you get a list of extension
numbers we get a list of extensions that
the foreign peer support then you
handshake and now you are in sync with
what extensions are supporting their
number so what you want to do is you
want to use the right extensions of this
communication so what you do is you
would map each number to a record which
I call F 1 F 8 8 17 here and those
records contains so they have records
like running records they contain
functions and each function in there is
a loop function meaning that at certain
places in the standard code flow I would
say here is a good place go to this
record go to a record look up the
function there and apply it in that pool
place so essentially that is that is the
first thing I'm adding these numbers to
a set of Records and then I have a pair
wise composition of these records if I
have a record here with functions I have
a record here with functions I can post
those to record by saying if I if here
in G here I can do if composed with G
that is now when you record so this is a
way by which I can take such two
extensions and compose them and that's
just the pairwise
composition inside the records and there
is an identity record that basically has
the identity function in all hope points
so the set of all these extensions plus
the composer forms of art so what I do
in this find is I say okay fine
I'm handshaking I get a list of numbers
which is the list of extensions I map my
record construction onto it I run this
income cap which basically says use the
mono it's composer function and now I
have configured that particular
communication such that it works for
exactly the right kinds of extensions
and it's very easy to extend because as
soon as I have the new number
implemented as if something I have
support for that extension as well I do
not have to go in and change the main
flow code at all in order to add
extensions to this this client which is
pretty nice so every time I have a new
extension it's a funnel so the code I
already wrote I don't have to change
that at all what is the bad thing the
bad thing with Haskell is that it is
that easy this is my personal opinion by
the way I only like lazy evaluation
it creates small irritating space leaks
that are hard to track down on your
province so that means if you have a bit
rank line which is long-running runs at
several hours and it has a small space
leak you are not having four kilobytes
of space used then you run a heat
profiles this is the trait for fixing it
you run a heap profiler you use to
figure out where these you add some
specific strictness annotations so it
executes certain parts of the code
straight and hence you avoid these
families which is essentially is when
that happens you can do stuff like this
so what I did in order to hunt down all
these kinds of leads I did some small
spark line things where I could see that
users of the system so the x-axis are
new commits so as I commit and fix stuff
the peak memory thing goes down and the
same productivity is a measure of how
efficient of how much time has been the
garbage collectors injury so I want that
to be pretty high because I want to
spend most time in program which means
that it's close to 1 and as these time
as possible in the calculator so that
dip there where it's all 14th that's
when I did about right so now I'm
creating vast amount of space and his
I'm calculating all the time and the
last thing is I'm measuring the amount
of CPU seconds I use per megabyte
downloaded so that is a measure of how
much CPU time am I wasting in order to
get a megabyte down from someone that is
a measure of how efficient I am you can
see I at some point I got all leaks and
stuff fixed so then it became actually
performing so you can say another
problem is that there are some stability
problems I think that barreling compared
to Haskell burning is a much more stable
platform it changes more slowly yes but
it is more stable platform and then
there's the problem that some libraries
that Haskell are complex very complex so
it's hard to actually understand how to
use them takes time understanding a
library and how to use it and that is
not necessarily a good thing so
performance missions so after two months
of tuning on and off mortis I got it
down to the numbers as show before and I
went back and thought well I haven't
heard right it's unoptimized but this
let's do where I wanted says let's do a
benchmark and they are out as fast as
their body performance so there is
something in my approach perhaps that
could be
meat or children better or burning is
just a very good platform when you are
doing massive communication yes so what
you're saying that that that it's not
unexpected because most of it is IO so
another way you could see this is that
since they are mostly balanced out to
each other it means that actually
Haskell's IO implementation is roughly
the same as earnings or they are around
the same ballpark in performance at
least for this though one should
remember for from returned actually that
is a considerable CPU binding it's not
entirely CPU bound but there is a lot of
computation you have to do all the time
because whenever you receive 16 K you
have new computation to make so it isn't
like in a HTTP server where you can just
basically push all the works of the
kernel and then forget about it when you
have same file you cannot do it here you
have to interact and do recomputation
all the time and then actually after
that I optimize some of the earning cuts
and now the your version is faster so
this and here are we're not really
measuring so I'm on and on a crappy DSL
line when I'm testing this so I'm not
really I'm not being bound by disk which
is normally the thing that binds you in
in between clients because you have a
lot of random sees and I'm not being
bound by IO because I need is a line
cannot provide enough to bind me so
what's left is how much CPU time am I
actually used and the funny thing is I'm
using roughly the same amount of CPU
time so I don't know if I could
interpret it in in a different way but
but that's what I see at least so some
lessons learned take place in a series
from the start because I didn't in
at least if I had taken a series from
the start I would probably have begun
laziness testing much earlier and that
would have mean meant that I would have
had less things to focus on when I went
when so it would be I would make a
change and then I would look to that
change and say if there's a leak it's
probably in my recent change mine
that would have been easier to do and
then be careful when choosing librarians
the reason is that before I did this
stand up a bill this is all layman
language has a station called Cardinal
there is a concurrent email
implementation for Haskell's I about had
he used that but it turns out that that
implementation had a lot of problems so
I was forced to change to this HTML
instead so be careful when choosing your
libraries yes
yeah that was yeah but but I can't
remember if that is about concurrency
parallelism because that's that's the
difference you have to make so so
whenever Haskell people are talking
about this they might actually whenever
they have a new cool library out there
it might be a parallelism library so the
computation is actually deterministic
they're doing the only thing they want
is they want to say compress their file
on a course but they're waiting until
that compression is done and the program
cannot do anything else before that
compression of the fine is done so it's
totally deterministic they just want to
exploit the fact that they have a course
in the machine that that that resolve
case there's another thing there is a
project which designer Payne Jones make
which is called cloud Haskell which is
an attempt to look into what is cool and
early and implement that actually inside
Haskell and that project came after my
working so this is a very interesting
project they have to check out if you're
a has forgotten want to do stuff with
this yes are there other questions
this one from Thomas
Yeah right
so the Thomas question is that if if I
had if I wasn't panicked by IO either
Network at this guy what would then
happen so I think that one out of two
things I I'm guessing one out of two
things could happen
one is that Mike so one is that you
might have an advantage because you're
processing data and box of money all of
a sudden so it might be that that for
instance Erlang is paying more upfront
in order to be better for the parallel
case or be better for the high/low case
later right or it has to might be doing
it same so the idea is that that you
might have bad numbers at a dull at a
low load level but when your own level
goes up that performance graph might
actually change and I haven't done the
measurement so I do not know but it's
very plausible that if you begin loading
these systems then this is you bound the
CPU powers might be very different
because because of this fact that some
of these implementation might pay with a
more expensive data structure with
Smallin for a data structure that
performs better at higher and I could
imagine I died it's plausible to think
that arraign would do that for instance
because it's built for that kind of
thing
the CEO the assets of the IO load so
when I for instance if you are you
saying so a good example is if you're
using a pole or you use the polling
feature the the kernel poll feature in
Erlang you change from a select based
thing to an epod basting and the
difference there is that the select
based thing actually performs pretty
well if you have a lot of sagas out
there where there's data on all of them
but if most of those suck it's a stale
idle doing nothing then equal wins by a
large margin all of this construction
because it only gives you we select you
have to shake everything so if most of
them I active that's okay to check
everything with with a poll you're
getting total oh it's only number five
and number seven that actually got
changed so I only have to shake that so
if you have say Webb targets where most
of them are idle all the time then an
equal based solution is much better and
the select thing would actually if
you're really moving data here the
select thing would work so yeah it is
about network loading or services if the
network load is different it might have
different kinds of performance
characteristics but it is really hard to
say without measuring what the
particular performance characteristic
would be
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>