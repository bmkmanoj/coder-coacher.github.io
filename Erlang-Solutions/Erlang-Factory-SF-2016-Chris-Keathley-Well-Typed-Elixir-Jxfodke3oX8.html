<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2016 - Chris Keathley - Well Typed Elixir | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2016 - Chris Keathley - Well Typed Elixir - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2016 - Chris Keathley - Well Typed Elixir</b></h2><h5 class="post__date">2016-03-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Jxfodke3oX8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">how's it going awesome y'all need some
extra coffee or like I can wait yeah
it's true yeah I went out there to get
some and they were totally gone so if I
fall asleep halfway through this y'all
come wake me up alright so I'm going
talk about a well typed elixir so what
are we actually going to talk about
we're going to talk about why I think we
ought to care more about types talk
about types 101 and dialyzer creating
our own types in elixir type composition
and then kind of we're gonna try to put
it all together and do something sort of
real-world at the end so why do we care
at all about types who here is I mean
I'm so I come into elixir kinda from
Haskell background a little bit because
I can I say a little bit because like I
don't actually do Haskell in my in my
daily life because um I think I've met
one other person in the world who does
Haskell in their daily life like that's
not an academia but you know so I when I
came into a lick sir I was looking for a
lot of the same things that I had in
high school and I was kind of I had some
maybe some poor expectations and was
trying to kind of get that same feel so
I care a lot about types I'm kind of one
of maybe try to convey that to y'all so
if let's start out real quickly who
understands monads okay raise your hand
oh okay cool awesome so if you want to
learn about monads go find those people
if you'd raise your hands let everybody
else know who you are again that's
awesome let's not actually talk about
monads at all that's not going to be
what we're going to talk about we're not
gonna talk about monads we're not going
to talk about a kind of heavy type
theory we want to talk about practical
things and we want to talk about
applying these these ideas in a very
very practical way that said if you're
interested in mon annonce I do have a
gist of monads in elixir that I wrote
and also does it Sam it there's a maybe
implementation there as well if you're
familiar with like optionals or maybes
so I gave that talk of it a very
of this when I actually did to explain
monads and I explained maybes and I
could chain maybes together and compose
maybes and it was really awesome and the
very first thing I got back was this
it's like this is Erlang just let it
crash right like why do you need these
maybes this is dumb and I you know just
don't agree I think that this is kind of
true and a lot of cases you know types
are not a replacement for OTP OTP is
good at what it does already and we
don't want to try to replace any of that
with types that's not the goal the goal
instead is this thing called mistake
proofing is anybody familiar with the
notion of mistake proofing cool this is
I think a really really interesting
early topic but it comes out of lean
manufacturing so the idea is that when
you're manufacturing something you
actually design your system in such a
way that it's incredibly hard or you
know ideally impossible to even make a
mistake and when you do it keeps it from
actually being a catastrophe so if you
can imagine and this comes out of like
Toyota when they're making cars so if
you can imagine an assembly line where
you've got a whole bunch of doors that
you need to paint you know you some of
them need to be orange some of them to
be blue when the actual spray can comes
up to paint that door it has deceit into
a socket and only orange doors will seat
with orange spray cans and by doing that
you effectively stop a door from being
painted the wrong color another example
this is like USB right you can't plug a
USB cord in the wrong way which
sometimes is more annoying which i think
is a good analogy for type system
sometimes the other thing that we can do
is we can help to reduce complexity and
when I mean complexity I mean that and
sort of the rich Hickey definition and
just many things twisted together right
types kind of force us to actually
decompose things into proper data and to
think about data transformations
so and along with that it it serves to
cut down on complexity long term right
like if like if you come back to a
project a year from now and you want to
make changes you might not remember how
all that stuff went together and so
using types we can actually kind of help
cut down on those on those mental
barriers so that's I think the the
impetus for it you know and I'm there's
obviously different ways that we can
achieve that so let's talk about types
101 so types and elixir so some of this
may be a rudimentary for some people but
it's there to kind of help serve a
purpose and if I'm talking if I seems
like I'm you know talking to low level
or this is boring or something hopefully
you'll get more interesting as we go so
we have a really basic application like
this we have we want to calculate a
balance it takes two numbers and
subtract them really straightforward
stuff until oh no someone passes an atom
in because this is the kind of thing
that happens like all the time right you
know we all face these problems every
day and like I recognize this is totally
contrived but it helps and I don't think
that you know we don't often actually do
explicitly bad things like this but it
does help to illustrate the point so
someone tries to pass an atom in this
obviously is going to blow up because
you know it's not a valid thing you
can't subtract a number you can't
subtract an atom from a number so we
could wait until we get out into into
the real world and like actually try to
catch this at runtime or what test or
something like that but we have this
awesome tool well we have this tool
called dialyzer who's used dialyzer okay
so not a ton of people that's awesome
perfect so dialyze is a way for us to
actually go in and evaluate to try to
catch different errors inside of our
systems before we actually you know
deploy in production and one of the
things that it can catch is is typing
problems there's two really good mix
tasks for this there's one called dial
sir another one called dialyze i use
both they have pros and cons just play
around with both of them they're really
easy to install as archives and then use
throughout all the rest of your
applications so the very first thing
we'll do is I'm going to use a dialects
right here and so the very first command
I'll run is mix dialects or dialyzer PLT
I'm gonna go get a cup of coffee and
probably lunch maybe go for a jog grab
some more coffee shower come back and
then by that point peeled the PLT should
almost be done being generated for those
of you who don't know sometimes it can
take a little bit to build a PLT and the
peel t is this sort of intermediate step
that we have to do in order to actually
begin to do type analysis on our on our
well airline code in this case so once
we've done that though we can actually
run it so i'm going to say mix dialyzer
and it's going to run and you can see
that it comes back and it says the call
calculate balance 50-some adam will
never return since it differs in the
second argument from the success typing
arguments number number which is a very
long error message but it does kind of
more or less explain the problem so
great so we can actually check these
things so let's look at a little bit
more of a complicated example so in this
case we're going to take we're going to
create a new variable called balance and
we're going to create a new transaction
and then we're going to calculate the
new balance based on the balance that we
had and the money that we used in the
transaction and you can see I've got
some extra helper functions here if I i
can use pay to create a new transaction
which is a 2-tuple with a name and an
amount and i can get the money out of it
but there's a problem is you might see
it you might see the problem yes yeah
the the two tupple and money and the
money function there is wrong and I have
a sticker for you or beer or whatever
that you want later thank you see it
pays to participate let that be a lesson
so right this is ridiculous like you
know know we've we've messed this up but
it's okay we've got this tool called
dialyzer
and it can help us with this right so
we'll run this again and it's all good
no big deal NBD like that's that's not
super helpful right why is this not an
error we know we can look at this code
and we can know that this is an error
right so the reason this is not an error
is interesting and it's it's
historically relevant and I think that
this is fascinating so if you you have
to realize that dialyzer came out long
after Erlang was already written and out
there in the world and being used and
out there you know being used as such in
very specific ways so for instance
people very happily wrote code like this
right this is actually an example from
the paper one of the papers that that
but dialyzer that the typing system and
dialyzer is based off of so what we're
doing here is where we've gotta send
function and we take a process group and
a message and when the process group is
an atom we send it to the registry the
the kind of global registry and when
it's a pig we send it directly right and
that is just the way that we you know
right good elixir in our line code and
that's cool the problem is that this is
not well you could write a type to
encompass this but if you were to write
a type to encompass this to actually be
able to type these functions you would
essentially have to rewrite them right
you'd have to you can come up with a
type to sort of and try to encapsulate
that but it wouldn't handle all the all
the actual cases like you'd have to
probably change the way that you
actually wrote this function and it
would tell you that your code that is
out there working in production right
now is broken which is clearly not it's
out there working in the in the in the
real world and so because of that so
people went away and they came up with
this notion of success types they wanted
a type system that we could use to check
or line code but we didn't want but they
did not want
to actually restrict they didn't want to
just tell people that the code that
they'd already written was bad right
they wanted to find very egregious
errors but not you know make assumptions
about the kinds of code that was already
out there in the world so the way
success typing's work is kind of like
this and look at like an and function
really really simple example we have
three different clauses for an ant
function if they're both true we get a
true out if one of them's false in
either either argument we return false
and the way that we would type this in a
like let's say Haskell is we look at
something like this we would say that
and takes a boolean it takes another
boolean and it gives you back a boolean
and if you're not familiar with this
type notation you can just that the last
thing there on the end is what we return
the other two things are the arguments
this though would fail with our with our
elixir code right that would not
actually pass with our elixir code
instead success typing's does this it
takes in any and in any and it returns
you bullion it doesn't he doesn't care
what the first two arguments are they
can be anything this is a dynamic
language doesn't matter what you pass in
all that matters is what comes what
comes out the other end this is
important because types are propositions
their their logical statements and if we
make a logical statement and it's an
error then the code is therefore broken
according to that type system and then
we can obviously write code like this
and elixir we can say and pass a string
in foo and false will still get false
out that will still work and we can also
say pass a number n as the as the
argument will get false out both of
those are totally valid those are both
totally valid and elixir code that if
given a more restrictive type system
would actually say is wrong that's an
error and so dialyzer is optimistic by
default it sort of assumes that you did
know what you were doing when you wrote
that code which you know if you're
coming from a stat a different other
background or if you're coming from an
ml family language you know that can be
very upsetting because you're like i
know this is this should be wrong i
don't know how to get this to fail now
but you can also take this is also nice
because if dialyzer does complain you
can almost like one hundred percent you
have a problem so we can actually in
this case we know there's a problem here
and we can't actually help dialyzer out
to help us find that and we use this
thing called type specs so in elixir
code we can we can do this i'm sure
people have seen this before you can
declare type and you can you know we'll
say a balance is an integer transactions
and add them in a 2-tuple with of that
contains an atom and an integer and we
can add these to our to our module and
then unfortunately you know just adding
those doesn't do anything doesn't tell
dialyzer you know doesn't help dialyzer
audit also and we also have to add specs
to our functions so we can do that we
can say that pay takes an atom an
integer returns a transaction and money
takes a transaction returns an integer
calculate balance takes two integers and
returned you a balance cool right so now
let's let's run dialyzer again and see
what happens and we still don't have
errors uh awesome so the thing is though
specs alone aren't necessarily all that
matters because we haven't changed the
actual underlying code at all the co
doesn't hasn't been manipulated we've
just added some fancy annotations to it
and they will get those annotations
wrong so luckily there's this flag we
can pass called over specs and you can
add this to like your mix config and
it'll it'll run that
and if I add that flag and I and I run
it again I get a whole bunch of errors
and over spec stands for sort of over
specified and we can see these errors
are really clear so let's look at the
second one here it says the type
specification for money transaction to
integer is a subtype of the success
typing money a 2-tuple with anything to
give you any so actually we've been more
restrictive in our type then our code
actually allows for our code allows
anything so there's a really easy way to
fix this we just add a guard if we care
about the type being passed in we have
guards they're there for a reason we
should be using them if we actually do
need to restrict these sorts of things
then you know we look that's all we have
to do we just say when it's an integer
then I display the amount and now
finally if I run dialyzer I'll actually
get an error because I've I've allowed
it to understand that it has to be an
integer when I pass it on and obviously
the fix is really trivial you just go
back and you flip the arguments around
so there's other fancier things we can
do with types with type specs we can
also do things like this we can say that
a transaction actually doesn't take an
atom anymore takes a name and we can
define a new type called name and we can
say that it's a union of an atom or a
string so we can actually create Union
types in this way I was just pretty cool
and we can also do even fancier things
like this we can take a ledger like
let's say we wanted to actually build a
ledger of credits and debits we could
say that we could pass an arbitrary type
into that and then everything you would
actually use that type so we can say
that you know take a ledger would take a
type and then it uses that type for the
two lists and then when we have this
function here we pass in transaction
into ledger so is everybody's mind-blown
I love that gift so that's kind of the
basics so how do we actually use that
now to create our own data types because
well that's awesome primitives are great
we kind of also want to have some notion
of being able to create like our own
data types so a lick sir gives us this
thing called structs I'm sure we have
many people have used them and it's
great because we can use these to
actually create our own data types so
let's say we have something like a queue
queue is just two stacks right has an
inbox in an outbox and we can so we can
define that this way everybody everybody
seen stocks before right so in the other
cool thing we can do is we can have
types to this so i can say a type t is
going to return a queue where the inbox
is a list in the outbox is a list and t
is i'm sure people have seen that too if
we use like string T those are that's a
convention to kind of give a type for a
module so and it's actually purely
convention if we wanted to go in and
actually implement all this we'd
probably create some specs that looked
like this we could say that push would
take a cue and any return us to q-pop
would take a cue and would give us Beca
to topple with any and Q and new would
just give us a new cue and then we can
compose this stuff so we can create a
new cue we can push stuff into it we can
pop stuff off so we have these basic
functions but let's say we wanted to do
something a little fancier like we want
to get the size of a cube so we could go
in and we create a function it would
pattern match on a cue would get the the
inbox in the outbox and it would just do
a count on both of them and add those
two counts together pretty simple right
but let's say we also had a different
data structure like a tree that has you
know a left side
the right side and we also want to go to
get the size of the tree so you know
again this is like really bit like just
take the size the left top size of the
right and add one to it and you get the
size of a tree but we've now got two
different uh we've got two different
functions that declare the same you know
really trying to do the same API and
ideally we'd like to be able to use like
an enforcement more like polymorphic
data and be able to think about data
transformations and the way that we and
reuse functions in a more like sort of
polymorphic sense so we can do you can
use protocols everybody seen protocols
before yes uh which which one oh yeah I
just didn't define it there but yeah you
could do you would just have the like
right here you mean yeah yeah you could
just use you could justify another
another type spec for that that you know
says like what that would be like so
left would be yeah it could be recursive
could be the tree so because you yeah
you can do recursive you can do
recursive types well so yeah so we'll
create a common API for this call it
sighs and for lack of a better word cuz
i'm awful at naming things i'm going to
call it sizing that's awful i don't i
don't know like how i don't know what
the right word for that was supposed to
be but yeah so well and then we can
implement that for both of our data
structures so we can implement sizing
for q implement sizing retreat and all
I've done is copy or just cut out the
implementations from the actual queue
and drop them in here but what this
allows us to do is then to reuse this
this same functionality in other places
so if i wanted to do up a queue and push
and stuff into it and get the size or if
i wanted to create a tree and then
insert a new
node into the tree and then get the size
of that I can do that and it's just the
same API the great thing here is that
protocols are opt-in polymorphism right
they don't just sort of magically happen
you explicitly have to go in and define
that stuff and so it actually is very
explicit in that way which is always a
good thing we always want to try to err
on the side of being explicit and
because of that we gain more use from
our common api's now it would also be
nice if we could do something like this
go in and say like okay well this should
be empty right and this is sort of a
thing that you can do with let's say
type classes is you can actually you
know declare a function and I could
declare a function in relation to the
other function or like it yeah I could
write the definition in terms of the
other function and that would allow me
to just sort of be able to implement one
and move on but unfortunately protocols
don't allow us to do that so we'd end up
with a situation like this where we need
to re-implement both of those functions
for tree and for Q and you can see that
like they're basically the exact same
implementation if the size is greater
than zero they're not empty and it would
be really nice sort of we use this stuff
so the pattern that I use to do this is
I typically create a module let's call
it like presence right is something is
something present and I can define a
function here empty it takes a thing and
gets the size of the thing and if it's
equal to zero it's empty and I also can
get the and then inside when I call
sighs I just delegate that into present
sizing and then my protocol just becomes
present sizing so now I only have to
implement the protocol once and i can
add all this other functionality on top
of that so and again we would just you
know the implementation for that looks
def they say and we just changed change
the name so later on if i wanted to add
something the opposite of empty maybe
that's present I could do that I could
say well president not just goes in the
same module guess the size of the thing
is great
zero is present and again we can just
compose this stuff because and that's
awesome like being able to have this
sort of data polymorphism is really
really powerful and it's powerful
because it's really sort of a form of
type composition right so if I have two
functions let's say the first function
goes from a some data type a to some
data type B and I have a function to
that goes from some data type B to some
data type C then if I want to combine
these I can just do that because i know
that a goes that function one goes from
a to b and function to goes from b to
seeing this gets really cool when you
start to think about what that means in
terms of protocols and polymorphic data
because now we're not really saying
something goes from A to B we're really
saying that something goes from a to the
class of B because it's implemented that
protocol and concretely that would look
like this it's like you would have
something that goes from a to something
that implements presence to see and I
think that's really powerful because it
allows you it puts you back in control
of being able to do data transformations
and it also just it just uh it means
that if I need to swap something out if
it means I need to change the piece of
functionality as long as those types
still line up as long as things still
compose everything's all good so how do
we put all this together into sort of a
real something that looks a little bit
more like a real world problem so we
have a ticketing system right we're
running a nap and there's problems with
that app unfortunately because it's a
it's a rails app with a JavaScript front
end which reporting reporting it to to
Phoenix and elm and so soon we won't
need this ticketing system but for right
now we need a ticketing system and I
really fell flat
so maybe that's just cuz I have to work
in rails and JavaScript all day so we
have an email and we have a and we want
to be able to take email or assuming we
take kind of tickets and we want to go
take errors in and we want to create
different interfaces from that so we'll
say that you know somebody could email
us but somebody could also slack us
because as we all know based on the
three different articles or blog that
have come out recently we are all in
slack all the time and we all get
notifications about it so we're going to
get these different pieces of data
coming in we want to do some processing
on them we probably want to put them in
a queue somewhere we want to store them
somehow and then we also want to notify
maybe our on-call staff and let them
know that you know hey there's a new
ticket you should go take a look at it
probably in slack because you know who
leaves slack those notifications are
always on so let's start with our data
we can define two differents trucks
right well so we'll say that this is an
email and we also have a slack message
an email just has from it has a body of
the email has a title and a slack
message has a from like who it came from
it has a message like the actual message
that it came in and it has a channel the
channel that it came in on and this is
important because we want we want to
define these data structures and in this
way we don't want to try to create some
generic data structure for these because
we might be communicating over these
protocols in more ways than just trying
to create new tickets so we want to
actually create real data structures
that really model the way we're talking
to these different protocols we can then
create you know some like adapters let's
say that a that talk to the outside
world and these are going to be sort of
stateful processes that could be gin
servers you know it could the slack
thing probably listens on some sort of a
WebSocket connection so that's a
stateful process and we need to be able
to get data in from the outside world
right we have this state there on the
boundary we need to go to get the actual
data in from it and then do processing
on it so and you can see those look very
pretty similar so for instance I might
take an email i might parse the email or
so
like that and to turn it into the
correct data structure and then I'm
going to send it into ticket dot process
and the same goes for the site messages
right I might decode it into a slack
message and then I might get called
process but again we're calling process
with two different completely disparate
data structures and we're going to use
polymorphic data to do that so inside of
our ticket tickets going to define a
struct where we'll have something called
like a requester like the person who's
requesting you know the fix or saying
like hey this thing's broken we'll give
it a message and we'll also give it like
a severity like 12 over 9000 because
like some you know some of the sites
burning down and we can apply types to
all these all these things as well which
is really nice so inside of process in
order to achieve this sort of data
polymorphism we can do that same trick
the very first thing we do in process
here is we call to ticket on the data
and we get a ticket out of that and then
we can push that into a queue and we
could or we could you know pass it to a
notifier and you can see down here in
our to ticket function all we're doing
is we're calling into this thing alerts
ticket dot fields to ticket so alerts to
me ticket dot fields that's our protocol
that's the thing that we're going to
define that allows us to do this this
polymorphism so and you can oh sorry and
you can see like for our notifier this
allows us to actually be explicit about
the types that we care about now we
don't have to define multiple clauses
for you know I want to accept an email
or I want to accept a slight message or
you know I'd you have to force those two
things that have the same keys from the
beginning it allows us just to say note
I want a ticket I get a ticket past end
and also hopefully this dialyzer can
actually catch these things so they
basically they have you know different
interfaces but they both take the same
type of data at that point and again we
can spec that so if I've notified on
call that takes a ticket gives me back
an email
let's say if I have or maybe that should
be a list of emails it push takes a
ticket and gives me back a ticket queue
so so we can then the protocol for this
is really straightforward we just say
that you have fields you can go from
anything to be a ticket and then we just
need to implement that for our two
different data data types so in this
case we take email and you know we just
Pat we just take that email we it's a
it's a struct so we can just get the get
who it's from get the body and then we
could maybe do some sort of like parsing
on the title to figure out what the
severity of it is maybe that's in the
title maybe that's in the body you know
that's something we have to we can just
write a function for to do and all of
that can live here where it's sort of
all you know all that parsing logic can
live here all together which is nice and
saying goes like messages we can just
create a new brand new ticket in this
verse and they almost exact same way so
by doing this I think that we can really
like enable a very specific type of
design of systems and we can again all
these things are catchable by dialyzer
these because we're being explicit
because we're actually declaring in code
like what we expect will actually get we
can actually get errors the thing we
can't get Arizona and it's just kind of
a shame is we can't actually die Elijah
can't actually tell us if you've
implemented a protocol for any given
struct so that you have to check at
runtime and luckily elixir will just
blow up if you try to call into a
protocol with us with a data type that
hasn't actually implemented the protocol
so let's talk about stuff we could do
for the future ways that we can actually
even make this better because I think
that's really the thing we have this
like this is the methodology I use and
it's I really enjoy working in this way
but I think that in a lot of ways our
tools could be even better and could
enable us to do this in a bigger way and
so
want to talk a little bit about that so
first of all I think we need something
that actually understands a lick sir
unfortunately you know even reading
dialyzer you know your your your you
have to do that mental translation into
ur line code and that's not to say that
that's bad like Earl anko's Batterson
like that but it's you know if you're
working if we're teaching people elixir
if you're working in a liquor all the
time and you're having to do that jump
that can be that can be tricky and
you're definitely doing a conta big
context switch there it'd be awesome if
we could actually check to see if things
you know if we've implemented protocols
correctly from the very beginning you
know yeah there's a lot of stuff that
you could do if you actually if you if
you sort of could understand a bit more
of a lick sirs stuff so the other thing
is like building the PLT that sucks you
only have to do it like once I get that
but it's it's you know it's definitely a
super time consuming and confusing it
first so that you know that's definitely
a thing that we could improve on um and
then just better errors like imagine Elm
esque in a tool that could like help you
check you know your actual code those
are really important i think a lot more
important than we've probably given them
they're a lot more important than we've
cared and we've actually we've thought
before and so you know rust is
definitely doing the same thing if
you're playing around with rust the
error messages or are now awesome and so
yeah I think we could really have
something has better hair so maybe that
means wrapping dialyzer and you know
producing better errors out of it airs
that make more sense I don't think that
you should have to read the success
typing's paper to understand how this
stuff works it's kind of a shame like
I've read it a couple times now so to
make sure that I can understand how it
all works so that's something that like
these are all things that I'm personally
very interested in and that I'm kind of
like slowly working on so if you want to
talk about that please come and find me
later and I'd love to talk about that
with you there's a whole bunch of
resources on this stuff if this is
interesting to you definitely read the
success diving's paper it is it is good
and helps explain a lot of the
the decisions around why dialyzer does
what it does there's great a great blog
on writing a sort of code and then to
learn you summer laying guides on types
and dialyzer super helpful and so yeah
with that I think that's about all I
have and definitely time for questions
so thank you yes yeah it does yeah so
you can yeah you can use opaque you can
use private types so that's that's a
great question types by default are
exported as part of your modules and so
if you want to make a type private you
just do type P instead for like private
functions let's say or private types
yeah um so oh yeah sorry the question
was on about opaque the using spiral
opaque instead of spiral type I so I
don't I'm not i'll just be honest and
say i don't know i don't know my opinion
is yet on it it's mostly because i
haven't explored it enough to understand
how it works in relation to elixir code
like the like if there's any
idiosyncrasies there about the
transition between elixir to Erlang
opaque and all that sort of stuff and I
and I only know curse like I only have a
very cursory understanding of like the
problems with using opaque and dialyzer
which apparently there are some like or
something like I just read this or
something like that like I don't know so
no maybe I'm wrong about that that's
fine I anyway so it's something I should
that's something to explore for now I
tend to just use type I'm going to base
most of my my methodologies off of sort
of stuff I see out there in the world so
yeah yes
oh this one yeah sure totally any other
questions yeah efficiently you would
need different implementations of size
for each type but you can't really do
that Oh suit so you're saying like if
yeah so you have to do the whole giant
calculation for her that's a great
question I don't know uh yeah I don't
know I don't know if you could I don't
know if you could maybe like yeah I
think I've at that point you're going to
have if you've got like well know what
you could do is you could just delegate
down into the actual implementation like
that understood the module but like that
understood the data structure talking
about a bit better and like memorize it
there yeah yeah you probably just add it
to the protocol that I thought at that
point otherwise like I don't you know I
don't know I think maybe that's a
trade-off
abstract understanding
yeah I mean and the thing is like the in
the example it's like you're saying you
know I want the size of this like you've
defined like a contract like whether or
not that's the right contract is you
know debatable like sis did you know
kind of the maybe not the best example I
guess is what I'm trying to say sure and
at that point like if you actually had
like real concerns about about that kind
of stuff then like this probably isn't
the right solution just call it on the
thing like or you know or delegate down
to the again delegate down into the
actual data structure and just do it
that way or put it in the protocol like
if those things are really important
then you should then that's what you
should do you know and like I don't
think the trade-off you're going to make
there by saying like oh you also have to
implement empty in your protocol is like
if you care enough about like the time
like that it takes to take to take the
size of something then like you're at a
point where you're probably fine putting
that in your protocol to like so oh gosh
um well I mean that's that's not I mean
you just do that you can say hey the
protocol you have to define an empty
function as part of your as part of
implementing this protocol that's no big
deal is that your
oh right so yeah so I've played around
this a bit you do have you can do any
like that's an option right i can say
like default back to any the problem is
once you've implemented once you've
actually implemented a protocol it
expects like all the functions to be
there so you can't just like delegate
back you can't delegate anymore like you
can't just fall back to the to the
protocol version or like the any version
of it cuz you've overwritten it yeah I
have a not nearly enough to be able to
like have a good answer I actually
started well so I tried that is it like
what this is getting too is like I
actually attempted to go do what we're
talking about doing and I ran out of
time honestly like I was going to do
that as part of as part of this but I
ran out of time so I just kind of
avoided it but it's definitely
interesting it's you know it's all
macros and stuff so it's pretty fun so
dig around and see so we should talk
about it later I'll be fun to hack on
right yeah and it actually creates
protocols that are like also you know
it's like protocol dot Q and protocol
tree like it creates its own new modules
and stuff to do that
yeah yeah yeah but I don't know that
there's any technical reason why you
couldn't do it I wonder I mean it might
be a that might be like a cultural like
that's not like a desired a desired
feature but I don't know it would be fun
to play with did you have a question
cool
I get like there's a lot of power to
Like You me too much power and the plate
dynamic aspect but it's nice flexible so
is it best practice to link those
irritations or what is the kind of steam
yeah I would say it's it's best practice
to use type annotations for no other
reason than its documentation it like if
it was just for documentation I would
probably still recommend you you do it
and you know there it's really nice like
when you generate like your hex docs and
stuff like that if you when you generate
like normal elixir documentation it
knows to go search for your types it
adds that to like your documentation
files those sorts of things and those
are you know it's really helpful um yeah
I mean I think I mean obviously like you
don't have to no one's going to make you
but there's benefit and like thinking
through what these what the data is like
what is the data you're actually taking
in what are you giving back like there's
value and just thinking through that
problem so yeah so I recommend doing it
some people probably disagree with me
that's fine anything else all right Brad
cool thanks y'all</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>