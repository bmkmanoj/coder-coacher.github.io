<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Illustrated App Development by Ben Marx | Coder Coacher - Coaching Coders</title><meta content="Illustrated App Development by Ben Marx - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Illustrated App Development by Ben Marx</b></h2><h5 class="post__date">2016-09-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/30CUEMhZAZc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this is an illustrated app
development I'm Ben marksman lead
engineer at Bleacher Report's forgive
you little bit of background about
myself I've was a ruby developer for
three or four years I've always been
interested in functional programming I
tried Scala and closure and I never
really clicked with them for whatever
reason and I never never have used JVM
so for better or for worse it was really
hard to to work with those for me my
background is in computer science it's
actually in philosophy and economics and
so in the logic classes in the
philosophy courses we would prove these
theorems in the way we do that was with
functions and which closely mirrored
functional programming in a lot of ways
so for those of you who don't know
Bleacher Report is the second biggest
sports platform in the world behind ESPN
as you can see we have very high traffic
and a large number of app downloads as
with most media sites you want to be the
fastest and this is very important and
our concurrent users the highest peak is
was when LeBron made his decision I
guess about four or five years ago to go
to Miami from Cleveland and every year
the NFL Draft is our biggest consistent
night one thing with all media sites is
that you have to be prepared for
unexpected breaking news and we send
tons of push notifications over three
billion notifications a month and then
pretty sure that's increasing ones over
month bleach report is about eight years
old started with rails one point x2
monolith like most things were at that
time at that time mobile traffic wasn't
wasn't a big deal people were going to
the website for the majority of the time
and eight years at a company in Silicon
Valley or the Bay Area is a very long
time so with a real site of that age and
that complexity there's a lot of lost
domain knowledge and the shifting trends
were from web to mobile and this thing
started the things started to fall over
in the Ruby world especially with the
way that breaking those breaking news
notifications we have to be the fastest
and obviously this isn't Ruby's strength
and we had to in order to sort of cope
with rubies with the some of the
decisions of Ruby
we had to invest in all these caching
strategies and they're very complex and
they worked most of the time but when
they didn't work they failed pretty bad
and one way to make Ruby Fester's to add
more servers and this isn't really a
sustainable sustainable approach over
time also the initial appeal bleacher
report was that you were able to follow
your local teams at the time we were the
only company doing that so you could if
you lived in Minnesota and you wanted to
follow your local college team you could
do that ESP and other sites like that
didn't offer that now that's sort of a
standard thing but that's due to
Bleacher Report and because of this on
the fly Condon delivery it was hard to
catch the actual content itself so if
you follow you know 12 teams and the
other person falls 15 teams it's very
difficult to catch that especially with
the with the growth of fantasy players
in fantasy football people want to
follow individual players so then you
have you know 50 something players per
team which can you follow 10 teams and
these kind of things you end up having
each person in the following loads and
loads of players and I'm not really like
andreia as well I'm not really a sports
fan but these brought these technical
problems are very interesting and
they're very hard to solve and so we
started to look at a new language and
that was obviously elixir the initial
appeal was that it was driven by a Josie
volim who was well respected in the Ruby
community in the rails community um and
you had the beam which has been around
for I guess almost 30 years and it
shines in a multi-core world and at that
time you know about two years ago if
elixir had fallen off we could always
write or lang if necessary so it would
have a fallback strategy the syntax of
Ruby's is comfortable for Ruby and rails
developers in elixir looks very similar
it would have been a lot harder sell had
we said okay so now we're going to use
Erlang this is very different than Ruby
so you have to learn the functional
programming concepts as well as the
Erlang syntax so at least you can sort
of trick people in the saying hey look
this look this looks like Ruby you know
the syntax you understand this and then
you learn the functional programming
concepts over time and so this talk is
about the
first app that we wrote at Bleacher
Report and in like every other app this
follows a common pattern first you have
product requirements then you have the
initial development features are added
and you release you refactor features
release and this is a common pattern for
every single app probably out there and
for this app this is sort of the gradual
history of the app on the top is the
additions and this takes from this is
taken from github on the top are the
additions and on the bottom or the
deletions and you can see the phases
divided their exploratory definition
release features refactor features and
so on the reason this is a little
different is because we were looking for
an alternative to Ruby so the
exploratory phase comes before the
definition and I'll explain that a bit
more as we go on so the exploratory
phase we started off in October of 2014
so this was one month after a lick sir
reached one point oh so at least waited
till elixir was one point o before we
started developing with it the code this
and add to be clear this was before I
was a bleacher report so all of this is
second or third hand knowledge so I'm
going to go over this little bit quicker
and I'll go into the other other parts
when i was there in a bit more detail
but just to give you a picture of the
full life cycle of the app we had a very
simple data model at the time at that
time Bleacher Report had very few
content types in the app so you had
articles videos video articles and that
was about it so it was a very simple
model which at the time this was also
act 0 point zero point two point five so
there's a very very early version of
ecto and the full relationships hadn't
really been defined at that point and
the relationship that had been defined
because we were new at this we didn't
take advantage of them all the way so we
ended up using json be to sort of cover
both sort of the the early versions of
ecto and as well as our own sort of
inability or not done as well as our own
sort of learning curve you know if we
don't know how to do this exactly we'll
just throw it in json p and at least
another database and that would come
back to bite us later
the and you can see this sort of the
additions and deletions graph are what
you'd expect for a lot of for a journey
for a churn of a new app especially with
the new language in a new framework lots
of the initial comments were like maybe
this works maybe this works is this
better is this better and as Andre
mentioned earlier we used enum a lot
which is very inefficient because eager
loading and and we figure that out later
on but despite all this it actually
performed quite well and it's through a
lot of promise and the first version of
Phoenix we used was zero point four
point one you can see the develop there
are no guidelines yet do what feels
natural submit a bug join a discussion
up on a pull request this is a pretty
laissez-faire attitude to have towards a
framework especially when one when
you're building the core part of your
business around and also using
coffeescript in Phoenix is very strange
um but if you scroll down to the bottom
of the page and you look at the roadmap
most of the initial core features were
already developed and so even though the
development guidelines weren't there at
least the features were the foundations
of the features that have made Phoenix
today what it is are there so the next
phase is the product definition so we
realized oh look this this actually is
something that could work the developers
seem to like it we actually started
writing a second app and the second app
was amazing a translation layer for the
older and newer apps to talk to the
digital newer apps and you can see in
this time that nothing happened
basically part of the reason was because
we had to figure out so we have this
eight-year-old rails monolith how are we
going to break this apart into into
services and a lot of the knowledge was
lost if you look the the Ruby code
wasn't documented very well then we're
there weren't many people there who knew
what was going on and it was it was kind
of quite of a difficult difficult time
and you know part of this breaking apart
this model lyst was understanding that
we were going to end up doing things
wrong and they were going to have to go
back and redo them and the product and
stakeholders support of that and this
was a ecto 0.5 which ecto change sets
were introduced and
just in my opinion the single biggest
change to act 0 Phoenix ecosystem that
makes introduction to to functional
programming an elixir and and i'll come
i'll talk about this in a bit more
detail when i talk about the code change
over time but we were doing something
like this before and it was sort of
convoluted way where you take a map and
you turn it to a struct and then you
would update it and it was it it wasn't
predictable and it was very sort of
messy but again it worked and the next
phase is the release phase then this is
actually when i started so now i can
talk a little bit more detail about the
the phases himself so because we had
stopped development for about four
months we were i think three or four
versions behind phoenix and one of the
great things about phoenix and elixir in
general is is the great documentation
they have and especially in these early
stages when you were upgrading there was
an upgrade path and still today when one
new version of phoenix is released they
say you know these are the steps you do
and tick tick tick you're done and we
are so far behind that the latest
version that they had was versions
before that before us or brother after
us so it took us like two or three days
to get up to speed and you know that I
valid from that point on that we would
always stay up to date no matter what so
if new Phoenix released came up once a
day we'd updated and move on you know
new ecto update a move on and this
helped us to get into a pattern of
refactor isn't as integral part of
development you know this should be done
regardless but especially with a new
framework a new language understanding
that refactoring is going to be crucial
to keeping up to date and to improving
your code is essential and also from the
fact that we had this monolith and that
no one liked working with and it was you
know it's code eight year old code we
wanted to make sure that that that
didn't happen with the new stuff with
the liquor in Phoenix at this point we
had three elixir apps and the first
within the first week we had this I
wrote an elixir up and I didn't really
know anything about a look Sarah until
about two weeks before i started the
bleacher report just by happenstance
someone that I used to work with said
hey you know we're using a lick sir and
I was like what's ellipsoids very
interesting you know Erlang I've heard
this is sort of an esoteric language
this looks interesting looks like Ruby
this maybe this could be the functional
programming language it appeals to me
and this was actually what this was the
reason i joined bleacher report and it
was actually really nice because we had
this older Ruby app and it didn't
perform very well when you had to do
multiple things at once so you know it's
very simple it does one thing attached
data manipulates data and does these
things and I look you know i'll just try
rewriting this in phoenix and elixir to
see if i can do this and it took me
about a day to rewrite it in in phoenix
and elixir the the code i look back on
it now you know for this presentation I
was like oh that's bad code but it
worked and the funny thing was it was
that it outperformed the Ruby app you
know many times over so to give you sort
of an approximate idea of how the ruby
up fared if you tried to fetch 5linx it
would it was like a second if regard
state fit fetch 10 links it was two
seconds we start that's 15 links it was
you know six seconds and there was an
exponential growth until it just
eventually fell over and the exact
opposite thing happened on the ellipse
our appt there was incremental
incremental time so you fetched five it
was half a second fetch 10 it was maybe
three quarters of a second and so on and
then evade and we could actually i think
it was about 50 links before it started
to fall over but this was the use case
that we would never have and and then
the release itself was a phase release
so what we did was we started off with
with less with least popular streams
like dressage or an equestrian or even
like WWE type stuff there were safe bets
that we could say you know if something
happens we have a small number of users
that use this it's okay if it breaks
because you know chances are no one will
even notice and it took us about four
months to get that to to where we're
able to migrate all the strings and we
did that with rollout flags so in the
event that something broke flip it back
it'll go back to the older system and it
was fine and you know if you look at the
graphs the additions and deletions again
this is what you would expect from sort
of an immature app
lots of changes lots of lots of churning
and at this point we were still using
even though change that's had been
introduced we weren't using them we were
still just directly inserting maps into
the database or stocks rather and and it
wasn't until a few releases later that
ecto would say you know you can't do
this anymore we can't guarantee data
integrity if you do that but at this
point it was still okay to not do that
and this was the period from about may
to october and this was saw milestones
and act 0 phoenix an elixir this was
actor 1 point 0 phoenix 1 point 0 and it
looks for 1.1 so at this point we could
be fairly confident that the api's were
stable that we we wouldn't have to do
these major upgrades and so on and that
we as a company felt that that ecto and
phoenix are are the way that we want to
go and you know it licked road already
been stable but it we were very pleased
with the way things were going and and
from the stakeholder point of view it
was it was a performant app it was doing
much better than the ruby app and this
is credit to the beam the beam does a
great job of covering up your mistakes
and of writing poor code so this gave us
the confidence to continue iterating
over it some of the negatives it was
still very object oriented we were all
Ruby and rails developers we didn't have
you know an erlang expert or any other
sort of functional programming expertise
so if you look at the code is still look
like a very rails the app we had even an
interactive directory which was our
rails and Ruby thing and they're
basically a service class if you never
use them before they don't really belong
in a in a ruby a petal owner elixir up
and then at this point it was quite
difficult especially when using Erlang
libraries to deal with dependency
resolutions because if you would you
know one library would use you know tag
head one would use 0.5 when we use zero
point five point zero so a lot of so the
mixed study access file had all of these
different override through a variety of
right to and I mean that's obviously
improved quite a bit but it was
difficult time at that time and in the
Ruby world you have new relic and I
guess also some other the go and note as
well where you can basically all of your
monitoring done it's very easy it's a
service everything's done and you know
we as a ruby company had used them I
think we're like I think our IDs in the
top 50 or so so we've been using them
for a very long time and and there
obviously was nothing like that for the
elixir world and but we found the
examiner which is metrics library for
Erlang and this was actually quite a
difficult library to deal with in terms
of dependency resolution but you know we
got our working and what are the
remarkable things about working with
elixir and the beam is that we showed
these charts and the metrics and like
this is crazy look we must be doing
something wrong like no matter the
traffic the cpu's is that three percent
the memory uses it three percent nothing
seems to affect this out we must be
measuring these things wrong and at this
point we before the release itself we
brought in Erlang solutions to just sort
of say hey you know you know we're all
new to this you have been doing you were
working with Erlang for four years and
years and years so can you just let us
know for doing something right or
something wrong and how we can improve
how we can improve and it was actually
very reassuring because they're like no
you guys are actually doing things
really well and they were helped they're
very helpful in explaining how the beam
works and with the schedulers and at
this point the documentation for sort of
intermediates elixir was was pretty
lacking and even stuff like we didn't
even know that the observer existed and
so they showed us Observer that starts
like oh you have all this stuff built in
this is amazing how we can see all these
things locally and using these kind of
things were able to understand how the
schedules worked and all these and this
so it made life a lot easier for us and
it turns out that the cpus and memory
use aren't really ways to monitor things
in the elixir in Erlang world and so
once that was really so once we release
it it went out of production we
celebrated hooray we did this thing and
it's working well the next stage was
features and part of the problem with
not developing features for about eight
months was that you had the product team
is
you know antsy to have these features as
they've been waiting for to be developed
and at this point we had three three
licks for absent production and on the
the Phoenix elixir actos side of things
there were no major releases and yeah
and so feature development I've been on
hold for for six or eight months we had
a big backlog and part of that backlog
what part of the promise from the
electric side of things was that we had
the team had all these different kind of
content types that they wanted to add it
to the app so Instagram Facebook tweets
and various other things and because of
the data modeling choices that we made
earlier it was very difficult to one add
these and to it was non-trivial work too
because you we're still thinking in
terms of models so instead of thinking
of things for example as change sets we
thought of a tweet as a tweet model and
Instagram is an Instagram model and
stream video and it became very
cumbersome and slow and lots of data
migrations and very messy and because of
the decision choose JSON be it was very
difficult to validate them listen you
had to take that and transform it from
json to map validate the fields and so
on and we were essentially losing out on
all the built-in model validations and
ecto and Phoenix and you can see the
humps there's the we started adding more
and more content and it wasn't
sustainable so the next phase was
refactoring this was perhaps the biggest
other than deciding to use elixir and
Phoenix in the first place this was the
biggest decision and the biggest
undertaking that we had to do now you
can see these charts are quite
remarkable and striking and it also sort
of a time of experimentation I think
I've been doing elixir for about six or
seven months now and the first well the
first giant spike is when we started
doing we started just adding content
types as models and then I was doing
some this very sort of difficult a
difficult way of meta programming and it
was like if you it would have been very
difficult to get a new elixir program
when I say look at this code what does
it do it was it was very unclear and it
wasn't you know this isn't going to work
we have to figure this out and
we decided to redo the mod the data
modeling so before I stream had many
items and that was it was just one layer
and this was and why we decided to it
afterwards was it a stream as many items
and each item has one content and each
continent has one metadata and the way
that we saw that was that the content
was basically a mutable data that the
programmer like the the content
programmer would add so it would be like
a title or description or a thumbnail or
a video depending on on the type of
content and the metadata was data that
didn't change author name provider URL
provider name these kind of things stuff
that wouldn't change over time and the
way that we did this was that we keyed
off a content type so each content type
added I have a unique key so whether
that was an article video article and so
on and it made for a much more
declarative way of developing as opposed
to saying well maybe this is this
content I because it has this key or
other so on it was it would said I'm
this content validate me as such this
was also during the release candidate
phase 4 ecto 2 point 0 and this is
another interesting change in the ecto
landscape were before you are validating
on a model and then they change it to
data and this was also a very small but
very intentional change that that helps
me to sort of understand how to look at
data or models and in the functional
world and then it's not a model it's
just a collection of data and you
transform it and then something else
comes out the other one it's either
valid or not and so on and this was this
was something that touched the legacy
app in a way that we never done before
um this was incredibly difficult to deal
with we the way dealing with it with get
it to work was by having a shadow
production environment and having a
production environment because we have
we have offices in San Francisco New
York and London so we don't really have
a down time and their sports usually
going on all over the world or we have
there's never really a down time so it
was very difficult for us to to just
flip the switch and hope it worked so
ended up having to go back and forth on
this shadow production in production
environment four or five times and you
know you would get sign up from the app
team from the web team and so on say
this you know
this looks good with flip it to be like
oh this field that no one knew about is
actually causing everything to crash so
we know the Android app isn't working so
we flip back and it was a very difficult
time not a lot of sleep for a few days
but eventually we got it to work and we
really had a lot of support from a
product team and our engineering
managers and dave mark Susan J senior
engineering of senior director of
engineering was incredibly helpful in
saying you know it's okay if it doesn't
work it doesn't work we'll do it again
and you know it also sort of gave us the
confidence to keep going and disfigure
that you know we'll get this right
eventually and and we did and it paid
off in in great dividends so here's an
example of of a new content type so on
the on the right you have the insert
change that in the cast change set so
you have the top level which is the
stream and then the stream has the has
content or content has a meta data and
so you on the the arguments of the
function or the model but this is before
active 2 point 0 so still Model Model
params and the content type and and then
you pass in the content type into the
cast change set and then it casts at
based on on the various skills so we
were able to only have three tables and
we I think we have now about 15 or 16
content types and what took a day or two
before to model now takes an hour or two
and this is actually a very good way for
new developers to start working with a
lick sir because one it gives them an
idea of how change that works and how to
how to model data in a functional in a
functional way but it also gives them a
sense of accomplishment and in a very
easy way to do that because this is
something that's that's very obvious in
the app you can say look you know I did
this little piece now we have this new
content but now we have a tweet now we
have like a podcaster or whatnot and
it's it's very easy to test as well so
this is this was the biggest this was
the sort of the Keystone on on on which
we base all of our new development on
and it made life a lot easier and it was
it was essential to developing our
back-end team to be elixir developers
and at that time as well
standardizations had not really been
around and elixir I mean there were you
know very style guides online and this
and that but we didn't really have a an
elixir style per se as a company and
there were a few different libraries
that came out dogmen was one and that
was just a basic lender it says this is
wrong this is it this is wrong you know
you're missing a space here and this and
that and we found crato which is the
which is a great tool because on the
right it'll give you it tells you why
and then you can actually go into the if
you run credo on the actual line it'll
go in and give you like a full page
explaining why this is not an optimal
solution and it's it's really great
because it makes code reviews that much
more meaningful because normally I don't
when you when you review code if you see
that there's this extra space here that
those are obvious and easy things to get
out of the way it's you're like okay I
reviewed your code I have these small
these small changes to make and it's
really a superficial code review but if
you have if you have use a tool like
credo which takes care of all the
superficial stuff for you then when you
review the code you actually have to
look at the code you'll have to look at
the flow the of the data you have to
look at the architecture of the of the
pull request and so on and it makes it
just makes the life a lot easier we use
X coveralls as well to make sure that we
have high test coverage and in checks
which is the elixir version of inch both
credo and in char itten by Rene ar ar ar
e ne i think is this github handle and
then i can't recommend them enough and
the nice thing about having a high test
coverage and then having you know these
documentation using inch for
documentation using and credo for these
simple superficial code reviews is that
and also the fact that elixir is a
compiled language it allows you to to
refactor big chunks like a be very
difficult to do this with ruby because
it's a dynamic language and you know if
you maybe there's no compiler to say
this is wrong with this is you know this
isn't going to work it allows the
developer to move code around freely so
in to think of terms and functions and
modules instead of thinking of models
and these kind of things um so this
lettuce you have consistent code style
across all of our licks reps
and and this was really the way that we
were able to onboard our developers to
elixir and after this stage we add in
another stage of features this was we at
this point we had four elixir apps and
two more in development these most
significant of these new apps was our
push notification service we as I said
before send I think three billion push
notifications a month um the older push
notification library was or service was
written in Ruby and we had these
external workers and there was all of
these various caching mechanisms and it
was very slow so depending on the number
of subscribers so if you subscribe to
NFL and save the new england patriots
and you send us subscribe to both you
obviously don't to receive two messages
so everything has to be duped and then
Ruby this was very slow so depending on
the number of subscribers it would take
from one to five minutes and with the
new version with the elixir version it
was very simple there were no external
dependencies it was gin servers and it
was and if Jen server so it was very
easy to to reason about and we were able
to get rid of this third party service
and the most meaningful thing was before
it would take you know a minute to five
minutes and now when the content
programmer would push the button to send
the alert they would immediately get the
notification so this was a demonstrable
win both in terms of saving on
third-party libraries in terms of
servers in terms of server costs and as
well as being able to have competitors
apps on your phone and game ends and
your notifications are consistently
fastest I mean this is a win across all
areas of the company and so the NFL
Draft I mentioned before is sort of our
yearly we can guarantee that this is
going to be the busiest night of the
year and this was the first year that
we'd had our elixir absent production
and in years past it was sort of a nerve
wracking night because we had all these
auto scaling rules in place for the ruby
apps and you know in years past there
have been some rocky times and so on and
so this year we were all sitting at the
at the office watching the draft go by
and we're wondering you know it's gonna
be okay you know well we're all nervous
felt fairly confident and from looking
at it from a metric standpoint
nothing changed the metrics are flat it
was just like any other day which is
really amazing to see and nothing
happened it was it was call night so we
just ended up sitting around talking and
it was a win across the board for for
that and the only sort of hiccup we had
was one service it was still using Ruby
and we because of these cashing with
reticent he's kind of things with the
developers ended up having to manually
flush the cache over and over to make
sure that it would keep updating and but
other than that I went to find and then
with unpredictable traffic spikes during
Kevin Durant he he joined the Warriors
and this was a huge news unexpected news
the traffic spiked in four minutes and
again on the other side of things
nothing changed it was remarkable so
that was that was just another testament
to how how well elixir is working for
the things that we needed to do and the
final thing that we had done on the
feature side was to move all the lists
blending to one app and this was this
part of this was understanding the
architecture that we had and
understanding how we wanted to take the
monolith apart so the the last the the
cache the last big piece of caching
problem that we had was on the NFL draft
night was basically when you open the
app you get your blended streams and
that we had cash with Redis and so we
move that into the into the main app
that this app that we were using to do
all the list management and and these
kind of things and it was the most hit
in point in the system so we were a
little nervous again about is this going
to work then and it would it performed
remarkably well and there were there was
obviously an increase in traffic because
we weren't like fastly we use fastly to
cache the streams that we can using
surrogate keys so that we only get
probably about we have about a ninety
percent hit hit right on fastly so with
the new blended strain we weren't able
to catch that and you can see here what
happened so before we were getting very
few actual hit request to the elixir
side of things so part of this was the
the efficacy to which we were using
fastly and then on the right at the
spikes are when we moved the the
listener the the home page of the app to
the elixir app as well and now we get
about a fifty percent hit rate and this
is about a daily
this is daily sort of traffic or not
daily but I mean you see the the the
wave patterns that we get over day over
today and this is the response on the
elixir side and it's pretty remarkable
that doesn't change at all there are
ways that we can improve this we since
we use docker to deploy and each of our
apps are isolated in containers we can't
really use ETS tables because each ETS
table is only for the container itself
but this is something that we're
improving over time and we'll get there
eventually and this is I can't stress
this enough encouraged into a duration
had we we wrote sort of sub optimal
elixir code in the beginning to say the
least and over time we still are
iterating over each app and each each
actor released each Phoenix releases a
time for us to sort of evaluate the code
and define ways that we can approve and
write better code and i'll show you some
examples of that so with ecto change
sets as I said this was a this is a huge
part of of how we came to understand
elixir and Phoenix and a good and in a
good way so this is the first one way I
showed this before we take a map you get
the the track from this leap from the
map you get the destruct and then you
just update that into the database and
then you return the track and this was
after active change that's where
introduced you have a change that you
have a model you validate it and it
returns it and at this point we had this
was after acto it said if there's no
change that we can't guarantee data
integrity so we did the bare minimum to
please ecto here's the next iteration so
this is this is much more indicative of
what you'd see in there you know in a
full in a more mature elixir app so we
had the the top-level item the the the
content item and then the metadata and
then the the content all of these were
wrapped in a transaction transaction and
so you evaluate all these various fields
so this is the way that
made sure that it was a valid content
type made sure that the URL based on the
content type was valid and do lock the
position doing all of these things that
we would have done in callbacks or
elsewhere in the application and like in
a ruby in the Ruby world would have done
we managed to this all here in one place
and this is the current implementation
so this is very similar to the other one
except that now we have figured out that
you can do this cast associated content
so we're able to basically do the same
thing without the extra boilerplate of
wrapping it in a transaction so you
validate all the fields at the Casa fees
associated type and validate all of
those fields and if those all pass then
the validation then the the the data is
inserted another element that we worked
that was sort of a selling point of
elixir was the ability to do a lot of
things at once so for instance if you
need to add a piece of content to all
NFL teams or all you know soccer teams
or all-nba teams and these kind of
things this was very slow and at the you
know there's 32 NFL teams I think
there's about 700 NFL players there's by
you know couple thousand soccer teams or
football teams if you prefer and then I
think there's about seven thousand
European football players and and this
was incredibly slow it would time out it
was very unreliable and here was our
first go at it and this was pretty
poorly done but as Andre I mentioned
earlier about the difference this is
eager loading so basically would do all
of this in the know of this and then it
would flatten it and using task and a
cinco and a white there was pretty
unnecessary because it had to wait to
finish this before we go to the next one
so and but this was still actually
better than this is a pretty naive
implementation but it was more
performant than the ruby version here's
the next version this was sort of
something in between where we start with
a stream and then unique which doesn't
make sense and then go back and forth
but it was better performed as well and
this was also if you this was before we
decided we were using change hats to
validate content so this is sort of
it's not a very confident way to model
your data make sure that well does this
is this actually unique if you're doing
bulk updates you have the same ones and
then make sure you know filter these out
like these are things that should have
been done and change that so we're
trying to sort of artificially insert
into this create track interactor that
we had and it worked but as you can see
we we were not really benefiting from
the ecto change that or from from the
Phoenix validations and this is our
current implementation so basically it
takes it chunks based on the size of the
of the number of playlist so you're
trying to add to a playlist or the
streams was just the internal the
internal name we have for them and then
it creates them and creates the tracks
in there and then it returns it at the
end then this actually worked out pretty
well because we were based on the the
length of the list were the chunk signs
changes so what before would take if you
wanted to add a attract to all soccer
players it would take 15 to 20 seconds
on it would timeout it was very
unreliable and now it takes under a
second and the chunk size is based on
the link so if you only add five only at
the five streams within the chunk size
would be smaller if you add the thousand
it's different so it actually worked out
pretty well and we can actually add to
all streams in under about five seconds
but there's never need to do that it's
just a sort of a use case for us to see
and so here's what where's Alex or
bleacher report you've seen sort of how
the development of one app has sort of
spread to the development of other apps
and and really to the two adopting
elixir bleacher report so now we have 66
elixir apps in production we have three
more in development and it's kind of
interesting the way that we've decided
to to sort of break out the monolith
because we do it on a sort of need basis
so the first one was was one was falling
over with the with the list merging and
then the next one was the app that I
wrote and that was more of an experiment
for me to see if i can write elixir and
then
after that was the push notifications
which was a huge win for us and now
we're sort of talking starting to break
apart the internal tools like the writer
tools the way we generate articles the
way we generate sort of our tag
hierarchies that's our sort of next next
steps and we've just we've been on a
lick search so much that all new
consumer facing apps have to be written
in elixir we have Ruby developers who
for whatever reason maybe I mean
everyone can write a lick sir but some
sort of refer Ruby it's comfortable so
if they want to write a ruby app it has
to be an internal facing up an admin app
a card app so so you're sort of limiting
yourself by writing a ruby because you
only you're not going to be the general
public aren't going to use the results
of your your code the stakeholders are
very happy we have tangible benefits
this is very easy to show server costs
we've we're still over provisioned on
the number of servers that we use in
this is just sort of overtime we're
fine-tuning it but I mean we save quite
a substantial amount of money on servers
and third-party integrations as well for
the post notifications we're using these
third-party to sort of send out the
notifications and all of that is done
in-house now so it's really rare I think
to have developer happiness to have
stakeholder happiness and have product
happiness as well as increase
productivity so this is a really easy
sell I think if you're considering
elixir in Phoenix and then Gary part
barnhart posted this the other day um
finally learning Phoenix the docs are
good and rails with a lot of met of the
magic remove definitely feels accurate
so far and I think this is a good
selling point for Phoenix um I don't
know that the Phoenix team would agree
with that because I feel like they feel
it I think that they're doing something
different than rails but it's it's
definitely a good sort of siren call to
Phoenix it says it rails you're doing
this it's familiar but instead of you
know though there's a sort of in the
rails world automatically automatically
doing things in the elixir in Phoenix
world that's that's removed you have a
con you pass it around you manipulate it
and you returned it and I think that
leads to better developers in the better
development when you understand exactly
what's going on I mean there might be a
little bit more boilerplate but i think
the boilerplate is worth it when you
actually understand the
the transformation in the manipulation
of the data and you know and also with
as ecto moved away from models to data
Phoenix 1.3 is moving away from having
models to having everything under the
lib directory and from models to module
so I think it's an exciting time to sort
of and both an exciting time to be
working in this ecosystem but also for
people on the outside to join and so
finally a summary of where we're going
from here all of our back-end developers
can write a lick sir on this app that
I've been showing the the graphical
history of there have been 16
contributors which is more than back-end
developers that we have we've had some
obstacle make contributions had some fun
and people make contribution it's sort
of then sort of both a experimentation
pool and also is an introduction to
Phoenix and elixir and it's enable us to
make all of our developers be able to
write elixir and then even the front-end
developers are sort of interested
there's sort of a a revitalization of
the developers in the sense it here's a
new language here's Phoenix there's
elixir try something new and they see
the you know it's it's it's very
rewarding from a development side of
side of things when you say hey here
look at this I have done we wrote this
new code now we're using you know X many
less servers we don't you know we're
saving this much money this makes me
this as a developer I feel really good
about this and the front of people I
can't this is really interesting I want
to try this too and you know the way
that we sort of introduce new developers
is you say we give them the programming
elixir book you learn the syntax learn
sort of the standard library and then we
take an existing project and have them
do small features and as mentioned
earlier with the standardizations that
helps them quickly become pretty decent
elixir developers pretty quickly and we
started a sort of open sourcing our
internal tools so look for more of that
from the bleacher report account and
we're sharing our our experiences at our
dev blog so devilish report com we cover
many topics but you can see how we're
writing sort of more elixir based stuff
because that seems to be more more
interesting to people and with that any
questions
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>