<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Kraków Erlang User Group meeting - Bob Ippolito - 'Random Choice' | Coder Coacher - Coaching Coders</title><meta content="Kraków Erlang User Group meeting - Bob Ippolito - 'Random Choice' - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Kraków Erlang User Group meeting - Bob Ippolito - 'Random Choice'</b></h2><h5 class="post__date">2013-10-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yAwJgp1b72c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I I'm coming here from San Francisco
I was in the neighborhood I was at a
conference in Budapest so I thought I
come up to crack out and say hello but
I'm living on Thursday so unfortunately
I don't get to explore a lot of the city
but I thought I'd at least mean to the
local lawyers and give it time so today
I'm going to be talking about random
choice and just randomized algorithms in
general and why this topic well I've
written an answer burn airline and
randomized algorithms are useful for ad
serving and they have some other
interesting applications as well and so
a little bit about airlines random
module I mean you all are airliner so
you might know a little more about this
but the algorithm used by the random
modulo airline is very very bold it's
designed for 16-bit computers and it's
not really a very good random algorithm
we've done much better since the 70s or
whatever that I were to turn the 1982
sorry and it has poor results and you
probably shouldn't use it but because it
has a nice beautiful interface with side
effects it works well for slides but if
you are actually doing real work with
with random numbers in our life you
should consider using either the crypto
module or perhaps a third-party library
like sfmta airline which implements the
Marisa
twist your algorithm which is commonly
used with other programming languages
languages such as fighting so one of the
simplest applications of random numbers
is to simulate a fair point so you flip
a coin half the time roughly heads at
the time tails and to something like
that with the uniform function in the
random module you simply call it heads
when you get a result less than 0.5 and
tails otherwise and so here here's just
a little simulation of what it looks
like to flip a fair coin and so we're
getting numbers between 0 and 1 and if
it's less than 0.5 we consider it heads
and color applies and otherwise it's
black and you can see that it's not
perfectly fair we flipped it 13 times
and eight times heads and five time
scales and that's that's expected if
there if there aren't some aberrations
sometimes your algorithm probably isn't
truly random and so another common thing
to do with a random number generator is
to simulate roll of a dice or choosing
an integer between 1 and n and this is
very easy to implement with the uniform
function are you simply add 1 and x n
and truncated but airline implements
this in his own library so you don't
actually
a minute you just call a uniform with
one argument and this is a very similar
to the simulation of looking at point
but when you flip a dime there's six
possible choices as you can see it's not
perfectly balanced but that is expected
and totally okay if I did this enough
times it would look very similar okay I
was a little worried there might have
been a bug their side of city sixes but
it's okay so when you have these these
algorithms to generate random numbers
you can start doing more interesting
things with it 11 algorithm is called
random selection without replacement and
so what that means is you regularly
choose an element from your set and then
for the next iteration that element is
no longer in this end so you can use
this kind of algorithm to simulate
shuffling a deck of cards or or a list
or perhaps choosing a name from a hat
for a raffle and implementing this in
enter line with the random modules very
simple you simply give the list as input
and you picked a random number uniformly
for the index of the list you split the
list and then you combine the beginning
of the list before the choice and then
the list after the choice and of course
if you pass in an empty list this will
explode because you can't choose an
element from an engine list and here's a
simple simulation of what random
selection without replacement looks like
so we picked the last one okay that
doesn't look very random but it should
be see there we go and you see it at the
end here we're out of elements to choose
I decided instead of low
this implementation would simply start
over with with the list that we had
shoveled so this kind of algorithm is
commonly used with with games or any
other situation where you don't want to
be the source list to remain the same
and so to get a little more complicated
more real-world out of the weights when
you're choosing are not always uniform
so you have some selections that you
want to happen more often than other
selections some examples for this will
be unfair dice or perhaps add selection
so in an selection waiting is very
important because some ads are worth a
lot of money and some ads are worth
almost no money so you want the ads with
a lot of money to show up more often but
you still want to give the other eyes a
chance we're also if you're simulating a
sporting event for example you expect
one team to win more often than another
team so you wait the selection and so
implementing this gets a little more
complicated here's a very simple
implementation it's not extremely
efficient but we maintain a a counter
for the total sum of the weights in the
list and then for each element in the
list we have a key which is whatever
identifier we use and then we come to
wait for that key and so we and here I
didn't have em on the slide to actually
choose the end but we choose n as a
uniform right of a number between one
and the some weight and just liked it we
simply iterate through the list
subtracting the way from n until n is
less than zero and when n is less than
zero then we take the New Sun and the
new some or we take the key that we
found we take the sum minus the weight
of that key and then we combined the
accumulator with the rest of the list
but because it's erlangen we build
simulator back to front we have to
reverse it so that the list is in the
order that we start you and so another
common algorithm is to do random
selection with replacement so this is a
little easier to implement because
choosing an element from the list
doesn't change the list and this is
similar to just rolling a doctor you
have a list between one and six and then
you do random selection without
replacement and its equivalent so
because it's simpler the algorithm is
much simpler we just choose a number
based on the index of the list and call
this m and that's it and here's the
simulation of that basically the same
sort of thing except the original list
doesn't change and in order to make this
selection waited we have some some
options some are very simple the
simplest option is just add the item to
the list multiple times so in this case
we want a to be chosen about half the
time and DC and need to be chosen about
16 to time so in to implement this very
simply we put a list three times and the
other elements going to list once and
that looks something like this
so the asterisk it shows a little more
frequently because they their chosen
about after time and the nite solution
here uses a lot of memory because you
you have to have all this cell for each
time that it's in their tent well this
gets larger as the weight distribution
changes you have problems where where
you have to put it in a lot more times
than you would want to because of the
way that the numbers divided into each
other but you can do much better by
counting these unique choice so the
trade-off here is that it's harder to
sync to the other choice but you can see
that we only have to occupy one cell /
unique element in the list and you can
do even better than that there's very
interesting algorithm called the alias
method and so how the alias method works
is you create n virtual points one for
each unique choice so in this case we
had a b c and d so we have four virtual
points and now to choose a coin to flip
we first roll a die so that guy has four
sides on it and then after we roll the
die then we flip the coin so to choose
from any number of sets with any way
whatsoever we only have to roll to rain
numbers we roll a die and then we flip a
coin so we have 0 1 selection regardless
of helping the list is or how the
weights are distributed and it also only
uses o n memory we only need one cell
for each distinct element in the list
and there's a very interesting algorithm
that allows you to initialize it in
linear time as well but unfortunately
the algorithm here doesn't fit on the
slide but if you if you want to look
into it is called the boats alias method
and here's a simulation of what that
looks like
so in this case we have four coins
there's the coin for a so if we choose a
a happens one hundred percent of the
time if we choose the coins would be to
search at the time you choose being
otherwise one third of the time we
choose egg and you see if you add all
the numbers up a happens half the time b
c and d half and 162 the time so here we
roll the die we got one and then it
doesn't really matter what what point
you clip because one hundred percent of
the time it's a and here we roll the
four and then we not a value less than
two thirds so we chose deep and so this
is a very efficient algorithm for
choosing a weighted selection with out
replacement or with replacement sorry
and so the reason i was looking into
these these different algorithms was one
for the out server but to we had an IRC
bot that would randomly say stuff and it
turns out with this that if you
implement this poorly and you put a lot
of text into this RC bottom then it
becomes very slow the initial version
does not actually ended up using so much
memory couldn't run anymore and if you
use this very clever algorithm however
you you reduce the non memory used and
you make the choices very fast
unfortunately it's very expensive to
update because you have to update the
entire list every time and so if enough
different words are said then it's very
expensive to say more words or even just
update the counts of existing work
because you have to update this entire
list especially an airline I worked a
purely functional data structure and
there's no sharing at all because all
these distributions are changing by way
of it by the method that you use to
build this data structure so this is
actually a pretty difficult problem to
solve with with Airlines purely
functional data structures so so one
possible solution would be to use a tree
like you have gb trees or the dick
module or something like that and this
gives you pretty fast login updates and
you generate one end garbage because
there's good sharing between versions of
this tree but the problem or a potential
problem is that seeks get a lot slower
because you have to essentially seek
through the whole tree in order to find
the weight that you're looking for
because you organized the tree by key to
make updates efficient so another
potential data structure that I found to
be a pretty good compromise between
speed and memory was to simply use a
sorted list and so the way that you make
this relatively efficient is you put the
highest weighted elements first in the
list and the nice thing here is you
generate less garbage because the
highest weighted elements are more
likely to get updated again because they
happened often in the past so they're
likely to also happen often in the
future so updates don't generally create
a lot of garbage and like like the tree
solution there's a worst-case oh n for
every operation but it has a very good
amortized common case because all the
big numbers are front and you're more
likely to choose that and so what I have
here is I have a database full of words
okay so here's a a escrowed Dykstra
quote they were mostly
and talk with the self assurance that we
tend to connect with competence and so
in this distribution here we see the
word which occurs twice so if we start
choosing words here it doesn't make any
sense but if we add more words then we
can see that when we choose from that
list it should often choose towards the
top so in the top here we have the top
10 elements that if it gets below the
there then you'll see the bottom of the
table and if we had a whole bunch of
quotes then this text makes even less
sense because we're really just seeing
the most common words there's no
structure at all in order to make text
that makes a little more sense you you
can use a technique called Markov chains
where you represent the the words as a
finite state space and the interesting
thing about Markov chains is that
present future and past states are
independent you only have to store what
the current state is and so you
represent a Markov chain as a graph
where the edges represent the
probability force a change so with with
text we simply have we simply have a
node in the graph for each word that was
said and then the edges represent when
that word was sent after the previous
word
and in the implementation of this in
order to have it generates sentences you
simply use a special token for start and
stop in this JavaScript case I use an
empty string for for the star token and
some other string for the stock token
and you build a weighted selection
random awaited random selection data
structure / work so it's simply applying
the the data structure that that we
built before you're applying at end
times in order to build this Markov
chain and so here's here's what that
looks like so we'll add a go to the
database which is one core so we see the
word with happens twice there and that's
the only choice point in that graph
otherwise the word where only comes
after day so when we when we generate
something from from this graph we have a
one hundred percent of the time work
happens after that 100 at the time after
work the word mostly happens but we can
see it's something a little strange
happened here it didn't copy the entire
sentence because when it got to the word
with fifty percent of the time the word
that happens next and fifty percent of
the time where confidence happens next
so we got a shorter sentence here but as
you can see it is actually even correct
English in this case which was a lot
better than just choosing random words
ok so here hira was able to generate the
original sentence and here it actually
generated the same phrase twice because
it simply chose the word thug again and
it can it can generate arbitrarily large
text like this but it's very unlikely to
do that and so if you start adding more
quotes here then the words make a little
less sense
but but it produces that instant it kind
of makes sense program is given the self
assurance that we tend to connect with
confidence it's not a lot of sense but
it still looks like English and that's
that's really the task is if we build a
data structure that represents the
probabilities of words that happen next
to each other in English this will be
big room that's some from rust ok people
people who have actually done this I
think and I think maybe once or twice a
paper has been accepted we generated
using this technique some price for me
and if we go ahead and add a whole bunch
of course here we hopefully will we'll
see something a little more interesting
with all higher level programming
languages that kind of bullying as
education proof at the computing
community displays a criminal offense it
is right a software engineer so you can
pleasure generate like poetry almost and
although in this case it doesn't serve a
useful purpose it provides quite a bit
of entertainment
alright so then that's pretty much all i
have today but these slides are
published online and github and if you
have any questions you can ask them to
me right now or feel free to email me or
send me a tweet thank you any problem
has only to a certain extent like that
sometimes want to force some values all
of the system because because of the
randomness that they were never chosen
and sometimes its desires like this did
you ever try to do something that sure
so in our ad server there were certain
decisions that we wanted to be made on
percent of the time usually this would
be the exclusion of showing it like say
you've seen an ad too many times we
don't want to show that to you or you're
in the one country to display that and
we simply filter the data sets before
running the randomized algorithm in
those cases the most important reason
that we use these randomized algorithms
is this no coordination was necessary so
we have all these observers making
decisions completely independently from
the decisions authorized service making
because we could choose randomly it
didn't
to be in some specific sequence because
otherwise maybe one request they would
then when I'd serve or maybe some other
requests they were did a different
answer because I rest up with the random
game other reasons beyond the behavior
that increases the chance of some event
happen as after time so whether we have
a chance of that study or something
percent of doing that after I know and
tries it will always happen because it's
more playable that way sure um so we had
in our answer where it kind of worked
the other way basically you would have
an ad that had a very high weight and
then you saw that ad and then if the
weight would be exponentially less or
logarithmically less so then the more
time you saw that ad the probability for
seeing that again would eventually go to
zero so if you wanted to simulate the
other case you can simply use a number
or so large that that isn't completely
improbable for anything else to be shows
that would be one way to simulate
another way would be to simply have say
a case statement but if it happened ten
times then then do this and I don't know
what they're there was like a general
solution to that problem
could you tip a little bit about this to
other modules that are available in
comparison to the decebet for under
module this was kind of random from
people okay so I talked about three
modules the first one was the random on
obviously the second module was the
crypto module the crypto module ships
with airline the the advantage is that
you can get cryptographically secure
random numbers the disadvantage is that
cryptographically secure random numbers
are much lower to generate than then
pseudo-random numbers squid without so
much entropy the other month like talked
about was SMMT hyphen Caroline which is
available on github and if you go to the
slides there's a link to it on that
slide or you just search for smt
parallel and so that's that's
implementation of the marathon twister
alberton which is simply a much more
modern an algorithm to generate random
numbers I think it's from maybe the late
90s and it works with I believe I
believe that SMMT algorithm might use
64-bit integers which allows it to much
more efficiently utilize today's
computers and generate you know 60
actually more than 64 bits of redness at
a time whereas the random module would
do 16 visited time because it was
designed for 16-bit computers with with
32-bit floats essentially
and there are pistol is a concern
they're the same thing there there Ellen
face implementations in those two
modules so the in the crypto module it's
all implemented in C because it's really
just calling openssl in the SFMTA
airline module I believe that they have
to compliment ations they have a much
slower one who ended up here early and
they have another one that's implemented
is I think I'd named so but but I think
it's pretty well tested it's been out
there for a few years so I would be
pretty comfortable using an introduction
so you know what happened to approach
Kenji been a detective came up with an
idea of changing my interface to the
existing rather marvel to accept like
five kaga mercy I think that's the
algorithm yorklyn on 64-bit precision
seat base they they were discussing it
to introduce it to the original airline
another nice between you know what
happens to death I do not know I wasn't
closely following that this guy 900
people were pointing out that the
cartridge limitations pretty weak and
doesn't give you much rather than this
yeah yeah the current limitation is very
weak I mean if you if you generate a
seed that has zeros in it that it's very
very weak and mostly people generates
cc'd use over like now which can very
easily have a zero in it somewhere so it
is really a poor choice but you know its
ass it was yeah
but I believe Richard Oh Keith had a lot
to say about that foundation for you in
our at our ad server we were actually
using the crypto random number generator
and rosanna bah so for most applications
you shouldn't expect they have a
bottleneck in your random number
generator especially if you're using a
good algorithm like thank for all these
examples in order to choose an element
from the set you would generate one
random number there there are other
randomized algorithms where the speed of
generating or I'd never make it is a lot
more important for example there are
some sampling algorithms where where you
have a data set a stream of data and you
know you don't even know how large the
stream is and so each time you receive
an element from that stream you have to
use you have to generate a random number
to decide whether you sample that
element or not so you build like a
bucket of however many elements you want
to keep and you can without knowing the
size of the list and without choosing
all of the elements from from that list
you can have this bucket of samples
going for those arguments it's very
important because you're choosing a
random number forever
a single stream element that you process
so in those cases it would be a lot more
you might find that game and like a a
performance metrics library like if you
wanted to see what the the media
requests time was that you might use an
algorithm like this because you don't
know how the request you'll have I think
those held up my development as hype by
him I think that's the folsom uses the
bathroom for like selecting person
titles or beings from the news yeah I
mean then that would certainly help a
pure airline solution but I haven't done
any
doesn't have to be about this as we talk
about anything
we are here at center
the most part of it so the most
expensive part is that the ad server
participates in several ad exchanges so
for a given request we're sending up
multiple HTTP requests to third parties
yeah so in many cases that that is the
biggest bottleneck in some cases we have
an ad in our own inventory that we can
choose in without any third-party
requests but in cases where we make a
third-party request that is most circuit
bottom line other bottom lives in the
past have been a memory for example
because we've put the entire the entire
database of potential ads all in memory
so that we could choose from very
quickly and we ended up working around
that by tape taking this data structure
and compiling it to a beam fun and
loading it as a module this allowed us
to to represent it in a data structure
that would be shared across all
processes because as a single gem store
it's a bottleneck but if we don't need a
jet server at all like any process can
speak to this data structure with no
copying that then we eliminate at the
bottom so that's that's why we ended up
from piling to a b-boy because that the
data structures that are constants in
modules are shared it's basically
referenced comment because processes in
airline maintain references to the
modules the versions of the modules that
they refer to so it's able to use data
structures from those modules without
any copying is it tell me more well it
is it's read only until we loaded a
version of the module so we modify an
angry
you can just use kiss tables you can use
ETS tables but ETS tables require
copying in order to do anything so it
generates a lot of garbage like say for
example any given an add request we
might consider hundreds or thousands of
and then that would all become garbage
that we need to be copied and then
collected but we have tried solutions
with that it might be possible to more
cleverly use s but this this kind of
selection the kind of we were doing it
it proved to be difficult because the
weight of an ad is different for each
user based on the ads that they've seen
in the past so we can't simply store
them at some fixed border we have to
walk most of the data structure most of
the time all right at least within the
countries that that irrelevant to them
yes that's it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>