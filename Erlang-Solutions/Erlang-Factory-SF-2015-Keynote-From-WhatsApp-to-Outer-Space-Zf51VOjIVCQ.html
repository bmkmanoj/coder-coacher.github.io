<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2015 Keynote - From WhatsApp to Outer Space | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2015 Keynote - From WhatsApp to Outer Space - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2015 Keynote - From WhatsApp to Outer Space</b></h2><h5 class="post__date">2015-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Zf51VOjIVCQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well good morning everybody that
Francesca asked us if we would give a
talk him he said yeah we're good at that
we've done it before so we've done it
before me Joe hello Joe Mike no Robert
he also suggested that we've done it
before so many times and talked about
the past that you people probably don't
want to hear it first old fogies talking
about the past again he said what can
you talk about the future we said what
were old fogies we don't know anything
about the future but we can if we can
invent the future of you so um I thought
I'd start and I start talking a little
bit of what I know about which isn't
much and where are we today as far as
erlangen OTP is concerned well a lot of
people actually using our life meaning
if we go back to when we work with our
line in the 1980s 1990s I never could
have believed that I've stand here in
San Francisco I said to complete all the
people talking about I find it quite
amazing and I firstly would like to
thank you all for being here and using
our lying i think it is amazing i am
very pleased and very happy so for that
i'm proud the other thing is if you look
at them and look at the companies which
are using air like that we put the one
which made most money out of it first
because that's the most logical that
whatsapp 19 billion dollars that is
incredible I think it even caused some
of the sleepy management to direction to
wake up and say well there's some
company of 19 billion dollars good god
what have we done so then of course
there are other companies that someone
told me the machines own are making a
million dollars a day selling their app
and their converse I I don't use
computer gearing myself but I think
that's incredible i'm not going to go
through all the list but it's a long
list and i'm sorry that i've probably
forgotten some people here would
probably feel offended that
their names are not on the distance
apologize for that and there are some
big names which are actually using
airline but they don't like us to talk
about it so we won't least won't do it
loudly especially not while being
recorded so what do they do that
messaging in various forms control
mobile telecommunication systems that
erection has forty five percent of the
mobile cellular infrastructure in the
world running through ericsson systems
if you make a if you're using data on
your mobile phones you almost certainly
at summerstage during the day are using
ericsson equipment and that Ericsson
equipment actually uses airline to
transport the data not the data the data
path is actually done in C but the the
control is done by airline so using
yelling every day although you don't
know it network management that my
friends at the computer science lab when
they disappeared and formed their own
company landed up eventually in the
company called tail f which is both by
Cisco and now using airline to manage
enormous networks of Reuters and similar
things banking I never would have
believed that banking is out there at
least two companies doing banking with
airline and one of them Volker link in
Singapore's the name i can mention the
others they probably can't database
management we have basher doing react
that again this is something we never
dreamed it would be used of when we
first work today like online gaming that
the latest one he likes that you like
games
I don't that's all several companies
doing online gaming online advert broken
in with head roll a lot of other things
i'm sure there a list could go on and on
a lot of things we don't even know about
and it's done it again it's joe's
machine he he he likes it he likes these
funny things called max I refuse to use
max I refuse to you that I refuse to use
either windows or max I use you bunt 0
on my linux system and the thing else
that's a sort of matter of principle and
the serious inconvenience as far as I'm
concerned well what do these
applications have in common they're all
server applications which is right there
all multiprocessor most multiprocessor
they also huge numbers of concurrent
transactions the zero down tiny making
fault tolerant systems a lot of them use
that someone don't allow some use that
but that's that's all then and we're not
really surprised about that because
that's actually what we designed our
line for and what we actually designed
their line for back in the 1980s 1990s
strangely enough it's very well for the
modern paradigm of distributed computers
multi-core computers and the internet we
didn't know that at the time so I can
only think that we were either
clairvoyant or we were extremely lucky I
think being extremely lucky is probably
more accurate
it's important to understand and I think
this is one of the reasons that some
companies don't use hairline but you
can't use our line for everything it
fits the bill entirely if the
applications are discussing but even all
these applications have got little bits
of sea and web browsers are using other
technologies in them it doesn't work
very well for number crunching it
doesn't work very well for digital
signal processing and that sort of
application but nowadays I think we've
reached an understanding that when you
build systems you use different
technologies for different parts and I
think that's really well understood
nowadays it was certainly was not
understood 1020 years ago when people
thought everything should be written in
C++ or everything should be written in
Java that we understand the different
parts require different technologies and
graphics is another example that you
really can really do graphic snare line
but a lot easier ways to do that
wxwidgets sucks
maybe we should actually start working
on these areas to get some decent
graphics you use their lining the wide I
don't know I'm quite happy as we are I
think that most of us are such as long
as there are companies earning 19
billion for business which they do some
of that money to me but that's a
different matter okay now it's all over
to Robert yes done we weren't like you
were brilliant my comment to that about
the properties of ailing and what's
useful I think they're always been a lot
of applications which have actually
needed these properties it's just taken
quite a bit of time for people to
realize that they do actually want it
they do actually want massive
concurrency in their system they do
actually want fault tolerant systems and
all the things that our line can provide
it probably is sort of again this is all
my opinion they're probably sort of real
life no they wanted for that is
specifically come out and said they want
it now they get up the field that they
come out and say yes we do need massive
concurrence we do need fault tolerance
that's how Ellen gets into the science
so what I was going to talk a bit about
just some personal experiences in
teaching our Lang and training so I do
quite a lot of training I honestly enjoy
it so it's no problems there just some
experiences from this so the short
answer about all this I could just say
it's easy right and honestly it is that
it is honestly quite easy to teach Ally
and teach people to use a line I don't
want to just go down now and leave you
but so go a bit more but these are my
experiences from teaching it the longer
answer is that there are a couple of
problems doing it there's some major
problems than this and lesser problems
doing these type of things some of the
major problems are airlines are
functional language and if you don't
come from a functional background a lot
of people
there are things in the functional
language model which people find
difficult this is nothing strangest
there are different things working with
a concurrency model a lot of times
people are not used to thinking in
massive processes thinking and
asynchronous communication all these
type of things for and another problem
is how do I use all this to develop my
architecture my application architecture
again it's a mate all these things are
read things from what you used to say if
you're coming back from a job if you're
coming from a Java background or
something like this it's nothing strange
it's just some properties so from the
functional point of view we have things
like your mutable data which way after
you become used to it seems very natural
but if you're not used to it it forces
you to really think how you work with
data yes you can use a lot of the old
algorithms but the way you do it changes
and again it takes some getting used to
it it's not difficult it just takes some
getting used to and that's not from your
background you have things like pattern
matching which is really fantastic when
you used to you when you use it but it's
completely different from what most
people used to if you're coming saved
from a lower background you're much more
used to saying how I want to pull
something apart and check its structure
and extract values from it rather than
using pattern matching I'll just write
down the pattern and let the system do
it for me right it's the same thing when
you're building data we write down how
we want the data to look and the system
will build it for us with pattern
matching we write down what we want the
thing to look like and let the system do
the testing and the pulling apart and
extracting all these type of things it's
not difficult it's just different at
that point of view another one is
recursion so anyone is used our
languages based on the early machine for
you know there are no loops you're doing
everything in recursion again that's
nothing strange but you're coming say
from lower background using see you've
been told recursion is bad avoid
recursion it will kill you we're saying
exactly the opposite everything's
recursion you have to use recursion
everywhere
but a lot of other things too as well
but these are all just standard
functional language properties so this
is nothing strange for a line so for
example if you've been say studied
haskell or something like this all this
is quite natural the syntax will be
slightly different but all the
properties are basically the same
another one's the concurrency model just
this fact thing that you're how do I
look in architecture yes I starts
putting things up in processes I have
asynchronous communication between the
processes that is can be different for
very many people we don't do things
synchronously across processes the
Selective receiving your messages began
not to rethink it's not like you have a
channel we have to take every message
that comes I can be very selective and
just look at the messages I want to in
this but where I am in this code that's
a very nice feature when you start
getting used to it because well in fact
means I don't have to worry about every
message I could get everywhere I can
just worry about the message i'm
interested i will ignore all the other
ones and someone else will clean up
after me or take care of the message
those messages somewhere else again it's
a rethink of how I understand
communication there's no shared state
this is the big one I think there is no
shared state between our long processes
there Rhett stables but they're not
shared they're commonly accessible but
you're not sharing data and again this
is a big rethink of how you how you
structure your system processes are
independent if I want to communicate for
want to send data I have to use messages
again back to my asynchronous messages
if I want to do a synchronous calls its
sending messages backwards and forwards
this is actually very powerful the
explicit handling of synchronous
messages because it allows me to handle
errors or properties of my synchronous
communication is very explicitly I mean
I can put a timeout out there
if I don't get a reply within five
seconds I will go do something else or
if the other no time talking with what I
process i'm talking with crashes i can
go and do something else and what i want
to do let's see what happens here yeah
it's very much up to me yeah okay
eventually eventually consistent so yeah
application architecture how do I build
a system architecture again when you if
you're looking if you're say coming from
a Java background when I structure an
architecture there I start thinking in
classes and instance of classes and
things like this if I'm coming to an
airline world I start thinking about
processes which concurrent activities I
got going which process how about going
who is communicating with who etc etc
it's a completely different way of
structuring the system and again it
takes getting used to especially when
you start putting in the fault tolerance
so typically when you're doing an hour
long systems or Alan based systems you
start thinking about errors very early
in the system this is part of that how
you structure the architecture what
happens when this process crashes how
important is it to recover how should I
recover can I just ignore the process
crashing do I have to clean up after etc
etc you start thinking this through for
every class of processes when you're
building your architecture of course
that isn't often not what you're used to
doing so I've heard people say they've
never thought as much about errors as
when they're building a line systems of
course the reason to do this is that
once you've done this then I can ignore
the errors and the processes then I can
happily let things crash with my system
instruction in such a way that will
clean up after from the airline point of
view that's completely natural why the
only way to build a fault tolerance
system is to think about what what will
happen when when things go wrong how am
I going to structure my system for that
but it again it's a rethink there are
some lesser problems syntax honestly
yeah i agree i will say most people
think the syntax is strange the first
time they look at it but there are a
couple of big butts here most functional
languages have strange syntax okay name
a functional language that has a
consistent syntax that looks like
something else they don't well well yes
okay yeah i'll grant you less PS i agree
but it doesn't look like java no it
doesn't it doesn't look like Haskell
it's got similar ideas to Haskell but
doesn't look like Haskell is what
Haskell looks different f sharp looks
different there's nothing wrong with f
harp syntax but it's not like anything
else you've seen if you're coming say
from a c-sharp world for the same with
any functional language they just look
different any language you don't know
has a strange syntax okay first the
first I'll honestly say i love Lisp as
people probably know the first time I
saw I saw a list it was strange I could
not get used to this took a while to get
used to the parentheses actually
defining structures once that was done
is quite natural as I say the same thing
for every time the first time you learn
a new language the syntax is always
strange whether it's Java whether it's
see whether it's Python even I'll say
whether it's alex here the syntax is
different right fine nothing strange
about this but what I have found is that
by the time most people here again this
is experience from giving courses I give
quite a lot of training courses from
this by the time that people have
grasped the basic concepts they're used
to this index okay but the problem is
getting people to understand the
concepts and by that time they will
grasp the syntax since the syntax
honestly is not a problem I know it is
to some people if you go out and read
the blogs on the net you think that well
because we're using semicolons and the
wrong ways to saw the end end of the
all type thing for it but most people
don't don't feel that when I tell people
I give course is that people complain
about the semicolons both them just
laughed it's not a problem so yeah in
that sense teaching our Lang is not not
difficult there are some new basic
concepts that are different but that's
nothing you can do very much about I
mean that's why you're coming to our
lane what are you coming to our long for
if not for the concurrency and not for
the fault tolerance the sequential
language is nice but I wouldn't use it
I'd use lists before I wonder just too
plain sequential stuff you're coming for
the concurrency you come in for the
fault tolerance that means rethinking
how you build systems that all there is
to it I think that was probably the last
one I had yes that was the last one I
had so yeah it's not so teaching our
line is not a problem i can say that
honestly from experience yes i might be
a brilliant trainer but even so a lot of
problems so hand it back to Mike talking
more sensible things well I don't know
if I'm going to talk about more sense of
the things but I will talk about other
things these guys they went on to work
out with their technology in or
respirator in about the mid-1990s I went
into management you know management's
the nice part of business you can tell
people what to do and don't have to
think it's because it's got it's got its
advantages and because of that people
tend to ask me management so i type
questions and such as how'd you start a
project well it is easy to build
prototypes in air like the prototyping
is easy you can get things up and
running and maybe one of the possible
disadvantages with airline is that even
very bad programmers can get
airline program is working which means
that you know I think it's felt better
if they use C++ or Java or something
like that but they never get anything
working which is a lot better they're
bad programmer the advice I give to
people is they're making a new system is
build a prototype try things out in the
small make mistakes it with a small team
and iterate until you get an
architecture would you like if you do it
that way it's not going to cost that
much if you actually make an
architecture which goes wrong and
requires a lot of workarounds and that
costs money and they when you have a
very large system which works and then
you have to re-engineer it it costs a
lot of money because not only do you
have to get the system to meet the
specification you have to make a system
compatible with all the bugs in the old
system and all weird workarounds that
people have that I've met that on
several occasions and it costs a lot so
rewrite your code redo it again and
again till you happy and then you can
actually speed up and go into a bigger
team it's also very important and I
think I've met a lot of projects where
I've made this mistake of getting people
to do the test Suites later and when
they do the test Suites later they've
actually forgotten all the weird
wonderful things that they programmed in
what if this happens what if that
happens and these test fit missing test
Suites should be done at the same time
there are people that advocate that you
should do the tests before you write the
code I never understood that that would
work but testing should be done at the
same space and make sure you use tools
like dialyzer from the very beginning
airline is dynamically typed dialyzer
will help you with that and get rid of
the problems which you because we don't
have typing
you also have to realize there is a huge
difference in starting up a new project
and maintaining or enhancing an old
project the difference is mainly the
sort of people that you want you will
never get hugely innovative people to
maintain the project for 20 years it
just won't happen the people you want
are the sort of steady loyal people that
will do the job and keep it keep it
going so you need different people and
you need people who were prepared to
work with the system over a period of
years an innovator who's doing something
new he's got it working he's happy he
wants to do something new the maintainer
is a different person we have different
goals the innovator wants to get it
working show our Jewish friends is
working the
maintainer was to keep the system
running so he's not woken up in the
middle of the night by a phone call
saying get into the office quickly it's
crashed schedules and project management
are different in in a startup project
when you're doing something new you can
have schedules you can have fixed
project management in maintenance an
enhancement assistant you cannot really
have sensible schedules for the first
time you do something it's basically you
can plan what you know about you can't
plan what you don't know about this is
now over to Professor Joe here hello um
this is the crystal ball bit and not to
try and think about what happens in the
future a little bit that's to fit in
with the idea that airline is developing
it's not static it's changes with time
so just kind of wonder where the
software industry is going what's going
to happen I don't know make a little
guess so the design of airline reflects
the period when it was first invented so
it was done in the mid-80s on what today
would be you call it a small embedded
system it was on a very tiny computer
with a couple of megabytes of memory
maybe you bought a 40 megahertz clock
something like that fax 11 780 small
number of nodes we would talk about tens
of nodes not not thousands of nodes and
zero security and everything was sitting
behind a firewall no contact with
internet there wasn't an Internet really
we weren't connected to the outside
world so there were no security problems
and so in 1980 we're looking at okay so
how do we how do we map a large number
of parallel processes onto a small
number of CPUs to talk about building
telephone exchanges with hundreds of
thousands of users and mapping them on
to two or three CPUs so that's the kind
of problem we're looking at there no
security problems today
we want to map billions of things onto
maybe millions or billions of computers
and security is a really big problem
because they can all communicate with
each other so the problem is changing
with time so this is the kind of
universal s-curve that you can use in
any talk you've just got to put some
axes on it and label it so so this is
time goes like this and this is hardware
hardware changes so I believe that that
when the hardware changes in computing
you make a new computer hardware then
the software lags behind and it will
catch up it takes it quite a long time
to catch up and goes through an s-curve
so so this is the amount of code that's
written to support the new change in
hardware so when there's a discrete
change in hardware you'll see a rapid
well first of all you won't see much
because people will ignore the new
hardware and then people will start
adapting the new hardware and they'll be
rapid changes and then you will go up
this steep curve and then it'll tail off
because at that point you cannot do
anything more to the software so the
point in time where people earn money
I'm not here not at the beginning that's
where you lose money okay but when it
takes off on this me of the curve and
possibly in this part of the curve
that's that's where you make money and
if you were early you make money when
you're on the flat bit at the top and
then you make money forever you make a
small amount of money that's forever
until the next technology comes along
and replace with you so you have a
constant income amount of this bit here
and if you're if you time this right you
make a heck of a lot of money in the
beginning I think that's why whatsapp
made a lot of money because they were
the first people to notice that the
internet was changing from wireline
access to mobile access and they got in
early there so they're in exactly the
right point on this curve where it takes
off okay and then other people will be
behind them okay so they won't make as
much money and then hopefully they'll be
in this position at the top weather in
this stable plateau and they'll make
money forever until a new technology
comes along
better than that that's what I think is
going to happen right oh dear come back
come back slides all is forgiven there
we go right hello yeah right so when the
hardware changes the software will will
change and what we saw up from 1948 to
about all turn of the century was von
Neumann architectures all that happened
to them with the clock rates got faster
and the chips got bigger their reached a
limit there when you couldn't reach the
entire ship in one clock cycle and so
the multicores came along at that point
there was a kind of discrete rate you
couldn't reach the entire chip substrate
him on clock cycle and so the multi-core
came on there was a brief delay while
people regrouped and built multicores
and and then the multi-core
architectures came along as a discrete
change in the hardware said now the von
Neumann machine which has just got
faster and faster and faster from 1948
to say 1998 or something like that that
trend is broken so we have a discrete
change in hardware says one of these
curves changes the other thing that
happened was the ubiquitous data
everywhere the internet it's reaching
everywhere fixed rate access fibers to
the home things like that the data rates
going up from kilobytes two megabytes so
so now you know I've got 100 megabits
per second at home over fiber in the
mid-80s something like that I mean the
first mode and we haven't was what was
it for kilobits or something no I was a
fast on 12 no 1200 bored yeah 110 board
that hundred and ten board is no good
for sharing movies and things i can tell
you and it will fit on the disk disk
wasn't big enough yeah apart from in
pembrokeshire where Mike lives you're up
to a killer bit or something right okay
so so this is curve and we're catching
up on it Andy I reckon kind of good
enough is the point you want to be out
because once you're good enough you
don't need to get a lot better than now
I think I think things are going to stop
at I don't know why I should want of
gigabit at home
100 megabits per second mobile is okay
for me right okay so software is it's a
certain um hello come back slide it
software's the same it follows his
s-curve early it's much slower it takes
a long time to adopt ideas so far it
took 91 years Alfonso church did the
lambda calculus in 33 and in 2014 Java
rate got lambdas which was only 91 years
later and so you know we're really slow
compared to the hardware people and
functional programs even worse got got
clubbed frayed defined what was probably
the first the first functional
programming system in eighteen seventy
nine but he didn't have a computer to
test it on and so the development pretty
slow and and the first computers weren't
powerful enough to run these kind of
stuff so there's a bit of a delay there
right so if my thesis is that hardware
changes will drive software i want to
say well what are the hardware changes
it that are going to happen so so so
this is where I take out my crystal ball
and and I'm not going to look more than
five years ahead because I don't know
what's going to happen I mean maybe we
will have neural nets that simulate the
brain I think that I don't know but but
let's look at the near term changes but
what's going to see I think are these
massive network-on-chip system on chip
architectures with with thousand core
cpus where's Andreas it's not here oh
right at the back yes so for go and go
to Andreas is talking he'll tell you
about where the CPU architectures are
going I think I think we'll see say 800
800 general-purpose CPUs on a chip with
100 100 200 hardware accelerators the
hardware accelerators will be doing
things like like visual processing audio
processing both very transform things
like that where there's a significant
benefit of doing it in hardware and all
we have to do is program these things
they'll run at fairly low power and we
will have massive computing power we're
going to see petabytes of local storage
we've already got terabytes of better
storage storage is increasing by a
factor of thousand every 10 years so
we'll see petabytes of storage pretty
soon
and exabytes and I don't I don't know I
don't know what we're going to do with
all this storage they seem like nuclear
weapons in the sense that what happens
to the film industry when you've got
petabytes of storage and you can store
all films in 12 petabytes install all
books in 138 terabytes so I think within
10 years will have will be able have all
books on our mobile phones or something
like that so once you've got all books
why do you want more you know there
isn't any more we've got it and
everybody on the world can have it and
that's fantastic we might evolve
non-volatile memory if that happens then
the time to boot an operating system
will be just one clock cycle and will
boot in one clock cycle it'll be pretty
quick pretty nice we'll see high-speed
communication massive massive number of
connected devices so in this hardware
landscape oh I talked to the heart where
people and they say memory is free cpu
is free and communication costs the big
cost is in communication and if you
think about it that means that well
today that the dominant model of
computation is that we move data to
computation so we have data we have
servers that perform computations and
remove the data to the computation and
then they would perform the computation
and remove the result bank well that is
stupid because if you think about it if
I have to shift a gigabyte of data to a
server for it to perform a computation
but the computation is a program that's
maybe 100 kilobytes it would make much
more sense to move the computation to
the data instead of moving the data to
the computation and so this is the idea
of mobile programs and agents actually
because because there are compelling
reasons why you don't want to you well
you don't want to move the data and one
of the reasons it's called reason about
privacy that if you've got your data you
keep it on your own server at home and
then you allow agent programs to have
access two subsets of that data and now
you're moving the computation you're not
moving the data so there are compelling
privacy reasons to do so but they're
also compelling environmental reasons to
do that because moving that data is the
part of the process
takes up most energy so we have to solve
the world's energy problems would be
moving the world's data centers are
using four percent of the world's energy
and that is the same as the airlines are
using okay and that is increasing at
sixteen percent per year that is
environmental disaster if we can put the
data locally on our machines move the
computations to the data we can save a
lot of that energy okay so Carl has been
completely right with his agent saying
you move computation ground the net two
agents rather than moving the data
around and these spawn of new agents
which perform new computations okay so
we have to do that right what's
happening in the place of the world
where I'm looking at our the data rates
for mobile data and since I work for
example among other things we can see
that we've had this development in the
last rendered 2g start that was 1980s
yeah every 10 years we've come to this
2g 3G 45g cycle and that has increased a
thousandfold communication capacity
every 10 years with a 10 to the 6 price
decrease per bit right now we're trying
to define 5g that will give us about a
gigabit per second in hot water five to
10 gigabits per second in hot spots and
a hundred megabits per second everywhere
this nomadic data or things will be
running at 100 megabits per second I
don't actually see why you would want
more data rate than that because that
together with caching gives you a
situation where it'll be very very
difficult to do better than that i'm not
quite sure i don't have enough
imagination to think what we would do
with it unless we start simulating the
brain or doing sort of really suppose we
try and optimize all of society build a
model with everybody on the planet in
order to optimize energy usage I mean
that that might need massive computing
power yeah what else so the new problems
well no problems come out well we've got
50 billion connected devices or trillion
connected devices we've got thousand
core computers we have limited energy
we have limited radio bandwidth and we
have to figure out how to use these
resources well I say this is a new
hardware landscape this is where we'll
be in good i say we're not going to be
info we might be there in I've got 50
billion connected devices today I don't
know not there yet 5g will have to say
that because of work for Ericsson that
cell be around 2020 we've already got
five gigabytes per second over the air
in the lab that will be rolling out
about 2020 something like that thousand
core cpus running at about 15 watt South
gand Reyes loma my prediction is they
will be around I wouldn't be surprised
if somebody came with him this year or
next year that I've always I've been
saying that for the last two or three
years I really want to be the first
person to get a thousand core computer
on my desk to program it because some
people say we don't know how to program
a thousand core computers and I would
say no we don't know how to program 2000
call computers but I want to be first to
try out how it works and ok cpu power is
free memories freely communication costs
a lot an energy costs really look after
energy so what are the new software
problems managing I don't see 50 million
connected devices IC 50 billion crypto
keys that have to be managed and you
know how do we make it safe or there's
one key to all 50 billion devices I'll
give it to Mike and then he lose it or
something Lindsay in the pub in
pembrokeshire somewhere we've got all
the software this is this is a system
that's going to be totally and always
inconsistent you you know you know with
all the kind of software manners stop
the system change the software restart
the system I'm going to do it 50 billion
connected devices it's always going to
be inconsistent what yeah yeah yeah yeah
let's stop stop every computer on the
planet upgrade everything restart it all
then then we've got a we've got a
program these thousand core thingamajigs
with hardware accelerators that's going
to be fun we've also got to fix up all
this old stuff we all this total met
billion we said another lecture that we
we should we have been at we who've got
gray hair in the audience you get medals
for writing all this stuff that the
people in the future will have to be
backwards compatible with so we've
created balloons of jobs I've about all
we can just sort of just throw it all
away Henry right here which I think alan
kay wants to do which is possibly good
hiding here and yeah i mean it is
actually yeah it is yes so we've got to
fix up all this old mess we've got to
we've got to save energy and we've got
to understand complexity we Dykstra was
saying you know that computer science is
all about controlling complexity and a
complexity doesn't hit you when you've
got a few you know any fool can make a
program with a few lines of code but it
parents get complex very very quickly so
as a thought exercise I would ask you
let me see how many 32-bit variables has
the same entropy as the number of atoms
on the planet give me a number somebody
nobody yes no no no no no no no far too
big a smaller number no no no no no nope
report with one 32-bit variables it's
two to the 32 combinations that that can
have and we can exhaust a pretest all of
them that's easy 66 integer variables in
C 2 to the power of 69 32 is greater
than 10 to the 75 which is the number of
atoms on the planet so we could prove by
exhaust or we can exhaustively test
programs that have less than 6 integer
variables in but you can't write complex
software like that so we have to turn to
mathematics and things like that to
prove that we need to control complexity
and we we haven't done a stunningly good
job on that in the past so so so I think
it's better to have this model that says
that all the software is going to fail
if the airline model is you know process
is going to fail and somebody else has
got to fix that up it's
not going to work any other way right so
the future systems have to be self
managing the notion of managing 50
billion of these devices is ludicrous so
things I version control security
authentication privacy are key problems
self-repairing stuffs got to repair
itself for its like the brain if you
knock out bit of the brain like that
have an accent if you're lucky it will
regenerate after year or so computers
don't do that you know if we if we take
a cpu and bang a hammer through it wait
a year it doesn't repair we things
happen while we sleep I'm trying to
imagine how Griffins that sleep you know
they need eight hours a day of good
sleep and then the next morning very
kind of more perky and things like that
well now if you if you do some of these
machine learnings late in to reach lay
allocation and things like that they you
could observe what you're doing during
the day and try to learn from it and it
might take you eight hours of good good
good sleep with nice bed and then the
next morning it'll wait something's all
perky and it's figured out all this
stuff that you didn't know the day
before I think we're going to have to go
and look at the brain fought for
inspiration we need to be energy-aware
right now right now we don't have
measurement points on the chips to see
where the energy is going we don't have
manageable measurement points out in the
network so we need to be measuring not
not term what do we measure its per
second or something like that we need to
be measuring gigabytes per gram of co2
when we transfer it to a data center or
something like that so we can figure out
what's happening cuz we don't dig up
this brown stuff and burn it and and
then use it to tweet about lady gaga or
something though they're actually better
a better uses for this brown stuff
plastics and the pharmaceutical industry
need it but but we don't need it to
generate energy and we need to solve the
privacy problems different people have
different views on which problems are
the most important I believe that energy
is the most important and we're sailing
today oh that's how I didn't come up
yeah well I think it's the language
with for programming soft real-time
distributed applications that's what it
was designed to do and it fits the bill
quite nicely it's the language of choice
for programming multicore apart from I
would say the GPU DSP type application
not real good at that fact completely
rubbish at that being tested from battle
tested for quite a long time i'm going
to say with self prepare the the
supervision trees and things give you a
sort of way of self repairing but it's
not self repairing like the brain it's
just kind of choosing between
pre-programmed scenarios that you
figured out in advance and just just
trying them and then failing and try and
another one it's not actually mutating
so we perhaps the machine learning or
something inside that would do it as
Mike's that's great for prototyping
distributed systems and great for
managing systems so yeah I be glad you
quoted Alan because if he couldn't be
here so so so I just say well the best
way to predict the future is go and
invent it so there you go go out and
invent some stuff right now that is the
end apart from we're going to have
quarter of an hour's of questions book
now we're five minutes overdue so so
yeah so how when do we have to stop well
could say give you a number number 15
minute okay right so now we become
interrogator who asked you right and and
and then the ideas I've got a list of
questions here i'm going to ask them and
me um and the ideas we hope that you
will then start joining in and ask your
own questions i have a reserve list of
questions that i'm going to use in case
you're all very shy and don't ask any
questions and i have a lyga tori
question well Joe it was like this we
thought that if we stood up here that we
be embarrassed if no one asked any
questions so to make it a bit easy would
ask questions to each other so I have a
bigotry question that i'm going to ask
all all three of us and that's what
what's the word
really bad it really sucks what's the
worst thing that that's a tough one and
the worst feature no records are fine
there's no problem with breakfast okay
everyone complains about records and I
say okay come up with an alternate
syntax and I never thought I never get
one no one has be able to come up with
an alternative in tanks for records
which actually works so don't complain
about variable scoping that I would say
is the worst yes we can argue Joan I we
don't agree on that's good that's great
yeah so people okay people complain
about the syntax and the semicolons the
variable starting with capital letters
now the stuff but they don't complain
about the real problem in the a-line
syntax and that's variable scoping or
rather lack of it and what no no no
that's got these great for sure the
programs are shorter because of it yeah
I know you can do really cool things
with it yes and it's easier to compile
know until magic that will register
allocation order cook you think Iran
okay okay
but what's the worst what's the worst I
were tempted to say the semicolon before
end but I know that Robert would hate me
if I told that I'll just discuss it with
you afterwards right required corner
yeah yep Joe what's the worst thing in
LA well I'm glad you asked me now um
well it's a bit it's a bit well cuz a
bit said okay the nips are okay because
you've got your application and you want
to interface to some funny scene but the
bits are things that come with the
system and they're what make it
difficult to port it to a new system
because they're 100 of the biscuit if
you look at languages you look at you
you know you don't want this bits of
special cases that don't fit into the
front there things that it can't be
written in a line and there are loads of
them now hundreds of them and if you
want to port it to do anything else
you've got to port all those bits that
make sure they all work on your new new
processor and everything is horrible all
the better should be thrown away and
written in LA okay yes ask chris and the
next thing that's wrong well it's a
whole list I mean it's horrible um we we
weren't chucking stuff away so so it
just Fiat said you know every time you
add a new feature to a language you
should chuck something away and we've
added new features and we haven't shot
so when we put maps in we should have
phone records away but there are up
there are some people because you don't
like records / maps maps don't need
records of maps they're not quite
equivalent oh I can grieve throwing
stuff away yes and we do but there are
people who want to be backwards
compatible yeah the average yeah but I
we will have two millions about we
weren't too bad with throwing things
away so when we were developing the
language we did actually put put a lot
of experimental stuff in which our users
said no this was useless or it was wrong
or was bad and we can't use it we
actually did
remove things that we work too bad with
that brother wise i agree yes you should
be very careful when you add things to
remove stuff why my next prime customer
microtel Jupiter telling programmers now
that's a question that comes to me
frequently and I tell you that the way I
tell you how not to recruit ailing
programmers that a lot of companies have
these hair personnel departments they
usually call HR departments and I hate
that expression because they're neither
human nor are they resources verte are
and you go to these pit departments and
you tell them recruit some airline
programmers and they put an
advertisement on the net saying we want
airline programmers and of course that
many elinchrom goes what they should do
you don't recruit airline programs you
through good programmers and good
programmers can learn any language and
you need people that have a mindset that
understands concurrency and what's more
you have to recruit programmers and you
have to use programmers who want to use
airline there's a problem that's in many
companies do decide that okay we're
going to use airline for something we've
got this department over here which is
not doing something not do it not
working but that product is a will use
this department for doing that and three
quarters of the programmers there have
spent their life learning some obscure
language like c++ and
think that that's what they've invested
in their future they think they laughter
than airline well I can learn something
new why should I see why should I strain
my brain so don't recruit program
airline programmers recruit good
programmers who want to do the job what
is the worst between we weren't changing
well that conclusively proves to the no
worse features is no that's terrible
just as bad do you think an approach for
the ifs is that a lot of other languages
as they matured at the hammock gin so we
have hype and it could we implement them
in early and maybe ahead of time compile
with height of its implemented Erlang so
they're still just as fast as the seaway
because like ruby has done that Gabe
reviewer a remedial so they push more
and more of the standard library and the
coconut is into Ruby by having it a
really good gym or yes it's not ready to
roll out dough is ready to roll now has
it got that partner yeah yeah is working
on it there's two guys the Swedish
Institute who decide to condone it about
a year and a half and and they're very
tall commented Memphis Daily music on
it's more or less likely to roll out
it's going pretty well
okay I didn't know that I can say one
thing reader bits if you look at me
yelling module the business of different
classes of gifts some of them are there
just to make the retina see to go faster
so why there are six functions which
could cyclic redundancy check I've
absolutely no idea was they were closed
position pays the bills but they're
there because to me that's how you would
see codeine faculty holidays a lot of
the bits are looking at intern and stuff
interlock getting internal information
out of the system the system info clear
for example which allows you to get a
lot of information ala system you could
not rewrite that in anything else
because that's looking into the Machine
and there is a bunch of bits that know
about internal data structures perhaps
you could do something with those but
definitely some of the glyphs I doing
with Joe shouldn't be there they should
be removed possible so problem what's
the story I mean how telling hit it with
other functional languages in my army is
it going to be easier to learn Haskell
yes partially I mean we've got the
Mughal was functional stuff right which
is pretty much the same is in most
functional languages we don't have a
type system why Castle does a large part
of the problem to be learning a school
is learning how to use the typing which
we don't do we have typed but we don't
have static types so yeah have you
encountered imposter syndrome in your
careers and it's okay to talk but again
sorry have you encountered or Phillips
impostor syndrome you mean copycat well
what do you mean no I've been feeling
like you don't belong like everybody
else is better I would flip that and say
yes we don't belong because we're better
so i can say during the agents in the
early nineties we took part from a lot
of academic conferences in functional
languages in logic languages and we're
often the yad yad people out because we
came from industry and we weren't
looking at the academic side of using
the language we're looking at how to use
the languages to make products so in
that sense we're often sort of you are
there now yeah we don't belong because
everyone is better i think that explains
exactly why became manager i knew i was
better i am actually I the cable
researcher kind of late in life because
I think oldest I have to think before
there are six before and I started doing
a PhD and in sacred ii who is my thesis
advisor I saw a PhD and learn about
research or anything so the rebbe PhD
and then safe said um this is big thats
related work I said well why drafter
like that isn't any related work should
have invented all this stuff and
satellite so I so that insatiable no you
know what you've done fits into the
bigger picture and so I started looking
at to what other people have done and
trying to see where what we've done and
get it into that and at that point I
realized that the difference between
research and opinions are all that
research can be reproduced and fits into
it to a bigger picture and other quite
pleased i did that because then i
thought how does it stop it together I
hadn't even thinking about that before
so if we work in an isolation lab we
just we bred all these papers
that's a good idea we'll steal them
that's what I ve always do that so so
there's no creativity involved area
business steal other people it is
packaged together in a nice way but like
i just say what one thing talking about
what well we haven't started talking
about what we did wrong but one thing we
did we did very wrong is that we three
we thought about these problems a long
time at long arguments about things the
discussion about what happens if you
send to a process that doesn't exist
that discussion went backwards and
forged for a long time honestly did and
we never wrote down a lot of the
rationale behind decision to be made
there now being serious a serious
problem so people do not understand we
have this feature why you have this
feature and most of the things in the
language not all but most anyway there's
a reason behind that we never wrote this
down and that was despite the first time
i wrote something about this 2000
something rather a short presentation
virtual paper button and I was talking
to Joe we'd never distant everything the
stuff down his head oh did we and we
just felt was so natural we don't wrote
it down so you just like making a system
write down why you've made certain
decisions yeah you will help you will
help the next generation looking at it
definitely doing that the other thing is
kind of any conceivable during this 10
15 year period number of users have
grown from one to ten or something like
that so so it was inconceivable to think
we would have underground or 200,000
users and therefore that the government
to keep this stuff it was just what we
were playing with so so I had all and we
did have computers to store everything
onto everything's on paper and I pick
five every time we moved Helen said done
okay chuckle that stuff away so every
time we moved I kill me
we're not going to show seem to be
everywhere so I have this box at home
mark history an unfortunate the first
version to bear lying i've got x version
5 and it says you know what the universe
was lost in the mists of time so we
never kept anything competitive energy
could store everything that forever Mike
actually really funny we talked about it
we think we've got any lotion for the
Sun so somewhere in one of them have to
be has anybody got a sullen tape reader
you know those little bit okay I know
the cassette thing is used to put in so
many but it's got a song take movie from
the 1980s someone in those versions are
having on it the only the problem is I
have to look at somewhere in the
mysterious boxes i haven't trying to
find that right I've got it somewhere
when I first designed the language what
was the motivation keeping it
dynamically type versus because it was
based on prologue the big that's all
atomic e-type tonight yeah it was some
rational made the code don't have a code
having easier because I mean the unicode
handing is a module and there's no into
module links or any connections at all
so if you're loading you just let
loading modules which make static type
checking the whole system very difficult
to do and we felt there was enough
basically and that's we came in again we
it is from the prologue willing what
we're working on the original time for
its flight strange because always come
from backgrounds with static typing I
mean so Joe was in Fortran program well
sort of static typing anyway
dragon I programs see well I was
assembly language program and I don't
think you can talk about typing there at
all course it does you've got the
integer yeah okay any more questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>