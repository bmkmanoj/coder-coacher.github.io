<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>æternity: Scalable Smart Contracts Interfacing With Real World Data | Webinar with Erik Stenman | Coder Coacher - Coaching Coders</title><meta content="æternity: Scalable Smart Contracts Interfacing With Real World Data | Webinar with Erik Stenman - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>æternity: Scalable Smart Contracts Interfacing With Real World Data | Webinar with Erik Stenman</b></h2><h5 class="post__date">2018-04-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NbZKaJe7J2U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">broadcast is now starting all attendees
are in listen-only mode good morning
good afternoon wherever you are
my name is a retail sabaidee content
marketing executive at erlang solutions
thank you for joining us today as we
learn about how eternity blockchain is
scaling smart contracts to interface
with real world data we're honored to be
joined by Eric Stegman Erlang developers
at Eternity CEO at happy hacking and
former CTO at karna this webinar is a
continuation of a series of webinars run
by erlang solutions highlighting the
most innovative and exciting work in
that Erlang and elixir communities
before we get started we'd love to hear
from you you can tweet us using the
hashtag erlang solutions talks or submit
a question in the Q&amp;amp;A for the Q&amp;amp;A
session using the box on the platform as
a reminder a recording of the webinar
and the slides will be shared after this
webinar has ended please keep in mind
that this is a live event and that we
may experience some technical issues
although hopefully not today now let's
get started over to you Erik thank you
hi and welcome today I'll talk about
blockchains eternity and smart contracts
and all of this in the contact context
of airline so eternity is a new
blockchain where we will have smart
contracts and be able to interface with
real world data so some background what
is a boxing a blockchain is a
distributed ledger and as the name
blockchain implies it is a chain of
blocks and each block contains a number
of transaction and a transaction can
transfer tokens between accounts
and an account is associated with a
cryptographic key pair so what is a
block this here represents a block a
block has a header and a body in this
case the header consists of a block hash
and a previous block pointer and the
root - I will explain what these are
soon and then a body of transactions so
this is block 0 also called the Genesis
block and here we have block 1 so in the
guiness this block there is no previous
block and in block 1 we have a pointer
to the previous block so this pointer
has the hash of the first block so this
way all the blocks are connected in
machine and since the block cache is a
hash of all the fields in the block it
uniquely points out this
you have been seeing my screen
apparently is got share screen here so I
hope you all can see my screen now at
least so this is a block block 0 and
block 1 connected in machine through the
previous block pointer the root touch is
a hash of the state of all accounts
after all the transactions in the block
has been executed so as we said
previously a transaction can transfer
tokens between accounts so an account is
an address in the in the book chain
which contains tokens and these tokens
can be transferred so each account has a
has a an amount of tokens in it in some
block chains like the Bitcoin blockchain
there are not accounts but instead there
are unspent transactions so there's only
transactions of tokens and these
transactions can be spent and then they
sort of not exist anymore and there is
no balance on their accounts I mean in
the book chain that we're building in
eternity and the etherium blockchain
there are accounts with a balance and
the root - is the hash of a structure
way of seeing all the accounts and all
their balances
so that way a block describes the state
of the whole world as it is right now
Cena in the boxing and since also the
hash of the block contains the pointer
to the previous block and all the
transaction and the route - it means
that there is no way to change a block
without changing the hash of the block
and saying the hash of the book would
break the chain so there's no way to to
change any information in a block chain
so what is mining so each transaction
that is transferring tokens from one
account to the other and to another
account has to be signed with the
private key of the account that you're
sending tokens from so only the one that
owns the account can send tokens from
that account and miners job is to check
all transactions before they enter the
blockchain and they check that they are
signed with the right key and the
balance of the block of the account is
large enough to contain so that you can
actually transfer the amount that you
want to transfer then when the mine has
checked all the transactions and see
that they are okay and they will be
added to the block and then the miner
will solve a puzzle this is also what's
called to mine the block to find a hash
for the
and the first - all the puzzle will get
a minor reward and that block will be
the be the new top block of the shame
so we've look at this ash here the block
cache it starts with a number of zeros
so these this is the most usual way of
making the puzzle and finding how many
zeros the block cache has to start with
so the miner tries to find a solution to
the block cache that results in as many
zeros as specified in the beginning and
it does this by adding a nouns that he
can decide what it should be and try
different ones
till he find a solution to the puzzle
and this nouns is also a part of the
block and miner gets tokens as a reward
for solving this puzzle but actually
what you're rewarding the - for it is
the shaking that transactions are valid
and signing off on this minor also gets
transaction fees from transactions so
this way you can use a blockchain in a
distributed way in a safe way to
transfer tokens between accounts so what
is eternity done eternity is a new
blockchain and it's designed to be
efficient to have transparent governance
and global scalability so with efficient
we want it to be cheap to do
transactions and be able to do many
transactions per second
and with transparent governance the
blockchain should be open and the users
of the book change the miners and the
people who have accounts and tokens on
the book chain should be able to decide
on fees and how the mining should work
and things like this and with global
scalability we also mean that we should
be able to have many many transactions
going through the botching so the
technology behind eternity and we use
airline which is robust robust scalable
and allow us do rapid development and
has good operation and maintenance
support you also use Alex here for
really rapid prototyping and back and
front and interfaces testing out new
features of the boxing and for the front
end we use javascript pjs h ml 5 and so
on and most of the development is done
on HTML on Ubuntu and on github and
everything is open source so why would
you
want to use airline to build a
blockchain one advantage is that with
airline it's very simple to be loosely
coupled components and it simplifies
Perl development and reuse and this
makes it easy to do flexible evolution
so we have been able to build a very
basic block chain and then evolve it
through iterations and in live with the
test net for a couple of months now
Aling also has concurrency done right so
it's easy to isolate like the protocol
from the program logic so there's one
part that talks to the outside world and
other parts that decide what's happening
on the server and it's easy to to handle
protocols in airline has many features
like bit syntax and other things to make
it easy to to do protocol development
and full-figure gave a whole
presentation on the subject on why to
use airline you can see it on the
eternity youtube channel the link is
also here so when you get the slides you
will be able to find it currently the
core Allen team at Eternity and has more
than 200 years of a line programming
experience so we have people like weig
air who has been programming a line
since 93 or 94 and I myself has been
probing airline since 94 and programming
since 1980
we have yondu's who has worked on has
girl and developed quick check and a lot
of other people with long airline
experience so this makes development
really fast and stable so the biggest
advantage as I see it with Eternity is
that eternity is the next generation of
box chains so we had Bitcoin first and
then came a theorem which provided smart
contracts and the number of things were
implemented many times in the smart
contracts things like Oracle's and
tokens but eternity brings is to take
these commonly used and very useful
concepts and making them first-class
objects of the eternity boxing so we
have Oracle's names tokens governance
state channels and contracts and I will
talk a little bit about each one of them
so Oracle's Oracle's are used to bring
in information from the real world the
data of an Oracle is structured and data
can be anything from a simple boolean to
the complete work of Shakespeare so when
you create an Oracle you submit a
transaction to the same chain that says
I want to create Oracle and
when you do this you say what type of
data you're going to provide and the
type of that data then users can ask for
this information and I as an Oracle
provider can provide this data and one
of the types is of course string where
you can put in arbitrary data
unstructured as an Oracle we also supply
names a way to give understandable names
for anything on the book chains so that
is accounts addresses also Oracle's and
contracts can have names so instead of
having to talk about the hash which will
be a very long sequence of letters and
numbers which is hard to remember and
hard to talk about you can actually
assign a name and use that to talk about
it
there are also tokens as first-class
objects so tokens can represent real
world objects in some way they can be
treated and destroyed and exchanged
through atomic swaps so tokens can be
used for example to represent some kind
of digital content or and represent a
a something in a game they can be used
for doing minting a new token that can
be sold to raise fund for projects and
then these tokens can be traded and
transferred for something when the
project is done for example if you want
to raise funds for making a new game you
can create a new token sell this stock
and use the money to to implement the
game and then people who has these
tokens will get in-game features when
the game is released or the game itself
so these are also first-class objects
and then we have governance so this is
done by voting on the chain on
government proposals so that means that
there is a way on the tarnished
blockchain to propose a suggestion and
then vote on it and this can be used for
other things done governance also so
governance and voting our first-class
objects on machine but it can also be
used to decide on minimal fee for
transactions or what the minor award
should be
then we also have state channels and
state channels is a way to scale machine
so by having state channels not all
transactions need to be done on the
chain so you start a state channel and
you agree with someone else
to put some tokens into this channel so
each of you put a number of tokens into
the channel and then you can do
transactions off the chain and both sign
each transaction so one example is that
I want to buy coffee and you have a
coffee shop I open a state channel to
you and I put in 100 tokens and then
every time I want to buy a tote yeah
coffee I I say that now the balance is
that you have one of these tokens and I
have 99 amiibo so now off on this and I
get my coffee and then next time I buy
coffee I say that the balance is 98 and
to me and to to you and we sign off to
this and then at some point we can close
the chain and and you will get those two
tokens and I will keep my 98 unused
tokens and with state channels you can
do transactions such as paying for each
frame of a streaming video broadcast for
example so this can be fully automated
and means that you you don't pay upfront
for the full movie if for some reason
the transaction is interrupted then you
have only paid a few microtransactions
for getting a few frames
and this would not be possible with the
doing on the chain because transactions
will cost more on machine and they will
always take some time for the chain
Network to confirm the transaction and
all these first-class objects can be
used in smart contracts so some people
have said that smart contracts are
neither smart nor contracts but actually
they're just code that can execute on
the chain
so the code execution is deterministic
and the outcome is verified by minor the
execution of the code can alter this
altered state of the chain so it can
transfer tokens between accounts and it
can do all the things that you can do on
the chain so on the ethereum chain on
the Eternity chain you can actually
create Oracle's and look up Oracle's and
so on so that's what we're going to talk
about contracts so when we this design
the contract language and the virtual
machine for eternity we had four goals
we wanted contract execution to be safe
we want it to be efficient and scale and
we wanted it to be cheap and there
should be a simple way to migrate from
ethereum smart contracts
so the first go contract execution
should be safe I think we all have heard
about some of the contracts on ethereum
where money has been locked in or stolen
because of bugs in the contracts so we
want the contracts to be safer and we do
this by giving you a possibility to
state properties of the contract and
actually prove these properties so we
have designed a new functional language
called Sofia and a new site safe virtual
machine FTW VM I will talk more about
both of them in a while the second goal
that contract execution should be
efficient and scale so in order to
achieve a scalable solution eternity
provides state channels and a new
consensus Algrim so we hope to have
Bitcoin ng implemented soon which should
increase the number of transactions that
can be done on Shane and since we have
state channels we can do many
transactions of Shane and this should
help with the scalability of the chain
to get efficient contract execution we
also designed a new high-level language
and then we are building an efficient
machine for more complex contracts that
also should be
executing fast but not as fast as the
very high-level language the third goal
is that contract execution should be
sheep so the price of contract execution
will of course be determined by miners
who decide whether they want to pick up
a contract and run it at what price and
by the users by deciding how much they
are willing to spend on getting a
contract execute so with open blockchain
that is fully decentralized there is no
way to to control the price really so
the price will be determined by the
users in the future but by having state
channels and efficient ways to execute
contracts and for the high-level
language a simple flat rate for
contracts we hope that fresh answers
should be kept low
Portico most that there should be a
simple way to migrate from aetherium
smart contract and by providing a
version of the ethereum virtual machine
it should be easy to migrate even
contracts to Eternity so to recap the
goals safe efficient scalable cheap and
easy way to migrate of course these four
goals are not very easy to combine and
to get all of them to work at the same
time so we decided to not try to do that
because that would probably fail
miserably
so instead we have decided to do three
different virtual machines so by having
a version of EVM it's easy to port
solidity contracts from ethereum to
Eternity so it should be possible to use
existing popular contracts on the chain
and also in order to test the
performance of eternity and fine
bottlenecks before main launch we have
made some alterations or to the EVM one
thing is a safe self-destruct
instruction so the contracts will not be
removed until they are not only used
we're using different hash so that is a
change in the EVM we'll add sub routines
that are coming to the EVM and bit
manipulation instruction that's probably
coming to the EVM
and also instruction for accessing more
than sixteen stacked positions since our
functional language that also compiles
to the evey eternity EVM needs to be
able to access a lot of stack positions
so in order to actually go one the safe
contract language we provide a new
language called Sophia Sophia is a type
functional programming language it's a
dialect of ml very close to reason but
with a significant byte space and Sophia
can be compiled to a safe virtual
machine FTW VM and so if you are
providing ways to define properties
about functions and contracts and these
properties can be proven to hold or
disproven which would result in a
compile time error so then you cannot
actually create the bytecode for a
contract doesn't fulfill its properties
a Sophia contract might look like this
it's typed so you have type event you
have type state which is a record with
the field data which is an unsigned
integer we have the init function which
takes an unsigned integer and returns a
state and here
it sets the field data to the value of
value note that curly brackets here are
not function body brackets its brackets
around
the record so the function get that only
access the field in the state doesn't
use any curly brackets at all and then
we have a set that change the state this
init function is executed at contract
creation and set the state initial value
and the set function is a way to update
the state and the state is a field in
the returning argument of this contract
we can call other contracts so there
will be a roll call built-in that calls
an address on the chain and other
contract address you give the function
name how much gas you want to give how
much value transfer you want to do and
then any arguments to the to the main
function that you're calling so this
call syntax is very recent and we're
experimenting with it right now so this
might not be the final version the Sofia
compiler is typed and keep tracks of
types all the way down to the FT wvm
code so the functional type boarded
virtual machine is a high-level virtual
machine with a variable world length and
an associative memory
so it's functional that is the data is
tagged it has automatic memory
management and
associative memory also its types or all
instructions and memory petitions are
typed and tagged in the machine code
also and it's what normally would be
called checked but we call it boarded in
order to get for the wind Burchell
machine and not FTC V M so all
instructions are checked at runtime for
overflow underflow types and so on and
the instruction cost of the machine will
be controlled by governance so if it's
determined that some instructions in the
machines cost too much or too little
compared to at the time it takes to
execute them this can be changed easily
dynamically on the chain our second
language for now after another bulgarian
city or also Sanskrit for type it's a
more like a scripting language similar
to the Bitcoin script language there is
no loops and the gas cost is decided at
compile time so this might of course
beast a slight over estimation in some
cases but you will know exactly how much
your gas you will need for for a
contract and miners will know how much
gas they will get for a contract
so now we come back to the power of the
first-order objects
so since attorney has all these first
robux the warner language is still very
powerful so here we have an example of a
banach contract and where you want to
buy some tokens of some designed tokens
that are traded on Shang previously so
you're buying them for a certain value
and there is an Oracle that provides the
game token current price so by
calculating how much how many tokens
you're sending in and the price of the
game tokens get an amount of tokens that
you can afford to buy so then if you
have the owner has that many tokens and
the color then the color tokens is
increased by that amount
and the owner tokens are decreased by
that amount and the owners balance is
increased by the value so with this
simple contract you can still by
referring to Oracle's and tokens you can
actually do quite advanced contracts
without loops or things like this these
contracts are compiled to the high level
machine HRM you might come up with a
better name at some point which is a
very simple
virtual machine and actually they are
just evaluated directly by the node as
part of verification of block
transactions not a real separate virtual
machine it's sort of the language that
contract transaction verification is
written in but it has a basic like
syntax that is compiled to and coded as
byte code stored on the be watching and
this code looks something like this and
hopefully not something anyone will have
to get ever so eternity is a new
blockchain with first-class objects why
do we have three different languages and
virtual machines so we have Sofia and
for the window actual machine for safe
system level programming where you can
create new more complex objects on
machine we have Varna and a high level
machine for day-to-day fast contracts
and we have solidity and EVM or a EVM
for porting all contracts to them to
Eternity so attorneys all open-source
you can find it at git hub at slash
eternity and you can see the development
going on there daily and you can see the
contract languages and everything in
the epic project under eternity so
that's about it and I'll open up for
questions thank you very much Eric very
insightful and in-depth overview of your
work with eternity blockchain our
excited we'll be opening a question and
answer session now and to kick off we
have a question from Christian who says
following on the state channel
communication of check of chain and on
the chain being recorded as just a final
balance where our persisted where the
off chain transactions persisted so
they're they're only persisted in the
closing channel transaction so it will
be up to the two parties of the chain to
keep track of any intermediate state of
that chain there will also be a
possibility to have a smart contract
that resolves the final state of the of
the of the channel but of course the
input to that contract has to be signed
by both parties and they will have to
keep track of this data so there will be
proxy servers that take care of
communication between parties in state
channels you can there's an open
protocol for doing this so you can write
your own but it will be up to the
endpoints to somehow keep track of the
state until the they actually closed
channel
thanks for that Eric the next question
comes from Ali and he says who or which
machines execute Oracle's and are they
also distributed so Oracle's do not
really execute as machines so the
Oracles are living off Shane and they
can subscribe to a WebSocket and find
requests for electrical answers and when
they find such a request they post the
answer to the chain and they can be paid
a fee for for this service by the
requester so implementation of of the
Oracle is done in in any language
outside you can write it in in visual
basic or python or whatever you want
thanks a lot Eric another question from
Ali he says could you talk more about
testing farness aviacode
test was it about testing the code yeah
testing Parnassus aviacode so i'm not
sure whether the question means the
ability to test it yourself right now or
how it will be testing by us so the
virtual machines and the compilers are
still under development there are some
browsers you can find in the Eternity
github where you can try things out you
can compile very simple sophia contracts
and run it on the test net as it is
right now but the interaction with the
chain is not on the test net yet
it will probably be within two to four
weeks and then you should be able to to
try out more contracts both solidity and
Sophia contracts the Varner contract
might be a bit longer before they are
online and our testing of the contract
we have the cubic team with us which can
do properly based testing so we will
have a many nice property based testing
tests for contracts okay thanks Eric I'd
like to remind everyone at this point
that you can still submit questions if
you have any in the question box onto
the next question from Thanos he's
asking do you have any customers or use
cases in finance that you can mention
that are planning to try your Chan so
I'm completely on the development side
and I do not really know what kind of
customers we have so you would have to
ask that question on the Eternity
channels that you can find from the
Eternity webpage of course and we'll be
sharing their eternity details in the
follow-up email after this webinar next
question from Gregory says do you have
any samples or contracts to look at and
test network for testing them the test
network is up and running and in the
source code on github there are a few
contracts under epic
eternity epic apps and Sofia is still in
the source code called ring for
historical reasons will soon change name
to Sofia
there is test contracts and there are a
number of contracts there so you can
find them some of them can be submitted
to the test net and run some of them are
still two to four weeks away before they
will actually work on the test net fully
Erik next question or - how would you
compare this chain to hyper ledge or
fusion I don't know enough about hyper
lint or future - to really answer that
we have a question from Andrew next what
other information resources are
available for eternity and airline
integration such as videos or blogs so
eternity has a YouTube channel and a web
page and there you can find some talks
about it and on github eternity there is
a repository called protocol which tells
you all the details about how the
Eternity talks to the outside world and
there's also in epic some read means and
getting started introductions to - set
your own node connect to the test net
thanks for that Eric next question will
it be possible to call contracts in one
language from contract in another
language yes that's the plan there will
of course be some restrictions depending
on types so the types and the data types
and in the different languages will be
slightly different so you have to have
functions that have an interface that is
compatible so calling calling functions
that take addresses on machines and it
takes integers should work between
contracts calling with different types
of record structures these would
probably be different between different
languages and then you will get type
errors at either compile time or run
time so since you can also refer to two
contracts by name and name's Malik might
actually change you can decide whether
the name should be dereferenced at
compile time or run time so you might
want to refer to the latest version of
named Oracle for example or a specific
version so this means that you can get
some runtime errors if you're trying to
call a contract that doesn't have the
the right function or a right type but
for simple calls the plan is that it
should be possible to call between
between different languages and that
there will be simple marshaling of
similar types like addresses integers
and so on
brilliant I'm so next question can you
resolve a state channel with a smart
contract
that's the plan yes
so the first implementation of state
channels that are coming in the next few
Sprint's we're working to experience one
sprint is ending today tomorrow there
are some parts of state channels coming
in there but not a full part and the
first version will only be without smart
contracts but in the final version you
should also be able to have a smart
contract that resolved the state channel
on closing and then you bought the state
that you sign would be the arguments to
to use - that's odd contract when the
closing ok thanks Eric and then unless
anyone else has any more questions this
may be the last question how is the fee
for a Varner contract calculated so sort
of in a similar way as for ethereum but
not at run time so each type of
instruction will have a cost and this
cost can be decided by governance but
there will be a starting cost defined
for each type of instruction and then
the longest or the most expensive if or
case branch of the contract the cost of
that one will be used so try not to
write very unbalanced smart contracts
that has one branch that does very
little and
branch that does a lot of work
especially if the branch that does very
little work is the one that most often
is executed so there will be a the
maximum cost so there are ways to to
avoid this problem by breaking things up
into smaller units but we think that
this will work out fine in most cases
but of course if you have an upper bound
there will be places where you will lose
out as a caller okay thank you very much
Eric I think that draws a close to our
Q&amp;amp;A session thank you everyone for
attending and special thanks to Eric for
joining us sharing your time and your
expertise on this subject to this it was
a very insightful session this session
was recorded so it will be shared with
everyone after the session in the next
few days thank you very much bye all
right
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>