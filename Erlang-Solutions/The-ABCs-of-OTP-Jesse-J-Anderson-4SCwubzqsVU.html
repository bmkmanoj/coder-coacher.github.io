<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The ABCs of OTP - Jesse J. Anderson | Coder Coacher - Coaching Coders</title><meta content="The ABCs of OTP - Jesse J. Anderson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The ABCs of OTP - Jesse J. Anderson</b></h2><h5 class="post__date">2017-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4SCwubzqsVU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I've got this buddy right now and
we're both kids the 80s and we're both
really into synthesizers but he's really
in the synthesizers right now he's got
or you used to have this little one
called the Opie one and this thing is
awesome for just like fiddling around
it's really easy just to make some
really fun awesome music but the other
day he's sent me a picture of another
synthesizer that he saw and it looked
like this and that
well first off that looks awesome I want
to play with that but I don't think I
didn't I know how to make it make any
sound I don't know how to do anything
there's like a hundred knobs and there's
like cables just sort of like strewn
randomly about and I would have liked
looking at this I have no idea where to
start and this I think is a really good
example of what OTP you look like to me
when I was first looking at it I knew
there was a lot of power there I knew it
could do some cool stuff but I just had
no idea how to do any of it
so let's just do some quick overview
what is OTP anyway well there's a lot to
it but basically a collection of
libraries and the hierarchy of
supervisors and workers that's sort of
when someone says hey you need to learn
OTP that's generally like what they're
talking about there's um so the main OTP
libraries are supervisor and Jen server
and if you're using the lick sir there's
a agent and tasks which are like
abstractions of Jen server but there's a
whole lot of other components to OTP
there's application there's Jen stage
dialyzer ETS it does list just keeps
going on and this is not a complete list
there's so many different tools and
aspects to OTP that when you're a
beginner like I was it's kind of
overwhelming it's hard to know where to
start but in general when people are
saying you need to learn OTP you they're
talking about supervisor and Jen server
so to learn supervisor Zeng gen server
we've got to start at the basics and
that's with processes and this isn't
like an operating system process
processes and elixir and Erlang or
superlightweight you can just spin up
a thousand on your laptop and not break
a sweat so let's go ahead and see what
that looks like so we're going to jump
into ie X which is the repple for elixir
basically like your playground tryout
code
so first we'll call spawned and that's
going to spin up a process and then
we're giving it a function for what to
do
so we're saying okay spin up this
process and once you start process I
want you to run this function that's IO
dot put and then hello EEF seventeen so
the process starts up and then prints
out hello e out of seventeen and then we
have this orange thing here is this if
you haven't seen it before it's kind of
weird look in the hash tag PID with some
numbers and that's your process ID or
commonly just called a pig and basically
that's how we're going to track this
process so we didn't capture it so let's
go ahead and just spin spin up the
process again and this time we'll
capture the process ID in the variable
pad so we run it up it prints out hello
EEF seventeen and now we've got that
process ID captured in the pit so let's
go take a look at what our process is
doing so we'll do process dot alive just
to make sure it's still alive and it is
not alive what happened to our process
so when you spin up a process it gives
it runs the function you give it and
then it immediately just gracefully dies
and that's just how how the processes
work you give it the work to do it does
it and then it's done so this is great
so now we know how to do processes we're
going to start throwing them in our
application but at some point you're
going to give a process a lot of work
and halfway through it's just going to
crash it's not going to die gracefully
so how do we deal with that so we're
going to do some error handling here as
I'm sure many of you have heard in the
world of Erlang and elixir commonly
commonly said is let it crash like
that's just the solution to everything
and when I first heard it I was like I I
don't want my application to crash I
don't understand how this is going to
solve things um and part of that was the
way I was thinking about applications
but when you think like outside of apps
you write you think about like like
Photoshop I'm a designer so Photoshop is
something that I all kind of have a shoe
with or um just your whole operating
system in general or maybe your video
game console your phone some of my kids
electronic toys your TV a problem
happens with that and what's one way
that's going to fix it most of the time
for all of those
does anyone here watch the IT Crowd yeah
have you tried turning it off and on
again and this works it works like
universally for a computing and
electronics like 90% of times this
actually does fix the problem why why
does that work so the reason it works is
because you're starting over that device
or that app or whatever it is with brand
new state what happened somewhere along
the way that that thing they had the
issue got corrupted State something
weird happened and then it cracked or
and then it had some issues but
restarting it you're giving it fresh
state and you don't have that problem
anymore
so the supervision tree is based on this
principle because the way apps work in
your lips and Erlang is you have these
clusters of all these different
processes we can try turning it off and
on again at a very specific level so we
don't have to crap let the whole app
crash we're just saying that little
piece that's not working right now
because the state got corrupted or
whatever we're going to let that crash
so so in this tree basic tree we have
right here we've got some supervisors
and then we have some workers and
supervisors are just other processes
have really really simple job because
you don't want them to crash so all they
do is they start up the processes the
children processes underneath them or
they when they see the state go bad and
the process crashes they restart it and
restart isn't quite the right term
because they're actually starting a
brand new process that has the same
starting state so if you look at this
tree look at this tree right here the
worker down there on the bottom right in
fact if that crash is the supervisor
right above it is watching this is oh
hey that that just crashed I need to
restart that and it'll try it a few
times and then if that doesn't work it's
going to crash itself and then the
supervisor above it will try restarting
it
kind of cascade all the way up if your
top supervisor crashes well then maybe
you just need to rewrite because you got
a really serious problem but that's sort
of the basic idea of the supervision
tree and when I learned this I was like
okay that that sounds great like that
seems seems cool seems useful but let if
start working on there what if I'm just
a bad coder what if I just have bad code
in there um this how is this going to
magically fix my bad code that's just
going to fail every time you restart it
and the answer is it's not that code is
not going to magically get fixed by OTP
so if it doesn't fix that what is it
doing so this is a part that took me a
long time to figure out um but there's
this really great article by Freddy bear
called the Zen of Erlang and he goes
over this he identifies bugs as being of
one of four types so you've got your
core features in your app and your
secondary features and then of those
kind of bugs you have the ones that are
easily repeatable and the ones that are
transient
so the first offs are core feature
that's easy to repeat it's pretty easy
to find those bugs like those are like
oh you do this you do that and you do
this on the main feature of our app it's
you know this bug happens so those are
pretty easy to find secondary features
also pretty easy to find but often you
overlook them because they're like oh I
forgot our app even did that that's the
feature we've made few years ago and we
forgot users actually use it so
sometimes those the ones that you can
overlook well the transient bugs these
are the ones where you get the bug
report and you're looking at it you're
like I cannot get our app to do this how
how do they do this it does not make any
sense
and these are the ones that are really
hard to find because there's some crazy
sequence of steps that somebody went
through to cause the state to get to get
into this weird state where this bug
shows up so because of this the kind of
bugs that happen in production the core
feature ones that are repeatable those
should never happen oh they do but they
shouldn't ever happen a secondary
features those ones happen pretty
commonly that's often because you
forgot about a feature you like oh
that's thing I'll fix it real quick and
we'll push the production this afternoon
the ones on the right though the
transient bugs those happen all the time
in produce in production because they're
hard to detect hard to find the great
thing though bugs that are handled by
restarts not really the repeatable ones
but the transient bugs restarting that
part of the app fixes that problem so we
have these kinds of bugs that are are
hard to find and a harder to detect
before they get to production but
restarting usually is a way to fix that
bug so we talked about all these just
independent little processes um and
they're actually the memory independent
which is great so restarting them
doesn't affect any of the other
processes in your app but they have to
have a way to communicate and the way
they communicate is with much with
messages so every process has the paid
we looked at earlier the process ID
which is like the mailing address for
that process and so and they also all
come with a mailbox so they are ready
when you spawn it up it's ready to
receive messages we have to tell it what
to do with the messages but at start
it's ready to receive those messages
excuse me so let's go ahead and see how
this works
um so I'm a big I'm a big fan of a
fantasy football and it's never too
early to get started to the next season
so we're going to build a real basic app
here that just lets us store the players
in our team with some basic stats in
this past summer hours of doing some
learning of elixir I've I created a
quick API wrapper for the fantasy
football nerd API and so that's going to
let us just feed a player name and then
it'll return back a bunch of data about
that player so the first thing we need
to figure out for our new fantasy team
app is how we're going to store the
state so there's a lot of different ways
you can do it off your from Ruby you're
like alright time to build the database
because that's kind of how you do it and
there's nothing wrong that like we can
do that we if we go to production with
this app maybe we're going to build some
bass using echo or maybe we could use
ETS for a more long-term storage
there's Neeta there's some other options
but for now we're just doing kind of our
own little app for us we're just going
to store that state in the process and
that'll be fine so this here is the this
is our basic process that's going to let
us add players to our team remove them
and store them and return the full team
so let's go ahead and walk through this
so we define the module at the top
fantasy team DUP basics we're just doing
our basic process here and then we have
these start functions so this is the one
that's going to kick up the process and
there we have the familiar the spawn
process we did earlier instead of giving
it a direct function we're actually
giving it a set of instructions so first
we're going to give it to module to call
and we do double underscore module here
which just references that the name of
the module you're in which in this case
is fantasy team basic so when you
compile this it's just going to replace
that with fantasy team basic and then
yeah that's the module and then the
second one is an atom and this is
actually telling it which function to
run under that module and then the third
is a list of arguments in this case we
only have one argument which is just an
empty map and so basically what we're
doing is we're spawning up the process
and we're saying hey take that module
and that function and these arguments
and then run that so when the process
starts up it's going to run basically
fantasy team basic loop with an empty
map as a function and that's our
starting stakes our team to start with
has there's no players it's just an
empty map ready ready to receive data so
now we'll go down and check out that
loop function we're telling it to run so
we've got loop state so at the beginning
state is just the empty map and then we
have this receive do block so before we
had our process that immediately died
when it finished printing out hello EEE
EE f17 in this case it's actually going
to sit and wait to receive a message so
this point it's just sitting there it's
not like eating up memory it's not like
walking or whatever but it's just
sitting there waiting not doing anything
until it receives a message
so the first kind of message we want to
be able to send it is this twofold it
starts with an ad atom and then the name
and the name will be a string like
Russell Wilson in quotes so we'll take
that name and then we'll we will run and
this is a function we have in the
background that does the API that calls
up the data so we're going to take that
name Russell Wilson we're going to run
fantasy team dot player to find Russell
Wilson and that's going to return for us
this big map with a bunch of details
about that player so you know like
college Wisconsin team Seattle position
quarterback etc so now we have this
player variable that's got a map of all
that information about the player we
just added and then we're going to
define a variable called new state and
this we're taking the existing state
which is an empty map and then we're
adding the team we're adding the key of
Russell Wilson and then all of his
information as the value for that so now
we're going to have a map that has one
one item in it which is Russell Wilson
and then all the steps and if we just
stopped right here it would create that
state and then it would just die so we
would lose it because we haven't looped
it again so the here's where we have
recursion so after we define what the
new state is we're going to run the loop
the loop at the top again we're going to
run this function again but now our
state instead of being an empty map it's
the map with Russell Wilson and so now
so now that we've run loop we're back at
the top and now we're waiting to receive
another message
so the second kind of message we have
listed is remove a player and it's the
same thing it's the remove atom at the
beginning of the tuple and then the name
that we're trying to remove and then we
don't need to check the API or any
thinks we're just removing the player so
we define the new state as the existing
state - this this player that we want to
remove and then we loop it again back up
at the top and then our third message
that we're going to receive is an atom
with team and then the paid because when
you when you're calling this you need a
message back you're asking for send me
back the team so when you send this
message you're sending back yourself the
process sending this message is sending
its own process ID so that this process
that were
knows where to send the message to so
like if we were in IEX and we sent a
message to this it would send its own
process ID with the message so that um
our process we're defining right here
could send the message back to IEX and
then we do that with the first thing
here we just do send to that sending
pid' and then send it the state and then
we're not changing the state at all so
we're just going to loop back up at the
top with that existing state and that's
it
so this is our basic process module
let's go ahead and see this in action
real quick so jump over to IEX
and we were starting up fantasy team
basic that start and capturing that page
so we can send it some messages and
first we're going to send it send the
message the tuple add the name Russell
Wilson so then we see the return like
there's a message to being sent at
Russell Wilson and now we're going to do
it again we're going to add Doug Baldwin
and then we'll actually try out just to
make sure it works we remove Doug
Baldwin and then we'll call we'll send
the message for the team so we didn't
get it sent off the message you see
right there team and then our process ID
but we didn't actually get anything back
and that's because IX isn't built to do
anything on that with that message so
the message was sent but it didn't do
anything with it and so we can just
flush out the mailbox and then see up
there there there it is there's our map
with Russell Wilson and in his details
so it did get the message it just wasn't
I didn't have any way to handle it yet
so this right here we just walked
through this is a really really really
common pattern and elixir and Erlang and
it's so common that they've built a
generic library to emulate it which is
called gen server what we've done here
it's pretty easy to kind of walk through
and understand but it's actually missing
lots of edge cases there's there's a lot
of issues this looks nice and clean and
simple but there's a lot of issues with
it having to do with compatibility with
supervision trees deadlocks message
ordering tail call optimization dynamic
tracing and I don't even understand what
half of that is but luckily really smart
people do understand what all
is and they've been working on Jen
server for 20 or 30 years behind the
scenes so it has a lot of history behind
it making sure it's battle-tested and
taking care of all the edge cases I
don't have here and do not understand so
let's go ahead and see what it looks
like we take what we built and move it
into a Jen server so might be a little
hard to see in the back we are going to
zoom in so on the left it looks like
it's about twice as much code but half
of that code is actually convenience
functions so we don't even like really
the code that's doing most of the work
is pretty much the same there's not
really that much more so we're going to
go ahead and go through this so that it
all makes sense
so to start off while we do the line use
Jen server and that's like saying yeah
we want to use all that great stuff but
the OTP team is built so we're going to
go ahead and bring that in here and
that's going to let everything else work
in this module so we start with start
with the use Jen server and then now
we'll jump down to those functions at
the end they're the ones that are
similar so well first we have our our
start function so that's the one that
kicks it off and it does kind of the
same as before before we had spawn but
the process spawning the process that
had the module the function and the
arguments over on the right and on the
left now we just do Jen server dot start
and we give it the module name which
again that double underscore is just
pulling the name we have at the top of
the module and then we don't actually
need to give it the name of the function
to run because it has its own loop
function we don't we're not going to
have to define how the loop function
works it kind of has that already so
we're just going to pass it in okay
tuple here and then the third list there
that's four options we don't we're not
going to use any of those today so now
we'll jump back so we have this init
function and this is something you do in
every gen server when you do the first
thing in Jen service start that's going
to start up the process and it knows to
look back at the module because we
define that as the first argument it's
going to look back at the module and say
hey I'm a Jen server I need an init
function
what is your init function and so we
define it right here and all it is we're
just doing an okay tuple and then
second part of the tuple is the state
there's so there's our empty map that's
where we're going to define our state
here and then we're going to jump down
to this function here called handle cast
so before on the right we have this big
encompassing loop function that has
received du and then all of our messages
so gen server we don't have kind of a
wrapping function a wrapping loop
function like we did over on the right
now we're actually going to be able to
handle each message individually in gen
servers handling the looping in the
background so so with this handle cast
we have the part handle cast is
receiving a message ad named like before
we had under the received block now we
just have it as the first argument of
handle cast and then the second second
argument is the state which instead of
putting it up in the loop function
because we don't have that we're going
to define that as the second argument of
every handle cast and then we'll jump
down to this part and this is exactly
the same we're looking up the player in
the fantasy football nerd API and we're
defining it and then we're creating the
new state by adding a player to it and
now instead of running our loop function
like we did on the right because again
we don't have it here we're just going
to return a tuple that starts with no
reply because we're not sending a
message back for the calling process and
then the new state and then gen server
knows how to now maintain the loop with
this new state yeah so then we have our
second one here the handle cast with
removed function pretty much the same
thing we've got the message received
there as a first argument and then the
state yeah the state of the second
argument which is again at the top of
loop on the right side and now I have
this line which is the same thing we're
defining a new state which is removing
that one player from the existing state
and then we have a no reply tuple with
that new state in it so the third one
instead of handle cast this is handle
call and the way general works is it
kind of has two types of messages that
you can send it you can send it a cast
which is kind of like sending a postcard
like you're not respecting a reply
you're just like hey do this and now I'm
going to go ahead and do my own state
or you can send it a call and that's
where you're asking for a return like a
do this thing and then tell me when
you're done like I want to know what
just the result of this is and so in
this case the result is I want to know
what the team is so I'm going to send
the message with it's just the atom team
and then we also send the second
argument there is from and that's the
sending process ID and most of the time
you don't actually need this there are
some cases where you do but we're just
going to precede that with an underscore
because we don't actually need that
value and then the third one is the
state so all we need to do here is
return a return a three element tuple
that starts with the hashtag refers in
the hash tag the atom reply I've been
doing too much a Twitter thinking lately
I guess and we have state in here twice
so the the first one is that's actually
the message that's going to be sent back
so before we on the right we did send to
that process ID the state because that's
what they want and when I see the entire
team so here on the Left we've got the
first or the second argument there which
is the first state and that's the
message being sent back and the second
one is that's the state that we're going
to save so in this case they're the same
but like if we have another handle call
that was like quarterbacks I just want
to see all the quarterbacks that are on
the team the first one would be all the
quarterbacks and then the second one
would be the full team because we still
want the full team to be the state okay
and now we'll jump back up to the top
and there's our convenience function so
we have the start right at the top that
we already went over and then now we
have our add/remove and team functions
so first we've got add and remove and
they work pretty much the same first you
will list the the process ID and of this
prot this gen server that we're starting
up and then the names like Russell
Wilson you want to add Russell Wilson or
remove Russell Wilson and we're going to
take that and then we're just going to
do gen server dot cast and so what
that's going to do is it's going to when
you run my
fantasy team my gym server dot add
process ID Russell Wilson it's going to
do gentle forecasts and it's going to
cast a message to that process idea we
gave it and then send it the message add
name and then remove name and then those
will be handled by the handle cast and
the handle call that we went over
already and then with the team we so we
don't have to supply a name so we're
just applying the pid' and it's going to
do a gym server call and that's going to
send the message and wait for the reply
yeah so there we have our full gen
server and the one thing that's really
kind of annoying with this setup though
is we have to track that process ID and
that sucks
so we're going to get rid of that
because we're for this example I'm just
trying to track my own team I'm only on
one league so I don't need to worry
about a whole bunch stuff we're just
going to make this real easy so we're
going to add a name to this this module
now we're going to call it single server
and so here we have a module attribute
that just defines name adds the module
name and then we're going to start
plugging out that into our convenience
functions so now when we do jenthor dot
start before we didn't have any argument
or any options on the rights we decide
an empty list now we're going to say
when this process starts I want to give
it this name of benefit team that single
server and why would you do that well
now we don't have to we don't have to
cast to a process ID we don't have to
keep track of that anymore because we
know the name so now in the gen server
caste we can just plug in the name right
there and the cool part about that is
now we can take the pit out of our
function name so now it's just just
fantasy team that single server dot add
Russell Wilson and it knows what the
gender is and knows the process ID and
we don't have to keep track of that is
one of the most annoying things about
all this is tracking process IDs so
anytime we can get rid of that I'm going
to do that so there we go so let's go
ahead and see what we've built in action
here
so we go ahead and start up that that
gen server fantasy team that single
server top star we see the process ID
right there but and OVA gen sir as it
returns rather than just the process ID
it returns a tuple that starts with okay
and then the process ID but we don't
need to capture it because it has its
own name so we can just write from here
say fantasy team dot single server
address so Wilson and it just returns
like okay which is like sweet okay I
guess it's working we'll go ahead and do
it again with adding text following and
then we'll remove Doug Baldwin and then
we'll go ahead and do our team call and
that gives us a return value of the team
so there we see it so cool um one thing
if you if you're using elixir they've
done this thing where they take gen
server and Jen server kind of what we've
used it for is basically just storing
state like it's not doing any
complicated stuff it's just storing the
state so it looks ER is kind of taken
the other thing you can do a gen server
is do a lot of kind of complex work and
i concurrent tasks and stuff and we're
not doing that here but elixirs kind of
taken abstractions from gen server and
so it has agents which just do storing
state and then it has tasks which just
do kind of all these concurrent work so
let's go ahead and just see what we've
built already we're going to see it as
an agent real quick and this is it this
is the full code that does everything or
Jen's ever did but now it's as an agent
so it's a lot less code because we have
kind of those convenience bug functions
where it's just my agent add and then it
runs everything from right there so we
have agent update and that's what
there's like there's only kind of a few
functions that agents do because all
it's doing is storing state so one of
them is updates so when we do aging the
update we give it the name or the
process ID if we're not using the name
named server and then we send it to
function for how to update the state so
in this case you're taking the state and
then you're saying map put the you know
the new player into that state on the
same with remove map delete that that
player from the state and that's all all
you need to be able to maintain
state with an agent oh yes there yeah
yeah and then we have for the team we're
just trying to get the current state so
we can use agent get and then our
function is just like a function state
yeah the state's done a setback there's
a few other functions you can use like
instead of just update you can say get
and update and that's going to you're
going to want to return a two element
tuple so the left one is the state you
want to see first and you can do other
stuff with it right here we're just
returning it as the first element and
the second element is going to be the
new state that we adjust here with the
map by either adding the player or
removing the player and then there's
also agent cast so all the other ones
update get an update those are all calls
so you're actually when you when you run
agent update you're waiting for that
response to for like an okay tuple or to
find out like okay yeah it added the
player with the cast you're just like
you know fire and forget like you're
like yep go out the player and I'm going
to do my own saying I don't need to know
that you did I trust that it's going to
work out or whatever okay so one thing
if you're more familiar with this you
might have been wondering like why I'm
using start and spawn instead of start
link and spawn link and if you're not
wondering that then let me tell you why
we should be using that so when we had
our supervision tree before I talked
about how a worker would crash and then
the supervisor would see it crash and
restart it so the way that works is
processes need to be linked together so
when you instead of running a spawn if
you run spawn link that links it to the
calling process so if you're in IE X and
you run spawn link a process and then
that process crashes ie X itself
actually crashes to because they're
linked to each other if one of them
crashes the other one goes down the cool
thing is is already using the
supervision trees you might not even
notice because IX will go ahead and
start right back up again
which is pretty awesome so that's a
really quick way to see the supervision
tree in actions just run a spawn link
and do like the function you know 1/0 or
some
and it'll just kill it and restart ix
for you which is pretty cool so the
problem of this like well you don't want
the supervisor to go down if one of its
child processes should go down so
supervisors have this thing that's
called trapping two exits and basically
that seeing like oh it went down I'm
going to not crash myself and instead
I'm just going to restart that process
so yeah as I said before we had some
functions that are just start and they
would spawn or gen server dot start
aging dot start all we do is change
those to adding the underscore links of
spawn underscore link or gen server dot
start link and then we're going to we
would go ahead and change the actual
starting function names to that to which
we don't I guess technically have to but
it's just common pattern you want to
have that so the when you start it up
you know it's link process so we're
doing pretty good here but if our gender
goes down it's still just going to die
because we don't have anything actually
supervising it so let's go ahead and do
a supervisor real quick and this is
supervisors we're really intimidating
for me but there's really not that much
to it they work like I said before
they're really simple all they're doing
is starting processes or restarting them
when they crash so at the beginning we
just do this use supervisor just like we
give gen server and that's kind of
getting all the magic that the Erlang
OTP teams and working on for decades
which is pretty nice really easy just
like oh yeah one line let's use all that
awesome stuff you guys have done and
then we're going to start up our
supervisor with start link and then that
will do supervisor start link and we
give it the module name that we're in so
fantasy team got my supervisor which is
at the top there and then we have
options and we're not going to use any
options here so it's just an empty list
so that supervisor process is going to
start up and because it's using
supervisor similar to Jen server it's
going to look back at our code at this
module that we gave it and say okay
where's your init function because
that's what I need now that I've started
so we do our init function here and
we're just going to give it the empty
list because it doesn't have any any
advanced options and then we're going to
define a variable called children which
is just a list of the process
is that we wanted to start up in this
case we're just going to have it start
up our single gem server so we give it a
worker function and we would do this for
if we had if we wanted it to start like
say like three workers and one
supervisor we would just have three
functions in here in this list and a
supervisor function so but in our case
we're just having it start at the one
gen server that we're going to watch so
we say worker and in the first argument
is the module name of the process we
wanted to watch which is our single
server and then again empty list for no
options there and then the thing that
makes this all work we end our init
function with a supervised call and so
this is going to take our list of
children which is just our one server
and then it's going to give it a
strategy and so there's a few different
strategies like your basic one is this
the one for one that means if you have a
supervisor that has like four processes
underneath it if one of them dies it's
just going to restart that one there's
there's some other ones like restarting
all of them if one of them dies and a
few other ones that I think there's just
four and they're pretty simple once you
understand once you understand one of
them is kind of it's pretty logical to
go down the list but for this case we
just have the one process so we're just
going to do our strategy is one for one
and that's it so now instead of starting
your gen server with fantasy team dot
single server dot start link we would
start with fantasy team dot my
supervisor start link and then this will
go ahead and start up our gen server as
well and now it's being monitored and
good to go so a quick recap
so we built a we started with processes
and then we built a gen server we named
that gen sir so we didn't have to track
the process IDs and then we built a
supervisor to keep track of that gen
server so that if something goes wrong
it'll go ahead and restart it if if
you're more advanced with OTP you may
see a few flaws and what we've done
because there's a there's a lot to OTP
like I said before and there's a lot
more you can do to make what we've done
work a lot better but what I did teach
you is this
and you can make some music you maybe
you can't do a lot with all this but you
can do a little bit with this thing
called OTP enough to kind of make some
stuff work and now you can like well hey
what happens if I grab this cable from
over here and plug it in what else can I
do you have kind of that foundation to
be able to start learning some of the
other things from OTP like maybe you
want to like well I want to figure out
how Erlang term storage works EPS or EPS
whichever way you want to pronounce it
like now you have kind of a model to
build off of to do that yep that's it
you can follow me at Jessie J Anderson
or just needs Anderson as all my friends
call me because it looks like that on
Twitter and I also created a quick link
a bitly link for abc's - of - OTP that's
got a bunch of links to different books
that have really helped me to understand
OTP Dave Thomas and Sascha Urich both
have books that are great I'm one that
really clicked for me was Benjamin tan
way how he has the little elixir an OTP
guidebook and that was kind of the light
bulb moment for me where it finally
started to all make sense there's also a
new book that just kind of came out in
beta bylanes Halverson I think he's here
and I read it the first like third of
that book on the plane ride here and
it's fantastic highly recommend that one
too and that one's called
functional web development with elixir
OTP and Phoenix by Blaine's Howerton so
that's it thanks there
any questions huh right so um oh yeah
yeah sorry the question was when you use
agent and when do you use gen server so
there's kind of differing views on this
I now that I really under I feel like I
understand OTP at least the basics of it
in gen server I like to always just use
gen server because then if I need to
change it later like I want to add some
more difficult stuff to it it isn't just
storing state I have it but agents
pretty nice but is a tiny low amount of
code so if you know like this is never
going to do anything more than just
store state agents are kind of a great
way to go but there's really there's not
a right or wrong answer it's kind of
personal preference yes right so the
question is about agents and tasks and I
talked about agents I didn't talk about
tasks so tasks are I haven't used them
so I'm not super familiar with it but
kind of the idea is like if you have
some complet like maybe you're doing
like machine learning or something like
really you have a bunch of complicated
work you want to do and you want to run
concurrently so it's using kind of all
the different processors in your machine
or whatever tasks is kind of a great way
to just send out and have it like it
automatically kind of can run that stuff
really well I don't actually use tasks
so I'm not super familiar with it but
that's kind of like the idea you want to
do you have a lot of work you want to be
done and it's going to be done better if
you have a lot of processes kind of
doing pieces of the work and tasks tasks
are really great for that but I'm not
familiar with a lot of uses gentleman
yeah yes
Oh perfect there you go if you wanted to
talk - what about tasks yeah
right it's really great and you're like
oh now I got to make it a jen server
anyway maybe I could have just started
there yeah cool
any other questions yes um the questions
about unit testing will exert yeah
there's some great testing I don't know
the knowledge off my head but yes
there's a X unit I think it's called
yeah yeah I'm dr. L doc tests are
awesome yeah so it looks they're really
encourages you to use documentation in
your functions because you can do doc
tests so your documentation in your in
your modules will have little examples
of how to use that function and doc
tests will actually run those to make
sure that they work which is really
really cool yeah yeah it will force you
to improve your documentation or you'll
have a lot of field tests
yeah right so the questions about elixir
1.4 and how it added this new thing
called registry I don't know I'm excited
about it I've heard good things about it
for managing process IDs but I'm not
familiar with it I'm excited to learn
because well managing that has
definitely been one of the pain points
for me and trying to do anything kind of
more advanced so yeah questions back
awesome I probably have that saved in
pocket ready for me to read later any
other questions yes right so that's one
of the things I talked about where
someone more familiar with this is like
yeah but you're not you're losing the
state if it crashes and that what we
went through you would lose that state
and that's some of the stuff I refer to
like ETS and nija and other ways you can
save that state in a more permanent
place yes right so the question was
about what if the state is a bad in
permanent storage and you're just sort
of refreshing it with that bad state is
that right so you have a supervisor's
have like a limit so they'll try to
restart it a limited number of times and
you can adjust that and if that fails
it'll kind of cascade up if you have a
really bad situation it may you may need
to get in there and fix it like if it's
somehow the state got corrupted and
there's not you haven't like engineered
a good way to clean that state if that
makes sense
so hopefully that's the sort of thing
that you would be able to that it would
be caught before it went to like
permanent storage if that makes sense
yeah anyone else awesome if you if you
have any other questions and you see me
around go ahead and ask I'd love to chat
all right thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>