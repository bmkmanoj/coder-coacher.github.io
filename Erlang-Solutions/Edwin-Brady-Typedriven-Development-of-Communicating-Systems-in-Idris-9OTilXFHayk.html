<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Edwin Brady - Type-driven Development of Communicating Systems in Idris | Coder Coacher - Coaching Coders</title><meta content="Edwin Brady - Type-driven Development of Communicating Systems in Idris - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Edwin Brady - Type-driven Development of Communicating Systems in Idris</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9OTilXFHayk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">title does indeed promise communicating
systems the title I'll just leave that
there
don't worry I am going to get there what
I really want to talk about though is
total functional programming and that
should probably have been the title so
I'll tell you I'll tell you more about
what I mean by that as we go so address
is a purely functional language it has
dependent type so if you were all at the
keynote this morning you live for you
have learnt about some of the cool
things you can do in languages with
dependent types and particularly this
idea of of type driven development sleep
the idea of coming up with the type
first and then because we've we've made
that we've made that promise of all we
made that plan of what we're going to
work on we can have the machine help us
work towards a working program so the
goal here and the goal behind thinking
that the Gopher you know me in the way
the way I want to write programs and the
way the way my research is going is I
want I want it to be so cheap to write
correct software that there's no excuse
for not doing so so now I think we're
quite a long way from that but this that
this this approach of dependent types
type driven development and working
toward the program promise pacification
I think it's a highly promising approach
to doing that so in this talk I'm
particularly going to talk about the
importance of writing total functions
and how writing total functions helps us
have a lot more confidence that the
functions we're writing the program for
writing do exactly what we expect them
to do and I'm going to talk about
something we don't often talk about at
least in in this kind of community is
that sometimes you you hear people say
oh sorry I hear people so anyway that if
you have if you have a total programming
language you can't write a server some
people think this is this is III I hope
to show you that this is this is not
true so total functional programming is
about a lot more than merely checking
the
program terminates it's about having
complete confidence that the types we
write really are describing the programs
were writing and the practical example
that hopefully I'll get to I like the
fact that Jessica use the word hopefully
in her introduction there I hope we're
going to get there too so we'll see how
well see how it goes okay so what I'll
do with my time traveling development
we've already we've already seen this
this morning in fact so think of the
type as being a plan don't think of the
type as being you know the thing that
you tell to the compiler and then you
write your program that goes alongside
that type and then you feed all of this
information to the compiler and the
compiler the you know the teacher will
send it back to you and say you know
you've got it wrong
you know eight out of ten see me after
class you know we do it and so you
resubmit your homework and eventually
hopefully you get it right we should be
thinking of the types of being kind of
like our assistants our lab assistant
that will get us to that prefer get to
that program so just like you saw with
with anchors program search machinery
this morning that's the kind of way we'd
like to work so well write the type
first we'll define programs
interactively programs might contain
holes so holes stand for part of a
program that you haven't written yet but
you intend to write at some stage so
again we saw a lot of examples of that
this morning so Colin was writing these
almost complete programs but with holes
that weren't worried where he was saying
to the Machine you do this this is
boring you do that job so and as we as
we work through a program eventually
we'll end up at a complete complete
implementation and what one thing we
didn't hear so much about but certainly
happens is when we come up with a type
we don't get that type right first time
necessarily so this process of
developing program we might learn a
little bit more about the problem so we
have to tweak our types a little bit and
eventually by this sort of
back-and-forth for this iterative
process of writer type defined the
program we find the type in the program
hopefully we'll end up at something
that's going to work so I was
informative
Jessica very pretty helpfully mentioned
that that there is a book on it is
coming out soon and the editor insisted
on me
a three word pithy phrase to summarize
this process because I don't know
anything about marketing and he told me
that this is what you have to do if
you're if you're into test-driven
development you'll know all about red
green refactor well we came up with or
actually he came up with type define the
repo I couldn't come up with this sort
of thing
I don't know if it's that I've said it
so often now that it's starting to sound
good but I don't know maybe maybe it
doesn't sound good to you anyway this is
why you should remember come up with a
type define the function and then refine
the types and implementation that's
necessary so it's kind of like I mean
you your your see when I say that your
analogy alarm should be ringing there is
an analogy coming up so it's kind of
like when you're doing this sort of
thing so this is a jigsaw you might not
be able to see this with the contrast
particularly well so this is a pub
that's just opened up next door and
railway station by the way fantastic pub
called the station house and and one
thing they have is a communal jigsaw
which is the best idea ever in a pub so
I'm concerned this is the communal
jigsaw and a couple of weeks ago we were
trying to build a picture of the
coronation Scot so this is this is time
for living development in action because
I can't reach this side so I'm going to
resort to the laser pointer so maybe you
can't see that are you the most pointer
so this is this is the specification
that we are aiming to implement here's
all the holes and then here's our
implementation so far now this analogy
does break down very quickly
unfortunately much like much like trains
actually and it it breaks them because
this train stays the same the whole time
but let's let's go with it anyway just
persist now this this thing there's what
we have here this this minimal program
so we will work through it we will write
and more few more bits of the program so
here's a programmer working on this
program we've got a few things that
we're going to fill in but this is what
we have here this this this image this
is actually well typed because all of
the bits that we've put in this program
they're there and they work so if I
didn't care about totality if I was only
writing partial program
I could solve a partial jigsaw and I
could say look I finished I'm done get
the next jigsaw out to move on let's
move on for the next jigsaw but I can't
really do that a program is not complete
until we've got all the bits in there so
you wouldn't take a specification and
say right I've done most of this I
haven't dealt with the errors I'm dealt
with you know I've dealt with the happy
cases I haven't dealt with the error
cases but a type check so it's fine so
you wouldn't do that you certainly
wouldn't do that it's so the the Forth
Road Bridge is nearing the end of its
life so this is what we have now this is
they're currently implementing the
specification of the Queen's ferry
crossing and you'll see here they're
just they're just filling in the last
hole so again you wouldn't be
particularly thrilled if they said well
we've fit the specification so far we've
got this little bit left over but you
won't you you know you could just drive
a bit faster it'll be so you
wouldn't do that but we happily do that
in our in our program so we happily we
have to run things that that aren't
complete because we think we think these
cases don't necessarily matter
so total functional programming is about
writing programs where we know we're
going to get an answer we know we're
going to get an answer of the right type
so this this means one of two things in
in practice so until these aren't
especially formal definitions but where
the purposes list or pending they're
they'll be fine so a total function is a
function which for all well-typed inputs
it will either terminate with a well
toke result so with the type we said it
was going to have oh and this is the
crucial bit that allows us to write
interactive programs or it will produce
a finite and non-empty prefix of some
well typed infinite result so think
streams so say you know you had say
you're generating an infinite stream but
you only generate the first few things
in it that kind of thing so why do we
care well I claim that if we care about
types we should also care about totality
and the reason we should also care about
totality is imagine you have some
function s of type T let's think about
what we know is that F is total versus
what we know if it's partial if it's
total we know that whatever happens it
will always give a result of type T
we're not saying anything about how long
it's going to take it might take a very
long time but when it gets there it's
going to be a result of type T there
certainly no accidental infinite loop
had anyone ever written a deliberate
infinite loop that didn't produce
anything I mean I hope not
the system was gonna tell me perfectly
valid reasons for that man
yeah please say later I know there are
perfectly valid reasons but if it's if
it's partial on the other hand then all
we know is that if it ever does produce
a result then it'll be a type T and how
are we going to find out of it produces
that result of type T we're gonna run it
well that's not quite what I want I
don't want to know if my own mean I kind
of do want to know if my programs gonna
give the right answer afterwards but I
know it's got the right hands but I
kinda like to know up front if it's
going to produce the right answer so I
didn't I've called this T and someone
remarked over lunch that we functional
programmers like to give single letter
variable names to things and it doesn't
help anybody there is a reason I pick T
here rather than say type and the reason
is that T can also stand for theorem so
it's a sort of part of what I mean about
making it easier to write programs where
we know they're correct
thanks to curry Howard if you have a
type that type is also a theorem that
you might be proving and then your
implementation of that program your
implementation of F if your proof of
that theorem so I'll show you some
examples of what I mean by this for poor
writing total functions in interest
hopefully this is kind of also by way of
an introduction to the syntax if you
haven't seen it before and to help you
with what's going on later on so let's
so I have a I have a Aten butter here I
like to use a term rather than vim or
Emacs when I give talks cuz if if you
pick vim everybody looks at your talk
and things oh I liked your talk but it's
a shame I have to use vim is for some
reason people think that if you use them
everybody has to use them so I'm using
Assam here because that way I can only
animate an entire audience rather than
just Harper it so they
so I don't actually use that in practice
so there re there are its interactive
mode for vim and Emacs and a theme to
all of this stuff I'm doing an anthem
you can do in in a text editor as well
did I say that out loud I'm so sorry I'm
so sorry that I really really shouldn't
say that sort of thing home right I'm
gonna be in so much trouble when this
goes on the right so it's on okay for
font size it wasn't I checked earlier so
yeah you're okay good so vectors you've
seen you've seen this morning so it's
the same sort of idea this index by
length and just just to show the basic
idea behind behind this type driven
approach in Idris so I've got zip with
zip with is a function that's got two
vectors side by side the two it's kind
of like two sides of a zip and you pull
the zip up pull things together we
having to apply function while we're
pulling those things to go so we're
prying a function correspondingly two
elements of the vector if I was using
angular I'd be able to do this this in
one key press and I'm jealous of that
and I will get round to implementing it
eventually what I'm doing is I'm doing a
case split on on each of the possible
inputs to this function Idris is telling
me what the possibilities are so notice
in particular if I the two of the two
inputs are the same length so if I do a
case split on the second thing after
doing a slit on the first thing it had
better be the same length so in this
case that'll be the same length and
because this thing I'm searching for
here so this this query zip with RHS
three this is a hole so it is it is a
part of the language I can type check it
so if I ask the Machine what it's type
is it'll give me all of the context
it'll give me the thing we're looking
for and then I can search for what goes
in it right so that's a that's your
basic zip width and something that idiot
always does that I don't often you know
put up front it is always checks whether
function definitions are total so I
could load this into into the raffle
and ask Idris if with this total the
only one I care about is this one I'm
just written main dog lick with so main
dog zip with is the one I just wrote in
it said it's total if I do something -
like I don't know miss a case out then
it says it's not total as there are
missing cases so you might think well
why is that why is that just something
that's in the repple rather than
something that is really an error and
the answer to that is it's simply about
path to adoption because programmers
don't typically think about I mean you
do think about these things informally
but you don't think about explaining
them to the Machine well I think
long-term it's going to be
I mean David Turner who I'm pleased to
see is sitting in the front row row to
the lovely paper in the 1990s about this
that we what we should really be doing
is thinking upfront about making sure
our programs are total rather than you
know anything else so so if we all get
used to this if we all get into the
habit of checking our program for total
and I can change the default to make it
really thought this is an error so you
can ignore that back in you can have
this be an error so so if I put a flag
on a function that says I want this
function to be total then then I can
make it an error and I would actually
advocate if you're if you are doing some
programming in a dress so you could you
can make this a default by putting a
pragma at the top of the file it really
is a good way of catching mistakes in
your thinking so if you write a function
where the Machine doesn't believe it's
total you should think twice now you
might be right because obviously we
can't that there is no solution to the
halting problem so the Machine can't
decide for certain the machine might be
wrong why you'll notice it's when you
see the error shortly
it says possibly not total cuz it's ER
it's not necessarily convinced but today
you might you you can you can give it
extra evidence and you can even assert
it if you think you know better than the
machine but it's it's it's generally a
sign that you should rethink your
definition and you might have
accidentally introduced some infinite
loop somewhere so just a really drive my
totality cares I've got I've got I care
about totality like really important
I've got
a type here a function where I'm going
to try to implement I'm going to try to
produce a value in the empty type so
void is the empty type if I can produce
if I can write a function of type void
and if address thinks it's total then we
found a bug in address this is this is
the rules because I mean what kind of
thing if you know if you know something
void if you know if you have a proof of
the empty type you can basically do
anything from that point so how I'm just
to just to show how you might go about
making one of these things and get it
get it written but having drift some
allow it you could say something like
well let's let's do it let's just do it
this way so if I say you know empty
equals empty so just some kind of
meaningless statement there you know the
thing the thing is the thing that I
claim it's empty it says empty is
possibly not total because it's aware
that this trying to solve the halting
problem here so you know it's just some
kind of empty statement where a thing
equals the thing we're not going to make
any progress on that one I mean it's
kind of like you know some kind of
meaningless empty statement like that
and it's so if I say I try to claim its
total then it says well we're exit is
possibly not total so we kinda need that
already right so let's move on
so that's termination alienated the
other half of the audience then that's
oh that's a termination
what about productivity because we're
going to need productivity before we get
on to this this this communication so
what if we try counting from the
building a stream of numbers counting
from some number upwards so let's try to
add a definition and okay so if I'm
trying to count from K then I can I'm
I'll stick a K on the front of the
stream and then I will make more stream
so this is a so this is this is building
a stream rather than consuming a stream
so it productive we have a we have a K
that would
moving on to the front so I'll just keep
making these while while I want them so
let's try reloading that and oh it's
broken brexit broken everything let's
yeah let's just not do that you know
woke up this morning and I told myself I
was not going to do that gag oh it's
absolutely not going to do that gag so
good job I listened to myself right so
we can reload it now and then we can't
yes we can
so we've got count from if I try running
count from 10 then it will say so this
is this is the interesting thing that's
happened rather than producing an
infinite stream it produced a thing and
then it says well when when you ask me
for it but not yet I will start counting
for 11 so this this delay says that you
know I oh I want to produce more of the
stream but I've already produced the
finite prefix and that's all you've
asked me for so I'll produce more later
on and how do i how do I get more of
that stream is the question this is the
crucial question for certainly when
you're running interactive programs and
the answer is I have to provide some
some kind of some kind of fuel to drive
this computation is this your analogy
comment of the fuel driven thing I think
I think I think honor is the one to
thank for calling this fuel driven so
we're trying to we're trying to produce
some we're trying to work through this
stream and get some things out to the
stream so we have to provide some fuel
that allows us to generate these things
so the fuel that comes in the form of a
natural number so I'm trying to get the
first K things out of a stream then well
what are what are the first zero things
in a stream it's an empty list and what
are the first successor of K things in
the stream well it's the first value and
then the first K things in the rest of
the street so that's we like that and if
I now try saying let's Nesta take the
first five things profit stream where we
came from ten and this time it's it's
because I've asked for them because I
provided the fuel then that delay has
been four
we've got more stuff so what I haven't
shown you is whether that's total and it
is total the reason it's total is
because we're producing a finite nonzero
prefix of the stream so addresses happy
to do this because it knows because it's
producing because it's guaranteed to
produce that prefix in all cases it
knows that when that fuel eventually
does show up it will be able to make
progress okay so what does this all have
to do with concurrency and interaction
well waitress checks for so just just a
just a hammer at home if this is
checking coverage so we saw that with
zip with I took out the empty list cater
than it said no checking for termination
so this is again in the zip with case
the recursive call was on the smaller
thing and in the empty type case it was
something that didn't have a decreasing
argument and it checks it also checks
whether something is productive so if if
these coverage and either termination or
productivity holds then you have a total
function so what I'd like to do I'll do
the commercial breaks so this this is
the reason I do this is there is there
is a discount code for this conference
valid valid only during this conference
I believe so you can get 39 percent off
this thing and and it is it is going
into production next week by five which
basically means the desktop publishers
get their hands on it so you can you can
have it sue so just to put that up now
to get you thinking you know all of this
stuff I'm presenting it's it's facing in
here so right so what about interactive
programs like Haskell so if you know
Haskell you love written programs with
IO so just like Haskell Idris works with
an i/o type and I like to think of IO as
being a description of interactive
programs well to be honest the reason I
like to think of it that way because
that's just what it is
io io is a type which describes
interactions the only way we can have
those interactions happen run is is by
having a runtime system get it and on it
so the runtime system will will take
this description of actions and it will
you know actually do stuff talking to
the operating system
so simple example here the yellow
example what's your name put the name of
read the name print the name so when we
execute that when we tell it run type
doesn't execute that that's what will
happen trouble is interactive programs
usually run if not forever at least
either might you might have some kind of
loop so here's a here's a loopy
interactive program that does the same
thing but then it does it over and over
again so this is an interactive program
that we want to run indefinitely and it
doesn't unfortunately satisfy any of
those conditions that I thought about
the toy doesn't it doesn't satisfy this
there's a decreasing argument condition
so an i/o is specifically the type of
terminating i/o actions so if I try to
do something non terminating then that's
not that's not that's not gonna be total
so I want to find a way of describing
interactive programs in in such a way
that we can get them past the totality
checker and the trick which I think
might be due to Peter Hancock possibly
is this a Hancock trick or is this a
Tomo trick I'm not sure kind of will
know so the trick is to describe your
interactive programs as it's not I call
it scheme it's not really a stream but
it's kind of in a sequence of
interactive actions so an interactive
program an infinite interactive program
it's a program with an action that
terminates so an interactive action
followed by given that result I will
tell you what more interactive infinite
actions you need to produce and then we
can give that do you know do notation by
you know that you'll notice that this
isn't particularly close to the
signature for you know binding in a
monad but we can we can give it due
notation by defining overloading this
function so if I try writing that's what
they're complaining this oh right yes
okay so if I try writing that program
try me there we are there's our in fiyo
type and then here is a here as a loopy
program in in in thio
and I will load that into Idris
to check for the loop here so it says it
says now Lu pious total the reason being
that we have we have a prefix we now
have a nonzero finite prefix of stuff to
do before we make the recursive call the
only unfortunate thing is we're going to
have difficulty running this so we're
going to have to explain to the Machine
how to get around to running this this
program so one simple way to do it would
be to define a run function so we we
have approach so just like with IO IO
programs when we execute them we're kind
of explaining to that the run time
system is getting hold of its program
and then doing stuff so we could do
something like so okay let's let's take
this interactive program and turn it
into IO the problem is that the thing
that runs it is gonna have to be partial
because there's going to be there's
going to be some recursion going on here
but I'm not entirely satisfied with that
because I want I want as few things as
possible to be partial so what we'll do
is we'll take this fuel analogy too far
and we'll we'll add will will will add a
fuel argument to our to our run function
so I could say right I'll provide some
fuel which is basically saying this is
how long I am when I am willing for this
infinite process to run for so I can do
run and I'm like a tank of 10 things and
so this is this is going to run for 10 I
owe actions which unfortunately is not
very long it's run out of fuel so the
final thing that we do is well you know
if only we if only we had some kind of
solar power you're some kind of
renewable energy to to keep this going
we could you know if we if we could
generate a number that was just big
enough for what we're going to need and
what what we do is we have this one one
partial function at the end called
forever which will generate fuel as we
need it so if I say run forever
yippee and then
I chose Fred Jim and Sheila as some
people might recognize this as homage to
the previous speaker Sophie Wilson Fred
Jim and Sheila were hardware Maps memory
locations on the BBC micro so so so yes
but I mean I can show who in Robert Mike
I don't him oh no I'm afraid I haven't
okay right so we get the general idea
that we we can now write interactive
programs to possibly run forever Idris
is convinced that that the Lupus total
it's happy that the run function is
total the only thing is we have to we
have to provide some kind of you know
constant fuel to the runtime system so
we do need we do need one bit of
partiality but it's just about the
runtime system and you always need a
runtime system there's there's nothing
there's nothing that's getting you out
you know even if your program is pure
you run a pure program at the repple
well you do see an answer there how do
you think you see an answer something
external is doing it so you have that
external thing of you know a bit of fuel
and then and then you're good to go
so just to finally bring this to the
communication because that's what I
promised so we've seen this so the
interest runtime system supports a kind
of message passing concurrency so so
inspired by Erlang and so there's
various things implemented on top of
this so so what I'll show you the simple
thing is we lived on top of this so it
this is I mean it's kind of if you've
types for concurrent programming is a
huge space so certainly going back to
Kohei Hondas work on session types in in
the 1990s and growing out of that so
there's a lot of work in this space what
I'm going to show you is is massively
simplified from that it's probably in
what it certainly is an instance of the
kind of thing you can do with second
time so what I want to show you is just
something that it's it's a way of
writing simple but remarkably common
patterns of concurrent programming by
putting a little bit more in the types
so what happens a process can spawn the
protest
a protest could make a channel and it
can make a channel either by connecting
to another process or listening for
connections from another protest once
you have the channel not to
bi-directional thing that you can send
messages back and forth on so the kind
of thing you might do would be would be
this you might have a process main and
main has no be spawned and adder and
what main will send a door a message
saying I want to add two numbers and
then add it will send a reply so you
might you might imagine a system that's
that's spawning a lot of concurrent
processes which are willing to respond
to messages on interfaces to be honest
it's exactly like object-oriented
programming sending messages to
something that responds to an interface
what's wrong with that so we've got some
messages being sent and messages coming
back in fact the name messages is it
sort of suggestive really an
object-oriented here so how will we go
about doing that well what I what I'd
like to be sure of is is when I send
that add the thing that comes back from
the adder process is going to be an
integer or than that in this case I
don't want it to send back just any old
rubbish that I wanted to send back just
a string I want it to send back
something of the right type but these
things are two separate processes and if
you have lots and lots of processes how
do you know that they're interacting in
the way that they're supposed to so as
well as talking about the the the types
that you send as arguments to functions
and the types that come back you also
have to think about what the protocol is
so not only what you send but when you
send it and this is something that types
and programming languages have not
typically been particularly good at
expressing it's it's it's but you see
the sort of thing all the time doing
things in the right order doing things
on resources at the right time so so you
know you if you're writing a network
server you you you you create a socket
you bind that software to an address you
listen for connections on that socket
but you've got to do these in the right
order and there's soft in a different
state it every time what's the type of a
socket though int well that's so but
it's in a different state at every point
so this is a kind of a thing that's
going on here it's we have we have a
process that's in a different state at
each point so somehow we want to be able
to encode that you think
so because I've only got a few minutes
left so I'll just show you the program
and possibly by showing you the program
I'd totally convinced you that you could
have written this program so I'll start
by defining an interface for the
concurrent communication so I've just
got one kind of request I can add two
numbers and from the request I'll write
a function which calculates the response
type to that request so these these
things together this request and
response structure says what is coming
back
based on the value that's being sent and
to define a server notice that a server
has to be total because there's no point
in there's no point in having a server
that runs forever if all it does while
it's running forever is it's just you
know nothing and there's no point in
having a server if that server is going
to crash at some point we want the
server to always respond to the messages
did it to get it so the thing has to be
total and it is a server loop and it has
to read it and it has to work using this
response interface so it has to do a
couple of things it has to while it's
running it has to accept some incoming
messages and once it's done it has to
loop if I miss out I've carefully set up
the types so if I don't do either of
these things I mean I can do other stuff
too you know I can I can I can stick in
a command saying or a message saying I'm
waiting so there's there's no there's no
requirement that that I I do exactly
these things but at some point during
this process I have to respond to a
message and then the client it's got a
reference to that server and it sends it
a message so the fact that the interface
is in the type and the fact that I've
encoded the the protocol in the type
means that if I get this wrong my
programs not gonna type check so then
I've I've encoded that communication
pattern in the types it sent to me and
where does totality come into this well
this is this adder program it's it's
it's an infinite sequence of actions
it's gonna this event affected is going
to go on forever but it is always going
to do something before before it moves
on
so let's let's just load that I have to
turn the color off because the contrast
isn't great okay so let's yet so what
know that I've tried the main program as
well so what the main program does is it
spawns the adder by like this this
notation so it's forms an adder and and
if it succeeds it gives me a reference
to the server and this is if it fails so
this is a it's a pattern matching
binders you might have seen in Haskell
but this is this is the alternative
cases if I miss this alternative case
out it's not going to be total I haven't
dealt with the error so it's entirely
possible when I spawn a process that
that it fails and maybe our amount of
resources so I have to check that I'm
not gonna get past the totality check if
I don't check that and I really have no
business not checking that because
that's an error case that could make my
program not behave the way it's posted
okay so it's Ponzi adder and then it
just runs and then main has to be
partial because with using this forever
but we're keeping we're keeping that
forever as in a smaller box as we
possibly can so if I execute it then
it's not particularly exciting you see I
have a prompt and then eventually I'm
going to type in a number and it's going
to send the message and get a response I
just got this this in to show you that
it's that something is going on
concurrently so there we are 100 plus 90
494 so just to show what could possibly
go wrong here if I had that a server if
I've got a picture I just happened to
have a picture so I'll show you the
picture so what a server has to do in
order to be a valid server is it really
has to respond to a request and then it
really has to keep going forever so a
server lives in three states and if you
if you think back to the index nan as we
were looking at a learning about this
morning this is actually much simpler
because we're in complete control of the
changes here but we start in a state
where we haven't received any requests
when we respond to something I think I
call that access rather than respond so
when we accept something we move into a
stay
where we have now processed something so
once we process something that's fine we
can loop once we process something
because we've done something on this
iteration we can carry on responding to
more requests so we can we can keep
responding as long as we like but we're
only ever going to be complete this
program is only ever going to complete
if we do that final loop so the type of
the type of server loop is implementing
this state machine and we're making that
state machine explicit in the type so if
you start locking state machines are
literally everywhere and yet we don't
encode them in the types these are
things about our program that are
absolutely crucial think of the socket
example it's absolutely crucial to the
the operation of the program that you do
things in the right order and yet we
don't put them in the types why are the
things about our programs that we know
and we're telling each other but we
don't put them in the types so this sort
of thing you can draw it in just you
know three circles and a few arrows
let's try to put it in the type so what
happens if I do that wrong like so let's
say I don't bother looping it says type
mismatch between sent and complete that
means you're supposed to be in the
complete state but you're actually in
the sent state or if I if I don't bother
responding to a request and it says
mismatch between sent and no requests
well I can't lose I'm supposed to be in
also but yet I'm I'm in the I'm in the
no requests state I'm supposed to be in
the same state so this doesn't work
either so this actually comes back to a
point this morning about error messages
as well so I mean these error messages
the main problem of these error messages
is that they're long but you do see you
do see explicitly what the problem is
that there is a mismatch between the
state we're in and the state will want
to be in but the point kana made about
we don't have type error messages I
think is an important one because when I
wrote this program I didn't write this
program in one go I didn't just write
this out and hope that it would work I
did something a bit like this I I said
well
I've got most of the program and then
I've got a hole for the rest of the
program so it says this hole tells me
something really useful about the rest
of the program that I have to write it
says you are writing it so it's a it's
normalized to type this server loop is a
type synonym function so it says I'm
doing something that the protest is
something that that gives a response and
you're currently ordered that the
process is currently in the state sent
and somehow I have to get into the state
complete so by this time driven approach
of you know where have I got to where do
I have to go I'm not going to get that
kind of type area that I just showed you
because I followed this hole driven
approach of writing bits of the program
as necessary so just you know having at
home a bit more what happens if I don't
do the access well I'm now in no request
and I have to get to complete so the
types are telling me to stay transitions
that I have to do in order to make some
progress here right so and I guess yes
so I've got a well so I'll just show you
what the definition of process is and
well we're presenting without comment
and then I'll comment so so we've got
I've got a definition of the states that
a concurrent protest can be in and then
I've got the process type so the process
type says I have an interface the
operation has a result and then there's
an input state in an output state I
think that's perfectly reasonable things
put any type they're things they're
things that we know about this operation
so let's put it in the type and then the
the the operations that you'll see are
that you know I can I can send a message
to some server with a particular
interface as long as I'm using the right
interface so this is this is the return
type isn't going to be a response on
that interface and I can send things at
any point it doesn't matter what state
I'm in at the server because I'm not
doing any server activities
just anything or if i i i can accept
something provided that the the thing
I'm working with is in a state where it
hasn't received yet and that moves me
into the sent state so I can accept
something at any time the important
thing is when I accept it I move into
the sent state so I can loop that moves
me from the center state to the complete
state all of these operations it's it's
just like the types you'd see for any
kind of operation it's just that we've
got these additional two arguments of
the state we're currently in a mistake
where everything to so that particular
function or that particular type by the
way it went to I think about four or
five iterations before I hit this point
where where it was doing the right thing
so you know there's the question of
you've got to get the types right well
you've got the of them right but once
you have the type of right for some
library which you can then give out to
users you don't have to get it right
again people can then take the benefits
of this type that you've ER you've
you've sweated over okay
so I've talked about all of this so just
to finish off all of these ideas I'm
presenting we're invented by other
people and there are there are things
you can read about about these things so
what I would I would highly recommend
this one I'd listed them it in order of
something certainly I intend to put this
one first because I'm really the message
of this paper about a strong functional
programming is that writing total
functions should be the norm not the
exception and and I think this deserves
a lot more attention it's it's it's a
very accessible paper if you're familiar
with a functional programming language
so I highly recommend you take a look at
it and just say that a lot of people
have been thinking a lot more than I
have about writing interactive programs
using a dependently type language and
still getting the benefits of totality
and still getting the benefits of
reasoning about what those programs do
i've just you know taking some of these
ideas and try to implement them so these
these these papers i think are well
worth a lot if you're interested in in
where the ideas i'm talking about have
come from okay so I think I will stop
there
I will thank you very much for your
attention and we do have three minutes
for questions many questions but just
one yeah brilliant
so any all communication between your
different processes you didn't need to
use the infinite fuel of tank for that
one so my question yeah okay my question
is in in these active processes I don't
understand why you need the infinite
tank because you are producing an output
you are you are sending a response okay
oh I'll come talk to you afterwards
because I'm still confused in one of
your slides you showed an example of an
interactive waiting loop of sorts and
then you added a number a final number
into it and produced a sum um I think I
said the word waiting I think maybe it
was that one yes how did you get it to
go so slowly so the the first pause was
because it was compiling on the thing
the second pause in this accept is the
particular
implementation of access I'm using has a
deliberate 1 second block because
otherwise that would little works in a
particularly good demonstration so I
should have said that explicitly because
you're now probably thinking wow this is
incredibly slow I did put in a 1 second
clause deliberately yeah a real
concurrency library would allow you to
talk about these things would allow you
to say oh I want mr. block for a long
time I want me to just how far off do
you think interests or something similar
is from being practical for use in
industry rather than academia is it
ready now please say yes the runtime
system needs some work for this and
fantastic work being done by Stephen
Dolan on this malfunction system which
is basically taking the old camel
back-end and making it accessible to
other language influences so so it's
certainly hard to get my hands on that
at some point at which point we'll have
a good runtime system and I think
there's we need to do some work on
efficiency of the type checker so it
it's it's okay it's usable but it should
be a lot better so it's a question of
how willing you are to put up with those
two things there's a bit of engineering
work okay we
yeah okay we only have a five minute
break to get to the next session so here
we go so we can leave this up for three
minutes thank you again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>