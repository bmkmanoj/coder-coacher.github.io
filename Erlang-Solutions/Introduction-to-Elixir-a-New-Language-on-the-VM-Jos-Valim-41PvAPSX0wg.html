<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introduction to Elixir: a New Language on the VM - José Valim | Coder Coacher - Coaching Coders</title><meta content="Introduction to Elixir: a New Language on the VM - José Valim - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Introduction to Elixir: a New Language on the VM - José Valim</b></h2><h5 class="post__date">2013-04-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/41PvAPSX0wg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hello everyone as Robert said says
I'm going to talk about elixir which is
another language that runs on top of the
inverter machine and I've talked about
elixir at other conferences that usually
had a diverse audience people coming
from different technologies and the
first 10 to 15 minutes it was always
about how the Erlanger tone machine is a
great piece of software and why people
should be using it to solve some
specific kind of problems luckily today
I can skip those 10 to 15 minutes
because some of our are familiar the
ones that are not from me are going to
see plenty of great examples at the
conference so we can jump straight ahead
into a lecture and today I want to talk
about the language goals so what our
elixir goals we have trimming goals
the first one is productivity and how
can we make you more productive or allow
you to write tools that makes you more
productive the second one is
accessibility and it's more about how
elixir promotes code extensibility and
the third one is compatibility because
productivity and extensibility would not
be worth it if it meant sacrificing
compatibility with learning boot on
machine learning Burton machine is our
strongest asset so we need to remain
compatible and you need to be able to
use an inverter machine fully ok so
before we go into those goals
particularly let's have a very quick
introduction to Alex here so we have
topples they have the same syntax in
Erlang curly bruh curly brackets and we
have lists again they are square
brackets the same as our link is a list
with three elements and here we start to
see some differences so when you see a
double quoted string in Alex here it's
actually a binary when we say string and
Alex you remain a utf-8 encoded binary
our atoms start with column and our
modules they follow the camelcase
convention okay and here is a hello
world example in a lecture so we are
going to define the module hello we are
going to define the function
and when called assumption it's going to
bring something it's classic Hollow Road
and at the end we are calling hello dot
world you're calling this function which
is going to print something okay so with
this we are going to be able to to go
through most of the talk the examples in
the talk okay so let's start about let's
start talking about productivity okay
all those goals there is not one
particular thing that makes it possible
it's usually a set of different things
and about productivity we are going to
talk about two of them and the first
thing is that in Aleks everything is an
expression and it allows us to do very
interesting things that I want to to
show you so before I'm going to a
lecture let's talk a little bit about
earning so here's an earning module
called hello which the function wrote in
it and it's going is doing the exactly
the same thing as the Aleks our module
was doing and the thing is we cannot do
this learning we cannot print something
while the mod is being compiled okay and
this is because the module in Erlang
it's it's a special place it's you can
only put attributes
function definitions and a couple other
stuff but it cannot put any code that
you want in there okay in annex C
however everything is an expression so
we don't have this differentiation so
when you are defining the module hello
if you want to print something that
that's that the modules being compiled
we can just put it in there and then
it's going to work so for you to have an
idea on how this would work if we
compile this file you can see that when
the file is being compiled we can see
that prints the message compiling
however when you execute the code the
seclusion of the code stays the same
okay so that message is only going to
show when the mod is being defined and
the magis being compiled and okay all
right this doesn't help us much who
wants to print compiling when they are
defining their code but again because we
don't make this distinction because
everything is an expression Alex here we
can do a bunch of interesting stuff so
the first one I want to talk about the
first example is to do compilation time
work so there are some times where you
have an RV to see many examples
throughout this talk actually that you
could be doing something at completion
time instead of doing at runtime and
this allows you to use this feature
easily so let's let's consider this exam
this example lets us see we have a
binary two integer function you have a
library and this library has a binary
two integer function where you receive a
binary and needs to return an integer
from it and earning the it has a bunch
of Beauty internal functions that allows
you to convert a binary to a list and
then a list to an integer but it doesn't
have a binary to integer yet okay so
here we are implementing this in Aleks
and this example is using the pipeline
operator which is very useful for those
cases when you have a value and you need
to pass it for a bunch of steps alright
so here we have a binary we are
converting the binary to a list and then
from a list to an integer and let's
suppose everything is working fine okay
and then the next air link release comes
out early are 17 and they have a binary
to integer function there which is a
booty internal function and it's going
to work better and faster than this so
what you want in this case that you know
you want everyone using the newer linked
versions to use the new binary integer
function but you still want to support
everyone still running on the previous
or linked versions so you could do this
check at run time so every time you call
this function you could check
hey this air link has this function or
not and decide on it but in Aleks see
when we are compiling the code we know
what is our target so you could just do
the check at compilation time and then
we check so does it happen that the air
link module exports the binary to
integer function if it happens so our we
can define the function here that is
simply going to delegate to our link and
if it does not we have our the foramen
tation we are using so far so this is a
very simple example of taking something
you could be doing at run time but we
are doing at compilation time and the
nice thing about this is that it's not a
special dry
David's not a special macro special
template the code that we use to define
the if/else clause and to check if the
routine kernel function is defined is
regular code is as regular as any other
al'akir code okay so this is an example
completion time work and you're going to
see more how we can do more completion
time work soon so the other example that
we can have because everything is an
expression is that we can define modules
on console and so here we just got that
hello Road module I defined previously
and I define it on console and it's very
useful when you're just trying stuff
around and you need to try a new library
and need to pass a module to it or
something like this and you can see here
that I'm defining the modules usual but
at the end of the module I'm doing
operation one plus two okay and the
reason I'm doing this is because
everything is an expression and if
everything is an expression it means
that they need to return something so
when I call that module that module
needs to return something to me
okay and what def module is going to
return is a tuple with four elements the
first element is just the arrow module
the second one is the module name the
third one is the module byte code is a
binary representing the module byte code
and the fourth one is the result of the
last expression is securing the module
body which in this case was one plus two
so we got three back and I have a very
nice story about this because as you can
see here we we get the module byte code
there's a binary so when I'm giving this
talk this talk sorry
at other conference what I do is that I
start to Erlang shells 20 clear shells
and then I define the module hello in
one of them and then I get this binary
and load into the other shell and show
that the code is there and everyone is
always impressed so it's a very nice
example and how you can use modules on
console okay and the third thing I want
to talk about the fact everything's
expression is that we have easier
scripts and Alex theory so when I define
that hello
in annex it could even be smaller
because you could actually define a fire
put in a file just a yellow dot puts
hello road and then we could execute it
and it's going to print color also this
line would be our is my last hollow road
example and notice here that we don't
have a special script mode ok is
everything the expressions still the
same kind of code you would write
anywhere else some of you may have
noticed for that we are using the exs
extension so in Alex when you define a
file it would have the dot exe extension
but in this case we put an S at the end
to mean it's the scripting but it's just
to review intention you just say you
know this file is not meant to be
compiled I just want run to run it as a
script but there's a queuing code this
equation model is still the same ok so
that's it so this is the first thing
everything is the expression we can do
more work at compilation time we can
write scriptures easier and we there is
more you can do with it but before I
talk about it we need to talk about
macros which is the first the second
feature regarding productivity and
macros engine is an interesting subject
because we have other language that run
under the inverter machine like Lisp
flavored airline and JAXA and they have
macros as well in the in the case they
are list implementations and there is a
very interesting quote from rich Hickey
which is the guy who created closure
that he says least traditionally empower
developers because it can eliminate
anything that steals from macros and
that the power and that power is really
what people keep going back for okay so
in Lisp
if you want to add two numbers you would
write it like this right to open
parentheses plus 1 to close parentheses
and then if you ask how is this code
represented internally this is the
answer right in this when you have what
is what you see is what you get so when
you write this code is exactly
in tournament presentation in LX here we
have an extra step okay but we try to
keep the representation very simple and
straight far too so in annex you're
going to see one plus two the way this
is representing internally it's the top
or with three elements the first one is
the function name which in this case is
the atom plus the second one is a slot
for metadata and the third one is the
least with the argument so in this case
the arguments are one and two but
important thing here is since we have
this intermediary representation we have
this is lots for metadata and this is
lot as extremely important because in
this is a lot that we can put
information about line numbers so when
you get an exception we can tell you
exactly which line you got the exception
and show you properly right in this very
common for you to have macros that are
generating code from different files or
calling a macro that's another file that
generates code into your file and then
we can put the file that where the code
come from in the metadata which is very
useful when something bad happens are we
need to debug the code okay and so we
have this intermediate representation
and that's how everything works in a
lecture so if you have we take the
function is Adam because we're to check
if something is an Adam it would
represent B represent internal in the
same way to be a turbo which three
elements the first elements the function
name is Adam the second one is a slot
for metadata and the third one is the
list with arguments in this case have
one argument which is the Adam foo ok so
now that we have this representation we
can do a lot of interesting stuff so
here is a very canonical example of
macros you find a different language so
here we are defining and unless macro
that does the opposite of it so unless
this is true do exit ok and this is not
a keyword in Alex here it's just a macro
just regular code and the reason it
works is because unless it's not a
function it is a macro so when the same
last true do exit it's not going to
receive the evaluation of true it's not
going to receive the evaluation of exit
it's going to receive the representation
of true the representation of access and
then
we can transform this representation
into an eight okay
so it is what they say rights trading
code as data so he can get the code and
we can manipulate it transform into
other stuff okay and now that I talked
about everything the expression and I
talked about macarons we come to the
joist part which is domain-specific
languages okay so it's very easy to
write domain-specific language in a
lecture so we can try to be more
expressive in some specific domains in
because we have the Erlang virtual
machine available we can do a lot of
interesting stuff regarding performance
too and they want to give two examples
now the first one is regarding web
service so we have a bunch of excellent
web servers in your language on machine
and if we take most of the web servers
when you want to do something based in a
route the way you would do it is that
you would define a module and this
module is going to have the function
handle and then they're going to pattern
match on the function handle so in this
case would have something like this so I
have a request if the request is a get
request and the request contain the path
is lash post slash something where this
something is the ID I'm going to do
something which the request okay so and
you would define a bunch of those
function clauses for all your different
routes in a lecture we would be able to
write exactly this like this right so we
define again the handle function Clause
we are matching on the get request and
then if the path is / po / something
where surf is the port ID we can do
central the request excellent
but in annex C if we want it we could
write a very small DSL just to remove
some some of the noise here and then we
could have something like this so I'm
get post / call on ID and request and
then I would do something with it
okay it's it's exactly the equipment
exactly the same thing and if you go to
other language like Ruby Python ojs they
have web frameworks that people are
using that they provide a very similar
kind of expressiveness right so you can
call get and pass a callback function
and pass the route that you want to
match but here so this is very nice
because we are achieving a very similar
expressiveness to those other languages
but here is very interesting because we
can use darling little machine power so
what we can do is that we made you have
a file with a bunch of routes what you
want to do is that you want to get all
those routes and is to compile them to
air link function clauses okay because
if you do that the only virtual machine
is best part matching so when it sees a
bunch of those function clauses their
language on machine is going to optimize
that it's going to come up with the
fastest routing algorithm possible okay
so what I did on the other hand those
other frameworks they have a very naive
approach when you have a bunch of routes
they go checking one route one by one
hey does it happen to match this route
no it doesn't so let me check the other
one so what I did is that I need a
benchmark okay so here you can see three
curves the first one in blue is Alex and
it's a dynamic web framework that we
have in Alexi to try out these ideas the
second one green is the matter in Ruby
and the third one is expression ojs and
what I did here is that I define an
application with one route and I
measured the average time this average
time is our base time so we've one
routes everything on there 100% okay and
then one it is that I added ten routes
on top of this world route okay and then
here you can see that those other
frameworks they are starting to spend a
lot of time on just matching the route
just to figure out on what they have to
dispatch you and when we add a hundred
routes you can see that things become
really bad so Sinatra is spending thirty
five percent of its time just trying to
match the roused expressive spending
about fifteen fifteen percent just
trying to match the route but in Alex
here with you know it's like one percent
maybe because again we and it's the
simplest implementation of all because
we are just delegating everything to
their language on machine and we say
like do what you know how to do best
right optimize this thing for us so this
is a very nice example we have very
great performance
and very great expressiveness the other
example I want to give is about testing
okay so here's how you define a test
case and Alex here so we are going to
define a module math test and then it's
they're going to say that it is a test
case and here you're using two macarons
the first one is the test macro that
allows you to define a test in this
format and the second one is the assert
macro okay the test macro is very simple
so pay attention to those three lines
all the test macro does is to convert
this to convert this definition to an
actual function okay so it's basically
transforming that into this function and
notice that it automatically adds an
okay at the end okay and why does it do
that because our line has two
optimizations so if in the last line of
our test you are actually calling your
library and never happened that would be
to optimize it and then you would not
know why our test is failing okay so we
automatically automatically as an okay
at the end it's just a very small
convenience but the real deal here here
is they assert macro a certain is the my
favorite macro in the whole Alex your
code base why because depending on the
test framework we are using and
depending on the language you need to be
aware of a bunch of functions to write
our tests need to be aware of assert
equal assert match assert this number is
more than this other number or such that
this number is more than or something
like that but in Aleks you don't need to
do that you don't need to be explicit
your test framework what we are doing
because the assert macro is going to
look at your code and it's going to say
hey look I know what you're trying to do
I know that you are trying to compare
two numbers you don't need to tell me
explicitly just write the code as you
would write in general and I'm going to
figure it out and just so have an idea
there are certain plantations actually
very straightforward because of pattern
matching here we would be checking like
you know am I trying to use the match
operator no it's not the match operator
in this case am i trying to compare two
things wait yes I'm trying to compare
two things so it would match on this
clause and then we are going to define
the code properly okay and just so have
an idea on
how it works this is a test failure in
analogy using a testing framework you
can see that we didn't we did not need
to be explicit it's telling us exactly
what happened and say you know I
expected one to be equal to
it went there and looking our code
exactly what we're trying to do with it
and you know it can figure out exactly
you know and it failed at the assertion
happening exactly at this line and this
is a very good example of writing tools
that make us to more productive because
if we can look at our test output and
figure out how to fix it and how to
react next it's very powerful
productivity okay so now I'm done with
the first goal which is productivity so
let's talk about accessibility and there
are many ways such an accessibility and
many different problems and today I want
to talk about one problem in particular
which is the expression problem okay so
the other to show the expression problem
let's consider this small table so here
as rows we have data types and objects
okay depending on the language and then
as columns we have new functions if we
go to all language they typically make
it very easy to add a new row so you
know if you if you want to add a new
link at least implementation or specific
list implementation you would just
create a new class and you would
implement those functions for our class
they would call methods but it will
implement those and it would be fine
however in all
typically it's hard to add a new column
why because if you take a language like
Java you cannot open up the list class
and define a new method in there right
so it's it's hard to to add a new column
in there to extend in this direction
functional programming it's a little bit
different it's very easy to add a new
function you're going to go there you're
going to define a new function and all
the types it can handle and import it
into your code and it's going to be fine
but on the opposite it's hard to add a
neuro because it's hard for you to open
up the add function and make it aware of
a new data type to come up with okay so
and why is this reason it's because we
write code like this so here's an
example in Erlang it could have been
written Aleks in the same way and what
is happening here is that we define a
module JSON and this module needs to
convert a specific item to its JSON
representation so the way we do this
that would say you know the two jazel
implementation for lists is this the two
J's implementation for binaries is this
other thing right and that's how we
would write it and then at the end that
we wrote this code we push it to github
right we'll start using it but imagine
that when you start using it you have a
new data type who haven't thought about
like a set right you cannot extend this
code right you need to fork the project
or you need to go in the source and make
it aware of your data type like going
straight to the source so there are many
solutions to this problem and the
solution we have in a lecture is called
protocols and the reason different
languages are going to call protocols
implementations similar to protocols
different things but the reason I
decided to call them protocols is
because that's how closure calls them
and closure is a dynamic language as an
allegory so it's in pit then if I had
come up with a name that I static
language is using okay so we call them
protocols and the way protocols work is
very very simple the first thing we do
is that we define a protocol okay so we
are going to define a JSON protocol and
then we're going to say you know if
someone wants implement the protocol
what functions does it need to implement
and the function here is just the true
JSON function and then we would call
this protocol as any other code so Jason
- Jason and we pass the item we want to
convert and it's going to dispatch for
us okay so we define a protocol and what
we can do is that when define this
protocol we could go ahead and implement
this protocol for all the built-in data
types in the language so we could go and
say you know the implementation of the
JSON protocol for lists is this thing
the implementation of the
protocol for binaries is this thing so
we define all the implementations and
then you're using this code right and
then see you someone wrote this code and
then you're using someone else code and
then you have your own data type like a
set or a red-black tree all you need to
do is implement the protocol for our
type so you can extend the code right
you can just go ahead and this and make
it aware of your own types without
having to open up the project source
code without having to fork it okay so
you know it's easy to add new columns
because you can just define new
protocols and easy to add new rules
because it just implements the defined
protocols so we have protocols and I
want to show you two examples of using
protocols in Aleks here
so the first one is there in a row API
so when you want to manipulate lists in
a lecture you're going to use the inner
module and then I'm going to find
everything you can also find knurling
like map all take drop split partition
all those things are there right and
it's going to work with lists fine but
then I think that enum is a protocol and
the anon module can iterate any data
structure as long as it implements the
nan protocol so here is a similar
example of using the anon with ranges
okay it's going to work just fine so if
you have a dictionary you can anyone to
iterate the dictionary you want to find
an item you're going to use do you know
module okay because it's just it's just
going to work it can work with the
majority of data types and then we have
like a bunch of powerful abstractions on
top of it so let's suppose you have a
web server and you need to parse the
query parameters you can parse the query
parameters using the anon module all you
need from the web server is a way to
iterate the parameters as they come raw
and then we create very nice
abstractions on top of it the second
example about protocols is the inspect
API and it's one of my favorite examples
for protocols because well I would say
so if we go to our link and we create a
dictionary from from
least it's going to print all the
dictionary internals even though this is
opaque right they're not supposed to
fiddle or relying this structure in any
way inadequacy if you create a
dictionary you get this pretty pretty
representation right we call this
inspect so here's the thing we want and
this is nice because when you have a lot
of code or a lot of massive data
structures it's just printing the
information it's not printing a lot of
stuff that you don't need and you can
easily look at it but here's the thing
each data type they know what is the
best way to pretty preet themselves they
know what is the best way to show the
information they contained so this is a
very good example for protocols because
all those what hash Dix is doing its
sticky Alex you know when you eventually
have to print me here's how you should
print myself and then it goes and
implements the protocol and it's very
nice because when you're working with
your code you're writing your your
services you're going to have a compact
representation but if it happens that
you are doing a patch for hash dict
and you want to actually get the
internal representation you can get it
too so I get we get the best of both
worlds
okay so this one I had to talk about
protocols and extensibility it's about
having ways to extend the code and we
are going for the last one which is
compatibility okay so as I said the
strongest asset for Alex here is their
language on machine and those what we're
talking about would not be worth it if
it meant sacrificing compatibility with
an inverter machine so people for a long
time they you know they are building
when they come to are like they say know
what I'm doing air links that I am
building distributed for third
applications we've hot code swapping and
a bunch of other stuff like they are a
boost and we want people to be able to
build the same kind of applications with
Alex ok and we have good examples
already popping out so right after this
talk Yuri is going to be talking about
be normal on the database track
and it has components built in early and
the components built in Alex Siri so if
you're interested go watch his talk and
feel free to asking questions I think
and and the reason we can do that people
they can build the same kind of
applications or we've Alex here is
because there is no conversion cost at
all for calling air link from Alex your
visa versa at opal in elixir is at open
air link a list in Erlang is a listen
Alex here in fact we want to promote
that we want to promote a healthcare in
rate so for example Alec the standard
library is meant to be compact enough to
showcase Alex's features it's not our
goal to replace our link standard
libraries not our goal to replace OTP in
fact if you're building applications in
Alex here you are going to use the same
modules that you would use in our link
you would use the application module
region server module the supervisor
module and you're just relying on what
OTP provides us but as I have seen on
this talk there are some cases that we
can offer a bit more and then in those
cases we provide conveniences in Alex's
so we've talked about a dino module so
in Alex here if you need to work with
lists you're not going to use the list
module we are going to use the enum
module because the new module can work
with different data types so you can
have you just need to worry about a
smaller API in your mind right you're
not going to use this string module
because a string in alex is a utaite 8
encoded binary so a string marjorine
elixir it actually knows about utf-8 and
it goes according to the Unicode
standard so you have a bunch of any
coded related functions to do title case
down case of the keys and stuff and
another example that when you come to
Alex here you're not going to use addict
or an object are going to use hash dict
because our dictionary can expand based
on the amount of items so they need to
think oh I have just a few items I
should use our text or if I have a bunch
of items I should use thick just go with
hash Nick and it's going to expand as
needed okay so just to expand a little
more on this
so they string module in Alex here it's
it goes according to Dennett code
standard according to the
database and it provides a bunch of
basic primitives talking at code points
graphemes and whatnot it provides all
the basic operations links capitalized
down keys up case and the nice thing
about this is that this module is a very
good example of doing compilation time
work compiled time work right because
what we do at the moment we are
compiling the module what we do is that
when the modules been defined we go and
we open up the only code database we
open up the database and we transform
the database into Airlink function
clauses right so the end result is that
the source code is 200 lines of code but
the beam file generated is 200 Calabar
kilobytes mean file but it's reasonably
fast because we are we're just compiling
to air link and there are no bottlenecks
other solutions what they do is that
they start the data in a ets table right
and then every time you are doing an
operation you are going to ets and be a
bunch of queries in ets other solutions
they load up the database when you first
use it so you need to wait two seconds
just to load up the unicode information
but you know we're doing compilation
time work so we get reasonably fast and
no bottlenecks more so other things that
addicts do offer that we go the extra
step is scripting you briefly briefly
say that so there is no special mode we
simply use the dot access files right
and we have two models modules that are
meant to help with scripting
the first one is path where you can do a
bunch of file system paths related
operations spans plate base name and the
second one is file which contains the
very basic file operations you need but
also a bunch of high-level conveniences
like copy this file from the students
copy those directories recursively and
whatnot and when it comes to scripting
we have a very we have a convention that
I like very much and I would like to
tell you about it which is auto restore
efforts so some time ago a friend he was
telling me his first experience in using
react right so what he did that he went
there he
download the airline he stopped he
stalled ryuk then every time he was
trying to run ryuk he got a bad match he
was trying to run ragged and bad match
alright that's all he got and then it
was his first time using earnings in
starting earning so he was not exactly
sure how he was meant to proceed at the
time we didn't have lying the stack
traces but you know it slowly he was
able to figure his way out and then he
figure out that what was happen is that
Reich was trying to create a file
somewhere but he could not create this
file so where Reich was expecting and no
que tipo it was getting a narrow topple
and at the end this was resulting in a
bad match ok so this is great the the
fact that when you call file dot rainin
are linked or file dot open the fact
that it returns the topo and you can
work with this topo it's great because
we don't want to be using exceptions for
flow control but there are some cases
like in rare case or when you are doing
scripting that you need to open that
file you need to do that operation if
that operation does not work it's game
over right and then there are scripts
it's a very common scenario or sometimes
when you are booting up this is very
common so what electri has that it has a
convention that if the if the function
name ends with bang it means that if we
cannot do that we are going to fail but
fail with many meaningful message we are
going to fail elegantly we're going to
say you know you tried you pass me this
file or I try to read this file it / Oh
No but I could I could not find it
right so it's very useful for those
cases and the last thing I want to talk
about that we also have an elective it's
an early application called mix and mix
is very similar in terms of of what we
want to achieve with free bar so if you
go to Alex here
you saw it and then you type mix new
your project name is going to create a
project for you so it handles project
generated it it manages your
dependencies so if you want to if you
need to depend on a git repository it's
to the load repo story for you and
compile it and a bunch of useful tasks
like project completion running tasks
and whatnot
okay so I hope you enjoyed the talk if
you go to our website we have our
getting started at the top that's going
to give you a walkthrough who electors
syntax and its main Aleksey features if
we just want to read some an exit code
we also have a crash course for link
developers so it's going to compare them
more directly and I hope you come to
join our community because we are
recently seeing up a bunch of
interesting projects popping out so I've
talked about you know Moe that URI is
going to be talking about but I want to
show some other examples so we have this
project called kouchi which is a very
simple API to to talk with Couchbase 2.0
servers so we also have this other
project called tire access which is a
DSL to interact with elasticsearch and
those guys the data hubs guys they they
emailed me yesterday to let me know
about this project but I really like a
project they they have written before
this one which was called couch
normalizer
one of their clients they needed to move
a bunch of data in couch to be from one
place in the other and you know if they
were going to do that through the HTTP
API it's going to take a lot of time so
what they did is that they wrote a DSL
for this data migration in Alex here and
since it's Alex here it's going to
compile to a beam file and then they
were able to load that being file into
CouchDB so the end result is they were
able to do everything much much faster
and I think it's a very great example of
using Alex Erie for doing performance or
higher operations so it was very
interesting and the last example I want
to show is so when some people they they
see Alex here and they realize how they
can do it with the macros and the deer
cells they try to explore they say no
I've been writing this code like this
for some time
maybe I could write it differently so
sometimes I see very interesting
projects where people they are just
playing with the idea of how I could do
everything I do every day differently
right is that mean like how can
eliminate something that at this point I
consider tedious to do myself okay so
that was it I was faster than expected
so I think we have some good time for
questions and so we are Alex here thank
you so the compiler target right now is
darling abstract format and the reason
we are still going if their language
tact format is because it's the highest
level in the compilation stack so we go
through all the optimizations warnings
and whatnot and that we can work with
dialyzer and the other tools so
eventually if we want to move because
our going to stay very close to the
Erlang virtual machine we still have not
seen like a reason to move to Carling or
some other part of the stack but if I
eventually want to do that and then we
will see it and you try to talk we've
every one OTP how we can also improve
the other tools to work on core at the
core level okay
I am Not sure I so okay so the question
is if you can do multiple dispatch and I
clearly not yet
so the protocol is going to dispatch
based on the first argument and that's
how it works we don't support operator
overloading in general and we still
don't have a mechanism for doing
multiple dispatch because this isn't an
issue I've found myself in yet
but we have a bunch of good examples
from other communities and I'm sure that
we can try some approaches out and try
to come up with a good solution for the
problem so yeah so you're still going to
get an in clashes because the protocols
the the protocols modules there are
regular modules so if you have two
different developers defining the same
protocol you're going to get a clash and
the air link is going to see just one of
them so luckily release the tools
they're going to warn you about things
like that but you definitely get named
clashes on the protocol name but you can
ask the names if you need to inside our
library so well I think we didn't have
an example but in annex here you can
Nast name so you can have a module
called hello dot Road and that that
would be the module name so that that
helps a bit of the problem okay
yeah yeah I I can yep so I let me try
let me see if I can be fast on this and
set up my terminal okay
that was is enough so not a good time so
can everyone see it okay so you know
here I'm going to call the lists module
flatten and pass a list and that's how
you can call in a link module because in
Erlang if you think about a link code
when you write something like lists
flatten right what this is really
happening is that this is an atom and
this is an atom right so what were you
doing an X is the same thing but just
now that our atom syntax is different so
this is how you would call a knurling
module from Alex here yes so right now
the way you would call well I I would
have to go to let me see if I can do
this okay so one second that's if this
works so the way you would call an
airline module an electric module from
air link is that you would call Alex
here ideally he would call Alex a string
down case and then would pass a binary
that's if this works okay this is what
we would like to call it ideally but
yeah ideally because in previous our
link versions we had packages and we
could not have the syntax because of
packages we could not use the dot so
currently we are compiled - - right so
this is how I would call the marginal
but assume we are just waiting a little
bit more for
all the distributions to get our 16 out
and then since we haven't reached 1.0
yet it's a great opportunity for to say
you know you're just going to support
alex running on early r16 and then
you're going to have the dot which works
quite nicely in my opinion okay ya know
so the question is about writing OTP so
you you don't have to think about
anything special you're just going to
define the modules right a bear module
as you would in air link you just you
literally do a syntax translation and
you could get the same result right so
we have a different so this this is
running what I can try to do is that I
was talking about the mix thing right
that generates in projects what we could
do okay
is let generate a new project called my
project just so we have actually let me
throw this away
I'll define a new project and I'll pass
soap I think that's going to generate
supervisor structure so yeah okay so
here's what I was talking about it's
very easy for you to get started because
it's going to generate very bare-bones
project structure and then if you use
rip rebar you're going to see like a
rebar configuration file and in Aleks
here it looks like this right it's just
it's regular laser code and then here is
the context that would go into the dot
app file so here is define the dot app
file stuff and then we would you know
just compile it as usual well there's
nothing to well I'm their own territory
so let me run the tester its way to
compare it so here you can see it
compiled everything in compiled the
supervisor and it ran the tasks
and everything just just works because
the all our structures everything just
translates directly turning so it
generates the proper at file as you can
see here we have so talking about their
cells in your the final supervisor we
have a very simple DSL so you can define
a supervisor so define workers in town
supervisor this provides and supervise
children strategy which is this for when
you when you don't actually remember the
order of the items in the top oh so I'm
sorry uh yeah so these so the question
is there is a keyword argument name with
parameter syntax yes so these would be
exactly the equivalent of writing so
again the goal was to just have a easy
way to pass parameters and compatible
with our learning at the end so you can
just use it regularly okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>