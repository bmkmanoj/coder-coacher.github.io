<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory 2014 -- Keynote Catalyse Change | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory 2014 -- Keynote Catalyse Change - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory 2014 -- Keynote Catalyse Change</b></h2><h5 class="post__date">2014-03-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Djv4C9H9yz4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">um a couple months ago Garrett he came
to me and he is guard here or is he
having a hangover hangover okay okay so
he he he asked me and say like oh do you
want to speak at earning factory and
then he said to probably be interesting
if you talk about Alex period option
like you know where the adoption is
where do you think it's going to be in
two years and then I said well that's
going to be a very short talk because I
have an idea and however I do know
things that are not are not working well
like because users they are coming
they're trying to learn elixir they're
trying to learn earning they're going
they're trying to get familiar with the
vm and they are stumbling to issues
right so this talk is is about that
right about getting those things that
we've seen happening a couple times and
how we can ease the process and some of
those things they you know you already
did some progress in Alex Syria for
example others we are we planned to but
others have no idea right like what is
the best way to go forward so that's why
I think it's interesting because it's a
discussion we want to get start and
having everyone taking part in yeah cool
and just the public health warning part
here if part of this talk make you feel
a little bit angry then that's good
because that's kind of what we're aiming
for um so as Francesca says we have got
this incredibly great environment right
we can do things that nobody else can do
we've had it for at least 15 20 years
and despite that we're still a marginal
community we're not mainstream by any
means now I know a lot of people here
are very happy with that you know let's
keep the barbarians out
but the reality is that that's not a
long-term viable solution for any
community so one of what we would like
to do is to go through and actually have
a look at why we might have this problem
and to have a look at why well I get a
fair number of emails from people
because you know I sit there and I was I
was promoting Ruby for a long time I
still promote Ruby and Here I am
suddenly saying oh it licks is a good
idea in your land virtual machines good
here and so people email me about why
this should be so this is going to be
one of those never do this in a
presentation slides but I'm actually
going to read from a long email that I
actually received because I think it's
relevant the email goes I keep trying to
apply a lick sir and Earl and two
problems I have and I keep running up
against issues with a terrible state of
the ecosystem whatever the Erlang devs
are done up the last night how here is
it certainly wasn't focusing on being a
citizen of the modern Internet I killed
many many hours deciphering bad
documentation fighting bugs in XML but
by BATS going to first it didn't go too
fast the first time I did this give me a
second it's going to keep going
see I rehearsed this it worked uh-huh
all right let me yeah yeah blame the
intelligence the person reading it all
right I'm actually gonna try this again
because it is important all right
certainly wasn't focusing on being a
citizen of modern internet I have killed
many many hours deciphering bad
documentation and fighting bugs and XML
HTTP libraries over the past several
weeks most recently I thought I had an
idea we should be a perfect application
of elixir line then discovered its soul
I'm at client library as moraband and
considered unusable by the one person I
could find who has tried it now
obviously the library suck is a bad
argument against the language ruby was
in just as bad estate back in 2001 when
I came to it but there are compelling
reasons to want to change that situation
in the case of Ruby the reason was it's
a joy to code as I understand it the
compelling reason for Erlang is it has a
great vm for concurrent and distributed
development but here's where I run into
a problem five years ago that argument
made a ton of sense but now closure is a
thing and go is a thing Scala too for
that matter closure and scholar have the
full Java ecosystem behind them go can
call directly into c code so it has the
whole c c++ ecosystem none of them have
Erlang's of semantic works like ass
obsession with arity all of them have
actors CSP pi calculus concurrency
abstractions baked in just like Erlang
given all this it seems the sole reason
to invest into a lick sir over some of
these other languages is the fact that
the JVM is simply much better than a JVM
or the go runtime at this point my
intuition is screaming at me to ditch
the Erlang vm and focus on my concurrent
language energy on either closure or go
I keep worrying that I'll find my way to
the ecosystem issues only to find myself
with a bunch of code that runs on a vm
that isn't materially better than the
JVM and can't be instrumented and tuned
the JVM way this is not just one person
renting this is actually a very
well-known very smart person
in the Ruby community admit who actually
took the trouble to come and investigate
something else and they did it in depth
and then wrote me a long email asking
okay I want to like this but i'm having
trouble and I hear that a lot so what we
want to do is to reconcile these two
things the fact that we're sitting on
top of something which is great we have
this fantastic resource that we can use
and yet it's not perceived that way
people are not flocking to to adopt the
beam environment so a lot of you could
say well we don't care all right we're
happy all right why do we care if other
people like what we like because we've
got what we need it makes us you know it
gives us a competitive advantage using
right so this is not our problem it's
their problem but our take is different
we think that we we should care we think
it's actually important for us that we
get other people into this environment
that we inject fresh ideas fresh talent
and basically new bodies going forward
that way we'll get more people more
conferences more companies more
libraries more ideas more technology and
eventually if we are so damn good then
having more people using this will
actually make the whole world better so
I think we do care so I think it's a
given that we have the best vm info
doing the kinds of things that we're
talking about best language well I mean
you could argue that you know there's
some room for improvement wherever you
are in any language but we do have a
great language for for writing the kind
of applications we write so those aren't
the issues we don't have to sit there
rewrite Erlang will rewrite elixir or
rewrite the theme vm in order to get
people in instead I think francesco
touched on this what we need to do is to
look at the barriers to entry right now
it just costs too much to become a
member of this community now I've been
working with my son on his AP chemistry
projects so one of the things we've been
looking at is activation energy at this
point I wanted to do in demonstration
with a small can of gasoline and a
cigarette lighter but I wasn't allowed
to activation energy in chemistry is a
very I'm sure you all familiar with this
right so you have a system that is in
one state imagine you have like a can of
gasoline it's sitting there it's exposed
to oxygen you know potentially there's a
lot of energy held in that camp but that
energy is kind of like not used until I
give it a kick I could light it and if I
just put a small spark into it then it
can catch on fire and once it has that
initial kick of energy then it will
carry on it will its self sustaining but
it needs to get over that hump so what I
have to do is to kick some energy into
the system once the energy is in there
then it's stable at that new level until
it runs out of gas so how's that
relevant well I needed to find a way of
like demonstrating that to you all and
so I thought well yeah how can I what's
the prototypical user I can think of to
demonstrate this in in our context who
has like the most expressive facial
expressions I can imagine so here we
have the canno Reeves guide to adopting
early all right so initially people come
on hey this looks interesting a lot of
people are saying that nowadays airline
is not
a buzz to it elixir has a bit of a bug's
to it so people are coming along so huh
cool let me have a look and so they
start digging in and it's not as easy as
it might be and so they get there it's
here on Pete going and this is maybe
after a day two days possibly if they
have a spare time and then eventually
they get to this phase all right I'm
good I'm a programmer I know what I'm
doing I've got ten years experience and
yet this language is making me feel like
I'm a beginner again I don't like that
and guess what ah i'm really happy doing
what I was doing before all right and
they move on this one slide ladies and
gentlemen demonstrates why the matrix
was not written in Erlang had the matrix
been written in Erlang clearly Agent
Smith would have won so we need to lower
the barrier now back to my son's
chemistry one of the reasons you study
activation energy is because you study
the process of catalysis right a
catalyst reduces the energy required to
start a reaction sometimes to the point
where the reaction will start on its own
so we're looking for a catalyst that
will make it easier for people to come
into our community so what is the
catalyst in this sense you are we are
the catalyst is to do with how we helped
people adopt our arcane technology but
for this to work here's the problem
everybody in this room has gone through
that hump everybody in this room is
saying there's no problem look at me I'm
here right I'm using it very happily I
don't have these issues that you're
talking about you know you're crazy to
think that their issues so what I'd like
you to do is to try to forget that just
for a little bit all right I'd like you
not to be Erlang experts for a little
while I'd like you to put on your
outside our heads yeah I want you to go
back and pretend that you didn't know
this stuff maybe pretend you didn't have
that particular gene that let you get
over that hump easier than most people
let's go back to somebody maybe like me
who just says okay erlang I've heard a
lot about it I want to make 30 billion
dollars to so how do I go about doing
this oh I know so I'm going to go to
Google because you know I need to first
of all learn how to write this code and
I'm gonna like search for something like
create Erlang application oh cool right
Google is my friend so I click what do i
do i click on the first link right it's
the official site so it must be good so
I click on that link and I get to that
now remember that I have no idea what
this Erlang stuff is so I'm looking at
this ok so this chapter should be read
in conjunction with app for an
application three so okay I'm game so I
click on those but they're not
hyperlinks that's kind of unfortunate
and now i'm going to read to the rest of
this when we hear
written code implementing some specific
functionality we might want to make the
code into an application that as a
component that can be yeah all right
moving on so I hit the back button and I
say oh learn you some Erlang that must
be good right so I'm going to go and
click on that and wow that's way
prettier than the previous one this is
fantastic right mandatory thing I am not
locking this site I'm knocking google at
this point right but so I look at this
and the first thing I read is after
seeing our whole applications
supervision trees start um nope that's
not going to help me is it all right I
still want to learn how to write your
low-lying program but back button again
all right get down to this one Oh rebar
is an airline bill tool that makes it
easy to compile and test that's what I
want I want easy right so I go to that
page and sure enough easy that's just
what I want so I read the instructions i
am not a typical programmer i read the
instructions and I'd get this thing it's
trivial it actually works right i guide
you get clone it and I do what it says
type that and you just compile wow this
is easy i like this erlang stuff so now
i'm going to start building my first
application and again i go on the web
and I search for things I discovered how
to do something like this all right top
down rebar create app blah blah blah
fine okay I can do that a bit surprising
about the the syntax there it's a little
bit you know IBM 360 JC Elish but I mean
that's okay you know I can live with
that maybe retros whatever now I think
twice okay now it's going to my
application oh wait a minute hmm that's
not what I was expecting uh I'll go back
I'll read the source oh it's into source
okay that's a bit strange but i'll go
into source and oh damn I've just over
written half the source of rebar so I go
back and I read the instructions again I
go into a separate directory
and i copy my rebar in and that's cool i
created an empty app now i can pilot now
how do i run it I'd go back onto google
and google says that to run it I need to
type something like that right there's
lots and lots of various crap on how I
run it but this seems to be kind of like
the average of how I run it so I run it
and this pops out so i have three lines
of what's going on in terms of the
header then i have something that looks
like really really bad JSON and then and
then it a crash a crash dump wait a
minute I haven't even touched this code
and I got a crash dump from a beginner's
point of view I want you to think about
this process I wanted to write hello
world that's all I wanted to do is to
write hello world how far into this
process mi now two hours by the time I
messed around in Google discuss stuff
and I'm faced with this so my first
question why on God's earth do we
display error messages to the console as
Erlang terms who are we trying to
impress
what is the error even right I'm
imagining the error is in net
terminating in do boot I didn't do
anything called do boot right so this
early thing must have a bug in it that's
strange and it keeps going all right
where exactly is there it's really hard
to read all right this doesn't just
affect newcomers as I'll show you in a
minute but what we also don't get out of
this is any indication whatsoever about
what I should do next apart from
possibly just give up but I don't give
up well maybe I do maybe I'm down here
and I really really really want to learn
this airline thing and I've got a spare
morning maybe that's all I've got in my
busy day I got a spare morning so I do
all this business and I climb the curve
I put in my own energy right I'm being
made to feel stupid the whole time
because I don't understand what's going
on it's talking to me in terms I don't
understand and clearly that's my fault
because the airline community has a
reputation of being really smart people
they get it so it must be my fault I
don't so I'm going to get to this kind
of point and possibly if half a day is
my limit well I'm just going to give up
and go find something else right do we
care yes we care because we've just lost
a smart person
so what they was talking about like all
along so far it's about the mechanics
okay oh but in general thinking in
Erlang is hard to there was very very
recently there was a huge discussion in
the airline crash on mailing list and
one of the very few good things that
came out of it was an email from Fred
Hubbert where he he because he won't
learning summer laying right and then at
music he has good experience well like
people are stumbling with fun learning
and so on and then he go on and say like
you know there are a bunch of things
that users they are not familiar with
and they need to learn how to think in
this different way okay like better
matching recursion high order functions
anonymous functions may the non-muslims
going to get easier now that Java 7 has
who knows expressed based conditionals
doing pattern matching in case write
sing assignment immutability and the
lack of wiring for loops which goes back
to recursion and so on right not using
object you can order thinking objects
you need to think in data structures
okay and some of those things right it's
it's part of the process right you have
to you need to have the activation
energy to go over this stuff because
it's part of writing airline codes part
of writing Alex your code right those
things are very important to how write
code pattern matching recursion and so
on but not everything fits into that
least that it you know things we could
move the process of many things so one
thing I want to use as an example is
NASA daily structures ok so imagine the
following scenario right like so we can
take davidson arrow there is someone
that is trying to to go into Erlang and
get it to it and they were able to pass
through that initial process right and
let's suppose he's doing a prototype for
a game okay a game server and our game
application and part in part of the
application and which that's what he
decides to do his prototype is
is related to like you have rooms ok you
have users that are using application
and those users can go into room and
kind of exchange information between
them ok and when I'm in this room I can
be in the same room from different
devices ok so every time the user does
something broadcast start you on that
room and if I'm that room from my phone
and my computer I need to get this
message from those different devices so
I start working on this okay and so I
figure out I need to create a small
server that's going to keep that state
and then every time there's a message it
figures out quickly to whom that message
needs to go to okay that's that's the
goal right so I create so here I'm using
the new are linked map syntax so the the
server States basically going to be a
map of rooms okay and in that map I have
a room ID and the roommate is the key
and it points to a room right which is a
record and in this record we have a
little bit of information like
information about the room and part of
this information are the users in the
room okay and that's another map where
it has the user IDs key and the values
are the list of codes and those codes
identify the devices so I know to whom
the message needs to go to and so on if
we are using a mutable language okay I
would be able it's the user if I user
needs to join a room I would be able to
write this code okay I would be able to
do something like I'll be able to access
the whole path and then just mutate the
thing at the end by adding the new codes
and it works easy and simple aight but
you know we are we are innumerable
language right you're not giving we are
not giving up on that no way okay so we
need to do this differently ok and the
equivalent of doing this in airline
would be this so what was what a good
part of my career has been a one line of
code now has become 12 lines of code
right I need to do step by steps I need
to match on the map on the room ID right
and then I need to go and then you need
to destruct church part instruct the
first map which doings I didn't distract
the the record and struck the user I the
users map which you I finally get the
codes and can put everything together
and then I do everything back
okay at this point you may even stop to
think say well actually if something is
hard maybe it's because we don't have
the correct design right maybe instead I
should try to normalize my data and put
everything on ets okay or I should maybe
split into different processes and have
them have smaller states but even
answering this question is hard because
this is a problem right the we are
thinking in terms of the outsider right
this is a problem he never had his
entire life right never need to think
like wait how I'm going to model my data
so the updated nursery structures we're
going to work correctly okay and it
doesn't need to necessarily be hard okay
so i want to pinpoint very quickly two
solutions that exist in other languages
okay and this is not a problem to
airline right it's a problem in in
languages where things are immutable and
that's the majority of functional
programming languages and people are
going to run to this problem they are
running to this problem right so for
example i really like closure solution
to this which basically in this standard
library you have three functions called
getting which allows you to get some
value in a very in an acid data
structure you have a shocking which
allows you to put a value in there and
you have update in which traverse the
structure and calls a function so you
can update estate if we had those
functions for example okay would be able
to write this we don't need no longer
those top lines of code would say okay
my states the room here is I'm going to
traverse the this state right so I need
to get the room for their ID then I want
to get to the room users and then I want
to get to the user ID and when I get the
other ID I have the list of codes like
in just a cup date and it's really nice
right and those who are familiar with
closure feel like closure developers
fear that this is very close yer eyes
because it goes in the closure way of
being very pragmatic and have it's a
very simple solution and it works great
okay but there are other solutions for
example
Haskell lenses we're not going to go
into details right but also you learn
about Haskell lenses you see wait this
view very has college right it's like
that's exactly how would expect a
haskell programmer to solve the problem
the problem is very well defined and the
way they think about lens is is that you
could so they call it lenses because
it's like a camera lens it's a way you
look into the data structure and it can
access it and manipulate in different
ways and for those who are interested
you should Jasper he wrote a very kind
of tutorial project that explain how
lenses work in air link right and and
the question is where is the language
way to solve this problem because if you
people are constantly bumping into it
okay so that's one of them and it's
worth pointing out that one of the
things you hear a lot is people saying
you know erlang is better than or it is
you know compared to whatever it is way
better and the comparison you here
typically is with Java C++ maybe guys
that is not setting the bar very high
yeah in reality we are if you like
competing with languages such as closure
all right that's like the new hot sauce
that's what what is currently like the
front-runner I guess for the kind of
applications we're writing so we need
solutions that are comparable so let me
also put on my beginner hat I invite you
all to put on your newbie hats and we'll
look at another area OTP all right ogp
is like you know it's it's it's it's the
Grail right it's everything so it
doesn't matter what you want to do an
erlang right I want to need some right
some application well clearly you need
to use OTP I need to handle events well
yeah I need OTP you know I need to do
what is best for my customer I don't
care you need OGP all right I need to
store state ogle state OTP right I need
world peace well clearly OTP is the only
solution right so OTP is the hammer that
does everything
actually could be useful for undone or
so ogp yeah it's cool anybody think it's
perfect it's high ceremony very steep
learning curve it's an awful lot of
duplication if if you you follow the
cannon and clearly you use emacs if you
follow the cannon and you bring in a gen
server skeleton you get I think it's a
hundred and twenty six lines of
boilerplate code that doesn't do
anything you haven't added a single line
of your functionality 226 line I keep me
to go through github find the Erlang
projects and just see how many instances
of that particular skeleton with nothing
changed apart from some of functionality
added right how many believe the comment
blocks exactly as they are in that
skeleton so maybe we've got like a
simple problem we have to solve common
problem at start we need to load up a
configuration file and maybe pause it
and then store the results somewhere and
then throughout the life of the
application we need to get to that
configuration so what's the solution Oh
be right we're going to write a gen
server for it so where to go and get our
server and we're gonna start with
skeleton I spared you the comments so
it's down to about 40 lines of
boilerplate and at this point we have
not yet added our own application to it
all right
when we wrote the pragmatic programmer
one of the principles that's actually
lasted over time is this principle of
don't repeat yourself dry this kind of
blows that away all right this is not a
dry way of approaching things but not
just that if ice now add my
configuration handling to this I get
really it's hard to see it's hard to see
my configuration logic in the middle of
this forest of other lines of code maybe
you say that's a necessary evil that's
the way it works sorry Dave but if
instead we look to language like closure
again it would be like this
I'll leave it to you to decide which is
more attractive to someone coming in
from the outside you feeling lucky what
okay so along the same line I want to
talk about the futures as well just
kidding so actually partially kidding so
futures I'm I have a direction with this
because it can really see some faces of
despair so futures they got like very
popular lately right and then they
there's a lot of there's a lot of it
coming from JavaScript right and
JavaScript a future is basically these
you start a future with some computation
that can possibly happen synchronously
in JavaScript that's likely the case and
then after that thing finishes you need
to register call back like oh if that
thing finished well I need to security
some success if it failed I i pass this
own failure call back right and and I
and it doesn't work with early right
it's clearly i mean it's it's nonsense
right because first we are it has this
callback soup right I'll for the
callbacks are not nested right you'd
need to you are thinking about combat so
if this works I'm going to do this on
successor then if that team works i'm
going to do these other finger on
success right it doesn't work and it's
required for javascript because if you
do things in the in the main block of
code it's going to block everything but
it's not a problem here right if a
process needs to block because it's
waiting for a message you know
everything is going to be running all
the other process it can in the other
course of our machine right we don't
need to go to do this tile right there
is no reason okay and it has a very cool
slated arrow handling right all you need
to do Sophie own failure you know what
we do a failure we let it crash right we
are not worth much like Oh once they are
going to do this or that okay so however
we see from time to time I people come
and our discussions in the mainly
similar Ellen questions mainly it's like
oh I
I would like a future right and when
they say that I don't think they want
this right nobody near st. minds would
ask for this explicitly what they want
is if they if they simply want to start
a computation ok and a synchronously and
later read its value back so it's going
to ask something to do some work and
then its way to light a thing of the
work while i do something else and then
I want to get the result later ok and
and the paper that mentions future for
the first time it future is not related
to call backs at all ok there is nothing
in the paper introduces that say about
callbacks it's like a reject orientation
I'd like the term that the the creator
of the term like Allan K he gave object
orientation is not how it's recognized
needs industry at all right the same
thing right but it came with this idea
that future is about callbacks this
nasty her handling but if we look around
ok they are there are solutions to the
similar problem ok that fits the way we
do things much better so for example
dotnet has a task parallel library ok
that has a bunch of conveniences for
doing parallel work and one of those
things they have their the basic
building block is a task so a task you
started with an action ok and then you
do some computation and when you care
for the result of the task you call
weight on it ok so there is no callback
like oh if it succeeds you're going to
do that the callbacks gone and if the
task fails when you call wait you're
it's going to break our code to so i
choose you know it's actually the
exceptions are propagating we are not
like the errors are pop again you're not
rescuing them and try to put them under
the carpet right so this is much better
and in fact we write this pattern a lot
in our code right because the rough
translation of this code would be this
ok what we do is that we spawn linked
with an action right and then after the
action is done we need to send a message
back to the parent with the result and
then we can do some computation
meanwhile I was polling is doing all the
work ok and then when you're ready when
you're done you just call receive and
you read the value right is the same
ideas like I'm
starting something to compute a
synchronously and then I'm going to do
something me why when I care about the
result i'm going to read it ok and so
this but this is verb broad right if i
was to write this code in practice it
would be a little bit i'll do a couple
more things ok i would actually I would
define two functions task function that
receives the action I'm going to execute
and a weight function and the test
project is pretty much this I started a
reference so i can do i select to
receive at the end but Lucas told me
early Sun wait quite work but anyway
what we do is that I start a task and
then I spa a link but since the action
can say I want to catch it so i
propagate the failure on weight and now
return the reference so we know it's its
simplest you write and then wait is
going to to receive the reference so i
can receive the result of the action in
my when I need it right so fast can wait
and the nice thing about these right
that we can implement tasks as they they
I just show the test for a library very
similar in about 50 lines of code well
you can implement it in about 15 10 yes
exactly right that's the thing right I
can implement it a 50 lines of code you
can implement it in 50 lines of code
right but we've put on our outsider hats
right is that true ok the question is
can we expect someone with two weeks of
airline experience to write this code I
would say no I i would say that i will
say that someone that's coming too early
they would because the lake is more like
mike was talking about it yesterday the
link is more you learn quickly right and
i would expect them to read that code
and have a good idea of what is
happening there ok but i don't expect to
write that code correctly ok not that
early because as i said we are sooo in
those first weeks are still trying to
get recursion around her head pattern
matching right how to think in terms of
data structures okay so Dave and I we we
say that there is an early gap
a-and the way the way we think about it
is these like programming languages they
have like historically had very bad
tools for concurrence okay like tread
locks new taxes okay and they're linked
since the beginning had those very
wonderful building blocks okay processes
right message passing we can link
processes weekend traffic seats right
this is great it's a much higher level
of abstraction to work with and very
productive but s concurs became more and
more important what happened that those
languages they had to add very
fine-grained abstractions for specific
cases oh you want to do some
computational synchronously here is a
task you want to keep state here is an
agent for you right so they provide
those high-level abstractions very fine
grain which are very useful language why
they are very useful they're not useful
for us to writing code right but it's
useful for lowering the barriers of the
language okay and what happens that so
they have those higher level
abstractions but we don't so there's
this gap right there is this gap in
between those higher level abstractions
and where we are and further us this gap
is very easy to close right we can it's
50 lines of code but for someone who's
like just getting started right someone
with the the outsider hat it's a huge
gap okay and it and they need to put a
lot of activation energy if they want to
pass it so just so i think the the
message that we want to get out of this
is that we do want to help people join
our community for all sorts of reasons
so we have to make it easier to get in
and we have to lower the barrier we had
to lower the activation energy required
before people catch fire and get it and
I mean it's pretty straightforward my
first airline program
should take ten minutes somehow right it
should be obvious how to do it I need to
install our line and maybe even as part
of the installation process it says okay
so if you want to write a program here's
a fire here something stick into a file
type this and it will run verify the
installation for you right but not run
automatically you run it because that
way I get this little thrill of success
that I just wrote my first airline
program Wow yeah we probably need to
think very hard about how we look on the
web right what are the likely searches
that people are going to do like create
Erlang application to start writing code
and how can we arrange things so they
get information which is suitable for a
total absolute beginner to start picking
up the language right my very very first
airline program I probably don't need to
worry about supervision trees so let's
see if we can find ways of you know
creating these tutorials and then
getting them onto google in such a way
that makes sense for beginners
error messages I've never understood
this I added to Joe's book way back when
and I never understood then and I still
don't understand it why do we display
Erlang terms to the console what
possible reason is there for obscuring
it that way I mean sure internally pass
it around like that that's really cool
how about we actually display them in
some meaningful format pattern match or
a bad match errors okay again a really
cool concept you try and open a file it
comes back with error you know end to
whatever it might be and you think
that's really cool until you try and say
answer the question well what file was
it I couldn't open right small things
like that not a big deal sure you can
just put a you know some kind of
inspection in there or whatever and find
it but just small things think about
what it's like to be a beginner and
asked could we do this better logging
error reporting right not ideal is it
possible we could include lago by
default get at least slightly better
because interestingly as a beginner if
you go and actually try and if you go to
github basher lager and actually look at
instructions as a beginner okay I need
better error messages because I'm a
beginner I don't understand what's going
on and I hear that this thing will give
me better error messages so I go to the
page I don't understand a single word of
the installation instructions not a
single word including the first one
which is what set the compiler option
and it gives me an erlang term a
compiler option or light doesn't make
sense right the whole thing is just too
confusing let's make it easier so it's
interesting because I think like
companies like the show that are doing
services the products that people in
their nap interface waiver link right
they face kind of similar problems right
so president we're going to have a talk
about cuddlefish that in
2 is the configuration but the same
problem we've lager right they they are
using lager because you know sometimes
like people you're running your right
clusters and then or were they ever
reports there were like what is the
whole thing like down just a hair report
which shows me like know that thing was
probably killed and someone restart and
everything's working fine right so lager
helps a lot with that and it comes from
from this need even the error in Owens
story I I case I have a fun story which
is I think it was like five years ago or
four years ago my friend he was he was
telling me when his first experience
trying to Israel so this was back then
and he he copied everything in his
machine he compiled and when he was
trying to run it he was getting bad
match you were in event right and that's
and I was all like his first time trying
to run he never did in there laying his
life and it's like you're annoyed and
they try again no it doesn't work I
think it personal isn't it he could not
get it to work so he was able to go for
the stack trace and that time we don't
didn't even have limes in there but you
could figure out from the function right
in the module and then he figure out
that it could not boot because there
wasn't a log file they were expecting a
log file to be there right so it's kind
of it's the same thing right ear
annoying when there is a bad match the
concept of pattern matching just
carrying about the cases you want to is
very interesting but what runs two
situations right it doesn't give you all
the information you need all right and
with a bunch of functions like you call
them they just give you better but wait
which arguments my bad argh okay yeah
yeah and then so your talk about like
nested so some of the problems there is
no way right we need to have a bunch of
examples and teach them and get people
acquainted with thinking recursion
getting use with pattern matching right
but there are a bunch of problems that
they can provide modern abstractions
right so we can have aer lingus way of
work with NASA data structures okay and
then when it comes to patterns regarding
OTP like agents
right and tasks we need to put this in
the conversation maybe they should be
included or maybe we should start
talking since the beginning how you
would write those patterns with the
tools we have today and I want to make
it clear that this is not you know the
goal of heavy agents are tasks not like
to only to reduce the barrier of entry
right I would definitely use patterns
like that right and we are using in the
Colby right right some of you probably
wrote a task pattern like 10 times
already in different applications okay
and having it a name give it a name
helps a lot in the conversations right
because now you can see so in digital
server the day pant is hidden know the
code right but if you have things that
you can say oh this is a task this is an
agent it helps with the communication
lot because you look at and say oh this
thing is meant to keep a simple state
that's why I'm using agent here and your
kind have a good idea of what that code
supposed to do and the thing is is that
we are talking about having those fine
higher-level fine grained abstractions
right and the good thing is exactly that
we already have the very good foundation
right so the problem is not like a
technical problem okay we have the good
foundation the foundation is there we
just need to close the gap okay we need
to to to lower the barriers so we're not
knocking our line we're not looking
knock in the community what we are
saying is that it would be a really
really good idea to have people join us
the world needs the technology that we
have we need to make it easier for the
world to discover it and to do that I
think it would be really helpful if
every now and then we stopped being the
clever smart you know billion
transaction the second type people that
we are and instead put on our canno ruse
hat and learn to think like a newcomer
and because if we learn to think like
newcomers then I think we'll make it a
whole bunch easier for newcomers to come
in and that will make it a whole lot
easier for us to share the love
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>