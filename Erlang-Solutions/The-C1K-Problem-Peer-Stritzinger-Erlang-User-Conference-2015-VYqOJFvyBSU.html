<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The C1K Problem (...) - Peer Stritzinger - Erlang User Conference 2015 | Coder Coacher - Coaching Coders</title><meta content="The C1K Problem (...) - Peer Stritzinger - Erlang User Conference 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The C1K Problem (...) - Peer Stritzinger - Erlang User Conference 2015</b></h2><h5 class="post__date">2015-07-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/VYqOJFvyBSU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi yeah the c1 k problem so connecting
thousand a long notes by distribution
doesn't work very well right now so
first a little bit about what I'm doing
that's basically my first project doing
Ellen that's the device for flashing
automotive devices it runs along on
freebsd and has some gateways with c
code on it and in the meantime i also
went into industrial applications where
we have more embedded devices smaller
devices where a long runs almost
directly on the hardware and in this
area there's a request to have a
programmer programmability by the
industrial people running building the
factories basically and what they
normally are used to for programming
their stuff and make it move is PLC's
programmable logic controllers there's a
variety of languages from very primitive
assembler like stuff to pretty high
level stuff and days recently also
standard for distributed PLC programming
which just about sounds right for
fitting in with an application that also
runs a along which is also distributed
and there the thing you see here is a
function block which is basically
written in a Pascal like language it has
a little state machine in the inside or
it has a large state machine inside it
depends on what you write which has all
kinds of conditions and it's it has
inputs and outputs the inputs are on the
left and outputs on the right on the top
part these are events that that's a new
thing for the distributed stuff and the
lower part is basically data like
connected data so like this but the
events are connected to the datas from
from top reversal
boxes and basically the data is only
valid when they have n triggers so this
maps pretty nicely to error messages
basically the event plus associated data
is the message which we send and these
function blocks blocks get mapped to air
long processes so one function block
with one state machine is one LMK
process that there are many of those
function blocks doesn't isn't be a
problem for us so last year I talked a
bit a little bit about more about this I
just show it very shortly I wrote a
compiler using the tools in OTP that
compiles the pascal like language which
these function boxes are written in and
there's also another part of the
language where you can connect them and
you can later you can also have a
graphical model also but the graphical
stuff doesn't exist yet so there's the
typical stuff you have there divides the
the brown files there is T files which
is the name of the language structure
text probably never heard of it anybody
program structure text yeah I I did I
had to because I'm my first user so I
compile this and and compile this to
beam files and the beam files have some
supporting files basically the beam
files mainly have the code needed for
the state machine and functions that
return tables of stuff like list of
tuples that tell the runtime system
what's what what to do with it and it's
basically the the two colors of the of
the st files that the darker one is like
a function block and the lighter one is
the application the application is
basically one big function block where
you connect stuff together and you can
also have some applications etc etc but
it doesn't add anything really new to it
and there's basically a function block
runtime
helper and application runtime helper
and there's also supervisor and this all
gets connected together the the function
block basically run in the PLC f-block
functions which are supervised and which
called basically the stuff that's that's
compiled from the st language is
basically i call that module like think
plc f-block is the gender of a module
and the compiled stuff is a quad big
module you would write there's also the
plc up stuff that controls what gets
started where and stuff like this and
how it's connected so I was talking
about distributed plcs so if you if you
want to have this distributed and I have
an along system they easy way to just
get something running is just use Erlang
distribution and further for the first
prototype that's also used and in runs I
i did this approach basically we have
the two notes here and there each note
says has its supervised part of the
application so basically the whole thing
is one applications so the application
the application connection file is
shared between all nodes it's basically
and there's an additional configuration
file which tells it which function block
needs to run on which node so it's
everything is known in advance i start
all the the supervisor starts all the
function blocks in in order and there is
one block at the end the plc mon that
monitors basically it's it's needed to
to like start everything up initialize
everything and then send one start
message at the end to everybody that's
the yellow ones on the left side and
basically it's I I didn't duplicate all
the messages because it's basically it's
mirrored the right side also has to
start messages of course and also it
monitors every other node it monitors
every other function block on other
nodes not
once the other one notes to see if it go
if they go away because basically the
how this thing works is if since the the
PSD stuff doesn't have any faith Phaedra
safeness or any any way to restart or a
cover state or something like this the
first approach to do it if anything
crashes we crash the whole network
basically and restart the whole network
again we want to move to get the allons
allons facial safeness features into
this part but for this we need to change
the way the PLC's programs add features
to the language which doesn't have at
the moment in the standard they still
learning phages rayveness and
distributed systems the whole then the
names of the function blocks where you
where you can center of the instances
basically of the function blocks where
can send messages to our just registered
in global so I can find everything very
easily which gets us into trouble later
but it made this prototype work very
well the whole thing runs on on al nvm
that's embedded on the atoms operating
system which is actually not really
operating system is more executive it's
basically you boot into the thing it's
the only thing running on the machine
there are no processes there's basically
one process and you have threads and the
other angry em runs on this it's
basically almost on hardware I have a
tcp/ip stack in there in this thing and
I can access my files or no no no no no
on the nand flash but that's about it
and this combination is side project of
mine it's called gris project it's still
not released yet but pretty soon maybe
later this year so let's talk a little
bit more about the application where
this is to be used where we have the use
case it's a research project that the
customer of mine is doing and lots of
other research organizations in Germany
smart factory IT industry 40 whatever it
may be cyber physical systems blah blah
like take all the buzz words in the area
and punch them together as a research
project but it's a good research project
because you can do interesting things
this is how the hardware looks inside
are the boards on former conferences
I've brought these sports and demoed the
the atoms running along and stuff like
this in the distribution now they got
the box so it's it's getting to look
more and more like a product and this is
one of their assembly lines basically
what they what they control these
assembly lines they the customer makes
transport system for assembly lines so
this include RFID stuff because you need
to find out what you have got it got
stuff to move stuff from here to there
usually ribbons sometimes like Rose
ribbons roles whatever and there are
little pellets on it or larger pellets
depending on what you're building and
they are moved along by the Romans and
stop by by little things going out of
the room of the ribbon that's a stopper
and there you can like pile them up and
let them out one by one and then you
have RFID antennas well so you can tell
what what you got there so you can make
like the product can tell the Machine
what what needs to be done next and and
all this functionality we have
integrated into this box actually the
upper box the lower box is basically a
wiring box that's basically where we
attach the cables so in order to get
like a better view of this I've made a
small video it's like from the demo
machine say you see the ribbons that are
the parents moving around the these
these lifts go up and down if they go up
there they lift it off and then it moves
over the side channel they get fixated
because if you do if you want if you
need to mount something they it has anti
collation you need
fix it too so it has a fixed position
because on the ribbon you can move
around rfid system fixing yeah that's
about it i only had a few snippets we
did several people did on their phones
while we were building the thing that's
that this machine is actually controlled
by alarm all of it and this is how it
actually looked on the trade fair it was
a shown on zibbet it was basically the
research project was showing everybody
was showing their stuff and the ribbons
go ucf one in front and one back and
there's also like a human interface
robot added to it like candy and all
kinds of other technology that the other
partners we're building so this is a
small assembly line we just saw but if
if you build assembly lines you need to
like to think Foxconn sighs so you have
hundreds of meters of this stuff and for
the small line we need it like 13 to 15
notes depending on how we built it and
if if we want to scale like whole
factory size we are talking about
hundreds and if you talk about Foxconn
sighs its thousands of nodes so we need
to connect thousands of a long notes and
use distribution and actually I want to
keep using distribution because
especially in embedded it's very nice
because you don't have additional
encoding and decoding is just built into
the system it's it's it's relatively
lightweight as long as you don't send
lots of lots of data of course and it's
very convenient to build stuff but it
has some issues so global is slow
everybody knows global is slow and we
found out when we start up our systems
and waiting for all the other notes
coming up waiting for all the names to
appear in global 15 nodes or 30 notes
depending on 30 notes took 10 minutes
15 minutes to start up sorry it wasn't a
problem for the trade fair because what
did me no it wasn't a problem in it
trade fair interesting something is
pinging because basically it started up
in the morning and it's not like work is
waiting until the machine runs and
everything and actually all the other
partners until their stuff when they
took even longer than the nasty boot
okay oh yeah sim so there there's the
issue with global so we need to get rid
of global somehow or augmented or
whatever and there's also a thing that
along distribution in the normal mode
tends to make a fully connected Network
and so the number of connections in
network is n square by the number of
nodes so I don't know where with the
embedded nodes where we will break I
know 15 notes work but i'm pretty sure
somewhere between 15 and 1000 notes it
will break i don't know if it's 70 or
100 or whatever but so we can't reach
our end goal by connecting all the nodes
shorter side I try to benchmark
different techniques for like replacing
global all the numbers i have is
basically if i run it on the embedded
networked it takes longer than 10
minutes and if i start the same notes on
my laptop and going over localhost it
starts in less than 10 seconds so if you
want to measure this it's very sensitive
to latency I don't think it's throughput
in this case it's latency so I gave up
on this because I for this I had to set
up like
old simulated network with where I can
really mock the latency just a lesson
for somebody who wants to measure this
stuff so I was looking at possible
solutions for how to fix my distribution
problem there is of recent the output of
another research project sdl on scalable
distributed Ellen we will have a short
look on it there's Jeep rock which is
mainly not used in distributive mode
because it had issues and but there's a
new locks leader branch which looks
promising for fixing the stuff then
there are hidden nodes more on it later
and yeah we could fix a long
distribution that's maybe a large
project then so short look at this D
along here they have recently they have
set up a nice website which tells you
how to get started it worked for me I
tried it out the thing is what you can
get there is you don't have the fully
distributed Network but you you can
define groups of nodes and which can
overlap so you basically have a kind of
hyper graph of groups so they you can
basically pass messages from you if you
have a router on a shared node you can
go from one group to the other group and
inside the group's they are fully
connected again and they they have a
name registry replacing global basically
probably grown out of global it's
looking very similar which only is
registering names in one of the groups
so you say for this group register this
name so you get around having too many
notes for global so if you have smaller
clusters so you can like manage the
connections of the fully connected
network it's especially nice if you want
to like distribute workloads if you have
like three like structurally of the
subgroup yes then one one member of each
worker node and in the enemy may note so
it clustering works could could work
quite neatly with it
in the end it didn't fit perfectly for
for our use case which we'll see later
so let's move on yeah there's a cheap
rocket issues with Jen leader there are
several versions fixed versions or not
fixed words with Jen leaders on mainly
people are using cheaper up not in
distributed mode but in blocking mode
for local registry only normally if you
build cheap rock nowadays if you don't
set a special environment variable it's
it's not even pulling in the
distribution stuff but there's a new
branch from wolf that uses locks leader
which uses locks which should fix the
gen leader problems hopefully it's I
mean it's not very new but it's like
from last year i think the locks leader
branch so it's all still calls it it's
beta so it's maybe not right for
production it's supposed to be faster
than global i couldn't measure it
because of the issues was my laptop
because global was already fast on on
the laptop and i had didn't have access
to the network and because it's like on
some place else at the moment of the
embedded nodes and but the problem is it
still doesn't fully connect the network
so you need everybody talking to
everybody it's not like it's not fixing
the 1000 node problem for this it could
fix their boot up time for the 15 node
problem let that could work quite well
but not the 1000 old problem then for a
long time there there is a concept
called hidden nodes in Ellen which are
basically hidden from the rest they are
not visible in the width for the normal
notes command and they are only
connected when when when you talk to
them so either when you say net net I
ADM ping or net Colonel connect or you
send a message to the nodes
if you know the node name then it gets
connected from then on it stays
connected so you get all the air on
connection things and you have all the
stuff like monitoring running basically
everything works as as usual except it
doesn't show up so global doesn't see it
and cons it can't like wired in and you
get the fully connected Network because
global is the main main factor like
producing the fully connected Network so
you get a hidden note if you start a
along with with some there's hidden
option then it's hidden this note is
hidden from the rest basically and but
you can still see them if if you don't
use the notes function with zero
arguments but with one argument because
then you can pass the type of notes
you're interested in so you can say show
me all nodes that are connected now or
show me all hidden nodes that are
connected and several other options
quite useful for this the monitoring
axis is expected so once you connect it
it works like normal except that global
doesn't work for it there are a few
other interesting functions if you want
to use hidden nodes there is a long send
function with an option and you cannot
pass the option no connect I didn't
figure out what you want to do with this
actually basically what it does is if it
avoids they can automatically connecting
the note but it doesn't send the message
so if the node is connected the message
goes through you get the usual answer
and if it's not connected you get the
answer no connect are not connected I
don't know you get an answer like this
note is not connected i don't know i
just put it in for completeness sake
because it's basically only useful with
hidden nodes what's also useful is if
you have hidden nodes and no global
registry for names you need
have a way of sending a process get like
you have a way to get either sent the
process or get get get hold of a pip
from an owl node so you probably
sometimes at least will want to use the
thing that you can send the top where
you have a registered name a locally
registered name on our other node and
the name of the node in a top oh and you
can use it like where you use the pit
for sending and it sends basically the
message they are the node and looks up
the name locally on the other node and
sends a message over there let's build
in and basically all of net kernel is
also very useful so if you want to play
with hidden nodes and just read the man
page of netqin colonel from front to
back because almost every second
function there is useful for hidden
nodes so except fixing the distribution
which will come to later that's that was
the overview of the techniques so let's
try to find out which one we pick for
this application because usually if you
have a distribution problem and unless
the along distribution protocols are
fixed by quite magical things it usually
gets application-specific what you want
to do so probably if LM distribution is
to be fixed or augmented this will be
different augmentation needed for
different application areas so let's
look at the assembly line that's
basically the skeleton few of the thing
you have one ribbon in front going going
this direction the one in the back goes
goes in this direction so you can go
around and there's 11 bridge in the
middle way you can also move over
basically this place is a repair place
so at the last place it gets tested and
if it's ok it moves back over and on the
back it gets unloaded and if it's if
it's bad it goes to the repair place and
the what needs to be repaired is shown
on the screen for the work of there and
stuff like this so if you look a little
bit inside
that's the drawing from from from from
the top of the assembly lines and what
you see here these are these this is an
airline note this is one of our embedded
notes and the small print below it are
the processes on it that need to
communicate so what interests us most
who needs to communicate with whom which
events on data is connected where so I
made a graph which looks peculiar
there's a big fan out in the top so have
a look at it so right in the top there's
a small note that calls let's called in
it and this fans out to everywhere and
if you have a if you if you look further
there's over there there's also one one
node with lots of fan out on the other
one these are delayed in it's basically
so this these plc applications have in
it event basically that they need to
start running because if nobody somebody
has to send the first event somehow
because the state machine is only
triggered to to do something if it gets
an event it's defined to be to do
nothing if there's no event so somebody
needs to send the first event and that's
this in it in this application so this
is basically the blue boxes are the
nodes so this is how these processes are
distributed around the nodes so it looks
a little bit messy it's everybody is
talking to everybody especially the one
know that the top is like pretty
connected so if you like move the
processes away and only look at the
nodes so the blue box is again the notes
these nodes will be connected so if we
run this in there with with hidden nodes
not this movie we would get fully
connected them if you run it normally
but if you use hidden nodes these these
will be connected so it looks pretty
pretty clean on the outside but this is
one note in the middle and who needs to
talk to everybody for probably obvious
reasons because this indeed event needs
to get sent
so we would have I mean if if the if
this is a thousand notes then this one
node has 1000 connections which is also
bad because if this node breaks it it
doesn't help us if if the rest would
work so let's let's have a look again
what if we if we kick out this node this
node and this node all the init notes
the delayed in it notes and replace it
by some other mechanism then the graph
looks much in but much more interesting
if I have these processes removed the
other stuff is looks like more like
local communication so if you look at
this one and remove their the high find
out stuff then we see we have like
change or the trains of like these nodes
are connected in one chain design one
chain and there are even some isolated
ones which only need to get the needed
off obviously and then just do nothing
just run locally so the note connection
graph goes from here to here I left off
the isolated ones so this would be
actually quite feasible to use with
hidden nodes sdl on wouldn't help us
much because even if you say we have one
group we can like use it like for the
groups for it falls apart but it would
fully connect the big group itself so it
might it might be a solution but if you
have like a very long assembly line and
like somewhere somehow somebody needs to
talk to everybody this this actually
falls in two parts because we have
basically a mechanical communication so
we have independent parts which only
communicate by the pellet going from the
Earth's there and not buying it by
getting a signal back when the signals
are usually antique relational stuff
like yeah this pot is free to upstream
and and then the thing moves and
sometimes you have like parts where you
can like pile up stuff like having a
traffic jam but one one one that works
well one you can dissolve and and then
you don't need the communication and
that's why it falls apart into into
pieces so as dln could help but what
looks most like it is like just use
hidden nodes just use hidden nodes and
distribute the initial event which I
only need to do once at system startup
that's also convenient by another means
for example by having like by manually
introducing that there will be the
simplest way manually introducing in it
proxies send a half half as a simple
function block that gets the event and
sends it out immediately and and place
this on the nodes where which are
connected anyway so that wouldn't be a
problem that since it's an easy way to
do so when we remove the hyphen out for
this application hidden nodes would be
the solution you can also for example
combine hidden nodes with some kind of
gossip network if you had other
applications to it or for example if he
if you have the PLC application you
needs hidden nodes but if you have like
some kind of compute clusters because
the embedded systems are very small and
if you want like to compute like online
planning algorithms which take a lot of
compute power or can take a lot of
compute power then we might want to have
clusters of our embedded notes and safe
a big server that stands on the site
doing all the online planning stuff so
we can reuse compute because these
embedded notes do nothing most of the
time they just sit there and wait for an
event a dipole there I owe a little bit
for debouncing but that's it fortunately
SDI long can be combined with hidden
nodes very easily because when
you start this dl on it basically all
nodes are hidden you have hidden notes
but you can group someone some of them
together which are then not hidden to
each other but the rest is basically the
same thing as hidden note so you can
combine it quite neatly with other
applications so let's move over to
fixing Ellen distribution I didn't do it
I just looked at it how I would do it
because when one of us gets to hear and
talks on papers that yeah we couldn't
use a long distribution because it's
broken for our use case for whatever
reasons for example it can't say it
can't scale to the number of notes
because you fully connected network
doesn't scale there's also an issue if
you send one large binary for example a
very large message from one node to
another node then since all the messages
from one node to the other no dissent
sequentially this large message blocks
it blocks align it takes a lot of time
to get over and smaller messages that
need need to go from one node to that
overload I have to wait behind it which
can get very messy because Ellen oats
want to send regular ping messages to
each other like normally every 15
seconds and if you miss too many pimping
messages the connection gets lost so
yeah just a beautiful support so there's
there's several approaches like but
mainly everybody who needs to send large
binaries are large large messages from
one node to another has a secondary TCP
connection where it sends a large data
and send only the small messages on the
distribution channel like orchestrating
the thing but it would be kind of neat
if this would just work if distribution
would do this for us like move the the
large binary over TCP connection or a
secondary TCP connection or a connection
pool and maybe send the small messages
as UDP packets why not
where is some kind of reliable Datagram
system or whatever they are possible
concurrency issues the thing is from
every node to every node there is one
tcp connection and there is one linkedin
port driver and everything has to move
through this port driver so if lots of
do give a fan in and a fan out like this
and I think we've seen some of the if I
studied right in the former talk there's
they had similar problems they had to
bunch up together small messages to get
rather one big message then if everybody
couldn't talk to everybody because
there's there's some kind of locking
involved if you want to talk to the one
port well at least I don't know I don't
know it might be it might have not been
the reason but this this could be this
could get messy if lots of processes
talking to lots of other processes on
the other side but it might be like I I
don't think it's like the main the main
problem the fully connect the network
and the head of line blocking are much
much harder then there's also what if i
want to have different transports i have
a like a research project coming up
going on to get hard real-time processes
into the llvm so you can write a hard
real-time process in a long then you
need some other way to do the
distribution for these processes because
i'm there are hard real-time protocols
and hardware and networks layers that
are used for this stuff but so you need
to divide up like put the normal
messages over the normal distribution
and the hard real-time over this
different distribution there's also the
thing that you might want to have
security for like if you're if you're
communicating in a hostile network in
theory there are in the examples folders
of SSL there is one you can use SSL for
a long distribution but it's not built
in
but what's building is like a mechanism
tool at least if you if you can deal
with the concurrency problems of the one
port you can build your own it's it's
pluggable it's actually I mean the
documentation is a little bit sparse but
it's it's not non-existent there's a
command line option proto dist which
takes a kind of module name which tells
the Erlang distribution that you want to
have your own module doing handling the
along distribution basically the module
it's actually call this mod underscore
this so it appends the dist behind it
and that's the actual thing that it
calls and it the module needs to
implement them all these functions it's
basically a kind of behavior but it
isn't one it's not checked by the
compiler you have to do it by yourself
and these these functions is basically
the whole connection setup and breakdown
and all the managing the orchestrating
of stuff and when implementing this
module you have also a desert this tools
module that you can use for most of this
stuff so the hard stuff that's always
needed for every distribution you can
pick from the other module and then you
can do your own what you also need is a
port driver that actually implements the
transport because the elgen sends a
message from one node to another if you
have like the same piff then you're
you're in the vm and the vm that's needs
to get rid of the message that so the
message doesn't flow over your airline
module doesn't go back top to air long
and then to wherever so the Kobuk module
basically orchestrates how you how you
set up the connection and everything and
and then distribution knows this node
has this port and the pot Robbie you
need to write if you have one to have a
different transport if you just want to
change like session setup and teardown
you could eat
use that the existing poor drivers but
that's probably not much point of in
this because if you want to have if you
want to have for example you want to
have some kind of routing for not fully
connected network then you need to catch
the messages in the port and do the
routing there there is also a example in
the in distress code I'm doing melon
distribution leave a UNIX domain sockets
which can be found in there in the
examples directory of yeah of colonel I
think and there is also a description
about how the driver is is built under
this link so it's actually there is
actually more there than I thought it's
not it's just a little bit obscure there
are thumb say if you if some if you want
to build another distribution protocol
there there are some things that need to
be observed by it which which which
haven't been like true for all the time
but are true for the current version
basically all messages are bracketed
between the node up in the note down so
for a current airline system there is no
message from the other node coming
before the node up and there will be no
message from the other node after the
note down I mean if it reappears again
then it needs to get the note up again
and all the messages and what's
generally true for long the ordering of
messages between any process / p and it
needs to be observed so you need to keep
the ordering you can't like if you want
to if I example you want to send your
messages by UDP you should at least add
a sequence number so you actually know
if they are out of order and reorder
them and then you can actually find out
if something is dropped and you can do
your own retransmission or you can just
send a note down then and on the next
map before the next message to send a
note up actually no download our
business is handled internally already
it so you don't have to
right your serve then there's also
another issue EPMD is pretty much right
into how the current distribution
protocol works you need to have a way to
find out where is your node which part
do you connect to what machine is it on
this is done by EPMD which usually runs
once per machine and is a bit
interesting piece of c code which is not
very nice to extend its a little bit
messy since I also had two needed I EPMD
for the embedded system where I don't
have processes because the emt normally
runs as an extra process from the hell
nvm and I don't have processes there all
together it's running all the other half
threads there is support for a running
EPMD in a thread somehow but it's I
didn't want to touch it so what I did is
I I rewrote EPMD in pol because there's
no reason it needs to be in C and editor
editor flag 2222 net kernel that if you
pass it at command line you can pass
your own EPMD module which need because
if he needs to be started before the net
colonel comes it needs to be there
already this doesn't take care of having
only one EPMD dem dem on purpose system
which wasn't an issue for me because i
only have one LOL per system the system
is an element so there's one EPMD demon
also but this can be easily fixed and I
have to say I'm looking at the I had to
look a lot of at the C code of EPMD and
if i look at the airline code and the
alan code looks much more manageable to
extend to other stuff which we probably
need if you want to fix the distribution
I've put a repo link down there if you
go there you will find an empty repo
because I just put the at least the repo
up so you can I can link to it
before the conference because I didn't
have time to push the stuff but I I will
I will push it in the weeks after the
conference soon I need to like add a few
comments of the license and stuff like
this time for questions okay we will
well no we will augment it basically we
will put the problem is there if you
have a purely event based systems and
I'm part of it goes down then you don't
know which Evan you did get and where
the state like that you don't get the
init event again so you need to have
some a cousin to like reset up the whole
thing and this mechanism actually needs
to be put in their Indian in this plz
language because let's actually a lack
of the PLC language it's a problem in in
this language I can't build this in a
long this is no problem but it's it the
PLC language is missing these features
but what what what we are planning to do
is like if you have segments of the
assembly line and what is done in like
in chip manufacturing there's a there's
a kind of protocol which runs on like
electrical lines so it's basically yeah
I'm free sent me the next 11 line I will
send you on now next line it's like five
lines which have a signer connector so
you can like put different modules on
chip manufacturing together and connect
them so kind of very primitive
point-to-point gossip protocol bus no
it's not the gossip protocol because it
doesn't send on stuff for my elsewhere
but it's a very primitive way of
controlling the flow in the line and we
will put something in like outside of
the peel
language a thing where you can if this
goes away then it and then every line
goes to the default site which basically
prevents this thing of sending stuff
into their into the broken assembly line
thing so you can bring up the stuff
separately I still need to be able to
communicate with with the thing but I I
like I want to add a little bit ere long
thing because these these function
blocks for the PLC I can also implement
them in the air long there is a behavior
for this and basically right to two
endpoints of these failsafe connections
and we will like segment the system in
this way and have different applications
that are separated by these along parts
so not everything freshness of course
it's like I mean with the 50 minutes I'm
if you develop on this system it's hell
because one crash somewhere you had one
little bug and then it takes the whole
system down and then the next boot takes
15 minutes that's kind of annoying yeah
you said running EPMD on all I notes
instead of csse program within is easily
solved so actually yes because it's just
a normal server so you start and earl i
know'd it does nothing but EPMD para you
start an O line note that does nothing
but EPMD he said to solution yeah that
would be a solution here if you if you
wanted to run it on a normal machine
yeah you start an l unload that does
nothing but EPMD ok for the embedded
stuff I need I needed something
different because I don't have an X ray
Arnold so I have added an option to the
command line basically what to the boot
line in this case which starts the
internal EPMD at the right point during
system startup before Ned colonel runs
but there is no other node in the
embedded system they can't be no I
wouldn't I I mean if I would run on a
unix system or on a mac i would just
start one Ellen own like he like like
the like you said is that one Ellen node
with a longie PMD on it just doing this
not running distribution like a non
distributed note just running EPMD and
you can start it by the same mechanism
where you start Howie PMD is started
basically EPMD prevents itself but it
started twice it looks is there another
in PMD basically there's that III think
it's to dial it says it has been a while
and I looked at it it's too tired it's
basically there's one thing that when I
LM not get started it tries to see EPMD
if it if it doesn't see it it tries to
start it and if you have a race of the
two of two nodes coming up at the same
time both trying to start an EPMD EPMD
itself prevents of being started twice
and you can use the same mechanism if
you use it in a yellow note you can even
maybe use it I I really would have a
dead
okay to know that I wouldn't honor you
on the unix system I wouldn't run it on
on one of the distributed notes this
doesn't sound right I think there was
one more question it's okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>