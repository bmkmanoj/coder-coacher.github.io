<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days - Konrad Malawski - Types of Types... in Scala | Coder Coacher - Coaching Coders</title><meta content="Lambda Days - Konrad Malawski - Types of Types... in Scala - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days - Konrad Malawski - Types of Types... in Scala</b></h2><h5 class="post__date">2014-04-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_XQARZFWaXo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello hello okay so I think we can start
okay so welcome to the Scala types of
types talk and first a few words about
me then I would like to ask you about
your experience about scholar and do you
know scholar at all or not at all so
first one slide about me when it's all
about you and types so I currently work
at eBay but I'm originally from Krakow
and well originally from Vienna but most
of my life in Krakow and actually from
this University and I found it a bunch
of user groups I hope you know them vets
for logos and even more often so I would
totally recommend attending either
reading clubs we have in Krakow over
lambda lounge which especially important
for you guys for functional developers
right stuff I like
obviously Scala in the middle ver and
other things but types so my first
question who is familiar with Scala
before this conference okay that's very
good you in the right talk so we'll be
talking a little bit of the basics and a
little bit of more interesting stuff but
no implementation so if the
implementation is an implementation
detail and we really won't care about it
during this talk we'll only talk about
type signatures and what we can do with
them so we will talk about types
specifically in Scala so while most of
the concepts are very generic and can be
applied to most languages we look at the
examples only in Scala and the big three
don't panic it's gonna be fine so if you
see very scary stuff just focus on it
and it's gonna be all fine keep calm and
type safe so first for total basics so
Scala types are static which means it's
compile time checked so I can't really
assign a robot to a human right if they
are not the same in the same structure
so that's a compiler error so they are
strong but strong we mean if a variable
has some type we cannot just randomly
change its type to
from into the string right they are
inferred by that we mean that you don't
have to save it fizzes an end the
compiler is smart enough to infer the
type and thus quite a few examples why
this is completely needed and we
wouldn't survive in a such a nice to be
typed language that our Scala without
type inference why well sometimes the
type can be like very long like very
long when we see a few examples and you
can obviously check for class so we own
the JVM and these are normal Java
classes okay and if you really want to
save a type you are notated after its
name so if it's just a quick refresher
if by some accident someone has not seen
Scala before today
okay so first the basics of traits so
what is a trait so trait in its simplest
form it's like an interface so it's some
type that has some methods inside of it
so it can be even extended and
implemented right same as Java
interfaces on the other hand and if it
can be also implemented in richer ways
and only method implementations so
that's a method so we can implement it
either as a method or you can fulfill
the same contract so f thing returning a
string also by just a value so that's a
very important thing we're gonna
leverage and some other patterns
okay so traits are a bit more than just
interfaces they can carry implementation
with them as easy as that and then you
can mix them in so which leads us to the
first problem with well is face multiple
inheritance well it's not really it
looks like it I mean you can mix in
multiple things so in that sense it is
not single inheritance right like we
have in Java but do we have the same
problem with C++ with with very old
diamond problem which is that if we
inherit for example such a such a thing
so in this structure we basically
inherited
Lazer's twice why because we inherit
lasers and also robot has lasers in it
already so in C++ for would be a problem
vert yeah so which lasers instance
basically so let's call a source for
something called type linearization
anyone familiar with it okay half of the
room so let's go through it in more
detail so type linearization is a method
to solve the diamond problem pretty much
so instead of having the diamond we
flatten flatten it out so there is a one
algorithm that always applies for seams
same way that is able to from this world
linearization with repetitions able to
represent one linear type so you can
always when you call super so you'll
call your super type you know which one
will be so if I'll go from the goats
trackpad start with X right the stuff
the types of in Reverse fun okay so we
reversed so in its robot women are
lasers so after reversing its lasers
human eye drop then you have to expand
all the types so in our example if it's
only robot so robot will expand to
robots and lasers all right then we make
it unique with keep rightmost so in our
case we're gonna keep this left lasers
instant when we add common things which
in this case will be object and any and
this is our Linares type and by looking
at this you know if in X I call super I
would be calling the methods in humanoid
for example if you have multiple in
multiple methods with the same signature
thanks to the linearization you know
which we would be calling but you don't
have to trust me and you can trust for
compiler a little bit more than me so
you can check further by investigating
the type so you can check for X type and
get its base classes so what would would
be something like that so everything I
do here you can verify yourself
okay next so if we reorder it slightly
just a quick sanity check how will it
work same amount same algorithm and in
this case you see the robot expanded on
the left hand side but Verger rhythm
still gets you to the same well not to
the same order but to a valid order so
order matters okay let's go into more
interesting things so type refinement
very similar to what we saw already but
when you create your type you create
your class you can either save
composition at declaration side or you
can do a composition on creation side so
here we have a new human and we try to
do the same thing as we did before and
we get a compile error a robot is not a
human but we can do the refinement right
here during instantiation of robot and
add the human trait to it so now we have
a robot with human traits which now can
be assigned to a human typed variable
yes first line this was so human assign
new robot but won't compile so we add
the mixin now we compile it right so at
creation time you add a type to it
that's called a refinement okay we also
can do a very similar thing but instead
of the creation declaration time and
creation time we can do it at the
receiving end so by receiving and I mean
a method that will take a basically
intersection of some types so if we have
an open oral thing and we have an a'
closable thing it's not related types
right if we don't extend each other
nothing of that kind
but let's say we have a method that can
only work on something that it can open
then do stuff on it and when it can
close it makes sense so we can write it
as a compound type so in the method we
require that it's gonna be an open
herbal with closeable so we oughtta have
a place where the same construction
appears so something with something but
it carries a slightly different meaning
not really
I mean you require that this object that
comes in well and it's here well this is
intersection Union would be everything
so this is and I mean if you look at the
Venn diagram like that's a crucible
that's an open or if it's both it's here
right yeah I think we agree only maybe
English problems okay so even more all
right now now we have a very interesting
problem
so can we in this case say but yeah I
know it's an open oval and it's a
crucible so can I say it open and on
whatever open returns can I say close
well the problem is open herbal has no
idea about the closable type so you
cannot really say without binding these
types together at declaration site right
you would have to say yeah so an open
number returns a closeable let's say I
don't want to
because only in the method I say you
have as composite exists so what you can
do here is something called this type
and this is basically you get this
instance and this type is this it's not
the open above right so it depends on
the context of whatever the object is so
now we can do this open and close on the
same thing yes you do yes so for this
pattern you have to predict this because
if you would just return this it would
be inferred to open the problem so yes
this is something you have to do
explicitly okay so type parameters or
type variants or type bounds so who's
familiar with type variants I would help
everyone right who's familiar with type
of bounds okay if you didn't raise your
hand for a second time basically you
know it is what it is because it's the
same thing it's only a different way of
expressing it okay quick reminder so
this is a class with a type parameter
why do we call it a type parameter
because this is actually a type
constructor when you think about it if
you have something that takes a type it
creates a new type in the process so an
example would be a list of string so the
only meaningful type is this list of
string you don't really think about list
most of the time you need a list of some
concrete type so it's kind of similar to
a function when you think about it but
we'll get there quick reminder of
variants I would love to skip over that
if we are fine so the only thing to
mention here is these plus and minus so
covariant means more generic minus means
less generic less general so if you've
picked this intuition and let's look at
this pattern
so a parent and then a Bolton extensive
a parent you can think in terms of more
general and less general and now
suddenly scholars type bounces in text
makes sense because parent is more
general than bottom or bottom is less
generally the parent or you can also
verify that something types are equal so
in this view would use this operator to
verify some types are equal so this is
used in type level programming and we if
we still have time I can show you that
we can implement basic math operations
using these operators okay quick example
house caller blows up so if you would
assign something to an invariant type so
a bottom to a parent in container it
would blow up nicely and I hope you can
see that but the nice thing about
scholars it would it will try its best
to help you out so it will detect yeah
this is not valid but if you will
declare your type as covariant it would
have been valid and you can refer for
more information in the scholar language
specification that's a nice way to blow
up instead of saying that I've don't
match
quick reminder when and how things would
blow up and covariant and contravariant
types let's go do more interesting
things so a structural type is different
to a normal type in the way that we
don't match by name but we met by
structure so here we can say this type
is defined by this block of code and
this means it has to have this structure
to be this type you can just slap such a
code block as a type so a box is
anything but has a receive method that
takes in a string and then you can call
the receive on the box you don't really
care about what exact type it is you
only care about what it has inside of it
so that's the structure type but that's
not easy to read when it's a bit too
long inside the method so you would
usually make an alias for it
we'll talk about type aliases in a
second and now let's say I have two
receivers one is home when this work and
they are not related by type in any
other any other way then having this
shared signature so we can send to both
locations without having to copy these
types together okay
okay we already saw type members but I
didn't really talk about them explicitly
so that's the type parameter it looks
kind of like a functional type level but
the type member looks a bit like a value
but it's again on type level by type
level I mean this is not really a value
this is only something we will be using
for type checking okay this is
equivalent but how is this better
sometimes so let's say we have a list
that has a type a so when we can
constrain it with the constraint syntax
I've shown you before so we can use a
type bound on it so a numbers list will
now only take types with a less well
deeper down in the hierarchy the number
so now we can specialize by assigning to
type a integer okay next and we cannot
create a list that would be specialized
for human because a human is not a
number okay so that's one way of using
tiberius
and another way and reason to use form
is to make code more readable so in the
Java style you would extend something
and then pass in the type parameters by
all hope is lost I basically mean some
meaning is lost because very some first
in some second parameter and you don't
really have the names for them they are
not used in the source code beneath on
the other hand if we were to have type
members for them you can use them here
and you can keep using them inside of
your implementation so this means
stringbuilder is something that builds
to string a from bite builders something
but built from array of bytes and then
you can reuse those and keep using these
names from in to in your implementation
but sometimes useful if you have some
generic types you don't want to
introduce boxing but want to keep names
get how we can assign them directly here
and this is not introducing a new type
it's only addressing it different when
and go where you would have to convert
to a from type ok now more interesting
things okay what was so where phantom
types so that's the point of them so
they are never instantiated so a phantom
type is useful for having more typed
things but not really useful for storing
things in them so let's say we have a
door and the door has a state so these
are the states of a door and we will
express our door as something very
straight with a type parameter called
state and it's a subtype of door state
now an open now an open method has to
have this state for this a closed
basically okay so implementation wise
you would have to only cast to this
other phantom type so you're not
returning anything new you're returning
yourself but for type the type signature
is telling you what state something is
in so in the runtime these things are
not present because of type erasure on
the JVM so this is no performance cost
on the other hand it's really helpful
because we can now when you open when
you get a new door it's closed when you
open the door it's open and you can
close it again so it's close but thanks
to the phantom types you cannot close a
closed door because we're closed
the
not conformed to being a subtype of open
so you can use further in builder
patterns for example when on some
operation only works on a limited query
or on a not infinite stream so you would
say my stream is not infinite so when
your operations can be constrained to be
more safe for example you would rather
not call size on an infinite stream if
your size implementation is trying to
get to the end of a stream right but it
would be a bad idea and we have a way
those of those higher currents very
quickly so kind something above types
and I hope I have time enough foot to do
that ok so a kind is something above
types so when you think we have values
when you have types which are kind of a
buffoon so kinds are above types so when
you think about a kind of an int that's
only X so the proper kind and you can
investigate further in the ripple by
issuing the kind command ok that's a
proper type as we said before a list of
something sweeter the type parameter is
going to be a key type constructor so we
invert realm of kinds say it takes a
type and it goes and creates another
type
so it's an X - X and usually it's gonna
be star - stars usually star is used but
star on responses between itself and
when we have higher kinds and you don't
really need to get high of an high
that's high enough so by higher we mean
so this is a tape constructor and it
takes a type constructor okay so it's X
2 X 2 X why do you need that good
example is a functor why do you need a
functor
so if functor is for example when you
want to implement a map operation so i
want to map my list of bins yes my list
of ends to a list of strings and you
want to abstract your implementation or
for any container but you can use that
is in scope available for use so the
user of your method would only supply
the int to string method and you can
abstract away the type of the container
okay let's see this in an example okay
so I can create a new functor off list
list as a topcoat type constructor so
now I'm high enough so I'm creating a
higher kind here
it's a map from string to int right and
in the input type is this list of
strings and composing the type
constructor with the input type and the
output type is where out comes from the
output of this function and now I'm
cheating and using the built-in map
function but you can easily just iterate
over and apply the function and build it
in your container yourself right so why
is it so interesting because you can
supply multiple implementations
somewhere in scope and that's actually
the next talk today about tag classes so
we will be taking that one over so you
can supply multiple man plantations so
we have implementations for a container
with as a list or a sum and by only
having those in scope you can implement
your two place which will work on a
abstract container thing that is totally
generic and doesn't have to know
anything about the container so we say
the container is a type constructor and
it will be available in scope and
someone will implement the logic to put
and get things out of it and you
implement it totally generic against the
container interface thanks to that and
implementing these type classes before
you can have this topless method to be
generic up among over this given type
without ever having to know what you're
actually working on so this is
incredibly powerful for code reuse
although might be a little bit hard to
grab at grasp at first but don't worry
good and of course when you look at the
signature so these types are different
so the first and second share the
container type but the types of the
insides are different right so here you
see that fit for list is shared but for
instance string types carry on on the
respective positions okay
the type Clause is something you will
cover so we also call it that hook
polymorphism we also call it more a pet
and verno type and yeah stay in this
room so I'm not going to explain this
one and since I'm out of time just a
short link so I have a pretty long
article about these things so this was a
broad overview if you're a bit lost
that's totally fine because firstly very
in-depth article about furs and you can
learn how to write nice reusable code
using that if you're interested how many
types of types for around these so thank
you and please if you have any and
questions I would be happy to take them
the type lambda I had it prepared it's
too scary to include inverse lights so
yeah so the type starts here so it's it
starts here and ends here
so it's like carrying we are familiar
with Korean right functional developers
but it scurrying on the type level we
can talk about it on fabric</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>