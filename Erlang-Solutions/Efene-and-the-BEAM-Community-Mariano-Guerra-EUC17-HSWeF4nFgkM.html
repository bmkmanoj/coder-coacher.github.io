<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Efene and the BEAM Community - Mariano Guerra - EUC17 | Coder Coacher - Coaching Coders</title><meta content="Efene and the BEAM Community - Mariano Guerra - EUC17 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Efene and the BEAM Community - Mariano Guerra - EUC17</b></h2><h5 class="post__date">2017-07-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HSWeF4nFgkM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and can you hear me okay yep okay and so
let's start and yeah she said I'm Melina
Vera here you can follow me they like
the website language to let the twitter
handle what I do that pays for this and
so let's start with a quick disclaimer
and I will start kind of in a critic
mode but at the end there are proposals
for improvement and I also think that
it's quite useful to have some talks and
that look at the other side of the
things the first time I saw it it wasn't
a jungle conference where they have a
specific talk they invite someone from
outside and the title of the talk is
jungle sucks so they did the idea of the
talk is to to critique what it's not
okay and find ways to improve it and so
you know you may know this expression
Erlang had it 25 years ago it's a common
expression and it's actually true which
is really cool Erlang made really
interesting decisions a long time ago
based on problems and with that they
were like 25 years ahead of the
competition let's say but did how did we
evolve after 25 years it's 2017 did we
evolve like a BMW or Dell more like a
ladder and the problem is and that when
once you get something right you get
more comfortable like you say okay we
have a really powerful platform people
will come because yeah we we are the
cool guys but let's see the other way
around what things are we doing now
today that other communities what other
languages will be copying in the next 25
years which is crazy to think about but
that which things are we doing right now
that we will be first in 25 years so I
think the times are changing or they
already change along a while ago
there are like 25 years ago or 15 years
ago you had Emacs or VI of course VI a
make file and our lank and you just had
everything you needed nothing more
because everything was like that like
tool in our own languages except for
things like small talk weren't really
common so building tooling and support
around around programming languages
wasn't really common and there weren't
many choices like you get a job arm
transcend ones that you could choose
between Fortran C and bash like those
were the choices but now comparing with
cars get the team and like people have
many choices even many choices that on
the basis are pretty similar for example
these three cars are actually the same
car or the same platform from three
different big car brands these are these
other three from another brand are the
same car they are actually building the
same factory from three different car
brands they're from three different
countries but the three brands are from
actually from the same company which is
falsifying so in terms of programming
languages we have this explosion sort of
options and many of those are come from
a family of languages which I call I'll
go like or derivative from algo and
people have some certain expectation or
they are more comfortable with that kind
of syntax and it's not only the language
but also the tooling and the community
and things around the language that make
an important part of the choice for
Portland so as with many things punk
rock has all the answers that Kennedy
said a record call give me convenience
or give me that and what I am saying
with this this is John McCarthy humanoid
know it he invented lisp here he is in
nineteen seventy sixty seven and using
an IBM 7660 or something like that
parameter with Lisp to play chess he
wasn't using list and 67 because of the
speed
Joel Armstrong before inventing Erlang
said this like he was using small duck I
will teach and comfort all he was used
to small talk and when Smalltalk GCD he
will go to take a cup of coffee so he
wasn't using small talk because of this
speed this is a quote from DHH the
creator of river rails when he started
rowing rails and using it in Basecamp
his company he was restarting the server
four hundred times a day and after
improving it he was only starting it
like 10 times a day so why all of these
choices because we can tolerate a lot of
pain if the tool make us productive or
make us feel productive which may not be
the same thing so McCarthy wasn't using
Fortran Joel wasn't using C and the
judge wasn't using our line so what's
that because productivity is not just a
thing of the language of the syntax or
the semantics of the VM even of the VM
implementation it's the whole experience
it's that's what I call community in
this in this talk so I've observed some
things that let's call it Mariano slow
if you want the Fordham community is
inversely proportional to the power of
the tool when you get a powerful tool
there's this feeling that that yes it's
much more powerful than the alternative
so let's just sit and wait for people to
come so this is a rebel in Java line in
IntelliJ I think look at all the things
they had to do like they had to build an
IDE they had to build a graphical tool
kit they had to build this all this UI
and they also had to build all day like
the supporting to make a Red Bull out of
Java because Java doesn't have something
like a red red Bull natively but after
that they have a quite good Red Bull and
a visual one and auto-completion and all
the types and other notation so
something that we get get for granted
that you have to make
not afford to get but after they made
all of the dead Ford then like now they
have a red book and much more things
than that the ID supportive now is
really cool and I cannot imagine
programming Java without an ID so that's
why they're that the reason why they had
so many cool ideas and I think it's
better if I come here so you can see and
so on the Left we have languages I call
the pragmatics which are languages that
take ideas from other languages which
have really good ideas before them but
then they take more shortcuts or hacks
and baby they are not perfect or pure
they have to make a lot of effort to
build things around the language to make
them more usable or approachable so you
can see CT from Algol C C++ Java from
seamless multiply some from ABC with
sort of math dog and JavaScript from
self and scheme and on the other side we
have languages I call the if we build it
they will come
which they got a lot of things right
they are like for each category they are
the languages that started that like
branch of programming languages but who
is using one of these today
so guy still a he is known from spore
scheme but also he was on the committee
scandalizing Jala and he said that he
was trying to take C++ programmer half
way to come all this through Java so
many people may not be think that this
is right but Java the good things about
Java is that they brought the idea of
virtual machine and GC into the
mainstream so we got people halfway to
more powerful languages even it's not to
Lisp and this not only happens with
languages like on the left you have like
things you know you should be doing or
you know it should be better if we did
activity for example and on the right
you have convenience we n usually end up
on the right because of convenience not
because it's the right choice
I think we are selling Erlang and when I
say our line the beam in general the
wrong way when somebody asked us what
what's cool about our line or why why
should I be using our link we tend to
focus on the features of our line like
we say yeah like per process GC and
cheap processes and 206 60-something
bytes and and concurrency and schedulers
and pre-emptive multitasking and stuff
like that but what they are expecting to
hear is which cool things how Erlang
makes them more powerful like we're
talking about the flower and they want
to talk about they want to they want us
to talk about what the flower allows
them to to do or to be so and this is an
actual thing I was thinking I'm
participating in a hackathon some months
ago and I say the problem of the
hackathon is or the idea is that you
have 24 48 hours to build some software
so and I thought would I use early
because I tend to use Erlang for almost
everything I do but the time pressure or
I have to deliver something really quick
and let's call it mean time to
meaningful result which is how much time
or how much scaffolding on how many
concepts around the thing that I
actually want to get do I have to get
before I get something meaningful out of
it so for example the the I think one of
the reasons why we invest becomes so
important is what's because the first
thing he did was a YouTube video
screencast showing people how to build a
blog engine in 15 minutes so he didn't
talk about the features of Ruby or how
the VM is implemented or which patterns
Rubin rail uses or which cool features
of the language it is I said look look
like start create this project run it
you have a blog like show the result
first then let's talk about how cool
Ruby is or how cool Ruby in races so
that's why I think we're selling along
the wrong way we are like talking about
the cool features that we never say
to people how much more productive they
would be if they use Cernan so this is
the buy confidence they had caused by
Jason freed the co-founder of Basecamp
from the product behind in Ruby on Rails
so here's what our product can do is
different from his what you can do with
your product it's sound similar but it's
not the same thing so I feel this
happens with our Lang is the powerful
language start it in which everything is
possible but nothing of interest is easy
like if I want to take a quick rest API
to test something how many steps that I
could remove are there and or if I eat
searching rule how to build the REST API
on our line
how much accidental complexity is it
around the problem I want to solve so I
think we should be selling Erlang the
opposite way the dursa talk Bob from
rich Hickey the great of closure that he
talks about the language of the system
in fact in a part he mentioned seller
and error long as a possible language of
the system
the advantage of Erlang is that is at
the higher level of abstraction than
other languages it's more like glue
between systems or a language to handle
other languages or a language to handle
platform service or systems but also
it's really powerful for things like
Internet of Things for obviously for
REST API web stuff for web sockets for
putting airline on in front of other
systems and many other things but it's
not just a matter of saying this which
we should be saying when somebody says
like why should I be using our length we
should say because this is the things
you can build with our own but we also
have to create all the libraries and the
documentation the blog posts the
examples the github repositories with
easy to run examples it's not just a
matter of saying that it's possible but
to show that it's actually easy to
achieve and we have to be careful with
this problem which is called the
innovators dilemma which is
like Erlang is innovating in many things
but more progress and pragmatic
languages and you may have seen it are
getting ideas out of our length and
implementing them not the best way but
possible but the way they can so you see
things like acha acha dotnet orleans on
the dotnet a goal goldang the language
so if we don't move and keep improving
we may get to a point where other
languages and platforms copied enough
features of the Erlang VM and at that
point there won't be a big enough reason
to switch to our line but because the
other languages are good enough at the
things that Erlang is with it you may be
thinking that I don't see a problem like
this conference is really cool many
people and many people doing interesting
stuff but that's called survivorship
bias like in the Second World War and
the English started analyzing the planes
that came back from from the missions to
Europe to see where where they were hit
and to see where where they should put
more like more material to avoid the
plane from actually crashing so the
first thing you may think is okay if
they get hit there then let's put more
reinforcement there no actually you have
to put reinforcement on the places where
no hits are because these planes got hit
on those places and came back that means
that the ones that didn't came back were
hit on the places and the empty spot so
if I ask you like ether and heart or do
you think that there's something wrong
with their languor is it hard to start
with their languor you are the ones that
survive so for some reasons we are we
have some genetic difference where we
can survive all of these challenges we
have to go out and talk with people that
try darling and for some reason didn't
continue using it or decided for
something else
a quick easy ways whenever you read
something on Hacker News already that
says this is a new service built on
golang and you say this should be built
in Ireland right every time you read
that you should take it as a reason to
make more efforts to make that the next
time somebody implements a service that
should be written in Erlang is actually
written in Ireland or when you see some
like distributed system build on top of
node.js or something like that you say
oh god that this should be running under
Lang VM but for some reason it's not
running there so why should you care
because you already are working order
learn your programming and your day job
why should you care
let's do a bus factor exercise these
people are really influential in the
community what would happen if we didn't
have them how many things we wouldn't
have how many talks how many libraries
how many frameworks how many books and
stuff like that but let's go the other
way around what would happen if we had
twice of this kind of people five times
this kind of people ten times this kind
of people so at least let's do it for
the egotistical reasons so if you want
to have more libraries more books more
broad posts more companies in our lungs
so you can choose where you want to go
to work next stuff like that
you just do it for the for that they go
testicle reason let's try to make it
easy to and too big a bigger community
on our length just so that you can
benefit personally so here is some
low-hanging fruit and this is their own
website which is it's nice-looking but I
find some problems with it so let's say
I'm not an airline programmer and I go
to Orlando org and I rebuild massively
scalable sub real-time systems and I'm
at a hackathon
let's not what I'm looking for doesn't
mean that it shouldn't say be saying
that let's read let's continue
so Erlang is a programming language it
will massively scalable so Friel time
system so doesn't apply to me I'm
building a website with requirements on
high availability yeah that's a nice to
have some of it uses our own telecoms
I'm not a telecom banking
completed 11 instant messaging the
closest I would get their instant
message maybe so and I quick I say okay
let's keep going
I don't see anything about webs or
WebSockets or HTTP 2 or NT DT or
Internet of Things but let's keep going
let's go to the quick start maybe you
see there if there then you say ok I
want to see this experience of let's
make a blog engine in 15 minutes but it
starts with like a really slow
introduction of every single thing that
Erlang has and at the end like after
like six seven eight chapters you're all
on the if statement like I mean this
this documentation is useful and it has
to be there but this is not a quick
start this is a reference manual or
something like that
let's compare I'm not comparing it with
JavaScript let's compare it with Haskell
so really nice website I have to say
nice tagline as legal mode of tag line
or explanation a cool code snippet so I
can get a feel of like what the language
looks like and they are not using
Fibonacci which is a plus they have a
wrapper right there
on the website you can start writing
Haskell right there and if you don't
know what right they have a five minute
tutorial on the landing page so you
don't have even to install our Haskell
to start so yeah and then you have
videos and then you have books and there
you have tutorials and blog posts and
feeds and everything and I'm comparing
their link to a language whose motto is
avoid success at all costs so it's all
down from there and you can check the
arm website the okama website the racket
racket website those are like hardcore
languages and all the websites are much
more approachable they you can get a
sense of the language and what you can
do with the language much faster you
have quick starts good getting start
guides it instructions on how to install
it even you can run it without is
telling it they have all tried web
online rebels I'm not comparing it with
like mainstream languages even I'm
comparing with with hardcore fluff so
this was the complaining part of the
talk I will move here again so what I'm
doing and first I started trying to
improve the documentation I open a peer
a pull request say seven months ago and
I blogged how to guide on how to work
with the build system and how to get the
documentation built and which files you
have to go and check and change to get
improvements exact so other people can
go and keep going from my guide it got
merged I think it should be available in
the next release and plenty and I'm
building a tool to create a client side
index for search not only for the like
for for Erlang itself like arrow dogs
but without the backend and but also for
your tools my idea is to open a pull
request where on their official Erlang
documentation you can get an icon on the
top right or do control S or something
and you can start typing and as you type
you get all the parts of the
documentation that match your search and
then you click and you go to that part
of documentation because a crazy thing
about Everlong the commutation is that
there's a lot of documentation really
detail good documentation but the
structure is not really approachable so
a good search and will make it much
easier I'm also working on a tool to
convert from the XML to restrictor tab
text and from there I can use things to
build a website which is the tool that
with the dogs website uses but it's not
only to compare to read so trick text
it's a generic platform to get from XML
to X which the first ones will be plain
text for for example for quick tools to
when you hover over a function you get
to the competition of that function it
can be also marked down as they
mentioned today and it's always combine
Docs and and I will do a lining code to
speak to all the other people that I
would like to get some help here so
we can get this so this is the the beer
that got merged it's not a lot I didn't
try to do a lot in the first PR because
I wanted to first learn how to use it
and see if they would accept the per
request and they did so it's a simple
slightly improvement of styling and now
we have optional syntax highlighting on
the code which is useful and this is how
the dogs look after being compared to
respiratory text and build with things
and so we get a if you have used to read
the dog or something like that it this
is we can use a tool that many
communities use so we can build on the
shoulders of giants in the same and I'm
also doing a thing called the fna for a
long long time but I decided that it was
time to release it to the public so what
if any it's more of an attitude towards
community documentation tooling and user
experience and it happens to be also an
alternative syntax for our line it's
just that it's not much more than that
I'm not trying to build specific tools
or specific libraries or everything is
just another way of writing our line and
interacting with the existing so you may
know what this is it looks like Jason
right well that's the FNS index for data
with the x12
you can have trailing commas everywhere
and and the rest you can have atoms oops
I know what click if you have an atom
with some crazy characters you can he'll
use backticks because I use the single
quotes for binary strings which I write
more much more binary strings than crazy
atoms and this is the cons operator and
I think it's smarter more clean than the
current syntax these are tuples like
Python and so now you know everything
there is to know the syntax for data on
this is a binary pattern that matches
the ipv4 packet rating and it's just a
map with the tag that says this is a
binary so the syntax for binary pattern
matching is just the syntax for maps you
don't have to learn a new syntax if you
want to add more parameters instead of
putting a number there you put a map
with the options and this is the syntax
for yeah if you've gotten C JavaScript
Python this is the syntax for operators
this is a syntax for a binary operators
same and boolean czar taken from Python
a comparison from Python yeah or any
yeah Python and so let's see a little
bit of syntax and this is the match
which in Erlang is case off and at the
core of Erlang if you didn't notice is
basically case clauses what they are
called in compiler and which is match
this then do that so this is a case
clause that matches error and variable
and returns it this is the a guard and a
else if you want to match something else
this is a receipt I don't know if you
notice with it all your team this is a
top level function this is a public
document function this is a lambda this
is a name lambda this is list map this
is if I had a module that had the lambda
first and not last if you know culture
this cold spreading
I couldn't make try aligned with all the
other ones but it's the same thing you
can see there this is a try-catch and
threading the other way and like if you
want to thread to the end of this next
call you use this double thread if you
want to thread first you thread it like
that and this is a list comprehension
slash for loop like functional hardcore
functional
programmers will hate me for this but
there is a cool optimization in Erlang
if the compiler knows that you are doing
a dis comprehension only for the
side-effects that is you're not
assigning to anything it won't build the
list of the last element and so what
this allows is to have more than one
statement here and use it for
side-effects or for a list comprehension
which is this replaces many of the cases
where you use list map and list for each
this is for each for with the clause
this is for with two generators this is
one of the main problem with Erlang it's
really small and really subtle but
Erlang doesn't have an if statement but
it has the if keyword so when people see
the if they think oh it's an experiment
and well I know I know what it is and it
doesn't work that way that's because if
in Erlang is not an if it's a guard and
guards need to be executed fast because
they are everywhere and they are at the
head of the function classes so they
cannot have any colder they only have
some some functions you can cover so
let's not use if for something that it's
not leave and let's use the same keyword
I use on guides which is when so when
people see when we say when is just a
guard that matches that it's there it's
not attached to any other clause these
are records of course they are supported
and this is how to declare it at the top
level and I use here again the tagged
data and tagging data is compiler
plugins as cheap as any with the with
compiler plugins for binaries and for
records you can add your own tag data it
I make it hard enough so that you don't
ship everything with your specific
tagged plugins but if you if we decide
that some other extension is useful and
I will add it or you can load it as a
dependency so you create a record with
the map syntax
and with our dot and the name of the of
the record you match with the map syntax
you get a field like this you update it
like this and you get the index of the
field like this so it's all there's no
specific syntax for that and since it's
an alternative syntax for our Lang and
we support the dialyzer x-rays and
whatever Elvis or whatever works with
our line so you can write your types you
can read your spec you can attach any
kind of metadata to functions and then
you can retrieve that metadata for a
function you can say give me all the
attributes for this function and and so
it we use it to declare public and so
you don't have to have to expose little
table you can if you want but you just
mark it with publican and it's exported
you can define the spec so our Lang SNe
is as i said many times already just an
alternative syntax for for our line
there is not going to be any specific
tool for ascending there's not going to
be it doesn't have standard library it's
not going to have wrappers around or
like libraries it's not got going to
have implementations of things that
already exist on our land it maps one to
one to Erlang it you can use x-ray of
dial RC you get all the Erlang warnings
because I'm just internal to syntax it
can compile the bytecode II can't read
file one two one two our Lang I'm not
generating any extra like like every
expression in F n is the same thing in
Erlang except the threading which I will
put the call in the place where it
should go so if you compile to our leg
you'll have nested calls and other cool
features and you can in call include
Erlang headers and you can use macros
you can include an Erlang macro and use
it in a phenol which may not sound
interesting but given the fact that
Erlang macros are lexical it wasn't that
easy and there's nothing to install you
don't have to install anything you don't
have to add two lines of rework on
I asked third if it could be just one
and he gave me a reason why it cannot be
just one line what is just two lines you
can start with one file so you have a
project you have these two lines - river
config and you start with math modeling
in Erlang if you don't like it you can
bail out at any time you do rebar 3fn a
compiled format air length and it will
generate a length for all your fnn files
the only other extra feature other than
threading is when you include a XNA file
an F any module it will include the
functions and if you redefine the
function in your own module it will
override the one on the on the header
and it will give you a warning if you
don't specify the override attribute
much more like Java so it will work but
it will say look you have this function
in the header and you have our
implementation and you're not marking us
all right it may be a network what this
allows is for example if you are doing
cowboy and you have a rest handlers and
for almost all your recipe as you have
many callbacks that are the same you can
just include headers with those
functions and in the specific cases
where you need to override one of those
you just override it in place so in a
sense if any is a boring language it's
probably going to be the last release
unless Berlin gets a new syntax in which
case we will get a new syntax unless we
can do it with tag data which in which
case we want it doesn't have a standard
library as I said but it has as the
Python senses there should be one way of
doing things so and the idea of Nathan
as I said is an approach to community to
documentation to tooling and to
onboarding and user experience so there
there are something that we I call a
blessed libraries so for everything
single thing you may want to do in fna
there's one recommended library or two
that we recommend so cowboy is one
I think I have listed them but the
templates will assume that you will use
that one and the documentation will
specify how to do it with that one and
we will make sure that all the blest
libraries interoperate the right way
then we make it easy to work together we
will work to make documentation better
those libraries so that you get a better
experience using them it won't have
wrappers or any parts of libraries it
won't have SNA only tools if tool is
built for fnh would work for everyone
too and I don't even plan to have a
slack I will kindly ask the airline guys
to open a channel on the Erlanger slack
if they can so as I said it's a boring
language but it's also an exciting
language but because the language is
done let's get things on let's start
working on the other things that Erlang
doesn't solve already or doesn't solve
100% perfectly so let's focus on the
commentation onboarding on templates on
neural messages some community and
examples and tools let's build this
standard tag and let's fill the missing
pieces let's polish and integrate them
the tools want some of the tools I'm
recommend river 3 relaxed cuttlefish
cowboy lager examiner recon see in
shotgun katana worker pool common tests
and let's make the beam a better
platform for interoperating with our
languages Erlang is great and many
things but it has some parts where it's
not good
so let's interoperate with other
languages that do that part well and we
should start working on making it easy
to write C notes and needs in rust
because it's less likely that you will
get a segmentation fault
which will crash your VM if you're using
it and also rust it's much more
approachable and user friendly than C
let's make it work better with closure
and JVM in general we already have the J
interface so it's just a matter of
writing documentation and blog post on
how to use it
Erlang is another language for building
websites so just buy again so let's
interoperate with JavaScript when we
write something let's show how how you
would use a JavaScript library to talk
to our land and stuff like that now we
have graph QL stuff like that lets lets
show examples of the whole stack not
until the point where we care and did
you just write the JavaScript let's show
how it's done and I think that's a great
opportunity of using well assembly which
has been standardized on the first
version is already available to write a
secure and performant code that won't
crash and it's cross-platform so there I
have many ideas we can talk later on how
to make it easy to make close to
webassembly to write performance
sensitive stuff and in a secure way
interested that's one way and we will be
writing on top of all the browsers they
will be like making it work fast angled
and secure and we can just use it but
also let's work on system interoperation
interoperability let's write and try it
with docker with rocket whichever method
let's write guides and tools to make it
easy to deploy to Heroku Google Amazon
Web Services sure and let's take it easy
to use on Windows we are many UNIX guys
I've tried to run my stuff on Windows
and it's not the most pleasant
experience and it's really easy to steal
programmers from Windows because many
platforms take Windows as a second
platform as a second level button so if
we are really easy to set up and run on
Windows we will be getting the
low-hanging fruit of people if they try
to install tree the platform Center Lang
is a shit one they may use Irvan so
which is the status and I'm releasing
the 1.0 rated one today it's being
stable for a long time but I didn't have
a reason to release it and I've been
using for toasties documentation tools I
mentioned before are made with definite
I have some tools to inspect Erlang code
also we'll build with it I have some
load testing stuff and also the backend
I put my
hands or my code word my mouth so the
back end of my new product is build with
deafening so if any has a bag I will
note first that that's a way of ensuring
that I will want to make this as stable
release and useful because I'm using it
everyday so how can you help try if any
read the dogs open issues when whenever
you find something confusing it's not
your fault it's my fault so report it I
will fix it talk about your experience
blog tweets or whatever mastodons draw
over its call to post something there
help me with syntax highlighter I have
one for beam but I understand that
people don't use them because they like
and but vim and Emacs will be a good
place for this community but I want to
make visual studio called des ID to use
so whenever someone comes and what
should be using for any Visual Studio
code not because I use it not because
it's cool or something but because it it
works it's easy to install it does a big
community and it will grow much more
useful so I help me improve the pretty
printer I'm improve the repple I started
something called the language server
it's a specification I won't open
standard that Microsoft released on how
to expose a service so that IDs can
interoperate with language tools without
having to like do 1 to N in connections
and templates so reap river three new FN
a blog and you get a full blog running
and you can play with it let me have
right in place I already have some but I
want to write more and let's build great
being tooling with FN if you are not
sure to use it for your work let's like
turn the other sign say which tools are
missing on the damico system let's build
them with definite so you can try it and
we can say that we are calling a funny
for useful things so yeah help me thanks
and by the way remember the ladder and
image from the beginning that's the next
ladder car
so they went from trade the same thing
for 25 years to this new car so if that
I can change we can change to thank you
so I think there's a three minutes for
questions okay
can you shout yep
yeah I'm not in the melon leaf so I
don't know that I don't against it but
I've been changing if you see the PR I
forgot to link it I being changing the
Excel XSLT to generate better HTML and
stuff like that and I kind of get it how
it works
my idea is to build a tool that will
take the XML and generate other formats
so the XML is okay
so you eats easy to process and let's
build tools to generate like different
formats from there
but what I did which it's more
approachable for young people is I use
XML to parse the XML and generate Erlang
data structures and then like a walker
and then you can plug in different
places and emit something else so - if
someone wants to make a XML - man page
they can write Erlang instead of
excessive P which is it's a good
language but you have to learn it and
it's not the language everybody here
knows so it's a good way but I think if
if we make it easy for people to to help
us which would be we provided our line
tools to build it I think we will get a
better result more easily because I even
use accessibility before and I forget
almost everything so yeah but that
that's what I say in this talk it fits
our ego let's fix it and if we say
instead of writing XSLT you can write
Erlang to generate other formats it will
be much easier for people to contribute
so that's why I'm trying to
okay one more things all other things
you can do is why cannot we get the Alex
cooler lecture things on the beam we
should start talking about how to get
the minimum feature to get stuff like
protocols on the beam why cannot we have
an interoperable way of protocols if one
of the language already has it we should
prevail probably providing one-to-one
mentoring you should be blogging more I
should be learning more we can have
stuff like earn and module of the week I
would like to see closer documentation
like like documentation like enclosure
where every single function has examples
of usage and comments of like god chess
and stuff like that you should follow
Erlang on all the platforms and whenever
somebody posts that we give meaningful
and helpful replies and friendly replies
help people we should have guides for
all the common tasks why we may be one
of the only community that doesn't have
an user survey I have I never got the
email well I guess in our twenty they
are doing this but we always say that
darling is not good as strings can we
make it better I mean it shouldn't be
like the best language for our string
processing but can we add more functions
and make it easier and document the
gotchas and guides and how to do string
stuff and more I have more ideas you can
talk to me I will be tomorrow here thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>