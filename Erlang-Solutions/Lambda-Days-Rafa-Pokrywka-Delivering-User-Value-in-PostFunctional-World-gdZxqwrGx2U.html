<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days - Rafał Pokrywka - Delivering User Value in Post-Functional World | Coder Coacher - Coaching Coders</title><meta content="Lambda Days - Rafał Pokrywka - Delivering User Value in Post-Functional World - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Lambda Days - Rafał Pokrywka - Delivering User Value in Post-Functional World</b></h2><h5 class="post__date">2014-04-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gdZxqwrGx2U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">haider hello everyone and I will try to
actually explain a few things in the
stock the stock will not be a technical
talk the stock is more a business talk
and covering some kind of aspects of
functional programming and
cross-functional term in turn in
software development process and in the
reef delivering of software solutions to
customers so that's the time title of
the talk delivering user value in a
cross-functional world let me let me
introduce myself like myself in one more
time my name is Sir laughs Apocalyptica
I'm actually founder of filters lab with
those labs types a partner in kharkov
here we are mostly doing work in Scala
actually all of the projects are right
now in skala so that's a good thing
definitely I've also found that the
of style users group with other joke
members with with friends from community
and Scala camp which is also organized
by cargo sky users group this is a
cyclic meeting about scala in Krakow we
had for 4th edition recently so they
would they will definitely they will
definitely be more okay so let's let's
get back to the to the topic is there
everything okay with the phone with the
with the speakers am I heard correctly
cool cool okay so let's let's go through
those three things that is the river ink
and what we are dead deliver that this
user value so this means what is
important actually for the further end
users that and and the term past
functional post functional world that
was a term coined by first by actually
marking on the risky who in two thousand
then wrote a blog post that blog post
was actually an answer answer or
response for other voices from there
from the development community about
about the topic that if the Scylla is
actually functional and Martina levski
argues or she try to explain a few
potential potential aspects and cry for
clarifies what what is actually the
place of scholar in the landscape of
rugged programming languages and sorry
sir for that and the details actually of
this blog post includes actually
argument that scallop actually is
functional it means that all of the all
of the critical feature features of
functional programming paradigm or
functional paranoid our present that's
in Scala that this for example functions
as a first first first class you need a
higher order function promotion of
immutability and pattern matching for
example and the difference between
Scylla and other functional programming
languages is that probably Scala has its
roots in JVM and Java and in JVM and
Java syntax so in the same time Scala
also embraces the object-oriented
programming I mean all the all the all
the aspects of object-oriented
programming are also available for
software developers in Scala and this is
kind of a different approach than other
languages also based on JVM took when it
comes to the functional programming for
example for example closure closure is
meant to be more a pure functional
language which I should not have set a
pure because it's not pure in our sense
that not that Haskell is for example but
it's
definitely definitely rejects aspect of
object-oriented programming to some
extent of course and it definitely has
different syntax so basically the syntax
of scholar as has its roots in Java so
that's why it may be a bit easier for
for java community and software and java
java developers actually to take a
venture to tell that i take advantage of
and to try just i will just take a few
drops of water sorry ok excuse me that's
a bit better at the same term that this
post functional as has been used by and
promoted action by by Daniel super bug
in his presentations i think it was in
2013 the first time he presented that he
presented the functional programming and
object-oriented programming together
showing the kind of things that are
potentially missing in some part in
functional programming or in object
objective of object-oriented programming
and the conclusion of the out of his
talks actually was that was that the key
thing in the next step in evolution of
programming language languages is
modularity and modularity and bundle
system is something that is to some
extent actually covered by traits in
Scala and some other aspects in
functional
closure for example protocols and but
the end conclusion is is a bit deeper I
mean I don't want I would like to I
don't like to enter into the details of
functional programming object-oriented
programming and combine those two those
tools and because the van a conclusion
actually of both of those those the blog
person today and the presentation is
that functional programming alone may
not be enough and the history actually
shows the same that is when the list has
been first introduced for example and
somehow it was a hard way for software
development and fervor for software
business to embrace actually the power
of leaf lease and use it in a mainstream
actually people and developers to estate
somehow in using the foreign for example
or imperative languages this shows that
somehow functional programming alone or
only using the functional programming
paranoid parrot for functional paradigm
in software development is actually not
enough and people always looked in other
ways of solving some problems it's of
course depends on the kind of problem
but it appears that the evolution of
programming go but probable program
programming languages has to actually
involve both the functional programming
style and object-oriented or object
oriented programming as well so that's
that's something that is that is
definitely definitely needed and this is
something that gives the software
developers additional tools or the broad
range of toast to wisely and actually
consciously use in solving real life
parameters
ok so the post functional means actually
they're not for me another step in the
evolution of of software program of some
of the programming languages actually
it's the natural step that allows
software developer actually do to to to
take advantage of of those practices I
will explain that in in a minute how
this relates to use a value and
delivering but this is our key think
that it's actually standard normal
evolution okay so move let's move ahead
let's move to explain a little bit more
about user value and what did this
actually means because we've mentioned
about programming languages with nations
about the possibilities they give us
this Gaza software developers they are
different ways of expressing the same
thing that we can use something that has
the most hype already or in the current
in the current current current moment in
time but that's something that that is
not probably the best thing in a given
example I mean for from the problem
perspective and from the user / /
perspective this is somehow the couple i
mean the programming and playing around
of the sand in the sandbox with all
those new tools new new possibilities
that the next programming language hulu
you will give us that's not actually
gives
the or is the best way to try to to to
to deliver a user value I mean to focus
on what is the most important thing the
user value actually is it's something
about what we are delivering user value
is something good we as a software
development business does and what is
the main purpose actually of our work
our daily work so when actually a
customer comes in and the customer just
would like to make an investment into
some new system that will allow the
customer to scale his business and make
for example better better profit org or
just as another source of revenue or
whatever other the reason is the in most
cases that reason is comes from
fundamentally from phenomenal value from
his the customer business and from his
site from his needs actually and
requirements and this this is the same
kind of investments actually as they are
made into for example new production
line if a gig business given in a given
sector would like to expand somehow
would like to add another product to its
to its offer they just invest in for
example in a new production line which
is a simple investment to make to
estimate and actually simple simple
investment to estimate the return of
return of it so the main expectation
expectation usually in
is for the customer is to actually
provide or sure that he making that
inventory making out that investments
will achieve the return of simple simple
value return of investments I'm this is
the potential additional profit he can
make so basically that's what the value
usually is for the customer the system
as it is should I should not fail also
that this should not have the hidden box
inside that are resulting in a failure
in a production environment that's even
if we meet the requirements even with we
gather the quagmire quirements correctly
and we fail to actually develop that in
in a correct way that's something what
is simply can be a total failure for for
the customer you can lose simply put in
lose a lot lot of money doing because of
that and the other aspect of a software
system that we need to deliver is that
the system does the job efficiently that
is for example it scales as the need of
the business scales as well it can
handle peaks of the load for example it
can be officially it can adjust
efficiently use the machines order or
the or the infrastructure of under it it
simply have some kind of set of non
functional requirements
just to sum up what the user value is is
definitely as user the end user the
business user gets the value if the
system is correct is this this is is
this if the system meets the
requirements and if the system it's the
non-functional requirements functional
and non-functional characters okay so
there's the last or final aspect that is
delivering and delivering is the fight
is the actually step that needs to be
done because before before actually end
user or business user will get enough
value from it actually that must be
delivered so same simply so what
guarantee usually the customer has if he
is buying but bespoke software it when
terms to return of investments and
delivering off of the end solution there
is a certain number of research done one
is by Standish Standish house it because
it's the group that does some polls in
annually annually I guess and it just
asks management if the projects they are
tail taking part in succeed failed all
be challenged challenge means that they
are over time over budget or order
without meeting the correct final
requirements and succedent means that
actually it the software has been
delivered with 11 the failed means that
it has not has not been delivered at all
so in 1995 44 we had the succeeded rate
of sixteen percent 531 and change 52 53
and in 2004 the same research shows
shows that we have we had succeeded with
in thirty two percent of the projects we
have failed in 424 and 44 has been
challenged in 2005 another research by
KPMG shows that forty-nine percent of
companies experience project failure and
86 of them experience short phone on rye
expectations in 2007 then another
another poll another article that's in
the doctor job Dorrough it says that
seventy percent projects are doomed to
fail from the start it means that
basically they are not validated
estimated they analyzed good enough
actually and it's known that they are
termed to fight them to fail in two
thousand eight thirty percent of
projects is just the actually has been
successful in government government
projects this is by Guardian newspaper
information by Guardian newspaper it
means that seventy percent is has been
just a filer in 2010 seventy percent
companies experience project by failure
in and fifty percent of them express
short short felan draw expectations and
in 2011 actually there's another another
article that shows that businesses
usually out of the sync with the project
requirements it's it's it has been a
poll in 2012 actually there's another
information at seven seventy percent of
IT projects go badly and so badly that
they can
treatment existence of the company so
that's all of that research shows that
we have done little actually little
programs in delivering user value to the
business customers so basically that
shows that maturity of software
development process and software
development business actually and sector
has a long way to go actually to to to
reach some kind of acceptable levels if
the construction works had the same
success rates or failure rates we would
have more of this definitely more of
this we have only one actually in
geography there's some there was a
certain number number of case studies I
would not like to enter into into
details of it but there was only one
example of universal credit which has
been which should be delivered in 2013
it has been totally reset in planning in
2013 so total failure it just shows that
we are probably doing the programming
and software development completely
wrong this is the sentence i'm not sure
if this is visible enough but this is
the same sentence but justin mccarty
Jenna McCarty is the inventor of lease
so the question is why with the why we
fail due to deliver value is it because
of the software development complexity
or the domain complexity and the simple
answer is that it's above but what we
can do with it we can do something with
domain complexity of essential
complexity by improving improving no no
requirements but we have we can do a lot
more in a reducing accidental complexity
in software development
and the evolutionary step of return your
true nature returning to functional
product paradigm is actually a step that
we've consciously allows us to reduce
accidental complicated complexity and
one of the basic things in reducing
accidental complexity using net ability
that that is avoiding the table state in
know when it's not a good thing actually
to have some mutable variables all over
the place and so you can't even reason
about about it and the bucket correctly
or efficiently when you have something
changed or change in one place or the
other the other place without maybe
deterministically in a simple simple
case but at the end it turns out to be
pretty much undetermined istic there's
also another thing that functional
programming brings this is the awareness
of side effects awareness of side
effects I mean it's impossible actually
to avoid or to not have side effects at
all but if you know where your side
effects are that's the big step ahead if
you can't consciously can can actually
avoid side effects in parts of your
software the view of your software if
part of your code code it turns out that
the coat at the end is really better in
terms of testability I mean it it's
desta bility increases and if you can't
test your code your call is probably
totally or maybe not to tell you but
it's not the biggest quote the best is
not the best quality there's one more
aspect that this referential
transparency and the referential
transparency means that for example
function gives the same output
concerning the input and this is another
this is actually the consequence also of
reducing or not allowing for side
effects in st. Ann's areas of the system
but it can result in a simple pieces of
software that can be easily composed
together and can be nested in isolation
so that's still improved that that
improves also testability and we have a
first-class functions that is functions
as a first-class unit which can be
killed palms together and this is as a
consequence we have also we can have
also higher order functions all those
things are exactly 00 modern programming
languages which are functions to some
extent support all of all of those four
traits but they actually help to help us
to as the versions of software
developers to to use them but it's
possible actually to follow those best
practices also in other languages which
does not actually support functional
programming in an explicit way this this
just means that all those four things
are just best practices that everyday
you as a software developer can use and
as a result you get the system of you
the good software that is testable
and that potentially is of a better
quality this is a statistics from our
one of our projects actually we have in
Scala we have 2671 values compared to 10
variables variables means you type
actually a very able and valence means
it as well vows mean values which are
basically immutable immutable very
values simply values and that shows that
avoiding avoiding mutable stale state
actually is pretty much possible and we
can probably week we can program that
way i would like to i would like to you
also stood i would like to show you also
the broader scope of in a timeline where
we are and what is the potential
evolution steps ahead and just to speed
up we had some kind of evolution
evolution of generation of programming
languages ahead in and in one time
actually the there is a point in time
when the community decided to return to
functional programming to some extent
also the skull appears or other
languages on the JVM that support that
or not owner GV without support
functional programming appeared and this
is a on a timeline we in the same time
in probably experienced evolution of
other parts of the software development
business that is for example PES driven
development or lean kanban or BDD it's
all actually moves us to some time I had
and for in 2015 2013 we that knows what
their languages will be
we definitely will follow some path of
evolution this path of evolution the
main thing in this evolution is increase
increase of maturity of software level
of software production of software
development and with the each year
probably the success rate of projects
will increase but to be honest is at
this moment there is no research that
can tell if functional programming using
a reg using functional program or
returning to functional paradigm will
have enough impact on the success rates
on the success rates of the software
projects but in my opinion those four
things I've mentioned about functional
programming paradigm and functional
programming is one step ahead in the
evolution of the majority of software
development systems or softer
development so let's hope that will
happen are there any questions for that
there's quite a big advantage after
actually of Skala as a programming
language itself so comparing for example
to Java of course the introduction of
functional aspects of an object oriented
and actually managing it together is
something that that that has a great guy
that advantage for us it means that it
means also that we can quite easily or
quite easy start with Scala on the JVM
and move from the Java style to the more
functional style in a gradual way and
everyone faces troubles with hiring this
is the common thing even we had the full
full bunch of software developers
developers actually it it's always you
always have to choose actually you
always have to choose the correct are
correct personalities to your team to
your correct skill levels to your team
so basically that's that's a tough job
hiring is a tough job it is to some
extent but the better that acknowledge
that the better the people who are using
those technologies usually that's the
usual case at at least at the beginning
at this in the beginning but okay
adoption rate and growth rate when it
comes to polish companies actually there
is a few examples that do when the
polish companies already uses scholar in
production and those examples also
include fun business from other sectors
like for example manufacturing sector so
basically basically this manufacturing
sector in Poland is willing to use new
technologies including scholar actually
to gain some advantage our competitive
advantage so that's that's the example
from the from double business site
actually there's also examples of
software house and houses that adopts
Calla as a technology that is getting
getting getting getting more and more
now more and more adoption abroad that
just simply to have the skills level two
and two to be able to develop systems
for fog refer customers
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>