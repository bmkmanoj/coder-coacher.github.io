<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ole Michaelis | Just Enough Plug to Build a Web server | Coder Coacher - Coaching Coders</title><meta content="Ole Michaelis | Just Enough Plug to Build a Web server - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ole Michaelis | Just Enough Plug to Build a Web server</b></h2><h5 class="post__date">2017-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ESzZCaaCzyg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi Alexa Tom so great so great to be
here thanks for the warm welcome
just enough tractability web server
there was a tough title to choose and we
will revisited a few times during this
talk
my name is Ola I'm from Germany and just
to fulfill the cliche I like to start on
time I didn't manage I'm sorry if you
got any feedback during this talk I
don't know you want to get in touch coat
does that how you can find me or almost
all over the Internet unless this Nick
was taken it's complicated
Twitter works you can also find my block
and coated for the new way I don't block
so my blocks turned into a website this
is how I usually go right everyone's a
medium now I'm also running the hemlock
elixir user group and we invented the
LexA cocktail if you haven't seen it
it's pretty pretty much worth a look it
looks pretty cool it tastes okay I work
for a company called Z and simple you
might have recognized us because we do
this awesome stickers but we're not a
sticker company so we're dns company and
we do everything you need to do we had
you doing everything you need to do with
DNS so we can register domain manager
and we have a pretty awesome API and
also an elixir and official Alexa client
talking about stickers I also have this
sticker I have it with me our official
ixr one and I hope this is another
additional motivation for you to stay
around because I want to give it away
after my talk so justify just enough
flexibility web server what like what is
in there actually there's a lot of
filters obviously so we have clock we
have web server and we have the part of
building it and this is also the three
topics I want to cover in this talk
let's talk clock imagine you've never
heard something about Clark and I am
sure the truth is the opposite so you've
probably all heard about it but if you
don't know it you will go further
in your head if we get her Bravo and the
Gator Bravo has pretty much on there you
say above the fold so before you're
scrolling unless you're on there like
really weird device you can see the
following explanation with luggage first
it's a civic it's a specification for
compostable modules between web
applications and second a connecting
adapters for different web servers in
the a language M which is funny because
if you check the actual implementations
s just want to dab the for cowboy but
it's you know the option it's about
having options and like really delivers
on that well worth of words and if we
are if we are in a like in the coding
world code matters so let's take a look
at how the code actually looks like and
then the interface you all probably are
all familiar with so we have the import
clock connection then you have a
function called init and then we have a
function called call we will revisit
this plug a few more times during this
talk but this is just how clock usually
work and all the web magic happens in
this call function but flex this this
alone is not like this alone is not a
very powerful tool that a key piece
missing to this which I like to call the
plug of plug and the plug of clark's is
basically a way that plugs that plug
gives you to combine multiple flags into
a single one and that way you can
compose like really huge app so let's
take a look at how this would look like
so black ships with a plug builder that
gives you a macro the plot vector where
you can put together different blocks
and every plug is sticking to the UNIX
philosophy of doing only one thing we're
doing it really well
you can also override the init function
and big hole function but this is
already optional so just the upper part
would be enough and I'm pretty sure you
have seen this behavior before
can recall where use it probably every
day if you're working with this
framework so in Phoenix when you use the
Phoenix router this is basically what
the Phoenix router is the Phoenix router
is a clock it is a rather complex lock
it offers a lot of like flexible option
of putting it together but in the end
this thing and this is just like the
default generated scaffolded router
strip down to like fit on the slide this
is the plug adjust height a lot of the
calls but here you can see that you like
plugging together and this is where the
name comes from
you can plug together different aspects
of your app and different behaviors of
the app so under the hood Phoenix is
just a router it's a big router and does
a lot of other things as well but that
is this router well there was a plug
part of the talk now let's take a look
at web service and first let's address
the elephant in the room who with the
brain in the head whatever comes to the
idea to write a web server apparently I
did or at least I had the idea to do it
and I found myself like in the process
of doing it that it was a really stupid
idea so in preparation for this talk I
came up with the idea to create this
thing which is called stupefy which is
the most simplest version to create a
web server and this is also what we are
going to see in this talk now
so I want to walk work with you through
this thing and how it was created and
also what code is in there to actually
make it work and a little bit of a
disclaimer here this thing is really
stupid all the code is kind of
there are no patterns in there and
everything you should like everything
you see here you see here you should not
do in your actual extract so it's like a
counter a counter example
there's almost no HP in it and talking
about OTP and
Airlines you have all heard of a ladder
crash this was this web server just
crashes so it's just
it doesn't get restarted or something
it's also not sergeant also not threaded
or something so it can servicing a
request at a time and when there's a
second one coming in just has just a
wait um but still and I think this is
what cool about this it's very simple
and that that is why it's super and also
easy to follow and you will see this in
few slides so let's let's take a look at
the HTTP protocol probably you might
know this but I want to just cover it
really quickly so we are on the same
page we're taking a look at HTTP 1 1
this is totally different for htv-2
I gave a talk at electric homes in
Orlando last year if you want to know
more about xv2 you should definitely
check this out but for the simplicity of
this talk we'll just stick to this
protocol it is a text-based protocol
this is what makes so easy
and now let's dissect it and let's see
what is actually in there so it all
starts with the request line so that's
the first line the protocol it has the
HTTP verb it has the path over here and
it also has the protocol version then
you have request headers head us a
usually key value pairs everybody colon
and then it's a functional programming
language so we have a maybe body I
thought it was funny was writing it and
then in the next so then there's an
empty line in the text base protocol and
then the next time you see is the
response from the server and it always
starts with the status line which
consists of the HTTP version then the
status code and the reason phrase and if
you want to like discuss if the reason
phase make actually sending text comment
I'm all into this discussion because I
think this number is totally enough then
we have response headers had a same
thing he value pairs what I think is
pretty interesting on headers there a
lot of like caveats and they're each
like almost each header has its own its
own kind of data format and you really
need to know they had a key in order to
pass the value like date it is obviously
a string but if you want to represent it
the actual data form and it could be an
elixir date also content type content
type is a basically list separated by a
semicolon while cache-control even
though not in this example is also a
list but separated by space so it should
be had a are really a horrible thing to
do with when it's just because it is
like that because it involves over such
a long time and then there's also almost
always may be a response body so let me
show you how to build a web server with
this fight with this five simple steps
and now we come to meet on what the
building actually looks like in order to
do so you start with listen then it
comes to accept parts then you delegate
and then you respond this is the five
steps you need and now I want to walk
through all the five steps and also walk
through the code and let's do it all
together to see what's needed to make
plaque work let's start with listen so
you're some electric code this looks
almost like an OTP app it has the same
interface it does not have all the
upside but I wanted when I just do i8 -
ethnic I wanted to start automatically
this is why it has the interface of an
OTP app first thing we do is we open in
TCP socket on the specific port the port
is magically appearing in here and the
options I'm passing here is binary to
receive data as actual binary instead of
character live then we have packet line
that tells gen TT P to return data line
by line rather than packet by packet and
also access Hall tells gentility to
block on education regen tcp receive
answer data is available and then we log
the line that the server is not running
here you see the only like concurrency
thing i needed to put in here because
this is no TP education and OTP
applications need to return immediately
so I got the control flow in this task
in order to like step out here and then
return okay and the pith of this thing
so here you see that that's the
interesting whole pattern here right so
this brings us to the next step of
building this thing which is the accept
step so it's a loop that also what they
function suggests it gets the socket and
Clark and what we are also doing here is
we are accepting a connection this gives
us a single TCP and the thing will
active TCP connection and then we pass
this connection down to a serve function
and then the search function returns a
stupefy request this thing is alias here
at the top and base of the request and
returns request and then there is the
request will be passed down to respond
and respond also takes the clock on the
actual client responders responsible for
for doing the actual TCP sending and
thus after after responders down we can
just close the client and then continue
to the acceptor and there you see it's
just a quencher there's no the second
sign needs to wait this is a rather
crucial part of the webserver here and I
want to take a look at this struct it's
really simple it has the three keys the
one is the waiting we're just kind of
like it's a state machine and it tells
the request what should be next and
you'll see in a second I'm how I'm going
to use that then we have a list of
headers ahead as a tuple of two Springs
basically and then we have the status
line which is the status line so with
this request you can see that I'm not
even considering dealing with bodies so
there is no request body in this simple
example so let's take a look at the
search function the search function is
responsible it's responsibility to bid
up the request and here you see like how
the state machine is kind of functioning
because I'm pattern matching on the
waiting key and if I'm waiting a
response
I'm terminate
the sir function so the serve function
is a recursive function here's the
actual implementation so you get again
the socket and the request object first
thing you do your pipe was talking to
read nine that's very thin wraparound
gentillesse if you receive so you get a
nine back you pass that line and fill it
in to the request and update the request
so we pipe the extra line to Paris parts
get line as requests and then we update
the request and then we loop through
serve let's take a look at this demo
because that's the next step in building
website that's at our step house look
like again it's recursive or as a multi
multi function motion head avoid he had
a function and again when we're waiting
the status line and this is the that's
the first thing that's like the value is
initialized with because this is what
you see the first and request right so
it should start with that and when you
see the status line or when we get data
and we awaiting a status line we know
that the data is data science so we
update it and then we know that we are
waiting headers we know that we're
waiting at us because regarding to the
RFC every request needs to have at least
the host header so we know that there's
at least the hotel unless it's not a
valid request and then it's okay to blow
up this is again determination function
so when we're awaiting headers and there
is not anymore so that's the empty line
between the request headers and their
request then we just said that we were
waiting in the response now because
again we don't deal with response body a
request what is here otherwise we would
set this to body now and then parse body
is there the body or not so this would
just complicate it more and then we have
the case where they are actual headers
coming in so we're waiting headers this
data and this doesn't match so we know
this is a key value power and then we
update we possibly had our dependent to
the headers and then we are waiting more
headers because this could match if it
is that was the last header this one
will match
now we come to the interesting part now
we want to connect it to plug and how
how does all that work this brings us to
the delegate let's take a look at the
response function so remember respond
get the request so that's the soup if I
request then we pass in the plaque and I
want to talk about this in a second why
it is a tuple and then we also receive
the socket that's the code of response
and here we really see how plug gets in
here and here here we come to to how
plug interactive all of that first thing
we do is we build up the connection and
the connection is the crucial as a
crucial part of clock and I want to show
this in a minute and this is a little
plaque struct
it's called block on and this one is
passed to plug to the plug we get passed
and we done it only passed the plug but
we pass down a tuple so we pass down a
tuple because we need to initialize
every plug remember that was the plug in
it and we did this right at the
beginning so you only do the init one
and the energy whatever the energy
return is the options the plug will
receive when you call call on it so this
clock variable here is module it's an
elixir module and due to the fact we
know it's a plugs we know it supports
the call function and then we pass down
the connection that could get build up
here and also pass the option this is
basically well the magic happen but it's
just a line so I want to like dig deeper
into these both of these calls in a
second let's take a look at the track
connection now so the plat connection is
a simple struct with the mass of 140
language documentation and around 3035
struct and then it has a few supportive
methods it's really interesting so if
you want to read any any like any source
file in slack I really recommend to take
a look at black-owned because it has all
the greatness in there
um also you see like how to write
extensively so dog that's pretty great
so let's take a look at this track again
flat con is a struct it's a module and
has a struct in it and just consists of
a very variety of different fields and
in order to like make sense of all the
fields in the documentation the skis are
grouped so I also want to like introduce
them in a group manner so it has the
request here's the patchable fields and
the response field starting with the
request fields we have the host which is
passed out of the host header which is
usually wwx amber calm then we have the
HTTP method or get post options had we
have the request path and they could the
issue with the request path is then it's
usually a list uh no that that's not
right the request path is Nautilus
that's a string 1 NS pass info which is
a parse segment then we have the port we
have Pia and remote IP that's a pretty
interesting combination so peer is the
actually TCP peer the server is
connected to and remote IP is meant for
other plug middlewares that understand
like the X dash forward and for headers
to populate this series so this is what
you are connected to and in modern like
application setups this is usually a
local answer because yellow buttons like
dispatched in TCP connection and then
the remote IP which gets populated in
the latest step with whatever you like
whatever the customer wants you to know
two things the remote IP is because
getting an actual client IP is almost
like there is no guarantee that you can
get it so be aware of that then we have
the request headers which is a list of
tuples we have the scheme with HTTP or
HTTPS and like many 99.9% of the cases
then we have the query string and a few
other fields like I mentioned path info
and script name but I don't want to dig
deep into them here we have the flexible
serious and I think tied to a catchable
fields are pretty interesting because
they are only populated
when the blackmailer will request them
so you don't have this here set unless
you fetch cookies or your fetch body
programs you have query parents you have
passed parents and then your parents
which is all of these three combined in
here so you really need to call like
fetch cookies or fetch parents in order
to this used to be populated if you
don't call this before you get an plaque
on untouched struct and yeah that's used
to this is used for pattern matching so
that you can pattern match on the struck
that's pretty pretty handy as well
then we there's also request cookies but
the difference in here is that the
request cookies are not modified where
the cookies can contain request and
response order cookies then we have the
response here obviously starting with
the response body the response character
said the cookies and the headers so
these are only the cookies you wanna you
want to set right ndnd response and then
we also have the status code and this is
pretty interesting
we only person integers or the reasoning
phase is not part of the struct and we
reconstruct later on and we will see
this in a second as well there are also
two more categories but they're not part
of like what every user of plug should
know because they are kind of only for
implementers or people that deal with
the actual library or writing their own
plugs and the private theories are the
adapter and then a field called private
private is really as a shared is meant
as a shared library and should share
library data as a map and then the
adapter and this is also what we saw
ready it's a tuple so it's the first
thing it's module and then the other
part of the tuples of the index one
element of the tuple is what they call a
payload and we will see like how this
works in a second as well then we have
the connection field we can actually
feel it has a sign which you probably
all have use because this shared you the
data as a map so if you want to transmit
any data from one plug to the other you
would
at the assigned field then we have an
owner which is the process ID of the
process that owns the connection and the
case of stupefy is really easy it's it's
the task the only thing that's running
it is used because Clark sends messages
to this process along the way of pausing
and dealing with the request then we
have halted that's a boolean flag in
order to know if the pipeline was halted
then the secret key base you probably
deals with that if you want to get your
test pass because you need to set this
from the outside this is not populated
automatically because no one should know
the secret that that's what secret means
right should know which no man and then
we have the state as well and the state
is the state of the connection so it
starts with unset because the response
body is not said then gets to set and
then to send or chunks depending on the
response model so let's jump back into
code and then let's take a look at the
build connection because this is really
where we make this where we bring
together our stupefy server and the plug
and the plug connection first thing we
do is we pass the status line it's just
separated by white spaces so we just
split in white space and we get the verb
we pass in the version then we transform
the headers into a map and also access
them more easily this is kind of
dangerous thing again don't do this
because had asked an actual move to the
times and that's okay in HTTP
we would lose this year and then we're
building up the like the minimum set of
fears we need in order to make this
connection working so we have the host
we set the method and we said the
request path we said the request headers
we also set the scheme and then the
adapter and the owner and I really want
you to take a look so to look to this
line because what we're doing here is
we're setting the adapter and this is
also the thing you saw before and the
adapter is not only the module but also
the one what is called payload and flag
in order to identify the actual
connection so you need a way needle way
to reference back to what what
connections should the recent to be
Center because you're passing away the
the module and the deuce exactly there
is no stage the need to pass along the
state and this is this is basically
passing along the state of the web
server in my case it's a it's a socket
so the Alan Park struct or a court data
type it's I think in cowboy is the
struct you can basically use any term so
you could also pass along pit integers
whatever whatever is necessary for your
case we receive this in a second again
so let's take a look at the response
function so now we've lit up the plug
connection so now we have an actual plug
connection and we're passing the plug
connection into the plug hole so plug
again it's the module and the we know
due to the fact that it's a black comedy
module we know that we can call call the
function call on it with the connection
we just filled up and the options we
initialized at the beginning now let's
take a look at the clock again this is
what we're just calling so we pass in
the clock connection and we have the
options so that line is pretty pretty
important so we import all functions
that I define a plaque on in order to
make our plug work because we are
calling this function over here what I
also want to point out here is the
options you receive here is when you use
the plug builder what you pass in as
argument you can transform them if you
want in this step and whatever you
return here is exactly what you will
receive here so you could modify it here
or initialize it in any way it's exactly
only need to run one you could even you
could even start like complete
supervisors if you want to do that and
then return the pit and then you would
get the pit again passed down here so
that's really flexible and then when we
do here we pass the connection to the
function foot response content type
which is text plain and
we passed down so that's also a
contractor flock you always return an
updated connection struct so you just
pass around the connection struct and
everything you need and plug is in this
connection struct so you pass around the
clock this plug connection this will
return an updated clock connection with
the correct header set and then this
will also set the state except because
we set the written the response body
it sets the status code and also the
body so I want to take a look into what
is happening here because this is a plug
function this is not something or web
server does but still it kind of needs
to interact with our web server right
because this does not send it yet so
that we actually plug in the
implementation and want to give you a
second to grasp it so you see on the
method as a function send response we
pass in the connection vector again we
match on the state because in the in the
real implementation there multiple
function header matching other states
and like doing appropriate error
handling and then we also again pass out
the adapter and here's here's the thing
again right so you have this tuple which
consists of the adapter which is the
module of your webserver and then
whatever you need to identify your web
server or the connection on your web
server so our case this payload would be
the Ln port well socket then we also
have the owner this is passed parts out
of the connection here because in the
real implementation that has more code
than what I'm showing here it's also
sending a message to the owner that this
thing was sent but this is the
interesting line so on the module we
pass in we call send response with the
payload in order to identify it so now
okay to the socket we pass down the
status the response headers and the
response body next thing we do is we
take a look at this function because my
adapter which is the 2p file web server
needs to implement this so now we are
coming to the response phase even though
in the plug world we are
spawning already this is now where it's
get passed down to our web server so
that's the send response and stupefy
this is the payload again so you've seen
that we pass it all back to clog and the
adapter to Poe and then we now get it
back in order to identify where we
should send like the actual body like
that is the socket where we need to send
the content to because again it's all
stateless and the web server doesn't
store anything first thing we do is we
ask to the plac status util to give us
the reason phrase for the status it's
important to do that if you ever find
yourself opening a web server because in
flux you can set your own response
reasoning phrases so you could for
example override 200 to not be ok but
rather I know I did it whatsoever you
can also define your own 1 define your
own integers and the reasoning phrases
and this line supports that and then the
next thing we do is already writing back
to the socket again read line if like a
release then wrap around gentie CP sent
it gets the string that you want to send
and the socket and we send the
hard-coded protocol again it's just the
very simplest version then the status
and the reasoning phrase that's the
first line that's the status line then
we send had us and this is again a
recursive function because they could be
multiple headers that cause like this
thing called sent had us on its own
again and sent each header so it pops it
from the stack and sent it again I'm not
going deeper into that function then we
are writing another line this is empty
line because there need to be an empty
line between the response header and the
response body and then we are writing
the body line that that's it this is the
whole response stem then regarding to
the plac protocol we need to return a
tuple the first thing is okay or error
depending on if it was successful or not
in our case obviously it's always
successful all blows up this is body
sent but in actual representation this
is
manager we said - no because you like it
should not give you the impression that
you're still able to modify it because
it's just not there anymore because
you're standing over the wire this is
used in test in order to assert we see
this in a second again and also we
return an updated payload because
imagine this would not be just a port
but this could be a struct or appeared
or it could be whatsoever so this this
line needs an in mechanism to update the
the payload and return it back to the
block so Plex support a concept called
adapters and this is really what you
think it is it's an adapter to support
different web servers if you check out
the source code and github the a cowboy
adapter and this is what you use
probably every day when you start a
Phoenix app that's basically the default
go to adapter because it's there for a
long time it's pretty pretty hardened
and also pretty stable and this is the
behavior you need to implement so we
just saw the send respond and you would
also need to have implemented the other
callers here and I want to get over all
the callbacks now really quick so the
first function you need to implement the
send response you get the payload of
this alias headers of the body and then
you meant to return the tuple okay with
a send body again this is only meant for
test cases so you can test your plug and
then assert on the body that was sent in
real implementations you better send
back nil because the it should not give
you the like in the idea or a false
sense that you could stay modify it
because we've gone and then again the
payload an updated payload then we have
sent file which is for sending files to
get the pail of the connection status
the headers then defiers a binary often
in length or you can just send
everything in once it returns okay then
the sent bodies are basically the
signature similar to that thing then we
have sent chunks you get the pair of the
stages and the headers and you have them
actual Chung which gets the
the status then you have a function to
read the request body this is one of the
vegetable fears though that's not there
every that's not always there then you
need to fetch it and also it improves
like the performance because maybe
there's a request like a hat request
where I don't need the request body and
then you would not time it would not
waste time to reading it from the wire
or wasting time in Parden yet it has a
more complicated way of returning or
much good weight is returning and then
you also have past requests multi-part
HTTP multi-party basically how they made
way to the file uploads work in HTTP I
think it's really butchered but oh it's
really complicated it's just really
complicated thing and this is how plug
supposed to that that thing and if you
want to write your own web server for
plug so this is this is basically all
you need this is just six six functions
and construct them don't the plug and
when I like doing the research for this
talk I was pretty much blown away that
it is really that easy and this is all
you need and in the example of stupefy
the only thing I needed is what's that
so that thing a function at the plug I
show you before that is everything you
need to make it work so during all of
this I really realized that you can
learn a lot from clock and I was
thinking about why it is that way and I
came to the conclusion that plug is one
of the first things in Lee was one of
the first things that exist in elixir
and also almost all the core members of
makes a contributor to it and if you
want to see a library that is really
written in a way that commerce would
write a library plugs is probably one of
the ones you would take a look at right
other than echo and hacks and this kind
of stuff this is one of the car things
and I thought while reading it that is
pretty cool to learn from them and to
get a grasp on how I should write a lick
sir and I was trying to extract a few
patterns or if you say
that stood out to me while reading the
thought and I want to share this with
you now and the first thing that stood
out was the idea to pass around modules
so passing around the tuple of the model
of the arm of the module and the payload
to identify your request that was
totally new to me I was not aware of
this concept elixir and I think this is
this is so great this gives you so many
options and so many possibilities in
your own code if you're writing bigger
application to pass around an extra
reference and be the reference like
exchangeable that is that was a pretty
cool thing and also struck over gen
service and Jose was planning pointing
that out in his keynote yesterday as
well and also Sasha wrote this blog
article about spawn and not to spawn
where he talked about process boundaries
and function modeling and this was also
what I was realizing when I saw this
real flux where I had this connection
struct
it's a struct that consists of 40 fields
and has like this 140 lines of
documentation and this is really this
really stood out to me because I always
thought an elixir is the way the way to
go is spawning a gen 7 then passing
around pits but this is not how it's
supposed to be a Sasha wrote in this
blog post that processes and also hosts
accept roses are not a language design
tool it's a concurrency divine tool and
this was another thing I really realized
and having a plug having it distract
with 40 fields is not it's not a bad
thing right you should not feel you
shouldn't think that the code smell it's
a good thing if it makes sense and then
the other one is the really really
simple API so think of the the API of a
plug it's basically two functions it's
in a nun call and these two functions
you can have the thing like the Phoenix
so that's super powerful also
implementing your own website with just
six functions that was really that was
really a mind-blowing moment for me and
I think when I am writing software now I
really think about the API that I'm
exposing and I try not to make it super
bloated and support
every use case and adding methods of a
method maybe even different IDs and
making my documentation more complex so
now looking at all of you I know you
have one question still open does it
actually work and I really like if the
demo gods are with me I want to try
there to demo it that is definitely not
big enough so can you read that now I
think that's good so that starts the
stupefy server and I was running on the
port 4400 and then we have this one here
so just make this bigger so just trust
me it's there and then I do a code
request through the same thing and you
see we have everything we need here so
curl is firing and then stupefy is
actually passing this to plug and then
black returns HelloWorld with this just
you really and I'm not kidding here you
saw all the lines of the 2p5 web server
there was nothing I was hiding this is
also why you see destruction there that
is that is it this is all you need to
implement a web server and this was
pretty pretty cool I think now let's get
back to my slide so yes it's actually
work this gets us back to the last
second here um I have two stickers up
here so when I'm doing Park I invite you
all to come come up here talk to me what
plaque talk to me about DNS simple if
you want to try out our service you can
have one month for free using that URL
and that's all I got thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>