<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Claudia Doppioslash - Building a Graphical IDE | Coder Coacher - Coaching Coders</title><meta content="Claudia Doppioslash - Building a Graphical IDE - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Claudia Doppioslash - Building a Graphical IDE</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jggRmf_XXkM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to this talk about making a
graphical idea with Alan and pure script
I'm clouded up you / I'm a game
developer and the functional programmer
and you might have read my functional
programming articles on lambdak at my
website and I work for path sitting here
gmbh where we make embedded hardware for
indus automation and the automotive
industry which may end up being
factories like conveyor belts and
uploading firmware on cars this is some
of the stuff which runs our beam
actually so we have AB in runtime that
runs on the hard way this is a video of
the conveyor belt working and we also
make embedded hardware there's a
wireless port that runs the Erlang via
so you can program with any Erlang
language unit it's got as I said
Wireless and also it's a real-time
operating system right so that's
Parramatta and I guess there are a bunch
of reason why you might be here one is
that you need to get front-end code done
and you hate JavaScript so who is like
that that's always a good reason also
you might be interested in asking like
languages and we'll talk a bit about
three of them today
so that's should be worthwhile and you
might also be undecided and we didn't -
if whether to choose that in more pure
State who here is undecided on that a
few that's good hopefully you will
hopefully you have more you know more
about it and be able to make a more
informed choice so what you're getting
is working progress Morton we have this
project it's not finished yet but it was
several it has already been going
through some a bunch of stuff so I'll
talk about the choices we made and what
was I what went wrong and and I got give
you an overview of elm and pure script a
very quick one and also of our
experience of porting
from and pure script so this is not an
alum or pure script guide and also it's
not about the latest al so it's not
about 0.16 it's about 0.7 little 0.17 is
about 0.16 and that is I guess an
interesting thing to talk about so the
jump between 0.16 a 0.17 removed all the
stuff that you see there functionality
of programming build boxes addresses
signals and fault P so if you see any of
that in the talk you don't need to know
that to do one now and I'll talk to you
about later about why all that happened
so the project is a visual idea for a
PSE language Piercy stands for
programmable logic controller and it's
sort of a parallel evolution of embedded
hardware programming that is used in
industrial automation there you can see
a function block which is so it's a
visual language I used these function
blocks and you can see some of other
editors the other side to make these
editor we were inspired by Brett
Twitter's inventing on talk and we do
principal talk which talks about how to
make better experience for programmers
by making interactive editors so this is
our editor I'm afraid I would have had a
demo but since the computer
malfunctioned
this is all you're gonna get I'm sorry
so basically you see the function blocks
on the right and the on the top there
are the events and they fire in red and
on the bottom of each function block are
the variables so with our IDE if you
click on the variables you can get a
plot on the other side that shows you
the last values of this variable for the
last 60 seconds or so which if your
software runs on an embedded hardware so
it's hard to get to it inside of the
bucket this should be very helpful for
people to make a better programming
experience for PSC so this is a bit
complicated and show your graph a
project so we have the POC language
people program in this PLC language
their industry automation stuff and we
have a compiler that takes this PLC
language and compiles it whirling
about basically being files and this
beam files run on the hardware so we
have at the beam running on the hardware
and also Cowboys running on the hardware
so cowboy talks to the runtime of our
compiler and our program and it gives us
the bugging information we can use in
the IDE the requirements was these were
pretty broad it had to work on all PSC
os's
and also an iPad pro so not the iPad pro
is powerful maybe not as powerful not as
powerful as a PC and also the
performance need to be interactive
because we have those graph updating in
real time so 30 fps we thought should be
fine
we had a few options do this like making
native applications for each platform
that would have taken a lot of time and
be very expensive so we chose to do
welcome to use web technologies so we
can be cross-platform as that would mean
javascript SVG and CSS but we thought a
minute and said do we wanted that to the
JavaScript and yes it is well no please
let's not do that it's not bad but
that's not so the possible choices at
the time for language that can pass to
JavaScript that is not JavaScript were
closure scripts CoffeeScript l and
typescript so by the title of the talk I
guess you you can guess what we chose
but a reason for it is probably
interesting so the main thing we were
wanted to have was functional reactive
programming because being an online shop
functional active program is sort of a
thing that felt familiar to us but that
is now gone is representing it's gone
also the good of messages were a pro
they're certainly better than undefined
is not a function
so that was there was something very
motivating for us also some concepts
were similar to Ireland like mailboxes
so it was familiar you felt familiar so
what is that you probably already know
this but I'm going to go through it
anyway it's a purely functional strongly
type eagerly evaluated language that
complies to JavaScript it used to have
functional reactive programming it used
to be based around it and it's also got
a syntax that's very asking like but
without the squiggles so you don't have
the dollars you don't have the starship
operators or more strange operators and
it's also very small language and they
try to keep it small they're very
darkonian about is actually and from
0.17 it's optimized about learning
curves so if you start to learn you
shouldn't find any point where you get
properly stuck hopefully so it's similar
to a skill but you don't have type
classes basically another nice thing is
the unpackage manager enforces semantic
versioning which is a bonus so compared
to javascript the pros were if it
compiles it works and I can say 90% of
the time that's the case unless you
actually deliberately getting rid of
some type of information so you if you
need to render some SVG you have numbers
before calling this video function
malice Ouija only takes strings so there
you lose your type information and then
if something is wrong you get a nice
runtime error when you run the SVG so we
can be confident or refactoring because
of set types and it's also very clean
and you can get much further with fewer
lines of code than you would in
JavaScript and the famous great error
messages are + so those error messages
they work because they are contextual so
in this case you have a case and you're
missing one branch to be a total
function so you it shows you your bit of
code you don't have to fish get your
editor get the code and find the place
it will show you and it will also
correct common errors so
here the solution is simple so it just
tells you what to do which is helpful
and how they do this how they achieved
is greater our message is what the first
thing is they make it a priority so it's
really important for them to them
community to have read our messages so
they carefully track them on our git
repository and people can people can
send their own error messages that
weren't clear so then Evan can look at
them and make them better and another
reason why they're able to do this is a
type system complexity is not that
complex so it's easier to have good
errors if your type system it's not that
complex but in my experience in 0.16 it
might be fixed now I don't know if you
have a big program and you're calling
something a bunch of times in different
places if you get the types from in one
place it will tell you the definition is
wrong so then you have to fish and Ford
all the places where you used it which
is less than idea that's not a big thing
and if you've seen the word talk you
will probably agree that elm actually
makes sense compared to JavaScript for
example this is what used to happen in
JavaScript if you did array 16 you get
16 commas okay well Alamut really makes
sense it doesn't do that so there are
also cons compared to javascript the
JavaScript interoperability
is a bit inflexible it's a bit more
flexible in 0.17 but it's done that way
if I mean it's a conscious choice so
it's gonna likely stay that way and it's
also a new language which is zero point
X so there are gonna be changes and they
might be big but all in all it's not
done much so that was an easy choice
so what project we're back to the PLC
board there is the beam running on it
there is a PLC program running on it and
then we have cowboy and bullets running
on the same team and they talk to each
other and through WebSocket they talk to
the browser which is running the bullet
client library which through ports two
one ports is talk
to our WebSocket library which is called
alma rank and we have a socket library
because at the time and didn't have
WebSockets and it's basically a wrapper
of Hulett and to arm run and one gets
the Jason from the WebSockets and gives
them to our PLC ID so later on I'll show
you another graph about the PLC ID I was
supposed to have demo here but no I hope
you remember the image from before
so the PLC ID structure is so we have
the PC device we just saw what happens
on that and we have a socket library
which is a component and we talked about
later what is a component in this and
then it gets the adjacent messages to
one other component which is the decoder
the decoder sends them to the renderer
which keeps all the state in the app and
those renders it to the browser and then
you eye interaction is sent to the
encoder which is another component which
send this back to the WebSocket library
and it gets back to the PC device so for
example I could open a variable path
States from the web browser just by
clicking on it and this whole
communication goes on so which one of
these components is a startup setup is a
concept that was in 0.16 which is
basically a library that implements the
Elm architecture and the names are you
probably familiar with the ARM
architecture but the names are a bit
different is your by 16 so I'm going
through it very quickly and beware this
is not how it works in zero PI 17 so we
have an action which is a union type and
it just anything you can do in Europe so
if we have a counter you can only have
increment or decrement then there is the
model which can be any data type that
you want but here is just an int because
it's a counter and then we have the
update function which takes an action
and the model and gives you back the
other model so we have increment model
plus one decrement more than minus one
and then you have the view that is
passed a new model is part of you ignore
the address here because that's
0.16 it's not
that anymore but so it takes the model
and gives you back the HTML that you can
render so in this PLC IDE we have those
components are actually startups and
they're wired by mail boxes together and
then we put them into a bigger start-up
and then we were that into the main so
that's how everything is wired up this
structure was invented by a github user
called Fox Donuts and we used it because
it's easy to expand it's easy to add new
components and the effects from one
component if FX on one component you
don't necessarily need to have effects
in to another component but no one
ported this will be zero point 17
because it was signals and for pees all
over the place mailboxes a lot of them
so it might be impossible it might not
be impossible it's surely not trivial
and our web server web sockets library
can be a component using this structure
we were supposed to open source it but
then it's not really relevant anymore so
we didn't so why are we still 0.16 so as
I said we use a 4-peat very heavily and
also this project was for a client so we
cannot use an unknown number of weeks of
money from the client to parties because
we're not guaranteed to have a result
and also it works so if it works don't
touch it it's cheaper and we were also
frustrated with lack of communication
because from 0.16 to 0.17 there were six
months and in those six months it would
have been nice to have a duplication
warning instead of just finding out on
the 0.17 half a day that everything was
gone it was a bit of a drama so we're
waiting for DNA evolution to stabilize
maybe come back in z 1.0 of slightly
earlier to see so we know what we're
getting pretty much there was a bunch of
production problems to get Erlang
working with al which are not big
problems but it's probably interesting
to look at them anyway so the main one
is out organized sub components in a big
al map and that is a big topic in itself
and I think is still a lot fun
at the time at the moment and also to
store dependencies which cannot be on
our package because an package doesn't
accept JavaScript files so your
libraries have to be completely enough
and also how to include end projects
inside an ER long up so my solution for
components is this and I got it from the
structure that I talked about before so
action model and view and update I have
shown their own file which you might not
need if you don't have that much code
but once the app gets bigger it's pretty
useful and also there is a feature file
which may be a bit strange you might not
have seen it and that's from that
structure I talked about before so in
the future file you wire up all the
mailboxes so you can build your
component and then in the app file we
wire up those mailboxes into a bigger
one and then we wire that that component
into the main because the main takes I
need an update and of view functions you
might remember so in its that needs to
be one point to wire everything up about
having dependencies which are not on our
package it's not hard but it can be a
bit tricky so this is how we did it so
we have our own repository and we saw
it's in a subdirectory of the Odin
project so we had Aaron it's a
subdirectory of the Orlan project we
only move the N files to a subdirectory
of the un-- project which is not
shouldn't be under unstuffed directory
because that's where the unpackage puts
their own stuff you don't want to mess
with that and then we include a
subdirectory into the unpackage so jason
so the young compilers knows how to look
for the files and that works and also
slightly more interesting problem is
Ottomans Hellman Allen project we could
have done it in a number of ways but
what we wanted to do was to have Allen
projects that have their own elm apps so
in the end they said oh I've been
different repositories it was easier to
just have a subdirectory
inside the
Aaron project and then we compile the
file them files to the proof directory
which is where cowboy gets their static
files to serve and then we just add the
JSON the JavaScript file to the HTML
file and that works about rendering so
this is an interactive application so
rendering needed to be decent decently
fast there were a bunch of choices the
first one was to do a WebGL 2d rendering
engine which would have been great I
would have loved that but we didn't
really need to do it sorry
another choice is to just use HTML which
is last an idea and the other choice is
to use SVG's we don't without CSS layout
and animations so in the end we use SVG
with CSS as much CSS as possible because
ideally you wouldn't want to do too much
animation we're done because keeping the
animation state around is awkward and
inconvenient although there are good
animation libraries from if you want to
do that so we have an expert in SVG in
CSS expert on call so we don't have to
know anything about this video CSS
because so many things can go wrong with
that so this person just does a magic
she produces the CSS files and those are
separate files and I get to write by
hand
inside the file the code to generate the
SVG files as she said one note about
that is that I think that I'll match the
marinum SVG which are the two libraries
that you can use in on two generators
which in HTML have great syntax because
for example here is you can have the tag
the tag name and then you pass it to
lists the first list is for attributes
the second list is for the tags that are
inside that tag and in my remind you of
hiccup from closure I think it's very
elegant as relevant as it can be without
being a lisp
and it's also based on virtual Dom which
is fast and you might have seen around
benchmarks on how fast armies and I
think they're pretty nice gets a good
rap about that so closing on our elm
section I think if you want to use them
for your project there are a few things
you should know about so the first thing
is be aware of what Elm is good for
because I'm is very opinionated and if
you do use the the case that is
optimized for then it's you can your
sailing is moot and everything works for
you and but if you're butting heads
against them it will fight back so it
will be hard so probably you don't want
to use it for stuff that doesn't fit the
Elm architecture so take a good look at
it and see if your project fits with it
also if you want to wrap big JavaScript
libraries you probably don't want to do
that in al unless you were bleeding in
two parts because you have to make
everything pass through the port also
you can't get them into one package it's
actually easier to get em inside react
than it is to get react inside al and I
think on the on website there is a way
to do that with an aside react as a
component also al mr. experimental
subject a big changes so be ready to
write some code and correlated that is
unlocks a roadmap it's all in Evans mind
and we're not quite private which goes
on within it we're more private now
because it does share with the mailing
list the album that mainly lists what is
thinking about so at least you know
what's going on in his mind and what is
working on but before between 0.16 and
0.17 you can only know that by checking
out the comments on the n compiler
repository which I didn't do
so what next we're going to skip 0.17
probably 0.19 and maybe come back when
enemies need at one point zero or at
least when we have reasonably sure we
know what we are getting
I mean why we are in the market for
another compiled to JavaScript language
so and we might put a portion of our
project and make new projects with them
so more choices they are breeding like
rabbits so there is reason now there is
back on script there is fable and there
is pure script I think you know which
one we went with so we have to choose
wisely with right so first choice was al
it was very cute it told us please adopt
me I won't mention Mona's everything
will be easy and it was very convincing
and our second choice is pure script NP
so it basically says you're free to do
everything as long as you can make it
compile which is very freeing after
having worked with a very opinionated
language that says you should do this as
I say and not anything else so pure
script is a purely functional strongly
typed eagerly evaluated and compiled to
JavaScript language does it remind you
of anything so that with that we were
fairly sure if we were continuing our in
an evolutionary way in our road and so
it also has advanced types like mono its
type classes monads that sort of stuff
the ethical like syntax is really asking
lies you get on the squiggles special
operators or the fun stuff and it
generates readable JavaScript and
differently for man it doesn't have a
runtime so at the end so even if you
read the code it actually you don't have
to figure out what the runtime does
because there is no runtime also nice
thing is that it's got an open community
and a bit of a road map which is
basically we get to ask like party I
guess with time
so philosophy differences you know
everything is made to be simple the
choices are made for you which gets you
started way quicker because you don't
have to make any choices this the way it
is go ahead and do it in pure script you
have muscle type features from a scale
and so you have a longer learning curve
and you have to make a bunch of choices
also in our meu can have only one
possible program structure which is the
alum architecture while in pure script
you can have many possible way of
structuring your app you can just make
them up from scratch if you want so wipe
you skipped after L well we thought I
thought the type system in almost very
good it was a nice change from doing
c-sharp or JavaScript or a bunch of
other stuff I'm originally a lisp ER so
type systems well they're not totally
new for me but a strongly type
functional type system is so I liked it
I'm convinced so we take a good thing
which is the N type system and we give
it more features now for those more
features so we got more power but we
have less simplicity so trade offs so
the simpler types gets you as more
learning curve as a smooth learning
curve and more boilerplate because you
have to what your section gives you is
that you can abstract away the stuff
that repeats so if you don't do that you
end up repeating the stuff so you get
more boilerplate and I think those of
you who went to Jessica cardstock so
another way to deal with that boiler
pretty stuff so also it's similar enough
that I don't have to have write
everything from scratch if we had used
clojurescript I would just write a whole
lot more parenthesis which I would have
liked but this way is also good because
I get to copy and paste my types and try
to make them work in pure script which
gives you start something to start with
and also for days it's very good the
please Keaton library and also the talk
that Ryan Lempel did you can find it on
online on YouTube so the puritan library
is a compatibility layer so you can
basically take your and
would change a little bit of syntax and
running now I don't think it has
implemented everything so there are
limits but you can still look at the
code and see what it did so you don't
have to find out yourself how to do a
dictionary in pure script you can just
look at the dictionary file import it
and you can read from that which saves a
lot of time so I got Restless with an
spoiler plate by the searched time you
make a sub function to your update
function it gets old so I'm ready for
more powerful abstractions even if I
have to spend a bunch of time learning
them so that's good for me also it's
possible to implement Alma in pure
script as I just said you can you have
the period and library but it's not
possible to implement pills getting I'll
at least not at the moment because you
have the unmarked attacker and that's
not very good for implementing other
languages I wouldn't think it's also
benefits from the insight of following
an Oscar from a distance so what Scott
does the research stuff and then you
skip and when they finish with it and
they made it nicer physically it comes
around and says oh we'll do that right
the first time around so they don't have
to go back and review stuff quite as
much also the community is very nice and
community really grew which is a good
thing but it also makes more difficult
to communicate and when you slack gets
to 3,000 people it gets a bit crazy on
the other hand the POC community is nice
and small and you still can know pretty
much everyone probably and but not quite
but say there are video meet up online
meetups so you can talk with people
actually and the channel is very nice
the freenode channel and the resolve a
guitar and the slack so there are some
outright pros I think compared to an
which one is pure sweet which is
basically Google for pure script so push
it has got all the code from all the
biskits libraries and you can search
within that by type signature which i
think is great
and also you can search from strings or
anything and it really helps I think
I'll also I've got something like
that someone else implemented but yeah
you'd have to find it out also it's got
a tiara direction as I said so I sort of
know what I'm expecting and I found that
they can work a lot more with the rapper
because in elm you have all the wiring
up and the runtime so the repple doesn't
it's a bit hard at work with the rapper
what impute if you import the libraries
or the code you made you can just build
your program in the rifle I find if your
program is easy at least I use it a lot
more there are also type holes which are
getting even better now and if you know
the space Mona's talk you know how type
holes are also and while you have many
of the cool abstractions that are around
the conserve it takes time to learn the
cool abstractions so book some time to
learn them now I'm going to inflict on
you a reflection on how Elm and pure
skate and a scale relate to each other
I'm sorry so a scale is our search
language which means all the cool stuff
come to ask her first
but that cool stuff as not it's very new
so they're not haven't thought about
user experience yet so it's quite hard
to make it work for you sometimes
while in pure script they they take the
cool stuff and they wait until they
figured out a nice way to do it and they
implement it which makes it easier to
work with also and but in engine al you
have the simplest language they only
worried but they're not only world but
they're one of the main things about
that is user experience so they really
really worry about that and sometimes
things I just made to make the user
experience better so that's one big
difference I think and in a scale you
have all the ways to do things and
people are making a place all the time
in pure Scott you are still free to do
anything but you don't have the research
going on in pure script I don't think at
the moment button let me have only one
way to do things which is Evans way and
which is cody has got great design sense
but still you have to agree with the
amount of
and another thing is that el mr. ko nian
about removing historical baggage so
even in the next version they're going
to remove some stuff which doesn't
really happen in a scale quite as
swiftly or at all possibly because you
well I don't think it's quite easy to
turn GSC around and change stuff there
are many people to make agree with you
and it's not quite that easy that's all
so they're not probably wearing that
much about it
and in pure script they also remove
stuff but they are less draconian about
it they will leave some stuff around
that not everyone uses and so I think in
the end is a great beginner language
into a skill like languages because you
learn the syntax you learn purity you
get used to let and in and the sort of
stuff so and you have that with the
least cognitive effort needed to
actually do stuff so you learned that
while you and you make something and you
will get something done relatively
quickly you can make a small projects
without going crazy when you are tired
about boilerplate or you want to try out
other ways to do things you can move to
pure script which has got a lot of the
great stuff that's in Haskell but it
also doesn't have it also gets it right
the first time because they come after a
scale enough to know what the right way
to do things is so you had to type more
types type classes mono it's monads and
all of that and you can still get
started relatively quickly especially if
you don't I'll first and at the end you
can go to Oscar where you add laziness
and you are dealing with pragmas and the
sort of stuff which might be complicated
but it also gives you a lot of power
which you may need so that's my view of
this matter I know people go straight to
ask I wouldn't do that I tried I this
world way worse but for me so I hope I
made you want to try your script and if
you try to escape this be aware that the
new
version has landed and when a new
version lands usually did appreciate by
example book is on the late diversion
before it so then just install 0.10 and
expect everything to work straight away
at one point the porting will be
complete so then you will be fine but
for now I say stick to zero point nine
point three so everything can work for
you and one point of contention is power
well with power it doesn't really have a
notion of where perfect is at so even if
you have zero point nine point three
installed if we still try to install the
latest libraries which are four zero
point ten so if you're non zero point
three watch out and check what Bower is
installing because it may be hard to get
a set of libraries that just works if
you just let powered with thing but the
good thing is the field is working on a
new package manager so I look very much
forward to that and the other side I
would say please let's not try as an
industry is try not to not put our
dependencies or get up any more it's a
single point of failure it times out
it's painful with power please let's not
try not to do that anymore
so we'll give you of us short frameworks
review overview there are basically two
types of frameworks one type is
preparing react and the other type is in
pure script so the type complexity sort
of works like this at the very beginning
there is Flair which is a pretty cool
library to make interactive graphs and I
started with that it doesn't require a
lot of type of laxity and it's a really
nice way to start I think then the risk
box which is basically the ARM
architecture and it wraps react and then
there are here balances the return might
an optic optic uy and here me three
models there is allergen so as I said if
for Flair it's a great way to start with
and you can make really nice interactive
graphs with it you might not want to use
it if you want to do is place our web
application from like a proper single
page web app because it doesn't do that
but a good thing about it is you only
need to understand duplicative functions
functor syntax and not much more than
that so that's basically Piketty
function syntax it's easier than it
looks but you have to go through all the
steps to figure it out and then there is
pox which i think is a great wave to
port an alum architecture up you might
have because it's very similar to real
market I'd sure and you can also have
the interactive reactive bugger welding
which brings back the time travel in the
bugger from alum basically which is
coming back but still you can have it
now it's also probably the single spirit
framework one reason not to do that is
react appendices get in react appendices
and since I spent a few days trying to
get power to an NPM to work with me and
not timeout on github and since this
starting up is a repository you can
clone from github and that gives you a
nice set up with packs and react and
gives you the interactive debugger but
then every time you try to install it it
just if it fails it just starts from
scratch and it's like bang your head
against the wall so I couldn't do that
anyway so back structure I said it's
very similar to the ARM architecture and
I proved it and this is 0.16 and as you
can say the names are basically the same
so below is the unmarked attacher and up
is box model state action is action
update is update and view is will you
even have inputs but the only thing
that's different is basically in army of
effects and implicit you have to deal
with opposite effects which are called F
and a half and this is some code that is
a box up and this probably reminds you
of an and map so next term might an
optic UI termites wraps react an optic
UI is just pure script and their
balances and I'm afraid I can help you
with that talk with
who is making termites in know way more
than me about it and next I'll talk
about allergen so if you rather not
install 300 reactor tools and spend your
life on Bauer and NPM you can use
halogen it just says so straightaway
it's used in production at a company
called slam data and they up they are
making with it I think is fairly
impressive and an advantage of that is
they are using it in production there
are a bunch of people developing it all
the time and keep keeping it up to date
with the period changes and also making
it better and it has a nice HTML DSL
which coming from Al is an important
thing to me you might not want to do
that because the type they're not
holding back on the types so you might
have wanted you might want to have
finish the pieces by a sample book
before going doing that but I think it's
a very good thing to have halogen it
still looks a little bit like the L
marketed sure modern state action is
contained in the query query contains
action and request request is a way to
ask something out of a component
component as its own type which is
probably a good idea
I think updated is a Val a render is
view a view is render and inputs and
effects can be wired into the main and
this is not all the code for an Origin
up but enough to get the idea of what it
looks like so getting started with pure
script
my suggestion is get it from NPM or PS
VM because then you get the version you
want you can get zero point nine point
three if you just get it from your
operating system package manager it will
probably give you zero point ten and
then if you can't install stuff don't
blame me and then you should start
reading frisket by example which is a
great I already like the book I used it
with some SQL documentation to learn and
if you do I mean if you bloody know
Oscar you probably will skip through
that like a breeze but I don't know that
much Oscar so I needed some extra stuff
and then I suggest you look at the
period ellen:oh compatibility library
because it tells you was everything in
AL is in pure script and then you should
probably try out bucks or Flower Fairies
really fun that's the first thing I did
and I really liked it and then coming
out on Puget Afreen on freenode even
earlier that with a really nice place
come to the video Meetup
and then maybe you could try allergen
and then profit profitable so the
conclusion about pure script is
pisghetti's powerful and it is also
sensible it's got all your favorites
abstraction possibly some you didn't
which are not your favorite and it will
take some time to learn but you haven't
know knowing Elm you get a head start
and also you don't have to know
everything to start with you don't have
to finish the biscuit by example book
you can start with puck so with flair
and get a hang of it without learning
everything it's also not obsessed about
language UX but is still good it's not
they're not doing random stuff it's good
your language your X I believe so if you
were dozing off I might inflict on you
an extra summary so helm works fine with
a link if an compiles it works most of
the time
boilerplate gets annoying after a while
and you should never expect fancy type
from M then then we're going to do that
don't expect eyeglasses and it's a scale
syntax with less squiggles and I think
it's a great beginner language if you
want to get into ask a later on and then
expected removal of a therapy for us was
a bummer
also pills it works fine with Erlang and
if you compile it works types will get
complicated if you get into allergen and
the sorts of stuff and you should expect
to spend a little bit more time learn it
but I think it's very rewarding and you
do feel quite powerful like a genie out
of the bottle the lamp and
you get all the squiggly glory of a
scale syntax but and also they have a
sort of a road map and you can talk with
feel about the road map and it will
answer you and you can get up to date
very fairly easily so it's a great
second step getting towards ask and
maybe use parks or flair to start with
that is all you are not free to go
unless you have questions by the way if
you like the embedded board I showed you
earlier you can get one for free with
from the raffle there is a raffle it's
another rough</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>