<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How Erlang took Virtual Hold Technology to Call Centre heaven | Coder Coacher - Coaching Coders</title><meta content="How Erlang took Virtual Hold Technology to Call Centre heaven - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How Erlang took Virtual Hold Technology to Call Centre heaven</b></h2><h5 class="post__date">2015-06-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rt-xVCznwKc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to the airline
solutions monthly webinar my name is
Martin mill excision I'm DVP for the
Amir region here at Erlang solutions
today's webinar represents a
continuation of a series of webinars we
have been running across topics of
interesting the world of Erlang and
dealing with solutions based on the
airline programming language the today's
webinar will feature virtual hold an
airline solutions customer who is used
airline to reduce call center operation
expense by virtualizing customer whole
time we will hear a bit about how
virtual hold has lovely leveraged
Airlines capabilities to provide fault
tolerance and client multi-tenancy
across a cluster of servers as well as
provide a primary and secondary failover
configuration allowing for seamless
transition of phone calls in the event
of a hardware failure now as with any
live event please do excuse any
technical issues that we may face but to
start by telling you a bit about Erlang
solutions we are a products and services
orientated company devoted entirely to
the airline programming language since
i'll start in 1999 we have worked with
organisations and individuals using our
length helping evolve the language and
supporting people and businesses using
it nowadays we have just over 100 people
sitting across our offices in london
stock own crack OH budapest seattle and
most recently Buenos Aires and working
on projects across the world we provide
services around the Erlang language such
as code and architecture reviews airline
language training a line consultancy
whether on customer site or remote and
support of line based systems we also
developer line based products and some
of those you've probably heard of such
as Mongoose IM which is our open source
messaging platform the react distributed
database and one batter or a.m. which is
our monitoring and management technology
for airline systems as well as many
other solutions that are applicable in
areas where like makes sense I'm really
pleased to say that our speaker today is
brian ward
the principal software developer and
virtual hope brian has been developing
software professionally for over 22
years now and in the course in the
course of those years he has worked for
companies small and large alike such as
AT&amp;amp;T for example he has worked with UNIX
and unix-like operating systems as well
as the ubiquitous microsemi Crusoe's
windows platform and primarily with
languages such as C C++ and Java he's
also tried his hand at management and
during all this time he did not write a
single line of functional programming
before learning our lank in 20-30
currently Brian works with virtual whole
technology and spends a lot of time
actively mentoring younger members of
his team in the arts of agile software
development and of course Erlang now
please allow me to finish by saying
you're very welcome to post questions
throughout the duration of the webinar
by using the chat facility on the
webinars interface we will pick those
questions up at the end of the webinar
and our speaker Ryan will answer them as
that at that time as time allows
obviously if any questions Dubrow
announce that you're welcome to raise
them by email using the following
address webinar at line hyphen solutions
com if you are interested in learning a
bit more about Erlang as a language or
simply wish to discuss whether it could
be a solution for the challenges your
own business may be facing then by all
means feel free to contact myself
directly my email address will be
displayed in one of the final slides of
the presentation we will share with you
today I would now like to hand over to
Brian who will be glad to start us off
thank you hello i'm brian ward and as
was said I'm a principal software
developer here at virtual hold
technology we're in Akron Ohio in the US
I have been developing software
professionally for about 22 years now
I've been at vht for the past four years
and today I'm going to tell you a little
bit about the experiences we've had with
Erlang
and with Erlang solutions over the past
three years to give you an idea of what
I'm going to try to cover I've included
this slide the first half of the
presentation is background background on
vht and what we do background on our
decision to experiment with Erlang and
background on our commitment Erlang and
our engagement with Erlang solutions the
second half of the talk will cover the
various projects we've done with Erlang
how those projects have increased in
scale and complexity and how those
projects have leveraged Erlang strengths
to make real bottom line impact here at
vht and as Boden said at the beginning
there will be time for questions at the
end of the presentation but that doesn't
mean you should wait till then to begin
thinking of your questions please feel
free to enter them into the webinar chat
any time during the presentation and
we'll get to them at the end so who is
virtual hold we are a 20 year old
software company that puts us about the
same age as relying solutions we
specialize in telephony applications we
have a head count of about a hundred and
as I said I'm sorry we focus on
telephony applications targeting the
call center market there are two things
that make us interesting to talk about I
think first of all we're located in
Akron Ohio in the US and Akron is a
relatively small Metro pal
an area with a population of just under
200,000 we are about an hour south of
cleveland which is about twice as large
as akron but all in all there just
aren't a lot of people around here the
landscape especially as it relates to
talent acquisition is radically
different than what you might find in
London Stockholm San Francisco or other
tech hubs and that complicated our
decision to move to Erlang second r
embrace of Erlang coincided with a
transition into an agile methodology the
agile shift began a couple of years
prior to the introduction of Erlang into
our shop during that time we have become
accustomed to the concept of constant
process improvement we had mastered or
tried to master the art of identifying
our own shortcomings and trying out
adjustments to see if they had a
positive effect Erlang was one of those
adjustments and one of the successful
ones the HT has several products but
without question it has one primary
product and that product is call back
call back is a service that allows
callers to remain in q4 an agent but to
do so virtually the software maintains
the caller's place in the queue and will
call them back at the appropriate time
and connect them to an agent if you hear
will hold your place in line and call
you back when it's your turn then you're
experiencing virtual old call back was
developed at a time when long distance
toll charges were significantly higher
than they are today the product was
developed as a cost-saving measure for
call center operations by moving the
caller into a virtual queue the toll
charges could be avoided it was also
very easy to
show how virtual hold literally paid for
itself at the same time that toll
charges were dropping virtual hold was
enjoying another kind of evolution not
only were we saving the toll charges but
we were also saving customer time
customers who didn't have to wait on
hold are significantly happier than
those that do as a tool for customer
retention the cost-benefit calculation
becomes a little more complicated but
the but is there nonetheless and
moreover our uptime characteristics of
our application became much more
critical we could no longer accept
downtime as an isolated event now it had
a more far-reaching effect so in about
2012 we started looking for a solution
to some of the platform instability we
were experiencing in our C++ based
callback product because of our shifting
value proposition moving from
operational cost savings to customer
retention we needed to be providing a 24
by 7 service to become a true enterprise
application no simple task when you have
years of code that was never designed
for that level of reliability so we were
in the telecom sector erlang is in the
telecom sector an erlang touts some
amazing uptime characteristics and even
more exciting was the claim to zero
downtime hot deployment of updates this
was the kind of thing our product was
screaming for but a switch to Erlang is
fall far from a small incremental and
measurable change that our agile tenants
were calling for
furthermore our list of challenges
around Erlang was non-trivial we had no
experience or expertise with erlang we
need both if we were to cut to
accomplish anything everyone at BHT had
been writing object-oriented code in C++
and C sharp for years a change to any
new programming language is disruptive
but a shift to a whole new paradigm like
functional programming is somewhat
earth-shaking and additionally we were
in that small market finding quality
developers is challenging finding
quality Erlang developers is nearly
impossible and finally our current
product was and still is a Microsoft
Windows based application and while
Erlang will run on Windows it clearly
has its roots in the UNIX world the vast
majority of tooling and deployment
success stories seem to be around unix
so we had to ask ourselves was this
really the right tool for us we decided
to do an experiment with Erlang and to
give ourselves the best chance of
success we found some experts to help us
out and those experts were the great
folks over at Erlang solutions the
engagement ran in two phases initially
Lucas Larsen came on site to take a
couple of developers into a deep dive
with the Erlang platform this was a lot
like a boot camp approach providing
direction taking them as fast as they
could go to accomplish some meaningful
and measurable success this lasted a
week or two after it was over our guys
presented what they had learned to the
rest of the team
and they were the star witnesses at a
big meeting with our vp and other senior
management to decide the fate of Erlang
well they loved what Lucas had taken
them through they had a good fundamental
grasp of the platform and they had some
excellent code to demonstrate so the
decision was made to go ahead with a
second phase to develop some actual
production code albeit on a small scale
our first production application first
production Erlang application was our
outbound contact client this was an
abstraction layer to support the need to
initiate the outbound call you back
portion of our callback product
ultimately we interface to a number of
different vendors and each one has a
subtly different way for us to create
the outbound call so we designed and
built an erlang service to do this the
service would communicate with our core
software over a proprietary tcp protocol
and generate the out dial requests via a
set of plugins that would handle the
vendor specific issues this felt like a
great place to start the code was small
and isolated further it allowed us to
flex some of Erlang's muscles certainly
the async messaging applications in an
hour an undeniable strong suit for
Erlang and that would be what was
leveraged to talk to our core product a
small team was assembled the group from
Lucas's training formed the core then we
added a couple of new developers and
within a month or so they had things
working Lucas provided some remote
assistance during this phase
and during this first project we were
very intent on doing some tests first
development so we had to learn both a
unit and common test at least
sufficiently away sufficiently well to
get us rolling looking back that success
was everything we had hoped for in a
small project we became adept with some
of the third-party tooling and by
third-party tooling at this point I mean
rebar Erlang did in fact deliver the
uptime that we were looking for our
design proved functional no pun intended
and extensible and we had something
working very quickly which was
unexpected but there was no success that
couldn't be more successful our decision
to isolate the Erlang team meant that we
began building a silo around the
knowledge we delayed our internal
education and acceptance by keeping the
secret of Erlang locked in the heads of
a select few also in our ignorance we
spent some time developing code that
really didn't fit the Erlang paradigm
and for which there were already solid
off-the-shelf options one such example
was our logging framework which has
since been stripped from the outbound
contact client code base it proved to be
a performance bottleneck in the future
using something like bash shows lager
framework proved much simpler and helped
to stay focused on the real work of
delivering call back the neck
project that we embarked on was the
development of a REST API for the core
callback product for this we created a
whole new team trying to tear down some
of the silos we had found ourselves
creating leveraging the same proprietary
tcp code that we had written for
outbound contact client we began working
to extend the platform via rest and JSON
job JavaScript object notation to allow
modern clients to interact directly with
the callback platform we added web
machine to the mix here so we had
something else to learn and web machine
pulled in mochi web so there was that
and mochi web gave a smoky JSON that
gave us a library to handle the json to
airline conversion but of course we
still had to sort out the somewhat odd
tuple and list structure that mochi json
uses to represent the json objects all
those things were still very odd to us
in the early days there was probably
more struggle that went into translating
our RPC model into a rest model though
then overcoming any particular issues
with Erlang we only spend a little time
on the REST API before some shifting
priorities put it on the shelf a shell
from which its yet to come down but it
was still a very valuable learning
experience for us when we retro
project a couple of positives jumped out
we realized we were getting comfortable
with Jen servers and this was a big deal
when you reach that point with a new
platform where you're beginning to
embrace their paradigms and you're no
longer trying to bend the platform to
your vision of the world you've gotten
to a good place this was the first
moment where we started feeling this way
we also really enjoyed working with web
machine and spoiler alert a web machine
makes many more appearances in the
future here at virtual hold having put
together a couple of projects we started
to understand rel tool and maybe
understand as a bit misleading we began
to understand that it was really
important and powerful but we needed a
lot more experience with it to really
begin to understand it at this point it
was kind of an all-or-nothing black box
either it generated the release for us
or we got some cryptic error that made
no sense to us then we'd have to go back
and check our work and see if we can't
try something different this project
also began to raise some questions with
us regarding the readability of modules
the TCP message code was beginning to
get very messy and hard to read we began
to worry about how to structure our code
to maintain readability with Erlang's
relatively flat namespace it makes sense
to keep modules big but big modules mean
that the code is hard to find and hard
to read so the next
step for us was high availability this
was our biggest undertaking to date
attempting to implement a high
availability failover solution using
Erlang using nif using our existing c++
code base and it was at this point that
tto came on site for his stint of the
Erlang solutions engagement at a high
level we had to take a monolithic
windows service create a wrapper to
support cross-system messaging to
negotiate state and to maintain status
between the the two nodes and to keep
the critical state data synced to the
backup system this meant that we had
fighter a bi-directional nif interface
into the c++ code which was pretty
complicated stuff early on for us we
utilize manisha to store state data
which simplified the coding to some
extent but came with its own baggage
this is where vht really started digging
into common tests common test framework
was it was a natural fit for the H a
platform our design involved a number of
different runtime nodes so CT gave us
the ability to write tests to span
Erlang processes and Erlang nodes at
test time
when we came out of developing a che we
had three big takeaways we realized some
of our developers were still hanging on
to old ooo coding paradigms they were
still trying to bend and twist Erlang to
be more like C++ they were still trying
to make OTP projects feel more like
visual studio projects they were losing
out on some of the elegance and power of
Erlang OTP because we we weren't going
with the flow but rather fighting the
current and while while the while others
had generally gained a level of comfort
with Erlang as a language and even the
paradigm of functional programming a lot
of the OTP features were still a mystery
to us especially the release process we
still really didn't understand what was
going on with relative typing rebar
generate into the shell seemed as likely
to fail as succeed at any given time we
were also beginning to build our first
real supervision trees in our OTP
applications when you first venture
beyond that simple application to
supervisor to worker model and into
something more complex but this was kind
of the anomaly in the code we were
writing we didn't do it a lot and our
understanding of what OTP could do and
how to use that to design solutions was
still eluding us but we were getting
there
so we had some work to do if we were
going to find long-term success and
happiness with Erlang we needed to spend
some serious time figuring out how we
really wanted to be constructing these
releases what were our project what what
were our projects going to look like and
what were the repository is going to
look like what were our releases in
runtime nodes going to look like and
what was our installation process going
to look like and what were we going to
do to replace visual studio in our
development and workflow we were
currently employing about half a dozen
tools for code editing and nobody was
getting very good at any of them because
we kept switching back and forth there
were a bunch of us using Emacs her bunch
of us using vim there were a handful of
this using eclipse with the Earl ide
plugin there were several people using
sublime text with its her lying plugins
and some folks were even resorting to
notepad plus plus on Windows we were all
over the map our next
project was the system management so at
the same time we were finishing up the
high availability work the team that
team that had been working on the rest
api was called in to develop a system
management solution something to control
the h.a functionality and report back on
the status of various components now
this project suffered all the problems
and shortcomings its sister application
to high availability one but it did
introduce some new things that help
shine a light into some of the darkness
we built the Erlang part of this
solution as a REST API having just come
off the rest api project it seemed like
a natural choice we built the user
interface as a javascript single page
application our first one here at
virtual whole and this set the pattern
for the web UI is to come we'd use
Erlang and web machine to construct a
REST API then we build a JavaScript you
I over the top of it some other exciting
developments on the Erlang front in
system management we built our first
distributed application using the
application environment till the ER line
colonel how to manage distribution we
used a global name to help give us
access to the distributed applications
gen server and we also consumed a second
rest api behind the scenes that are
internal authorization and
authentication service was consumed by
the Erlang
so this solution really did set the
pattern for a lot of our future
applications the whole Erlang plus web
machine plus JavaScript formed the new
formula for success it was also at this
point that we began to standardize on
using fashos logger as the logging
framework and just as the H a project
was heavy into common test this project
was very heavy into e unit in between
the two it felt like we were really
getting our hands wrapped around testing
um so listed on the good side of the the
table here is the line showed the need
for a real messaging platform and that
actually sounds like it might be a bit
of negative to have shown that we needed
something that we didn't have but in the
long term it was a real positive when we
first rolled out system management we
relied heavily on Erlang messaging to
get the notifications pushed around and
and into the system management system
but long term we needed status messages
to be pushed from all kinds of different
components many not written in early and
that put us down the path of amqp and
specifically RabbitMQ and we had talked
about RabbitMQ here at virtual hold for
years in fact rabbitmq as a as a name as
a topic of conversation predates the
term early
in our design and architecture
discussions but it always needed a
catalyst and ultimately the system
management project became that catalyst
and then manisha so I really liked
manisha and when it works when it's good
it's great but when it's bad it's a
little disastrous and you know those
footnotes in the minion that talk about
eating the reliable and low latency
network to support the to support
manisha well they truly weren't kidding
and we did experience a lot of problems
in early production around manisha when
we would deploy this at customer sites
we would discover that networks weren't
reliable networks weren't fast in all
cases and manisha is where that showed
up the most so we had a lot of struggles
early on and we're still to be honest
working through some of those when is
the right place to use manisha and when
is where is the wrong place to use
manisha
so that brings us over to our
configuration management project this
was the first of what I call our next
generation Erlang projects we had some
time while vht began rolling out the
high availability solution to customers
we had time to think on our sins and
time to experience the joy of supporting
the brand new technology out in the
field at that time and the time that
wasn't spent healing network partition
manisha datasets began to look at the
project structure we had employed in
2013 and came up with a better 2014
version starting with configuration
management we began to build projects
centered around the node or the release
still not really sure when to use which
term individual applications would be in
sub directories beneath this and not in
their own repositories the whole node
can be worked in all at once and as one
this really streamlined the process the
configuration management project itself
was a huge delivery success it was
another airline plus web machine equals
REST API with a JavaScript you I
exposing a lot of functionality that had
laid dormant within the core product we
enabled some on-the-fly reconfiguration
of some aspects of the callback system
we did two really cool things during
this project one of which had some
far-reaching future direction
implementations first i'll talk about EE
unit we really got into test generators
in this project the code itself made
heavy use of higher-order functions
enclosures and suddenly he units test
generators didn't seem so foreign
because there are also higher order
functions so we really began exposing
some of the power and functionality
that's in the e unit framework that we
hadn't seen before and the net and the
second thing and and probably the most
far-reaching and impactful thing is we
really began seeing some platform
independence with configuration
management so for no particular reason
we began doing some of the early
configuration management prototypes on
Linux the configuration management
service was interacting with our core
product over a network connection so
they didn't have to be running on it
didn't have to be running on windows so
we started putting it together on the
Linux platform we began doing a couple
early demos with the airline code
running on a Windows Server talking to
our core product running on a Windows
Server at one point in time we even did
a demonstration of an early version of
configuration management running on a
Raspberry Pi on the Erlang distribution
put together by Erlang solutions that
you can download and that was successful
the biggest thing internally that we did
that was shift around the structure of
how we were putting together our
projects we have this new and improved
approach to projects where we would
layer everything under the
node and when we have applications that
are being packaged up into a node or
into a release we found that there were
three ways that we could include them
and incorporate them the first was the
way we had done it from the very
beginning where the application was a
dependency managed by rebar in this case
it has to have its own git repository it
has to be separate from the application
or I'm sorry separate from the from the
node of the release this works really
well if the application is completely
stabilized if you're expecting to
interact with it about as much as you
would with a third-party dependency but
it's really really awkward we found out
to be making changes interactively with
an application that's included this way
the easiest way to include applications
we found was just as a subdirectory
maybe we'd create an apps folder inside
of the project we'd include the
applications the various applications up
under that there was no fuss when you
were doing it this way all the code was
all in one place the applications the
tests for the applications the node the
release everything was all built in one
tree nothing was terribly complicated
the only downside to this was that the
applications really couldn't be shared
outside of this structure for that we
went to using get sub modules this
formed sort of the middle ground between
these two with only minor management
overhead one extra commit and push
inside the sub module you'd wind up with
something that was easily shareable but
also easy to maintain and develop with
and again this is only necessary if you
actually want to share out the
application so we had a few applications
within our project one to interact with
a relational database we had the one
that did the asynchronous messaging back
and forth to the core client these we
wound up implementing as sub modules and
then we made all the other applications
just sub directories within the project
another thing that we did at this point
they'll prove to be really useful was
beginning to create multiple release
targets inside of the relative config
this enabled us to run a slimmed down
version of the code in certain
disconnected scenarios if we wanted to
test the interaction between the user
interface and the API without
necessarily interacting with any of the
backend databases we could spin up a
configuration of the node that didn't
include any of the relational database
code it's allowed some of our JavaScript
guys to work from coffee shops where
they didn't necessarily have access to
the legacy databases at this point when
we started doing things like that we
finally started getting to the point
where we felt like we were understanding
a little bit about what was going on in
rel tool and that was a big turning
point for us and now a quick word about
our deployment that is to say
installation and i added full i had
avoided this story early on because it
was hard to find a spot word fit
but in the spirit of full disclosure
here's how we mess this up and then we
recovered when we built the installer
for our H a release we did some weird
things for what we for what we thought
at the time we're good reasons we
thought we have all these nodes on the
system and we might want to delete one
of them and replace it with a new copy
while leaving the others in place anyway
the whole problem with that is that when
you've got all these nodes running on
the system and it's a window system one
of those nodes is going to fire it up
EPMD and once EPMD is up and running the
files locked because of the way windows
does memory mapping can't delete the
file can't delete the folders that
contain the files and so you can't
easily drop in all the new stuff so
instead of figuring out how we might be
able to use rel tool to support using
the Erlang runtime from the system copy
of her hang which we later found you
could do we instead decided to dump all
of the libraries and applications that
we were writing straight into the
Erlang's the system Erlang's live folder
in retrospect probably wasn't too smart
to have done this and as if that weren't
enough after all of that it turned out
that the use case of replacing just one
note on the system turned out to be pure
fiction we never ever did that we always
replaced everything all at once so at
this point we backed off on trying to
all things this way during a
configuration management instead we went
back to what I like to call the sandbox
environment that relative kind of
creates by default where it bundles up
all the pieces of the Erlang runtime
that you're going to need and puts them
in one directory tree for you to use and
we started pushing things out that way
so starting with system management we
were distributing all the core pieces of
the Erlang runtime that we needed we
weren't relying on a system Erlang to
have been installed and things were much
simpler another huge benefit that we got
from this was that when we rolled out
system management we did it on release
16 of Erlang and a 64-bit version of our
16 the earlier age a project had been
done on a 32-bit version of our 15 by
using the sandbox proach system
management could run under our 16 and
the core stuff the main product could
run under the r15 32-bit stuff and they
could interact over the network just
fine so while configuration management
was getting built another team was
focusing on extending and revamping the
parts of our system management this is
why the absence of needed message
platform that we talked about earlier
became such plus system management team
added RabbitMQ to the system footprint
figured out the whole installation and
configuration process and retooled all
the components to leverage amqp for
status updates ok maybe not all of them
but most of them and it's still ongoing
work
this was another huge win for the ER
lying initiative here was a project that
was getting actively enhanced and
extended after its initial release and
at a small company like ours it's the
definition of acceptance Erlang was
becoming entrenched we were starting to
set the stage for the future and here's
the future well maybe we're currently
building a prototype of callback for the
clout we're calling a PHX and it's all
Erlang all the time it's running on
linux not windows that were not actively
crippling it from later running on
windows if that's what you really want
to do we're heavily leveraging RabbitMQ
for distribution work across the cluster
we're also employing some noon on Erlang
technologies like elastic search and
engine X our work distribution scheme
uses something we're calling workers
because you know that names never been
used before so we declared that a worker
would be represented by an erlang
application that made it fairly module
modular it also allowed us to build a
custom supervision tree to support our
needs at the top we have a worker
supervisor who's in charge of managing
what we call the control gen server and
also a scaling supervisor the control
gen server listens to a special amqp
exchange that delivers messages specific
to configuration of workers the control
gen server then acts on those messages
to reconfigure the workers mostly by
issuing requests to scale the number of
processes listening for work that's the
job of the scaling supervisor it manages
all the actual workers
Jem servers it's a simple one for one
supervisor so we can easily scale up and
down the number of worker processes and
all these modulars all these modules are
completely boilerplate they're reused
across every worker without any code
modifications they only take some
slightly different parameters at startup
ton the worker gem servers themselves
are layered with a module that abstracts
all of our protocol stuff we've agreed
to structure messages and handle returns
and such the custom worker implements a
behavior and the framework uses that to
invoke it currently implemented three
kinds of workers into this framework our
simple worker is amqp based it gets its
work from a rabbitmq work queue we have
an HTTP worker the sitting atop web
machine we use the web machine framework
to acquire rest requests which we can
then dispatch into the worker the
framework handles all the out of and
back into HTTP drudgery leaving the
custom module free to focus on actually
doing work and we're also supporting
something we call an automation worker
this worker is simply triggered
periodically not by any external
stimulus but rather by an erlang timer
message this allows us to extend our
worker framework to incorporate workers
that aren't triggered from the outside
and one last plug for v HX we started
using travis CI for building and
continuous integration and it has been
great I can't imagine going back to
doing it any other way they have a
wonderful flexible system that does
everything we need builds triggered on
every push out to github even on
branches
for every push we get a compile we get
all our tests run we get the generated
release we get test results and the
release bottled up and pushed out to
Amazon s3 where we can later go out grab
them put them on a server for some real
interactive testing so here's the big
disappointment for those of you thought
I'd be walking you right up to those
gates of call center heaven that we're
in the invite we're actually still on
that road it feels good it feels like
we're on the right Road in the right
direction and moving at the right pace
we're confident that we'll reach our
destination in a timely manner but for
the real results of this effort will
have to stay tuned and that is what I've
got for today so do we have any
questions Ryan please allow me to first
of all thank you for a very inspiring
talk on what virtual hold have done with
our line and I'm glad to say that
questions have been sort of pouring in
quicker that we can hope to answer them
but just to say to our audience because
we only have theoretically speaking
seven minutes left we will try and
answer as many questions as we can on
this particular moment of the webinar
itself and then obviously if we cannot
answer any questions I left we will
answer them by email so you'll get your
answers but just to start so people have
been asking a lot of questions in
relation to the big sort of paradigm
change that you've described in moving
from one environment to a completely
different sort of airline focused
environment so I guess a theme that's
been sort of moving through a number of
questions is how long did it actually
take for people to become productive in
airline moving from a completely
different mindset well it it varied a
lot so we have our development group
programmers is probably about 20
people give or take of that a handful
four or five I took to this like like
fish to water and it felt like just a
matter of a few weeks and anything you
threw at them they just chewed up and it
was like they were just meant to work on
Erlang and we're just waiting for a
chance to I think for the for the bulk
of the people it was a much slower
transition I think that our agile
approach to software development we do a
lot of pair programming here and we do a
lot of tests first development and I
think that really helped spread the
knowledge but i think that when new
people start working on Erlang for the
first time it takes them a couple of
months probably to really start to fall
into the the patterns and then you know
there are actually those that that
simply never made the shift you know
they're there a couple of people who
just decided this isn't for me this
isn't what i want to be doing and you
know they're not here anymore and and
that kind of happens in software
development when you make these kind of
changes so I I hope that answers the
question I I think in general it takes
people a couple of months to start
getting comfortable they think that I
think that it uh it can take a long long
time to reach the point where you've
actually encountered and worked with a
sufficient amount of the framework and
the functionality of OTP to really start
getting across the board comfortable now
does that make sense yeah absolutely i
think that answers a question and
obviously there's any follower freelance
adesso
writing just to sort of give as many
questions a chance and thank you
everyone again for asking all the
questions we've received again we will
answer all of them if not now then
writing but there are a couple of
questions that are sort of moving for
this general theme of language option so
the next question I guess would be
coming from William where would you and
where would you not particularly user
like based on your experience to date hi
I'm trying to think if there is a place
where I wouldn't want to use Erlang the
so yeah i think i think i would go with
that I think Erlang itself and an OTP
are something that we've never really
had a problem with we've never looked at
a sector of our solution space and said
whoa or Lang's a bad fit for that I I
would not extend that to say that every
aspect of Erlang and OTP is perfect is a
perfect fit in every place and I would
especially call out you know our bad
experiences with manisha you know
they're there are those huge disclaimers
about using manisha on networks that are
not reliable and that have latency and
things like that and we didn't think we
were um but when the code actually went
out and got deployed it proved us wrong
it showed us that we actually were
putting manisha out into places where we
had an unstable network and and we began
paying the price for that so certainly
there are places where certain
technologies with
the Erlang sphere our bad fits but it's
not that we could not have authored a
wonderful solution in Erlang using its
core feature set that could easily
operate in that Network environment we
just didn't realize what we were getting
ourselves into when we did that thank
you for that and just to try and honor
as many questions as we can i'll quickly
move through the next few at least and
again apologies to all those who will
not have their questions answered now so
the next question comes from Tom and Tom
is asking would you consider moving sick
RTP packet handling to Erlang um that is
a good question we we currently don't do
a lot of that in our core product but I
think it would actually make an
excellent fit for Erlang um you know I
look at the huge success stories that
Erlang has in the marketplace around
asynchronous messaging and stuff like
that and think you know building a
building a sip switch or something like
that on Erlang seems like a very natural
fit thank you for that moving on
straight to the next question Fernando
is asking so in relation to your
previous comments on Asia what storage
technology do you then use for
persistence when ninja itself is not the
best fit we are still using manisha
almost exclusively in the Erlang
solutions that we're writing here the
the part of manisha that we're
definitely shying away from is the
clustering of magnesia nodes and the the
inherent trust of the underlying network
that that implies however that being
said we are employing the use of elastic
search which is a java-based no sequel
clustered storage facility we started
using that in one of our other products
and we're experimenting with its use in
the new cloud offering of call back
thank you for that and I'll move
straight on to the next question we're
officially over time that we would
normally take but because we've had so
many questions we should try and answer
at least a few of them so Dominic is
asking have you deployed a line in
actual call centers and was it difficult
to make them accept that kind of
solution in their production
environments um we we have um and it was
not difficult to get them to accept it
because we honestly didn't like jump up
and down and say oh by the way you know
this is Erlang so we just sort of
silently rolled that out as part of our
80 which was our high availability
offering it came out a couple years ago
and the place where we did have some
amount of acceptance issues which was
actually internally and it was working
with our support organization we we try
to work ahead of time to say hey we're
using this new technology with the high
availability stuff and we want to help
you guys get up to speed with it and
stuff like that and they weren't jumping
on that bandwagon and when
did roll out there was a little bit of
pushback and backlash because the Erlang
solution behaved so differently than a
traditional C++ application that it took
some time for those guys to get up to
speed with it and get a good feel for
what was going on so that's where we saw
the backlash I think with that thank you
for that I think that really answer the
question now we do have to finish a
webinar at this point but i do want to
allow one further question because it
really sort of stood out on guard and it
may be probably a good question to
finish with so the question is was there
one single unexpected benefit of using
Erlang something that really sort of
stands out in your implementation of our
line something you did not expect but it
was a benefit that sort of just came up
I'll tell you that that the thing that
was really unexpected arm and the thing
that is so elegant about the Erlang
runtime is the ability that you get to
interact with the system while it's
running you know I've worked with
systems that are interpreted and I've
worked with systems that have sort of a
quazy interactive shell and I've worked
in the in the java space with jmx and
stuff like that but nothing nothing
beats the ability to fire up an erlang
she'll connect to a running node and
begin interacting with it to figure out
what's going on what's going on that's
right what's going on that's wrong
making changes that you need to check
that you need to make or even the
ability to push out a modified module
and dynamically reload that while the
systems running those kind of things are
just
crazy powerful and and completely
unexpected when we got into this I don't
think anyone could even have imagined
that we were going to be able to do
stuff like that with the Erlang platform
when we first started writing code with
it thank you for that I think that's
really inspiring and a great response so
i do apologize to everyone asking all
the questions that we haven't managed to
address but I would say I know that
everyone will join me in thanking
yourself Brian for a fantastic talk on
your implementation of our like you can
call center operations and many thanks
to all of you who have joined us for the
webinar as well please join us for our
next monthly webinar and following today
just to say we will be sending you a
short survey to make sure we capture
your feedback of today's webinar please
note that the recording of the webinar
and the presentation that was shared
today will also become available for you
to collect on Erlang solutions is
corporate website which is www.hyken.com
I would like to mention though maybe a
bit late that at the moment we are
running our line user conference in
Stockholm that's from the 11th to the 12
jun if you do have a chance visited then
please do is the oldest and the largest
online conference in Europe a perfect
place to hear some compelling
cutting-edge airline talks and mingle
with our language so please do that if
you can just to say once again thank you
all for attending the webinar we very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>