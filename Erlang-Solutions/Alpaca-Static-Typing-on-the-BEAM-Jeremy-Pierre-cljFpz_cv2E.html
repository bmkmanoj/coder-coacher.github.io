<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Alpaca Static Typing on the BEAM - Jeremy Pierre | Coder Coacher - Coaching Coders</title><meta content="Alpaca Static Typing on the BEAM - Jeremy Pierre - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Alpaca Static Typing on the BEAM - Jeremy Pierre</b></h2><h5 class="post__date">2017-03-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/cljFpz_cv2E" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you okay everybody hear me okay
yeah we're good
okay thanks as he said my name is Jeremy
you can catch me on Twitter and github
at that handle there it also works for
Gmail boards I may live to forget but go
ahead and hit me there by day I'm
director of platform engineering at a
company called askew 'ti which is
headquartered in Toronto Ontario Canada
we're a retail analytical company which
means we're a little bit like mint.com
we take store level data for retailers
and their suppliers get them on the same
page and help them make data-driven
decisions to improve their business our
back-end is a mix of Erlang and Scala
and we are of course hiring so if you
like things like Canadian companies or
ETL and all app problems that are
multi-tenant please come talk to me but
we're really here to talk about alpaca
so in brief alpaca is a statically typed
functional programming language for the
Erlang virtual machine it is written in
Erlang so far and compiles using the
core Erlang ast and compiler modules
that's just a core module if you're
familiar with any of this stuff comes in
your standard distributions no big deal
as much as possible we want to
interoperate safely with Erlang and with
the rest of the Erlang ecosystem and
that last point it does have a couple of
implications we'll get to later
specifically when we start to talk about
the trade-offs that we make so in terms
of syntax and features alpaca is heavily
inspired by the ML family of languages
so if you have experience with things
like either o camel or elm some bits of
this are going to look eerily familiar
but not exactly the same I started
working on it in January of last year
and open sourced it in June so we're
still pretty early on but it's already
useful for a few things already and you
can generally use it for a variety of
problems something that's probably
pretty important to mention as well is
that our type checker prioritizes being
able to infer types rather than
requiring type annotations explicitly at
present we don't even have annotations
although that is coming the type or just
tells you when you've mixed something's
up so if you you know try to add an
integer to a string that's going to be a
compile time error right out of the gate
and finally well we our ml inspired
we're not intended to be ml so we're
prioritizing being functional and
statically typed over replicating any of
the usual suspects entirely will
seamlessly take any good idea but I
don't really want to be
automatic about which one of these
things we consider to be the one true
language I don't think that's a useful
fight to wait into and right now we
don't care about things like higher
tided typing and dependent typing effect
typing any of the ad hoc polymorphism
flavors all of these things I think are
important for us to deal with at some
point but we're really trying to be
conscious of prioritizing more basic
basic features and functionality ahead
of time so things that make us really
useful again within the Erlang ecosystem
it should be noted we don't even have if
you're coming from ml we don't even have
like an ml module system right now at
all we've talked about it but right now
alpaca modules and Erlang modules are
one-to-one correspondence we don't
really do anything fancy there at all
and when I started working on what
became alpaca I had absolutely no idea
how demanding only worked at all had no
idea what type reconstruction was
there's a whole other talk buried
underneath this one about how our typer
works in a lot of detail and where to
start if you want to do something like
this because it is a very tractable
problem but this is not that particular
talk and my objective today is to give
you a flavor of where elpac is coming
from you know why it exists in the first
place what's already working and where
it still has some problems that we need
some help solving I'd like to encourage
all of you to come and participate in L
practice development to that end we'll
talk a little bit about the community
and how that's structured to wrap up
this talk but let's start with why even
build something like this in the first
place what's the what's the motivation
well I started working on alpaca
initially for two reasons I really like
Erlang and it's virtual machine but I
also love being able to rely on static
typing for faster iteration which is
going to be a controversial statement I
understand but in my experience a decent
typer can help to reduce not eliminate
but reduce the number of tests that we
have to write especially the upfront
tests so in addition to Erlang as I
mentioned I spend a lot of time in my
day job in Scala and so some of the
motivating bit especially around typing
come from things like Stella's case
classes this kind of example I really
like case classes in Scala I like the
way they let me model code and think in
terms of relatively expressive types I
think of them a little bit like type
constructors in an ml language coupled
with record
so I sort of think of case glasses as a
stricter version of that coupling so
here we have something that looks a
little bit like Oh camels tag variants
and records L I think you can do exactly
the same sort of thing and this happens
to be perfectly legal
alpaca code as well you can drop this
into the shell that we have or an alpaca
module it will work no problem but the
problem is that in Scala I can't use
patterns everywhere like I can an ER
line or an ml so I can't be structure
case classes like a function head like
this and that frankly makes me kind of
sad because this sort of shorthand I
find both expressive and very useful in
Erlang and in ml variants and when I'm
moving between Scylla and Erlang tests
are another particular place where I
think Erlang's approach really shine I
like how even it lets our tests live
right beside the code that we're testing
and the distinction that we have between
unit and common test is really nice I
know that not everybody likes one or the
other but the fact that we have two very
coherent approaches to different styles
of testing and then layer on on quick
check or proper on top of that it's kind
of amazing in our industry as a whole
and unfortunately testing on jvm
languages is typically nowhere near as
simple you know we often need a
completely separate source trees
completely separate test classes just to
check what we're doing with our code we
don't get that thin kind of flow it's
not really possible where you can have
your tests and code living beside each
other I think having tests live beside
the code that they're testing is also a
really great set of example so when
we're coming back to something we wrote
a year ago and trying to decipher what
we did it's really useful to have that
right beside each other right or if
we're coming to somebody else's code and
trying to figure out what they've done
so we do try to feel a bit directly from
Erling with alpaca and because I think
Erlang does tests and pattern matching
particularly well alpaca tries really
hard to keep both of those things front
and center in its design from very early
on it was important to me to be at least
as test friendly as even it is and again
to me that means being able to couple
tests and the code they're testing
together in the same file in this
tension between the two languages tests
and pattern matching and Erlang versus
modeling and typing in Scala is a large
part of why I started what became alpaca
in the first place one of the very
earliest mo
this was actually case classes in the
the type-checking that comes along with
those and the tools that we have to
model our problems in solutions aren't
strictly part of type checking right
like case classes type constructors
records those kinds of things aren't
necessarily only strictly coupled to
type checking but I think it's all
really connected I generally think of
the type checker as a free set of tests
especially when we include pattern match
exhaustive miss checking it's all in
effect a low cost chunk of test-driven
development to me and unit and
integration tests then themselves become
more of a behavioural set of tests
that's really what we're checking there
right and this is where things like in
other corners of our industry things
like dependent typing or closed respects
start to look really exciting as well
the key here though is that I think
tests or test writing I should say in
type checking are really two sides of
the same coin
I don't think we should have to pick one
or the other and types and tests are not
in competition they're not in opposition
to each other they can and should
support each other and I want to work
with a language that actually considers
both of these things to be first-class
citizens I don't see why we shouldn't
have that as a first-class construct
both of them I also really want to make
tools like alpaca accessible for other
people
I think this combination of test
capabilities and type checking can
actually provide a competitive edge and
I'd like to share that I think that if
more of us have that we'll build better
stuff together and I think that's a win
for anybody and it all basically
translates to I wanted a reasonably
pragmatic statically typed language with
algebraic data types let's in pattern
match everywhere and which easily
integrates tests which is not at all a
tall order right so for those of you
haven't tried alpaca yet here's a sneak
peak
we have pattern matching in function
definitions here with Matt I don't know
if everybody at the back can see that
maybe a little bit tiny but the pattern
matching in function definitions is much
like you might do in Erlang and an
Associated test there's a pretty basic
algebraic data type here the auction
type or if you're in Haskell the maybe
type I'm good that's what Elm calls it
as well but I'm not sure the map
function is basically a functor map I
think some language is called the F map
it's not flat map it's very different
but the basics there are that you know
if we apply and map to an
empty option we get an empty option at
the other side we don't even talk about
the past in function don't care about it
and if we pass a non empty option with
something in it we get a new option with
the function applied to the contents at
the other side as you expect the type of
the resulting option depends on s so if
the function we're giving to map is
integer to string and we give it an
integer option we get a string option at
the other side note that assert equal in
this test here is not strictly part of
alpaca but it's pretty easy to define
tests in alpaca get synthetic names that
match the way that even it names its
test so if you're using the rebar 3
plugin that Tristan wrote you can bang
rebar 3 unit into the console and your
alpaca and Erlang unit test will run in
the same go there's no changes you have
to make they're pretty straightforward
and here's a quick and dirty assert
equal definition if you're curious about
how that might look this is a type safe
that sword equal so if you hand us an
integer in the float you're going to get
a type error when you would go to test
but otherwise it does what we pretty
much what we want if a and B match then
it just proceeds and the test passes if
they don't match it throws an exception
and even it will tell you your test
failed basic so before we actually get
into the details of alpaca itself in
some of the core features there I want
to talk a little bit about some of the
key principles there are three key
principles that we keep in mind while
building alpaca the first thing is type
safety which I know I bang on a bunch
about but we'll talk more about anyway
type safety is prime we want to be able
to model and specify our intent and
alpaca should check that model for us
and tell us if we got it wrong that's
really the goal here right this includes
things like pattern match checking for
exhaustive miss well it's something
that's still fairly in the early stages
for us but it already exists for
top-level function definition so if
you're doing pattern matches and
function heads alpaca is going to yell
at you if you didn't actually cover all
your cases the second thing is basic
utility you know how useful is alpaca
can we write useful programs with both
alpaca and other languages in the Erlang
ecosystem does it make it simple to test
those programs that's a key part of
usefulness as well I think and the last
principle is simplicity a simple
language to me is one that doesn't
require a lot of memorizing
recall it should be as obvious and
consistent as possible rather than being
implicit or cryptic and having to
decipher things I think that we need to
be guided by a relatively simple set of
questions for this to you know like a
how much of the language itself is
implicit or hidden
how many competing or contradictory
things that we have in the language how
much of the behavior and the semantics
of the language are obvious you know
from what you're seeing rather than how
much do you kind of have to force
yourself to remember and figure out
what's actually happening occasionally
we will trade some of these principles
off against each other and you'll see
examples of that but for the most part
you'll find that type safety really
rules everything
followed closely by the broad utility or
usefulness of alpaca within the
ecosystem as a whole and to double down
on an earlier point this means being as
friendly as possible with respect to
Erlang or ecosystem interoperation in
general so just the last thing before we
get into the specifics of the language I
want to talk a little bit about two
things why we target the Erlang VM and
why we're basing things on the ml family
of languages in particular because it's
you know that's a completely different
syntax to write to start with white beam
why the Erlang VM there are two main
reasons of the Erlang VM itself and core
Erlang so as far as the VM goes I really
just like the properties we get with it
we get the basic soft real-time stuff
that the previous speaker talked about
but we also get great debugging and
tracing facilities and lots of
guarantees are baked right in there for
us like all the message-passing stuff
and much is receiving all that stuff is
done and with very well understood
properties already and core Erlang
similarly makes a bunch of things
relatively easy for us to do a lot of
the basic constructs and key
abstractions are right there in its ast
we don't have to do a lot of the heavy
lifting that you would normally do with
a new language I think there's a
probably a subtle reference to
definitional interpreters under there
but I won't get too into the weeds there
as for the ml family I really like its
brevity there's really no ceremony about
braces or parentheses and it's very
expression oriented I think that
expression oriented nature helps to make
us think about things from more of a
compositional perspective that's not to
say that Erlang doesn't force us to
think about things from a compositional
perspective as well because it clearly
does it's more that Earling aside I
think ml is a little
a better place for us to be pulling
things from than other languages in our
industry
now I'm likely going to mention the
terms unification or unify a few times
as we get into the details here so for
the purposes of keeping things simple
you can treat those words as meaning
given two expressions can we show that
they are the same type anybody who's an
expert in inference or type
reconstruction I'm sorry as I know it's
a gross simplification but it'll work
for today so let's talk about a few
differences and similarities to get
started the biggest and really only
breaking differences are that strings
are utf-8 strings or you take a binary
zai should say like an elixir and
records are compiled as maps instead of
as tuples there are a few reasons for
that and we'll get into the why of that
later maps and list in alpaca are just
Erlang maps and lists under the hood but
they are typed with parameters so if you
were coming from the ml side of things
we would talk about parametric
polymorphism if you're coming from the
Java side of things we would talk about
generic I'm just going to use generics
because it's easier for me to not mess
up to the body of this talk so here's a
basic map with atom keys and string
values nothing particularly strange here
we use elixirs atom syntax just to keep
things clean between variable and
function names as well and here's a map
that's going to give you a type error so
all the keys in a map have to be the
same type and all the values have to be
the same type as each other as well so
you can have a map from atoms to strings
but you can't have a map necessarily
from atoms and integers to strings right
we have both some and product types so
this is a pretty obvious tuple one of
our product types and a specification
for that same tuple type if you wanted
to specify this as a user-defined ADT
records are the other kind of product
type and we'll get into the details of
those shortly too some types or if you
prefer Union types are pretty
straightforward and play well with
generics as do our product types so we
could have used type variables on the
previous slide we're borrowing Oh camel
syntax here with the apostrophe for type
variables and we do allow for recursive
types - so here's the obligatory linked
list example again it might be a little
small for people at the back but we'll
carry on
type constructors take a single argument
which i think is pretty common in most
languages here we're using a tuple -
cons we do use a literal -
syntax rather than using asterisks as
you find in their languages I think it's
a little bit more straightforward and
here's an ADT that on the face of it
looks a little bit dangerous
we're unifying integer and flow without
type constructors right how are we going
to tell the difference between these two
in a match or how are we going to tell
the difference between different and
integer in that so those of you who are
familiar with type inference will note
that we are breaking decidability here
I'll pack it when it sees an integer in
the presence of this type can't tell
whether it's an integer or this
particular type now there are a couple
of rules that goes through to get there
but this is really key to how alpaca
wants to be friendly with other
languages on their own VM because these
kinds of unions are normal for us to
work with but still maintain type safety
for when we're purely an alpaca land and
the way that we type pattern matches
plays a really big role here and just
before we talk in detail about matches
and clauses and what that means for
typing I want to I have to admit to
something up front really any type I
don't really like it at all so this is
where you mix you know editors and
floats and something like oh camel or
Scala and the compiler just tells you
well let's see any type now I can't
figure it out I really don't like it I'd
go so far as to say that I hate it so
you cannot explicitly use the any type
in alpaca at all if you mix a float and
an integer you won't get any out the
other side alpaca will tell you you
screwed up you know unless you have an
ATT in scope but again we'll get to that
so let's build up to how we work with
that previous Union by looking at
matches in some detail here's the form
of pattern matching you're used to in
Erlang with K sub right and like in
Erlang it looks pretty much the same if
we're dealing with receiving messages
and we use the same form for our foreign
function interface or FFI as well we can
also apply guards as we do in Erlang so
here we have an integer guard so X has
to be an integer we haven't implemented
every single type check yet but they're
pretty easy to add so if you're looking
for a low-hanging fruit you can come in
and help out with that guards right now
you can have multiple separated by
commas but they all have to evaluate to
true it's all conjunction or yeah
conjunction we don't support disjunct or
ORS yet there's no reason we can't we
just haven't gotten around to it yet so
this match here in isolation that unions
in
and floats is going to be a type error
right alpaca will not let you mix those
just implicitly you can't just get on
any of the other side of this patterns
all have to unify with each other so the
patterns all have to be exactly the same
type and the bodies all have to be
exactly the same type as well but we can
fix this by bringing the ADT and from
before so this is that Union type we're
doing the dangerous union of integers
and floats right again we want to be
able to work with the exact same Union
that we are able to in Erlang or elixir
or anything else and let's work up to
how we actually type that so here we
have a really simple clause this pattern
match where we have an integer pattern
and integer body now pakkun knows that
the body is an integer and that X is an
integer because plus can only be applied
to integers if you try to you know add
with plus 1.0 and 1 you're going to get
a type error if you want to add floats
you have to use plus period like you do
in okay and let's say right so alpaca
can pretty easily tell that X is x
excuse me should only ever be an integer
but what happens if Erlang calls this
with a string right there's no way that
anything outside of alpaca is going to
know what we're going to permit with
hell packet here alpaca is not going to
let us call this with anything other
than an integer but Erlang or elixir or
LFE can shove whatever they want into
this function and and we won't be able
to stop it
so an Erlang with a forced or contrived
example we might throw up a type guard
on here like we've already talked a
little bit about right to catch that and
avoid the batteries nitaac exception
alpaca lets us use pretty much the same
functions as you saw but in alpaca they
do double duty both as guards and as
additional information for the typer we
kind of privilege guards so back in
alpaca we can include a type check that
not only guards us at runtime just as
we're used to in Erlang but it also
serves as additional information for
alpacas typer
we don't throw that information away we
privilege these particular functions as
an aside for those curious these guard
functions in alpaca compiled to the same
Erlang function and guards have the same
restrictions as we have with Erlang
guards we haven't changed anything there
really so if we drop the addition bit
right which means that we remove that
information for alpaca to see that it's
an integer
this guard gives us the runtime checking
that we're used to but it also informs
the typer we don't throw that
information away we use that information
to feed the inference err okay it's
crucial to how our foreign function
interface works as well now to be a
little bit more specific or to double
down again on an earlier point in alpaca
we want to be able to work with the
Union types that we're used to in Erlang
we don't want to throw that stuff away
we don't want to make that hard or make
anybody jump through additional hoops or
at least too many additional hoops type
guards let us maintain all the runtime
safety were used to but we also leverage
it for compile time checking the type
checking as well we don't throw the
information away okay so expanding on
this all calls made to languages in the
Erlang ecosystem outside of alpaca must
go through the FFI so here we're calling
Erlang date right
you can't call Erlang date from alpaca
it will tell you that it's not a defined
function you must go through the FFI and
this is integer clause here is even more
important because it's the only way that
I'll pack and knows you're giving it a
tuple with three integers coming at the
other side of this right it's the only
way we're actually going to be able to
tell anything and to reiterate again
these guard functions can be used
anywhere you normally use clauses so you
can use the same guards in recieves you
can use them in foi you can use in the
normal pattern matches we can also get
really simple if we want to so here's a
trivial function to print excuse me a
simple greeting or message and you'll
note that in the pattern we're not even
bothering to check the type because the
body is always an atom so alpaca can
tell really easily that you know an atom
is always going to come back from this
function no big deal in general it's
pretty easy to kind of cobble together
functions with our FF ID to take
advantage of all the libraries you're
used to
as an aside if you can see notice we're
matching on the type of X here right
with this is string and the reason we're
matching inside alpaca not in the FFI is
because the foreign function interface
doesn't type check any parameters going
into it so anything in that list of
parameters you pass to a beam call is
not type checks we don't care what it is
we don't want to have to unify all that
stuff it's we assume you know what
you're doing so if you want to restrict
this to string right on the way in you
have to type check in advance so I'll
pack you have to give I'll pack a little
bit more information as to what's
happening you know is this important
to be as specific as possible okay so
enough of the basics the parts that I
really like the most so far in alpaca
are typed messages and records with row
polymorphisms so simplify that last bit
our records should feel really familiar
to anybody coming from either oh camel
or elm we have a few extensions a few
differences here and there but they're
pretty close so usually the first thing
people ask me about El packet is what
about typing processes and messages and
the short answer is that all method
sends in alpaca within alpaca are type
safe they are checked at compile time so
let's look at a simple motivating
example before we get into the basics of
how that works because it will explain
why so here's a really simple of example
of a process that we're going to cause
some problems for on the top we have an
outer function right it receives a
message and adds it with plus the state
so this will only handle and deserve
messages as a function below we're going
to spawn it and then we're going to send
it a string which is going to cause a
crash it's going to cause a battery tick
exception right that's not so awesome we
could put an integer guard function in
that process there but that means that
any message we send is going to sit in
the mailbox of that process forever
right so eventually your written message
receives are going to slow down or
you're going to write on a memory or
something like that's going to happen
and nobody's going to have a good time I
don't know a month from now right here's
the exact same actor code in alpaca but
now what we have is compile time
checking of our message flows so break
adder here the string that we're sending
is going to result in a type error this
code will not proceed to test and it
will not come out the other side of the
beam file it's not permitted to pass it
is a type error at compile time and
types message flows in alpaca revolve
around a particular type called receive
receiver excuse me this is what helps us
provide types Pizza types processes and
the keyword received is what yields this
particular type the message type is the
kind of messages that is that are
received by the receive expression and
the return type is the the body of the
expression like what comes back from it
right here's a particularly a very
simple example we have integer messages
because the patterns are the messages
right and we know they're integers
because all the patterns have to unify
and there's an integer at the top and we
have string body so this is a receiver
of integer messages
that yields string values pretty
straightforward but what about mixing
receivers with other expressions because
this on its own is not particularly
useful right
so I've boxed the main receiver here in
this particular example right remember
received is the thing that yields a
receiver type okay now X of course is
also receiver because X is type is the
same type as the expression it bounces
there's nothing again particularly
strange there now when we mix X with one
down here right when we when we combine
those things that whole expression
becomes a receiver the receiver type
kind of boxes outside a tree and
reinvesting that that can that contains
it right unifying a receiver with any
other expression moves the receiver to
the outside so the receiver buried all
the way down at the bottom of the syntax
tree here right actually makes the
entire enclosing expression a receiver
as well and it means something
particular for functions so what if a
function contains a receiver here I to
receive well the rule still holds
whenever an expression unifies with a
receiver the entire including a function
write the entire expression becomes a
receiver so I'm going to reiterate this
a couple of times when a receive occurs
in any expression at all you know
addition a function anything the whole
thing becomes a receiver the receiver
again boxes everything that because that
includes it smells a little bit like a
functor to me but I'll admit to not
digging quite deep enough yet so what
happens when we spawn a function to get
a process and we know that receives our
typed but how does that actually make it
to a process or a pit well spawning a
function in alpaca yields a pit no
difference from Erling there but for us
a pit is typed it's generic the type
variable here is the kind of messages
that a process can receive so if you
send a message to a pig the message type
you send must unify with the pigs
message type
okay so we have polymorphic processes
basically generic processes in alpaca
here at the top we're receiving integer
message we know they're integer because
we're doing simple addition on them
the bottom we're spawning that so when
we actually spawn G here we get a pig of
integers pretty straightforward if we
send that process that comes from get a
pit of G if we send out a float type
error at compile time doesn't proceed to
test doesn't make it to a beam file now
note also in the top right we have a
type here in the function definition are
AC and rec there means that this
function types as infinitely recursive
and we specifically include that type so
that we can type functions that are
written or typed processes that are
written the same way as earlier where
you're looping on a process if this
function ever actually returned a real
value it would the type would reflect
that but because this function never
returns it has the type of infinitely
recursive what happens if there's no
receipt you know what happens if you
spawn a process to do some asynchronous
work and you never actually check the
mailbox well in that case we get a pig
undefined app it undefined cannot be
sent messages because undefined unifies
with no concrete types if you try to
send an integer to this process here
type error you try to send it a float
type error any message you send to this
will result in a type error you are not
permitted in alpaca to send messages to
this process undefined
will unify with type variables so if you
have like other generic functions it
will unify but that just means that
undefined is propagated all the way down
and all the way down deep in your call
graph you still can't actually do
anything with real values ok let's talk
about Rho polymorphism in short our
records are intended to be safer than
maps with all of the flexibility that
matters or most of it at least so what
on earth is real polymorphism well it
solves the problem of information loss
so here we have an identity function for
any record that has a field S basic
structural pattern matching note that
we're not checking the type of X here so
this function is actually generic even
with respect to X as type X could be an
integer could be a flow to be a strength
doesn't matter being on the record
doesn't matter only the presence of X
matters so what's the return type if we
pass a record that has both x and y to
the identity function well without real
polymorphism the ID function doesn't
capture the presence of
this is a little bit like if you use or
type with interfaces in Java or C sharp
right if you get an interface back from
a function you don't actually have any
of the details about the class that's
implementing that interface you your
your code has forgotten that information
you've lost it but with real
polymorphism we actually capture it so
it remembers on the other side that
there is a Y field as well if we add
fields to a record without matching its
type if we just say this is a record
without matching any of this type we
still preserve all that information out
the other side and because records are
immutable in alpaca we talk about record
transformations rather than record
updates now the resulting type of a
transformation is distinct from the
input type just as the record itself is
distinct from the input type right when
we construct with Y it does not affect
our there at all okay and as a result we
allow transformations not only to add
members but we also allow them to
transform an existing members type so at
the very bottom here we're actually
replacing the integer X with a string X
and again because each one of these
records is a distinct type and a
distinct value this is perfectly safe
okay so in the abstract of my talk I
mentioned a few trade-offs that alpaca
makes and I'm not going to lie we do
have a few big ones so the first one is
that when it comes from moving processes
from Erlang to alpaca there's no way to
test their parameter type they are it's
an undecidable problem so that means
that if you get a process or a pit from
an FS I call your methods ends are
unsafe alpaca is going to make its best
guess based on what you do with that
process but it might be wrong there's no
actual information there to help I'll
pack it out as far as code reloading
goes it's a little bit of a gamble oh
yeah we have some initial ideas that may
be good or bad mostly around or inspired
by things like database migration tools
you know and checking the types of
things it's probably going to be a
tooling problem more than a you know
solely a language problem but it's
really just the idea stage if you have
particular ideas here we're happy to
hear them so please come help
and lastly OTP interoperation we can
build types of replacements for things
like Jen supervisor or or
and server but real OTP integration is
often going to devolve to what's really
a typecast the kinds of things we're
talking about can guarantee that things
like message types in a dense server all
line up or reply types all line up but
sort of building those things directly
into alpaca we can't actually prove that
the type of a process coming back from
spawn link is actually the kind of
process that you think it is note that
the the issue here is about proof in all
likelihood it is type date but we can't
prove it we can't actually provide any
guarantees about it so it's a little bit
problematic now the alpaca compiler
itself is actually pretty simple the
front end contains all the basic lexing
and parsing we use leaks and yex it's
just part of the standard Erlang
distribution so there's no strange new
tools involved at all
lots of good examples out there in in in
the community we actually faced a lot of
stuff initially with leaks based on
examples from LFE right so there's lots
of documentation out there I tend to
think of the ast generation stage as
distinct from the front end it does
perform a little bit of trivial
validation but most of its job is
rolling up different function versions
into one concrete ones this is when
you're doing pattern matches and
function and the function heads excuse
me and it does a bunch of variable
renaming as well so this prevents things
like variable leaking from a receipt
block or making sure that things like
you know multiple wildcards are properly
named for quarter lines that kind of
stuff pretty straightforward it should
be noted that everything after alpaca is
a SP generation stage works on our ast
we don't have an intermediate language
we just operate on the ast so code
generation turns our ASP into the core
Erlang ast and then just runs the
quarter line compiler on it directly the
last code generation stage also renames
our modules to keep us from colliding
with anything within the ecosystem so if
you have a strings module in alpaca it
will get renamed to alpaca strings and
all of the internal references and
external references in your alpaca code
will be renamed accordingly as well just
to be just to be safe and so wrapped up
as we're wrapping this up I want to talk
a little bit about our community and how
it runs
when alpaca originally became
open-source as ml flavored Erlang it was
pretty important to me to ensure that we
had a solid grounding in both openness
and
Civet II so to that end we adopted the
contributor code of conduct version 1.4
right away so any project you see hosted
under the L tackling github organization
abides by this code of conduct and while
our community is actually pretty small
it is growing and I'm really really
grateful for it as alpaca started to
look like it might actually be viable
the community aspect started to become
very very important it's virtually
impossible for a single person to know
every good idea or to be aware of every
good idea let alone for that one person
to implement everything
so for alpaca to become useful we need a
community it's not going to happen
without that and I mentioned also much
earlier that I want alpaca I want to be
able to share excuse me the competitive
edge that I think this is combination of
testing and typing capabilities brings
and if that's really a value of the
alpaca community then we need to make
our packet itself accessible to me this
means doing things like the tree even is
the initial things like
internationalizing error messages making
the parser pluggable very very important
thing we actually have
internationalization of error messages
in our master branch now so if you want
to translate alpacas error messages to
your favorite language you just have to
edit a PA file you don't have to edit
any code at all in alpaca whatsoever the
parser itself is pretty pluggable as
well you could write any parser that
sits in front of the ASP generation
stage and you get everything behind that
for free and as for growing the
community I take a lot of inspiration
from a friend of mine in Vancouver named
sangani
Sun was one of the cofounders of
Vancouver based meetup called polyglot
poly watts both a meet-up and an
unconference the unconference
yearly fees of 300 or so people there's
regular meetups that see a couple
hundred people and regular social meet
ups as well in hack nights and it's a
community that's predicated on the kind
of openness and inclusivity that I
really value and exhibits a lot of
characteristics that I'd like to see
fostered within the alpaca community too
when Simon and I were talking about the
genesis of a polyglot meetup a few years
ago he told me that he got behind it
initially as he saw it as a way to build
the kind of both personal and
professional support group that he
wanted to have and I'd like to see
alpaca be that same thing it can be hard
to find a group of compiler hackers to
with an ask questions and learn from and
I'd like to be able to provide that for
other people and ultimately a big part
of what excites me about our growing
community is being able to learn the
ideas that other people are going to
bring to alpaca will make our community
much richer and make the tool much more
robust as well the community itself
right now mostly communicates via gift
how the issues and pull requests the IRC
channel is sporadically active and the
mailing list is very young we've used it
mostly to announce releases or
coordinates and bigger picture ideas but
please come join us in all or any of
these forms at your convenience as far
as where to help us out literally
anywhere there's a huge wide open space
now so if you want to come and leave
sort of your your imprint your ideas in
the concrete of alpaca by all means come
talk to us any time any way here too we
have a number of community projects that
are already useful a rebar three plugins
so that makes it fairly easy to get
going with alpaca right away and mix
both alpaca and Erlang code from the
get-go there's a simple shell that's
actually bundled with the rebars free
plugin so it's like a very basic repple
that it's in early stages
there's a simple Emacs mode that did all
the syntax highlighting for all of the
stuff that you saw so far and a visual
studio code integration - it's all in
the early stages but everything shows a
lot of promise and again it's pretty
useful right away we're starting to
sketch out the beginnings of a standard
library - there's one module in it so
far and haven't really settled on how
that's going to be available for
projects that use the plugin yet the
rebars free plugin so there's a lot of
room for ideas there - tooling is really
a wide open area right now especially -
with respect to how we output an
organized documentation we don't have
solutions for that yet it's really still
so early that we can use your help
literally anywhere simple and really
excellent places to start are writing
examples for other people to follow
along with or write library bindings
with our F of five to make other things
immediately useful joining documentation
efforts or just helping us direct sort
of the course of inquiry and ideas and
finding new directions are all really
really valuable ways to participate or
just use it and break it please find
some bugs
there are lots there under the hood I'm
sure we really would love to have more
participation in every
and any aspect of the community
including compiler development if you
want to get into the guts of the typer
and want a guided tour I'm happy to do
that too I'm personally pretty
interested in getting alpaca self hosted
and writing a code format or NL packet
directly but we do have a bit of a
distance to go yet before we're there
and finally just to close this out I
wanted to give you a few links and but
we will be in the slides that are
available shortly as well we have a
basic language tour in the github repo
so you can see in a bit more detail all
of the features and functionality that's
there including binary and all that
stuff
the typer started from a oleg Castelli
outpost on how the o camel type checker
works in fact the very first version of
our typer was almost a literal port of
his Oh camel code to Erlang and then we
just expanded from there and the last
one there is a great presentation on row
polymorphism if you want to get into the
guts of how things like field addition
and removal work we don't actually
support removal right now but it's a
thing that we could talk about and with
that
thanks for coming and I'm happy to take
questions we've got a few hands
I'll let the guy with the mic pick where
we're going first yeah why that's that's
a great question I actually became aware
that after the first open sourcing of
what alpaca was it looks really neat
they actually I think do some I haven't
looked in a ton of detail but do some
similar bits around I think they have a
similar idea to receiver it's not
exactly the same but there's there some
similar tracking it's really neat it
uses pure script FF I and I write like I
bet that standard thing which is fine
but I wanted something that was a little
bit more directly compatible with Erlang
as well a big part of this is I wanted
it to be buildable in Erlang so that we
could just kind of you know bootstrap
there and get up and running right away
yeah but it's a super neat effort I'm
really curious to see where they go with
it yeah
and by sure sure I'm not super familiar
with typescript so I'll try to answer
your questions effectively and you can
you can correct me if I get off course
as I understand it typescript is sort of
bolting annotations on to JavaScript is
that about right okay right yeah yeah I
will admit to being a bit of a language
zealot in some ways there and wanting
the expressiveness of ML yeah well yeah
it's there was a there's a certain sort
of expressiveness that I think case
classes bring specifically and you know
records and type constructors feel close
enough to me that I wanted that kind of
thing you know we can approximate that
in Erlang of course right with with
tuples and such but I wanted a little
bit tercer briefer kind of thing
happening so it there's definitely a bit
of a desire to be slightly obtuse there
all admit to that yeah oh cool Thanks
yeah that's an excellent question
the I'll give you two answers the short
answer is I don't know the the slightly
longer answer is I'm I think the thing
that I'm most enthusiastic about right
now is traits approach similar to rust
type classes are nice I have some
negative experience in Scala with
implicit and the implicit conversions
and things that makes things a little
mysterious sometimes and so I want to
kind of stay away from as much magic as
possible although we are talking about
things like the oak handle implicit
modules paper that's come up a couple of
times you know straight type classes
like hassles are an interesting approach
as well and I think relatively similar
in some ways to traits so if you have
particular ideas I'd really encourage
you to come hang out and talk about them
it's something that that keeps popping
up here and there and I think it's going
to couple with how we approach something
like a gen server right because we need
to generate a module from a set of
function yeah I think it's going to look
something like traits and role
polymorphism with records like something
in the middle there and I just don't
know yet to be honest I hope that's not
an unsatisfactory answer okay cool okay
you can feel free to come bug me
anywhere today as well but yeah yeah
so the annotations are actually
restricted to airline guard functions so
you can only tight you can only use the
primitive type annotation so cowboy
specifically is an interesting case
because I actually have a bunch of
cowboy code deployed at work and I think
we probably need to talk about something
like a no more opaque bridge like a some
sort of opaque type where we say I want
you to call this function in this module
and I'm going to assert that this is the
type like some arbitrary name like a
cowboy request right like how do we type
that right maybe that's that's sort of
the example and in that case then we
might have additional restrictions like
well you can have these opaque types but
if you have them you can't put them in a
union right you have to use them
standalone it's that's not necessarily
desirable but we're probably that's
that's a potential angle the only other
way really to do this with cowboy is to
say well we're going to be structure the
tuples right in the FFI and kind of get
nasty that way but yeah we're limited to
the guard functions inner line because
we actually compile those could we
output those guard functions in the
quarter line directly because we want
the runtime checking and the compiled on
checking does that make sense okay is
that it yeah
yeah in master you'll note that there
are a few ASP nodes that are now defined
in L packet directly so things like
function names variable names those are
considered a symbol in the lexer and the
parser and symbols actually now are
defined in alpaca as a type constructor
and wrote polymorphic record so I think
it's going to be sort of a gradual
process although I was talking with
Tristan about the rebars pre plug-in and
I think I might have painted us into a
corner in terms of bootstrapping there
the language back that back out I think
it is going to be a gradual process
probably starting with the ASP and then
replacing bits as we see opportunities
if you look at the type or code it's
about 6,000 lines including tests and a
lot of nested pattern matches so there's
the up there's a lot of opportunity
there for us to simplify things I hope
that's a satisfactory answer I know I
didn't it's not very direct but we don't
have a really clear plan yet it's going
to be sort of piecemeal and seeing which
bits are easiest to bootstrap first yeah</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>