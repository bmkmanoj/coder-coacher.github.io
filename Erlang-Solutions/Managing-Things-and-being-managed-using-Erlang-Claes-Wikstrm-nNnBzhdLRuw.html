<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Managing Things and being managed - using Erlang - Claes Wikström | Coder Coacher - Coaching Coders</title><meta content="Managing Things and being managed - using Erlang - Claes Wikström - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Managing Things and being managed - using Erlang - Claes Wikström</b></h2><h5 class="post__date">2013-11-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nNnBzhdLRuw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so good morning everybody
I am going to speak an hour about
network management managing all being
managed and I'm it's going to be a tour
through some of the management protocols
we've had in Erlang over the years but
before I do that let me start by
introducing myself some of you know me
very well but I think majority of the
audience here and may have heard of me
but don't know who I am so I worked in
the early days at the CS lab when we
were developing Erlang in the good old
days and so during during the nineteen
Tsar all of 1990s actually I was working
with a virtual machine and did a lot of
work on the virtual machine and large
parts of it remains there so things I
did at the time were things like ATS and
debts and mini Jie and the garbage
collector binary is the driver
architecture the bit syntax lots of
stuff distribution lots of stuff a lot
of that work together with tony rogge
well so this was during a period where
there emulator grew from I think 8,000
lines of C code one tone and I started
on it and and it's been growing since
and now it's a beast it's a fantastic
beast
it's an amazing piece of engineering and
it's well whatever and since then I've
been so Joe showed a picture the the
other day and referring to the DNA of
Erlang and he was showing blue tail
clarinha and tail if and I can relate to
that because I was a founder of all
those three companies and currently I'm
working tail F which is a company
specializing on network management we
started 2006 and so I've acquired a few
opinions on network management during
these years and I'd like to share some
of them with you today
and I will be doing it in the form of
going through management protocols that
we've done in our
over the years so I'll be showing some
software which is part of our 2p and
some which is not and a lot of this
software a lot of you have used over the
years so let's start let's start with
what's the story what's that what's the
task a lot of you are writing software
that needs to sit somewhere in some
actual commercial environment or at some
wherever wherever your software is
supposed to sit if it's real software
that's supposed to be used by others
than engineers then the software needs
to be managed and there are two
components in managing software like
having software in your software which
allows it to be managed and then so
that's the agent this is man s an MP
speak I don't actually know where the
name agent comes for it if you could say
server and the other end is the client
which in SNMP speak is manager so that's
the client that connects to somebody and
manages it so I tell if we do commercial
software to do precisely this we're
doing the agent side which was sold to
companies that do switches and routers
and whatnot so if you go buy a Cisco
router today you'll find our software in
it and vice versa if you have a thousand
Cisco switches and a thousand juniper
routers and you need to management we do
that sort of software as well so that's
what we do and we export that software
and it's commercial software and it's
not open source in the beginning was the
config file this is the easiest way to
configure program this is something all
of you have done and there are actually
good and bad config files as well this
is an example from a jaybird account
it's just an airline term do you like it
it's horrible it's horrible it's there's
no way for the user to
to look at an existing config file and
figure there's no schema there's no
nothing there's no guidance for who has
ever is supposed to edit this file and I
bet you if you if you do an error
configuring the ETA body that the
message you get back is not going to be
super instructive so the only thing
that's good about this is that it's
really easy for the programmer doing the
config file it's it's a one-liner in our
line to read in the config file not good
don't like at all slightly better that's
still not good so this is from Josh
Kampf yours is another on my project of
which I started many many years ago and
this is not my finest moment it's it's
it's ages ago on it looks as if it's
some kind of XML ish thing I'd probably
seen XML but didn't grasp it at the time
horrible horrible and if you look at
open source projects there there are if
there's some that have really really
nice configuration file syntaxes so my
favorites is that they config file for
nginx so if you're going to do a config
file format have a look at the nginx
config format that recommendation an
alternative is old Microsoft style ini
files they're they are actually ok this
is not ok so now I'm going to go through
a number of pieces of software that we
have in OTP that has been so this is the
reason I'm starting with is than one
compiler is is the first piece of
management software that was written in
Erlang that was maybe it's not but it's
is one of the first pieces so a Zen doc
man it's it's an ideal
it's a strange ideal it's got it's it's
it's been around for ages it originates
from ccitt II and it was heavily used in
in OSI networking stacks you define data
structures like the one on the right
there people blah blah blah person
location and then the the a stand what
one contains marshaling encoding rules
see how one of these data structures you
can get it into a stream of bytes send
it on a network of writing on a file and
vice versa you can reproduce the
original data structure at the receiving
end not rocket science it was heavily
used in the disgusting OSI a management
protocols see me at the time so this was
early nineties when we did this and
Ericsson for example was completely
infested with the idea that the OSI
protocols and that was not just for
management you remember Solaris came up
with a version that supported the TCP
using using that horrible what was it
called TT pls no no one remembers and
come again
anyway horrible stuff and is it's it's
all gone and no one is missing it so I
did the first day is done compiler and
can it completely rewrote it and making
it in making it actually workable usable
this is this is a little bit this is a
nice slide actually it's a long jump in
time so there isn't what the original
code was written early nineties but we
look if we look at the implementation
now it looks beautiful look at this code
it's fantastic it's bit syntax at its
best some data comes in and and just
right at the at the header you pick it
apart and and so this is almost a
specification of the of the protocol
itself it's fantastic I guess this is
Kenneth code it's good that we have it
it's still the the language is still
heavily used within a number of ITF
orifices so all of the security related
orifices so all of those the security
framework surrounding Isaac mp4 IPSec
and all of those horses they were using
they using is no no no and I think
they're using it in Indian DNS SEC as
well so it's still relevant highly
relevant so is really nice that we have
it and I'm sure that that the existence
of it has facilitated in number of
different protocol implementations in
their LAN community over the years so
it's great that we have it the
alternative would be horrible here's
another one disgusting little protocol I
said that I said that before early 90s
telecom industry was all confused about
oversee and I was working at the C slob
and Joe and I wit had a little session
out to a place in Kong oscura where they
were doing cross connect optical digital
cross connects and they were all about
OSI Management and they had they it was
so much vaporware and there was no
actual code and they were all talking
about the OSI specs and see meet band
and it was and then at the time I heard
of as an MP which just had come out then
at the time and I thought it's got
there's gotta be an easier way than than
than the OSI stuff so I signed up Martin
Bjorklund and closed Ericsson as thesis
students at see slab then I this must
have been maybe in 1992 or something
like that and so they did they did they
didn't a proper SNMP implementation and
that's pretty much the same one we still
have in the in in the OTP distribution
so referring to the actual protocol
itself
one thing they did get right which very
very few management all been
in quite a number of different
management protocols here and a lot of
them did not get this one thing right so
SNMP it's more than a protocol it also
defines the payload using a formal data
description language SMI so you have the
protocol to send to from from the
manager to the agent do this what's the
counter what's the value of that bla bla
bla bla bla so that's over the protocol
but the actual payload whatever comes
back in the response from from from the
agent when you read the counter or
whatever you do with Trevor is a table
that data is defined formally in the SMI
language so this is one of the things
they actually got right this is what
makes it possible for management
software or engineers doing the manager
side to have a look at those SMI files
and see so kind of data do we have on
that device the alternative is is ad hoc
random if you got a REST API for example
it's ad hoc Curling to the device and
see what you get yeah and figure out
from the names of things you get what it
actually means so this is one of the
things they actually did get really
really right SNMP is ubiquitous it's all
over the industry so whatever you build
if you're going to install your software
in another alien environment like at an
operator or at a bank or in a data
center or wherever you're bound to have
an SNMP agent on your software so it's
it really good that we have this high
quality as an MP agent in the OTP
libraries so don't be afraid of all of
adding it to your application it's a
breeze to write your own tiny little
Maebh define your counters feed that
into the SNMP compiler and then you have
an SNMP agent on your software making it
easy for the environment where your
software should go making it easy for
them to monitor your software and mind
you I say monitor because you can
actually do two things with the SNMP you
can read data but you can also write
data if you look at
a Cisco router for example they got a
slew of MIPS but they got they read-only
all of them all these MIPS in the RFC's
they define some read-only data and some
read/write data but Cisco turn it all
read-only and there's a good reason for
that
they don't want some SNMP manager to
send dis periods as an MPPT use to their
routers reconfiguring bgp that's way too
dangerous and so they're in the
networking industry for the past 20
years there are fairly few examples of
successful SNMP readwrite projects I
know that some telcos ericsson is one
alkyl ooh is another I think alcohol was
more successful with this than Ericsson
they had the manager called Sam which
was as an MP based and that's actually
still in production today and considered
a good manager so but in there the rest
of the networking industry which is more
IP IP oriented is read-only and and I
recommend do not recommend to use as an
mp4 rewrite the last bullet here is a
bugger it's it's it's one of the things
they really got wrong with SNMP so say
that you're running a switch or a router
or your pieces of Prayer whatever
there's no way to over the SNMP protocol
acquire the configuration in the actual
configure the device and then feeding
that into another there's no way to get
a copy of the config you cannot take a
backup of the config over there's Nampa
protocol so that pretty much limits the
usefulness of the protocol nevertheless
it's good and as I said before it's
fantastic that we have it if we didn't
have it the alternatives would be
horrible I mean you would have to
interface to two netizen MB or it'd be
it'd been really ugly
exhaie sting implementation exists there
at its port it's an OTP application as
most of you already knew authors Martin
bureaucracy exon and Peter hug felt he
used to be an active member of the Orlan
community is participated as well fifty
six thousand lines of code and this is
the compiler the client or the manager I
should say and the agent the server
here's some code this is so if the
previous code you saw was the bit syntax
that's classical protocol implementation
code for Erland this is the other
typical classical protocol style of
decoding decode this code gets a
sequence of bytes first byte is one six
four it's a trap then you have a
function that takes the remainder and
does something and then a bunch of
function that picks up something and
returns the remainder picks up something
returns the remainder from a sequences
of bytes it's classical colt it's a
matter of taste if you prefer to use the
bit syntax or have the the Porsche go
through a sequence of bytes and abettor
this code is old and if it was to be
rewritten in in today I'm sure they
would not chosen the bit syntax here's
another one very unknown mystic orb is
actually in the room Steven OC I think
he was one of the part of the original
team that developed the the first corpus
Peck there's a there is a core by good
Corbin implementation in Erlang done by
lucien pardonnez on Theatreland L and
Nicholas Eckland Nicholas is working at
a left just right now so the reason we
have it is because it's mandatory to
have it for configuration interfaces in
the GSM network so a base station must
according to the specs I don't know if
all the base stations do but they must
have a Korbel server so that you can
manage the base station of the Cobra
protocol it's nothing more than a
glorified RPC mechanism there's it's a
big beast but but if you look behind the
lid there is not a lot more than
then the nicely easily understandable
son or its twenty five twenty nine
thousand lines of code it's that
contains the idea of a compiler and
everything
typical bits in tax code beautiful code
to decode the the the packet header here
love this type of code
now we're getting something which is
slightly more modern what I've said so
far ancient style of protocols that most
of you young guys here find arcane
probably and but even if I ask nappies
arcane use you're still gonna have to
deal with it whereas core by you can
probably ignore this you cannot ignore
though rest HTTP HTTP so if you're
building something
it's almost required today to have a web
UI or and it's to have a REST API is is
becoming very modern so main benefit of
the rest if I rest let me spend 30
seconds on what mode a REST API is it's
HD it carried over HTTP you can get a
URL in the device or the application
you're getting back a set of resources
which contain data and other URLs and
then you can get those as well and then
you can post and patch on those
resources on those URLs thereby over
these rest api using Curl Curl is the
typical or a Perl program or a Python or
an hour long program for that matter in
this type of environments these operator
environments where then then the guys
running ops in these type of
environments they're typically Python
and Perl shops and they love they love
rest api is all those guys so main
benefit of it is really easy to
understand it and it's super easy to get
started you you go you power up this
Steve shining new box and it announces
something over port 80 or or
4:43 you can curl there and see I'm
getting stuff back here and it's a
structure I can look it's a JSON
structure or an XML structure I can look
at it again from the names of the tags I
can guess what they mean and I can
continue to curl through that they're
down the device this is really really
easy and it's nice if you're if you're
an ops guy and all you want to do is
patch up a little Python script do some
simple provisioning on this device or on
this application it's perfect it's
perfect right here if well design it's
almost self-explanatory and and we have
a slew of nice web servers and web
technologies in the airline community
now so whipping up a REST API for your
application or your device is a walk in
the park the negative and this is a
biggie
so rest is fine but it's actually barely
usable except for the case where the ops
guy whipping up a Perl Python script to
do some naive simple provisioning for
integration into into a larger context
it's useless worthless
so the and that's because the payload is
structured but it's there's typically no
formal definition of the payload and
that makes it virtually impossible for
someone above to integrate towards your
device by guessing the tag names they
need to write custom code in order to
integrate towards your device which
makes it horrible and a lot of device
manufacturers today they proudly
announce we have a REST API and we ship
JSON structures but that doesn't help we
can use XML schema to define the payload
but but that's pretty pretty awkward and
as far as I know there are no wealth
good formal ways of defining jason
structures maybe there are I said before
the slew of nice web technologies to
choose from
personally I'd go for yours but that's
because I'm highly biased
the other ones are fantastic you also
has 35 thousand lines of code that last
bullet here is not to be neglected
maybe you should scrap all this web
server and roll your own they it's a
walk in the park to write 50 line web
server in Erlang and the reason for that
is because we have the packet HTTP
option to to TCP sessions so if you
create a socket like this this is not
news - I guess the majority here but
this is great stuff you create this
socket like that and yeah you're getting
and when you read you're getting HTTP
stuff
Heather blah blah blah you're getting
the HTTP these things on on the soccer
on the socket so it's which is what we
will do what you sing is a shortest HTTP
server done is it 50 lines 10 lines
right right so this is not to be
neglecting and neglected anyway we have
fantastic as a cell implementation and
these days it's an hour long based an
SSL implementation done by OTP team
great work rest continued we have
interest we the payload is it can be
text or Batory text that you whatever
text you like it can be anything the
most common is now Jason structures or
XML structures in the payload for for
for for your rest calls we have
fantastic fantastic support for both
JSON and XML in in Erlang if I if I
should do a recommendation I'd go for
the JSON payload it's also hipper
next somehow though how much we dislike
it we are going to have to live with it
it's here to stay and it's not going
away and there is there is no way that
you can survive as a software engineer
without being XML knowledgeable you have
to know what a namespace if you don't
you might as well go look for another
job we got several nice XML parsers to
choose from both Dom based and sax based
the Dom based parser they read the whole
chunk and represent that as one big fat
tree that your code then later can walk
and traverse so the downside there is
yet you need to parse the whole thing
before you can do anything the sax based
ones they work on a stream eating tokens
and then your code needs to act on those
tokens and rebuild building tiny little
stacks and doing things like that
depending on the application you need to
choose one of them so one my favorite
XML parsers is not XML that will figure
on several orders here in the in the
room here wrote many years ago it's a
cool item and the author is actually
here we Lim the young a - guy and it's a
really fast and is really lightweight
and it's easy to understand it's at LF
we did our own for reasons I'm not sure
of actually but that what they did you
carry grab energy that XML schema I
absolutely hate it it's it's the most
horrible piece of engineering it's meant
and it can you understand it's meant to
be read read and written by humans
that's the program I mean it's the
schema
it's an engineer needs - it's not meant
for machines to generate it you're
supposed to write it with the simple
type complex types and all of its
horribly complicated nevertheless you
need to know it that we have XML support
I bet you nine out of ten May or maybe
four five out of ten a lot of very long
projects are using XML in in some form
today okay not to be underestimated so
we have a nurlan program and we want to
manage that and we write the client in
Erlang as well great stuff right
early cool using distributor we can from
the command line invoke any function
inside in Erlang node and each a body is
controlled this way it has some serious
security implications it's all the whole
management of the node hinges on the
Erlang cookie file oh that's what you
get right it says and the cookie file is
as bad as you can think because beneath
it we actually do have the airline
security the security foundations or of
the of the UNIX file systems and they're
solid so as long as you know what you're
doing the basing your your your your
whole security of the management for the
server on based on on file securities or
maybe group secured fine fine but you
need to know what you're doing and you
need to be aware of it so the earth call
it's using turn to binary and binary
terminal it was mentioned yesterday it's
a it's a it's the it's the it's
fantastic turn to binary and not only is
it so easy it's so easy to use so that
we're actually forgetting that we have
this tree or queue or whatever data
structure where have we do turn the
binary on it and so we it's so easy to
use you actually tend to forget that
what we bypassing here is the entire
idea of course on RPC or alright and
that one well or whatever other cruft
they made up we did away with all of
that fantastic there's a downside to it
there's always a program there is always
a corn the corn here is that there is no
formal document describing this
structure so well you win some you lose
some
another really good thing about eternity
binary is that it is so fast I don't
know if you're aware of how fast it is
compared to traditional martial arts the
marshal is you you find in in in in in
core but for example so it's super fast
and it also produces very compact output
so it's it's it's great technology
number three here normal socket to
localhost and sending turn to binary
yours is controlled this way so instead
of using alcohol just create a socket
and send terms on it and and and again
make up some other file based security
mechanisms so that only if you're within
this group or within this if you are
this use or something like that
you need to be able to figure out the
cookie send it on the socket and this is
how you what is doing it's remote
controlling you have the server and you
want to control the server at least you
want to be able to stop it right that's
that's that's number one without using
kill so idea I mentioned this there is a
positive positive and a negative to the
idea the interface is embedded
implicitly in the client-server code
this is not good
right so in order to figure out what
what can go on the wire here what are
the messages we need to go into the code
and actually look at the code and see
what it decodes and what it does on the
structure it decodes maybe the code
isn't even comprehensive it's it's not
covering all the cases we don't we don't
know I will never be able to defeat find
out so that's the downside so you need
to as I said in Denmark thought it under
made a good they're great C and Java
implementations in the of the external
turn informant so it's really easy to
interface to the external world I don't
know if there are Python the
implementations I suppose there are
three here showing turn to binary
turn to binary
so we have a term a tuple we can produce
a minor you all know this great stuff
this is by the way this is also the
basis for distributed Berlin distributed
Erlang is obviously using this to to
send the data over the wire with an
additional really clever trick and that
is a tiny little atom cache so atoms in
the term to binary format we we see
Carla here
so Kelly goes very bottom so 104 means
atom no 100 means a term no 100 means at
them and Oh fie length of atom and then
comes 107 not said it counts the actual
atoms so atoms going in atoms go
verbatim on the wire
whereas in distributor Erlang we're
using a little clever trick whereby
atoms go into a little atom cache table
and the first time the whole atom goes
in the second time just an index into
that 256 byte cache goes over the wire
so how am i doing on time coming up okay
okay so I'm going to spend some time so
I said I'm working at a company called
teh left now right now and we are in the
network management business and so
obviously we writing network management
software and I need I need to mention
some of the software that we have and
in order because that's the topic right
so net conf is a new protocol defined a
couple of years ago by the ITF and well
not new and new it was invented by
juniper and it has an accompanying RFC
called yang and so those two protocols
net confine yang
they are the equivalents of the SNMP
protocol RFC's and the SMI RFC's
defining and RC defining the SMI
language so as net confidence the
protocol and yang is a modeling language
to define the payload for that protocol
so this is the first time the networking
industry got it entirely right Vasavi
management aspects and by right I mean
that a device or an application is
shipped to a customer and then that
customer is tasked with the task of
integrating that piece of equipment into
their management whatever management
applications frameworks they have so in
order to do that the device must have a
crystal clear interface not just the
protocol how you talk to it but also
what data can you send to it and what
data are you getting back what how you
talk to it is precisely defined by the
network protocol which is well thought
through XML based RPC mechanism is nice
I'll I'll show you some some some
examples of it soon yang know is used to
define the XML payload in the Netcom
protocol so you're using yang to define
the data structure here's an interface
it's got these leaves and the so it's an
alternative to XML schema you define
it's a readable and writable version of
XML schema and it's the it's it's
designed with readability in mind so
RFC's are written once but they read
many times over and over again and that
means that it must be easy for the
end-user to read the spec or the RFC
another thing they got really right here
in this protocol is that they're making
a distinctly distinguishing between what
is config data and what is not and so
when you're writing your yang
specifications for your device you need
to define this is config this is not it
sounds easier than done sometimes it's
the line is blurry but a lot of the time
it's not and the way to think about it
is that if I would like to take a backup
write it on a file and then next week
reinstall from that what is config that
that's a good way of thinking of it
thinking about it everything is
text-based here as well so you can get
anything into your Emacs buffers and
manipulate it lovely this is not the
case with a lot of the other management
protocols transactions so this is
something I'm going to spend some time
on here now we won't when we reconfigure
things in a number of applications or we
reconfigure a network we want to be able
to do that as a transaction so say I
want to change two routers on one switch
I send that to change to route 1 and
write a 2 and then to the switch and the
switch I don't know no I don't like this
says blah maybe you're talking see lied
to it and it comes back with an error
string at this point you're pretty much
screwed there's no easy way to figure
out if you're talking C light to the
device and you you've produced a number
of VLANs created virtual interfaces or
Mabley created the number of vrf so now
on the router there's no easy way to
figure out how to undo that there's no
reverse same thing if you sent a bunch
of SNMP PDUs or if you issued a bunch of
curl requests to to your application and
some are you the manager what I'm
changing my mind I don't want this
there's no there's no easy way there's
no way at all actually to to
automatically undo what you just did so
what they did here in the Netcom
protocol they
right but getting that into the protocol
the mechanism that not confusing is
called confirm commit and it's like
two-phase commit for databases sort of
but it's much cooler and it's a network
key so these are messages that would go
from the manager to the agent we're
locking the candidate and we do that for
a number of devices the two routers and
the switch we're locking the candidate
no one else can touch this guy now then
we're sending an edit config Orpah city
and this contains the actual payload
this is what comes here I want to create
a VLAN here bla bla bla this is the
payload I send that to the candidate of
the three devices you got it you got it
you got it they all happy with it they
reply all okay so far we've only
modified like the shadow copy of the
config on the device next thing we do we
send a commit with a confirm tag there
at this point all these guys they will
go up they will go live with this
proposed change so after they will get
the commits confirmed message they're
the top one there they are all alive and
this thing is now operational on the
three devices or on the three thousand
devices if they do not get the commit
message within a stipulated time out
they will automatically roll back if
they lose the SSH socket to the manager
they will automatically roll back so
this is a way to push out a change in
the network view your SNMP trap logs and
see if full this breaking hitting
the fan no it looks good you see the
commit message so it's a way of a
staging thing towards the network it's
not like two-phase commit or databases
because you typically need human
intervention there at precisely between
these two messages so this is great
stuff juniper invented it and it's part
of
it's part of the Netcom protocol and
this is the technology that makes it
possible to do network wide transactions
you want to push out a change to a bunch
of devices and all of them get it or
none of them get it not an easy task and
if the devices speak all they have is a
homegrown fancy JSON based REST API
there's no way to do this this is some
yang code list blah blah blah blah blah
blah it it pretty much has the same
semantics as XML schema sort of it's
used to define payload and and the
payload is an XML is readable and it's
almost self-explanatory we have is it's
not particularly interesting so this is
a tiny little way of getting the data
from a device you can send a get config
request to it and you're getting the
payload back in an XML format this Eli
is ubiquitous the network industry is
it's every device has to see life you
cannot buy a device without this Eli
there are two main sea lice in the
network industry where one is completely
dominating and it's a cisco seal i so we
have a tail if we have an implementation
of a cisco seal i define the data model
seen in yang and you you get a cisco
seal i for it and basically all Knapp's
network equipment providers that are
doing switches and routers there you
know about it's got to be a cisco seal i
and it's got to look exactly like this
first eli has two aspects one is
entering config so this is config show
running config blah blah blah you can do
no and set and things like that the
other aspect of this cisco salah is the
show commands you do show routes or show
bgp or show ports in you getting stats
back
that stats is unstructured text and this
is how the networking industry is built
so we have these huge networks today
right with billions of dollars or worth
of switches and routers and all those
switches and routers within all the
Facebook racks and whatnot they all have
that seal I so in order to provision
things on these devices we have Perl
scripts that and so that's screen
scrapes towards these switches and
routers and that may work well for for
config fine that's fairly structured
anyway but what's worse is that those
same Perl scripts they used to do show
routes and show BGP in order to plan
they parse the text output and this is
how the entire need the Internet is
built today so it's built towards the
cisco c lie and it's built with Perl and
duct tape and that is a scary thought
and so there's a lot of work to be done
in order to remedy that situation and
besides this is an industry that is not
like agile and ready to change we think
of ourselves we can change we we were
using new methods we're changing
languages bla bla bla bla bla
these guys they're they're they're
they're conservative they're this is not
another CLI Juniper devices they the
Cisco's Eli it's based on commands you
do command setting commands whereas the
junipers Eli is a much nicer model the
idea is that you have a conceptual idea
of the configuration as a tree and the
the junipers Eli manipulates that tree
that's easier and it's a nicer ID but
the general Priscilla is not at all as
common as as a Cisco Scylla for obvious
reasons this is the latest fad
Sdn Software Defined Networking OpenFlow
is is getting all the rage now
personally I think it's not going to fly
very high it may solve some issues some
problems but it's not it's not something
that Cisco needs to worry about I don't
think so in a way so we have the view at
Alif we have the view that what you want
is say you have this network millions of
devices different vendors different
brands and if firewalls VLAN
accelerators switches routers whatnot
and you have this and what you want as a
network management programmer you want
to have a conceptual tree which is the
network and what the network programmer
then does is write programs that
manipulates this tree and so if we can
get air and we order with tail of
software the programmer manipulates this
tree and then commits over the tree and
whatever needs to be done is done and
it's so much easier and that's a
computer science task to manipulate the
tree we can hire a guy off university
that knows how to manipulate the tree
whereas the other task or actually
reconfiguring routers in the network
it's much more it's much more difficult
it's it's all the routers are autonomous
because all these old BGP and all those
protocols they've done they designed in
order to so each device should be able
to function in its own right and only
get its information from from its
neighbors so we'll see where all this
goes the networking industry in Silicon
Valley now is in turmoil and everybody
is arguing with everybody what should be
done and we'll see where it all leads
regardless the idea of programming the
network instead of sending out those
guys with black t-shirts ponytails and
bad attitudes to recon
the routers that that's a great idea we
with you yeah we want to go there and if
you talk to management they really want
to go there so I float about separating
the forwarding plane from the control
plane forwarding plane is whoever ships
that IP packets control plane well that
the sea lice are up and they should be
they should not be on the same device
that's that's the OpenFlow ID so topic
spoke about our open flow management
solution we so we've done an open flow
controller Intel F as well that we've
integrated into and CS which is that
tree I was talking about and so now we
can have nodes in the tree which are
open flow controllers we're using travel
ping flower a flower flower from from
travel thing which is a sort of open
flow library routines you could call it
to encode and decode the packets a great
great software great software the last
one is this is where the networking
industry wants to go and this is we
don't want to control switches and
routers we want to do we want to program
services so if you consider a VPN for
example it's got its it's got its legs
and it touches a number of routers and
and maybe you need to add a leg maybe
you need to make it multi multi mesh
blah blah blah whatever so as a
programmer you just want to talk about
the VPN you don't want to know all that
you don't want to go in log into all the
routers to do it and error-prone and
it's also the case that 10-15 years ago
networks were more static it was
realistic to have the guy with the
ponytail go and actually configure the
router and then you're done with it now
networks are changing all the time due
to different characteristic due to for
different reasons the virtual machine is
fired up and it needs a new VLAN whatnot
there's a lot of things that that make
networks change more often and it's
costly to do it so this is where we want
to go we want a program
services and we instead of controlling
switches and routers so that concludes
my talk so thanks a lot for listening
any questions yeah you said it's
impossible to get all the conflicts via
SNMP yes but you can always get a string
back so if you have some kind of
conflict for well you can have all the
contributors strings so what's the
problem with sending the whole string
via SNMP number of numbers the whole
configuration as a string yes so what so
you're proposing to have a field in the
mid but where one of the fields is a
string containing the entire config yeah
ok I got it
you're fired
exactly it's gotta be it's gotta be
containing one UDP packet oh okay thanks
for listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>