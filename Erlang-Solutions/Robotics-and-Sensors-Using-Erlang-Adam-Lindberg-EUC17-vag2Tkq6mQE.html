<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Robotics and Sensors Using Erlang - Adam Lindberg - EUC17 | Coder Coacher - Coaching Coders</title><meta content="Robotics and Sensors Using Erlang - Adam Lindberg - EUC17 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Robotics and Sensors Using Erlang - Adam Lindberg - EUC17</b></h2><h5 class="post__date">2017-07-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vag2Tkq6mQE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you Bruce so let's get the slides
going yes so my talk is titled robotics
and sensors using air line so it's a
talk where we're using our Grist
platform building embedded systems with
our lang and interfacing with the with
the real world my name is Adam Lindberg
I work for parrot singer as Bruce said
I've been doing a little bit of
everything and recently got into
embedded hardware basically and
low-level things carry low-level things
so this is where I'm at at the moment so
the outline will be I will describe the
hardware of the grasp itself we'll talk
a bit about what components you can
connect to it what the goal of our kind
of interfacing with the sensors and
components I'll show you how this
software is structured so we're talk
about how we get our lying on this
embedded board how you will develop on
it how how we build our drivers and how
you build high level drivers and
applications in our line and then I'll
wrap up with some future developments
what we're working on at the moment and
I will sprinkle some demos in between
here so we'll get the little bit of fun
as well so in fact I will try to be as
bold and start with a demo so let's see
this is a very high resolution can i
mirror my own display okay this is a
little bit better so what I will show is
I will show the grass board the hardware
itself and what I will do is I will
basically start the system so just
remove everything press the reset button
and watch it boot so this is what you
can see in this this window here I'll
make it a bit bigger
so what happens is is we boot the boot
loader the low-level stuff we initialize
the hardware and then you can see here
in the middle we're starting the Erlang
runtime and that one will boot this is
the point where it kind of stops a bit
so what happens is that the Erlang
runtime is started and now it starts to
basically load up the VM and load up all
the OTP code so in a short while we'll
see the the subtle logs start appearing
and then we're actually in real or
langland
so the reason that this is a bit slow is
because we're still working on the
sdcard performance so currently we don't
have any direct memory access there for
reading from the SD card is a bit slow
and the Erlang is kind of fighting a bit
with the IO reading from the card and
printing to the serial console but we
are booted so this is a gnarling shell
we're currently running on some Cree
17 version almost 17 because that's what
we had bar patches on the goal is of
course to move the later versions and I
will talk more about this later in the
talk so this is a normal Erlang shell
stuff that you're used to will will work
so we can start by checking where we are
and we are in our little embedded world
where there is not so much on the file
system and actually checking what's in
the SD card you can see the tracer link
stuff in there so the program that's
running right now is this is being here
so we're actually running our line on
this thing there is no kernel no nothing
there's Erlang on the bare metal and to
spice things up a bit
we have a grist run time so I can do
this this will be a bit slow again
because now our line goes down to the SD
card and try to like search through the
code path everywhere to find the right
modules so soon the Russell output would
come so the grist run time is basically
a knurling application that runs in this
Erlang VM has a couple of processes and
has a couple of drivers
that can interface with the Grist part
where so it provides you with a
high-level Erlang API to all the
hardware nasty hardware stuff and it's
starting to become quite a few
processors because we have some
different ports and functionalities we
have drivers for things and for the LEDs
and so on so this is what I will demo
now maybe I can just put it here for now
so you can see the LED there a bit so
this is an example module I'll use I can
everyone see this or should I bring it
to the tire let's do it this so it's the
LED module nothing fancy
there's two RGB LEDs on this so I'm just
going to set one of them to red and yes
it works very nice and let's do
something else who - the second one blue
for example episode
index vectors um let's go for a color
instead and this worked so yeah this is
how basically our goal is to make this
as much Erlang as possible so you don't
have to know all the hardware stuff you
can still work with the board so let's
go back to the talk so first I will talk
about the hardware itself how it works
so the specifications this is the board
a bigger picture for so you can because
you can see this small one up here and
what we call this a embedded wireless
device so the goal is to to be able to
build embedded applications and use it
wirelessly so we have Wi-Fi on board the
way we achieve this is we're using our
line and we're having it's a real
airline VM and we're putting this bare
metal on this device so this is like
you'll never get this close to to bare
metal with our line in any other way I
mean you can get it in similar way but
this is as close as you get so I'll
explain the whole kind of software side
light later so this is the board itself
and we couple this together with
connectors for different sensors and
actuators so you can actually interface
with the real world and we want to build
lots of drivers for this so you can use
building applications that use all these
components so the specifications
themselves it's a 300 megahertz
processor 64 megabytes of RAM built-in
Wi-Fi and microSD for storage so I'll
explain them all a bit more in detail so
first up the CPU so it's in the middle
it's the big one there
it's a arm cortex-m seven core it's a
32-bit system on a ship and it uses the
utmost time v71 microcontroller it runs
up to 300 megahertz so if you can scale
it it has a flowing T floating-point
unit built in and digital sing
processing extensions that you also can
use so it's a nice processor comes with
lots of features and we plan to use as
many of them as we can the ROM sits on
the side for storage and also the
microSD slot so you can put something on
there from your computer so internally
the the CPU has 2 megabytes of flash and
through earnings 4 kilobytes of s ROM so
this is nowhere near enough to to run
our line so we put externally we put
this 64 megabyte SDRAM chip which is
plenty for our line so just looking at
this one I had now along the in boot
that takes about 6 megabytes something
like this so you have quite a lot of
memory especially for building embedded
applications so you can do some pretty
cool stuff on this one we have EP room
storage for configuration or other
things so this actually survives power
outages and reboots and so on so if you
want to store some configuration that's
for example if you want a provision
devices and then send them out the field
this would be a good place to do it and
of course the microSD slot for for
external storage so this is where we
kind of boot everything the bootloader
goes into the micro sd card reads in any
file and then boots whatever you tell it
to boot we have Wi-Fi on ship and this
is a normal b/g/n Wi-Fi 2.4 gigahertz
band it's connected via the internal USB
interface to the processor and that's
the normal kind of Wi-Fi speed for 2.4
gigahertz theoretically up 250 megabytes
you feel over but yeah it's a standard
Wi-Fi chip and it also has a power
saving mechanism so we could also use
this too if you want to hibernate the
board you can bring the Wi-Fi up and
down maybe only at certain points for
example so now we come to the kind of
connectors for more fancy stuff so this
was all pretty basic it's just a
computer right what we put on our board
that maybe this image is from bigger
boards bigger and cheaper boards like
raspberry pi and Beagle bone and so on
is like all of these connectors that we
have
go through them we have two generic GPIO
ports with six pins so they're up here
and what also is controlled by GPIO is
the the lead on board so you have two
RGB LEDs and we have five dip switches
which you can check the state off and
the reset button so all of this is GPIO
general purpose input output and it
basically it's a kind of generic pins
that you can control in runtime so you
can say okay I want this much power or
high-low than kind of ones and zeros on
them and what's neat is that these
supports pulse width modulation so we
plan to have drivers where we implement
the pulse width modulation for you in
the C side and then you can write erling
drivers so you can do stuff like LED
brightness so the lettuce I showed you
here for example the the red and blue
ones currently there's no way to to set
them to like a lower brightness or a
nice mix between two colors so you can
just now you can just like the RG and B
component so once we have pulse width
modulation you'll be able to like
smoothly transform between all colors in
the RGB space what also you can do with
pulse width modulation is you can
control motors more precisely so instead
of just blasting at full speed you can
go slowly or faster accelerate the
accelerate and so on so it's it's a nice
feature to have and it's used in many
other components as well what's more is
that we have a uart port so this is a
stands for universal a synchronous
receiver transmitter and it's a
synchronous serial communication
basically it's generic bit streams so
it's kind of ones and zeros and you can
configure the data format and the
transmission speed so here we're talking
about stuff like baud rate and so on and
normally when you talk to you are
devices it's actually it's a text-based
protocol most of the time so it's kind
of like you send a command like a string
with some codes or a word and some
parameters and then you listen and the
device and something back for examples
it's a very simple one but it's much
more high level than GPIO
because notes about controlling pins
ones and zeroes you actually have X
projects per example and to go even more
events we have to SBI ports so we have
116 port so all of the ones up here are
6 pin ports and there's also one SPI
port which is 12 pin and has extra pins
for interrupts so you can see it here
like that this one is slightly larger
than the other one so it has twice the
amount of pins so SPI is a serial
peripheral interface and it's
synchronous serial communication at the
bus and it is kind of simple like GPIO
but you have this serial aspect of it
and it has very broad support among chip
makers so lots of ships just know how to
talk SPI lots of other components know
that pretty standard protocol for
example you can have these nice
oscillators that can show you like this
VI you can debug the SPI on the wire
lots of stuff like this so there are
many nice components that know how to
talk SPI and we do as well it's quite
fast protocol so it's up to 20 megabytes
per second megabits per second and the
way it works is that you send and
receive at the same time and that's why
it's a synchronous protocol it's also a
master/slave protocol so it means you
have a controller which in our case will
be always the grist p-- and then you
connect lots of components and then you
use what's called a slave select line to
actually decide which component you talk
to so we have two lines for input/output
and you have one clock line that
determines the rate of which you're
communicating so if you up for example
two components on the same SPI wire you
use the slave select to decide which one
to talk to at the moment and then you
start blasting on the input/output lines
and you can then talk to this component
and the bigger SPI port we have have
extra interrupt lines so for example
some components they can listen for
events or for example the accelerometer
detect freefall and then send you an
interrupt which will end up on the grip
side and then we can do stuff with this
in our line for example generate an
event or send a message or something
like this
in addition we have I Square C connector
sits in the middle so it's a smaller one
and it points straight up eight pins and
I Square C is integrated into integrated
circuit that's so it's called I Square C
it's also a master/slave protocol it has
less wires than spi so it's only one day
sign clock line plus power and ground so
it's four pins instead of six what's
nice is that it has addressable clients
so you can send like packets of data to
specific clients in this in this bus so
you can chain lots of components you can
say to this one I want to send this data
and it's usually used for board local
stuff so stuff that sits around your
board because it's unreliable over
longer distances and it's slow compared
to SPI so it's only about 0.4 megabits
so it's much slower but it's also a
little bit nicer in some respects so
it's a nice choice tab and the last one
we have is one wire so it's a protocol
called Dallas one wire and it's
developed by Dallas semiconductors and
what is cool about this one is that it's
only one wire plus ground so it's two
but it's data and power goes on the same
wire so when you have devices connected
on this they can charge themselves on
the high so whenever there is one going
on the wire they also charge a capacitor
and then they use this to power
themselves over time so it's a really
neat one and it's similar to R square C
so you have addressable clients and so
on but it supports much longer distances
so we're talking a room or house scale
where you can draw like wires so if you
have this one sitting in a corner
somewhere you can pull like temperature
sensors around in your house and then
get all the data back and you only need
this this tiny one wire system so also
in this one it's kind of a microloan so
you have addressable clients so every
every device has a 64-bit address
and it's a unique ID plus some device
type so you can actually know which
devices you're talking to and it's it's
very popular for like buttons like key
fobs or weather sensors stuff like this
because it's low-power and kind of nice
distance so for example you can buy lots
of prepackaged like weather sensors but
then like it's books nice books you can
put it outside somewhere and then you
have a one wire cable and then you can
actually connect it directly to the
crisper for example or some other hub so
for interfacing with the programmer kind
of or for getting power we have the
micro USB connection and also a JTAG
debugger and on board the bugger so we
use the micro USB for power so from my
laptop in this case from battery packs
or something like this it also exposes a
serial console and a JTAG debugger
access over over the USB so you have two
USB consoles or two USB ports one for
the console and one for zero console and
one for the JTAG debugger and also we
have this external j-type connector
which is a standard arm two times ten
pins where you can connect the hardware
JTAG debugger and you can do cool stuff
like actually step the processor so you
can like freeze the whole system and you
don't have to change your software
because it's all all of those features
are in the process of themselves so you
connect the debugger and you can
actually step through your whole system
like step debugger for normal languages
which is pretty neat it's useful for
developing low-level hardware stuff so
next up I'll show some examples of what
you can connect to this device and I'm
going to focus on something called P
mobs so P mobs are standard by did
DeLand or and it's small components six
or twelve pin ports and they usually
talk one of like spi uart or GPIO which
means you can plug them into all of
these ports and use them so just give
some examples of some some control
that you can buy Vigilant has up to 90 I
think components and there are other
manufacturers following this standard as
well because it's simple so for example
lots of these ships that are onboard
like an accelerometer ship it's really
really tiny one so what did land does is
they take this they build it on one of
these P mod boards and then you can then
give you a nice interface and you can
use it so many companies to develop
their own ships they also sometimes
build p models because it's an easy way
to test it so there's lots of key models
already out there you can go to
electronic stores and find these nice
collections of various p modes like for
robot kits and weatherstaff's and some
swords and all kinds of things so I'm
just going to show a few examples this
one called country and it's a GPIO P
mode that is implements a four it has
four standard three wire servo motors
connectors so you can connect servo
motors to it this is called P mode knob
which is a nine axis inertial
measurement unit which means it has
accelerometer gyroscope and magnetometer
built in and it's actually 10 or 11 axis
because it has a barometer on top where
you can get stuff like temperature air
pressure and so on so this one is really
rakul it's quite a new one but it gives
you lots of data so you plug it in stick
it on a drone and then you already can
have like quite a little data to work
with simpler version of the same idea is
just ship so it has one of the parts so
this is a gyroscope for example so it's
a 3-axis gyroscope works over SPI and
this is a three axis accelerometer and
so this this new one is the cool one
because it has all in one kind of but
you can also buy them separately and I'm
going to demo this one later hp3 is a
h-bridge driver so you have feedback
inputs so you can drive a DC motor with
up to 12 volts so you plug in the motor
and some external power to this and you
can actually drive a motor a very
similar one is to HP v but it has a 16
jst connector
which is something that these digital
motor gearboxes uses so they have a you
can see it there they have a little ship
on the motor itself so it's a more like
advanced high level interface it's the
same kind of motor so it's a 12-volt DC
motor but you can get data from this one
it has a loosens or like how fast is
spinning where it's rotated at the
moment stuff like this so it's it's
nicer higher level and you can buy them
in kits like this so you get the motor
and the P mode together the last one is
a example of a UART P mode which is a
GPS receiver so this one has like 3
meter 2 D satellite position accuracy so
if you have something out in the wall
you could be reuse this to figure out
where you are so these are just some
examples of p models that you can buy
already and connect and the prices vary
between five up to thirty forty dollars
depending on how advanced it is or what
you want to do with it so I'm going to
do another demo so I'm going to use just
the board but I'm going to connect a
Piemonte to it so I brought with me the
P mode a CL - so it's the accelerometer
one and I'm just going to plug it in so
in this case I don't need to reboot
because I didn't talk to this need and
if you just plug it in like the knob the
pins are in some normal power space so
it doesn't mess with anything so
actually I don't have the reboot now
that I install this I can just leave it
here and I will show you how this looks
like
nice flickering and we are back to our
Lang shell so I told you that we had a
crisp run time so as you can see before
as I showed you before we started the
grist application and this started some
low level drivers like SPI to talk with
SPI components and other things so I'm
going to stop this one so now the run
time is stopped
basically the hardware doesn't really
care about the run time shut down
everything and I'm going to tell the
grip application that we have some
devices connected so the way this works
is that you could either configure in
your sis config or like this dynamically
or maybe we had some API for like
pulling and plugging devices later but
this is equivalent so we'd say that on
the port this VI port 1 which is this
one which is the extended one we now
have something connected and this is AP
mode a CL 2 so that tells the the Grzyb
runtime to when it boots it also starts
a driver instance for ok i misspelled so
let's do it again the reason I'm doing
it again and not just fixing the line is
because the terminal emulator we're
using is a bit stupid so it doesn't have
proper line editing so this is just
using the the serial interface over the
USB and you could use screen for example
to connect to it we're using a OS X app
called
serial this one because it has some
other nice features like line editing
mode and so on but it's up to you how to
connect to this one so we told grasp
about this and we're now going to start
grasp again the runtime and what we can
see here in a while after all the basic
stuff started is that also this P mode a
CL 2 driver has started so because this
one is started and it knows which port I
told which port
this p-mod sits on you can now use this
module and it's called this function
first there's some value is there so you
can see that I didn't specify like which
port I wanted to be on or I advise type
is specified by which driver I'm using
so the idea here is that by default you
probably normally only have one device
connected so it's nice not to have to
type that slot all the time so it's
actually automatically mapped in the
Grzyb application it knows where your
devices are connected and will redirect
the drivers to the right device of
course you can talk to a specific one if
you really want to if you have like two
of the same connected so this is another
problem so this is accelerometer data
this is the raw values that comes out of
the device and you can convert them to D
forces so if I used light superflat like
this you can see that the first
component is about really the third
component the said axis is about 1000
and the others are about 0 to 100 so if
we actually interpret this as G forces
which is another feature of the driver
you can see that the XY set values kind
of look okay because we're lying flat on
a surface so we're in 1g environment
here on this planet and this is kind of
normal so they might need some
calibration but in general this is fine
so if I flip it upside down and I do the
same thing you can see now that we're
minus 1g so you actually can see which
direction you are and if I shake it a
bit you see I get different values on
all the accesses by default it's in a 2g
mode so this this one has up to I think
eight GS and the P mode nav the cool one
has up to 16 G's force protection but
the accelerometers themselves they
actually handle much more because it's a
electromechanical sensor so they I think
in the specification it says that it can
handle up to 5,000 G but of breaking so
I'm not sure I'm going to be strong
enough to test it but I'm at least
strong enough to produce 2g which is
nice so I
small demo where I connect this one to
the leads so I will start this and just
going to check what I call the start
function to do to do run apparently so
it's running so let's start in this one
so when I hold it like this you can see
that the letters are red and if I turn
it like this they become green and if I
turn it like this they become red again
so that means I applied the red
component to the whatever one of the
accesses
my spatial awareness is not the best
today and the green component is to one
of the accesses and I don't know if you
can see it but it's blue now basically
and if you tilt it a little bit you get
the combination of the color so now you
get green and blue and yeah bit
different ones so this is a nice demo
where you show actually I built an
application right I built the program
that takes one of the sensors and does
something cool with it so later you
could send it to something like if you
have this with a battery pack stuck to
your I don't know your kids by cycle for
example and they fall over you can like
an alarm in your mobile phone or
something I don't know whatever so this
shows how we actually can connect
different parts of the hardware and do
something cool so back to the slide so
I'm going to talk a bit about the
software side of things so so far I only
talked about the hardware what you can
do with it what what can connect to it
so on the software side of things we
have stuff like toolchain the operating
system and put quotes around that
because i was playing it later and the
grist per on time which i already talked
a little bit about so to make all this
possible we're using something called
Artem's which stands for real-time
executive for multiprocessor systems and
it is a real-time operating system
but you can kind of see the concept as
operating system as in library because
it's not an operating system it's not
managing other processes and like taking
care of resources but it's something
that you link into a program so that's
why it's called real-time executive
because in the end you get just one
program so if you write a C program and
you link in our temps you get still your
C program with lots of libraries behind
it and then you can actually boot from
this program directly on the processor
and this is what we're doing with with
the Erlang VM it does support so
standards like POSIX or operating system
API and this is why for us it's perfect
because our line uses POSIX so we can
just combine our times and whenever
Erlang makes a Cisco lor a POSIX call
our times implements this for us it's
very performant so it's very scalable
like timer timeout support uses
fine-grained looking for implementing
threads and so on and processes do exist
so you can run actually other programs
on this but they are simulated as
threads so in the end what Artem's does
it starts and it takes up the whole
memory and it runs alone right which in
our case is being together with Artem's
and then if you run a external program
its simulated by spawning a thread and
then managing that memory for you so you
can get kind of neat high-level stuff
for stuff that looks like high-level
things in any case it has SMP support
which is nice because our Lang supports
SMT and they should go for a multi-core
processor we could use this so that's
very nice and it supports different
networking stack but among other it
supports the freebsd networking stack
which means you can compile our terms
together with the drivers from freebsd
so you can get things like Ethernet
Wi-Fi USB things like this and that
means that we get lots of drivers for
free and they're fairly advanced high
level drivers so you can you can do a
lot with them and it's a nice fit for
Erlang which is also a high level
language so what we do is we compile
beam together with our terms
with the headers and libraries that is
Artem's and that means we can start the
virtual machine directly from the
bootloader so in the bootloader versus
malcolm or in the SD card raised a small
config file that point that specifies an
executable and there we say beam dot bin
so the way we do this is when you
compile beam we cross compile it to the
artemis architecture to the ARM
architecture and we so then you get an
elf executable and then we take that elf
executable and we do we use the object
copy tool object copy tool which
actually converts it to machine code and
then we stick this on the SD card so
basically what's read from the SD card
is directly is the the main memory code
for the beam and it just piped into
memory and booted and we're good to go
and all the API is that we need to do
things is provided by Artem's
so whenever you make a call a system API
in our line or under the hood in there
along the Artem's takes over implements
the thing and then returns a value so
the beam doesn't really know that it's
running as the kernel but it is
effectively the kernel in this system so
to kind of sum it up you have hardware
and you compile the beam and Artem's
together into one big thing and the beam
does stuff like run LTP and have the
grist run time running in our case and
it runs your application right and then
our tents is like a small middle layer
underneath in the same executable that
implements all the OS layer stuff so the
grist run time it's just an early
notification it's a couple of LinkedIn
drivers as well to talk with the
hardware so for example when we need to
talk GPIO so one of the the GPIO port or
for example check the switches or modify
the leads we use a driver for this and
we have a driver to talk to SPI so we
have a sea level layer provided by our
thames and by the
implementers of the hardware board which
interfaces with SPI protocol and we then
have bindings for this two-hour long so
you can send and receive SPI commands
and this is for example how the
accelerometer driver is implemented and
then we have high level drivers for for
using the LEDs which I showed you for
reading the dip switches and for
interfacing with P modes so we're trying
to write more and more P mode drivers so
the hope is that for at least the most
common useful p modes we already have
ready-made orling drivers that you can
build erling application with I'll show
you a example of how this pair driver
kind of works from C to R link so you
get a feeling for kind of what's
involved here so the SPI driver in this
case this is an airline port driver and
when we get a message from Erlang or a
call command from the Erlang side
I'll show with our line code later we
get this gift this binary buffer in here
this is normally how you interface with
the port reverse in Erlang you can
decode it as Erlang terms but we went
the other way and said okay let's just
do all that bad stuff from the Erlang
side because it's much more comfortable
and then on the sea side we just deal
with binaries so this interface is
pretty simple it's a buffer of
characters and the first character in
this buffer is the ship select so this
is a number specifying which of the two
SPI ports we should enable in this
driver and then the rest of the buffer
is just the message we want to send to
the device so later in the code we
create a message struct and we use this
ioctl function with the file descriptor
for the spi port and the message we want
to send and then from that point on like
it's the low-level routines to take over
this very implementation and whatever
support for anything like in the cpu and
so depending on what protocol to use and
then we just check the reply and we
output oops sorry for that we send the
reply back to the Erlang side
so in darling side it's pretty simple
it's a driver's at the porch driver we
spawn it we want to talk with binaries
back and forth because it's nice in our
line you can do stuff like send
hexadecimal very easily and so on here
on the ER line side we do the mapping so
we map from the Adam GPIO one for
example to the actual which should be
SPI to the actual index of the ship
select that the CPU wants or knows about
that and then we send off this command
to to the port and that's it so an
example of how we use this is I think
this is for the accelerometer that I
just showed you
so a command NFC is a couple of bytes is
usually bite so in this case we send two
bytes the first byte for the
accelerometer this is all in the
documentation for this accelerator ship
and you can read lots about which
commands so which registers to read and
write so this means read from a register
and I want to read from from this
register and I think in this case it's
the Who am I register which is like the
device ID of the P mode and we practice
with an extra byte so the way FBI works
is that it's synchronous so it's a it's
two it's one output and one input line
so from the master it's one output and
then from the slave it's one output back
and what happens is they all go in
lockstep with this clock line on the
side that dictates the speed and every
time you send one byte to the slave the
slave sends one byte back to the master
so this is what means it's synchronous
kind of so we're sending two bytes this
the the command and the register we want
to read and we'll get actually for each
of those we'll get one bite back but we
also want the value of the register so
if the value of the register would come
in the second byte the p-mod wouldn't
know which register we wanted to read
because that's the byte that's currently
in transit right so we have to wait for
a
or exchange where actually the value
comes and that's why we pad with zero
because we have nothing more to say to
the P mode and we're just waiting for
one more bite from the other side and if
I send this I send it as a message to
the port and then I just flush to see
what I go back and you can see that we
got some data back so in the end we sent
three bytes and we got three bytes back
and I was nice enough to send nothing in
the third one because I'm not really
caring about this and the P mode was
nice enough to send nothing in the first
two where my command bytes were shipped
over because they wouldn't know what to
send there right and then at the last by
I get the value back from this register
I was asking for so this is all very
very low level but we also implement of
course our long APRs to do this a bit
more efficiently so this is an example
of the same call where instead we're
saying okay I want to talk on a spare
one I want to send this command please
strip away the first two bytes and give
me the one byte back and this will
handle all the padding and cutting up
stuff so you don't have to think about
this so this is what we use when we
implement the T mode drivers for example
so I'm going to do one last demo and
it's going to be a robot and I have no
idea how it will go so let's see if we
can make this work so I have another
baseboard down here and it has a battery
pack and it's built on top of screwed on
top of a robot and I have a small
program waiting on there so when I flip
a switch it will try to do some things
and we'll see how it goes so I will do
it this way see so you can either come
up on the side if you want I will also
try to film it and show it on the screen
so for the people who are back or for
the video so if you're in front of the
camera please try to sit down in any
case just so you don't block the view
so let's do like this so I'm going to be
very antisocial and I'm going to call
myself yay
this is Meza so Bruce if you would be
nice enough to basically just film the
robot so in case people don't see it or
for the future for internet so maybe if
you stand over here so it's a small
program that pauses for a little while
and then it moves a little bit and then
it's supposed to drive in a circle and
the problem with getting this working is
first it's all hard-coded like how much
it should turn and drive so I'm not sure
exactly how well it will work and also
getting enough power to the motors with
the battery pack was a bit programmatic
so see how much energy it has to do
something maybe it's Lacey so this blue
blinking light here means that we are in
a state where the program has booted the
Grzyb runtime is running and we're just
waiting for this switch to flip which I
programmed and once I do this it
switches to green so now it's knows it
should do something and then hopefully
should start doing it let's see I have
some sleeps in between so
so it looks around a bit and I'm just
going to reposition it to go standard
drives ahead yeah
and that's it so this is the grist board
here this is a big USB battery pack
underneath there is a battery pack for
the motors and if I flip it around you
can see the motors themselves and the 2p
mods that drive the motors so the P mods
are connected with extension cables the
grey ones that disappear under here to
the wrist board and then there comes
external power to the motor from the
battery packs and this is it actually so
I have a hope that we would be able to
have the Wi-Fi fully working to actually
drive it remotely but we didn't have
time for this so now it's just kind of
hard coded demo so let's see thank you
so the last part is basically what what
are we working on right now so I'm going
to talk about some issues and the future
roadmap basically so in terms of issues
we're working on getting full Wi-Fi
support so we have Wi-Fi running but we
have very high packet loss because of
some driver issues and some USB issues
so we've been working a lot on this and
it's getting better but we weren't sure
how if it would be stable enough for a
demo so we skipped showing it off in
this case but for example if you boot
the board with Y for the beam with the
Wi-Fi enabled you will connect to like
the first open Wi-Fi that exists and get
an iPhone number and then you can
actually ping the Grizz so once this all
kind of works you'll be able to connect
this tubular line to it or even access
the serial console over Wi-Fi things
like this so this will be really cool as
I mentioned before we're also working on
getting the microSD speeds up because
we're not using DMA yet and
to do it so it's on our to-do list and
we have one more problem where the clock
speed is a bit off so I didn't really
expose the problem here but if you do a
timer asleep for example it takes about
twice real time so we did lots of timer
testing on with low-level stuff with C
programs and everything is just fine
but somehow the way airline uses the
operating system timer and clock
functions
create some problem that we haven't
really figured out yet so currently our
long thinks times these times are going
like twice as slow and another funny
thing is if you booted it the time is
set to like zero or something so it's
always 1988 so this is a really retro
board with from the 80s which is super
slow at the moment but it's all stuff
we're working on another thing we're
doing is we're part of the EU project
called light-cone which is about
Internet of Things stuff computing at
the edge so in huge networks like
internet and so on and they use things
like synchronization free programming
hybrid gossip protocols so we want to be
we're part of this and we want to use
the grist to like as an edge node
basically and because we have our
language is fairly high-level language
we can still do cool things like use all
these CR DT data types and so on on the
grist itself so this would be really
cool and the future roadmap for the
grist project itself is to get up to
speed with the latest Erlang and will
probably just go straight for 20 because
it's released soon this means in
practice porting all our patches over
that we have for this current version
and just modernize the whole thing
basically we want to build and improve
the rebar tooling we have so the idea is
that like you know with rebar 3 you can
do rebar 3 new apps something like this
and we want to basically make the
equivalent of new grist app which will
set up all your dependencies give you
some nice rebar targets for compiling
and deploying onto the SD card and for
real advanced things we want to do stuff
like you can compile your own beam
instance and copy in your own drivers if
you want to write really low-level stuff
on this one as well and we want to work
more on more
pema drivers and Wi-Fi and setting all
that up so you can use this to beauty
darling so this is it thank you very
much so
ah yes sorry I didn't have a slide for
this so I will just explain it with
words we have a raffle going on I can
actually show you the webpage so it
means a patil Sunday I think yeah so if
you sign up for the newsletter the
Grisby newsletter until Sunday you will
be part 4 in a raffle for three grease
boards when they finally are released so
I will just show you the webpage so you
know where to go so it's grist.org this
is the homepage of the grasp project and
in the bottom you have the subscribe to
great newsletters so if you do this
before Sunday your will be taking part
in a raffle of three boards for this
conference so any questions yeah
sorry max own risk so when writing
drivers in a normal always Colonel
movement rely on interrupts and the DMA
yes is there a way you can expose that
functionality to our long code then yes
so we plan to do this because I mean
even like the components like the
accelerometers and things they have
interrupts or we have to get back to
Erlang somehow right now we're doing
everything with poor drivers so you
could do it there but since we got a bit
inspired by the OTP talk yesterday we
thought we could use this new miss
functionality and actually do interrupts
on the seaside and then send darling
messages back so this is all kind of in
the pipeline to get this working okay
and more questions
how much patching this air long actually
need not so much so mostly we patched
make files and this is to first get the
cross compilation going and then get our
own drivers into so what we did at the
moment is we have we put our own drivers
into the emulators driver folder and we
happen to make file mes compile
everything in one go so that's kind of
the majority of patches there are some
other generic things that I can figure
out the top of my head but like really
tiny stuff like one line here and there
that we probably will push back to OTP
because it's just common sense stuff
that just haven't been tested in the way
we did it so I would say in average like
very little patching required more
questions
yeah when will a chip pair so I asked
the question when will the chip and I'm
answering it myself so the plan is to
have by end of pipe at the middle of
June after Hardware final you verify
when we basically cut cut all the Wi-Fi
stuff in in order and we have six weeks
production runs on the first port so
ship and July so will be again a little
bit delayed yeah it's on the website and
let's see what actually where's the P
order button there yes I block all the
scripts all the time so that's right so
this is the this is the single board and
yeah with SD card we have a normal one
without and then you can actually get a
ten pack as well as if you want for your
company or for education we want to give
away a bit boards or discount them for
education but if you need a bigger one
to try out big experience we also have a
ten card
yes any other questions I have one
question and that's what does crisp
stand for there it's a really cool name
yeah it actually stood for a programming
language I developed in a lot like 15
years ago and then I learned about
yelling and kill it off so I had the
name left over in the logo and yeah any
more questions or should we wrap this up
three two one okay thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>