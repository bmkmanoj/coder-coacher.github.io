<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tech Mesh 2012 - Social Architecture 101 - Pieter Hintjens | Coder Coacher - Coaching Coders</title><meta content="Tech Mesh 2012 - Social Architecture 101 - Pieter Hintjens - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tech Mesh 2012 - Social Architecture 101 - Pieter Hintjens</b></h2><h5 class="post__date">2013-08-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uj-li0LO_2g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">powerful and not so far away here's why
so who here does open source of any kind
does anyone not do open source here okay
and who started a project open source
project at least one at least two
projects at least ten projects okay so
what I'm going to talk about is going
very slowly because there are still
people arriving is this thing called
social architecture which is something
one of my hobbies how to build online
communities and i'll try to explain why
and how with some examples why it's
relevant why it's useful and how we do
it so it's like architecture it's the
the process and a product of building
things but social online communities you
can look at many examples that exist
that are not to do a software and things
like Wikipedia or just any other
community reddit or 4chan whatever but
in our business and the goal of this is
how to how to do that on purpose for our
for our profit I will argue that if you
don't do this deliberately in the next
year's you will basically be unable to
compete I think open source is like
every other business has to compete for
developers for talent for you know for
for footprint football and if you don't
do this deliberately then you will end
up with you know great ideas and no one
actually joining you so I think the
world is changing and I think we're
leaving the time when you could become
successful by being very clever in a
garage I think that nowadays you have to
be clever it working with other people
so some extent this is about all my
experience in the last 30 years good and
bad about how to build communities and
what works what doesn't work and why I
try to put this into a kind of
also to experiment over and over on
innocence to see if it's really
reproducible or not so kind of the basic
tenant is who we are isn't that
important it's difficult people with the
egos to accept but our our share
personal intellect is not that of a big
deal doesn't really matter it's how we
organize it really matters and you can
see this in many domains the same team
organized differently will have very
different results it can be in sports
we're a fairly ordinary team rearranged
in the right way can do brilliantly and
better than a very very good team lots
of experts sometimes the experts will
actually be unable to work together at
all so it's not really about the
individual quality it's about the
organization and that way people will
work together Master focus of this is
how to help people organize in the best
possible way not just good enough but
really as good as possible and then
better and better I'll say it's
combination of psychology economics
politics and technology it used to be
about technology you know where's my
mailing list do I use usenet do I use a
wiki do I use what's my technological
basis and it got more economical
hardwire motivate people how do we make
money from this but today it's all about
psychology for me fifty percent more
than that if you don't get it it'll get
you psychologists but other people it's
about our limitations as in as
individuals it's about our laziness we
don't like to have difficult things we
can handle complexity and we're afraid
of taking risks and we're proud so we'll
work very hard to not look foolish and
will be competitive and jealous and all
these things make us interesting and all
these aspects of the human brain are
what matter when you bring people
together and I've seen many brilliant
people completely baffled by psychology
and it just makes them useless in the
end they can do amazing things been by
themselves and it doesn't scale
so I think the understanding psychology
is not necessarily easy for for
engineers but it's it's essential to
some extent now when we start a project
we do I think aim for success we don't
just sit there randomly making projects
we want some kind of success I'll use
this successes number of contributors
the size of the community no one is
proud having a very small community we
want people to join our project to use
our software and to some extent I've
seen big communities killed by a
conflict the wrong kind of conflict
competition is fine but senseless
arguments over you know details isn't
fine so my formula you know number of
contributors divided by number of
conflicts is your success it's not maths
it's just twit I don't take this too
seriously general process then is
attract the best people and then make it
really easy for them to work together so
if you're building a community you have
to be focusing on those two things how
do you attract good people to your
problem to your project and how do you
make it easy for them to work together
how do you remove any potential barrier
those two things have to work together
there's no point attracting good people
and then pissing them off this happens
all the time it is useless and there's
no point having a great you know a way
to work together but a problem no one
cares about so I look at these
attracting good people removing friction
and I spent the last six months more or
less working in career which is very
stupid in missing this day and age why
in some teams you have to travel across
the world to work together and other
teams can work together with never
seeing each other yeah I have people
sending me pull requests on the mailing
list I never seen these people network
is perfect I don't know who they are I
don't know what they do I don't pay them
I don't sign contracts and we build
production quality software together at
the same time I can't even discuss
anything with my customers that being in
the same room as them and having beer
and
so do whatever so there's there's some
really weird stuff going on about how we
collaborate how we create the
collaboration and what it seems to be
based on is the quality of the contracts
and the rules that we use when the
contracts and rules are very clear
totally unambiguous and don't require
any assumptions or any shared context we
can work together really easily so
clearly assumptions and knowledge are a
big barrier to collaboration remove
assumptions remove requirements for
upfront knowledge people can collaborate
together much more easily so a big big
part of my job in building communities
is to document and define better rules
like the number one job is there's a
problem figure out what the cause is
figure out what rule will fix that
problem write it down and then
eventually enforce it people insist on
breaking a rule kick em out it's very
simple the rules are not really optional
the game has rules you play the game I
think this is what I've observed is that
many potentially fantastic projects die
because the founders are idiots and I
speak for my own experience i'm an idiot
many times our egos make it very very
hard for us to let go in the right way
and one of the things is in the
community everyone should be equal there
should be no one with special privileges
only because they were there longer I
mean a moderator fine but no one really
owns it people start owning it others
won't join in and letting go of your
work as a software engineer as a creator
is very hard if you can't do that people
won't join in so
when you have all these contributors
brilliant people and they're able to
work together then how do they scale and
the way is they have to be able to make
stuff and have space with that to happen
if you have just one project one box
then you can have maybe three three or
four people in that one box and it gets
full set of lots of boxes you look at
successful projects they have lots of
scalability in terms of space that you
can work in and call your own wikipedia
has thousands of pages and you can
create a new patients your page you can
own it so think in terms of the
architecture of your software affecting
the architecture of your community the
two go together and then this okay let
me just take a poll here who prefers BSD
MIT style license for that work and who
prefers GPL can you can you tell me why
GTO political intentions we Gareth why
would you prefer GPO the other ones are
crossed many questions GPL services this
slicer Dicer that just comes through
everything and inevitably it's just
going to just easier it's very intuitive
answer but doesn't really answer the
question right so why who was it the SD
MIT here why
right okay let me ask you a question
rhetorical question I'm you make you
make a BSD or MIT license project and is
fantastic and I take it and I I for kit
and I make a GPL version of that and I
add on some stuff when I get some
contributors and I get a GPL fork is
that good or bad do you like it does it
make you happy angry do you know care at
all is it success is it failure right
right okay so one of my hobbies is to
troll bsd projects by four kingdoms GPL
just for fun just to annoy them and of
course they shouldn't care because it's
if I make a GPL if I include bsd code
and a GPL project it's just the same are
it's actually nicer than factory in
commercial project but somehow the two
seem to be treated differently my
conclusion we've tried many licenses in
our communities many many licenses
within our own licenses for open source
and all kinds and it's this I don't want
my competitors to take my code use it
against me that's that's a very big cost
a very big risk if I right I spend a
week writing code and I find some guy
using it in a closed source project
against me I have a real problem the
opportunity cost could be massive there
so the GPL for me as a way of
guaranteeing remix ability in all both
directions is really really important
the politics of forcing the sharing on
people whether they like it or not seems
to scale better so when a community and
building large architectures the
mandatory reshoring seems to scale
better you get more contributors and so
I would predict without any worry over
time that every time and there's a bsd
project in a GPL projecting the same the
tibia will win systematically will beat
more contributors will be more active
it'll have more adoption I'll commercial
adoption to just not reused in
commercial products as such
that's why I for GPL it seems to be a
winning strategy attracting people
keeping their attention there was a
who's on Twitter complaining that with
some patches some issues in the patchy
they've been there for two years and
there's a great pattern hasn't been
applied for two years like this is that
is shocking in our communities if we
don't have a patch applied within 24
hours that's a big issue that's a big
problem and we try to get it down to a
few minutes we have people fighting to
be the first to press the merge button
they've got quite weird discussions
about what's the trade-off between code
review and latency of your change how
much that code review worked if you lose
a contributor the answer is not worth
very much a code review is not worth
losing somebody and if the attention
span is down to a few hours then it's
better to accept a bad patch than to
review it in delay and not have a first
in your community and everyone starts
off by making mistakes and the process
should accept the mistakes in the
beginning people's be able to make
mistakes make patches that are rubbish
and if they're really offensively bad
and they don't learn then you click on
that just unpatch will revert the patch
it's very simple so this notion that
work can be accepted and put into the
mainstream very very fast is I think
important and we've had this argument
I'll take Wikipedia again as a classic
example is it worth having errors on
pages the answer is yes because you get
more contributors and more contributors
means eventually more accuracy having a
few experts who make everything perfect
won't give you success it will give you
actually death failure no one knows
about the competitors to Wikipedia
another thing about the good communities
it's trivial to join and it never ends
people do we do like to play we'd like
to learn and it should be really easy to
get into it and should never get bored
never get boring never get finished so
the problem should be infinite and yet
start very simply this is not easy these
are these are patterns which can take
quite a lot of thought to get right
there are some theories of collective
intelligence which are quite strong in
social architecture and they are things
like diversity is very very important
the small group of experts simply can't
think straight they get it wrong two
guys in the garage will actually go
slightly crazy and make stuff that no
one really cares about and isn't that
brilliant at all whereas one guy in a
garage and one complete idiot somewhere
else will together make a great product
comparatively so diversity of thought
diversity of background and education
and language and age and character and
education is a very very valuable and
you look at your community think about
how diverse it is and how you know how
much diversity is is influencing the
thought process decentralization the
same thing people in the same room tend
to adopt the same thought patterns and
they go collectively crazy I mean we've
seen this in the last election in the
states how half population can literally
misunderstand reality this happens in
software of course much more because
it's so much more abstract the
self-organizing part is great if you if
you can actually identify and bring up
all the problems as first-class citizens
your issue tracker should be number one
thing people look at people will
organize around the problems and no one
has to be told what to do it's a lovely
way to work I mean in open-source it
becomes obvious we still in commercial
software don't really think of it like
that so we're doing that in our in our
company I like people to organize around
problems very freely and sense of humor
I mean the thing about jokes and
laughing is that
diffusers conflict and conflict is toxic
people can laugh together they want
really take any conflict too seriously
the open and transparent is difficult in
theory it's open source people still go
off in a corner and start discussing
stuff and doing stuff by themselves and
two guys in the corner will eventually
make weird stuff I keep I'll repeat is
because it happens over and over again
and they'll assume some kind of
privilege and those are doing stuff and
shove this massive pull request with
lots of code names like what where does
this come from even in our zeromq
community we had to fight to get this
theory that anyone could contribute that
wasn't wasn't a given there was his
understanding that some guys had special
status and they could actually reject
contributors which I found offensive the
tribal aspect you know do you belong to
community you don't want to have that
makes people emotional makes them makes
them easily upset so a recipe for
building a community I take all these
patterns and go through step by step the
first thing is the mission it has to be
focused has to be a clear reason people
to get together and make something so if
you're starting a project think very
clearly about the gold emission try and
put it on paper try to write it then it
should be short should be slightly crazy
slightly dramatic slightly impossible it
if it's just been all nobody will care
about it nobody will get up in the
morning and say I have to do this people
do want drama so give them something
dramatic may give them something that's
crazy and impossible if they succeed is
you know worth doing um I'm not sure
about the bad guy thing but I do this in
some of my projects and it's quite fun
while we don't like too much emotion
it's also a good way to get a group to
bind together to define a bad guy and
sometimes that can be incredibly
powerful to motivate people to focus and
to see really what they're doing be
competitive so for example with zeromq
we kicked mqp for years just as a
if a token token bad guy it's not really
competition but it's good to get people
to look at this and in open source you
have Forks you have other projects but I
think it's useful to try to identify
competitors even in a in a nice way and
say this is what we're aiming at or
better than that we're going to end here
the platform today is almost a
no-brainer it's github anyone not using
github is on the wrong side of history I
think I think it's we have we've thrown
github at lots and lots of people from
all backgrounds non technical technical
in all kinds of environments and they
learn it very very quickly there's some
there's some simplifications that we use
in our projects like we don't use
branches you'll find shocking but that's
what we do get up of course it's cheap
it's free it's there it's you know isn't
it's not a difficult thing to use a seat
product so the thing about open source
is it what doesn't just happen by itself
you can't just say here's a great idea
people start working for me for free it
won't actually happened you have to
spend some time building a first version
that can actually deliver some useful
value and it may take three months six
months shouldn't take more than that if
it takes a year you're probably doing
too much and you build this seed version
in the open you build it public for you
everything's happening live people can
download it they can see it developing
they can start to get involved in and
invested in it if it's a stuff that you
make in the background you bring in and
you open source it it's not going to
work people will not buy into a product
that's open sourced past tense they want
to be see the process happening and
start buying into it as it grows so you
start with the mission start throwing
code there start showing stuff happening
start producing test results start using
statistics start seeing how much amazing
this stuff is and people will start
trying to use it and as they try to use
it they'll say Oh doesn't work it's
broken here and there which is perfect
it shouldn't work if it works they won't
participate they will just use it
passively
as consumers so it should be that good
enough that you'll actually download it
but not that good that actually works
and does the job it's a very very
delicate balance to get right the
problem is bringing contributors the
issues the patches the portability
doesn't put to this that I find a crash
I can fix the crash and that is when
your process starts kicking in very easy
pull requests very very easy to get
involved and they start getting involved
and I think we're getting this process
down to about two months to get three or
four people in working around a
particular idea and the rules we're now
getting to the point where we have
reusable rules for software projects
this thing called C for collective
collaborative code construction contract
I don't know some some random some
random acronym basically it's a it's a
bunch of it's a protocol for
collaboration which came out at the
zeromq community and seems to work
pretty well it's quite important not to
do too much this is very hard for
engineers to to feel we like to make
stuff when you're building community the
more you make the less people will join
in making stuff puts people those people
off what you can do is make a minimal
solution the more you make the less you
can move around it's the inertia I have
this nice and I call this minimal
plausible answers whenever there's a
problem try to make a minimal answer
that can solve it no more even if you
know it won't work in six months time
doesn't matter just make the minimal
answer move on hopefully someone will
use that and somebody else will make the
real version that's what you really want
you don't want to be solving problems
completely you want to be solving them
just enough to prove the problem is
worth solving and get someone else to
come in and take over for you don't make
legal entities I've learned this just
don't do it there's no reason to do it
and this is money involved and money is
poisons for communities anyway so just
don't make legal entities
a few years ago we were for some reason
we were involved in standards standards
setting with Microsoft and we were not
with them we were against them and we
ended up making an organization called
digi Stan digital standards organization
which was to promote the use of little
standards and we use this quite a lot in
serum Q community and the same time
there was another group of people that
were making something called the the web
something standardization something some
some new very similar organization and
they spent something like a year and a
half just building legal entity
literally 18 months just choosing a
board and getting the statutes and by
the time they'd finish the Microsoft had
taken over the whole committee and made
it to look like you know something they
wanted to legal entities suck just don't
go there they don't need them for
anything anymore these days any kind of
upfront contract that has to be signed
like copyright assignment is a problem
we we tried this all these things we've
tried this is all based on stuff that
we've tried often more than one time and
that we've found is really painful if
people have to sign or agree to anything
even a even I agree button before they
can make a patch they won't make the
pattern I mean for the most cases
minority that do will do majority want
and you lose those contributors and in
zeromq we began with we thought was the
right model with the copyright
assignment you would fax us a piece of
paper saying you assign as the copyright
and I think in one year we had one fax
that came in not successful and we
eventually switched to a model a GPL
based model of everyone owning
everything so every every patch is owned
by the by the owner by the contributor
the author and the resulting product is
owned by everybody that's contributed
that's it period there's simply no
assignment required we just merged GPL
code into GPL code and it works
it's insanely simple but it took us a
long time to get there and simple things
often do because what happens if you
want to change your license you can't
and that's also good the thing is if I
contribute to a project I don't want
someone changing the license I agree to
contribute on a certain basis and it's
actually it is actually unfair as a
company to ask for the right to modify
the license in someone else's work we
can do it and people will accept it but
it won't scale as much as if we don't do
that if we make a promise the license is
there forever it's GPL version 3 or
later and that promise is kept will get
more contributors and again the really
the only measure of success here is
number of contributors is really nothing
else depends I have no other criteria
except mass scale I don't care how good
the code is if I don't have contributors
I don't really care how much money we
make if you don't have contributors all
that will last is the number of people
working on that so anything that reduces
the number of contributors has to be
looked at very carefully I know GPL will
put off some people but it will probably
bring in more people that's our
calculation yes yes yes yes yes yes yes
scales better there are other things in
GPL three that I like very much at the
time we were involved in software patent
disputes and we helped sflc and Evan
welcome seem to put in lots of nice
language which makes it hard to sue
anyone if you're using there's GPL 3
software on those patterns there's one
reason why companies like Apple are
working very hard to remove all GPL free
software from their tool chains they
hate GPL 3 they would appeal to is fine
with you feel free they hate it because
the patent language the patents are very
bad for the software industry so by
using GPL 3 you're actually actively
fighting software patents yay this is
actually very important
would take infrastructure by that I mean
building your own anything building your
own anything don't build any
infrastructure you're building software
building community don't build
infrastructure like you know custom
websites or custom anything it's sooo
it's a waste of time in communities
which are focusing on a they should be
focusing on be I think wikipedia has
spent money on infrastructure but it's
minimal they have a version wikipedia
has not changed much in the last 10
years basically that's what you want a
kind of level minimum level power
structures by power structures I mean
any kind of committee any kind of
organized group even Evie I go even as
far as say even the admins and in the
end become a problem because just having
the admin right becomes itself important
people then fight for that and fighting
for that right takes priority over the
actual work that are trying to do
together so be very aware of power
structures as a problem and whenever you
see them emerging attack them on the
mind and remove them you don't want
power structures in the community and
ego and money are really really
problematic so the working with
volunteers having no single person
responsible for anything these are
tricks to reduce the level the impact of
ego and money on on the community
imagine if someone is being paid to
write Wikipedia articles now how about
if someone is paid to write software is
there really a difference I don't think
so i think that the accuracy of your
work really depends on who's giving you
money whether it's your own notion of
where you want to go or someone telling
you where you want to go I think
volunteer self-driven self-organizing
software development is much more
accurate than money work for hire
exactly the same as a Wikipedia article
the guy writing it may think he's saying
the truth but he's probably not so with
zeromq
see if I got my logo here right under my
logo the yeah the slogan was a good one
just very simple very stupid very
meaningless but it got people interested
in the beginning this was the going to
be the fastest messaging ever it turned
out not to be true but that's not the
point the point is setting the goal we
wanted to make this the fastest free
messaging ever and we did that the logo
which I have not managed to get my my
this weird this is called reveal Jay has
anyone used that you know when you go
online the whole thing changes let my
wife is on everything changes all the
fonts change I'm like what huda so
anyway I'm just a bitch in there so I
can show you the logo but the zeromq
logo is done by a really good artist and
it's like totally brutal bright red just
huge shapes and it's supposed to be
brutal is supposed to hit your neocortex
and make you feel what this stuff is
impressive I don't know what it does but
it looks it looks brutal I like them you
don't want a soft gentle logo you want
something that hits people and makes
them feel well dramatic and drama I
think we started with GPL and we switch
to lgpl because she feels just a little
bit too aggressive nobody would use it
lgpl is a good compromise to library all
patches we get but we don't touch
applications and it works very well the
layering in zeromq is nice we have the
core library we have language bindings
have applications on top of that
basically you can find your level of
competence you can start writing some
stuff on top start writing a language
binding there are 40 50 language
bindings now and then you can get it in
core library over time core library is
more complex and it should be but it's
it's not that difficult to get into even
I can do some work in that no copyright
assignment no roadmaps no feature
request this is the thing I love so much
as you r mq there's literally no roadmap
people ask where is a roadmap and I said
there's no road map and the reason is
that when you have a self-directing
community you can't tell them where to
go you don't want to tell them
to go you don't want a roadmap for a
group of people who are working on your
vision for free you just let them go let
them organized around the problems and
they will discover the right problems
and they will fix them the right way not
one hundred percent but much better than
if you're doing it yourself roadmaps
interfere with that process they subvert
it they and they don't help with the
real problems the real problems are not
where are we in six months time the real
problem is will it still work with what
I have today the real problem is
compatibility interoperability stability
it's not will I have feature X actually
no one cares about feature X if they
really do to make themselves what they
care about is it still works with what I
have today they won't say that but
that's the truth and we had roadmaps in
serum queue and we removed them and when
we remove them things work much better
so don't make promises don't make
promises what you will make what you
will do what you'll deliver the you will
disappoint people they will not trust
you a second time and you will stop
other people from making stuff they
could be making oh it's not on the
roadmap I won't do it so sorry I
remember I was CEO of a company called
wikidot for a few years there's a polish
company and these guys were amazingly
good at making promises that's what they
would do is just spin these great blogs
with all kinds of promises and stuff
they would make and they never delivered
and had this huge community people who
were just disappointed all the time and
at some point there was like a
revolution because they had been
promising all these features which they
couldn't deliver because their code base
was crap and then they made unicorns and
rainbows literally a feature in wiki
symmetrical unicorns and it was like
revolution in the community of like this
is it we're not we're going to come down
and kill you guys and I went to Poland
to fix this spent a year there just
fixing their process and we stopped
making promises we just started making
deliveries it's little gradual
deliveries one by one and it got things
back on the rails feature requests is
the same we don't have features we don't
have feature requests we only have
issues it's either it's a problem you
can identify and you can fix or
not there at all you can take this
further you can say that every single
change must be based on a problem and
software you can do that and it works
quite well and there's a process again
now you can search for this c4 somewhere
which which works like that is the one
that we use in our open source nowadays
so there's a background to software
source social architecture in this book
I'm writing there is a kind of work
example in the zeromq grade which will
be out in or Riley in two months time
yeah lots of material there so question
time
young man at the back yeah you mentioned
that zeromq didn't turn out to be the
fastest messaging right away layer so
which is well so the thing was before I
answer that I'll just point out why it
didn't turn out be the fastest because
in the end no one really cared people
really wanted more than speed with
simplicity and scalability which is a
little bit different you can make faster
messaging by using proprietary hardware
propriety networks InfiniBand for
example nobody ever made an affinity
band driver 40 mq not once it's very
strange isn't it the reason is that
people who need that kind of speed they
don't want open source anyway they want
to use expensive stuff because they like
spending money and they have site
another they're all they're all
marginally criminal anyway so they will
be hi mum so there somewhere doing stuff
open source hits people just below that
who want flexibility and simplicity more
than speed and the mass of developers
who for them speed is you know 1,000
missions is a second but not 10 million
the 10 million is the extreme thing so
commercial software like twenty nine
west like typical like IBM low latency
are faster and they cost X towson per
cpu / per year you know x is 50,000 or
whatever it is very very expensive
party contribute hard to open up and
look at the code these projects I would
imagine that transparency of technology
stack that enables the people to use
that simplicity and number of drivers it
sort of gets a lot of items but the fact
is that it's transparent and that's
gotta be huge it is is this a question
I'm not sure all right nice what was it
what was the question Gary could you
please rephrase the question the
follow-up okay yes when you correcting
people who are outside these doors
typically traditional managerial Styles
the workflows right do they talk to they
take notice of of what's going on in
this type of dynamic can ask you Peter
help us understand how to do more of
this work or is there sort of a soul a
big wall between these two parts
humankind so I've spent the last year
and a half working in a company where we
actually did it all like this and we
were lucky we were lucky to find
managers internally who were younger who
understand open-source more intuitively
I would say and who had nothing to lose
and we're willing to bet on this way of
working and we actually uses in
commercial software development very
successfully so for example the notion
that a bunch of engineers will self
organized around problems we use that
and it worked and we've trained teams to
use that process and they use it and
it's sticky and it grows and they end up
making products which are surprisingly
good where before the same people making
really really really really shitty
products like really bad products you
look at them you like what is this who
made this who authorizes to be published
it's so embarrassing the same people
organized differently next of it look
I'd say wow this is really nice who
invented this who's a genius is no
genius it's just a group of people
working differently so the notion of
self organizing around
problems rather than being driven
towards you know towards the goals seems
to work very well whether this is wider
scale I don't know I suspect that it's
in companies where they have a much more
dramatic outcome if you're guaranteed of
budget for the next five years you're
not going to be revolutionary in any way
at all so the teams we worked with rose
on the knife you don't succeed you're
fired kind of thing within the next
three months one year very short term so
they were taking taking the risk happily
and we've produced a closed source
version of the process it's a pc three
it's called it's very similar but it's
aimed at a close source it still
requires github the private github of
course not GPL license just commercial
just normal normal copyright but very
similar process and it seems to work
very well basically you take a product
you make a first version of it you throw
it as a bunch of testers people using it
all the time and they're finding
problems and they're reporting problems
on issue tracker a bunch of developers
you throw the issue tracker and the ones
that don't perform you get rid of it's
that simple and you keep bringing new
developers and see who can hook into
problems and the ones that solve the
most problems they get the most
something most credit most bonus
whatever it is no ones that don't think
I removed gently and the developers
don't get told what to do they just
organized around the issues and it's a
certain methodology and how you express
the issues so it was a problem you don't
specify a solution you obviously this is
my problem I can't do this I won't do
that and then there's some discussion
and then there's a pull request in this
merged and that's it and we get
something very similar to what we have
in zeromq where the master version on
github is basically production ready all
the time it's very weird little patches
which are carefully thought at each
patch of x1 issue gives us a smooth
development process there's no design
process there's no testing process it's
continuous testing all the time and
continues design of little features one
by one each problem is being solved and
the master version is pretty much always
stable this is
amazing but we're shipping on this
company I can specify but they make
smartphones and we're shipping this
software on every smartphone that comes
out now make hundreds of models every
week there's a shipment the master
version is being shipped it's really
quite stunning and this is Anna company
which has no software engineering skills
they're incompetent world-class
incompetent making this amazing software
so yes this is this is used successfully
in closed source but maybe not
everywhere for a while yet I think as
open source becomes a dominant theory of
how to make software that's become
inevitable people will want to use
techniques they've seen they've used
elsewhere I think most of Engineers will
use open source and contribute open
source as part of their education and
they'll bring into their work inevitably
it will take time still long that you
say that it's meant to be
self-organizing within a granny
environment and yet okay you do kind of
have thrown developers at it and you say
well work on this project please so
there's obviously there's obviously two
cases one is pure open source and one is
commercial development and commercial
development you have money you have
budget to spend and you have certain
goals in terms of shipping software
right so you're trying to put your money
and turn it into shot into software
somehow with the open source it's a
little bit different similar in some
ways you have money or your time
investment and you have some goals but
you're going to bring in many many
people to help you in those goals in one
way or another so it's a it's a little
bit different leverage is different
right the leverage is much more indirect
much more longer term you can't tell
people hey we'll go and work in this so
the developers that you're paying on the
one hand you can say look here's an
issue tracker this project really is
important for me because its mission
is important for me now how i get there
i don't know i said i don't have any
idea how we're gonna get there but here
it is look at the issue tracker what can
you do and if the developers say no it
makes no sense to us at all we don't
like it then you're like okay i have a
problem here either I very bad
developers or they're telling me that my
mission is bad if they can work on some
issues and make some some changes and it
kind of starts to fit with the people
trying to test it and use it for system
carry on but what they actually make
every day what they actually do you
don't tell them don't have to they
should be able to think about it
themselves work it out as they would in
open source argue come to a conclusion
it was the best is simplest and because
are under pressure to deliver quickly
and they haven't got six weeks to make
an amazingly big thing they'll make
little changes and little changes are
much easier to judge to fix the test to
check and big changes so they're
self-organizing within a certain domain
you know paying them to go and work on
some other project they are working on
this particular problem that you defined
for them for example with zeromq we have
a mix so there are people I pay and I
work myself on zeromq with very specific
goals our goals are things like bug
fixing so there are so historic bugs
which people can't fix nobody will be
able to find them and so there's a small
team that works on those when it comes
to adding a new stuff making you know
explore to stuff we don't do that we
stay away from that and let other people
think about them all right i was
thinking more essay your company has two
or more products and when you know my my
reaction to self-organizing developers
would be that they choose what projects
they want to work on sure absolutely
would that be a part of yeah that would
make perfect sense because a normal
company will have lots of products I
mean we have I don't know we have five
or ten anymore anytime any point in time
we don't know which ones are going to be
successful we don't know which ones are
really worth working on
but everyone has an opinion of that and
the collective opinion is probably much
more accurate than my opinion if I'm the
guy finds it or starts it i have a very
biased point of view i will lie to
myself all the time if i get my buddy to
tell me he will lie to me just make me
happy but some group of people thinking
about it will come to a much more
accurate understanding not just
developers but people who can also you
know use it downloaded try it get
involved so the self-organizing is also
pool as well as push it sits I like that
product I want to try it yes I'll make
an issue on it it's a product there that
no one's making issues on it's probably
dead probably no one is using it so why
would you work on it and developers can
judge where their interests lie if I
work on that product is good for my
career that's probably a good sign as
well</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>