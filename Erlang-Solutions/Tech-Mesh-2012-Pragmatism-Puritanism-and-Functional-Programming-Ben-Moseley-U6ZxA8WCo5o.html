<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tech Mesh 2012 - Pragmatism, Puritanism and Functional Programming - Ben Moseley | Coder Coacher - Coaching Coders</title><meta content="Tech Mesh 2012 - Pragmatism, Puritanism and Functional Programming - Ben Moseley - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tech Mesh 2012 - Pragmatism, Puritanism and Functional Programming - Ben Moseley</b></h2><h5 class="post__date">2013-09-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/U6ZxA8WCo5o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning Phil took us all the way
from Haskell to Java only taking us back
when I guess before the phone journey so
I'm going to talk about pragmatism
puritanism and functional growing so we
start off by carrying along the
religious theme and asking why am I here
what is my purpose and even though I'm a
functional breaker I can't really answer
that and the higher order sense but i
can tell you why I'm here at technische
and the reason I'm at technische is
because I'm interested in large-scale
software development so I spent about 16
17 years of my professional career doing
building large-scale industrial software
systems I think I spent the first decade
of that building object-oriented
software so that's typically systems
which have got multiple millions of
lines of code written an object-oriented
style very often in Java and over time
I've seen systems like that I've seen be
born I've seen them evolve and I've seen
them die I've come to the conclusion as
I think of quite a lot of people that at
the end of the day software development
of large-scale systems in industry is
basically broken the main problem we
have in software in the software
industry today I would argue is not the
multi-core revolution the main problem
we've got is that we still don't know
how to build large-scale software
systems and have them work so why is
that at the end of the day it's because
the systems we build the programs we
build are too complex there should be
too hard to understand and what happens
is that as systems get harder to
understand the costs of maintaining them
and evolving them go up and they get
slower to evolve to respond to change
and as a result of that people develop
is becoming a more time pressure and you
end up getting more bugs creeping into
the systems
so my purpose here at Tech match today
is to give you my perspective on how
functional programming techniques can
help us in industry and to do that I can
be drawing on the more recent part of my
career which has been focusing on an
industrial functional programming system
now this is a bit smaller than some of
the other system of systems I've worked
on so it's probably of the order a few
hundreds of thousands of lines of code
but it's still a system with developers
scattered around the world and we can
draw useful conclusions from that I
would argue I think it's probably one of
the one of the larger commercial
hospital systems in the world moment so
I'm gonna talk about Haskell I'm going
to argue that Haskell makes our programs
simpler to read and simpler to write and
these two things are not equally
important it's far more important that
your software be simple to read and
simpler to understand so does this mean
that Haskell itself is simple and I
would argue that actually it probably
doesn't if you look at something like
ghd the Glasgow Haskell compiler the
main Haskell compiler which is used
that's probably one of the most
sophisticated complicated compilers on
the planet the important thing however
is not the complexities which are
bundled up in the compiler or the
language itself the important thing the
thing which makes all the difference is
how simple your programs are to
understand at the end of the day and
that's why I think Haskell really shines
so high school maybe not simple as a
language is easy well easy is probably a
relative term it's it's easy if you know
Haskell I think there is I think there
is a learning curve issue here if I'm we
touch on that a little bit but the
important thing the takeaway message is
that Haskell is one really good way of
making programs which are simpler to
understand oh no this is another
language sales pitch
the point I'm trying to make with this
slide really is just that what I'm
interested in is not languages i'm
interested in in software techniques so
if you want to think of it this way you
can think of it as i'm going to talking
about the language features that i'm
going to demand in the next program
language i use after high school i'm
already looking at a couple where so
what is it that's important about
functional programming at the end of the
day I think is only one thing that's
important about functional programming
and it's it's none of these things it's
the fact that functional programming
lets you write programs which is simpler
to understand these guys are important
because they're they're the main ways
that functional programming lets you do
that so today I'm gris focusing just on
purity and type systems and we see some
examples of how they help I don't try to
have a bit of balance in this talk as
well I want to talk about what it is
that makes functional programming hard
to learn talk a little about the
learning curve so I was thinking then I
tried to call the list of what things is
it that actually makes functional
programming to be hard to learn and this
is the list that came up with saying I
talked about the first two things about
purity and type systems some of their
benefits some of the pitfalls and some
things about the learning curve involved
so first up is purity the functional
programmer sounds rather like a medieval
monk denying himself the pleasures of
life and the hope that it will making
virtuous and this was a quote from John
Hughes I think maybe at the end of day
this is why I prefer to refer to myself
as a functional promo rather than
investment banker but more seriously i
think i'm a bit wider the purities got a
bit of a bad reputation in the industry
at the moment for I don't know maybe
being impractical unrealistic something
like that and I'm going to argue that
that that might be true about 30 years
ago when when this was written but it's
certainly not treated
it's not been true for ya more than a
decade in fact i'd probably go further
and i'd argue that if you're interested
in building large-scale software systems
and actually having them work trying to
build them without using purity in some
form that's what's really unrealistic so
large scale systems how do we go about
building them the end of the day we
build amount of bits or chunks as I'm
going to refer to them here and when we
do this we're really interested in a
couple of different things we're
interested in the results we get back
from a chunk so we're interested in not
the Y and the Z we get here and we're
interested in what it is that a chunk
does because at the end of the day
there's no point in calling chunk 3 or
chunk 4 if you're not going to get a
result unless it has some kind of a side
effect so I'm arguing that the really
important thing is that your programs
becomes simple to understand so I want
to look at some small bits of code and
try and do some understanding of them
we're going to try and read the bits of
carry we're going to ask them very
simple questions and see if we can get
come up with the answers so the first
scenario is is we're going to imagine
we're just shipping what we're trying to
ship the very first version of our
software we're up to version not point 9
where our final beta releases and we get
some user reports that come in and say
that basically will work out that value
why is wrong in our software so we need
to go anywhere to debug this we need to
track down where could this problem be
coming from I'm quite clearly we listen
clearly it could be a problem in in
trunk too so we're probably gonna have
to look at the code for that and and
read it and try and find a problem but
could it also be in shunt one and the
answer is we simply don't know there
could be some mutable state involved
which could be upset by chunk 1 which
causes Trump to to give the wrong result
so simply by looking at this code we
can't tell whether we're going to have
to investigate both bits of the software
that both jump while and chunk 2 and
every time we ask one of these simple
questions and we cannot the Lancer don't
know
that's basically a fail it's a failure
of us trying to understand our system so
when I see a couple other examples now
we're going to assume we've solved this
bug we've made it all the way to version
one of our software our users are happy
there's no bugs at all and in fact it's
so successful we come up with a full
release of the software we make it all
the way to version two sadly with
version 2 we introduce them to new bugs
or 11 new bug in particular and the
question is we're gonna have to go
through our changes to our system and
we're going to try and work out which
changes could possibly have introduced
this bug and so this is the first change
the first change here we've swapped the
first two lines around so now we call
chunk 2 rather than chunk 1 first and so
the question is could this possibly have
caused the problem and well again there
may be some mutable state involved in
something like that so we just don't
know whether that caused the problem or
not so how about if I tell you that
there's no mutable state involved in
chunk 1 or jump to can we then say that
this was a safe change we rule it out as
the possible cause of our bug and the
answer of course is still no because
maybe these chunks I didn't know any
mutable state but maybe they were doing
some I oh so maybe they were both
writing to a file or something and
clearly if you write to the fire in a
different order that could cause a
problem in the system so how about if I
tell you there's no state there's no I
oh can we then say this was a safe
change and of course sadly again the
answer is still no the example here
might be maybe both chunks would raise
exceptions and in version one of the
software the exception from chunk 1 was
being caught and handled and the system
was carrying on and everything was fine
whereas in version 2 of the software we
now get the exception coming out from
jump to and maybe that's a different
kind of exception and maybe the
exception handler can't handle that and
maybe that causes the problem so just
the mere presence of exceptions in the
code could cause this to be unsafe
transformation so again we're asking you
the question
this have changed the behavior of the
system and the arts is we don't know we
look at one more example change here
this change was a an optimization so in
version one of the software we called
chunk for twice in version 2 of the
software we only call it once and use
the resulting in two places so could
this possibly of course a problem well
again of course the answer is we don't
know because what we don't know in this
case is whether in version one of the
software whether we were getting two
different results back from each of our
two invitations of chunk for in version
one where x and y the same we don't know
so maybe we attach the debugger maybe we
go an investigate version one of our
software and we look at it and we look
at the results that we're getting back
from into x and y every time we enter
this fragment of the code and we see as
far as we can tell each time they are
the same and maybe that's good enough
for us maybe we're going to say they're
fair enough can we then assume that that
this was a safe change and of course now
because we have the same issues with
mutable state as we had before so maybe
there's mutual staging chunk for maybe
that doesn't cause the results of chunk
for to be different but it could quite
easily cause side effects in other parts
of the code so we still can't say this
is a safe change and at the end of the
day the problem here is just we don't
have enough information to reason about
our coach be able to understand it and
answer even simple questions about it
and worse than that the the problem is
the information we need is hard to get
hold of so the only real effective way
you can get hold of this information
it's by going a looking at the code
reading the code for chunk one reading
the code for chunk to reading the code
for channel 4 and of course then you
have to read all the code for all of the
chunks that they call and all of the
chunks that they call 2 and so on and if
you're working in any kind of real world
system which has got millions of lines
of code in it this rapidly becomes
completely impractical and so what ends
up happening is that even with the most
experience most diligent developers in
the world they can't possibly read all
the code
is necessary to answer their questions
effectively and so inevitably they end
up having to guess now if you're
building a system and you've got really
good really diligent really experienced
developers they're going to get right
most of the time but of course most of
the time is not the same as all the time
and if you've got a lot of developers
working over a long period of time
making a large number of guesses then
sooner or later statistics is going to
conspire against you and that's how bugs
get introduced and at the end of the day
that's what really kills large-scale
software systems so purity what is
purity well it's very simple it's if
you've got a chunk that's called F then
it's pure if and only if it takes input
values of type A and it turns values of
type B and it does nothing else that has
no side effects at all then it's pure
and if we can say that about our chunks
the chunks of code we've used to to
build it ourselves we're from here
that's a really powerful property we can
instantly answer all of those questions
you're asking a minute ago so we
instantly know if we know that the
chunks for cure we know that the
reordering those first two lines is
completely safe that can't possibly be
where the buggers and if we know the
chunks appear we know instantly that
this optimization was also said we know
that we can rule that out as a possible
cause of the bug straightaway so this is
the the really the real importance of
purity it helps you to understand and
answer simple questions about your code
and saves you huge amounts of time end
of the day so I want to talk a little
bit about some of the pitfalls behind
purity and the first pit forms the most
obvious one of course it's it's
sometimes you actually need to have some
side effects in your code sometimes you
actually want to have some mutable state
or something like that and fortunately
there's something we can do about that
and what we do is when we want to have a
region of lock code and we want to
introduce some side effects to that we
do two things the first thing we do is
we change the input value the the a on
the left hand
I'd and we change the output value
change the values which was passed into
and out of chunks and the second thing
we do is we change how we glue the
chumps together so for example if you
want to add some state into a section of
our code then the way we do that is we
add so maybe we want to add integer
counter or something like that to the
code the way we would do that is we will
add an extra integer input but I've
called s here we're gonna add the same
in turn out put to the result site over
here on the right and we would change
the way we glue the chunks together so
we simply thread the values from one
chunk to the next and using that we can
simulate mutable state we're still
maintaining all the RPO reasoning
abilities about arcade and you can also
use a variant of this technique to have
the compiler perform genuine mutating
place update as well so this this
technique allows you to have efficient
mutable hash tables and mutable arrays
and things as well it's going to look at
one other kind of side effect so that
was how you might simulate state you can
also use the same approach to simulating
pieces of code which may throw
exceptions or may go wrong and use the
same approach you you've changed the
input and output types in this case we
just change the output type to be a
maybe B or an optional be and we changed
the way we glue the chunks together into
a sequence and this time the way we glue
them together is each time we've called
one we check the result we get back see
if we've really got one if we have we
carry on if we haven't we bought the
computation so it's different way of
gluing things together so that allows us
to simulate exceptions so this is ok but
it's a bit of a pitfall and the pitfall
is it's starting to look a bit ugly
really but all of this is glue all over
the place we're having to wife wire up
and plum ourselves unfortunately you can
address that as well and the way you
address that is simply by adding some
syntactic sugar we had two bits of
syntactic sugar we had one to make the
the types easier to read and we have one
to make the
glue disappear so we just have this do
at the top here and this syntactic sugar
is actually overloaded so depending on
the type involved so depending on the
side effect involved this these sugars
into the right kind of glue
automatically now hold on it is this all
a bit of a con what have we done here we
started off we said that side effects
are a really bad thing we took them out
of our language in the name of purity
and we're just going to put them all
back in again so have we actually
achieved anything here and I would argue
yes absolutely you have and you've
achieved that you actually achieved a
lot but why is that first of all we're
only putting them back in if necessary
so there's a cultural thing here we try
and avoid using side effects where we
can but more importantly when we put the
side effects back into the code we're
putting them back in in a restricted way
in a restrictive way that makes the code
simpler to understand so specifically in
the new world every chunk of code uses
only the effects that it needs so if it
only needs exceptions we only have the
glue for exceptions if you're only needs
state we only have the glue for state
and nothing else the exact effects which
are being used are visible in the type
of the code I'm going to talk a bit more
about types in the second half of the
talk and the final benefit is that you
actually get control over how different
effects interact so there's actually a
number of different ways that you could
make use of both exceptions in the state
at the same time in normal languages
which bite them into the main language
the mutable state changes you have a
persisted if an exception is raised so
the state changes have still happened in
high school you get a choice you can do
that or you can go the other way around
and have make sure what no side effects
get no state changes happen in the case
of exception so that can sometimes be
useful but the more important ones are
the first two because they make the code
simpler to read simpler to understand
so the second pic fly want to talk about
is about equality now the quality is
quite useful thing you need it whenever
you want to put structures into
collections for example for example if
you want to use them as keys and a map
and one of the things about working in a
language which is pure is that you've
only got one kind of equality or in fact
you could say you've only got one kind
of equality to worry about and that's
pure value-based structural equality and
this is normally a really good thing
it's much simpler normally works really
well it eliminates a whole bunch of
equality related bugs but of course it
can occasionally cause some performance
problems and the case that we ran into
at work was that we were using some
fairly large expression structures to as
keys at a map actually as keys in a
cache and what that meant is every time
any look up was to happening all of the
comparisons that were taking place we've
been complete sort of structural
comparisons which really killed the
performance unfortunately the solution
to this is not too complicated what you
effectively have to do is you
reintroduce an explicit notion of
pointer equality and the way you do that
is simply by assigning unique
identifiers to each of the nodes and
your trilling so we assign unique
integers and we use them to drive the
Equality test which can then be fast and
gets us around those performance
problems so the high-level approach here
was in some ways similar to what
happened with side effects we took out
side effects and put them back in the
control way with pointer equality we
make sure we take that out of the
language and we put it back in an
explicit way only where we need it only
localized in places and that leaves our
overall code being much simpler to
understand so the third pitfall I let's
talk about is to do with objects which
change to do with identity sometimes
you're building a system where it seems
the most natural way to model this is
with mutable objects and how on earth
would we do this in a pure functional
and one of the examples is if you're
building like a CAD system or something
like that so maybe you have different
objects in their circles and lines
something like that and you want them to
have references to each other and
maintain relationships as the objects
change their state so you might for
example want to make the circle on the
right hand side bigger and you want the
lines to change to reflect that slow
maintain their tangential relationship
or something you know that kind of thing
in an object-oriented world this is this
is very easy to achieve you have
different objects for the circle you
have different objects for the lines and
you'd have references between them so
effectively you've got references to
mutable stage here but we can't do that
if we're working with purity the
solution this has some similarities to
the solution to the efficient equality
program effectively what you have to do
is you assign a unique identifier to
each of the objects involved to the
circles and the lines and then rather
than they are mutating them you maintain
an association map which records what
the current state is if you like of each
of those identifiers so then rather than
updating the state of the small circles
become a big circle you simply
disassociate the circle with the I
disassociate the ID sorry with the the
small circle and we associate that with
the larger circle so you achieve the
same effect but without actually
mutating anything in place and in some
ways this has similarities to the
approach which is taken in relational
databases so again here we've taken
identity out of the the language where
you put it back in again in a restricted
way and that's the approach we've taken
all of the first three pitfalls we've
taken things which make our code harder
to understand remove them and then put
them back in in a controlled manner and
that enables us to avoid these pitfalls
there's one which i think is a bit
harder to avoid there and that's that's
the learning curve and it's been my
experience that learning to think and
program with purity is your default
model is not something which didn't come
treated me anyway I think a lot of
functional programming zealots would
probably say that no no purity is the
natural weight of religion about things
this is how mathematics works for
example but my experience is slightly
different I think people tend to
naturally feel more at home in a
stateful mutating updatable world and so
that there is a bit of a learning curve
there but I would say that it absolutely
does become natural with some practice
and further than that I'd say the
benefits you get from in terms of
improving the understandability of your
code are so important that I think we're
all going to have to learn how to do
this in industry so that's purity I want
to talk now about type systems and by
type systems I mean static ones so this
is the point in the talk why put on my
Crusaders costume and I wander onto the
the bloodiest battle field in
programming language debate and what I'm
going to say is that statically typed
languages are dynamically typed
languages which is one difference and
that difference is they behind an extra
feature and that extra feature is that
whenever you're making a classification
in the language wherever you decide you
want to distinguish between two things
you have a choice you can make that
distinction statically or dynamically at
compile time or at runtime additional
differences they typically tend to make
use of this feature in their standard
libraries that doesn't have to be the
case in principle so when I look briefly
at how Haskell works in Haskell boodle
is not too tight which is built into the
language it's a type which is defined in
the standard library and the point I
want to get across here is that there
are two sides to data definitions data
type definitions in haskell as the left
hand side where we've got ball and this
introduces the static classification so
we're introducing a new static
classification here and then there's a
right hand side and that's the dynamic
side and we're interview seeing some
runtime tags here if you like which is
to enforce and their distinguished only
at at one time and in the normal
standard libraries in high school
we have the other basic types are
treated as other separate static
classifications here but in principle
you could quite happily have an
alternative standard library for high
school at work like this where you only
have a single static classification so
the static point of view everything
looks the same and all of your basic
types are distinguished solely at
runtime solely dynamically and then you
start to get behavior which is much more
like a dynamically typed language and
you're absolutely free to do that it
just happens to the standard libraries
don't do that by default I want to give
a concrete example of how this works
with a slightly higher level type and
the example I want to talk about is foil
pals now when it comes to file paths or
just plain strings the first choice
you've got is to make no distinction
between these at all you could just
choose to represent and the strings and
if you do that then you have an
operation for maybe appending these
things together that would insert a
slash delimiter or something and it
would look like this and you would
invoke it like that and that would be
fine of course if you try and do this if
you accidentally pass in the text of
your first novel instead of a directory
path here then again you're going to get
no error now not only you're going to
get no static error you're actually not
even going to get a runtime error at the
point you try and append these paths and
you might decide you don't particularly
like that and if you do then you might
want to make a distinction between
strings and paths and you might decide
to make this distinction at runtime if
you do then the way you do that is by
working on the right hand side of the
data type declaration you add a new tag
on the right hand side for path which is
separate from the runtime tag for string
then the if you try and invoke the
append operation like this then the
append path operation can look at the
tags detectives been passed in the wrong
one and give you a dynamic error at the
point you're trying to pin the paths now
of course you might decide that you'd
like to know even earlier than that so
you might decide you want to make this
distinction but you want to make it as a
static distinction and to do that you
instead add a new static classification
called path a whole new one of the time
if you do that then you describe your
your literal pars look something like
this their types are in yellow so
they're just how a static classification
of paths as opposed to your value
everything else has your append
operation then has a static
classification like this which
statically enforces its given paths and
then if you try and do this then you get
a static error compile time and you
could quickly vape it like this so the
point is that with a static type system
you have a choice about whether you make
this distinction statically or
dynamically however you might want to go
a bit further because even with our
static distinction we get no error when
we try and do this where we actually
make use of a file as our first rather
than a directory path to start with me
try and depend two files together so you
might decide we want to make another
distinction so we've distinguished now
between strings and paths in two
different ways static Liam directly we
now might want to distinguish between
file paths and directory paths or we
might again choose to do this at one
time if we choose to do it as a runtime
distinction we do it by working on the
right hand side of the Declaration so we
add a new tag so we split the tag for
file paths into 214 file paths and 14
directory paths and if we work like that
then we invoke the the append operation
like this because we're passing in a
file path the pend operation can detect
this and give us a dynamic error so if
instead we wanted to do this make a
static distinction then we would start
off with what we had before so the
single static type we would amend it we
would add a new type variable here
there's actually a couple of ways of
doing this I'm only going to give one so
this example here we add a new type
variable on the left hand side of our
our distinct declaration on our static
classification here and so this changes
it from defining a single static
classification into defining a whole
family of different ones and in this
particular case there's only going to be
two members in this family
going to effectively be two defining to
static classifications with this one one
declaration that that means that our
literals I saw require new static
classification types like this so before
they were just path now their pasture
and path file as appropriate and our
penned operation now applies this type
which statically enforces that the first
augment has to be a directory path so
the whole point of this is that static
typing really is a sliding scale you
choose if you have a static type system
how much classification you want to do
statically and how much you want to do
dynamically so we've seen that with
strings versus paths we can make no
distinction we can distinguish at
runtime or compile time and we've seen
that with a finer distinction here file
paths and directory parts you can choose
not to distinguish all make a distinct
distinction at runtime or at compile
time so the benefits of static type
systems clearly they make your code
simpler to write we've seen that the
analysis to detect errors earlier but
more than that with Haskell at least
they're almost always the very first
thing you right so we use them as a
statically checked design language in
addition to that they're really useful
when it comes to refactoring you can
almost turn your brain off on your
refactoring code you make a change then
you get the whole list of all the other
places you need to change as well they
help our ideas and they help out
performance but none of these are the
really big benefit of static type
systems the really big benefit of static
type systems is that they make your code
simpler to read they make it simpler to
understand and this is what I was
arguing with the huge problem with
large-scale industrial software systems
static type systems are a godsend here
we're going to see four ways they do
this we're going to see how just having
static types helps us locate bugs I'm
not talking about type errors here I'm
talking about bugs in code which is a
winy type correct we're going to see how
static types help us to understand
normal code so this is
without bugs in it so that prolly a few
minutes abnormal code but anyway we're
going to see how static types help us to
understand very abstract code and we're
going to see how they document side
effects but first of all I want to talk
a little bit about how to think about
static types so I like to think them in
terms of assumptions and guarantees if
we're trying to understand the chunk of
code called my chunk it's got this type
signature we know that this code in my
chunk whatever it may be is allowed to
assume that its input as a list of
integers and furthermore it must
guarantee that its result is also a list
of integers sounds a bit boring but it
gets a bit more interesting if we have
type variables in here so if we have a
type variable a then what this tells us
is that my chunk is allowed to assume
that its input is a list of items but it
is not allowed to assume anything at all
about what kinds of things are in that
list and furthermore it's got to
guarantee that the result is a list of
values and there's got a list of values
of the same kind as it was passed in if
instead it has a type since you look
something like this then it sounded to
make an additional assumption it's
allowed to assume that the elements and
the list have some kind of an equality
operation on them if as this signature
it's allowed to see them they have
numerical operations if it has a
signature like this then it's
additionally allowed to do runtime
inspect introspection and examine what
kind of type things are and then switch
behavior accordingly so do things like a
type-safe cast that kind of behavior but
without that with just the type
signature like this the code in my trunk
whatever it is cannot possibly be making
any assumptions about what's in the list
or it wouldn't compile the type checker
ensures that for us so locating bugs so
this is our program and we're getting a
report from our user that there's blood
in this system and there's a bug because
the result of the system result of this
process with call is a list which has
got
number in it and we're not ever supposed
to have any negative numbers in our
output some reason we look at the code
and we can see that the input R is a
list will only positive numbers in it
and that that list is passed into
function f and the result of that then
passed into function G and so clearly
the bug could either be in function f or
it could be in function G now function G
is right here whereas function f is
actually passed in dynamically so that
means the bug could be in principle be
in any one of the only possibly hundreds
of different s which are called passed
into this function at one time so we may
just at the moment based on current
information let's go and look at all
those bits of code locate our bug ivory
had a type signature here then the
Haskell programs in the room are going
to go and say look at this type
situation and say instantly the buggers
injury they let need to see the code for
G they don't need to see any of the code
from F just from looking the type
signatures and the description of the
problem that we had a negative number in
the output they can tell us that the bug
is in G and the reason they can tell us
that is because the type for F tells us
that none of the f's at all are allowed
to assume anything about the kinds of
things which are in the list and if you
don't assume anything at all about
what's in the list then you certainly
can't make things negative so what would
happen if we had this type sinker
instead if G also had this type
signature which takes a list of a's to
this today's well with this type
signature it's absolutely impossible for
process with to ever return a list of a
negative number in it so if this is the
type signature then we know the user has
made a mistake in their bug report
because at the end of the day the type
checker does not like so that's locating
bugs so this example going to try and
understand some code and see how the
type system can help us with that so
here's some code and this is actually a
pretty nasty code and therefore it's
actually probably fairly realistic if
you're working on a large scale system
so if we need to know we're not going to
try and read it instead what we're going
to do is we're going to look at a number
of different types
inches for this code and see how the
type signatures alone allow us to infer
different things about the code without
even looking at this and all of these
type signature is going to be valid ones
that the programmer could have written I
like you some are better than others so
if we say this is the first one then
this this type signature signature tells
us this chunk of code takes two lists of
pairs of integers and returns another
list now this gives us a bit of
information that tells us were working
on lists and we wonder what the code
might possibly be doing it could be
multiplying all the numbers by 10 for
example it could be a pending those two
lists together to make the result rest
so we've got a bit of information but we
can't deduce too much from that type
synced you're alone if instead the
program I had given the type signature
at this type cincher which is equally
valid then we as the person reading the
code could instantly infer a whole bunch
more we know now that this code whatever
it is is not multiplying any of the
numbers by 10 because it's got no
numerical operations it can possibly do
it could still have us still be
appending those first two lists together
it could be swapping the elements of the
pairs around it could be maybe taking
intersection of them or it could be
maybe just maintaining all of the the
pairs where the first and the second
elements are the same could be doing any
of those things so we still get we get a
bit more information with this type
signature but this isn't the best type
sync check the best type signature to
give this function is actually this one
here and this is actually the one that
ghd's type inference would infer and so
now we can see there's actually three
different type variables involved a B
and C and this tells us that this piece
of code is not allowed to assume
anything about the relationship between
a B and C it's certainly not allowed to
assume that they're the same type it
allowed to seem nothing at all about a
nothing at all about C and therefore the
only possible way it can generate
agencies on its output is by taking them
from whatever ones were past it in in
the relevant list and the only thing it
can do with bees is do some equality on
them and therefore use them to match up
the values
they're being passed in so the point
here is that this sat excite signature
without us looking at any of this code
is only giving us quite a lot of
information about what's going on and
what's actually going on here is that
you could imagine this being some code
for a social networking site with sort
of friend relationships between user IDs
and this this is identifying new friend
of friend possible relationships or
something like that and just to reassure
you the sort of nicer way of writing
that piece of cake has called be
something like this but chances are if
you're trying to debug someone else's
carried it won't load like that so
that's how types help us to understand
working code so now how they help us
handle very object code well this is
some very abstract code it's very small
piece of code but it's very abstract
we're not even going to try and dive
into exactly what it's doing but I
trying to make a couple of points I'm
going to ask one question and that's
what kind of thing is this H here now
even the experienced haskers in the room
if they haven't seen this function
before are probably going to take a
little bit of time to work out what's
going on so Allah here is a high order
function and I want to do now is I'm
gonna add a type signature on to this
and two things are going to happen half
the people in the room we're going to
have a heart attack because the type
signature is bigger than the code itself
and the people who've got bit of a house
for experience will look at this type
cincture an instantly tell us all right
okay I can now see the H is a higher
order function itself and what that
tells them is that not only is a l'heure
a high order function which takes
functions as inputs and happens to
return a function is output and there is
a higher order function which takes
three functions of rim as inputs one of
which is itself a higher order function
and returns a higher returns a function
as a result so allow is a higher order
function which operates on other higher
order functions and the point I'm just
trying to make here is that trying to
write code this level of abstraction
without a static type system to help you
is really really hard and if you manage
it pity the poor person sees got to then
try and understand
site that without be able to lean on the
type system to help them understand
what's going on so the final thing I
want to look at is with how types help
us with side effects so we saw these
examples this example before state but
the way you normally a counter this soon
production Haskell code it's something
like this you've got a body of code
you're trying to understand what it does
and the very first question you want to
answer is what kind of effect phul
environment is it I must interpret or
understand this code in and the way you
do that very first thing you do is you
jump straight to the top and you look at
the type signature and here we can
instantly see from the type signature
there are no side effects in this code
apart from the state and more than that
we can see that the only kind of state
which is being an idiot or the only
piece of state which is being
manipulated is a single integer and a
single boolean and so then we have that
in mind when we read this code if
instead the the types integer look like
this then it's a more side affecting
piece of code and this type see me who
tells us that there's still some state
in here this time its state of type
connection the code is reading something
from configuration information from a
local environment of type config and the
code may raise smeller's or exceptions
if it does then they will be of type DB
error so then we can have all of that in
the back of our head as we read through
this code so my argument here is that
the type systems the really big benefit
of static type systems is that they make
your code simpler to read and understand
we've seen how they help us to locate
bugs even in code which is tight correct
we've seen how they help us to
understand normal working code we've
seen how to help us to understand very
abstract code and we've seen how they
document the side effects which were
involved so static types are really
important and the reason they're really
important is because they make your code
simpler to understand so pitfalls there
are a couple it can take longer to get
your code running because you've got to
fix up your type errors that's much less
of an issue these days because modern
versions of the ghd Haskell compiler
allow you to make
Walt I Perry's into warning so you can
actually run your code anyway if you
like to work like that the second
possible pitfall is changing your mind I
said that if you've got a static type
system you have the choice about which
distinctions to make statically and
which ones to make dynamically and you
do but if you want to change your mind
later on and change from a static to a
dynamic one then you've got a bit of
refactoring to do it's not being a huge
issue in my experience because you don't
tend to change your mind that often
possibly the bigger one is it's the
learning curve side of things and that's
if you're working in a language it's got
a really sophisticated static type
system and high schools of ghd's at any
rate is pleased sophisticated then
you've almost got an entire second
language to learn you can learn the
normal dynamic language the dynamic
behavior you've been and learn the
static language to you and the
constraints and what they mean and how
to interpret them but again I would
argue this is really not a big problem
and the reason for that is this whole
sliding scale thing and that's that you
choose how much static typing you want
to do if you want to do basic stuff so
most of the features we've done been
through in this this talk today have
just used fairly simple features of the
static the high school type system and
we still manage to get really big
benefits in terms of making our code
easier to understand so it's really you
choose to do as much of this stuff as
you want if you want to do really
complicated sophisticated static
classifications you can do that but you
pay as you go really so the summary the
point I want to make is that the reason
the single reason that functional
programming is important functional
protein techniques are important is that
they let you make your code simpler to
understand and that's what lets you
build big systems more reliably purity
and types are the two most important
ways that functional programming
languages can help you do this thank you
so thank you very much been we have a
couple of minutes for questions yeah so
you mentioned something about user
interfaces in a pure style the the CAD
user interface oh yes yeah so can you
talk some more about that you know if
there is a research about it you know
building large user interfaces so
there's lots of research into Haskell
and graphical user interfaces it's not
something I'm hugely familiar with the
big stuff is a topic called functional
reactive programming where you try and
it has some similarities with data flow
way you try and model your your system
as input taking input flows of dynamic
don't be changing values and that can
make things simply to describe there
have been some efficiency problems with
that so there's research in that area
but in my line of work we don't build
any theories in high school so this was
just personally experimentation ready
you mentioned task was also a dynamic
language in sense of where you where you
showed that example of passing a
function of a to another eight way to
another function of a 2a is there a way
to interrogate actually user user can is
a program that can interrogate the type
of the arguments passed in at the right
yeah so this is a really interesting
point and in a lot of languages you can
do that kind of thing even in something
that we think of as static and type like
Java you've got an instance of operator
where you can dynamically introspect the
type of an object and you can always do
that this goes back a bit to the point
that phil was making about the in the
previous talk if you were here for that
about the capabilities of object so the
sort of ambient capabilities in your
language so in many languages you can do
that by default for any value in high
school you can only do that if it's
declared or bother if you try and do
that you will be able to see it in the
as the type inference system will report
that that's happening and so that was
you would have in your type signature
something which says typable a until
then you know when you're looking from
the outside of that code without reading
all of the code involved you know
somewhere in that it might be doing some
special dynamic lookups sure yeah if you
want to it if you want to program pison
style in high school you can and then it
will behave like Python give or take if
you want to program like see you can
program like see in high school and
again good luck to you but yeah so you
choose really what style you want to
program in and yeah we strongly
recommend purity where possible the
approach is purity by default but if you
want to break out then you can break out
and it's clearly delineated what's going
on so if you're trying to understand
someone else's code has done this you
can see what kind of things are up to
all you have to read the code that's
that's the real big win no more
questions not at all so if i may ask so
now you're talking about all of this
stuff with Haskell and what would be
your message to people who can't use
hair school in the day-to-day life what
what we were the takeaway be further for
them it's absolutely the back there's
huge benefits to be had by using purity
as your default approach so if you're
writing the carrion you're building a
new system trying to avoid side effects
as much as possible makes it a lot
easier to understand you're never going
to have quite the same ease of ability
to understand someone else's code if you
if it's a black box and you don't know
what's in it you have to assume that
they could have used any feature in the
language so that's that's one of the big
strengths of
look at school but if you're not using
it you get some benefits in that their
menu makes things easier cool there are
no more questions then thank you very
much thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>