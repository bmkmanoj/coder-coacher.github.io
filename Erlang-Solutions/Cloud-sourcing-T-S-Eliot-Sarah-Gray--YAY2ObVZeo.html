<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Cloud sourcing T S  Eliot - Sarah Gray | Coder Coacher - Coaching Coders</title><meta content="Cloud sourcing T S  Eliot - Sarah Gray - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Cloud sourcing T S  Eliot - Sarah Gray</b></h2><h5 class="post__date">2017-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-YAY2ObVZeo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello okay I have a microphone and I
have a clicker but I'm gonna make this
work first of all thank you guys for
coming I really appreciate it my name is
Sara like Garrett said and I'm really
excited and honored to be at this
conference I have been programming for a
long time since 2001 in fact most
recently I was programming Python on
Hillary Clinton's presidential campaign
but I am a relative newcomer to Erlang
and so what this talk is gonna be it's
it's gonna be talk about me learning
Erlang through the context of a project
in process that I've been working on and
specifically talking about it as someone
who comes from a different language or
sets of languages so I'll first describe
the project then my initial prototypes
which were in Ruby and then I will move
on to Erlang and sort of what that
looked like and what I learned so I'm
gonna start the story on my birthday so
March 27th is my birthday and a few
years ago on March 27th this venture
capitalist wrote a blog post that
intrigued me and you should always if
you want to feel good about yourself
always read blog post by venture
capitalists on your birthday really
achieved things but he was talking about
he was engaged in a conversation about
how there were a lot of new applications
and networks that were springing up on
our existing social networks and he was
discussing with a friend of his whether
or not these new applications were
actually networks in their own right
but more interesting to me than that was
he framed our social networks as sort of
an operating system he said what if we
think about our social networks is an
operating system upon which we can build
applications and I thought that was just
a super neat thing to think about it
just just a neat image and my mind
started going and I thought well what
could I build sort of on top of Facebook
or what could I build on top of Twitter
and I'm not a huge Facebook user but I
love and use Twitter or at least until
the election
and now I try to stay away but I think
of it as sort of this giant rushing
stream of consciousness right it's our
thoughts it's what we had for breakfast
it's News events its presidential events
it's like everything and it's just
rushing by and so if you look at it from
a high enough level it's like this
gigantic stream of disjoint words and
ideas that we're all plugged into and so
what can you build on top of a gigantic
stream of rushing by random words and I
thought well you could build poetry and
not new made-up poetry like make it up
but existing literature and so that
became my question which is can existing
poetry be found just skimming along the
top of Twitter so there there's so many
words going by at any given moment so if
you just dipped your hand in and pulled
up a handful of like the current state
of Twitter and let the shaft fall away
could you be left holding a poem like
what if we had one of those fancy leaf
skimmers that you all use for your la
vacation swimming pools right like what
could you skim off of the top of Twitter
and so this is what I wanted to do I
wanted to take a leaf skimmer to Twitter
and see what poetry I could pull off and
I've you guys know the Four Quartets
yeah I've always I just love it it's a
beautiful work and it's so full of it
talks about time and the present moment
and history and it felt sort of
conducive to this timeless stream that
we have in front of us and the the idea
of writing the Four Quartets or having
them be written or rewritten by just
random people anywhere around the world
by talking about what they were having
for breakfast contributing a word out of
context I found that really intriguing
and on top of all that TS Eliot really
basically called Twitter like back in
1935 that's for real that's right out of
the four quartet so what I mean
right yeah yeah so I'm just gonna break
out for one second here because I've
been talking about a river and words and
blah blah blah but just to give I
started building this at the beginning
of the talk and so this is an example of
a segment of the Four Quartets that is
just currently being written off of
Twitter right now so this is real-time
word by word words that are lost just
show up you know in a lost word and you
can just track this and if we did it
again in 20 minutes it would be a
different set of tweets it would be
different people but it would be the
same poem so I just wanted to show you
that so you know what what I'm talking
about so my question was are the Four
Quartets on Twitter and I jumped up at 4
a.m. and spoiler alert the Four Quartets
are on Twitter I wrote a little ruby
prototype super quick just of just a big
messy four loop but it was super
exciting just to see parts of this work
that I love be recreated in front of my
eyes you could mouse over and see the
tweet and you can see words that aren't
found are words that have sort of fallen
out of our language that oops show up in
this column and it was yeah just
analyzing Twitter coming in uh-huh nope
no so just like what's happening right
now
so this this first thing was just a
gigantic for loop it hit Twitter Twitter
was super generous back in the day it
was like search me however much you want
I don't care and then it drew words on a
web page it was very simple but the
thing is I liked the project I found it
compelling and I wanted to keep working
on it and I realized that if I was going
to keep working on it I would need to
have something a little bit something a
little bit better than what I had done
initially like I had a prototype but I
needed a project and so I went back to
the drawing board again with Ruby and I
focused on
splitting the different behaviours of
the domain into their own applications
so I thought of it as having two pieces
a skimmer which would take care of
searching and parsing a poem and a
scribe which would do the writing to the
client and what I did was I just made
two small independently running
applications I ran them up on Heroku
skim row was made up of a bunch of
classes that handled processing a poem
and sending messages in the scribe would
figure out what data what the content
type of the data was that had been sent
and then figure out what to do to do
from it and it was much better than the
first sort of stab at it but there were
some things that jumped out at me which
were I was thinking of these
applications sort of like processes but
they were relying on a third party
vendor for their inter process
communication so they were sharing the
state that they were getting through
PubNub and so what happened if that
vendor fails or one of the applications
fails or what even if I wanted to say
instead of drawing the words like one by
one like spin them up all at once or
look for lost words at the same time and
so it was all doable but I would have
had to look for concurrency libraries
and Ruby and basically I was I while I
had a cleaner prototype I felt like I
was working in a language that wasn't
the best fit for the problem domain so I
needed a different paradigm and it's I
instead of separate applications
applications I wanted to have separate
processes and at that point
enter early I don't know who drew this
coffee cut but it's super nice it looks
very professional I found it on Google
so I had heard about Erlang and it
seemed like the instincts that I was
having for what I wanted the application
to work were things that you got for
free with Erlang so because that's how
Erlang says you should build
applications so you have separate
processes that scale independently each
process has its own copy of the data
there's fault tolerance built-in
processes can access other data without
causing race conditions and it's very
easy to
eunuch ate back and forth between
processes and I wanted to learn
something new I've been programming for
a long time in my last job I was working
in Python and then before that for about
seven years I was using Ruby both
standalone Ruby rails Sinatra its other
frameworks I've worked on objective-c
I've worked in JavaScript and then
before that I had that there was a very
esoteric language I worked and it
started with a P and ended with HP and
in those languages I've been very
focused on sort of traditional
object-oriented designs in the sense in
the sort of traditional sense of
modeling nouns and their relationships
to each other and the applications that
I've worked on have been to a large
degree database back of what web
applications that model business flow
though you know with everybody else in
the last few years I've been moving
towards an SOA model and sort of
grappling with how do we take our
current patterns of code in and put them
into distributed systems with lots of
different components but it it was very
easy on some level to just swap in any
of those languages for another and just
look at different different libraries
and different syntax so for me to look
at a functional programming language
that was built around concurrency
messaging and fault tolerance it was a
new paradigm for me and I was very
excited to dive in the coffee cup on the
left is just a logo from a coffee shop
no it's like elixir coffee elixir coffee
and an Erlang logo and I wanted to put
this up so I've never actually looked at
elixir to this date but when I started
the project of people said to me like oh
you should think of learning a lick sir
because it would be easier and it has a
much more Ruby like syntax and I have to
say that that that didn't sit well for
me and it's not because anything bad
about elixir I've heard wonderful things
but I felt like if I'm gonna use
something that looks like the thing I
already know right and if that's why I
use it this looks like the thing I
already know then I'm gonna sort of
start to try to solve problems the way
that I already know how and even if I
consciously don't want to I'm gonna feel
comfortable enough to sort of think in
familiar patterns and so and I also kept
hearing will Erlang syntax is ugly and
it's weird you should use a lick sir
because elixir kind of takes that away
and that's great but in a similar vein I
thought if I'm gonna choose a language
for the reason that it hides or masks
and ugly weird syntax it would sort of
be like sleeping on a bed with a monster
underneath it right like I I would build
Erlang up into something that was really
big in my mind and and that I was
deliberately avoiding it would be it
would become this unapproachable thing
and again it's nothing against a lick
sir but I really wanted to my thinking
is that when you when you pick up
something new and if it's unfamiliar if
it's an unfamiliar idea just go and be
unfamiliar with it like dive in to that
unfamiliarity with it because even
though it might make you slower and
stuck and all of those things that
unfamiliarity is going to help shape the
way you think and it'll make it much
harder for you to think yeah I already
know what I'm doing I'm already here
and then also it appealed to my sort of
tough side because there's like there's
a mystique around or Lang right it's the
applications are built in a different
domain than the ones I'm used to and it
scales to two bajillion process
is a nanosecond like it's just like
really crazy and people are opinionated
about the syntax and it's like I want to
do that that sounds that sounds awesome
I wanted to dive into these new and
different shapes and see how they
affected my thinking so before we get to
what the code did I just wanted to look
at the shapes of it so here are three
Erlang files some are mine and some
aren't and don't know it doesn't matter
what they do I tried to make them small
so it didn't matter but the exercise
that I would ask you to do and then I
did a sort of squint at it and to see
what you see by the shapes of the words
on the page and so when I squint at it
and I what do I see I see groups of
similar looking code right I see a lot
of code that has the same name but then
different arguments there's there's a
list like terminology that's that has
that's there a sort of circular or self
referential syntax and so okay if you
don't know anything at all what might
you get from these these patterns and I
could say well Erlang looks like it uses
patterns of similar code and it seems
like what was really interesting to me
is that the logic in this application is
effectively a first-class citizen like
you write you encode your logic into
your code rather than sort of building
up a function and then inside it putting
a bunch of different logical statements
so that's interesting and that's that's
a flexibility that means you can think
with your logic right away it makes a
lot of statements I'm sort of very
declarative so I'm you might get other
things but that's just that's what I got
from looking at the shapes then this is
the a parallel this is the same thing it
doesn't matter what it does but it's
three Ruby files and again if you just
look at it what are the shapes show so
one of the first things that I notice is
that in in the Erlang code before
everything was left aligned and in this
code here you only have a couple of
things left aligned and everything else
is a little bit indented and what that
says to me is well there's there's
overriding groupings
some kind of conceptual groupings and
inside of them are pieces of smaller
stuff
there's also assignment so if you're
reading the page from top to bottom you
see values being assigned to things
because okay well this this code assigns
values first other things the chunks are
they're kind of cute right they're short
and sweet they're the words are englishy
and it's sort of fun to read so what
what might that tell us if we knew
nothing about the language you could say
well this language uses classes and
methods maybe it's just encoded into the
shapes the units of work are small and
manageable it seems to be optimized for
human reading it's just kind of very it
has a very English feel to it so it's
not what I'm saying it's not entirely
fair because now I've programmed in both
of these languages so I could be saying
well I know these things and now I'm
retro actively putting them onto the
shapes but it's the shapes are clearly
different and I think it would be
interesting so next time you're thinking
of learning a new language just before
you even get into it just kind of squint
and read some code in it for a while and
jot down like what do you think that
says or what might that indicate and
then work in it for a while and see were
you right were you wrong what else was
hidden etc I think it's just a neat
exercise in thinking differently okay I
have to address this I kept hearing it
Erlang is weird it's ugly and first of
all like why like what do we mean when
we say something a language in this case
is weird or ugly and I feel like there
are two a couple of ways to think about
this and one is a visual impact right so
is the language concise is it verbose so
for example in Erlang there's a there's
a lot of punctuation that's used just as
symbols in the language Ruby uses almost
no punctuation at all so there's a
difference punctuation symbols can kind
of break up a stream of thought perhaps
they could make a code feel cluttered
instead of clear if you were going to
use those words or dents instead of
not dense and dense code can be harder
to read so that might be one reason that
people have that reaction but I think a
more important one has to do with
comfort zone and I think whenever we're
confronted with something that we that
is unfamiliar not easy it's
counterintuitive or confusing we have a
natural you want to push it away and say
well that's weird
it's I don't get it it's because it's
not in your sort of lexicon of thinking
maybe something exposes different ways
of doing things that you're used to or
when you look at it right away you don't
have that moment where you're like I get
it you look at it and say I don't know
or maybe it's you have an expectation
and implicit or xpect for explicit
expectation that has been breached and
so I think these are all things to think
about when you say when you hear that or
find yourself thinking about that as a
language so I wanted to show you one
quick example of an expectation of mine
that was breached which has to do with
string processing in Erlang and this was
a case I was just trying to I was going
over a data structure and trying to come
up with a very simple list of intz right
I just wanted a list that said 34 35 36
37 and my expectation and the way I
thought of this was well this is very
simple and I ran my code and I got that
string on the top like backslash quote
hash dollar % ampersand single quotes it
wasn't even a list and and yeah and it
makes it's expected in Erlang and I
learned like all ASCII character values
are identical to integers and strings of
characters are identical to lists of
integers so the way that I was writing
this like 34 is the backslash of the
single quote I'm not sure if that's
escaped it's a much escaped right right
right but when you first see that when I
first saw that and you what the hell is
this
and I will say in fairness that when I
had to do string parsing in Erlang I did
often wish I was in a different language
oops on the other hand what do you say
what makes someone say oh this language
is elegant or beautiful which is
actually how I feel about Erlang now and
which is a complete shift when I started
it's like aha and now I love it
and I would say well it matches your
expectations so things things make sense
you you can fit pieces together in a way
that's understandable the way that you
think about the problem matches the
solution and using a tool feels simple
just like an extension of fall like it
should be this way the way that I'm
going to do it this is how it should be
and a couple examples so for me now like
there's nothing that I find more elegant
than then starting a function with a
base clause and then working up clause
by clause with different clauses and
again it reminds me of Sarah what you
were showing in your talk with the UM I
forget what it was but the the to
function clauses which were different
because it makes sense if you think
about it you're in the same domain
you're working in the same function but
it's in different contexts every time so
after a while that just seems like a
really elegant solution you can also
ignore the data by using underscore so
every time you're looking at a function
you can just have a different context
the same thing with function era T's
that you can have the same function name
with different numbers of arguments and
it's a similar thing you're in the same
domain but doing slightly different
things and did a recursive list
processing so again at the beginning
lists list processing is
counter-intuitive
you don't have your little eye or your J
you're not going I plus plus J plus plus
but lists are really like Russian
nesting dolls in a way and recursive
processing exposes the structure of the
list instead of just magically giving
you what the next element is you don't
have those messy little variables you
don't have to use each and it's very
clear what happens at every phase the
list is it and I just think wow that's
super beautiful
who knew but it took quite a while to to
get there so anyway back to my back to
my story I decided to learn Erlang so I
did read a by
books which were great and did all the
tutorials which was time consuming but
crate and then I watched a movie this is
this is the Erlang movie that's what
it's called and it's amazing and they
talk to each other on the telephone yep
and I decided to build an OTP
application was it it seemed like what's
the record that that's the recommended
approach and I liked what I was learning
about it because you get a bunch of
predefined behaviors that you implement
an OTP feels to me a little bit like
Legos in that you get components and you
and that you can take and build with and
there are a few patterns you have to
follow how you start your app how you
parameterize your supervisors but it
doesn't feel as heavy-handed as some
frameworks like for example rails or
other frameworks like that which feel a
little bit more like they're saying well
this is how you build your app here's
where all the pieces go do it and OTP
says well here's how here's how you
start your application here's a bunch of
behaviors that are awesome and will take
care of things for you figure out how to
fit your functionality in and now go and
so to me it feels a little bit more like
emergent design with just by which I
mean like a set of rules and entry
points and then a framework and it's
very lightweight there's not a database
layer backed in and it's built for
scaling and fault-tolerance so I'm a new
new Erlanger but this was the boxes and
arrows for my first OTP application so
it's composed of the application entry
point a word ordering server so that you
could say well order the words from the
beginning to the end of the poem or the
end to the beginning or all at once a
few supervision trees that would search
for words or search for lost words
utility code for connecting to Twitter
which I will talk about more in a few
slides and Jen event for broadcasting
and handling events and I have to say
because I've heard people scoff at Jenna
vent and I think I've even heard someone
when it's call it evil but I don't know
why
and it was great for my application
because it allowed like at every stage
of the application processes could
broadcast events and you can hook up
specific types of handlers so you can
say this handler is focused entirely on
sending data to PubNub or this handler
is focused entirely on keeping track of
the current state of the poem which
means a web page could reload in the
middle and get the full thing again you
could hook up a new client and it would
always know where it was and so remember
with my Ruby application I used pub pub
hub as my inter process communication
but here inter-process communication
comes for free that's what Erlang is
built to do it's designed to send and
receive messages between processes and
here's a more accurate view that you
guys use the observer I I discovered it
and I loved it it's a way to see your
application as it's running like what
are your process is what are they doing
and this is this shows my application
supervision tree in two different states
what processes are spawned when I'm
searching for a word and what processes
are spawned when a word is being lost
and I just found this this whole
observer to be a great way to understand
what my app was doing and also to remind
me to name my processes oh for 30 wait
what and then I go back and name it and
get another screenshot and yeah and so
here's just a couple views so this is a
view of that I had that shows words that
are being searched for and not found or
if they're crossed out it means they
were found here's a screenshot of a
segment of the poem that's been drawn
and I will say that one thing I learned
that was very unexpected is that there's
a lot of porn on Twitter
like actual um so what did I get with
Erlang an OTP I got one repo with
different processes I got supervision
trees gen servers and other behaviors
fault tolerance concurrency the ability
to swap out behavior and it's easy to
build new views so when I was preparing
this talk Garrett suggested that I name
it massively scaling TS Eliot and I
would have loved to have named it
massively scaling TS Eliot because as I
said at the beginning my idea is just
pulling poetry off of Twitter in real
time like as fast and furious as you can
get so I absolutely would have loved to
name it loved to name it massively
scaling TS Eliot but Twitter in 2016 is
not your grandmother's Twitter
in the intervening years since I had
done a prototype it had just really
tightened the screws on how you can
access the data so I have an early no TP
application that has the power to
massively scale TS Eliot and it is
basically because of Twitter's rate
limiting I have built a giant for loop
with asleep in it yep
so Twitter rate limits it rate limits
like crazy it didn't do this before you
used to be able to get just like 2,000
words just search all you want it was
great but now you can only get so many
searches per user per every 15 minutes
and what this means is you can't build
poems fast and if you exceed your search
quota you receive an error and
eventually you get blocked so it really
means that no matter what your software
can handle you're limited to the number
of keys that you have and their rate
limited ceilings so between Corey and
myself we had about 10 sets of
authorized Twitter keys just from
whatever toy project one or Tory project
two and which isn't enough to go fast
but it was enough to kind of get me
through development and buy some space
and time and I want to take an aside for
a second and just talk about gen server
because gen server is one of the OTP
behaviors and it's the way that I
structured using the different keys was
to implement a server that manages them
so you asked it for a key it gives you
the most current one it doesn't again
doesn't solve rate limit or anything
like that it just keeps track of the
next available key said and puts the
most recently used one or the one that
got rate limited on the back of the
queue it's just a circular cue cue but
it provides global accessors to a
singleton state and what's super cool
about it is if you look here like I
barely wrote any like I put the keys in
there and a little bit of logic forget
current keys but basically I get all of
this for free because this is how gen
server is built if I had if I had
written something like this in Ruby I
would have made a class with accessors
but it would be vulnerable to race
conditions and I would have had to
manage if different requests came in on
different threads so I just gen server
this is again as a super simple
implementation of it but it was a
wonderful
to have in a toolbox let's talk a minute
about other Twitter detours specifically
because I ended up spending a lot more
time writing code in Erlang to support
what I needed from Twitter than I
expected when I worked with Ruby they
were like here here's a library it's
called Twitter something and you just
did things simply and it abstracted it
and I think I wrote like Twitter dot
search like I didn't have to think about
any of that at all which might also be a
difference in the communities and
libraries but that that's the case but
but when I started this I couldn't find
a lot of existing libraries for the
functionalities that I needed and so I
ended up spending a lot of time writing
code to handle these functionalities
myself which was neat because it got me
deeper into Erlang but it was also like
whoa I'm off on this crazy detour doing
something I hadn't planned to do for
example
ooofff so you know if we talk about like
I wasn't that excited about string
processing and Erlang I at the time I
was doing this Twitter had just recently
been like hey now you always need to use
OAuth and the Erlang libraries I found I
think I found one that was like we're
starting working on this but at any rate
it wasn't done or I couldn't find it and
I was like okay well I'm gonna have to
write this so I ended up writing a
little Twitter
ooofff library in Erlang which was a
crazy thing and figuring out how to see
my SSL requests because you make them
it's hard to see how do you see what's
going wrong and it taught me a lot about
string processing in Erlang and now I
have an OAuth library and the next
roadblock was was rate limiting and so
when you make it was related to rate
limiting so when you make an HTTP REST
call to Twitter you just get back a full
tweet you're like search for car and
it's like here it is the whole tweet
with car but you don't want to make a
lot of rest calls because of rate
limiting and so what you need to do is
connect to their stream API which lets
you keep open a long-running connection
for a set of terms but when you have
this long-running connection open for a
set of terms you don't get back a full
tweet you get back like here's a full
tweet or here's the middle of a tweet or
here's the beginning or here's the end
of one with the beginning of another or
something like here go and it's to you
as the developer to say well
how do I build these into a full tweet
so I had to spend a lot of time doing
string parsing with binary strings which
was crazy and I just wanted to throw up
some of the tests that I wrote just to
confirm I was constructing tweets
correctly out of these random chunks of
binary strings and I ended up spending a
lot of time
how do you do matches how do you do reg
X's in these things
and it works but as I mentioned before
Earling is not built for easy string
processing at any rate so I want to look
at the two approaches side-by-side the
apt comparison so in Erlang OTP there is
one application with many processes they
don't share state and you have built an
OTP behaviour in Ruby I had then I'm
just going to say two separate
applications and I put it in quotes
because if I wanted another one it would
have been three or four the process is
shared State and I ended up writing a
lot of custom classes in Ruby there's a
very much this is great there's very
much culture of program by wishful
thinking that's part of the Rubik
community so you just sort of write what
you want it to do which is great I love
that approach but there's very different
from being an OTP and thinking well how
do I fit this into a gem server does
that make sense so one of the biggest
paradigm shifts for me which was going
from working with objects to processes
and so there are a few reasons for that
so first of all Erlang applications tend
to scope themselves or talk about
themselves in terms of lots and lots of
concurrent processes whereas we don't
say in Ruby or Python oh I'm going to
create a million little objects and just
use them all at the same time like if
you did that someone would say well it
doesn't sound like a very good design
and it sounds like it might slow down or
crash your program so when it was first
suggested that I use a single process
for every word I felt like well that's
really wasteful like a word is tiny why
would you use a whole process for it but
and that's the beauty of it is a process
is meant to just do in a small
individual chunk of work and you can
think of it and I don't know if this
stands or not but you can think of it in
a way like a piece of a for loop
in that it starts with some state it
executes sat ask and then it exits but
it doesn't then unless it's supervised
explicitly to start again it's it's just
done its work and gone another
difference in Erlang or with processes
they were often explicitly managed with
supervisors whereas in the Ruby land we
didn't have that and we have patterns
for creating objects you have the
factory pattern etc but you don't have
this idea of of lifecycle then to me
Erlang processes have this very organic
living breathing feeling to them they
feel more like cells than like than like
cars and this this is a screen from an
oo training video and it's obviously
basic but everybody's seen something
like this right like we everybody's been
introduced to oo in this manner at some
point which is visualizations for
object-oriented programming tend to be
very physical object focused like you
have a thing and the thing has facts
about it and the thing tends to be
something that you recognize from your
world like a car or a refrigerator
whereas this this diagram it's a little
hard to see because it's dark but this
is a screenshot from a video walking
through an airline visualize visualizer
and you don't see things here you see
relationships and state and so it's just
a different sort of conceptual entry
point
and interestingly just because we're
taught object-oriented programming by
learning how to model cars and
refrigerators the corner of the term had
a much different idea in mind and when
you watch this this keynote there are so
many things he says in it that feel to
me like oh my god you're describing
Erlang like for example he talks he
first says he wishes he had used the
term process-oriented instead of
object-oriented which right away is
super interesting and he says Westerners
focus so much on nouns and the Japanese
have a word which is ma ma that
represents the space in between things
he says he thinks of objects as like
biological cells or individual computers
on a network and they're only able to
communicate with messages right it
sounds sort of familiar he says every
object is a virtual server server with
its own URL and IP address again very
similar so it was a super fascinating
but even if you can argue that Erlang is
like the lost oo it's really not how we
were trained on it and mostly how we
work on it what one of the hardest
things for me as I'm just gonna say oo
programmer to think about inner language
state and it really threw me for a loop
because I think in reflecting in oo
state the concept of state is so baked
into the entities that we model that I
don't think of it as its own entity like
you have a car your car is blue it just
is it just is blue and even the way that
you access it in the code usually like
car color it just feels like there's not
a lot of lines between the entity and
its state and suddenly Erlang you have
that there are no instance variables no
accessors and you have this thing called
state or new state which is the internal
state of your gen server process that
just gets passed around and I'm actually
embarrassed to admit it took me a really
long time before I was like oh wait I
don't have to call it state like I can
call it
it was so foreign to me and it's like
our just cause it's just the thing it's
searchable it's just the thing it's the
data but it was so different um you know
shared state can be a problem in hopes
but I was trying to come up with
metaphors just to help myself think
about like what's the difference between
states in functional and this functional
programming language and state and
object-oriented languages and one of the
things I felt like was that state was
kind of like a baton in a relay race
that a process is running with itself
and maybe the baton changes every time
like now it's on fire now it has a bird
or whatever but it's just like it gets
passed along and you can think of an
individual process as a state machine
right and every time it does something
it has a new state or it's state is
unchanged and then it just waits for the
next event but it's basically this
passing the cycling of state which is
intrinsically different from just being
something again like a blue car one
other metaphor that helped me was
thinking about state as a backpack for
from the perspective of an individual
process it's it's something different
than itself that it carries along with
it these they don't share their
backpacks they each have their own yeah
their child processes oh my god that's
awesome thank you I got so close
three small process he's like Oh
beautiful thank you Wow oh my god I love
that
anyway it's again the distinction
between being something and having
access to something or carrying
something around and well from the
outside it may have the same effect if
you're working with the programmer is a
working with the program as a developer
it's really it was a big paradigm shift
and it was a stumbling block for me so
yeah basically thinking in Erlang to me
had a lot to do with decoupling like
decoupling State for methods decoupling
processes from each other and then
finding clean ways they can communicate
decoupling the scaling of an individual
process from the scaling of an
application at large and decentralized
data and so spring so anyway I just
where do I want to go oh five more
minutes okay so we're almost up so for
what I'd like to do with this project is
build it up so that it can show all of
the Four Quartets which is hard because
it's like 60 pages but there's a lot of
word work to do for that as I said
earlier the one word at a time it's slow
there's a way on Twitter that you can
search for multiple words at a time but
it's hard it adds a lot of complexity
because the words don't necessarily come
in in sequence and you don't want that
so I took a stab at building a
multi-term search with some linked
processes but a lot of challenges that
come up it's like when do you know if a
word is lost like if a word is found can
you display it because what if you found
word eight but you haven't found word
three like then what do you do so this
is a work in progress I'm looking trying
to figure out how to use these linked
processes versus supervision trees etc
but I haven't figured it out yet I'm
excited to be here with so many greater
land people to get their input and sort
of that wraps it up and summary I would
say Erlang is awesome I've come to love
it I find it super beautiful it's helped
me shape a lot of ways of thinking and I
feel really lucky have a specific
project that's driving me to like well
if I want to do this feature I have to
figure it out so that's it I feel very
honored to be here speaking at this
conference with people and thank you so
much
and this is where the poem got to yeah
mm-hmm yeah I think I do I don't have a
desire to switch but at this point it
would seem silly to not check it out
like when at the beginning I was like no
I don't want to do that and these are my
reasons I think it would start to feel
just as equally weird to say well I
don't want to look at that other thing
her Lange as a fire is that is that your
own coffee
[Laughter]
it does calm the mind yeah oh I did not
but I would say every oh the question is
did I have a list of some favorite lost
words and the answer is I didn't but it
was always facet fascinating to watch
what would come up for a while I would
just do the same poem and always the
same words would be lost like sometimes
words are lost because they timed out
and then two seconds later like here's
the word it's duh but then words like
I'll ant
I ant this or diffident like things that
we just don't say anymore and I think
more than specific words it's realizing
like we don't these words have fallen
out of our language and I could be stuck
here at this point forever cuz nobody's
gonna say that
okay awesome
even if you don't have one yes it is not
not for any philosophical reason just
because it's a bunch of functions on my
laptop
what yeah it could be I mean that would
be something to do with it for sure it
was one of the earlier things I wrote so
it's sort of messy works but it's I
would want to clean it up but it I could
put it out yeah yeah
uh-huh right yeah yeah yeah it is very
subjective oh thank you so much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>