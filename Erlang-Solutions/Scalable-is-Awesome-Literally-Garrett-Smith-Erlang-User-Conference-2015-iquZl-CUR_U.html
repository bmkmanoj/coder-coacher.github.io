<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Scalable is Awesome, Literally! - Garrett Smith - Erlang User Conference 2015 | Coder Coacher - Coaching Coders</title><meta content="Scalable is Awesome, Literally! - Garrett Smith - Erlang User Conference 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Scalable is Awesome, Literally! - Garrett Smith - Erlang User Conference 2015</b></h2><h5 class="post__date">2015-06-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/iquZl-CUR_U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the a flunks session and
we'll have Garrett talking about
scalable it's awesome
yes it is awesome I mean who does not
think that nobody scalable is awesome so
this whole idea started off with me
getting this question all the time
seeing this question all the time
have you ever been in a design session
and said whoa whoa wait a second will
that scale either you asked it or you
were asked that question by someone else
have you ever seen on a mailing list I'm
doing such such such this this that that
bubble of scale you ever seen that so I
see this all the time
and what's interesting is that people I
personally think this is a very
difficult question to answer
we'll see how difficult it is but people
will pile on with like very specific
answers to very very general questions
that always confuses me I'm always sort
of weighing it at some point I can't
resist and this is what I do so I come
in and say okay I know you wanted to
scale but your application doesn't exist
yet so let's not talk about scaling
something that doesn't even exist in
time and space that seems a little
premature why don't you build something
first so that's step one okay now that
you have something you've built it put
in production run at deploy it get some
experience with it so you know you have
this thing that you built and you're
gonna put it into production and then
you're gonna observe it now when you
observe it you're gonna see certain
things you're going to get data you're
going to be in the realm of physics
you'll collect statistics and you can
judge is this performing the way it
should then problems you can fix now
nowhere in this is the word scalable
really the idea doesn't even exist in
this and this is generally the approach
I take every single time and the
response is every single time this oh
thank you for not answering my question
I wanted to know how it was gonna scale
and you kind of blew me off with a sort
of pedantic Oh build it it doesn't exist
I'm not trying to be a jerk here I'm
trying to actually be thoughtful and
help sort of you think about what's
going on before you get into you know
optimizing something that thing probably
should exist but this is not a
satisfying answer it is never a
satisfying answer so it got me thinking
maybe I'm doing something wrong here
maybe I'm taking the wrong approach I'm
kind of viewing this as a technical
question but what if it's not a
technical question what if it's more of
a personal emotional question it's
something that somebody wants wait a
second they're not really asking about
scalability I don't even know what that
word means what I think they want is
something good they want a sense that
they're building something great
something amazing ah now this makes
sense to me and I'm starting to
internalize this is actually a word that
has no meaning whatsoever but it's
generally used when people want to use
this word now this is the one who went
to propose no this is a serious proposal
I want to change the vernacular I want
people to stop using the word scalable I
want you to start using the word awesome
let's just try it out but will it scale
this simple question will it scale let's
replace that but will it be awesome oh
well that's a really really good
question you know no no my sequel will
not be awesome my sequel is my sequel
nobody uses that if that's not awesome
at all so now we can start talking about
really cool technology we bring in new
databases and distribute you know key
value things and distributed this to
street
you know clusters and we could talk
about awesome things and have a lot of
fun because really it's more fun to talk
about awesome that it is scalable so
this is the pepper this is the premise
right if we're gonna use a word that has
no meaning whatsoever or basically what
we mean is we just want to feel good
about what we're doing let's be honest
and say rather than using this sort of
technical mumbo-jumbo
scalable we really want to build awesome
software it's a lot more fun it's more
direct it's more honest and I believe it
addresses the real issue now I'm going
to spend this entire talk or most of
this talk getting into this you think
this is a joke I'm naturally not joking
there's a material impact on society
because of this misconception that we're
building something
awesome but on the auspices of technical
engineering so I want to kind of dispel
that myth okay so I'm gonna break this
down as follows I think there's a myth
of scalability I think we use the word
scalable way too often I don't think we
should use it at all as I've said so I'm
gonna try to establish that I want to
get into why I think we do this because
I think when we understand ourselves our
psychology it'll help us to use the
right terminology it'll help us to get a
perception of what a good understanding
of what we're doing and then probably
most importantly I want to go through
some patterns that I think I would I
would apply in the realm of scalability
so when we're talking about scalability
were often talking about accommodating
changes in load of some type some type
of change some type of Delta usually an
upward Delta so something changes we
want to accommodate that I want to put
some patterns out there but none of the
patterns have anything to do with
scalability traditionally so I'm gonna
call them anti patterns but I think if
we use them we'll end up building
software that is actually awesome it's
really really good and we can actually
measure it and we can we can prove it in
the word scalability just falls out and
instead we could just have fun okay does
that make sense
that's the game plan so let's talk about
the myth of scalability now let me be
clear here
I think that you can define scalability
precisely enough that you can talk about
it but I believe in general maybe not in
general often people are talking about
scalability in a magical sense in the
sense of infinite scalability will this
architecture scale that word will this
architecture scale is not sufficiently
precise to be an actual question it
means you know will this architecture be
good or will it be great nothing scales
infinitely and I'll just I'll just prove
that there's this thing called an outage
it means your your server your software
is not working it fell over you can also
have outages that are our service level
outages where your your blatant C's are
too high your service levels are falling
over so your application is technically
working but it's unacceptable
those are outages as well how did just
happen all the time to everybody
everybody the most scalable web scale
crazy-awesome companies in the world
have had material problems with their
architecture every single
one of them a Twitter's been doing
pretty well for a while now but you can
go back and read the amazing history of
the transformation of their architecture
somehow they powered through it but
there's no infinite property of
scalability where you put something in
place and off it goes
the process that Twitter went through
was very much what I described before
they built it in a Ruby on Rails come on
and Ruby on Rails has got this bad rap
for being something that doesn't scale
twitter came back and said you know what
that's actually not the problem there
the problem is architectural but they
built it they deployed it they observed
and they fixed the problems and they
pushed forward and they have it they
have an application that works is it
scalable it seems to scale it seems to
accommodate or know how much they're
changing it seems to work pretty well I
know that but there is no magical
property of scalability they're saying
with Amazon I mean the great Amazon how
many people here have been affected by
an Amazon AWS outage one way or the
other
yeah you know cloudBees ran their
platform as a service on this I know
intimately every outage that has
happened over the last you know six
years intimately I was there you there's
just some simply no such thing as an
infinite scalable system eBay you can go
on and on and on any one of these
companies have had issues so this is
what I'm saying don't use the word
scalable there are more precise terms to
use I want to get into some of that
stuff so if you doubt any of this go
online and read every company goes
through specific issues in time and
space involving physics and it's words
like latency throughput response time
you know concurrency or if you've
concurrent connections very specific
things that mean specific things
the term scalable is hand-wavy okay it's
gonna be something DIF we want to use a
different word now
all right so nothing scale so let's not
use that word I think we should use the
word awesome but if we're a little bored
with that cuz it's fun and we laugh and
we think you know yes we're gonna build
awesome software then what what's
actually useful and productive here I'm
gonna propose a word that has very very
little sex appeal
but I think is a very good word if we
really want to build good software I
think we should be using this word this
is the word
we should be considering suitability
what do we need to do and understand
that very precisely and then go do that
that's an engineering discipline that is
not in the realm of Awesome that is not
in the realm of like let's feel great
about what we're doing unless you feel
great I feel great about this but it's
not building magic it's not building
something out there that's amazing and
cool I believe you can get amazing cool
things with this and we'll take a look
at how that can happen
so speaking of amazing cool this guy
fastest land animal on earth the cheetah
we love this guy this guy's fast is
amazing it's great to watch pushes the
boundaries of physics I mean the
architecture of this animal it starts to
you know top off the meter you can't
really go faster with this particular
design but the reason the cheaters
cheetahs fast is not because the cheetah
wants to be awesome
the cheetah knows it's awesome he's
comfortable with that he's cool any but
he doesn't I was that aspiring to be the
cool kid he's fast because these guys
are fast antelopes are fast and the
antelope in the end the cheetah got into
an arms race in an evolutionary sense
one gets a little faster the other has
to match otherwise it doesn't exist we
wouldn't be talking about either of
these if one had overwhelmed the other
and probably they both would have gone
extinct this arms race is sort of a has
an equilibrium to it as it as it goes up
but its suitability that's driving this
this this particular this particular
characteristic of the Cheetahs speed now
this is a very fast food this is a very
slow food right so if your food source
isn't an antelope but it's a blackberry
you don't have to be fast at all in fact
if you want to compare the relative
fastness of a predator to prey the
turtle is literally infinitely faster
than the cheetah that's fast profoundly
fast
of course the turtle is subject to
predation right it's slow so other
creatures can come by and gobble it up
so what's its feature
what's its secret sauce what what do you
think it's a shell that's that's right
so you have stuff like this going on
this is an actual
is an actual event this is not from
Photoshop sure this is an alligator
who's trying to make a meal of this guy
and note note the the arrogance of
usually usually a turtle who were just
like retract I would retract I'd be like
that I'm not going anywhere near those
fangs but this guy's like whatever this
is great he's just hanging out and what
happened here this is real 15 minutes of
this and the alligator just gave up and
left so you know we're talking about
features that are necessary for survival
and I like to apply this to software so
the term suitable actually deals with
precise things that we need to do Joe
Armstrong you you may have heard of him
this is language out of Sweden which is
really cool is it said this he's no such
thing as fast and you'll see this he'll
he'll he'll pipe into these lists if
anyone asked about speed Joe will say
this every time and it's great we should
all be saying this is no such thing as
fast only fast enough and that's he
should be saying it for another 25 and
and beyond this is an axiom this is
something we should be living and
breathing I realized that I'm preaching
too perhaps to the choir here but keep
in mind this is recorded so others
others will see this I'm gonna propose
some some patterns that I hope will be
challenging to you I know that many of
you are not obsessed with speed but also
I know that many of you did reply to
that post on the list when somebody
asked about Willis architecture scale
and you were proposing react Corps and
you were proposing this thing and that
thing and being very specific and I'm
just saying you know maybe maybe maybe
maybe don't do that and just rephrase
the question saying what you really want
is awesome if you have an actual problem
you know we're happy to discuss that so
we have an this this fixation on on
optimization and you can kind of see it
with the cheetah you can kind of see it
there we like the cheetah we like the
Cheetahs as fast we've been pressed by
the fastest animal on earth and we have
games that that measure human
optimization you know how far can
somebody throw the javelin how far can
somebody you know throw a shot put you
know a rock why you know why is this an
event well of course it's an event
because
were human we're programmed to to
capture and kill prey so we can eat and
to escape prey and so you have here the
javelin here he is
you have the shotput guy up here these
are all part of our DNA it's part of our
programming I mean we are by nature
directed toward speed height strength
agility so our games measure that and
you think it's just gonna because we're
engineers it's gonna stop at software
that's psychology that programming that
mandate to be faster stronger better is
going right into our designs right into
our whiteboard discussions you know you
could be a little critical and say there
might be some egos involved but I prefer
to say it's programming it's the way we
are built I'm not even get into mate
selection behavior here because that's a
completely different topic and but
there's that I think possibly going on
here there's a lot of things that have
nothing to do with software that drive
our engineering decision so what I want
to do here is sort of with this in mind
with our new self-awareness we now are
you know enlightened individuals and we
know that we wanted that just you know
distributed whatever because we you know
we're doing this for whatever reason we
can back off of that and say okay what
are we actually doing here what is
necessary in this case to be suitable
think of the turtle not very fast but
cool in the in the jaws of that
alligator and that's cool that's awesome
so I mean there's a consolation there so
what I wanna do here is talk about some
what I call I'm calling here
anti-pattern so I'm not leavin sure what
an anti-pattern is I like the name
though it sounds kind of revolutionary
but what I mean here by anti-pattern is
none of these actually address
scalability so but I believe they're
important and I believe that we should
do them and if we do them we will be
taking steps toward this goal of
suitability we'll be taking away step
steps away from this concept of awesome
let's be awesome let's you know don't
get me wrong when we're in those design
sessions let's have some fun let's dream
but let's at least be aware that when we
talk about magic and we talked about
characteristics that we don't strictly
need we're engaged in that programming
that's fine
just be aware of it just be aware and
then me laughs and then move on to some
interesting problems okay so I'm gonna
summarize these and I'm gonna get into
each one of them so not a problem build
that naive dependencies bad think system
and physics not magic you were waiting
for some natural substance I think this
is gonna be substantive and takes us
away from this I think silliness about
fixation on these arbitrary
characteristics of speed strength
agility etc okay so every problem has at
least one solution every problem has at
least one solution that one solution is
this you solve a problem by deeming the
problem not a problem there's a few
Snickers here when I do that at work
there's always somebody laughing
somebody always thinks I'm making a joke
there I'm not making a joke at all every
problem needs to be vetted before you go
solving it and one of the ways you can
solve a problem is to vet the problem
and say you know what not just to
forcefully say it but you know discover
you know verify do we need to be doing
this many of the problems with
performance have to do with going out
and solving problems that actually
aren't problems if you doubt that look
for it take a look look to say how many
problems are being solved here that are
just generation you know being generated
by other things that we did like a norm
for example you know object relational
mapper a map mapping like how does this
thing you if there's no objects right
there's no arm the worms are a bad idea
in the first place but if there's no
objects right so we have you know a sort
of a non solution I you know maybe being
a little hard on objects here and I
shouldn't be but this is an example an
example you know there are things that
come up in our design session so we can
just deem not a problem and then move on
to something that's interesting what
this does is it gives us the ability to
focus on things that are actually
important in that process of vetting
problems before we go blindly into
solving them is incredibly important I
think it's actually more important than
the solutions once you have a very
well-defined precise problem the
solutions tend to be self-evident and
trivial sorry functional programming at
the experience that all
I'm okay there's not a problem there's
not a problem right now many people make
the mistake of trying to solve problems
that they think they might have down the
road today push those off and focus on
something that you need to do okay build
a naive that's the next pattern here so
build a naive looks like this I call it
the unclever approach take obvious line
of sight decisions so don't be
speculative don't imagine too much
imagine a little bit and this line of
sight this is an something that's
obvious to do so you take existing tools
existing know-how existing solutions and
you apply it as directly as you can you
will find that this usually works it's
line of sight almost by definition if
it's obvious in line of sight it should
work you're saying that it's gonna work
so it usually works and I found that it
often works forever these little
unclever not imaginative approaches you
think are never ever you know gonna
survive more than a few weeks end up
surviving forever because you
misunderstood the problem and we do that
all the time it's fine it's not a
judgment it's not a bad thing we just do
it's difficult to see in the future I
know exactly what you have to solve so
when you build something with naivety so
I'm not gonna be too clever with this
you give yourself the advantage without
spending a lot of money to learn from
experience and get to the actual problem
so that's anti-pattern number two
building naively I see this not
implemented a lot people don't like this
it doesn't feel good to do something it
feels dirty it's not the right way there
somehow a morality associated with what
we do and being suitable just isn't good
enough right it has to it has to survive
it has to be you know scalable it has to
be evolvable it has to be this that and
the other naive direct approaches tend
to get you into evolutionary position
without over speculation all right so if
you doubt this or if you need to make
this argument a lot of cases this would
be like you know do we speculate on do
we speculate invest in some big thing do
we bring her laying into our
organization nobody knows her laying
should we bring us in check this out
I think these things are I'm gonna give
you two points and then a conclusion
from that see where we get all right I
this is this is this is a law cost of
work is almost always underestimated
alright so how many people are really
rated estimating well you know we can be
pretty good but I always always a
hundred percent of the time we'll
underestimate the work I just do I don't
I don't make any you know pretense here
I'm not gonna fake it I'm just gonna say
I honestly believe it's gonna take this
long and it never - it always takes
longer so this is certainly my case true
we also tend to overestimate the value
whose optimistic you optimize you you're
optimistic on the cost and you're
optimistic on the value so these two
things work against efficiency and
software development and they make
software development very expensive all
right so one of the ways you can battle
that is this build at naive approach
which is very simple keep work as small
as possible and then improve
incrementally because what you want is
you want data to validate what your
assumptions are your optimistic
projections and the way you do that is
drive the complete drive of the unit of
work down to something as small as
possible so that is obvious direct line
of sight work nothing big nothing
speculative so that's billet naive okay
dependencies bad lately I've been really
railing against the pendants ease and
some people coming up to me and saying
what you know what's it what's your deal
with the pendants ease why do you hate
them so much you seem kind of fixated on
this I've been hurt badly by
dependencies and when you're hurt badly
by things you tend to not like them I
guess that's probably the most simple
and direct and honest approach I give an
example so this was cloudBees one
morning all of a sudden we were we got a
lot of tickets we had a lot of issues
open literally every single application
deployment so this this is a cloud-based
platform as-a-service where we're
hosting applications and providing a
runtime environment literally every
single application deployment deployment
was failing a hundred percent of them
where there was no code change
there was no environmental change all of
our measurements and statistics and and
and monitoring were fine nothing had
changed literally nothing had changed
it's like how on earth is this down well
it took a little while not too long but
we were tracked it down to an XML file
so every application had an XML
descriptor of
of metadata associated with them so this
guy you have to look in here has this
thing here now I don't really get into
the headspace of XML too much so I step
back from this I don't want to get into
that too too deeply because I think it's
it's a little disturbing but it's got
this thing called a schema location and
what it's doing here is it's referencing
an x SD file which would of course
provide the schema for this XML and then
you could use that to validate the XML
and lo and behold we were using a
validating parser who did look at this
and said ah I'm gonna go grab this thing
so guess what happened a little server
called Java dot Sun comm was down for
like a day and it completely destroyed
everything that we were doing wow that's
a really bad dependency that's horrible
well we removed it by deleting that line
not hard at all or you could turn off
the validation on the parser so that was
an easy fix once we identified it but
this is an an example of millions upon
millions of examples were an innocent
dependency can just tank your system
that's just one very obvious one you
have dependencies that have interactions
with one another dependencies tend to
come with other dependencies when you
bring libraries in or other software so
you're not bringing a dependency and
you're bringing in a tree of
dependencies and all of these things
start to fall out of your control and I
start to erode the stability of your
system these are essentially moving
parts they're not literally moving but
they represent moving parts to your
system and we know about reliability you
want to drive moving parts out of a
system to make it more reliable well
dependencies are moving parts and they
come with trees of more moving parts
they're very very very costly so I have
a I guess you'd call it a jihad I I want
I want to fight dependencies I want to
eradicate them you can't of course you
you you you eventually have to bring in
something I'm if you are blank which if
you have a computer if you don't have
power there's a certain dependencies
that we concede but for the most part
make do of what you have
fight each dependency until it
overwhelms you there are cases where you
have to bring something in but just
fight against it just realize that I
don't want this thing alright this is
now it's like a pet right it looks cute
you know
you think it's gonna be great but then
you get it and you realize it's and this
isn't working out or this is a lot worse
than I thought it was gonna be so fine
you we all get pets at some point we're
always persuaded to get the pet yeah
great
got the pet but just minimize it and
fight against it until you have
absolutely no option and then when
forced to do it bitterly I want like a
grudge holding you keep your eye on that
I told you that was gonna hurt us I told
you so you usually get you get your
revenge that way or you forget about it
because it's fine either way but have at
that grudge that that chip on your
shoulder okay well this is an Erlang
group and I probably don't have to go
into too much detail here but think
system I like to talk about this because
using the word system a lot is useful
especially I mean it's useful for
ourselves but it's very very important
when we're working with other people who
are used to what I would describe is
software environments that specialize in
creating large hair balls or monolithic
you know applications there are some
that really specialize in that they
really want you to build an incredibly
intertwine set of dependencies that
called application share a you know
common heap and are very very difficult
that's you know a certain size to keep
under control certain environments
encourage that and as a result there's
are there are certain mindsets out there
that are comfortable with monoliths
comfortable with large things that do
lots and lots and lots of unrelated
things you know because it's one app so
a system is this I like to call in
dependencies so it's sort of the
opposite of basically what we're talking
about it creating boundaries in time and
space so what I mean by time in space
there is it's not so much code
abstractions although there's a
correspondence there what I'm talking
about our actual independent entities
running in time and space and that could
be something like a core a spindle a
network a node but it could also be a
virtual machine for example that
isolates processes right it's not
physically separate but there are
guarantees made by the machine that
create things in separate independent
bounded areas when you think this way
you tend to believe you tend to start to
see things as follows
when you have a system view and Erling
and I think is probably unique in this
respect because it is so system oriented
it's called a system right when you
start the VM it's called a system system
in it the init subsystem within Erlang
is modeled after the in it scheme in an
operating system so you feel like you're
booting an operating system when you run
a VM your application starts to look
like you know little you know your app
as actually made up of little apps just
like an operating system so we're very
used to thinking in terms of system here
the rest of the world is not what you
get when you think of systems as this
it's very easy to be focused these other
points are making a beam you know be
naive build it directly avoid
dependencies in a system view you have
the actual mechanism to do that so I can
just say Oh take a knurling process as
an example I have a particular task it
needs to do this it's one thing and one
thing only single threaded boom I'm
gonna create a process that does that we
do that and live and breathe that but so
does this admins or DevOps people what
they call them today all right they do
that all the time it's a systems view
the more we can let systems view
permeate our our architectures you will
see the more evolvable the more tooling
we have the less dependencies we have we
may have dependencies but they tend to
be isolated and independent we manage
dependencies system view gives us all of
this stuff is this controversial I mean
come in I know we all know this but the
cloud right I mean the cloud that's
magic it's part of our vernacular it's
part of what we do we use cloud api's we
use like HTTP and JSON all the time now
that's Matt that's essentially magic we
don't know what's going on there so I
mean as much as this is sort of
self-evident to us
it's where a lot of difficult sort of
so-called scalability issues go we start
to abandoned our respective physics so I
have two quick points here I can't cover
all of physics in you know I've got 10
minutes here so III don't even know how
love is exfol couple areas that I think
would be helpful
to get us out of the cloud get our head
out of the cloud what I mean by that is
get our head out of like abstractions
that don't actually have measurable
tangible qualities to them the way we
used to have that back in the day when
we had you know computers and whatnot
okay so here's one thing that's
interesting this is a chart of Layton
sees that it has a number of authors it
actually has accumulated over over a
period of time and these are Layton sees
measured in nanoseconds and you start
with you a very very fast operation
which is a level one cache reference of
half a nanosecond all the way down to
you know 150 million nanoseconds to send
a packet from California to Netherlands
roundtrip what's interesting about this
is when you're talking about suitability
the suitability is real I mean it you
know to do something again and time in
space for customers who are real and
expect you know you know millisecond
latency z-- you have to go solve
difficult problems at times and if you
don't if you're not generally familiar
with these qualities of physics because
this is physics here something like this
is helpful it's helpful for me you know
every now and then I should just look at
this unfortunately I don't have access
to most of these things because we tend
to run these in virtualized environments
where these are all been interesting to
see some of these you know performance
numbers in virtualized environments you
know we can go buy an SSD but we tend
not to run those ourselves and you know
many of us used to but most I think most
of us are running in in cloud
environments so this takes us those take
us away from physics so an investment in
understanding what's going on and of
course of course of course when you're
actually solving real problems you have
to get into you have to get into these
layers and measure things so that goes
without saying I'm just talking about
let's get reacquainted with what used to
be sort of computer science it certainly
isn't gonna hurt us and I think what
would be fun is if everyone were to have
some of these things there's a whole
ecosystem of these little devices they
cost like you know anywhere from 20 to
250 dollars maybe a little bit more so
you can buy them and just have fun with
them what's cool about these is they
tend to be a lower CPU lower lower clock
rate CPUs they tend to have unusual CPUs
we saw
yesterday a coprocessor that was highly
parallelized that could be exploited
they have GPUs they have things that are
existing in time and space and they
don't necessarily have to have anything
to do with your day job it's just fun
but it reoccurs us with electrons which
I think as computer scientists is quite
fun so buy these and then go build this
this is on display over here from from
relying solutions but these are Ray's
raspberry PI's and a Lego thing and I
don't know what it does but it looks
awesome and we should just go build
stuff like that why not right so this
will react Wayne to us with with physics
it's fun I've actually taken up
soldering because I just feel like I was
you know I repaired my phone
I took a microphone from one dead
motherboard I was like well I can't
believe I just did that it's like actual
actual stuff okay all right so we have
some time for questions but I wanna I
want to just kind of get into like a
preach mode here a little bit and then
I'll stop and then we can open this up
for for some discussion so we talked
about this word how many people will
actually do this I'm going to I'm gonna
start calling it ha Sam I just am why
not there's no harm in it you're not
being rude to people maybe a little bit
maybe a little bit but I mean there's
good reason I think we'll see if it
takes off I don't I don't know maybe it
needs a video I don't I don't know well
we'll see how we can see if we can get
this to take off all right so that's fun
and that's funny and it's a little bit
of a joke and it's a little bit serious
but really what is important here is is
this guy so I would like us to to
reframe our thinking about what we need
to build and I know you do that but I
know you also don't do that I know I
don't do that it's difficult at times
because we want to jump into something
that that javelin the shot put the
cheetah all of these optimization
fixations that were programmed to do but
there's one word here that I haven't
mentioned that underlies a lot of this
and I want to spend a little bit of time
on that and that's this word evolvable
part of the premise here part of why I'm
pushing back on scalable designs scale
architecture since it's not just because
the word is completely meaningless and
we shouldn't use it and so that we
should use awesome there's that but the
fact of the matter is that we can design
as much as we want to physics is going
to come and overwhelm something we
didn't see and we have to be able to
react to that otherwise we're not going
to exist will cease to exist this is
evolution we have to adapt to
evolutionary pressure we have to adapt
to the ecosystem and it's just very very
hard to predict that so when I see
elaborate architecture is a lot of
design initiative effort going into
something upfront I just get kind of
nervous about it because I'm thinking
you know you're gonna get all this
exactly right you're gonna have exactly
the architecture that you you you dreamt
of that you feel great about that's
incredibly awesome that's the best on
the block you can brag about to all your
friends but when you put that thing into
production
I guarantee something is gonna come by
that you did not expect and it's going
to sideswipe you that could be one thing
it could be 10 things but it's gonna
happen so knowing that let's under
invest in our initial architecture and
just get things going but in order to do
that we have to bank on evolution we
have to bank on our ability to change
and adapt to things that we didn't
anticipate so yes that involves walls
physics and involves you know marshaling
and harnessing and and and stewarding
dependencies so that our systems are as
simple as they possibly can be so when
we come in to have to change something
and evolve something and modify it we
can approach it with sense with with
some common sense we can approach it
logically it's just like functional
programming you spent time decomposing a
program into you know sort of
symbolically
what it is you mean to do when you come
back to try to make changes to that it's
very very simple you have a roadmap to
to make point changes based on your
based on the the changed environment
that's true a functional programming but
it's also true systems I've seen this if
you have an in sort of a system of
independent components that are small
and focused I mean this is what micro
services this is SOA whatever you want
to call it you
these are general principles of reality
right you have stuff that can evolve and
that's the key to anything that's gonna
scale scale right
it's a vulva Lucien if you look at the
story of any of the big companies one
thing this this is you know something
I've spent some time with one thing is
interesting what comes out of it isn't
an architecture it's an internal culture
around different practices in the
organization so the organization might
say and we're just gonna put this Ruby
on Rails app out and then we get crushed
with demand that we'd never expected and
now we have to evolve we've got we've
got a you know chip away at certain
problems and they realize okay to do
that we need to get numbers we need to
measure so you tend to see in
organizations that have scaled
architectures scale you know they big
robust tall fast architectures they tend
to do a lot of measurement they tend to
be very scientific they tend to know
when something is starting to get slower
and identify okay this is a this is a
problem they can identify it six months
before it happens I guess they can start
to see okay this latency is starting to
go up here all right well let's take a
look at that now and figure out what's
going on so measurement becomes a
central part of of these environments
but it's a process that they bet on that
their company in their organization
technical organization is committed to
so evolving always vetting you've you
know vet design decisions certainly you
can get all of your experienced people
in a room talk about something before
you build it that's just as I'm not
suggesting you'd be random here but what
I am suggesting is that scalable
architecture is not a goal right we
should be focused on getting something
started and evolving it and using some
of these anti patterns I think will will
contribute to ultimately so-called
scaled architectures but really what
we're talking about is awesome software
because that's what we want okay so with
that we have a few minutes for some
discussion
hey there my name is Thomas with what
the what oh oh yeah these these or this
one okay i well
let's slowly let's do an exercise here
right what's what's the objective here
we're gonna change the word will it will
it be awesome i think it is awesome
yes absolutely it worked it worked that
time so that's good so far yeah yeah
yeah yeah so the observation is this
fitness stander the survival of the
fittest
so there's a there's a I'm using the
word suitable the observation is that
this this sort of evolutionary
environment is survival of the fittest
and there is a fitness test but there
are also inefficiencies in nature nature
doesn't arbitrarily optimize so you
could actually have an animal or an
individual that's quite a bit more fit
quite a bit faster but it's pointless
and useless in the ecosystem so that
gets pruned back you know there were
probably some really fast Turtles that
we know that just didn't get the pass
their genes on because you know it
doesn't matter
and maybe the females aren't interested
in fast turtles I don't know you talked
about you talked about picking simple
solutions instead of over engineering
that's a good approach but it kind of
requires the willingness to reconsider
them later on and
possibly scrap them when it turns out
they were well I did use the word
evolution so that kind of covers
everything so yes I did no you're right
so I didn't I didn't hit that and I will
hit that now so when you make it when
you take an AI naive decision you're
doing so with the expectation that that
won't work at some point I should have
had that as a point but that indeed is a
point when you make a decision like that
the reason it's naive the reason it's
the unclever approach is because you
just don't think about it that much and
you just go do it with the expectation
that it probably at some point won't
work but if you have an evolutionary
evolvable system or system approach
that's really not a problem in fact that
happens all the time you go down a
particular path you experiment with it
and it works for a while and then it
stops working but that's true of
anything that's certainly true of your
elaborate architecture it absolutely is
it just costs a lot less and it will get
you to the real problem quite a bit
quicker than the elaborate architecture
yeah we have to be successful in the
right area so yeah so it's not actually
survival of the fittest I mean this is
sort of a misnomer there's all sorts of
inefficiencies that that I mean look at
the peacock feathers for example this
has nothing to do with fitness for
traditional survival purposes it's a
simple Caprice of the peahen the peahen
likes these feathers Why ask the peahen
you know they got into an arms race
where you know that you'll see these
things if bizarre be patterned in nature
that have really they've got their
liabilities the peacock feathers a
liability to the peacock but it gets his
it gets the attention of the peahen of
course that's how he reproduces that's
how his genes move on so I don't get
into too much of that but they're there
so this is the this is the mate
selection programming that I was talking
about but in general we want to optimize
in the right area it's it's nature's
very specific and channeling
optimization as to what is suit what is
it required not what is optimal optimal
it's like a moral judgment and that
doesn't exist in nature I think we have
one more question
your time for one one motion one last
question one last question okay so I
would bet some money that you're looking
at a monolithic architecture there I bet
you know almost every time you're like
oh my goodness what are we going to do
here well why would you say that if it's
an evolving system and it's a system of
small independent components you really
your problems going to be one in a few
areas and then it becomes fairly easy
you you you tweak these areas and
improve these areas but when you have us
you have a case where you're overwhelmed
by the pathology of a system that's a
monolithic design and I would I would
just point to the dinosaurs and the
designs of dinosaurs are an amazingly
successful organism species over
billions of years obviously but they
went extinct at a certain point and
sometimes these systems just need to be
shot in the head and redone I'm serious
okay unfortunately we have to stop there
so let's thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>