<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Basic Erlang I by Simon Thompson | 1/13 of Erlang Express Course | Coder Coacher - Coaching Coders</title><meta content="Basic Erlang I by Simon Thompson | 1/13 of Erlang Express Course - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Basic Erlang I by Simon Thompson | 1/13 of Erlang Express Course</b></h2><h5 class="post__date">2017-09-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aEyQcZg-Njs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so what I'm going to do is cover the
first few the basic aspect of our line
arm so what we'll do in the basic
outline one is cover data types
variables some rather more complex data
structures and finish off by covering
pattern matching so I'm going to start
off talking about the basic Erlang data
types now in a way that's not very much
surprise to start with about the data
types integers in analyte are pretty
much like integers in any other language
except for a few a few differences you
were allowed to use different based
representations for numbers so if you
use the base followed by the hash
character and then the value in that
base that will represent a number in an
arbitrary base between 2 and 16 it's
possible to write down the integer which
is the ASCII value for a character by
proceeding that character with the
dollar symbol and I guess most
importantly about integers and perhaps
the biggest difference from other
languages is the fact that integers are
by default as large as you like so once
an integer value exceeds a certain a
certain amount certain size they're
converted to big numbers
so it's possible there's no worry about
overflow and so on you can deal with
arbitrary precision within integers okay
what I'll do now is just demonstrate you
can see some examples on the slide what
I'll do is I'll show you how you
evaluate numbers in the line shell so
here we see a UNIX command prompt we
type er L in order to invoke the Erlang
shell you can tell it to now Erlang
shell because it's saying each shell and
also you can see the prompt has changed
so here you see a number followed by a
greater than symbol and that's the
number of the expression that are being
typed so the pattern for the Erlang
shell is that you type an expression
followed by . and you get back the value
of that expression so for example if we
type in 2 followed by . we get the
answer - if we type in 3 + 4 for the
Bayeux . we get the answer 7
and you can see that the prompt are
changing we're now on the third
expression if you fail to remember to
type a full stop at the end you type
three plus four followed by carriage
return you can see that we are able to
continue input length to that expression
with this carries on until you type a
full stop
so there we've got three plus four plus
five so an input an expression can be
input over multiple lines now you can
see here we've seen some simple integers
we can use you can see an example of a
different base we've got the number one
101 base two and that is 13 because it's
eight plus four plus one and you can see
that we get the character code for a
character by proceeding that character
with dollar there you see character code
for dollar you see the character code
for a so you can see we have these these
operations we have the standard
operations you'd expect
we've got multiplication on integers
we've got division oh sorry we've got
subtraction all integers and we've got
division on integers that's whole number
division and that's whole number
remainder okay so that's that's is the
end of the demonstration of the Erlang
shell for integers floats in Erlang
follow the I Triple E and five for
standard so they're represented as
double representation they're not
tremendously efficient initially because
you want to get real-time performance
from from numerical calculations the
advice is to use integers you can see
that the representations are the
standard representations decimal point
or you can have
and exponent now I'll show you just a
couple of examples of calculating with
floating-point numbers in the young
shell you'll see in the Erlang shell
that we can do similar things to the
things we can do with integers we've got
2 plus 4 times 3.1 we can represent
numbers by exponent and mantissa so you
can see that is 2.1 times 1,000 and we
do have a division operator so 2.3
divided by 2 is given by the division
symbol there if we write 2.3 like 2
divided by 1.3 you can see sorry
remembering always to put a full-stop
write an expression you can see in both
of those cases that the the interviews
there is converted to a float before the
division takes place on the other hand
if we write something like 2.3 rm2 we'll
get an error there we're getting a
typical it's the first example of an
error being being produced by evaluating
expression and did the error is that
there is a bad argument this is a
standard Erlang error bad aaaghhh bad
argument in arithmetic expression it's
saying it's the operator Ram called as
2.3 round 2 it's not pointing could
perhaps point to the fact that the the
problem there is is putting a
floating-point number as an argument to
an integer operation okay I mean that
concludes what I wanted to say about
floating point numbers in Erlang so
let's move on now to the next data type
so the third primitive data type in
Erlang is the atom and a term is a
constant literal it simply stands for
itself there are two ways of writing
atoms the simplest is to write something
that begins with a lower case letter if
you write start with a lower case letter
you can use any other letters
integers or underscore within the utter
so you can see how much like this person
but there's also start underscore with
underscore etc the other form of atom is
written inside single quotes and within
single quotes any character at all can
be used so that is a much more general
form of atom but you must remember to
write that within single quotes so these
are similar to static finals in Java
there are things that just can't be do I
mean static finest knowledge I do so did
these data types are similar to
enumerated types in other programming
languages okay and I think I don't need
to do a demonstration that they in the
shell to show you how these things are
produced so in our line there are two
ways of forming compound data there are
tuples and lists and they have a lot a
number of similarities they are both
heterogeneous they can contain data from
different data types in all combined
into this single composite item but they
have some differences we'll start by
looking at tuples
so tuples are delimited by curly
brackets and items are separated by
commas in the examples you can see on
the slide we have a data type beginning
on two three followed by the atom BCD so
i contains a number under data it can
consist also of atoms ii or indeed other
tuples so in the fourth example there
you can see that we have a the second
item is itself a tuple whose first item
is an atom and second item is a number
and the third item is
the third example is a very important
one because it shows an important than
conventional idiom that you represent
the type that add a tuple has by using
the the first field to tag the data so
you're saying that this is a
representation of a person by having
person in the first field and then the
fields that follow in this case are
atoms for Joe and Armstrong but you
might record coordinates by having
something like the first part easier
secant and then followed by by two
numbers which represent positions on a
so this is a jet very general form of
data representation simple as it is a
fixed format so the example some of the
things are different in other languages
would be records in Pascal or
language the reason that it says tuples
are used to store fixed number of items
is the fact that when you analyze a
couple in Erlangen we'll see this later
on all you can do is pull out particular
fields it's not possible to decompose a
couple into sub tuples and that's the
crucial difference between tuples and
lists
so a list is used to store items which
come from different data types just as
is the case for tuples but it says
they're used to store a variable number
of items the way to interpret that I
think is to see that a list is built up
by adding items to a smaller list so a
list can be decomposed into its head its
first element and the remainder of the
list so in that sense Alisa T's is
dynamically sized now the way that
strings are represented in our link is
that they are simply lists of ASCII
values listed eliminated delimited with
listen eliminated lists are delimited
with square brackets in contrast to
tuples which have curly brackets but
again the elements are separated by
commas now I think the crucial thing
about here we see a number of examples
of Lists again a list can contain data
from different types it can contain
other list elements it can contain
tuples as elements so lists contain it
can contain lists or sub lists as
elements tuples can contain lists so the
types can be arbitrarily much now what I
think I'll do is showing you a few
examples in the shell right moving back
to the shell let's have a look at a few
examples first of all let's see an
example of a tuple here's a couple
abc123
here's a list ABC 2 3 you can see those
both evaluate to themselves we can we
can ask some different questions of
all right but here we're seeing an
example of applying a function we'll see
an awful lot of functions in the course
of this lectures of what we're seeing
here is a simple example of a function
applied to a list and that's saying that
the length of the list a number of
elements are on the list is two we can
also apply that to a list like this and
you can see here the parentheses are
matching there as I type now think of
this list is two that's because the list
itself contains two items the first is a
and an integer one two three and second
is itself a lists of two elements in the
list one a number the other a list now
if I type a list like this of numbers
I've got four numbers in it what we
expect to see as a result is it's just
that list being echoed what in fact we
see back is a string because strings are
represented in lists simply as as the
servant is in strings are represented in
Erlang simply as lists of integers and
so you see it as a string because that's
how it's the Erlang she'll choose
chooses to to echo that list back to you
I type this what was the feedback is a
and I can ask for the length one of
these strings
thanks for as you would expect okay
now I think that I'll just I'll stop for
now talk a few more talk a bit more
about how this are constructed and then
come back to demonstrate a few more
aspects of Lists so the crucial thing is
to think about how lists are constructed
that Lister constructed a what's called
a recursive data type the list is built
up in two ways it might be an empty list
which is just written down open square
bracket close square bracket or you can
think of it as being built by putting an
element on the front of another list and
the way that is done is by writing open
square bracket the element vertical bar
the list and closing square bracket so
list where and in the the the two
elements that come before and after the
vertical bar are called respectively the
head of the list and the tail of the
list and in fact you can put anything to
the right of the vertical bar but it's
typical in Erlang to do only to build
what are called proper lists so those
are lists which are if you like lists
all the way down so the thing on the
right is always a list so you finish up
building a list from an empty list at
the extreme right hand end I'll show you
an example of that in a in a second so
lists are a few the most commonly used
data type in Erlang and many elements
it's unusual to find a neuron program
that doesn't do some list manipulation
here's an example just showing you they
big arrow they are showing you that the
list is built up in this recursive way
before I move on to talk about this
slide what I'll do is I will do some
more examples in the Erlang shell so
we've restarted the Erlang shell just to
clear up the so we don't have a whole
lot of old expression sitting up there
and let's see an example of creating a
list in this way well one way of doing
that is to simply to write the empty
list said that's a way of creating a
list another way is to use what's called
the conce notation I should have used to
explain this where I was talking about
the slides when this is a notation where
you have open brackets element vertical
bar lists closed bracket so here we've
got a simple example of a list with one
number you can see here the first
element of the list is two and the tail
of the list is the empty list we see
what we've got here is the list with
just two in it we could build up a and
more complicated list this way we could
write 45 before the vertical bar and
then after the vertical bar we could
write the list two comma three closing
square bracket and . and there we see
we've got the list 45 2 comma 3 it's
just worth pointing out that the way the
Erlang shell works is if you write a
list of numbers which are don't make
sense as as printable characters you'll
see back the numbers but as we've seen
earlier on if we write a list with say
the number 65 twice in it what we get
back is it is a string representation
because those those letters are
printable now I think what you can see
here I could show you one last thing and
that is that you can put anything you
like after the vertical bar so we can
write 45 vertical bar 3 and that just
represents itself it stands for itself
it's a an item whose first element is 45
and whose tail is 3 but you can see that
is not a properly constructed list
because the tail itself 3 is not a list
so perhaps what we meant to write here
was 45 vertical bar list with just three
in it followed by full stop and there
we've got I think that was what we were
that was what we were aiming to do and
most programmers in use only what he
called proper lists such as listed it
terminated as you want
I'm deconstruct them by an empty list
the final slide on on lists is talking
about some of the operations that we can
perform what I'll do is I'll show you
those on the two important operators on
less are plus plus and minus minus or
plus plus does is join 202 bits together
so one two three plus four five seven is
the list one two three what - - does is
4 and we subtract from that what gets
removed is the first occurrence of two
and the first three so the answer doing
that you can see that it's not removed
that second occurrence of two just to be
clear something that can be confusing is
the difference between plus plus and
cons so it's important to realize that
you write a list plus plus a list
whereas you write
so if I write one too I get the list for
numbers whereas if I write one to cons
three four I get a list with three arms
the first is a list one two so it's
important to realize that those two
operators do quite different things I'll
do now is I'll move on to the next part
of the presentation and that's about
variables variable - no line begin with
a capital letter and after that you can
put small letters underscore and if you
put an underscore line zone that's
what's called the don't care variable
now also a variable can begin with an
underscore and that will see a bit later
on it's like a don't care variable but
is slightly different properties but
we'll see that when I do a demonstration
okay
now what I'll do now is show you how
variables are used in the shell okay
let's have a look at what we can do with
variables in the shell so what we do is
here we've got a variable a and what we
can do is assign that the value 23 what
we see as a result we get back as the
result is the is the value that's been
assigned but then we can use that value
of a you can see a is 23 we can ask for
a plus a or you can ask for a minus 10
for example let's try and assign a again
we want to add one more to it
whoa we're getting an error here what
that is showing us is that assignment in
Erlang is single assignment you can only
assign to a variable
once we've assigned a the value 23 and
it keeps that value
I come back a bit later on when we talk
about pattern matching to explain
precisely what's going on in this error
but for the moment just beware Erlang is
single assignment and so you assign once
if you want to in the shell forget the
value of the variable a you can type F
little a and now we could within the
shell assign the value again but when
you're programming inside an Airline
program and you want to assign to
variables you can't do this forgetting
so you can't use variables in the way
you would use them in a traditional
imperative programming language like C
or Java it's crucial to realize that it
makes our life a lot easier to use for
concurrency so it's a good thing right
what are we seen here we've seen an
assignment of a variable we can also
have a look at assigning to thee that
again has the value 23 but it's not made
an assignment because that the thing on
the left of the assignment is a
wild-card so what we see on the next
slide is just a reminder of some of the
things that we saw in the shell
variables can be used to store we saw in
the example we only saw some simple
examples and integers variables can be
used to store any sort of data structure
and also there is no types variable to
know I'm not typed a variable can be a
value of any type can be assigned to
what we see now is an example of a
complex data structure which pulls
together atoms like person and Joe
enclosed in single quotes lists like the
list 3 5 7 tuples which we see in the
first line you see the tuple and so
those put together can represent quite
complex data structures now we create
those values by writing down those sorts
of complex structures but what one of
the nice features of our line is that
has pattern matching which allows us to
analyze and conditional code dependent
on different structures and that's what
we're going to look at next in the
section on pattern matching this
religious reminds us of what's going on
in using complex data structures they
can be arbitrarily nested they can
contain bound variables so if you've
assigned a a list to a variable you can
then use the value of that list within
another data structure and one very
important thing to emphasize is that you
don't have to worry about memory
allocation or even more importantly
deallocation garbage-collected language
so allocation is automatic and
deallocate as you're probably aware
along is a concurrent language and
garbage collection is a concurrent
process so it's a very fine-grained and
very very very optimized garbage in
garbage collection but let's move on to
the general form of pattern matching is
that on the left you see a pattern on
the right you see an expression between
using equal symbol and pattern matching
has three roles it's used for assignment
it's used for execution of control flow
and it's used for disrupting compound
data types and we'll see some examples
of that on the slides that follow so
first of all we have an assignment a
that succeeds and finds a 210 we seed
further down the slide we see some
examples of assigning a tuple variables
to a tuple of values and at the bottom
you see is not an assignment of a
constructed list - a list let's move to
the terminal and see some of those
things right let's have a look at how
this works out in the Ullman Show
we've seen simple assignment already the
variable a is assigned a value 10 but we
can see a different sort of assignment
here we have a tuple of variables on the
left and we can have a corresponding to
pull the values on the right now we see
at the as a result the result is the
value on the right hand side but now we
have made separately an assignment to B
and to C so there we see that that's one
mechanism in Erlang for extracting
values from complicated data structures
you put a pattern on the left which
matches the value on the right and the
individual variables in the pattern on
the left in this case B and C match the
values on the right maybe 34 and 12 now
we can also do some checks as we do this
so for example if we assign d d e to
23:23 12 we will see that that succeeds
and d has got the value 23 and e has got
the value 12 but it's interesting you if
you look in the pattern you'll see that
we repeated the variable here and so
this was only successful because we had
23 on both sides
let's have a look at that what happens
with that fails we put FFG and we try
and match that with 23 24 12 you can see
that now we've got an error from this
because there's been no match of the
right hand side value the right hand
side value is indeed what we've written
23 24 12 but the pattern on the left is
trying to match that in such a way that
there's the same value for the first F
and the second and that can't be the
case because the first F is match to 23
second F is match to 24 so that fails
and this is one of the first example
we've seen of a pattern match failing
well it's not in fact it's the second
example because what happens if we write
a equals 11
well we've already on the first line of
this shell assigned a to 10 so if we now
assign a to 11 we get exactly the same
error because what is happening is that
we're matching the left hand side
variable which we know already has the
value 10 which is a value on the right
which is 11 does that fail but what will
succeed is that because the variable on
the left hand side already has a value
10 and that's equal indeed to 10 so
we've seen there that pattern matching
can succeed as it did in line 2 and in
line 5 but it can fail as it did here
because of a failure to match the
pattern on the left fails to match the
value on the right it fails to match in
line 8 because the two values 23 and 24
are not equal it fails to to match on
line 9 because of a is already as the
value 10 okay
so we've seen their an example of of
failure another way that that pattern
match can fail is that we could write
something like a tuple of two elements
on the left and a value with three
elements on the right that's failing
again because the pattern on the left is
expecting a two element tuple and we're
trying to match it with a three element
of value on the right now I talked
earlier on about how lists were
constructed and we saw that one of the
ways you can construct a list is to is
to write something like a head comped
onto a tail and that will give us a
value we could give them a good
assignment let's assign that to end
oops so now we've got this complex value
in how could we analyze that well the
way you can analyze that is to put a
pattern on the left hand side and the
pattern here is that the head P and the
tail Q and match that with M what should
we expect to see well it's been
successful and what we should expect
will be the value of P P is the head of
the list so we'd expect that to be the
first element q is the remainder of the
list so we'd expect that to be a list
and that is that is the number 34 but
here you're seeing one of the the
features we'll might call it a bug of
the the shell that it's it's thinking
the shell is thinking oh the character
go to 34 is something I can print and in
fact it's the double quote symbol
but that is actually equal to 234 let's
just check that by typing Q before of
course that is wrong because what I've
written is a list being equal to a
number what I should be writing is Q is
the the list with just 30 for it let's
see if that works and that does work
good so I think that that's shown Assam
and that's shown I think very clearly
how lists I said earlier on that lists
were work analyzable as a head and a
tail an element plus a sub list that's
rather different from a tuple the only
thing you can do to destroy to take
apart a tuple is to take all this
elements whereas with a list what you
can do is take its head and remained
have the remainder of the list as its
tail and we'll see that that's very
useful in programming in recursive
programming of all sorts of functions
over lists now I think what we've done
here is we've seen the three elements of
pattern match we've seen an assignment
so we're getting values assigned to
variables we've seen testing chest width
for instance where the two values at our
pattern or equal and we've all seams
also seen that the portions of a list
can be extracted by pattern matching so
what I'll do I'll just run through some
slides which summarize that and that
will bring us to the end of this this
first section on basic only can be used
for assignment
it was a simple thing we did to assign a
value to a variable we've also seen now
that that can be an assignment to a more
complex if we do an assignment be Khan
the city to the tuple 3 comma 4 that
finishes up with B being equal to 3 and
so that's assigning a number of values
now what we can see next seen in that
they can be a test aspect to a silent so
we can if for instance we put the same
variable in to add a pair and assign
that to 3 comma 4 this will fail because
we're expecting two equal values and
we're presenting two different values
aside you see some other examples of
failure a list of bigger form variables
being assigned to a value of 3 variables
on the in the third example we see a
successful button match of a comma B to
the first two elements of the list the
remaining two matches 307 but another
failure is to try and match the head and
tail of an empty list because their
interest doesn't have a head so that's
an unsuccessful
and finally what we see is extraction of
values and in the examples here you see
extraction of complex values from
complex data structures so we're
extracting the first example we're
extracting an item ABC in the variable a
constant integer 22 you because twice in
the in the value is being extracted into
the variable
so writing complex patterns that involve
variables atoms numbers will match
successfully with the values that have
those corresponding atoms numbers and so
on the corresponding position so we can
do complex pattern matching and we can
simultaneously pull out extract elements
from a complex data structure so what
we've seen in this section is we've seen
the basic datatypes of integers floats
and atoms we've seen how strings are
represented as lists of integers one
thing that we haven't mentioned because
there isn't this type in and we haven't
mentioned billions and billions the
boolean type is simply represented by
the atoms true and false and the
collection of operators over those atoms
we've seen how Erlang has single
assignment variables are identifies that
begin with a capital letter or an
underscore we've seen how those are
assigned to we've seen how they're used
in complex patterns for testing
assignment and extracting values we've
seen how complex data structures can be
built using combinations of atoms atomic
types like atoms numbers tuples and
lists which combined together can
represent very complex values so that
concludes the some of the basic Erlang
section one what we'll do next is move
on to basic going section two</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>