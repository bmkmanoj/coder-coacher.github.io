<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>1135   The ABCs of OTP - Jesse J Anderson | Coder Coacher - Coaching Coders</title><meta content="1135   The ABCs of OTP - Jesse J Anderson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>1135   The ABCs of OTP - Jesse J Anderson</b></h2><h5 class="post__date">2017-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/l5OODJ71qOs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I've got this buddy right now and
we're both kids the 80s and we're we're
both really into synthesizers but he's
really into synthesizers right now he's
got or used to have this little one
called the Opie one and this thing is
awesome for just like fiddling around
it's really easy just to make some
really fun awesome music but the other
day he's sent me a picture of another
synthesizer that he saw and it looked
like this and that
well first off that looks awesome I want
to play with that but I don't think I
didn't I know how to make it make any
sound I don't know how to do anything
there's like a hundred knobs and there's
like cables just sort of like strewn
randomly about and I would have liked
looking at this I have no idea where to
start and this I think is a really good
example of what OTP you look like to me
when I was first looking at it I knew
there was a lot of power there I knew it
could do some cool stuff but I just had
no idea how to do any of it so let's
just do some quick overview what is OTP
anyway well there's a lot to it but
basically a collection of libraries and
the hierarchy of supervisors and workers
that's sort of when someone says hey you
need to learn OTP that's generally like
what they're talking about there's so
the main OTP libraries are supervisor
and Jen server and if you're using the
lick sir there's a agent and task which
are like abstractions of Jen server but
there's a whole lot of other components
to OTP there's application there's Jen
stage dialyzer ets did list just keeps
going on and this is not a complete list
there's so many different tools and
aspects - Oh T P that when you're a
beginner like I was it's kind of
overwhelming it's hard to know where to
start but in general when people are
saying you need to learn Oh T PU they're
talking about supervisor and Jen server
so to learn supervisors and Jen server
we've got to start at the basics and
that's with processes and this isn't
like an operating system process
processes and elixir and Erlang or
super-lightweight you can just spin up
like
thousand on your laptop and not break a
sweat so let's go ahead and see what
that looks like so we're gonna jump into
ie X which is the repple for elixir
basically like your playground to try
out code
so first we'll call spawn and that's
gonna spin up a process and then we're
giving it a function for what to do
so we're saying okay spin up this
process and once you start process I
want you to run this function that's IO
dot puts and then hello EEF seventeen so
the process starts up and then prints
out hello e of seventeen and then we
have this orange thing here this if you
haven't seen it before it's kind of
weird look in the hash tag PID with some
numbers and that's your process ID or
commonly just called a pig and basically
that's how we're gonna track this
process so we didn't capture it so let's
go ahead and just spin spin up the
process again and this time we'll
capture the process ID in the variable
pad so we run it up it prints out hello
EEF 17 and now we've got that process ID
captured in the pit so let's go take a
look at what our process is doing so
we'll do process dot alive just make
sure it's still alive and it is not
alive what happened to our process so
when you spin up a process it give it
runs a function you give it and then it
immediately just gracefully dies and
that's just how how the process is
worked you give it the work to do it
does it and then it's done so this is
great so now we know how to do process
is we're gonna start throwing them in
our application but at some point you're
gonna give a process a lot of work and
halfway through it's just gonna crash
and it's not gonna die gracefully so how
do we deal with that so we're gonna do
some error handling here as I'm sure
many of you have heard in the world of
Erlang and elixir commonly commonly said
is let it crash like that's just the
solution to everything and when I first
heard it I was like I I don't want my
application to crash I don't understand
how this is gonna solve things and part
of that was the way I was thinking about
applications but when you think like
outside of apps you write you think
about like like Photoshop I'm a designer
so Photoshop is something that I often
have issues with or
just your whole operating system in
general or maybe your video game console
your phone some of my kids electronic
toys your TV a problem happens with that
and what's one way that's gonna fix it
most of the time for all of those
does anyone here watch the IT Crowd yeah
have you tried turning it off and on
again and this works it works like
universally for a computing and
electronics like 90% of the time this
actually does fix the problem why why
does that work so the reason that works
is because you're starting over that
device or that app or whatever it is
with brand-new state what happened
somewhere along the way that that thing
that had the issue got corrupted State
something weird happened and then it
cracked or then it had some issues but
restarting it you're giving it fresh
state and you don't have that problem
anymore
so the Supervision tree is based on this
principle because the way apps work in
your list in Erlang is you have these
clusters of all these different
processes we can try turning it off and
on again at a very specific level so we
don't have to crap let the whole app
crash we're just saying that little
piece that's not working right now
because the state got corrupted or
whatever we're gonna let that crash so
so in this tree basic tree we have right
here we've got some supervisors and then
we have some workers and supervisors are
just other processes that have really
really simple job because you don't want
them to crash so all they do is they
start up the processes the children
processes underneath them or they when
they see the state go bad and the
process crashes they restart it and
restart isn't quite the right term
because they're actually starting a
brand new process that has the same
starting state so if you look in this
tree look at this tree right here the
worker down there in the bottom right if
that if that crash is the supervisor
right above it is watching and says oh
hey that that just crashed I need to
restart that and it'll try it a few
times and then if that doesn't work it's
gonna crash itself and then the
supervisor above it will try restarting
it and it can kind of cascade it all the
way up
if your top supervisor crashes well then
maybe you just need to rewrite because
you got a really serious problem mm-hmm
but that's sort of the basic idea of the
supervision tree and when I wanted this
I was like okay that that sounds great
like that seems seems cool seems useful
but what if they're working on there
what if I'm just a bad coder what if I
just have bad code in there this how is
this gonna magically fix my bad code
that's just gonna fail every time you
restart it and the answer is it's not
that code is not gonna magically get
fixed by OTP so if it doesn't fix that
what is it doing so this is a part that
took me a long time to figure out but
there's this really great article by
Freddy bear called the Zen of Erlang and
he goes over this he identifies bugs as
being of one of four types so you've got
your core features in your app and your
secondary features and then of those
kind of bugs you have the ones that are
easily repeatable and the ones that are
transient
so the first off their core feature
that's easy to repeat it's pretty easy
to find those bugs like those are like
oh you do this you do that and you do
this on this main feature of our app you
know this bug happens so those are
pretty easy to find a secondary feature
is also pretty easy to find but often
you overlook them because they're like
oh I forgot our app even did that that's
a feature we made two years ago and we
forgot users actually use it so
sometimes those the ones that you can
overlook well the transient bugs these
are the ones where you get the bug
report and you're looking at it you're
like I cannot get our app to do this how
how did they do this it does not make
any sense and these are the ones that
are really hard to find because there's
some crazy sequence of steps that
somebody went through to cause the state
to get to get into this weird state
where this bug shows up and so because
of this the kind of bugs that happen in
production the core feature ones that
are repeatable those should never happen
they do but they shouldn't ever happen
the secondary features those ones happen
pretty commonly that's often because you
forgot about a feature he's like oh
that's thing
I'll fix it real quick and we'll push
the production this afternoon the ones
on the right though the transient bugs
those happen all the time and predict in
production because they're hard to
detect hard to find the great thing
though bugs that are handled by restarts
not really the repeatable ones but the
transient bugs restarting that part of
the app fixes that problem so we have
these kinds of bugs that are are hard to
find and a hard to detect before they
get to production but restarting usually
is a way to fix that bug so we talked
about all these just independent little
processes and they're actually their
memory independent which is great so
restarting them doesn't affect any of
the other processes in your app but they
have to have a way to communicate and
the way they communicate is with mess
with messages so every process has the
paid we looked at earlier the process ID
which is like the mailing address for
that process and so and they also all
come with a mailbox so they are ready
when you spawn it up it's ready to
receive messages we have to tell it what
to do with the messages but at start
it's ready to receive those messages
excuse me so let's go ahead and see how
this works so I'm a big I'm a big fan of
a fantasy football and it's never too
early to get started for the next season
so we're gonna build a real basic little
app here that just lets us store the
players and her team with some basic
stats in this past summer I was doing
some learning of elixir I've I created a
quick API wrapper for the fantasy
football nerd API and so that's gonna
let us just feed a player name and then
it'll return back a bunch of data about
that player so the first thing we need
to figure out for our new fantasy team
app is how we're gonna store the state
so there's a lot of different ways you
can do it if you're from Ruby you're
like alright time to build the database
because that's kind of how you do it and
there's nothing wrong that like we can
do that if we'd go to production with
this app maybe we're gonna build some
database using ecto or maybe we could
use ets
for a more long-term storage there's
Nisha there's some other options but for
now we're just doing kind of our own
little app for us we're just going to
sort that state in the process and
that'll be fine so this here is the this
is our basic process that's gonna let us
add players to our team remove them and
store them and return the full team so
let's go ahead and walk through this so
we define the module at the top fantasy
team DUP basics we're just doing our
basic process here and then we have
these start functions so this is the one
that's gonna kick up the process and
there we have the familiar the spawn
process we did earlier instead of giving
it a direct function we're actually
giving it a set of instructions so first
we're going to give it the module to
call and we do double underscore module
here which just references the the name
of the module you're in which in this
case it's fantasy team basic mmm-hmm
so when you compile this it's just going
to replace that with fantasy team basic
and then yeah that's the module and then
the second one is an atom and this is
actually telling it which function to
run under that module and then the third
is a list of arguments in this case we
only have one argument which is just an
empty map and so basically what we're
doing is we're spawning out the process
and we're saying hey take that module
and that function and these arguments
and then run that so when the process
starts up its gonna run basically
fantasy team basic loop with an empty
map as a function and that's our
starting stakes our team to start with
has there's no players it's just an
empty map ready ready to receive data so
now we'll go down and check out that
loop function we're telling it to run so
we've got loops States so at the
beginning state is just the empty map
and then we have this receive do block
so before we had our process that
immediately died when it finished
printing out hello EEE EE f17 in this
case it's actually going to sit and wait
to receive a message so at this point
it's just sitting there it's not like
eating up memory it's not like blocking
or whatever but it's just sitting there
waiting not doing anything until it
receives a message so the first kind of
message we want to be able to send it is
this tuple that starts with an
Adam and then the name and the name will
be a string like Russell Wilson in
quotes so we'll take that name and then
we'll we will run and this is a function
we have in the background that does the
API that calls up the data so we're
gonna take that name Russell Wilson
we're gonna run fantasy team dot player
to find Russell Wilson and that's gonna
return for us this big map with a bunch
of details about that player so you know
like College Wisconsin team Seattle
position quarterback etc so now we have
this player variable that's got a map of
all that information about the player we
just added and then we're going to
define a variable called new state and
this we're taking the existing state
which is an empty map and then we're
adding the we're adding the key of
Russell Wilson and then all of his
information as the value for that so now
we're gonna have a map that has one one
item in it which is Russell Wilson and
then all the stats and if we just
stopped right here it would create that
state and then it would just die so we
would lose it because we haven't looped
it again so the here's our we have
recursion so after we define what the
new state is we're going to run the loop
the loop at the top again we're going to
run this function again but now our
state instead of being an empty map it's
the map with Russell Wilson and so now
so now that we've run loop we're back at
the top and now we're waiting to receive
another message
so the second kind of message we have
listed is remove a player and it's the
same thing it's the remove atom at the
beginning of the tuple and then the name
that we're trying to remove and then we
don't need to check the API or any
thinks we're just removing the player so
we define the new state as the existing
state - this this player that we want to
remove and then we loop it again back up
at the top and then our third message
that we're gonna receive is an atom with
team and then the paid because when you
when you're calling this you need a
message back you're asking for send me
back the team so when you send this
message you're sending that yourself the
process sending this message is sending
its own process ID so that this process
that we're spawning up knows where to
send the message to so like if we are in
IEX
and we sent
a message to this it would send its own
process ID with the message so that um
our process we're defining right here
could send the message back to IEX and
then we do that with the first thing
here we just do send to that sending
pid' and then send it the state and then
we're not changing the state at all so
we're just gonna loop back up at the top
with that existing state and that's it
so this is our basic process module
let's go ahead and see this in action
real quick so we'll jump over to IEX and
we were starting up fantasy team basic
dot start and capturing that page so we
can send some messages and first we're
gonna send it send the message the tuple
add the name Russell Wilson so then we
see the return like there's the message
being sent at Russell Wilson and now
we're gonna do it again we're gonna add
Doug Baldwin and then we'll actually try
out just to make sure it works but we
remove Doug Baldwin and then we'll call
will send the message for the team so we
didn't get we sent off the message you
see right there team and then our
process ID but we didn't actually get
anything back and that's because IX
isn't built to do anything on that with
that message so the message was sent but
it didn't do anything with it and so we
can just flush out the mailbox and then
see up there there there it is there's
our map with Russell Wilson and it's
details so it did get the message it
just wasn't I didn't have any way to
handle it yet so this right here we just
walked through this is a really really
really common pattern and elixir and
Erlang and it's so common that they've
built a generic library to emulate it
which is called Gen Server what we've
done here it's it's pretty easy to kind
of walk through and understand but it's
actually missing lots of edge cases
there's there's a lot of issues this
looks nice and clean and simple but
there's a lot of issues with it having
to do with compatibility with
supervision trees deadlocks message
ordering tail call optimization dynamic
tracing and I don't even understand what
half of that is but luckily really smart
people do understand what all that is
and they've been working on gen server
for twenty or thirty years behind the
scenes so it has a
a lot of history behind it making sure
it's battle-tested and taking care of
all the edge cases I don't have here and
do not understand so let's go ahead and
see what it looks like we take what we
built and move it into a gen server so
might be a little hard to see in the
back we are gonna zoom in so on the left
it looks like it's about twice as much
code but half of that code is actually
convenience functions so we don't even
like really the code that's doing most
of the work is pretty much the same
there's not really that much more so
we're going to go ahead and go through
this so that it all makes sense
so to start off we do the line use gen
server and that's like saying yeah we
want to use all that great stuff that
the OTP team is built so we're gonna go
ahead and bring that in here and that's
gonna let everything else work in this
module so we start we always start with
the used gen server and then now we'll
jump down to those functions at the end
they're the ones that are similar so
well first we have our our start
function so that's the one that kicks it
off and it does kind of the same as
before before we had spawn but the
process spawning the process that had
the module the function and arguments
over on the right and on the left now we
just do gen server dot start and we give
it the module name which again that
double underscore is just pulling the
name we have at the top of the module
and then we don't actually need to give
it the name of the function to run
because it has its own loop function we
don't we're not gonna have to define how
the loop function works it kind of has
that already so we're just gonna pass it
in okay to pull here and then the third
list there that's four options and we
don't we're not gonna use any of those
today so now we'll jump back so we have
this init function and this is something
you do in every gen server when you do
the first thing you Gen server's start
that's going to start up the process and
it knows to look back at the module
because we defined that as the first
argument it's gonna look back at the
module and say hey I'm a gen server I
need an init function
what is your init function and so we
define it right here and all it is we're
just doing an okay tuple and then the
second part of the tuple is the state
there's so there's our empty map
it's where we're gonna define her state
here and then we're gonna jump down to
this function here called handle cast so
before on the right we have this big
encompassing loop function that had the
received ooh and then all of our
messages so Jen server we don't have
kind of a wrapping function a wrapping
loop function like we did over on the
right now we're actually gonna be able
to handle each message individually and
Jen server is handling the looping in
the background so so with this handle
cast we have the part handle cast is
receiving the message add name like
before we had under the received block
now I just have it as the first argument
of handle cast and then the second
second argument is the state which
instead of putting it up in the loop
function because we don't have that
we're gonna define that as the second
argument of every handle cast mm-hmm and
then we'll jump down to this part and
this is exactly the same we're looking
up the player in the fantasy football
nerd API and we're defining it and then
we're creating the new state by adding
that player to it and now instead of
running our loop function like we did on
the right because again we don't have it
here we're just going to return a tuple
that starts with no reply because we're
not sending a message back to the
calling process and then the new state
and then Jen server knows how to now
maintain the loop with this new state
yeah so then we have our second one here
the handle cast with the remove function
it's pretty much the same thing we've
got the message received there as a
first argument and then the state yeah
the state is a second argument which is
again it's at the top of the loop on the
right side and now I have this line
which is the same thing we're defining a
new state which is removing that one
player from the existing state and then
we have a no reply tuple with that new
state in it so the third one instead of
handle cast this is handle call and the
way Jen server works is it kind of has
two types of messages that you can send
it you can send it a cast which is kind
of like sending a postcard like you're
not expecting a reply you're just like
hey do this and now I'm gonna go ahead
and do my own thing or you can send it a
call and that's where you're asking
for a return like hey do this thing and
then tell me when you're done
like I want to know what you're the
result of this is and so in this case
the result is I want to know what the
team is so I'm gonna send the message
with that's just the atom team and then
we also send the second argument there
is from and that's the sending process
ID and most of the time you don't
actually need this there are some cases
where you do but we're just gonna
proceed that with an underscore because
we don't actually need that value and
then the third one is the state and so
all we need to do here is return a
return a three element tuple that starts
with the hashtag Earth from the hashtag
the atom reply I've been doing too much
Twitter thinking lately I guess and we
have state in here twice so the the
first one is that's actually the message
that's going to be sent back so before
we on the right we did send to that
process ID the state because that's what
they want then when I see the entire
team so here on the Left we've got the
first or the second argument there which
is the first state and that's the
message being sent back and the second
one is that's the state that we're going
to save so in this case they're the same
but like if we had another handle call
that was like quarterbacks I just want
to see all the quarterbacks that are on
the team the first one would be all the
quarterbacks and then the second one
would be the full team because we still
want the full team to be the state ok
and now we'll jump back up to the top
and there's our convenience function so
we have the start right at the top that
we already went over and then now we
have our add/remove and team functions
so first we've got add and remove and
they work pretty much the same first you
will list the the process ID and of this
process gen server that we're starting
up and then the name like Russell Wilson
you want to add Russell Wilson or remove
Russell Wilson and we're gonna take that
and then we're just going to do gen
server dot cast and so what that's going
to do is it's going to when you run my
fantasy team my gen server dot ad
process ID Russell Wilson is going to do
gents overcast and it's going to cast a
message to that process idea we gave it
and then send it the message ad name and
then remove name and then those will be
handled by the handle cast and the
handle call that we went over already
and then with the team we know we don't
have to supply a name so we're just
applying the pid' and it's going to do
Jen server call and that's going to send
the message and wait for the reply yeah
so there we have our full Jen server and
the one thing that's really kind of
annoying with this setup though is we
have to track that process ID and that
sucks so we're gonna get rid of that
because we're for this example I'm just
trying to track my own team I'm only on
one league so I don't need to worry
about a whole bunch of stuff we're just
gonna make this real easy so we're gonna
add a name to this to this module now
we're gonna call it single server and so
here we have a module attribute that
just defines name as the module name and
then we're gonna start plugging that
into our convenience functions so now
when we do Jen sir start before we
didn't have any argument or any options
on the right so we just had an empty
list now we're going to say when this
process starts I want to give it this
name of fantasy team dot single server
and why would you do that
well now we don't have to we don't have
to cast to a process ID we don't have to
keep track of that anymore because we
know the name so now in the Jen server
cast we can just plug in the name right
there and the cool part about that is
now we can take the pit out of our
function name so now it's just a fantasy
team dot single server dot add Russell
Wilson and it knows what the Jen server
is and knows the process ID and we don't
have to keep track of that because one
of the most annoying things about all
this is tracking process IDs so anytime
we can get rid of that I'm gonna do that
so there we go so let's go ahead and see
what we've built in action here so we go
ahead and start up that that Jen server
faints
single Seurat start we see the process
idea right there but and Oh with Jen sir
as it returns rather than just the
process ID it returns a tuple
it starts with okay and then the process
ID but we don't need to capture it
because it has its own name so we can
just write from here say fantasy team
single server dot add Russell Wilson and
it just returns like okay which is like
sweet okay I guess it's working well go
ahead and do it again with adding Ted
Baldwin and then we'll remove Doug
Baldwin and then we'll go ahead and do
our team call and that gives us the
return value of the team so there we see
it so cool one thing if you if you're
using elixir they've done this thing
where they take Jen server and Jen's are
kind of what we've used it for is
basically just storing state like it's
not doing any complicated stuff it's
just storing the state so elixirs kind
of taken the other thing you can do with
Jen server is do a lot of kind of
complex work and like concurrent tasks
and stuff and we're not doing that here
but elixirs kind of taken abstractions
from Jen server and so it has agents
which just do storing state and then it
has tasks which just do kind of all
these concurrent work so let's go ahead
and just see what we've built already
we're gonna see it as in an agent real
quick and this is it this is the full
code that does everything or gents ever
did but now it's as an agent so it's a
lot less code because we have kind of
those convenience functions where it's
just my agent add and then it runs
everything from right there so we have
agent update and that's what there's
like there's only a kind of a few
functions that agents do because all
it's doing is storing state so one of
them is update so when you do agent
update we give it the name or the
process ID if we're not using the name
named server and then we send it the
function for how to update the state so
in this case you're taking the state and
then you're saying map put the you know
the new player into that state on the
same with remove map delete that that
player from the state and that's all all
you need to be able to maintain state
with an agent oh yeah there yeah
and then we have for the team we're just
trying to get the current state so we
can use agent get and then our function
is just like a function State yeah the
state sent us that back there's a few
other functions you can use like instead
of just update you can say get and
update and that's going to you're going
to want to return a two element tuple so
the left one is the state you want to
see first and you can do other stuff
with it right here we're just returning
it as the first element and the second
element is going to be the new state
that we adjust here with the map by
either adding the player or removing the
player and then there's also agent cast
so all the other ones update get an
update those are all calls so you're
actually when you when you run agent
update you're waiting for that response
to for like an okay tuple or to find out
like okay yeah it added the player with
the cast you're just like you know
fire-and-forget like you're like yep go
out the player and I'm gonna do my own
thing I don't need to know that you did
I trust that it's gonna work out or
whatever okay so one thing if you're
more familiar with this you might have
been wondering like why I'm using start
and spawn instead of start link and
spawn link and if you're not wondering
that then let me tell you why we should
be using that so when we had our
supervision tree before I talked about
how a worker would crash and then the
supervisor would see it crash and
restart it so the way that works is
processes need to be linked together so
when you instead of running spawn if you
run spawn link that links it to the
calling process so if you're in IX and
you're on spawn link a process and then
that process crashes ie X itself
actually crashes two because they're
linked to each other if one of them
crashes the other one goes down the cool
thing is is already using the
supervision treats you might not even
notice because IX will go ahead and
start right back up again which is
pretty awesome so that's a really quick
way to see a supervision tree in action
is just run a spawn link and do like the
function you know one divided by zero or
something and it'll just kill it and
restart IX for you which is pretty cool
but the problem with this like well you
don't want the supervisor to go down
one of its child processes to go down so
supervisors have this thing that's
called trapping the exits and basically
that seeing like oh it went down I'm
going to not crash myself and instead
I'm just gonna restart that process so
yeah as I said before we had some
functions that are just start and they
would spawn or gen server dot start
agent start all we do is change those to
adding the underscore links a spawn
underscore link or gen server dot start
link and then we're gonna we would go
ahead and change the actual starting
function names to that to which we don't
I guess technically have to but it's
just common pattern you want to have
that so the when you start it up you
know it's linked process so we're doing
pretty good here but if our gen server
goes down it's still just gonna die
because we don't have anything actually
supervising it so let's go ahead and do
a supervisor real quick and this is
supervisors were really intimidating for
me but there's really not that much to
it they work like I said before they're
really simple all they're doing is
starting processes or restarting them
when they crash so at the beginning we
just do this use supervisor just like we
did Jen server and that's kind of
getting all the magic that the Erlang
OTP team have been working on for
decades which is pretty nice real easy
just like oh yeah one line let's use all
that awesome stuff you guys have done
and then we're gonna start up our
supervisor with start link and then
that'll do supervisor start link and we
give it the module name that we're in so
fantasy team got my supervisor which is
at the top there and then we have the
options and we're not gonna use any
options here so it's just an empty list
and so that supervisor process is going
to start up and because it's using
supervisor similar to Gen Server it's
gonna look back at our code at this
module that we gave it and say okay
where's your init function because
that's what I need now that I've started
so we do our init function here and
we're just going to give it the empty
list because it doesn't have any any
advanced options and then we're going to
define a variable called children which
is just a list of the processes that we
want it to start up in this case we're
just gonna have it start up our single
gen server so we give it a worker
function and we would
this for if we have if we wanted it to
start like say like three workers and
one supervisor we would just have three
functions in here in this list and a
supervisor function so but in our case
we're just having it start at the one
gen server that we're gonna watch so we
say worker and in the first argument is
the module name of the process we wanted
to watch which is our single server and
then again empty lists for no options
there and then the thing that makes this
all work we end our init function with a
supervised call and so this is going to
take our list of children which is just
our one server and then it's going to
give it a strategy and so there's a few
different strategies like your basic one
is this the one for one that means if
you have a supervisor that has like four
processes underneath it if one of them
dies it's just gonna restart that one
there's there's some other ones like
restarting all of them if one of them
dies and a few other ones that I think
there's just four and they're pretty
simple once you understand that once you
understand one of them it kind of it's
pretty logical to go down the list but
for this case we just have the one
process so we're just gonna do our
strategy is one for one and that's it so
now instead of starting your gen server
with fantasy team dot single server dot
start link we would start with fantasy
team dot my supervisor duck start link
and then this will go ahead and start up
our gen server as well and now it's
being monitored and good to go so a
quick recap
so we built a we started with processes
and then we built a gen server we named
that gen server so we didn't have to
track the process IDs and then we built
a supervisor to keep track of that gen
sir so that if something goes wrong
it'll go ahead and restart it if if
you're more advanced with OTP you may
see a few flaws and what we've done
uh-huh because there's a there's a lot
to OTP like I said before and there's a
lot more you can do to make what we've
done work a lot better but what I did
teach you is this and you can make some
music you maybe you can't do a lot with
all this but you can do a little bit
with this thing called OTP
enough to kind of make some stuff work
and now you can like well hey what
happens if I grab this cable from over
here and plug it in what else can I do
you have kind of that foundation to be
able to start learning some of the other
things from OTP like maybe you want to
like well I want to figure out how
Erlang term storage works ATS or ETS
whichever way you want to pronounce it
like now you have kind of a model to
build off of to do that yep so that's it
you can follow me at Jessie J Anderson
or Jessie J Anderson is all my friends
call me because it looks like that on
Twitter and I also created a quick link
a bitly link for abc's dash of that OTP
that's got a bunch of links to different
books that have really helped me to
understand OTP dave thomas and sasha
uric both have books that are great I'm
one that really clicked for me was
Benjamin tan way how he has the little
elixir an OTP guy book and that was kind
of the the lightbulb moment for me where
it finally started to all make sense
there's also a new book that just kind
of came out in beta by Lance Albertson I
think he's here and I read the first
like third of that book on that plane
ride here and it's fantastic highly
recommend that one too and that one's
called functional web development with
elixir OTP and Phoenix by Blaine's
Howerton so that's it thanks is there
any questions right so oh yeah yeah
sorry the question was when do you use
agent and when do you use gen server so
there's kind of differing views on this
I now that I really under like I
understand OTP at least the basics of it
and Gen server I like to always just use
gen server because then if I need to
change it later like I want to add some
more difficult stuff to it that isn't
just storing state I have it but agents
pretty nice let's is a tiny little
amount of code so if you know like this
is never gonna do anything more than
just store state agents are kind of a
great way to go but there's really
there's not a right or wrong answer it's
kind of personal preference yes
right so the questions about agents and
tasks and I talked about agents I didn't
talk about tasks so tasks are I haven't
used them so I'm not super familiar with
it but kind of the idea is like if you
have some complicated work you want to
do and you want it to run concurrently
so it's using kind of all the different
processors in your machine or whatever
tasks is kind of a great way to just
send out and have it like it
automatically kind of can run that stuff
really well I don't actually use tasks
so I'm not super familiar with it but
that's kind of like the idea you want to
do you have a lot of work you want to be
done and it's gonna be done better if
you have a lot of processes kind of
doing pieces of the work and tasks tasks
are really great for that but I'm not
familiar with a lot of usage gentleman
yeah yes Oh perfect there you go if you
want to talk to someone about tasks yeah
right it's really great and you're like
oh now I got to make it a gen server
anyway maybe I could have just started
there yeah cool any other questions yes
the questions about unit testing with
elixir yeah there's some great testing I
don't know the knowledge off my head but
yes sir X unit I think it's called yeah
yeah and doctor all doc tests are
awesome
yeah so it elixir really encourages you
to do use documentation in your
functions because you can do doc tests
so your documentation in your in your
modules will have little examples of how
to use that function and doc tests will
actually run those to make sure that
they work which is really really cool
yeah yeah it will force you to improve
your documentation or you'll have a lot
of field tests yes right so the question
is about the elixir 1.4 and how it added
this new thing called the registry I
don't know I'm excited about it I've
heard good things about it for managing
process IDs but I'm not familiar with it
I'm excited to learn because brought
managing that has definitely been one of
the pain points for me and trying to do
anything kind of more advanced so yeah
questions back awesome I probably have
that saved in pocket ready for me to
read later any other questions yes
right so that's one of the things I
talked about where someone more familiar
with this was like yeah but you're not
you're losing the state if it crashes
and that what we went through you would
lose that state and that's some of the
stuff I refer to like ETS and nija and
other ways you can save that state in a
more permanent place yes mm-hmm
right so the question was about what if
the state is bad in permanent storage
and you're just sort of refreshing it
with that bad state is that is that
right so you have a supervisor's have
like a limit so they'll try to restart
it a limited number of times and you can
adjust that and if that fails it'll kind
of cascade up if you have a really bad
situation it may you may need to get in
there and fix it like if it's somehow
the state got corrupted and there's not
you haven't like engineered a good way
to clean that state if that makes sense
so hopefully that's the sort of thing
that you would be able to that it would
be caught before it went to like
permanent storage if that makes sense
yeah
anyone else awesome if you if you have
any other questions and you see me
around go ahead and ask I'd love to chat
all right thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>