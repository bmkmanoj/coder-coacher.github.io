<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Norbert Wojtowicz -  Modeling your domain (Lambda Days 2016) | Coder Coacher - Coaching Coders</title><meta content="Norbert Wojtowicz -  Modeling your domain (Lambda Days 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Norbert Wojtowicz -  Modeling your domain (Lambda Days 2016)</b></h2><h5 class="post__date">2016-03-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UrGJHfB21Ok" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this talk is dead oriented architectures
can ever
hearing fine they're awesome so I'm
Norbert I go by that nickname ever run
the Internet's I gave a talk last year
lambs days about closure script just
from my own personal curiosity has
anybody seen it okay a couple of hands
that go up and you've decided to come
back for another talk why this good this
is gonna be a different talk because I
want to talk about system design and
system architecture so we're gonna be up
up up up in the clouds but not up in
space right so it's still pragmatic but
architecture not code which is important
because if you are interested in some
looking at code and so forth you should
probably go to one of the other talks we
want to have any code here and on top of
that none of the ideas that present are
innovative in the sense that they're not
my ideas there are things that have been
around for a while but for some reason
they're not getting as much attention as
they should so this is why we have this
talk anybody who knows me personally
knows that I have very strong opinions
and I'm not afraid to share them with
everyone so this talk is just one
person's idea of how to build systems
take from it what you may
I want to give you a little background
about myself so you have a little
context about where I'm coming from I
build stuff in various industries
including business sports non-emergency
health devices booking hotels booking
flights etc etc lots of different
industries but basically they're always
the same thing
some kind of highly available
internet-based
back-end with distributed clients
whether they're a mobile or web or some
other kinds of devices all these
companies for some reason call
themselves product companies some or b2c
some are b2b the only thing that I can
figure out that all these things share
in common is that they have some notion
that user interface is important and
user and that user interface is
important right user experience I am NOT
a particular fan of this term I like to
think of them as information systems so
the way I define it is that the main
primary purpose in life of an
information system is to serve as this
black box where data comes in
it's external from the system so users
provide data or other machines provide
data we store it securely and then at
some point later in the future someone
comes and asks it questions and we give
it answers and insights and etc etc so
just to get a feeling for the audience
who here has worked on something like an
information system pretty much everyone
raises their hands because if you
haven't you're either working and
building compilers or you're doing
real-time embedded systems or you're
working on your PhD I presume okay but
how many of you had suffered the burden
of technical debt same exact hands go up
functional programming who here is
excited about functional programming
this is lambda days this is a trick
question
but how many of you tried to teach it to
your colleagues and failed yeah so this
talk is a silver bullet and the reason
this talk is so cool is that it turns
out I can solve both of those seemingly
unrelated problems for you now I know
that makes me sound like a crazy person
but before you judge let me also tell
you that I believe in a conspiracy
theory and the conspiracy theory is the
following we have model view controllers
service-oriented architectures don't
repeat yourself and test-driven
development all suspiciously
three-letter acronyms and all I believe
are slowly but surely killing and
poisoning your projects I believe they
are the snake oil salesmen of the
software industry because they
consistently over-promised while
consistently under delivering and worst
of all giving you a false sense of
security that what you're building makes
sense until it's far too late to change
it take for example encapsulation right
it's a beautiful idea it's this idea
that I like to think of this as the
complexity iceberg all business domains
whatever you're working on are
essentially a complexity iceberg because
it turns out that in the real world
things are messy and difficult and
complicated and so the way we deal with
it ideally is that we build this iceberg
where we push all the details underneath
the water where we don't need to think
about on a daily basis right because
things should sort of just be working
out on their own you solve the problem
once and then you don't know
the thing about it you have this nice
API or some kind of facade up on top
that you deal with on a daily basis the
question is how do these solutions
attack this problem so MVC for example
is this idea that the system that we've
been building has become complex why has
it become complex a consultant comes
along and says the reason why it's in
complexity and complex is I see these
things that are models and these things
are of use and they should be
independent of each other so the
consultants come in they separate the
things into models views and controllers
they pat themselves on the back and they
go home six months later you're on the
crew you're on the floor sobbing because
somehow the complexity didn't go away
they then solve anything this talk is
far too short
for me to tell you horror stories about
MVC but I'm sure you've all discovered
them I know you've discovered them
because we invented service-oriented
architectures right this was somehow
magically supposed to solve the problems
that we had with these monolithic MVC
applications what was the idea the idea
was that those same consultants came
back and said no no no the problem is
that you have this big monolith and you
need to split it into multiple things
that do one thing and one thing well how
did they work how did how does this work
in practice though in reality what
happens is now you have multiple
problems you had one MVC and now you
have form VC so you have four problems
instead of one and on top of that it
turns out that no matter how you model
the services it turns out that all of
these things are entered are
interdependent on each other I've never
seen a system implement in such a way
that you can ask one of these services a
question and it doesn't need to start
chatting to all the other services in
order to give you a sensible response
right the separation is on the wrong
level we had an architectural problem
and we tried to solve it with some kind
of quick fix technical solution we
wanted to create a complexity iceberg
for ourselves and instead we created a
dependency iceberg where there was this
huge oil spill and then we just started
pushing things on the bottom and hoping
god forbid we never have to dive and fix
things all the way over there
same thing with duplication right don't
repeat yourself
deduplicate code I keep seeing this
everywhere but this was never the idea
behind dry the idea behind dry was that
you had a single source of truth right
this was the idea that if there's a bit
of information in your system you need
to store it in one place so you know
everything that depends on it and you
can change it in that one place but this
is not how it ever happens in real life
in real life is this is especially a sin
committed by object-oriented programmers
they create abstract factories and
classes or even worse they create
mix-ins that bring in dependencies at
runtime so you can't even see it in the
static code you see it at runtime they
fixed they tried to hack around with a
technical solution and all they did was
they created more coupling in your
system same thing keep you set about
reliability and testing because I think
if you ask anybody and you know over a
beer I think they're gonna tell you that
testing is about having reliable systems
I like to think of it as confidence
though I like to think of it as the idea
that I want I want testing to improve
the confidence I have in my code base
that it runs correctly and that the
thing that I'm building is the thing I'm
supposed to be building this is what
really irks me about test-driven
development oh and the people who are
behind it they're really Pro unit
testing but if the goal is confidence
why are we ignoring all these other
things types and schemas are really
useful and so our runtime assertions why
is it that Erlang can do it and nobody
else can what about generative property
testing these are all kinds of things
that improve our confidence in our code
but for some reason we ignore it as a
community right a lot of the kinds of
unit tests that I see are things that
are usually solved by type schemas or
property testing again unit tests were
easy so it was a quick technical fix but
it didn't really solve the problem that
we are trying to improve the confidence
and on top of that unit tests the way we
write them in industry they just create
lots and lots of company in our system I
know I'm being just a little
melodramatic here I know that these are
just tools and then they're not the end
of the world but the real problem is
that
people forget that these things are
tools they start training on like a
religion and these are where the
problems come in because when you start
trading things as a religion you stop
realizing that things can be different
and you can do things in different ways
because we're gonna talk about religion
I have to just admit to you that I'm a
devout rich Hickey convert I believe in
the almighty power of data and cues and
the concurrency fairy
unfortunately concurrency Fairy isn't
real all you've got left is data in
queues projects fail projects fail all
the time I think it's for one of three
reasons you don't understand the domain
so you build the wrong thing or you
don't actually model the domain so you
end up building the wrong thing or
inevitably somewhere down the line you
break rules one or two and you're
unwilling or unable to adapt and change
so I've been doing some soul-searching
and I said we need to build things in a
better way and I in order to figure out
what is the better way we need to define
some principles so I made up two guiding
principles for myself whatever I decide
I should strive to model the essence of
things it doesn't I'm not promising
myself that I'm gonna be able to manage
this but whatever we do we should at
least strive to model the essence of
things and try not to violate physics I
think these are two really good guiding
principles so whenever we hit an
architectural decision where there's one
of two ways we can go down which roads
we should come back to these principles
and see which one fits these rules that
we made up for ourselves and so this is
the moment in the talk where I can tell
you my restiveness lash that inspired
recipe for success so this is what this
is what's gonna help us build real nice
systems we have data flow magic sauce
and profit data we had to have some
rules data must be immutable and not
because it's it's cool and that's what
all the hipster kids are doing but
because that
how the real world works in the real
world all data information is immutable
right just by definition we are very
simple-minded people in the sense that
we don't understand multiverse theory
and parallel universes and Schrodinger's
shortening our equations and so forth as
far as we understand things are and
things may change over time but when I
say that something is something at a
certain point in time nobody goes and
says no maybe it isn't right because
that's essentially what mutation is you
don't want to explain to your users that
your system has supports Schrodinger
data you just don't avoid this subject
at all cost and the way you do it is you
just have immutable data the data must
have certain semantics so since we're
striving to model the essence of things
we're going to limit the number of
primitives that we use and the way we're
going to decide on this is that we're
going to talk about semantics if two
thing if there's two things in our
system there must be a reason why these
two things exist and the reason these
two things exist is they have different
semantics because if they had the same
semantics then we could just model it
with one thing and because we're
limiting the number of kinds of things
that we're going to be using we need
recursion because recursion will let us
now build up once again from primitives
to complex models so this is really
abstract but I want to give you some
concrete examples that kinds of things
that are primitive for example scalars
things like strings boolean's numbers
nil another useful thing attribute to
model is the idea of identity I really
like the fact that in closure there are
two forms of identity symbols and key
words and closure API is really take
advantage of this fact because you can
then apply completely different
semantics to what it means for something
but identified by a symbol or of a
keyword
you have collections lowest Maps vector
sets all have very different semantics
and all support recursion and sometimes
in your domain you have custom things
right for example that thing up on top
is a string but I want
to support the semantics that this is
some unique identifier so I just tagged
a UID string and that thing on the
bottom is a representation of time but
it's represented as a string and the way
is I tagged it as an instance and so
then when I pass it on to my system it a
portrays certain semantics right that I
want to support and and you can
basically customize this to your domain
so then when we come to flow right flow
is really simple to understand because
all we want to make sure is that we have
one-way data flows so we have some set
of data a and we wanted to get it to a
set of data B and we do that through
some pure function f some pure
transformation or if you're more of a
graphic person it would look like this
right the thing we're guaranteeing is
that for all of a there's a function f
that will give us B but the reverse is
not necessarily true and we don't care
because we're only going to be doing
these things in one direction when I
find really insightful and useful in
practice is to start thinking about the
data types and sort of ignoring the
transformations it turns out that this
is really practical and this is really
useful in practice this is something
that Haskell and closure has taught me
because it has two nice properties first
of all when you start talking about the
data and not the transformations you
really start focusing on your domain
which is really useful because you have
very important conversations with your
colleagues about what it is that we're
actually trying to model and the other
nice property of this approach is that
for people who are not functional
programmers they get really excited
about this idea of data transfer of data
of modeling data on our system and
without even realizing it before it's
too late
they're already functional programmers
right they they reach the conclusion on
their own that the way to build these
systems is through functional
programming because they have already
accepted that the way forward is to talk
about these data transformations which
brings us to the secret sauce our system
is basically going to be a black box
where we're going to introduce facts
into our system we're going to
in some sort of a log and then some
point in the future we're gonna ask it
questions and is going to give us
answers so let's talk about facts I
think Bruce Lee has a lot to teach us
about system design
he once famously said you must be
shapeless formless like water water can
drip and it can crash I don't think he
was realizing it at the time but he was
talking about flat data because flat
data turns out to be just like water it
can take any shape you want in the
system which is a really useful property
if we're talking about facts things that
are coming into our system and to be
more precise I'm really interested in
the following representation AVT
entity attribute value time it turns out
that this is a really nice
representation for facts coming into our
system because a it's flat B it can
represent any kind of model we have and
lastly it's understandable by everyone
right not not not just programmers
everyone because it models very closely
the way we reason about the world right
entity is just identity and identity is
something that we all intuitively
understand but unless you're a
philosophy major you can't explain it to
anyone this table has an identity
because as soon as I start talking about
this table everyone knows exactly what
I'm talking about right we have things
on the table but somehow they're not
part of the identity of the table
somehow we can automatically
differentiate between these things this
table also has certain attributes it has
certain amount of number of legs or has
a certain color right so it has
attributes and values at a certain time
point in time if in the future I paint
this table a different color the value
of the color changes but it changes at
some time in the future it doesn't
change the fact that at this point in
time this was the color of the table
this is a really nice way to model our
domains but this is a way to model
information at rest
it's not enough to portray communicate
because communication is a protocol
where you transfer information in order
to model this we need to add one more
variable now it's a VT boolean the
boolean tells us whether we're learning
or unlearning facts about our system and
this way we can now communicate the
change over time of information so if
you want to look at this concretely we
have some identity one in our system and
it happens to be named Bob I arbitrarily
chose to use integers for the ID for the
entities but it doesn't really matter
they're just some arbitrary thing in our
system and it turns out that this thing
in our system that we're modeling is a
person and the only reason I know it's a
person is because in my domain I applied
the semantics that things that have
names are people right so this is
something I know the semantics I bring
into the system the model doesn't say
anything about this to be more precise I
learned about Bob at time 100 and to be
even more pedantic I learn about Bob at
time 100 now let's look at what a
transaction would look like we have two
transactions here at time 100 I learned
that Bob likes cats and at time 111
I learned that Bob likes dogs if I ask
the system at this point in time someone
between 100 111 what does Bob like the
system will tell me that Bob likes cats
but if I ask the system later what Bob
likes the system will tell me that Bob
likes cats and dogs notice that it's a
flat structure but it can model
collections now what if we want to limit
our data
what if we want to have a constraint
that says Bob can only like one thing at
a time
well that's really easy model because it
means that in that second transaction we
have to retract the information that Bob
no longer likes cats he only likes dogs
we can model both systems both ways this
of course doesn't have to be manually
done because if you tell the system that
there's
schema involved and it can sort of do
this automatically for you right this is
just a technical detail but inherently
this is the way the system works there's
one additional nice property is that the
values of things the values of
attributes can be pointers to other
entities so this gives you a way to
build graphs and build references so
here we learn of Bob and Mary and we
learned that Bob happens to like Mary at
time 111 and much later in the future it
turns out that Mary also likes Bob and
one last thing I want to point out is
the fact that this is a pointer to an
entity so if for example we instead of
using two I can say name Mary because
this is some way of identifying some
other entity in the system
AVT this is the way forward everything
else that I'm going to show is based on
this so if there are any questions about
this specific thing now be a good time
to ask silence yes value or time so so
this says some entity one this is the
attribute and this is the value and this
is a certain point in time it's a
transaction okay so you can ask the
system about information at a specific
point in time we don't lose the we don't
lose any of the history okay logs we're
gonna get to it actually so hold on with
that this is similar to even sourcing
but it's not exactly the same yes let's
talk about logs so logs are a separate
part of the system because that thing
that I was talking about is just a
representation of information how we
actually store this information as we
store it in the log and more
specifically we stored in an append-only
log there's two reason for that we want
to we want to model total order in the
system this is kind of I
there's always the question of
performance and forget about it it
doesn't matter any business system you
model any that's sort of related to
reality has to have total order because
as soon as you break that law things
will always start working wrong so you
need to fight that urge to have
distributed inputs into your system you
need to have a total order in your
system and there's ways to work around
it where you can distribute the trans
actors and still have total order but
for the generic case you always need to
have an append-only log in order to have
total order and the other thing I really
wanted to mention is in our industry we
have a real problem with business data
for some reason our source code is
really important to us we store it in a
pen Dhoni get ripple weed we back it up
onto hundreds of laptops we create
static and dynamic analyzers to make
sure that it's all correct and so forth
what do we do with our business data we
just throw it around right the most
common case of business data is to store
it in a mutating database with a last
write wins
strategy we don't even know if there are
other rights involved why do we do that
the business data is the life's like the
life and blood of your company start
treating it with respect which brings us
the last part of a system which is no
matter how cool it is to store things if
we can't get that information back out
then it's a useless system at the
abstract it's very simple to create a
system to do this because basically for
any kind of question that we have about
the system we can just read the entire
log and get the correct result that we
want because we have all the facts and
practice that's not practical
because certain kinds of queries are
better optimized for certain kinds of
indices and databases and so forth the
nice thing about this is that we can
model this we can model this reality so
we can build custom databases that are
optimized for answering certain kinds of
questions but notice that the databases
are always fed in in one way from the
log so you can have the best of both
worlds
you store all of your raw data in logs
and then you build custom data
to answer questions and all these
databases are in sync because they all
have the same log as its input source
okay fair enough so let's talk about
queries but before we do I wanted to
take a take a little short road trip to
the side who here can read it understand
sequel so even the people who didn't
raise their hands I assume they can but
who here can read data log one person is
like a which is a really good answer
because this is why I decided to use
data log for this presentation data log
is basically as old as sequel and if not
enough people know about it and I want
you to go and learn it this by the way
is not data log this is the logo for
data script which is a data log engine
implemented in JavaScript that runs in
your browser it's a really awesome tool
so let's talk about queries one kind of
query we often want to make in our
system is auditing someone comes along
and says tell me everything that changed
who changed what when and why usually at
this point we you know if we have like a
standard sequel databases we just go
home and cry right because we lost all
that data but here we get it for free
because we have the log if you want
auditing here I'll just give you the
entire log you can have everything right
so you get this one for free other kinds
of questions we often ask our system is
some kind of relational row query right
so this is what's most common in your
standard sequel database it's the idea
of I have some identity and I have a
bunch of attributes related to it give
me all those attributes well if you want
to do this in a performant fashion we
need to build an index but off of that
log that indexes by EI VT because that
means that we have this ID and we'll
have all the values for it so once we
have this kind of index we can see our
first data log query I'm gonna go really
slow on this one first
notice that we say given a database and
some ID notice that I pass in the
database as a variable to my query I'm
looking for actor names and ages so this
is like select and this is the word
clause the word Clause says give me find
me an eye
identity some entity that has attribute
actor name and this is the semantics
where semantics come in where I
semantically said that in my data set
actor name means that this is an actor
right so whenever something is tagged
would it has attributed a means and that
it's an actor and this is the name of
that actor and the second thing is that
I also want the his age now I want you
to keep in mind two things all of the
variables have question marks and in
this case these two variables are the
same so they match up
they don't log is like day log is
basically like prologue anybody done
prologue before okay so this is like
prologue the idea is that you have a
logical language and these things have
to match there's a constraint solver and
it figures out it finds all the actors
and gives it the same name and age and
just returns a list of these things okay
so other kinds of queries is you want to
do relational columns right and this is
where our databases often usually fall
down because if you give a seat or a
standard a sequel database too much data
it can no longer do column data they
can't do you know like averages and
counts and things like that because it
index things in the wrong way so then
usually what happens is you push it off
to a data warehouses or some oil TP or
something in that nature but the essence
of this is that we just need a different
kind of index we need an index that goes
by a EVT because if we index things in
this fashion then we can opt in an
optimal way say given some database find
me all of the actor ages and give me the
average and because we've created this
index that goes a EVT we can do this in
a very fast manner graphs we often
forget about this but our business
domain is mostly about graphs and in
order to optimal queries on graphs you
need to be able to travel traverse
forwards which we already saw but you
also need to be able to traverse
backwards so we need another index we
need an AV ET index because this way
we're indexing the reverse relation so
when we have something like one likes to
we want to be able to say quickly that
two is this reference
so we want to be able to say who likes
Mary so then you check the two likes one
right so you need to be able to just
reverse the data so here's an example of
a query a graph query which says we have
two actors so given a database and two
actors find me the actor first and
second it's a one and A two then for the
first actor find me all the movies he's
played in and then for the second actor
find me all the movies that he's played
in that match the first one so this
query says find all of the actors that
played in the same find all the movies
that these two actors played in and just
give me the title right I didn't want to
include a longer code a longer example
of code but this is really easy to
extend to n edges so it's really easy to
do pull graph traversals other kind of
query we often want to do is search as
in a full-text search right none of
these indexes that I showed so far are
good at full-text searching but it turns
out we have the technology we have in
there inverted indexes that index by
term to document write things like
leucine and so forth there's no reason
why we can't just set up in an
additional database like a leucine or
elasticsearch or something of that
nature feed the data into the from the
log and be able to in an optimum fashion
query full text searches so this has
given that database in a query I want
you to do a full-text search on this
database with a movie title query notice
here we are using the cue of the symbol
identifier in an interesting way to tell
us that this is some kind of operation
and then so find all the movies titles
based on this quote you know full-text
query and just return to the titles
sorted by score kvt I can go on and on
and on there's lots of other kinds of
interesting indexes that you can build
to end to answer interesting questions
but the point is that all of these
things are possible just with this one
simple data storage mechanism and so
that sort of comes to like the
conclusion of the toxin is in the sense
what do we get out of all this
well first of all I want to point out
one real thing
not a lot of people understand in the
real world your application has at least
three data structures that are
constantly in motion all of your data
comes in in some form of a stream all of
your you eyes are some sort of a
hierarchy tree structure all of them
whether it's a mobile web or whatever no
matter how you look at at the end of the
day it's a tree structure and all of
your business data is most likely a mesh
most architectures don't take into
account the fact that you're constantly
working in three different dimensions
and you need to be able to no matter
what kind of architecture you decide to
use you need to think about this problem
can I can I work in these three
structures at once sensibly I want to be
especially I want to especially talk
about mesh for a second because it's
something I sort of made up mesh is a
graph as far as I'm concerned but it's a
very peculiar kind of graph I find that
in most business domains there's only a
couple core objects to the domain and
everything else is metadata for example
let's say you take Spotify right so core
objects and Spotify could be for example
you have listeners artists and songs
right artists write songs listeners
listen to songs
well what about playlists playlists are
not a new object in our system a
playlist is a new relationship between a
listener and a song so it's a new edge
with certain metadata attached to it
similarly if someone creates a playlist
then other people want to listen to it
they subscribe to it
that's a subscription is not a new
object in our system a subscription is a
new edge between playlists and listeners
that are subscribed to it with certain
metadata attached to it what you find
over time is the amount of core objects
of your domain do not change so if you
model them correctly you'll be golden
what changes is that as you add product
features and so forth new relationships
emerge between those existing things so
you need to be able to reliably model a
mesh that's constantly growing and
becoming more dense what's the ROI on
all this
as far as I'm concerned building an ark
building system this a kind of
architecture it turns out that there are
a lot simpler your reason about both for
users and for developers they are easier
to make changes to it to adapt and
they're easier to test because of all
because all this one my data flows has
really nice properties for testing as
well I think this is one of maybe
several legitimate solutions to how we
can actually build complexity icebergs
versus dependency icebergs now I want to
leave you with some apply theory because
this was all theory the question is how
do you apply this in practice I think we
should all start focusing more on Q's I
think we don't do enough we don't we
don't think enough about Q's in our
system because in the end of the day
your system is just a bunch of Q's
through which data passes if you bring
that out if you make those first-class
citizens a lot of nice interesting
properties just fall out magically I
think we should all learn data log and
declarative query language is in general
but data log in specific this is an
awesome website learned data log today
that org it's gonna take you about two
to three hours with your favorite glass
of scotch to learn all of data log this
is an interactive website where you can
do queries to existing database I think
it was of their movies or songs
something like that so yeah seriously if
anyone tells me they can learn all of
sequel in three hours it's not gonna
happen but you can learn all of data log
in three hours at an easy pace and um
simulation property testing don't wreck
property testing I think we don't do
enough of this I think we need as an
industry we need to do more of this and
it turns out that if you think about
this ahead of time you start building
systems in different ways because you
start building systems that are easier
to test in this way right if you want to
look at practical examples of how people
are doing this in industry check out for
example lamda architecture if you're
interested in the macro level right so
lamda architecture is this architecture
applied at a macro level of the entire
system the entire back-end system so
things like LinkedIn and so and LinkedIn
for example is really known for lambda
architecture right so these things are
being done industry
check out Martin Clements talks and
content he does a lot about he he has a
lot of information about Samsa and
inverted databases and so forth
so basically a lot of the same ideas
applied at a database level
similarly the atomic studied a Tomic
architecture because they tell me
thought really the guys behind the
atomic sout really long and hard about
how to build these systems they were
really a keen insight was the fact that
they separated trans actors storages and
distributed peers and they actually used
this kind of AVT protocol as a protocol
for synchronization of these separate
things if you're more interested in the
client side I really recommend you check
out on NEX it's not even released yet
but they already have a lot of good
videos and other content blog posts and
so forth about art the architecture
behind it and how to build applications
using the kind of this kind of approach
and this all nice thing if there's a any
PhD students in the audience I really
recommend I really think CRD teaser of
the future I think among other things
see our DTS might be the answer to how
we can build how we can have multiple
trans actors and still have total order
in our system so I think this is a
really interesting research direction I
think there's actually a talk and this
today right about CEO duties that's the
end of my talk thank you for being such
a wonderful audience</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>