<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Andrea Leopardi | The Best Library I Ever Designed | Coder Coacher - Coaching Coders</title><meta content="Andrea Leopardi | The Best Library I Ever Designed - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Andrea Leopardi | The Best Library I Ever Designed</b></h2><h5 class="post__date">2017-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tbo7IV8akvs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello hello Thanks so I started doing a
lecture in 2014 I think and the first
thing I did for building the website and
says massively build massively
concurrent christened and distributed
stuff I said like I don't know I don't
have any need for module I don't know
what to do with it so I started just
doing like small things and doing some
NIDA no coding exercises and for like
the first proper thing I built in elixir
was a library and then I did that and
then it was a very shitty one and then I
did one more anyone would be better than
I need one more and it was a bit better
and I've been doing that since so fast
forward now which is 2017 and I've done
like a few and the hope is that I
learned a bunch of stuff in the process
and that's what I'm going to talk about
today so what I want to talk about
mainly is like what is the software
library why do we write software
libraries why do I write sources like my
experience in writing them and talk
about how how you like just tips and the
stuff they learned about writing a
software library so I bought this
remotes and I'm afraid that I'm gonna
like walk off the stage and fall down
because this stage is like ridiculously
small so if you see me fall down I mean
it's okay that's me staring into the
functional programming heaven I work at
so that's why my username I work at a
company called first of football so we
do like a football app with live scores
and stuff and oh I don't care about
football at all like that soccer does if
you like see if you're American so I
don't care about football at all but
it's okay because we really like this is
just like a short term goal the long
term to long term goal is actually
getting all the core team members to
work for us so harvesting code we don't
know what to do with em yet
but we
we do not get them all we're gonna catch
them all quick so three of three of
those already worked there I'm I'm one
so I mean the elixir core team so how
was this this intro was it okay cuz cuz
I hit the same talk I did the same talk
in San Francisco and I neither like much
longer much funnier much like more more
interactive interesting talk and I got
but then they count the talk get
uploaded on YouTube and I got one
comment so thanks Sasha okay I hope you
like this one just I really hope you
like this one not like not even like no
capital letters know like just worth
bursting okay I hope this one was better
so let's get to the to the stuff what is
a library how how do you write one so
first thing is what so what how many of
you use the software library more yeah
it's all of the it's all of them but
someone doesn't want to raise your hand
how many of you wrote soft to library ah
that's nice
so you know you probably know what it
for why we do that so with the reason we
do that is because I think the key word
is abstraction so we did we do write
self libraries to abstract stuff and I
think like in my in my experience in my
experience with like writing libraries
and using libraries of course and
reading the code of libraries I think
there are two main two main categories
of libraries that we end up writing and
they try to abstract to like of the like
tuples of things and I think the first
kind of library you can write is the
elaborate abstract complex code so this
complex code I mean just coded it easy
to get wrong there is a full of corner
cases that is the it's not application
specific in any way so you can be
extracted but it's just like
you just code that you have to really
drill down and and get right and it
takes like testing so there's like
complex code and a good good example I
get is something like a database driver
so that's just that just come like you
need to write code to talk to database
so you need to write code that encodes
according to the database protocol you
need to write code that uses the
network's also the database little
complex stuff but these all complex
stuff that doesn't really it just like
code that no like you don't want to
write comfortable times you just want to
write it once and then use that so this
is the first first category so your
abstract away accomplished good but the
interface is simple this is daily like
you the code you abstract it is can be
intricate but the interface is just like
the bare minimum and then there's like
another kind of libraries which is
leverage that construct patterns and
ideas I think so the other thing thing
you want to extract is this so when you
do when you write software and you do
you recognize start recognizing problems
I start thinking about ideas on how to
solve those problems and thinking about
ideas that can shape the way you solve
this problem then you can abstract those
ideas and you can build libraries that
actually guide you to so like tell you
household problem instead of giving you
the tools to solve it they merge they
shape the way you solve the problem so
this this is the to two types of things
so obstructing complex code obstructing
ideas and patterns a good example of
pattern is like stuff from OTP like like
gem server it's a good example of thing
because that it's not a lot of if you
read the gen server it's not terribly
complex code it's just that it but it
introduces like a countably tells you
how to shape a generic server so it's
introducing I think the value is more
the ideas that it's introducing more
than the implementation because the
implementation is not again not terribly
complex so I try to coin terms for these
two types of libraries I couldn't find
good one so the first kind I'm going to
call let me handle this for you which
means like libraries that you give you
give it stuff and they do the like heavy
lifting and they like grip I stuff back
or do stuff and again a good example is
that a base driver sitting so this is
I'm not like I have two extremes I have
one very very complex and I'm not very
but one library that is small almost
only complex code handling and very few
API and I have another library that it's
mostly API and very few code very little
code so the an example of the other like
let me handle this for you libraries
elaborate obstructs complex code which
is not necessary complex what I mean
abstracts code with a with a small API
but abstracts like code that is
error-prone and and everything is radix
which is a reddish client for a lecture
that I wrote and so this rate is going
this is like basically the API so you
start you start a connection and let the
connected socket connection to read it
and then your issue comments to write it
and you get response responses back
so is it like this is basically the
whole API and it's pretty simple but
when you do start link bunch of stuff
happens so you connect ready to
negotiate the protocol when you do come
and you do encoding you do and the thing
you handle concurrent requests from two
clients to the thing it looks your
connection you decode whether you wait
for this one to come back you decode you
route to the correct line so there's a
bunch of code that's going on behind the
scenes when you call that but the API is
really it's not introducing any any any
new counter terminal not introducing any
idea so this is like one extreme and the
other type of library on the other
extreme is I call here so you angle this
which means libraries that tell you so
here's the you handle here so you solve
this problem and give you just the tools
to shape the solution the tools to make
it look like I want to but it's not like
a lot of code and my personal personal
library
example that does this laboratory
release recently it's called so it's
like a validation and confirmation
library kind of like closure would close
respect that if you know and this
library just basically used to validate
data and confirm data to a certain shape
so and the idea is that so the letter
code for the libraries is it's not a lot
it's very like little code but the cond
a concept that introduces the
consolidator and a validator is like can
will be a boolean function or it can be
a function every turned an updated like
a conformed term and this so the idea of
a validator it's basically what the
value of so what so provides and the
code that he actually provides is just
the ways to combine this validator so
one off for example is like a validator
Combinator that combines the two
evaluators and so the idea is that like
the real value I think that this library
provides is just the idea idea of
validators it doesn't it provides
basically zero validators the only
provide ways to combine the like
primitive ways to combine those
validators and then you build everything
else on top of that but it gives you a
tool to shape the problem here your
Chinese also if you it tells you things
out like right validators and combine
them to do that evaluation so there's a
lot of code but it's like packs like
ideas mostly more than code and this
these two kinds of libraries they
usually there's not there's no hard line
between them so they're just there's two
extremes but the most every say most of
the stuff is kind of like lean it's a
bit in between so you lean most
libraries lean on one side or the other
but there's no like usually they're not
on the on the like opposite poles but I
do think that when you write a stuff
library when you use a social library
it's good to think where this library
belongs between the two because it like
it helps you I don't know put into frame
what the library is for or if you're
writing it
designing because they okay this is like
their library that just abstracts away
hard code I don't want to deal with a
complex API I just want to do that part
and then I do the API on top or as a
separate thing or in my application and
same thing for the for the other I
you're introducing ideas I just want
introduce a I don't wanna provide you
know tons of code tons of code to so
like solve that problem either so so
this is like leads us to the next point
which is how to design a social library
so the first tip was this so try to I
think it's good to try to like category
categorize your library and see if it
belongs either in the in the abstraction
complex coding obstructing ideas and
make a move make easier to to have to
build a nice library then I want to talk
about a bunch of properties that good
good libraries in my opinion share and
the first property I think a good
library should be extensible so when I
when I write a library I try to make it
as extensible as possible because you
can cover all the use cases your users
we're gonna have because you don't know
which one they are so when you write a
library with extensibility in mind
you're basically covering your ass for
when people are going to have problems
that you didn't think about when writing
the library so and you're gonna tell
them right yourself and plug it in
because that that's what accessibility
is about basically and the liquor is a
lot of extensibility itself so it's it's
a core concept I think of the of the
language already if you read a library
for it really clear just make sense that
you share this content as well I think a
good a good way to think about this is
to have like an 8020 rule where what I
mean is 80% of the of the use cases
common use cases covered already in your
library but I've sort of have them built
in your library and have their rest the
remaining 20% extensible what I mean by
this is make your library library
extensible
so that you can plug in everything and
then provide through the extensibility
mechanism provide already a bunch of
stuff that does the most common things
the most common use case it covers the
most common use cases and the restaurant
2% you live to the users that are that
have like more complex use cases or
weird or use cases to implement
themselves I think a really really good
example in elixir of this it makes shelf
so make shell is the behavior for makes
shelf and basically it defines the
behavior allow shell that mix uses
should behave and already having this
this behavior and having the shell
configurable so the shell was computable
at runtime in mix and having that
configurable at runtime means that
there's already the 20% of extensibility
is already there so basically if I want
to write a complex shell and write and
write it and just plug it in but elixir
already provides three like very common
use cases they're covered in the
standard library so the first shell
makes iota shell IO just writes to IO
to the terminal shell process sends a
message to yourself when when we print
something on the shell and makes shell
quiet doesn't like silent assault
messages so these are pretty common your
skates and they're already covered
because you don't want ever be writing
please because if the 80% of the use
cases will be using one of those those
three but the rest the resting the rest
of the use cases that you can cover you
live so extensibility by having the
library configurable runtime another
extensibility point is get out of jail
point if I read this in some blog post
but this I think this is the way you fix
so there I read something else on a
different blog post called the law of
leaky abstractions and this mentioned
that this we said that every abstraction
you think of every obstruction you do
it's going to leak at some point if it's
complex complex and off so leaking means
that you abstract something and then you
lose something that you could do before
abstracting just because you abstracted
this because
of this abstraction so the law so this
is where you lick the abstraction
leagues and if you have to get out of
jail point it's kind of a way to plug
the leak basically and get out of jail
points are pointing where in your
library or obstruction in general where
you can just go to the to the lower
level of abstraction and a good example
to make these concrete is active select
so it's like a query query database
framework for a lecture and it has a
very rich query language built in elixir
but this query language can since act to
support small to databases this Korean
language can support everything that
databases support because there's
something that some that only some
database support there will be weird
stuff that you can do so the way to
obviate that is they provide the
fragment macro but basically you can
pass any query string to the fragment
macro and you still get interpolation so
the question mark there you still get
like escaping and sanitization and all
the stuff you still get come-from-behind
benefits but you can use any arbitrary
SQL expression in the in the fragment
and this is this big you bypass the
obstruction detector so the obstruction
of the query query language you bypassed
by using fragment basically so these are
and you don't leak anymore basically so
extensibility is a pretty good pretty
good requirement for a good library
thing
another one is composability so a good
library should be I think impossible
with other libraries because if it's not
it's hard to use use music usually and
the way you make I think libraries
composable it's a bunch of advice that I
have is first one I think this is the
most important one is to use the
language feeders so if you if you use
the freezers of the language you're
writing the library in this library is
naturally going to compose well with the
language and if father library uses
Peters who's not really going to compose
well with the other libraries as well
and I have a really good example I think
with strings so elixir strings which are
like infinite infinite possibly infinite
lady collections and so Mia me and a
co-worker were wrote a Cassandra driver
I mean two terribly drivers apparently
they wrote a we wrote a Cassandra driver
and Cassandra supports screaming queries
where you paging queries basically where
you have a query and fetch out only like
pages of results from database not you
don't a child hole the whole result set
and the way you so the way we modeled
that in the driver is to basically have
stream pages function so the stream
pages function takes a query and returns
the stream so right away if you call
this it doesn't do anything it just
deals with data structure and in return
to stream and this stream is a stream of
pages of results basically and now that
I have this and the stream is a concept
of the Christian elixir so to come to
the language provides so now that I have
this stream I can combine it with other
features of the language and again
properly choosing tools that are in the
language I don't have to write in the
library until for example we could do
tests the sink screen is a function
takes the stream and maps a function
over the stream in parallel and so since
it takes a stream we can just pass the
sandra stream and we can map a function
over these pages of results in parallel
so when testing stream up the stream of
pages for for a page then we will
actually do the query and we'll spawn a
process and process the result in the
different process and then we can do
something like a numerators and like
combine the results or do whatever and
the nice thing is that in this in this
nipple of code only the first line we
wrote the rest is just for free because
we're using the right to abstraction the
right feature of the language provides
and the nice thing is that potentially I
can write after
I think streams in stock using extreme
returns of stream I can provide
something that processes a stream after
that and I would have composability in
all the you know the directions
basically out of my library into my
library so you can you can do you can
combine it very easily so another thing
that I think is really important when
doing for composability is to know
existing conventions so when there is a
language convention it's usually good to
follow the same convention because you
may have many library to follow the same
conventions and this way they're easier
to compose so for for example if you're
writing elaborated provide say a
function that does something and returns
a result and you can never out if you're
returning something like this so you
live like this is a pretty pretty strong
convention I would say in the lecture
community and you would have ways to
compose composite function with other
functions and with other libraries
because this because they all deal with
something like that and another example
will be if you return error exception
instead of instead of a generic term
then you would have even more like it's
not a really commenting yet but you
would have even more composability
because then you get an error which is
an exception an exception is already on
elixir feeder that you can compose with
other other things and one thing you can
do is you can transform it to a message
and log it or you can rate it or you can
give it to another library that takes
exceptions for example and does
something with them or force them to
never reporting service or some kind
that another thing that so extensibility
composability pretty good pretty grim
and if focus I think is really good so
having the library as well so when you
write a library or use the library you
like the idea is to try to have a
library that is focused on doing one
thing and doing it well and this plays
very very well with composability
because if you have elaborated works
very well on one problem and it's
composable then you can solve like
a more complex problem by just composing
the library and computing the tools and
it's going to be easier so another thing
that a good library I think should have
is easiness of use so if you if you
write a library and it's not easy to use
it's going to be hard to have people use
it and if you use the library it's going
to be hard to use it this is not least
use so it to be easy to use I think
consistency is a good it's a good thing
to strive for so the print prints will
list astonishment is something that says
try to do what the don't break the
expectations of the user with users
basically so try to do what the users
expect expect the library to do so
consistency is one thing the mixing
library is easier to use transparent
hitting so this is a good quite
important point I really like when I
when I do a library and where I when I
when I do a library strive for this and
when I'm making when I use the library I
try to use one that strikes with this
but the idea is that to make a library
that is transparent enough but so the
obstruction is thin enough that you can
see through what this means is if you
abstract away too much it then it
becomes like super painful to for
example understand before to it
understand what's going on and then to
the bug stuff and then to understanding
our resources relegated so resource is a
good example of this so when I when I
design radek's the first thing I did is
that
Cerreta kits just going to give you one
connection to read it and then you
manage how many of them you want to open
for you how many is good for your
application you decide if you're gonna
open them on demand or keep them open so
I give like the decision was to give
control of this to the user instead of
defining sort of having so in this such
as I mentioned about gen gen HD this
morning and this I think it's pretty
good I plugged really well here because
right now all the HP clients that we
have they take a lot of decisions for
you so they decide how to how to do
pooling there is hard to have to do
session to decide out to do
redirects the inside so this takes take
they take a lot of decisions that maybe
you should be taking so they're not the
abstraction is not seen it's quite quite
large because they do the protocol
parsing the actual network stuff than
the pooling all this stuff in the in a
single library but it would be much
easier to work with something that's
comfortable and that is smaller and then
you can do you can decide how many how
to feed the pieces and how many pieces
you want basically and to have an
easy-to-use library you gotta have great
errors so the code above you never do it
I will hunt you if I find this code so
this leads to this leads match error
which is the worst error you're gonna
have because it doesn't say anything so
it's not even I don't think it's okay to
everything your application but if you
have it in a library your criminal
basically and so when you get when you
get this you're saying you know that
something can go wrong and if you assert
that something is not wrong then it's
going to blow up at some point and then
people have to go read the source code
the source code is not it's not a good
way to to learn about libraries which
brings me the next point which is
documentation so you gotta have
documentation
I think documentation is super important
for you first of all so when I write
documentation already for myself because
like when I'm going to go when I'm going
to use the library in six months the
library that I wrote I don't want to go
look at the source code to understand
what's going on I want to just the user
of the library just want to go to the
fermentation they all did this is how
it's done
I don't want to go because I don't
remember the source code of for six
months so so if you write very
documentation for yourself it's good and
then it's good for other people as well
but we don't care about other people
that's that's point so but ready for
yourself it's gonna it's going to be
really nice so we talked about what is a
software library and why do we sign them
they dated we determined to abstract
complex code or to abstract
ideas and patterns so I think these are
the two polarizing parts basically pro
writing types of libraries and then
there's everything in between but I
think when designing is good to strive
for to try to try to lean on one one
side basically and then I said some like
I give some gave some tips about design
libraries one of them is to make them
extensible so that they play well with
the language and we libraries to make
them sorry extensible so that that users
can extend them composable so that they
can play well with the rest of the
ecosystem and the language and make them
easy to use so that they're easy to use
for you and and other people and that
was basically so the idea was I hope
that I gave you credit in tools to build
software library and to build good
source of libraries and to recognize
when a software library it's worth using
and when it when it looks like a good
library and things too I don't know
decide if it's if it's a good library or
not so that we can all improve the
ecosystem and last thing the wiki to
each other here know so the wiki job
this morning there was like textbook
joke I think probably read it off of
Wikipedia or something here gave more
loft blast to him
yeah super well thanks a lot that was
that was great and good for laughs as
always so does anyone have any questions
I can bring the mic over if you have
questions so just raise your hand and
I'll come on over keeper my question uh
you wrote levers for both Redis and
Cassandra adapters right yeah
why did you made like a standalone
adapters instead of Connect adapters so
ready ready doesn't really make sense
with ACTU those actors like for
relational kind of relational databases
so but Cassandra there is an adaptor up
there I think for EXO but I don't know
we don't need EXO so we're ready that
work because we needed it and we don't
need EXO for what we're using it for so
we didn't we didn't look into it but I
believe it's how it will be hard to make
heck to play with so X and raise is a
key value store after all so I don't
know how well it would play with with
ACTU and it doesn't have things like
foreign keys it doesn't I mean the query
language is different than SQL databases
I mean it's similar in syntax but
meanings can be different and so I'm not
sure how well we work but there is one
up there so maybe words yeah all right
thanks
super anyone else have a question
as a story in the monocle wearing a
monocle there's no story in the monocle
just ready me
there's no story in a monocle there's no
no one in the model I just okay rejects
are they always go of my Yap so that
always I get some of them I do get
something so all right going once going
twice last chance for question before we
break all right so that's it that's a
wrap
thanks very much for a super
presentation</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>