<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Eric Meadows-Jonsson | Coder Coacher - Coaching Coders</title><meta content="Eric Meadows-Jonsson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Eric Meadows-Jonsson</b></h2><h5 class="post__date">2015-03-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aI6sH5YawD8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this talk is about the Hicks package
manager and the hex package manager is a
package manager for the whole for the
whole ecosystem and I'm trying to make
that point that it's important that it's
for for for the languages in the
community and I'd like to start out with
a quote from disabled lame that I really
like which is said for why he started
working on elixir and he said I liked
everything I saw in Erlang but I hate
that the things that I didn't see and
that's one of the things that maybe
start working on hex because the package
manager was one of the things that I
hated that I didn't see and that we
didn't have and this talk is going to be
made about hex but to start out I want
to talk about mix which is the bill and
the project management tool for elixir
and hex integrates with mix but it's an
external application I'm going to show a
bit about how that works later on so
with mix we can generate new projects we
compile our projects we run tests for
our projects it handles our dependencies
and you can basically do anything else
you can think of because it's extendable
through what we call mixed tasks and
this is a mixed file and the mix file is
located in your project directory it
defines your project and what you see
here is a very basic way of defining
your project these file ends in da TXS
and that doesn't mean anything else
except that it's a convention for what
we call script files and a script file
is a company is a file that is not
compiled we just run it and execute the
code so we define the my project mix
file module at runtime and set its load
automatically and in this file you can
configure project you list your
dependencies and you can have compile
options and options for other tasks here
and this is what it looks like when you
define your dependencies so here we
define two dependencies pool boy which
is a JIT dependency and we also have the
ecto dependency which for which we are
not defined a way to fetch the package
to fetch the dependency which means it's
going to be treated as a hex package and
we just specify the version requirement
so we have a bunch of tasks in mix for
handle dependencies we have tips get
tips update and so on another thing
makes this is what we call it converts
to dependencies and I'm going to talk
more about this later basically we're
converging does is that we take your
whole dependency tree which is your
dependencies in your dependencies
dependencies and we convert them to a
list to a set of unique applications we
also need to sort the dependencies
because we have compiled time
dependencies because the meta
programming another very exciting thing
we have in mixes what we call repeatable
builds and a repeatable and what we mean
with repeatable build is that everyone
that is using the that is using your
project is going to get the same exact
same set of dependencies and the exact
same versions of the of those
dependencies and we can and we commit
and we can achieve this with the mix
lock file and to lock the dependency
means that we is I will lock such a
specific version and every time we
fetched the dependencies we will get
this version that is in the log file and
only explicit actions by a developer
will will will unlock a dependency so we
have for example depth update that will
update the lock
and this is a file that you should also
commit to version control so that all
the developers of your project will get
this file and get the exact same
dependencies we also support rebar and
make file dependencies and they work as
long as they follow OTP conventions
which most projects do of course and it
can also fetch sub dependencies or rebar
projects so rebar projects kind of work
out of the box with mix and that's
really great because that means we can
use all of the existing great libraries
that exists in the in the in the
community already so so mentioned mixed
tossed earlier and a mixed tasks is
basically a module that follows this
interface its name space under mix tusks
and it has a function run that takes a
list of CLI arguments and when have this
in your project or in one of your
dependencies it will be available like
this as a is it tossing that you can
call via mix and two examples of
libraries that makes use of this or act
0 and x RM so ecto is a library for
building for wrapping databases and it's
a query dsl for databases and it has two
tasks that i want to show its first have
the extra gin migration tasks task that
will generate the boilerplate for a
migration for a database migration and
it will generate that in a project we
also have the extra my great task that
runs the migrations oh and e XR m is the
next project that i won't talk about and
it's a library that generates OTP
releases it makes use of relics to
generate the final the final release but
it can take the metadata that mix
provides and the OTP can fix that we
have in mix and and compose everything
to a final release and this is also how
hex integrates with mix so hex provides
tasks for publishing packages or
registering a new user adding owners to
packages and so on and we are finally at
X so like I said earlier Hicks is a
package manager for the early ecosystem
for the whole ecosystem and I said that
because I think it's very important that
it's not just for elixir it's for the
whole ecosystem and you can also you can
already push erling packages and there
are quite a few land packages and eggs
already and and I'm going to talk about
later about how you can use mix for your
earlham projects and other airline
tooling that are starting to integrate
with Hicks so this is the bragg slide
this is the number of package downloads
per month so we started out last year in
May and last month in February this year
we had almost 200,000 package downloads
so that's very exciting and it's growing
as you can see so so that's great to see
I think so now going to talk a bit about
how Hicks integrates with mix and mainly
does that through mixed tasks it's a
standalone application like I said so
it's not bundled with the liq sir like
mixes so when you install elixir you get
the bill to mix in the whole package but
hex is installed separately and this is
kind of because sex is much newer it's
much newer than elixir elixir has
reached 1 point 0 and hex is still in
the better stages
it so this is an easy way to do it and
in the future we might bundle hex with
elixir or we might continue to have it
separately because I actually working
quite great still and it's just an
example of Hick's toss that we provide
so there's task for reversing new users
publishing packages updating your
registry file and so on and hexes
install as a code archive and for those
of you who don't know what a code
archive is is a very basic thing
actually it's just a zip file that
contains beam files and application
files and it's not an elixir feature
it's an feature of the of the color that
comes with that comes with OTP an accord
archive just looks like this so this is
basically what the hex code archive
looks like we give it a we named it for
the version so that we don't have
conflicting versions where the app file
we have and we have all the module bin
files and when mix starts we load all
these code archives so basically add
them could to the code load path in your
home directory and this is a real great
way to extend mix there's one issue with
karakas though it and there is that they
are one it's an it's an issue for elixir
because it's because it's compiled code
and with a and with elixir we don't have
the same binary compatibility that's
that that that that OTP has so we need
to make sure that we match the elixir
version with the code archive version
and to make that streamline we need to
make sure that
updating the archive is really easy and
mix provides tasks for installing
archives and so on and we do this by by
having a mix tossed that install sex and
it basically it just goes down URL and
it downloads hex and it and we give the
elixir version inside the URL so that we
can install a version that match the
elixir version and we also include only
Hicks versions in the registry file
which contains all packaged versions and
I'm going to talk about register file
later so this way we can inform users
when there's a new release of hex so
they can update it and finally it
integrates with mix through the remote
converter and the remote converter is
called by the converter which I'm going
to to talk about just in a moment and to
talk about that whole flow i'm going to
talk about the flow or what happens when
you run the task that fetches
dependencies so the first thing we do is
run the converter and the converter it
traverses your dependency tree in a
breath for free in a breadth-first
fashion as its as its as it is
traversing it is converging dependencies
and converting a dependency means that
we see if they have the same application
name so then we need so then we know
that we need to convert them into a
single application and we also and we
also do shakes like see if they have the
same sem so that they both use jeep they
both need to point to the same git
repository they need to have the same
branch or tag or reference and we try to
do this converging if the conversion
fails we say that the applicant that the
dependency
is diverging and we inform the user and
the user can then see this error and
they can idle handle it by fixing it or
they can fix it by specifying an aid so
they can fix it by defining a dependency
that is overriding at the top level
project so that deserves so there is one
way to always get around the issue and
as we are converging down we fetch
dependencies we frigid appendices we're
skipping hex packages at this point
because the hex package dependence
resolution is a different it's a
different thing that we need to do at
later stage because it's a bit more
advanced then it's using because we have
the whole registry we can do the
dependency resolution in a much smarter
way and I'll talk about that later and
finally we need to sort the dependencies
because as I said earlier we have
compile time dependencies between
dependencies so we need to sort them to
make sure that we compile everything in
the correct order so after the mix
converter run we have skipped the hex
packages so then we can run the D remote
converter which calls into Hicks and we
call into hex giving all the hex
packages we found during the original
converter run say it took it into a
converter and before we can run the
dependency the dependency resolution
algorithm we need to update registry and
the registry is just the it's very
simple thing it's just a simple ETS file
which we so it's an e testable that we
store to a file and it just have has it
has all the packages all the versions of
those packages and for each package
version pair we specify all the all the
dependencies
and all the version requirements on
those dependencies and it's any test
five today because it was a very easy
way to do it we can just purchase the
test table and it's very easy to
distribute one problem though is that an
ETS file is not really optimized for for
storage it's a it's not optimized for
space on me so today we have around 500
packages and almost 2,000 versions or
those packages and this file weighs in
at around 350 kilobytes and a bit over
100 kilobytes compressed so we need to
change the registry format at some point
in the future because this is not going
to scale in the future and we have a few
ideas for hard to do that but it's not a
big problem yet because it's still only
because still own just a bit over 100
kilobytes to distribute so to fetch the
registry we can continue with the
dependency resolution algorithm and the
dependency resolution algorithm tries to
find a matching set of dependencies so
if you remember from the last slide we
have the requirement so it so every
package specifies the version
requirements on own its dependencies so
when we have those version requirements
we can run on a resolution algorithm
that finds a set of dependencies that
are insured to match or in short match
if if the requirements are correct and
we are recommending everyone to use
semantic versioning and it's not perfect
because there's nothing assuring that
you're not introducing breaking changes
and so on but it's it's been working
well so far and I think it's basically
the best thing we can do so the
dependency solution algorithm starts by
getting all the
hicks packages from the from the
converter and those are called pending
requests so pending requests are our
packages that we have jet to process in
the resolution we also have a list of
activated packages which are packages
that we have find a version for and that
is the version that we're going to use
so number one we start with the packages
we got from the converter on the next
step is to take the next pending request
which is the next package that we have
yet to process we find the latest
version that we can use that we compare
so we basically get just the latest
version we compare that against all the
activated packages requirements and we
we first tried it for the latest version
and they will try all the and then we
try all the all the other versions to
see the match if nothing matches we're
going to backtrack which will get back
to later but if it but if we do find a
matching release we activate the package
when we activate it we add the
dependencies of the package to all the
pending packages and we save the current
state for backtracking so it's to save
the current point in the resolution so
that we can go back this place if we
find an issue later on so with this
algorithm we can find if there is the
matching set of dependencies we're going
to find it the problem is that if you
have a very huge dependency tree this
algorithm has the potential to take a
very long time because it's basically
trying all the different it's trying
it's going to try all the different
combinations of all packages it's as a
few shortcuts so we haven't had any
issues with this yet but we're kind of
testing the waters to see if this is
going to work and another problem with
this algorithm was that it was very hard
to find so if there was a problem in the
resolution it's very hard to say to the
user where this problem was because it
could be
any because it could be it could be a it
could be any combination of our problems
but what we find was that every time
that we do a backtracking we can find we
can say the version requirements that
failed and we print those to the user
and those are a good indication what the
user can do to fix the issue so finally
in the depths gate process we're going
to fetch packages we do this by doing
HTTP requests to to the CDN where we
store the packages we are starting to do
parallel fetching of packages which
improved for Miss a lot and we are going
to work caching the packages locally so
if your net is going to go down or
something we can use the packages that
you have on your computer and even
before we started to doing parallel
fetching this was a lot faster than
fetching by shelling out to jet or
something like that to to fetch packages
or two fish dependencies so next I'm
going to talk a quickly about what a
package looks like when we distribute it
so this is a package turbo so it's just
a in uncompressed rball which contains a
version file which we can increment if
we're doing breaking changes for
packages for some reason we also have a
metadata file which describes the
package and a shake some for integrity
and then finally we have a compressed
tar ball inside which we call contents
which contains the source code of the
package and the reason we're using
source code is basically because in the
lick sir we it's very hard to do
pre-compiled packages and that is
because so meta programming someone
depending on a package can specify in
there in the configuration something
that changes the d produced compile
binaries so it's just easier to do
source code I'm going to talk a bit
about ideas about doing precompiler
packages later on you can also use six
with airline we have is what we call
standalone mix which is just an e script
with elixir bundle so you can use mix
without installing elixir and you can
use mix for your projects mix can
compile a source code for 40 TP
applications and you can use elixir for
configuring your application and your
OTP environment and I think that's great
because elixir I think it is a good
language for for scripting and for
configuration and there's a project
called mixed Erlang tasks with which you
can find on github and i believe it's
also on hex now which has a few which
extends mix with a few tasks for testing
applications so it has common test the
unit and a task for generating
documentation so if you're so if you
want to try out mix with your current
projects you can check this project out
and hopefully it can help you by
providing tasks for your for your common
things that you do I'm also going to
talk a bit about the about xpm which is
what we call the api server and the
website on the website you can find
documentation for packages you can
browse and find new packages we have
download statistics and so on and we
just use the API server for basically
just registering you use
and publishing packages so all the
registry and the packages the package
tar balls are distributed separately so
that if the API server work to go down
for some reason we're not going to break
your deploys or or your or your or your
or your workflow and this is just what
the what the store page for the website
looks like and like I say we also host
documentation there so you can use X
unit X doc sorry it puts the X talk to
generate your documentation and to do
this you just call mix X docks which
calls into a the documentation
generation and then it's going to sip
that up and upload it to to hex docks
where we host your documentation and
this is an applicant is just an example
what that will look like you can also do
that for your Ireland project so s
broker ism is and is a project that is
using the sister that is distributed
through hex and you can just call into a
doc so you can just replace the the docs
task that X doc provides with a the task
from if you remember from here if you
just use this project you can upload
documentation for your projects easily
and mix aura has support for building e
scripts but we're also going to add the
support for installing these scripts
globally and E scripts are just a a just
a compiled binary with the beam code
that you can run from your shell and and
if you remember earlier this is what it
looks like to define your dependencies
and we're going to use the same format
for installing a script so you cannot
you can either go through through jet or
through Hicks and it will fetch the
jetpack the dependency or the hex
package and we'll use the existing
functionality for installing for
building these scripts and then it's
going to install it somewhere on your
local system where you hopefully have
your path pointing to and this is this
functionality is going to come in the
next minor release of elixir which is
going to be 1.1 fine I want to talk a
bit about our line tooling and how it
can integrate with hex so we have a
rebar 3 that is being worked on by Fred
and Tristan which is a new version or
rebar which is still being developed by
believe yes and we talked to them and
they are in the process of using of they
are in the process of implementing
support for hex and we have also been
talking a bit but with the OTP team
about their plan package manager if you
remember there was a discussion on the
mailing list for IDs for an OTP package
manager and we'll be talking without p
team and seeing kind of what we can use
if we can work together and it
I think it's looking promising the
things that we showed each other was the
format the idea for formats for metadata
and so on it's very similar to what we
have today in hex so I think that can
work great and rebirth three rivers
three also it's looking promising they
had requirement that I want to pre
compile packages and like I said earlier
the current packages are just being
distributed as source code because
elixir because easier for leaks or
applications but for but for but for OTP
applications it's it's much less common
that your compiled code is going to be
different because of some kind of
configuration it's almost always exactly
the same the only thing that you need to
to keep in mind is that you need to tell
you that that you need to recompile for
every new major runtime version so we're
working with them and we have a proposal
for how to do pre-compiled packages and
let's look at more promising and I think
rebar 3 can use Hicks and it's great
because the goal will with hex has
always been to be for the whole
community for the whole and for the
whole ecosystem so the idea is to have
one shared specification and then we can
have multiple clients and multiple
servers that are implementing the
specification and the specification is
just to share the same format with the
registry we share the same format for
the package so that we have the same
format for the tour balls and how they
are laid out and also the same HTTP API
so that everyone can publish new
packages the same way and this is great
because it means that we
can still have many different build
tools we can have rebar we can have mix
we can have built tools created by the
by the OTP team but they are still
talking the same language when it comes
to the package management and that's
great because that means we can all
focus and have packages on the same
place or at least find packages in the
same way and we don't even have to have
the same repository for the packages we
don't have to have hex PMX p.m. can be
one alternative and then there can be
curated repositories for those that like
curated repositories and so on they can
be one repository for example for all
the applications in the OTP distribution
so that the that the OTP team can
control so that is the big picture of X
that we can that the idea is that we can
all use it in the end thank you that was
everything from me
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>