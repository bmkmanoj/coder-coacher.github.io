<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A CutEr Tool by Kostis Sagonas | Coder Coacher - Coaching Coders</title><meta content="A CutEr Tool by Kostis Sagonas - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A CutEr Tool by Kostis Sagonas</b></h2><h5 class="post__date">2016-09-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5p1hFpQqPBs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so thanks a lot for the introduction is
it on my okay because I don't see it
here but it's fine so this is a talk
that is very similar to the one I gave
in San Francisco although I have changed
some of the demos so this is a tool that
we have been working for the last
approximately one half years so Allah I
have a lot of slides but I will actually
try to do most of the things in demo so
this is in the area of testing as you
well know and i will introduce a
different forms of testing that we have
in in general in programming languages
and in Erlang in particular and then i
will show with some examples what con
colic testing can do for you and how it
easy it is to to actually use and also
all the different things that you have
to be aware if you're using a con colic
testing tool so let me start by saying
that testing is important I hope that
you will agree with me I think if you
haven't tested your program it most
likely doesn't work and the most use the
most commonly used method out there is
to write some unit tests now the and
there are various xunit frameworks
including the unit framework that exists
in our language p now the problem with a
unit testing is that very testing is
that it's typically a manual process you
have to specify both the correctness
criterion that you need to specify that
you need to have end the inputs that
produce that particular output so you
have to specify some relations between
inputs and outputs so most people do
unit testing up to a point I think there
is really no replacement for unit
testing but it only takes you that
there are more automatic ways to do
testing as you probably all of you know
in particularly functional languages
they have pioneered the idea of property
based random testing and there are
plenty of tools out there in starting
with the classical quick check and then
the various variants of quick check that
have been in the earlier world including
my most level it one proper which I will
shortly demo now the problem with the
property based random testing is that
it's a semi manual process you get
typically some support for generating
random inputs but you have to specify a
property and also if you if you have
complicated programs actually takes a
while to write a proper generator for
them so writing in something that
generates correcting puts is something
that is not so trivial once you go
beyond simple examples moreover it's a
random process it doesn't give you any
sort of guarantees that your program is
correct afterwards it just might find by
some bugs and typically finds a lot of
bugs and I think should be using it but
it you don't really get any guarantee
after you don't find any more bugs you
have actually no clue whether your
program works or not so let's see some
demo here so this is a function in
Erlang my classify function it takes
some term and checks whether the term is
less than 17 and it classifies that
small if it's between 17 and 42 it
classifies at medium and if it's greater
than 42 it classifies at large okay and
I think most of you can see that this
this is not a total function if there
are some cases that it doesn't handle
and I will specify here my correctness
criterion to be really really really
simple my correctness criterion is that
this close that implicitly gets added by
the compiler is not reached okay so i
will never throw a bad match error if i
call classify so i have this program
here it so happens that I have it and
this is the classified function you can
see the exactly the same and i will use
proper to find out whether this one if
this property holds or not and the
property i will try to test is that for
all the ends that are a number if i call
classify the result is one of the small
medium and large basically that this
function doesn't crush so i have already
compiled this program and i will run now
a hundred tests and it passes in another
hundred tests and still passes another
hundred tests and still passes oops i
want ah finally after about four hundred
and forty six tests i have found the
error okay but what about this program
now it i found the error because 42 is a
very important number so i make sure
that proper generates it every now we
know why every once in a while but what
about this program here will i be able
to find this so let's change the program
to have 4 7 11 here and for 7 11 here i
save i will recombine and i will run
Henry tests so let's run ten thousand
tests
it didn't find it even after ten
thousand tests I can run a hundred
thousand tests it still doesn't find it
okay so you have I hope I have convinced
you that with property based testing you
have absolutely no guarantee that you
will find the error that your program
has even though i think if you show this
to any of your colleagues at work they
will find you that tell that here there
is actually two values that you don't
handle not just one there are two values
that we don't handle in this program so
now i have used here a very very simple
correctness criterion i have said that
my correctness criterion is that this
close that is the compiler generated is
not reached but of course i can add my
own correctness criterion wherever i
want with assertions basically here
what's happening is that you have a
pattern matching failure and i can add
whatever assertions i want just with
pattern matches and what about this
program here so if i give it now a list
and i won't tell the sum of the list to
to be classified as small medium and
large based on this thing so now i need
more sophistication for the tool so or
whatever i can add whatever assertions i
want with pattern matching in wherever I
want in my program okay so for example
with this pattern matching hear you say
that I want my F function with some
arguments to be returning a list of at
least three elements where the first
element is 42 and the next two elements
are exactly the same ere long term okay
so i have a very expressive language to
also add my assertions wherever i want
them
now how can we use that sort of thing we
can use it in with something called con
colic testing con colic is not English
word it's a made-up word out of the
combination of concrete and symbolic now
the nice thing about this technique is
that is fully automatic you don't have
to specify anything you just run the
tool you don't even have to specify a
property that you want to to verify or
falsify you just find all you just have
to put your assertions whatever you want
to do a program or find out whether your
program clashes with some inputs so the
approach actually aims to achieve high
path coverage and if it you it will
explore all the paths that there are in
your program now typically this is a
very big number and we're going to see
that in in practice it doesn't explore
all the paths because that will take in
big programs forever but it does achieve
very high path coverage so let's see how
we can use this thing so i can write
listing the cuter tool and i give it as
an argument the module name it's called
the you see not this one I don't know
this is the hugest one that exists in
this type of terminal i'm using but
don't worry because i think it will be
very easy to see so I'm calling the
module name EUC with a function that I
want to test the classify function and I
just give it some random input I've
chosen zero here but somebody else might
have a better number to give me not 42
because you will find immediately but
let's say some random number is this a
random number yes so it compiles the
file and it finds you
but actually it fails with 4 7 11 and 47
11.0 because the spec I have here this
takes a number I didn't even say
anything about integers as a matter of
fact I can't a I can say that this is a
term and again it will find exactly the
same inputs that make the program fail
ok don't worry about this at this point
ok now what about the other program that
I had let me something like this one I
will comment out this one first the
least some so now what I want to do here
is my function here is called classify l
and takes a list of numbers and I want
this to fail if I give it an input list
whose elements some 24 7 11 or 47 11.0
so of course now I have to give it a
list of a random number as it a seed an
empty list ESS
and it gives you now a list with 47 11.0
and at least with 4 7 11 and a list of
size 2 whose if you do the addition you
will see that these two numbers add 24 7
11 sorry i don't have bigger font for
those of you that are vision challenged
now what about this one I cannot comment
this one now if the list has length less
than four i classify this as a tiny list
independently of the elements that it
might contain so the second Clause is
only reached if I have a list of length
foreign above now I will do that but now
i will run this in parallel also because
cuter runs in parallel so i will say
that i will use for solvers and for
Polar's ok so my laptop doesn't have
more than it has only four cores with an
eight with hyper-threading so it doesn't
really make that much it doesn't make
sense to make to use much more than that
so let me see what it does now it finds
no runtime errors no run time error so
cute it doesn't know in the beginning
sorry I'm sorry if you don't see it I
see it on my screen so I don't really
know what you're seeing so let's give it
a bigger depth to search deeper industry
let's say I give it a depth of fifty
so it finds now an input that is a list
of four elements that if you do the
addition for those of you that can do
addition fast enough it it will it will
add up to 4 7 11 as a matter of fact it
gives me now a a weakness and if I don't
you know I can out run this and get the
exception so I have also a case that
makes my program fail and of course the
least some of this is for 7 11 okay so
this was fun but what about if i do this
i substitute this guy with this
it will better be the same
it better be the same okay this was not
something particularly exciting but what
about this one where do I have it this
function here let me take it up so that
you see it what about this function it's
like the previous one but now it takes a
higher-order function is the first
argument and the list as the second
argument okay so are there any
combinations of functions of RIT to that
return a number that if you give them
them to fall del with a list that has
length at least four it gives you a
crush so how this is called FL I think
right so I just need to write to change
a single character whoops no it's not a
narrative to is an era t it's all a
narrative one is an RT to write so I
have to give them a function here so let
me give hit a very simple one it takes
two arguments and returns 42
plenty of inputs that lead runtime error
let's see the first of them if you give
it the least eight seven six five and
the function that takes 8 and 0 which is
the accumulator of the valle del and
takes you 24 and then seven the next the
second element of the list and for it
gives you 2 0.0 and six with 0.0 it
takes you 2 3 and 5 with three it takes
you 24 7 11 if you don't believe it of
course you can just take this start the
Erlang shell and just oops not crushes
okay so i think i have convinced you
that this is actually quite powerful
it's a very automatic testing tool that
just requires you to specify the unit
that you want to test here it's just a
single function but can be a whole
module below it or a part of a module or
many modules you specify an entry point
which is the unit that you want to test
and give it some random inputs that
there might be a good idea to actually
make some sense so that you don't also
see this as an error okay if you just
give it a random thing he here like
rather than giving it this I give it 42
this will also crash obviously but for a
different reason nor actually this is
the empty list so it will not even use
this but sale with this list what
happened hmm oh yes yes I need a list
Thank You Simon one two three four oops
three four yes
huh no no this is this fails it tells
you that this input fails also the input
that I just gave but this phase for a
totally different reason because they
are not typed correct we try to call as
a closure you try to call it a
higher-order function the number 42 so
you better not give something that
doesn't work because you will see it in
the input suddenly to runtime errors and
we don't probably go what to do that you
want to see the other inputs but you can
just give it random term Slayer really
so how does it work under the hood so
the idea is we are going to do a
simultaneous concrete and symbolic
execution that's what Khan colleague
means and during the concrete execution
we are going to collect some symbolic
constraints on the program inputs and
we're going to record this quote
symbolic constraints and we are going to
see which branch is the rich so then the
symbolic constraints we are going to use
them to force the execution to go to
some other path by negating one of these
constraints at the time so the it has
some nice advantages over both concrete
testing and symbolic testing alone
because the concrete execution makes
available accurate information about the
program state which may you may not have
without also a concrete execution if you
just use symbolic execution of the
program symbolic techniques for testing
by the way they are been around since
the middle of 70s or late 70s so it's
not something that has been invented
yesterday and yeah so you get much
better coverage in this way that you
will get by random testing tools or by
just symbolic techniques alone so
so you collect path constraints as you
do the concrete first execution and then
you record variables that depend on the
input that have some dependency
typically some control dependency on the
input and you express this path
constraints in some appropriate logic
and we offload all this thing two very
powerful tools called SMT solvers or you
can use just a constraint solver if you
have one around to solve these
constraints and generate now new inputs
that will steer the future test runs to
explore some unexplored paths and if we
do that sort of thing or systematically
we will eventually cover all the paths
that our program cuts now as I said this
is a big number in practice or you
cannot actually do that but still you
get much much much better coverage and
also all the tests here have the
property that each of them follows a
different path there is no like it's not
like random testing where you might be
following the same path again again
again ok how much time do I have 15
minutes 20 I have plenty of time so let
me now explain how it works under the
hood so let's take this this example
here I have a compare function that
checks its input it's very similar to
the previous one and then I have an F
compare function that takes this one and
checks whether its result would be GT or
LT obviously I'm not handling here the
42 case and then I have some other
function above it that does a list for
each on this function and export only
this one which is my unit of test so if
i run this program where i will work you
to run this program is in its in the
berlin representation so i will take
what the coral and compiler produces
which will be this program and you can
see that it has to failure points it has
the case that I'm not handling here they
kill returned from the compare function
and it has a case that is fails here
because this function is not handling
the 42.0 case the floating-point 42.0
just to see it again this does an exact
pattern matching with 42 not with a
float 42.0 so there are two points in
the program where this can this can fail
and we want to find these two programs
automatically so let's say so if you
look at this program as this called this
functions as control flow graphs they
look pretty much like that the F compare
function has a branch here this case
that checks whether the return is for GT
and if so if not if so it returns ok if
not it goes to check whether it's the
return of the compare function call here
will return LT and if it does so it will
turns ok otherwise it goes to the other
branch and go through to the fey label
the same for the other function now what
happens here is that let's say that we
call this with as input the list with
just 17 so the list was just 17 it will
check do I have a non-empty list yes I
have a non-empty list so i will go to
the true branch is my input greater than
42 actually it's not great on for 217 so
i will go to the false branch branch is
my input less than 42 yes so easy why GT
know is why LT yes
and so on and so forth so this will just
explore one path and will not find any
error with a list of just 17 so now what
we're going to do is we're going to pick
one of these constraints and negate it
so the first thing to do is here we
follow the true branch so we had a a
non-empty list so now we're going to
negate this and try to get the empty
list but with 17 with Ali 17 and the
empty list is doesn't this is
unsatisfiable you cannot satisfy this
constraint so you don't have any
solution that is both non-empty list and
empty list this is not the interesting
case so let's go to the next one so now
I want a list that is non-empty and its
head to be greater than 42 now this
constraint has a solution let's say the
list with element 40 50 for that the
constraint solver gives us some random
value 54 so now we will explore this
path actually this path will not really
lead to the error so let's see what
happens afterwards now we need to negate
this Chris conjunction of constraints we
have a non-empty list the head should
not be greater than 42 now because it's
the opposite of the other one the
negation of the other one and the head
has to be equal to 42 so we go to the
true branch of this check here of this
test here so there is only one list that
has this property its head is not
greater than 42 and it has to be 42 so
it's the list with 42 so we have already
found a case where it fails this
particular example
so by doing this thing systematically we
do this sort of thing again and we
explore all the paths ok so this
constraint here believe it or not in
Erlang is satisfiable these are not
arithmetic stuff this is a term
comparisons so that is the least value
42.0 that is neither greater than 42 nor
less than 42 and not doesn't match with
42 ok so that's how it works I gave you
some idea of how it works under the hood
but you actually don't need to know how
it works under the hood most of you at
least unless you want to contribute to
its development so the thing that is
using is it needs some search strategies
that explores all the all the paths so
we use some heuristics to to guide the
search towards various points of
interest and we use this depth that
counts how many k statements we are
allowed to reverse you might have a
program that goes on forever its
execution so you need also something
that makes the testing finite so you
have this D this D option that we used
here we did this with depth 50 in this
particular case there is a default depth
if you don't specify this option
okay let's do one more example I think
it's this one so suppose that I want to
test some module i have written so in
this particular case i will cheat i will
not write a program i will use some
particular program that exists in the
Erlang library the function day of the
week from the calendar module okay so I
want to test whether this function from
the calendar module actually works for
all inputs so this is the module EUC
three my function is called t calendar
and takes three parameters the year
let's put 2016 the month let's put nine
and let's put nine today's date okay so
this will run this and give you that
this one fails for many many many inputs
you
so it fails for all these possible ways
of calling the calendar module but hey I
mean nobody really wants to call the
calendar module with the empty binary as
the first argument this is not how it's
supposed to work so how can we do here
how can we use the tool well we can add
a spec I can take the speck and say that
I want to observe I want to use this for
non empty integers as years with man
that are between 1 and 12 and with days
that are between 1 and 31 which is what
you would expect so let's now run this
again
and it enumerates all the months the
curve that don't have 31 days they have
30 days so that even the type language
the message is different even the type
language here is not expressible enough
to filter out combinations of these
arguments that are not valid date so
obviously we do not want to get this as
as wrong inputs to the function we want
to see if the function actually has some
really validate that makes it crush it
doesn't handle it so what can we do
about this sort of thing well we can do
the following
there it so happens that in the calendar
module there is a there is a function
that says that checks whether a
combination of wise Em's and DS is a
valid date or not so we want only to
check whether the day of the week
function works correctly for all
validates so now i will write this as my
wrapper for my test i will exclude
testing the calendar day of the week
without it III function with things that
are not validated and of course you can
write your own filter here for all your
functions if you don't have such a such
a convenient function laying around in
your module so now I can run this and it
will actually find that there are no
runtime errors for this depth and
actually for any depth in this
particular case okay so you need to add
some specs and whenever the types are
not expressive enough to express your
real constraints of your inputs you need
to write a filter function that checks
the input before it calls what you want
to call there is no error in the testing
function you might you might have an
error in the check that tricks you have
to check the valid date before so here
is I can I can test my validate before
as a different unit and after I have
verified that that one is correct then I
can use it okay now all this is very
nice i'm showing you small examples here
and some of them are more impressive
than others i also have some really
really complicated ones
which you can see by following the video
in San Francisco you can see for example
the tool handling functions with a y
combinator and it manufactures functions
that if you apply them to other
functions it will give you something
that clashes but i will not do that here
i will just show you some real example i
will skip this thing so so we'll do a
bigger unit here to test there was an
erlang bug sorry a posting on the
airline bugs mailing list when we had
the mailing list last year in May and it
involved the particular module from the
OTP libraries and the posting is this
don't have to read all the details it
was by like and it says some of my
application won't compile anymore
because they have the ssl negotiate next
hour instead of some other function here
and i get crushes in OTP internal ok so
it was a compiler bug it so happens that
I have this which has been fixed so for
since then it so happens that I have
here this module hey I have renamed to
OTP int as opposed to OTP internal so
that it doesn't clash with the one that
exists in the thing and as you can see
it's actually quite big not very deep
but it's actually quite big it's 641
lines of code so where is the bag here
what crashes here you know of course you
have the posting by like so it helps a
bit but let's say that we didn't have
that and we want to actually test it so
this is a function called OTP module
called OTP int and the function is
called
so leet and it takes an FA so I will use
a long length with additive one oops of
course I'm going add wrong directory so
it runs and now I can explain what is
dots a nexus mean these dots are cases
where it follows successfully some other
branch because the constraints were
satisfiable and the axis means that I'm
trying to follow some other path but
there is no solution from the constraint
solver let the constraints unsatisfiable
and an occasional I you which you don't
see here even if you have very good
eyesight because doesn't help happen is
that the constraint solver has timed out
so so here we have found a case that if
you call this obsolete function with SSL
and negotiated protocol with a little
one this clashes and actually will be
this is the only bug that exists in this
module because you will see that
finishes for this depth but actually for
any depth because here you just need the
depth of three actually to explore fully
all the search space so if you happen to
have a 64 code machine lying around this
will actually be much much faster
believe me I don't have that sort of
thing and actually not my laptop doesn't
have a fun and has overheated and it's
very very slow but yes it takes a while
of course to fully explore all the paths
that might exist in a program especially
as programs become bigger and bigger but
you can explore them in up to a certain
depth so I'm wrapping up here I would
like to say that this is a tool that is
available on github it works for various
things it doesn't work for everything of
course it's under development we support
17 our language ep 17 and higher I would
very much recommend the higher versions
because we have actually put some
supporting some modules of ATP for that
so there are various known limitations i
will just mention the current one the
ones that are most important for we need
to add some symbolic information for
many of the beefs that exist in the
Alamo TP library and we add this
information as we happen to hit it so we
don't support all the beefs yet
symbolically so you might get something
that says I don't know about this
particular diff so please when you get
this reported by sending as a program
that needs this particular beef to be
exercised we don't support maps at all
with support binaries we support lists
with report apples we support integers
floating point numbers items but we
don't support maps yet and the support
for recursive data types that are
defined in some other modules by type
declarations is still very incomplete
and we don't support concurrency this is
just to explore all the paths in a
program this is not something that we
just concurrent programs you test that
you have covered all the all the cases
in your program
but this is open source so contributions
are very much welcome and especially
opening up issues that you might have if
you tried it I think I will stop here
and I'll take questions channel message
passing quite culture genetic server so
I the question was does it handle
message passing on the generic server so
as I said it doesn't handle concurrency
so this explores it will handle receive
and send as built-ins it will handle all
the code of the generic server but it
will not this will explore just the
paths wrapper in the program not the
different interleaving that you might
have between processes this is not
something that explores process
interleaving this is explores data non
determinism it finds input for which
your program will crush because you
haven't handled something in the in the
in the pattern matching typically high
yeah and I still have many questions
whether I was wondering you mentioned
that symbolic testing has been around
for many years every video and con
colleague testing assistant previous
work so what was challenging here for
playing on calling testing in a
functional language that perhaps well
it's a second of all we need you honey
to handle all the data types also we are
among the first tools that are doing
that sort of thing in the level of a
code language the tools that have been
for con colic testing of imperial
imperative languages are doing it either
on assembly the ones that are for sea or
in which case you only have integers
effectively and pointers but they are
really integers and they all they do it
at the level of the Java Virtual Machine
the ones that are for Java but they are
closed source so I cannot really tell
you more about because I haven't seen
them here one of the challenges to
actually do it at
level of language that is much more
higher level second we need to handle
higher order functions and as you saw we
are actually generating higher-order
functions we are generating the
constraints that will give us the
correct higher order functions I don't
know of any any other tool that does
that sort of thing all right thanks and
one quick question what was I a fateful
code it will do the side effects it's
concrete execution right you get the
concrete but when you go to a symbolic
and you take the other branch there
might be some side effects there you
cannot execute but the side effects
don't affect the the control flow what
they might okay every execution is start
from beginning so that's not a problem I
mean if you have some stateful thing you
have to of course right to a rapper that
does the cleanup and the thing this is a
unit test and you have to execute the
unit test many many times and all right
you know if it sends a bomb and destroys
the universe yes it will destroy the
universe but that's I mean how would you
test this thing in in just unit testing
no I'm not criticizing it no it's not a
matter of criticizing is that you have
to handle that of course yeah I don't
well we can discuss offline but I'd only
that you know which side effects you
might perform quite a while actually the
old examples were with pure code right
so yes yeah there you go okay but we can
chat I'm glad to chalu you after all so
the properties that you've been testing
now is just if the program crashes or
not but in you know quick shake like
stuff you we can we can specify more
interesting properties so I wonder if
there's any support for that as I said
you can specify no matter what
interesting properties you have as
assertions so you can put wherever in
your code any sort of complicated
surgeon and actually the language that
you have here is much more expressive is
turing-complete language you can write
whatever you want that I
in this particular point in my program
that this function returns that great
also a quick question is there anything
in the smts over that you're using the
or does it lack something that you would
like to have its little isn't it always
somehow preventing you from testing
certain things that you would like to
test so far in our experience so far no
but I'm sure there are so one of the
things we are working right now is I
think I heard it here we are
experimenting with more SMT solvers
currently we are using an abyss folder
called z3 from microsoft research but we
are actually right speaking as well as
we speak we are hooking it to other more
advanced for certain theories SMT
solvers so we are generating anyway smt
lib to which is a standard of all these
things so it's a just an engineering
effort in hooking it up to menu and
since we have the Paranal solving any
the parallel solvers anyway it's just a
matter of sending some tools at three
and some too yikes and some to this and
that and the other we don't have any
time for more questions I suggest you
come to kotas afterwards and talk more
about it running footfalls for Katya
sake knows</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>