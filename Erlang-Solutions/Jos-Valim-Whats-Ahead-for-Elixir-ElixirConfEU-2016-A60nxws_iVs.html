<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>José Valim - What's Ahead for Elixir? (ElixirConfEU 2016) | Coder Coacher - Coaching Coders</title><meta content="José Valim - What's Ahead for Elixir? (ElixirConfEU 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>José Valim - What's Ahead for Elixir? (ElixirConfEU 2016)</b></h2><h5 class="post__date">2016-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/A60nxws_iVs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so let's get started first I want to
thank Jean and Monica entertainment are
linked solutions for organizing the
event and I also went to thank everyone
for coming I hope to have two great days
of conference we have a lot of learning
and this is going to be the usual talk
so the plan for today is going to give a
little bit overview of what happened in
the last one year six months since the
last event and then we are going to talk
about the usual stuff what is happening
in Alex your master and what we can
expect in the upcoming Galaxy releases
and then we'll go to talk about more of
the long-term things right like what are
things that are bothering us and
bothering the community that we want to
solve in the long term and what we are
doing to solve those things so let's get
started so Alex 310 came in September
2014 who we started with we started
before Alex 00 all right so and then we
join in the 10 branch around cool yeah
well we will continue to show your hand
soon so electron at zero came to 10 /
2010 it has not even been two years but
it feels definitely like much more than
that and it was great because we had
more than 180 contributors code
contributors to the language we had
three books almost out they were
actually just waiting on the language to
be 10 so the books could also be final
and we just had our first exit
conference in in austin texas and for
those who are there before Alex 210 it
was a period with quite you know because
it was before the first official release
we had the opportunities to do backwards
incompatible changes and things of sorts
so we had a lot of churn right we were
removing features any features so what
we decide is that after what Alec 310
was out we said okay we are going to
wait a little bit now we have
foundation right that's starting be on
top of that let's let the ecosystem
start to build itself and that's why we
waited a little bit we waited a year so
we got a leak through on that one out so
who joined with Alex tiro not one a
little bit later cool and so that was
the Tamara sheer and we had almost 300
contributors hex was also reaching some
important milestones like were just
reached 1000 packages and we had both
the first lexicon for the United States
and delicacy conference Europe and at
the beginning of this year we released
Alex you're not true so it was like
first or second January and the reason
we released quite early on at the
beginning of the year is because I don't
have to do any more work for the rest of
the year right we just we got our
release 4 2016 done now it's just smooth
sailing okay so and then we can see more
and more code contributors coming to the
language and since this release at the
beginning of this year a lot of things
interesting things happen so we started
to see first more local event so there
was elected days in Florida there's
going to be the entire empire City
Electric conference in New York in 10
days or something our learning resource
page on the website it continues to grow
we have more books more screencasts and
other resources so we can learn a
lecture in a bunch of different ways
more books one of those initiatives I
really like is alex three school so the
goal is to teach elixir in a wide range
of different languages there's also the
Electra forum which is something we are
trying right now to be because today a
lot of the discussions in learning and
improving the language it's happening
over the main list and that's not a
proper medium for us anymore so we are
starting with Alex your farm when you're
going to see how that we work we're
starting to transition the mailing lists
there and you can see that it's
definitely a better place for having
discussions and hex got a new new page
and every like it because now you're
putting sohrab arteries
package manager for air link and they
adopted hacks as well which is going to
help us have more and better packages
and they got this new page and actually
I want to where's Eric Eric okay woke up
so I actually want to everyone to clap
and appreciate the work
that Eric and the heck sings doing we've
everything both in terms of security for
structure server-side client-side
integrated with Alex integrating we were
laying definitely a lot happening there
and Eric's leading this works a really
great job and there are couple packages
that deserve kind of a special mention
so one is Phoenix so Phoenix got the 10
release and then even more releases
later and it's interesting because in
the early days right when Alex was a
language in development a lot of the
community came and the main goal was to
learn the language itself and that and
that was a some experience and now with
Phoenix out there and as we're going to
talk next nerves it brings a different
perspective because a lot of folks come
like hey you know I want to build this
thing and of course I need to learn the
language to do this thing but it's more
of a site go and that changes the
dynamics and it's a really interesting
experience altogether so Phoenix got to
a know we also have the nerves project
which it's trying to spread more
knowledge about embedded and get more
developers interested in batted
development and they're doing a great
work progressing really really fast and
that's also interesting and we are going
to have keynotes bike race and justing
one for Phoenix and one for nerves
tomorrow so that's definitely going to
be interesting really looking forward to
that and besides the project we started
to see more and more companies using a
latrine production i'm going to show to
use cases that i find interesting so for
example moss they wrote this very
excellent blog post where they are
rewriting part of the infrastructure and
they just beach the database right and
and say wait we have Alex here like
those things are really good to be
running for a long time so what if you
just ditch the database and do all the
work we need to do by keeping the daily
memory so it's really interesting blog
post we also have companies like Peter S
design hey are going to start investing
in the elixir
community in India ecosystem and those
of course they are just two examples for
example Chris tomorrow is probably going
to talk about companies that are using
directly Phoenix in production and
justice like to talk about companies
Beauty hardware software if nerves and
shipping that than selling that so I
wanted to focus on the shoe because
there are more electric centric and to
me the really interesting cool so that's
as the name said it's just an overview
it's not meant to be a completely fooled
detail what has happened but some of the
highlights and now let's talk a little
bit more about go let's talk about what
is coming in the elixir on that trailer
it is so one of the features that
actually makes me want to relieve al
akhirin three today because I think this
is going to be a huge is going to be
really important for the community is
the addition of calendar types so here
is some cold okay and we see examples
many examples of this kind of code and
that's what triggered us to add
counter-attacks imagine that you want to
get like yesterday add one hour to it
and persist it to a database using acto
so let's say look well the we have is
library which is really well named
called good times that is going to you
can get yesterday and it has a lot of
functions that allows you to get
yesterday today tomorrow and things like
that but what good times return is the
very old top performer that airline has
so you need if you want to use it with
the daytime library that allows you to
do all kinds of manipulations you need
to call like from where lang and then
you can add hours and then you need to
convert it back to this type of format
so actor can read it and persist the
database so that's not good right like
the real logic is to lives and then the
rest is just boilerplate getting the way
so we decided to do is that Alex e1
d'etre is going to shape with 4 new data
structures time which is our minutes
seconds microseconds date which is ear
month
day and then we have nice day time and
day time this is really interesting
because so nice day time is the date and
the time without the time is on
information and the reason why it's
naive its because if you don't have the
time for information that they may not
actually exist or it may be ambiguous so
for example when we have daylight saving
saving time right we need to move our
clock forward one hour or move it back
move it back one hour when we move it
forward there is a whole hour that's
gone disappeared right so if you don't
have the time zone information cannot
actually validate that so that's why
it's naive or it can happen twice when
you move back the clock and you to know
which one you're actually referring to
so that's the ninth date time and at the
date time it actually has the time zone
information and the go to the calendar
types is as I said is to provide a
common ground for interoperability and
that's why I'm really excited because
when we release alak three on the tree
and the libraries start to adapt those
view data types right we are going to
it's just going to be easy to have a
library that is doing parsi another
library that is doing formatting and
it's going to allow the acquisition to
grow and integrate better okay have more
in specific responsibilities and for now
the goal is to mostly focus on the types
however we do want to add just some very
basic conversion functions right like
convert from airline get you are linked
and things like that and maybe get an
integer which represents the unique set
talk and things similar and we also want
one of the goals one of the design goals
of the library is to support multiple
calendars so the one elixir is going to
support by the phones that counter that
we all use okay which is specified by
the iso 86 year old format but if
library is want to bring other calendars
it's going to work with that as well and
I have to thank both law and Paul that
law works in the calendar library powers
on time acts for opening up the
discussion so we could add those five so
basically when I saw code like this
right i was like no this
this is not good and then I sent an
email to law and Paul and today's at
Radames like 60 males where they were we
had all this discussion what did those
types and it was a very enlightening
discussion so I want to fight them so
cool so this is one of the features that
I'm really excited about there is some
other feature that I'm also excited
about but there are more people excited
about it in me which is with so Alex
you're not to introduce this new special
form called with okay and what is and I
really love it because here's some code
that i actually wrote i'm working on
this thing called a dynamic supervisor
which is a supervisor and one of the
things that then an improviser receives
as argument our data like the strategy
the number of restarts the supervisor
can do in the given time period which is
mac seconds and we're seeing this data
we want to validate it so what this code
is doing is is doing this so i want to
validate a strategy if and if the valid
that validates try this returns matches
okay i'm going to validate the restart
and if that matches okay i'm going to
validate the number of seconds and if
that matches okay i'm going to return
okay with this state so it's very it's
very succinct and readable right and the
way those is more functions but maybe
strategy validate restarts are
implemented it just is so i want to
validate the restart and the restart
should be an integer and if it's an
integer I return okay so that's going to
match but if that doesn't return an
integer I'm going to return an error top
o ok with the reason why that thing is
not valid so basically if you look at
this code it can return district of code
can return to things it can return okay
and state Apple or the ever and the
message because if it doesn't match it's
just going to return the valley that
does not match so really really handy
and but there was an issue I think
developers starting using this feature
they realized that sometimes they
actually want to change a little bit as
result for example they want to add some
more information to the other message or
let's say you want to update their
for some reason and we value your not
true which is the version it's out today
the only way to do that is to get the
ho-chunk assign the value to a variable
and then here the bottom we are going to
pattern match on the variable and then
if it's okay stay that it returned here
you want to keep it the same but if its
lair message you do the operation wanted
to do so at extreme on that tree is
introducing this feature called wif else
which is the opportunity to add else to
the wave and it's going to be vocal in
case one of those claws do not match so
which by any chance any of them returns
the effort up oh we are going to imagine
it and then we can obtain and and the
reason this is really interesting is
because when we added with to Alec 02 we
actually discuss about anything else and
then we said you know what this feature
is really really new and we don't know
if else is going to to make sense in the
long term so let's release with as is
without else and we will see how the
community will react and if anything
else in the future makes sense and as
soon as we release a literal not true
and developers started losing with a lot
of developers from different places from
IRC main least semi as you may say you
know who would be really cool is that if
we could use else because I really need
this pattern in my code so it was really
interesting because everyone came to the
same conclusion like no that would be
really handy so there it is it's going
to be there in the next release X unit
which is our test framework I'm sorry
may not be able to see this quite well
but actually it's our test framework is
also get improvements and one of my
favorite improvements is that for
example when you compare a left value to
a right value so here I'm comparing two
maps we print the left hand side so
imagine you have a large map here I'm a
present with 30 keys and you want to
compare it to another map that has
approximately 30 keys if your assertion
fails you're going to print those two
large map right identity to go Oh 11 is
here 11c or 39 is here all right that's
not really nice so X unit
in 103 it's going to do a diff between
the instructors so if you're comparing
strings when say look that's the part of
the string that is different I really
like what we are doing for maps so if
you are comparing two maps what we do is
that we shall look the key 23 it's the
same existing both maps but the valley
is different however the keys 876 were
removed and the key 33 was added so this
is really good because with a very quick
glance at the deef you know exactly what
are the differences right and you can
act on it so I'm always using elixir
master and you know this feature has me
a really lifesaver and alack sales work
is working on the eight when we are
continue to ship improvements so that's
a great feature coming the new in the
liberal is mix which is our bill to is
also getting provements and one of those
improvements actually talked about it
last year that we wanted to do it and is
the addition of a scripts for mix so mix
has this feature called archives so this
is in alex's and a clear 10 it's there
for a while we have this feature called
archive and if you use it hack or if you
use it Phoenix you use it archives so
when you want to install Phoenix for
example to generate your first
application you do something like me its
archive install and the path to
something and what that's going to do is
that is going to get that tar file put
it in your machine so you can run a
command like this mix Phoenix that new
new app and that's going to generate on
your application mixie script is a
little bit similar so we're going to do
that you can do mix a script is tall and
you're going to give a path but instead
of stalling and archive is going to
install and is securable which then
you'll be able to secure like phoenix
new app right no longer did mix is just
phoenix new app right it is 10 alone is
curable so why are you through the scene
scripts if they're both quite similar
there are added exactly as an
alternative to archives because archives
the only run inside mix you need mix
there in order to run the archive and
that's why we tell people to not go
crazy with archives because
is every time you run a mix command mix
is going to load the archives so if you
have like 20 archives you're going to
make every comment that your realm which
makes it slower alright then you don't
want that makes the essential to me in
the acquisition okay and you're in our
everyday work okay so we don't want to
do that and in scripts give exactly that
if they run completely apart from mix
and they do not even depend on the
electric version that is installed
locally they have a copy of Alex fear
inside of them so they are much more
isolated and that's really really good
the second one we wanted another good
change that is coming to mix is we now
have an environment variable called mix
owners car debug and we are continuing
to improve it so if you're a variety of
mixed a scan you are a little bit lost
how things are happening if you run now
with mix underscore debug one it's going
to print everything that is happening
right like look I'm running this task
for this project and if there is an
error it gives all the information that
one for the ever so it's a very small
addition but it's really helpful when
you're working with mix we also have a
two new very useful tasks which mix app
tray and mixed up the tree so app is
going to pray to the tree that you
specify in your application file what
our application dependencies and those
are the dependencies like hex packages
github repositories and things like that
so here's an example you can also try
elixir master and sit for ourselves well
here's an example that you get from
running it inside the new Phoenix
application you get like the name of
application then you say look it depends
on good tax that is a hex dependency it
depends on Phoenix pub/sub that is a
good helper post story and you can have
a good overview of your project and
right now we are printing it to the
terminal but if someone would like to
contribute something like dash dash dot
that would actually paint a dot file
with the tree using images that's going
to be really really sweet cool so that's
just a very small overview of what is
coming in electoral nut tree then the
opana see wrote this article calling
what's coming
the train that go over a lot of other
changes that are happening the language
and with more detail that I have given
right now so i recommend everyone really
to check that for more information what
is coming next cool so you know those
are some of the changes some of the
things I'm personally excited about and
I hope you're excited about for the
upcoming Alex releases and this is the
part of the top everyone's start talk a
little bit more about long term okay so
one of the things that we have been
always thinking is like how it can
improve OTP right so and by OTP I
mentioning all the those building blocks
that we use for building distributed
fault tolerant application so when we
use a supervisor when we use agent
server right those are all those
building blocks coming from OTP and
there are two things that have been
planning to improve them for quite some
time it's the simple on foreign
supervisors and the gentleman and here
you need to do a disclaimer I think it
was last year that i talk like look we
want to improve jenna vent and somehow
it became like nobody should use
jennifer ever know it's like they're if
you have a problem for example where you
you want to send event to an entity and
you want to broadcast those event gen
event is a good solution that we have
today and if that fits your problem you
should definitely use it that doesn't
change the fact however that it could be
better okay and that's what we want to
focus here so let's talk a little bit
about the shoe okay and then we are
going to talk what we're trying to do
too just to solve this so when you use
the supervisor right so you create your
Phoenix application or create a new
application using mix you d in your
application file it defines a
supervision tree and you choose a
strategy right and we have four
strategies we have one for one one for
all restoril and simple and front and
one of those do not look like the others
okay
so the first three strategies they are
pipe similar in terms of API and how
they behave but a simple one for one
it's a little bit different and in order
to first understand why it's a little
bit different we need to understand why
we would use a simple and front and we
use it every time I want to spawn
children dynamically so for example when
you were beauty your web application and
then there comes a request and we start
a process to handle that request right
request can come anytime and you're
starting those processes dynamically so
eternally our web server like cowboy it
uses something like a simple on front
supervisor so that's the use case you
just know or for example if you wanted
to you have those requests call me and
you want to send emails and to send
those emails you are starting new
processes you want to put those on the
simple and foreign supervisor because it
was built exactly for spawning children
and I'm clean all right so every time I
want to start a supervisor process
endemically because something else
trigger it you use a simple inform
supervisor that's important because the
design of the sea poem supervised that
implementation was done in a way where
we can actually spawn hundreds of
thousands of children millions of
children and the representations to be
lightweight and things like that so that
is the use case in our support this use
case a couple things at different so for
example in a regular supervisor when we
pass the children that we want to start
when the supervisors start the
supervisors are going to get that list
of children right so say I have child
one two and three and it's going to
start that in order however for the
simple one prone supervisor every time
is this fine knit it must return just
one list with a single child cannot have
zero clan top five needs to be one and
that child is not started automatically
it works as a template so it starts to
get a little bit confusing right because
they have the supervisor module and then
you have three strategies that start
things only need and then you have these
special strategy that behaves it will be
different not only that so here's
something you can do go to the
supervisor documentation in your
terminal or your
just do a supervisor and IX and
everybody see that a lot of the function
the functions in there they have if the
supervisor strategy simple one for one
the input is these and the outputs that
if it's one of the other strategies that
you put should be DS in the output you
do that that's not good right I never
remember what are the proper API is we
can use this if one foreign supervisor
and when we are explaining it to someone
it's always a little bit maddening as
well so we definitely want to improve
that and there are a bunch of other
cases where the c14 supervisor is
different or just slightly different
enough to be maddening okay so what we
want to do then to solve those problems
that we know if that thing doesn't feel
like it belongs there let's just break
it apart so instead of having a
supervisor module what if we have
something called a dynamic supervisor
and all with this for now is to
implement the simple one for own
strategy except we no longer need to
call it sip 141 can just call it 141
okay and we actually we've actually done
this work I've that code I showed at the
beginning with with came from this
implementation and and for now that's
all it does it really got that cold from
the supervisor and we put it apart
elsewhere but now that we did this now
we broke it apart we started to ask
questions like what else could be useful
for our dynamic supervisor to do because
now it's much clearer we have this
particular code working sighs if this
specific responsibility so how can you
improve it how can we make it more
interesting so for example what if we
have better back pressure mechanism
because if you have a supervisor and
then for example you want to send emails
right starting children the supervisor
to send email today we have no back
pressure you're going to send you have a
lot of processes pushing messages to
that supervisor and they're going to
wait how long it waits for the
supervisor to restart the child okay and
so there is no back pressure so what if
we could say look I can only really send
a thousand emails at the same time so we
can specify this limit and then if
you're rich please limit our
if you try to start a child if you try
to send a new email and say look I am
it's overloaded I'm full okay so this is
a better way to do like back pressure
for Bush commands but what if so in this
case as I said we are only pushing
amends to the supervisor but what if the
supervisor could actually pull what if
the supervisor could say look I can send
a thousand emails and when everything
starts its tell someone look I can send
a thousand emails now and then you you
start sending those emails and then
maybe you get a thousand to send it the
first time and then unsupervised look of
those 1000 I already sent 100 so you can
give me more hungry to send so it's more
of a conversation right it's not like
pushing and sake and off its like look I
can send a thousand now my case on 100
9200 and then you have better back
pressure because the two layers are
communicating with each other how much
data can actually work with ok so those
are things would like to explore right
dynamic supervisor and better back
pressure mechanisms cool now let's
forget the supervisor for now let's talk
about Jen event okay so what is Jennifer
so gentlemen it is one of the
abstractions like just server task asian
supervisor and it is used for handling
events and when you start a gen event
when you start something called jen
event manager so every time you send an
event the manager the manager is going
to broadcast this event two different
handlers but the thing about Jennifer is
that when you add a handler to handle
those events you don't those handlers
they are not new processes they are
piece of code that gets attached it to
the manager so as as you go and you
stall handlers you're stalling y'all
this piece of code through the same
process to the same manager process so
have all those entities here kind of
running the same process in the issue of
that so we have the general vent and
then we have a manager that broadcasts
events to Hitler's but really it's a
pasilla broadcast right because those
handlers that we saw here they are not
separate processes everything is in one
process which means it doesn't exploit
concurrency everything is running single
elective process which means
going to leverage of course okay if you
want to exploit concurrency you need to
write that yourself that's not good
right we can definitely do better than
this and it has really awkward error
semantics so because the handlers are
installing to the manager if there is a
bug in the handler the manager is just
going to throw that code out so like I
don't like you anymore right it's going
to not going to run this code anymore so
if you want to actually add the code
back you need to create a separate
process that is going to see if the
hailer is still there and if the handler
is no longer there you kind of add it
back so there's a bunch of interaction
and we know that if the handlers there
are actually separate processes we could
just put it on your supervision tree
then if the handler crashes the
supervisor would go and start a new one
so you know the these idea here that we
have that all the handlers they're in
the same process it's really limiting
its not if in a way discards a lot of
what we learn about Alex see right we
want to isolate our code in different
processes so we can get fault tolerance
and we can get concurrency we're not
doing any of this okay and I think we
can do better as well so in my mind we
are going to have a chance something
okay where the handlers they're actually
different processes and it's going to
port multiple strategies because why
only broadcast what if i want to send
event to all those different handlers
using a different technique or a
different mechanism okay so i want to
park motorboat strategies and i also
want to provide back pressure exactly
the same idea are talking before if i
have processes certainly data to the
other processes I want to make sure that
we are never going to send more data
than we are supposed to okay i want to
have that conversation going like hey
gimme gimme 10 now give me a hundred
okay so so that's it right those are the
two things we would really like to
improve and we are working on that and
we have been working on that if if you
if you have seen previous keynote
presentations we're always talking about
something
so you're kind of working it for almost
two years as well and right now the
place where we are in the research and
development of solution to those
problems that we have two new things
called Jenny stage and Jim broker that I
would like to talk about so I remember
very clearly in the first electric
conference in austin i had a slide like
this I was talking about collections
okay and that's one of the ways we can
also get to this problem so let's forget
a little bit about the supervising the
gentleman let's talk about this other
problem look so many problems right so
we have this idea of collections Malik
Syrian this is co that works today so we
have something I'd say we have widgets
and we want to keep only the widgets
with the color red and then we want to
map over those widgets getting the title
and the height and then we want to put
everything into a map ok so the widgets
they are what we call innumerable it
doesn't really matter what those widgets
are doesn't matter if they are at least
if they are set if they are map as long
as they implement this that is called
the numeral protocol this code is going
to work ok in the map here at the end
where we put all of our data it doesn't
really matter what it is isn't it to be
a map as long as it as it implements the
collectible protocol this code is going
to work so we have you know this
protocol that knows how to get items out
of a collection and we have these other
one that knows how to put those items
back into collection and this will also
do very interesting stuff for example I
can get this code and they can replace
the widget in the map by something like
these i can replace my something that is
going to parse the csv file so now the
widgets are no longer memory they are
coming from a csv file and at the end
instead of plotting to a map i just want
to print the data today standard output
okay so that's really nice but there is
an issue it with this code which is
imagine that the CSV file that we are
parsing it it is one gigabyte of 65 okay
or 10 jigga what this code is going to
do is that
as soon as we filter the CSV file we are
going to load all this sense all the ccv
file contents into memory so if the file
has one jigga bite and eighty percent of
the widgets in there have the color red
at this point here at this stage we are
going to have eight hundred megabytes of
data loaded into memory because filter
is eager right it's always going to
process everything and now that we kept
those ones we are going to map over them
over them so we have like 800 bytes of
data and now we are going to map to this
other list with more eight hundred
megabytes of data and then we finally
get and print everything into the
terminal okay so we don't want to do
that right so Alex here already has his
idea of laziness so if i replace the
email module four eager right in the
modules eager if i replace it by the
string module everything becomes much
more interesting so I needs to replace
the module and now a necessity parse a
strange filter that's not going to load
the CSV file you just going to store the
computation then we want to do that to
that specific file when we say hey I
want a map over again right it's not
going to map effectively it's just a
star at some point I want to map over
that file and then we go collecting
those structures and at the end when we
know everything you want to do we call
it trimmed up run and what's trained
operons way to do that it's going to
fold all this data all the scope of
sorry it's going to fold all those
computations together and perform it in
a way where we're going to parse the
first line of the excessively file and
then we are going to see if we want to
keep it and then I way to map it and
they are going to print it so it's the
data is now a streaming right are not
performing those operations in batch we
are doing it one by one and then we get
the next line and then we want to keep
it and then we map it and then we print
it and so on and so on and so on okay so
this is good it's going to be more
expensive in terms of CPU but it's
really going to save our memory right
you're no longer no longer loading
potentially one gigabyte of data in
memory and when we have these intronic
say we started to think look if we have
this strange thing that encapsulate the
computation we want to do to the data
right we have the data we have the
computation okay maybe we can do
interesting things like what if I get
this computation and split it apart what
if I say I want part of this computation
to run into this process using one of my
machine course and then want this other
part of the computation running on
another process using other cores of my
machine okay so we can get more
concurrency and parallelism so what it
so this is the what if part right so
what if we had a new function called is
trimmed up a sink in Alex eerie and all
it does is that before I call a string
that async everything before here is
going to running in a process and
everything after is going to run in
another process so now we can see how
i'm going to have one process using one
core parse in this SUV file and as soon
as it has some data it's going to send
to the next process that is going to do
the rest of the computation and you have
those two running at the same time right
and that's something that we call
pipeline perilous because if we call
this sum function stream a sync multiple
times we are going to have something
that looks like this okay we're going to
have like a process that is reading from
the CSV and then it sends to the next
process that's going to do something in
a sense in X process the next process
until you perform the whole thing so we
talked about this right in the past I
think last year we're talking exactly
about this ad electric conference and we
said we have a solution it was a lie we
have a solution to this problem and it's
called generator it's even in red
because it was a real hairy so we
thought you know we know how to holidays
we are going to introduce this thing
collagen router and the idea if they're
out is that all those stages they are
going to be they're going to use this
entity called engine router so i have
this SV that's going to change send data
to the router and in this case the
ralphs is way to filter or transform the
data somehow and then the next stage is
going to filter us from the data somehow
and so on so on so in this case we're
using the router mostly a transformation
right to change the date a little bit
but we said since you are coming up with
is a distraction right what if you could
also use the router to handle cases like
this instead of being always one to one
what if we could have the router receive
data from different places and then
round it to different places using
different strategies it's kind of when
we were talking about the Jenna vent and
we're thinking that maybe we could solve
it somehow replace it somehow we're
thinking that the generator could do
that okay but we actually implemented is
head upon the type running and then we
said okay now they are and as we run it
we're excited to run into issues so the
biggest issue was that this scenario
here it's actually not good imagine that
we have a process here a that wants to
send data to a process here one okay the
way this works is that a would send the
data to the router that would send the
data to that process which means that
the router would quickly become a
bottleneck right if you have 24 course
you are passing all the data for the
single process that's not going to work
and that was the problem that we found
we're trying to optimize the router and
it was really really hard and the reason
why it was hard it was because first of
all the router is doing actually two
jobs right we I just talked about those
two jobs right we are using the router
as a transformation mechanism and we are
using to distribute event okay it was a
design decision but it turned out to be
a very bad design decision it's coupling
two things and let's make it really hard
to optimize it and the event ballasting
every time you want to route event right
there is an extra copy because
everything is going to go for the router
and there also is going to be a
bottleneck so we said well if the issue
is that we are coupling two things let's
just break them apart so that's what we
are proposing now with Jenny stage and
Jim brokers like you know let's break
those responsibilities apart so now we
are talking about transformation okay we
have all those processes that are
performing computations and the gens
stage it only worries about them from
the data so if you are developer and
you're in the future using exterior and
you're using Jenny stage always going to
worry about is how it's going to
transform the data when the data comes
in the
on the future do you want a map and what
I want to do with it okay and the way
the gents stage was was designed
remember talking about back back
pressure it was designed so everything
is demand-driven and what we mean by
this is that a is not going to start
send data to be because remember what to
have that conversation so it's going to
happen here is that every time you want
to have data flowing for your system the
first step is that the consumer is going
to subscribe to the producer and that's
the first step so consumer subscribe to
the producer and even after the
subscription the producer does not start
sending data first the consumer needs to
ask for data okay and then after the
consumer ask for data the producer can
send data but it may send data in a way
that does not exceed the amount of items
be has asked that so far so subscription
is the first step so it's sorry it's a
single step it just happens wells in the
whole lifetime of the data flow so first
to subscribe and after we subscribe we
can ask for data anytime you want it's
an a synchronous message so i can say a
send me 10 send me 10 or send me a
thousand whatever you want sir I'm going
to ask for data and then a can send
event whenever it has event right in a
way that it does not exceed the total
demand ok cool so that starts to give us
that ad of back pressure and data flow
right we have this communication between
processes and what it's really really
cool about being the man driven and
about sending the demand when we ask for
data is that we can effectively push the
demand upstream so what I mean by that
is that imagine that now we have that
pipeline right we have a bunch of
processes that want to send data so we
have this process a that's what send
data to be that will send data to see
because the demands are even approach we
cannot start sending data sea is going
to first ask before data and then B is
going to ask a for data what this means
that you have the end of our code okay
that is going to dictate what is how
many events should flow upstream and
that is going to get up to the boundary
of a system up to the producer the
producer connector
so for example imagine that you want to
do a data processing system that wants
to get data from rabbit leq process it
somehow and put it somewhere else with
this system we are sure that whatever is
taking data from rabbit meq is not going
to flow your sister right it's going to
take only the amount of data it can
process and if any of those steps right
for all the whole pipeline if any of
them because if you have a pipeline of
data one thing is sure one of those
processes or many of the process
throughout your application lifecycle
they are going to be a bottleneck at
some point and you don't want them to
get floated with data right so that's
why this communication here it's really
really important so so we have see
asking be for data ska for data and then
after we have the whole demand a can
send data and in a way that does not
exceed the demand and then it gets to be
B does whatever it wants with the data
and sends it to see so we have this
demand driven flow so what is so at the
end of the day well this is
demand-driven thing it's just a message
context just a way that processes talk
to each other and it's realized because
as we saw it pushes the back pressure to
the boundary over our system right we no
longer need to guess whatever you're
getting data from right we'll be able to
signal that and say look this is how
much data i can consume right now and
the gen stage is just one implementation
of this message contract anything can
implement this message contract really
and we've got a lot of inspiration by
the aqha streams and the reactive events
that is happening there in the java
community and this whole idea of that
pressure okay so this is nice this
solves one part of the problem which is
doing the data transformation like that
parallel pipeline okay in a way that it
has back pressure but we still need to
solve this one i was sitting to solve in
general there okay and the way we are
trying to solve this right now is with
the gym broker so the idea so we hear
their author the issue to remember to
recap was we have this process we want
to get the data here but is always going
to press for the router and that's going
to be slow so the idea that your broker
is that remember I said the consumer
needs to subscribe to the producer and
the reason why subscription is important
is because what we can do now is that
the consumer can subscribe to the gym
broker ninja broker its responsibility
is only to broker connections between
producers and consumers so the consumer
is going to say hey I want to subscribe
then when subscribe to the gym broker
division grow did your broker will be
like hey hold on tight right I got a
subscription but there is nothing n and
then when the gym brokers when
eventually someone subscribes the gym
broker to the producer the gym Brooks
like hey you two should be friends right
they have like producer a and we have
the one consumer so you should talk to
each other and then the consumer is
going to start to ask data directly to a
without passing for the broker and then
eventually if you go and subscribe the
broker to another producer the producer
hey i have a new the broker stays and i
have a new producer here and i have a
consumer there you should definitely
talk to each other and then the customer
is going to start asking for data and
then if you add a new consumer you know
subscribe it to the broker the book is
going to look i have two producers here
you should definitely ask them for data
okay and that's how the broker is going
to get all those processes to know about
each other and the data can now flow
directly between them without passing
for the broker and what is really
interesting about the broker is that if
we look a single producer to multiple
consumers relationship so for example
let's forget about everything else so we
have a here right that is a producer
that's supposed to receive the man from
one entry and send the data to one and
tree there are multiple ways where this
producer can send data to one and train
right and that's something we put into
the broker which is the different
strategies so imagine that we have the
producer here and we have multiple
customers we can use the broadcast
strategy that's the one that shipped
with vision event so every time there is
an event to the producer like one it's
going to send that event to all the
consumers every time there is another
event is going to central consumers and
so on and so on so on but that's just
one strategy you can have another
strategy which is for example
sighs the producer is going to send data
to the customer that has the biggest
demand because you are assuming that the
consumer of the biggest man is the one
that can take more work okay so that's
one way we could do it right so now for
example there is one and it's going to
send to the first process and then it's
sending the data and then at some point
you're going to have different
dimensions we're always waits in the
event to the one of the biggest demand
so that's nice and that solves the
problem that we have at the generality
right where all the data is going for
wrong place so we get the multiple
strategies and we can now effectively
route events right but without going for
that main router abstraction that would
be a bottleneck so if you look at the
gin stage in your broker it but together
they solve the issue right from
Gibraltar and we know that stages are
separate process right they're all
processes in a in a pipeline or in this
case we're talking about the broker
they're all a bunch of different
consumer processes and we know that it
provides back pressure and we also
support multiple broker strategies okay
so trick this is a recap right of what
we got right now so we have like we were
talking about collections then we talked
about laziness and I say look once it's
Piper ilysm and then we try to solve it
the dinner out there and then stages we
and that didn't work so we added stages
and brokers and stages they only worry
about transformation while providing
back pressure and we have the broker
strategies which is first that allow us
to send data round right using different
mechanisms so here's an example okay of
how can I kind of hated at this so you
can have something that said taking data
from rabbit meq or any other system
really and you want to those events to
be filtered because you don't want to
process all of them and then you want to
send those events so something that is a
dynamic supervisor and what a dynamic
supervised is going to do is that every
time a new event arrives to the
supervisor it's going to start a new
child to handle that event right so but
as I said the way this work is that the
rabbit meq we cannot only starts in the
event so I was going to start that the
dynamics ax provides first going to say
look I can handle a thousand children
and
time which is really great i have one
child can barely handle it so so so did
that answer provides going to say look I
can handle hundred children at the same
time and then it's going to tell the
filter that is going to tell rabbit meq
and then rabbitmq may get at most a
thousand event send it down stream then
the dynamic supervised is going to start
a thousand children and then as some
children finish their job is we say look
I have 100 more spaces so its end this
thing up string and then rabbitmq get
100 more and so on right so we have that
conversation going and we now have the
dynamic supervisor that can spawn
children dynamically with back pressure
right some other example is that so here
what we are doing is that for every
event we are starting a child but what
if for every event i have already a pool
of processes i have like 16 processes or
four processes and and what if instead
of starting a new child i just want to
send to those different processes every
time the event comes so we can do that
we have again RabbitMQ we have a filter
and now it's the help of gym broker the
filter can send data to all those
different processes using whatever
strategies one so it's another way we
can express those data pipelines right
and both of them is going to have that
pressure and one is using the dynamic
supervisor the other is using the broker
system so if you go back to what we
wanted to do which was improving OTP now
we have those demand-driven dynamic
supervisors right where children respond
on demand and we have back pressure and
we can see how we can use Jen broker to
effectively replace Jen event right
because it solves all the issues we have
with gel event it's going to leverage
concurrency because we are brokering
data between different processes so they
are all running concurrently they're not
going to have those awkward ever
semantics anymore and yeah it solves all
the problems we have this crime in the
past and it supports multiple strategies
to okay so that all sounds very exciting
right and we and there is too a lot of
work to do but every time I come here
give this presentation sometimes I'm
afraid I I found like my half life 3
i'll be presenting this for 10 years and
we actually would never deliver anything
but on the other hand every time you
come and we work in prototypes to build
some code it feels that we are making
the proper steps and go into the to the
direction 12 so what is the password so
far we have written a lot of science
fiction which is basically documentation
without the supporting code so we want
to so we have documented the message
protocol and we have some prototypes of
the message protocol working we have
like define the callbacks we want you to
implement it for implementing stage but
we haven't wired everything together so
we need to finish the in stage we need
to finish the broker and we we have
implemented that end supervisor I named
supervisor works but we need to revisit
it later after they staged in a broker
ready so we can add back pressure right
and you can follow all those discussions
everything is happening publicly there
is a repository under alex you dash line
called Jim broker and we're going to be
working more actively on that for the
next month since we have done a great
breakthrough between the events so
that's it finally I want to thank my
company platform attack that is
investing on Alex ear and on the
community for almost five years at this
point and all this research and
development work is literally my job
that's what I'm responsible to do and I
also want to thank the dielectric
community and especially the electric
our team we have been working a lot of
those things together and all different
issues together and it has been a great
experience so thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>