<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2015 - Tomek Borek - Why bother with FP? | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2015 - Tomek Borek - Why bother with FP? - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2015 - Tomek Borek - Why bother with FP?</b></h2><h5 class="post__date">2015-05-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_bYkRXcf9sA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">um you might know me from these groups
only double group a geek on conference
or a software craftsmanship crackles
actually the latter is most awesome for
the stock because it gave me like at
these three papers to use in preparation
I'm also leading clam de so if you are
interested in functional programming but
you believe you don't have to the venue
for actually talking about it just
contact me and we'll organise things out
the other person to contact his majestic
who is sitting over over here can you
stand up it's I waited for this
opportunity to actually announce
exhausting being adopted as organizer
for lambda long strapless bra and I'm
not he came because I wasn't sure he
will so if you ever had some quotes like
these ones or read about them and you
were slightly annoyed annoyed by
Department that well it's actually more
hype than data then you're at right
place because what I want to talk is
exactly that so if you read mythical man
month by Frederick Brooks you probably
know the concept of silver bullet if you
do not let me actually introduced it
real quick so a medieval mythology and a
number of other mythologies as well
contains a monster known as a werewolf
it's a really hairy scary monster which
can grow some we kill you in a matter of
seconds so to kill a werewolf one would
employ is silver and well toss silver
bullets is born and the number of people
make various claims like for example
that this or that is actually a silver
bullet for the programming so if you
want to be a good programmer you need to
do this and that because it's a silver
bullet and it solves all your problems
and as far back as in the 70s from the
previous century Frederick books Brooks
took actually that concept and he took
it apart claiming that there was no
silver bullet
and we actually the problems we only
have lead bullets so we have a number of
tools at our disposal to be good at what
we do but there is no one tool or
methodology or whatever programming
paradigm included that will be actually
a silver bullet and toss much more
effective so about myself in the token
this is pretty much covered what
actually means better in terms of
programming languages and the usual
claims who here when someone talks about
fractional programming being totally
awesome and what data I found and then
during my studies also not so usual
claims like for example good
object-oriented programming is close
enough or actually enough to be on par
with functional programming and in the
end I'll try to summarize so why bother
with functional programming answering
the title questions show of hands lovely
people who here has read the following
papers why functional programming
matters by John Hughes a number of hands
not as many as I would hope you might
want to actually make it out because
John hooks i believe is present during
the conference so he will be
nevertheless very very pleased if you do
that out of the target similar number of
hands also similar people who razor and
so let me watch them slightly more
clothes and can program will be
liberated from for normal style ah
that's what was surprisingly different
of this but there is one person for at
all those free papers thank you do sir I
count on you to actually spot any
mistakes i'll be making during the talk
out of the papers these this free are
actually a one there which offered me
the more substance for the most
substance for actually most claims are
making here i have also to apologize to
you because this is yet work in progress
i'll be making all the list of sources
and studies i came across available on
my blog please feel free to contribute
I'll be also making a paper out
so the paper will be most likely
available on github so this is yet work
in progress as I stumbled this week upon
some very interesting leads and was
unable to actually incorporate them here
so if you would like to hear the next
improved version of the presentation
stay tuned are we speaking about it on
students key festival on chromatin which
is the student has to be festival of
informatics and on the lab in the
Atlantic on in it like so when somebody
says functional programming is better
then usually he talks about either
paradigm or some specific language and
usually he has a number of arguments
which pretty often boil down to personal
experience but more about later more
about that later pretty much functional
programming implementation is functional
language functional languages that we
know are well there is a number of them
some quite popular some less popular
still it's one important thing to be
noted pretty much every language is at
all pretty much every tool that we
programmers create is designed with
something in mind we came upon the
problem we needed a tool to solve the
problem we created a tool to solve the
problem so usually when you take a look
at programming language it's also
designed with something in mind somebody
wanted something out of this language
somebody wanted to express ideas
differently to implement lambda calculus
by Alonzo Church and to do something
with it but he wasn't able to do in any
other language he wrote in previously so
take a take a look at the language that
you're using of it this other person is
claiming to be really awesome and ask
yourself this question what is the
design goal of this language what was it
designed with in mind a number of people
when Java started to be the new big
thing said that Java is better than C or
C++ because you don't have to deal with
memory allocation there is a number of
arguments behind this claims but to be
honest
these are language really good if you
actually take away a feature if you
can't say art subscribe to addition is
this language really make you a better
program does this language really make
you a better programmer that's the
question that I would like you to
actually ponder for a moment because
yeah java was safer through the fact
that you gave it gave you tools or
automatic memory management say garbage
collector and all that coupled with
actually preventing you from shooting
yourself in the foot with by hand memory
allocation so this actually led to
somewhat some popularity in Java but
that was safer in some contexts it
doesn't mean better the usual claims it
is the future functional programming is
the next big thing coming it will change
the world and all that let's claim
number one functional programming as a
new paradigm changes the way you think
about code changes the way program
changes you it makes you into a better
programmer also it gives you another
tool to have at your disposal you may
reach into the toolbox and reach out and
solve the problem with functional
programming it leads to shorter or test
surcoat your code will have less
opportunities for box it gives you more
power it gives your better obstructions
this leads to higher code reuse this
leads to actually making writing program
programs becomes more convenient less
complexity to do with no state mutation
some say the non-state it makes you
thinking streams and this actually gives
you better way of programming composing
programs it gives you less side effect
it gives you actually opportunity to
write code without side effects it's
reliable it's proven it can be proven
programs written in functional
programming style can be actually
reasoned about it solves the multi-core
problem because it's better for
concurrency I suppose these kinds of
familiar to you aren't they I see little
naughty so which is not familiar a total
silence I thought so so let's start with
the future what is the future think the
next big thing how can you actually take
a look and say measure it so you can
take a look at same trends how much do
we talked about it during the
conference's how many articles can we
see about it how many article tutorials
and whatnot appears in mainstream
sources practically market share in
which domains this is used this
technology is how how exactly is
widespread the languages would support
this technology how widely popular are
they so by Fame yeah we are here at
lambda is conference strictly oriented
to lambda related things which is
functional programming there is logic on
there is a number of other conferences
which are fairly young this is second
edition of lambda dice I believe lambda
compass like three editions during
strange loop if you take a look at their
agenda year by year you can see that
functional programming topics are quite
prevalent and they actually moved from
oh sorry are you familiar with the
emerging languages camp I hear few years
but not so many strange who actually has
a side event sort of like lambda discuss
react a stranger kept has the new
emerging languages camp and if you are a
creator of a language you actually can
talk about your language there and it
gives you an almost 15
p for in-depth talk about language
design and all that so if you take a
look at it you will notice year by year
that yet languages that are functional
are quite prominent in appearance it was
quite the same when you actually took a
look at how many people wanted to talk
about their own java implementation back
in the 90s when java actually can't came
to prominence so looking at the
conference is looking at the articles
which even appear in the most mainstream
sources for java and.net coders yeah
it's on the rise it's quite prominent
you can actually take a look at it and
think you are this might be the next big
pink practicality market share who and
where users domains and here we have a
much bigger problem first of all if you
try to answer even a simple question
like for example who uses say a zinc as
those other systems the implementation
of the virtual Java machine and if you
take a look at just that you notice but
a number of people who even might use
ink or are even known to use ink they
are not really very vocal about it there
is a number of reasons you don't want
actually to reveal to halt wird the
technology stack of your favorite
application which brings you money there
is also the startup advantage if I
believe that this and that technology
offers me competitive advantage the
others I will not talk about it out loud
at least not until I capitalize on that
competitive advantage now that's a given
so if we take a look at the market share
we have not much data to go on so it's
hard to see how actually functional
programming is taking the market by
storm by tiptoes not much to go on there
are job offers though and geographers
are actually the best Intel we have and
the other info we have is the adoption
level you can clearly judge the
popularity of a given paradigm by how
features of
paradigm up in part appearing in
mainstream languages one of the
mainstream language is Java the other
would be C react and other will be
fighting and all those actually have
functional paradigm incorporated in that
way or another yet another reason for
believing the functional paradigm is
gaining momentum is the fact that pretty
much the number of new languages
appeared that are quite functional
closure on the JVM and hybrid or
multi-paradigm or whatever you call it
scallop Haskell also is gaining traction
so by that virtual we can see that the
adoption is raising and of course are we
don't have actual data unless we take a
look at something that has been here
quite long and number one and probably
less obvious choice is sequel sequel
adopted a number of functional
programming paradigm features like for
example immutability quite some time ago
to cope with our large volumes of data
so if we take a look at the adoption
level yes there is the rise in recent
years say like 2002 and more if we take
a look at the language popularity within
job trends I lose the sight indeed which
offers you to actually gosh what is
trendy and offers you actually to
glimpse what you should learn so I've
taken a number of functional languages
that is color along haskell f hush lisp
and well as color is the most prominent
here and the rest of them well not so
much let's take a look at the scale 0.04
impressive what didn't you say now let's
make something even worse let's put it
in context let's up the big players so
with a sequel we have Java don't have
c++ while is in decline and young
JavaScript sorry this is jobs too busy
signal's boss the colors on this might
actually elogio slightly but this here
yeah these are all the others so again
not so great question DOM is all
positions or programming position
position this is all the positions and
this is actually through all domains
because I wanted to have also data that
incorporates not only software jobs a
number of jobs actually are presented as
not jobs in software industry about job
say in finance industry or something
else when you actually create software
to solve business problems you see what
he's doing here let me guess you feel
one of the functional
now for the fact i know that hey so this
is not not really honest from my side
but yeah that's associated words are
declining sorry multiplay yes I'm here
yes they are our names job should be I
think I think that number the chocolate
egg is pretty much to say about number
of the jobs in 2014 that is also correct
I'll talk about talk about such
reasoning more in the next graphs to
come where I'll have more data actually
to back up my claims because let's just
acknowledge there is a number of reasons
which can explain the jobs or highs in
these graphs and unfortunately I wasn't
able to get to them so since I promise
you I will not offer the speculations
but you later I will not delve into this
so the glass is that as it is indeed
come you might find the actual data
munging algorithm as much as they reveal
they don't you do that much to be honest
but if we take a look at our yeah this
is when I wanted to see also Ruby on the
screen not very well sorry moving dinner
another source would be geeked up the
quite popular and social coding site
which aims to be the gathering for
pretty much every programmer and which
tries to actually show you a number of
things about the data geek app offers
data mining API which a number of sites
and projects uses to actually take a
look at number of things and if we take
a look at this red bank made graph that
monks made a nice post on the site which
explains pretty much everything about
the graph how it was taken world stands
behind which a peak and actually
declined and all that and for that
matter if you take a look at pearl you
will see that we have a peek here and
the
reason for that is actually a giten
project do you know get one project I
know that at least one person does as
expected our peril hacker so given
project is actually a project by red
marks and sit on to port sip and
repositories to github well for those of
you who do not know sit on it's actually
the largest code repository for pearls
for paralogs and pearl hackers so they
put that number of repositories to D cup
and that was the reason behind the peak
why Ruby declined so much you might
think that Ruby used to be widely
popular about emphatic it's quite
different things happen here github
became popular as geek hub became
popular contributions by just rails
people and Ruby people were not enough
to keep up with contributions from other
languages in general so Ruby never was
the most popular language ever oh sorry
okay that's speculation you don't you
shouldn't actually take from this graph
that ruby was a most popular language
back in 2008-2009 it's actually that
than on github it was the most popular
so unfortunately even when I'm trying to
present you data you you see that you
really need to take it with a grain of
salt and well in this case perhaps not
even a grain perhaps like a bucket quick
question do you hope you'd help
determines that it's a Java project or
writing project was algorithm project
awesome question thank you for it ah so
me and asks how actually did have says
that well this code is Java or Python or
whatever unfortunately most of the most
highest criteria most scored is lines of
code so this actually leads to that
so unfortunately if you take a look at
this you can see that javascript is the
next big thing we really should stop
going to lambda days leave this room go
lunch on JavaScript and the reason for
this popularity is unfortunately the
fact that if you create any web
application you're most like people in
JavaScript frameworks what your code is
like few lines of HTML perhaps some CSS
and then you are jquery tada you've
created a new java script repository
convert so if you want to actually
really play with these things i
recommend you get hot info it's a
totally awesome page I don't know if I
let access here to show them I might not
sorry um good music tho if you're into
it
so github actually is a default behind
this and on the side makes it a number
of other categories like total number of
forks a total number of new repositories
number of issues / language and when the
language came up so you can actually
take a look and see objective-c how it
first across all the categories and
honestly i recommend you spend 5 to 10
minutes playing with it it will be time
well-spent gob gob is yet another tool
to actually measure the popularity of
forgiving language it's widely quoted as
the best source for such statistics and
Intel what it contains on the very first
page so to say what's the most in recent
year long range trends very long range
trends think like 1995 for me that's
quite some time and it contains the
early index of languages like what first
the best I look at top 50 and across
2014-2015 top 10 contains no pure
functional language you might of course
reply back to me wet well that is like
Haskell and few others right and I say
we are sure so name me a functional
language and I'll try to name you back
its position scar 46
closure up around 30 30 yes f sharp ah
that sharp from you that's actually the
best and most popular functional
language as it stands by tob it's
actually number 14 so you don't have
actually anything higher than that and
takes a look at two first roles here
sixteen percent in ratings and fifteen
percent and ratings go to c and java
let's look at directing as we seen with
previous graphs graphs or dangerous
let's look at the logic behind them so
gob works actually by calculating hits
for a very specific search query the
query is language programming quoted and
with a plus so basically we're looking
for basic programming java programming
closure programming and all that and
they are doing this using 25 search
engines which they pull out from alexa
which is page rancor basically and
counted heats are no more iced basically
they take a look at search engine for
all languages and all languages together
add up to one hundred percent so from
all queries queries for java queries
fosse make up for more than thirty
percent of all queries in programming
forget javascript gonna go Nancy go work
in Java
I like that I like that you guys keep
coming back with those I'll later make
it into some Sparkle studies so other
really harder to teach it seems like
legit lead to be honest why because
usually what they what they actually are
searching for is our offers for offers
for trainings for example our offers for
improving the skills tutorials and all
that so basically resources aimed at
giving you toward be more productive in
a given language not all that but still
and they have in a minute they have a
hand calculated confidence factor for
each search so for example if you they
are looking for basic programming they
take first hundred results and see
whether it's really basic or for example
improve your basic java programming
skills how early on census counts the
last one make a query or the number of
documents that returns with that query a
number of kids for that query
fast I will argue that they are analyzed
right actually popular music songs there
are two understeer question and perhaps
you can decide which i did in bed so let
me repeat the question is basically so
what if the language is popular now my
answer in this talk is I searched for
any indicator that would actually tell
me that functional programming paradigm
is the next big thing is the thing of
the future the thing that will change
the world and all that popularity of
functional languages is intended in is
an indicator it ain't indicated that
it's the best thing that's not the same
but it's an indicator that more and more
people want to learn those languages
because they see any need in it weak
even fashion they want to be fashionable
and fashionable people fashional
programmers learn functional languages
okay so FP languages at gob and non
makes it past currently at hash which is
a number 14 they hold usually less than
one percent rating with the sole
exception being F hush yet another thing
usually they hold rating it's like point
four percent stuff like that so not much
a number of nice functional languages
like for example airline didn't make it
into top 15 sorry not 1550
the index is it starts right now for the
top 10 languages is that as you can see
and notice one thing the really sharp
difference between the leaders and the
rest of the world to be honest if you
are up to ask me what I attribute this
to then I would say to link and usages
see is the system language and most of
the systems service operate on is in
some form of C and Java is the
mainstream language which pretty much
took to every domain since like 15 or
more years well now even 20 years so if
you were to ask for my opinion why those
languages are so prominent that would be
it summarizing fail is it on the rice
yes definitely is it dominating is it a
massacre physics something that you
should actually start letting right on
right on the go well not yet I would
like to actually say something else
because I like functional programming
but I don't have any data to back it up
so this of course includes the start of
the startup advantage that is I'm holdin
I'm holdin back the information that I'm
using functional languages because they
give me competitive advantage this
includes lack of data on the market
actually what companies use what
technologies and one last thing I should
tell you language gets famous popular if
it's pushed forward it needs to have
backers so for example scholar has
backers in forms of typesafe and java
had backers informed of some and later
Oracle so if your backer is strong one
then the language will survive and that
is one of the greatest if you actually
were to look for
those reasons for F gosh rose to
prominence i would say Microsoft backing
would be among the reasons sorry I would
say you're operating systems so these
are not company oriented buggers these
are rather buckles and actually factual
backers the fact is that if you want to
write system code you have C at your
disposal and perhaps go and that's about
it Google is back in gold and the point
is where they want to take it this might
lead to further prominence of God go in
tob index was one of the languages which
one the most prominent language of the
earth award which for example happens to
none of the functional programming
languages I know since like 2002 because
that's as far as well as well as I word
foot bending and yet another tool to
help you in your toolbox let's face it
general truth says that you should learn
things different from your own field and
people stated throughout the ages beach
on the south side south side like
miyamoto musashi beat on the craftsmen
side like for example famous cathedral
builders over beat on the software side
like a number of people pauvre Homme
eric raymond martin fowler and in long
list of names follows so truth is and
there are studies that actually show it
we think in patterns if we think in
patterns then if you learn something new
then you can take the patterns from what
you learned and apply it to computer
science so yeah number of personal
statements floats around on the internet
and you can see for example either and
haskell and I became better programmer
you can see also i learn Haskell and I
suffer why do you think this guy suffers
there are a friend of mine runs blogs I
think they're hiring they write in
hostile but a yea there is a little job
of Haskell's at the market so you're
right that's one of the reasons but the
other reason is he started applying
functional programming concepts into his
usual see house job that led to a person
from his team asking him okay I kind of
see what you did there those three
functions etc why not it just a
follow-up and the problem was there but
his coat was actually not so readable
anymore for his colleagues so he was
forced to actually go back to imperative
programming which actually went against
his principles now so yeah definitely by
number of personal accounts are much
more accounts you can find on the web
and among your circles most likely that
say that yeah learning functional
programming made one a better programmer
or give gave him a deep insight into
something or simply different insight
into programming one of the most
actually interested leads I found was
there are universities both in Europe
and the United States and in Canada that
actually a running a very interesting
experiment instead of exposing young to
be programmers to imperative languages
they expose them to functional languages
and too impractical manages to see how
will they fare later and I don't have
yet the full full actually data and
experiment and how it goes etc but
initial findings seem to suggest that er
people who are exposed to functional
programming languages first later stayed
with them which is interesting in terms
of yet another criteria so I'll come
back to that later shoulder and thirsty
coat pretty much every damn tutorial on
every damn functional programming
language has this example that if you
write in my language this will lead to
your writing shorter code and there is
the example which shows that if you do
it imperative style you have 24 ribs and
whatnot and in the functional style you
have only two functions in one line and
what not cool really I get it there's
something that personal it frustrates me
as you can see but usually pretty much
always those tutorials have this
statement usually it leads to shorter
code most of the times this leads to
shorter code it can lead to shorter code
cool lovely but not data they don't have
studies they don't do studies because to
do studies and something like that it's
actually quite time consuming and hard
so no studies that I found proof that
functional programming actually leads to
shorter code in general or even in
specific cases I thought no they died
thinkers in the study with like yes but
under Eric frequently asked questions
page there are some statements but there
aint data but back up these statements
so they actually publish the end result
of their studies we bought me being able
to replicate it perhaps I said wrong
excellent point I like your writing
what's your name Rafa awesome roffle
said something very very clever are
shorter code and the biggest problem we
have in computer science typing longer
or shorter well it's convenient for us
but it doesn't actually think it doesn't
actually weeks straight and that's
another awesome point whenever you write
shorter code you are close to
sacrificing grid readability for some
people it does but I get what you mean I
would does not mean that I have to
everywhere from my coat is sorting
algorithm because I don't know how
awesome observation what district set is
something i'll be talking about on the
next slide so basically when people are
talking to you that functional
programming is better because it leads
to test the record or shorter car there
are two ways they mean it one way is i
type less i have less opportunities to
actually introduce box because i typed
less letters signs characters whatever
so yeah useless and the other is more
power thank you 5-10 minutes left people
this means we're going straight to the
end so more power more power is in
better abstractions as if ability to
express myself better more concisely
more to my liking possibility for me to
think about what I want to achieve with
the code instead of just fiddling around
with the code to actually achieve
anything have you heard about the black
paradox hands up ah awesome for people
there's actually six people that's like
my personal record so the blog parable
paradox basically goes like that first
languages VAR i in power second take a
look at the assembly in the liver and a
high-level language yeah who uses
assembly now to code when he can use
actually high-level language there are
either superb arguments in favor of
assembly or you go with higher-level
language so programmer programming
languages duvar are in power so we can
actually have an axis and place them
ascending lee so let's have a
hypothetical language blog which will
place right in the middle of the power
axis and then let's get a hypothetical
blood program and the observation that
graph i made about it is as follows if
blood programmer takes a look at the
languages down forever to the left my
left your
previous on the axis previous is such a
wonderful turn so previously located on
the axis then he will see now they're
weak they don't have this or that
feature which I saw laughs about blob
but if same programmer was to look up on
what's next on the axis then he actually
sees some weird languages and the most
favorite quote that Graham tosses when
he tells the stories for example those
with lots of parentheses so more
powerful is weird less powerful is
obvious and weak and that is this ties
closely of comfort zone and what you
know and this ties with one practical
thing don't argue that with that
everybody I will you make them
experience the language that you claim
to be stronger or just don't argue this
because you're not getting any you don't
have data to prove that language is more
powerful how do you actually would want
to prove that this language or that
language has better abstractions next
time less box so tragic Brooks around
with cheering about the Silver Bullet
concept also talked about complexity and
complexity would be the essential one I
need to solve the problem problem has
this and that complexity I need to
tackle this complexity this is essential
I don't then I don't solve the problem
accidental to solve my problem I'll pull
library X or 2 y 2 y comes along with
this and that complexity when I want to
use it for say manipulating images now
in order to actually solve my problem I
need to tackle essential complexity
manipulating images plus the complexity
of the tool I'm using for the job so far
so clear okay so there is number of
papers which shows and ties complexity
web state and there are quite nice
logical reasonings and you can freely
use that to dispute both the merits and
disadvantages of functional programming
to your heart's content there are no
studies which would be large enough to
actually be of any usage avenues but
there is a number of really nice papers
including all three that I've started
the top wave and a number of others
which can back this claim up state
mutation versus immutability referential
transparency which means less side
effects or no side effects actually so
we have papers on all that we don't have
studies that will back it up next you
can reason about it you can use rdp of
programs after all functional
programming underneath bows down to
month if it was down to month you can
for example proof that your program will
work as it as intended you don't have to
have suits of tests you may use
reasoning formal or informal but you
won't sorry that's my claim judging from
how many people adopted tools for it how
many tools there are four actually
proving that your program works in any
given language there aren't that many
the best actually we make use of it is
in type inference take a look at skul
our take a look at haskell even even
better type inference and yeah we do use
it when we construct the programs but we
don't use it much to reason about
program saying in a way to prove it if
you have data that contradicts it I'm
glad to learn it but I thought not
tools called property dismissing which
actually being successful yes so
scholarship which the stools for
example coq so tools are there but they
aren't so prominently used so if I said
that there are no to see as their tools
but prominent usage etc not so much and
frankly if we deal with a business
that's really mission-critical say a
plane falls down or space shuttle
doesn't get anywhere or if my software
doesn't work right people whose lives
there are usually other means in place
to make sure that the software is
reliable not just functional programming
and not necessarily proving that set
program does what it what it's should
that should do and you think there are
programs in which we don't care for
correctness I mean if I don't get my
paycheck end of the week I'll be
frustrated i think that promotion
correction it doesn't have to be flights
for medical device
so if it works about the business right
yeah the discussion here goes around
whether we actually want correct
programs or not usually we do your
example with the paycheck at the end of
the month sometimes we don't need to the
counterpoint usually you won't do it why
such claim because we have software
crisis since like 1960 and the software
crisis doesn't go away and the reason
for that is quite numerous and should be
topic of yet another debate so for the
sake of backing this with data let's say
for now this is just my claim because
that will be morons this is just my
claim I do have some data to back it up
but let's take it outside we've got
simpler I like it the boxing gloves I
stand a chance so functional programming
solves multi-core problem because it's
immutable because you do not share state
because you often don't have stayed
because you have referential
transparency because you think in
streams and function cost function cost
function so it's pretty much liner at
the execution and you can make it
independent yeah there are papers which
nicely outline all that there are no
studies that will show us what actually
works I would really like to talk to
young people about this because I
believe they have the data they should
have the data everyone kissing
business for quite many years now so
they state that it works you can take
their word or do not believed unusual
claims hybrid approaches are the next
big things and good Opie works similarly
to FP good ol fee as in small talk the
way it was intended the way it was
designed etc so again these are more
leads that I would like to follow on
here than something I have big data
enough to actually be ready to engage in
a scientific discussion so for now let's
say i'll include more light on this in
the next versions of the presentations
so summarizing you can infer number of
things about concurrency you have some
data about you can see if you talk to a
lot people you have complexity you can
reason about programs but not many
people do it for you to actually pull
out the data and use it in an argument
whether functional languages are better
or not you can argue though about power
and expressiveness in functional
language languages but please do make
people experience them first and Tesla
code doesn't really make a difference so
does popularity my point about it and
that's pretty much it thank you very
much for listening and for the
discussion thank you for nice points I
got
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>