<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Handling Unicode - Patrik Nyblom | Coder Coacher - Coaching Coders</title><meta content="Handling Unicode - Patrik Nyblom - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Handling Unicode - Patrik Nyblom</b></h2><h5 class="post__date">2013-06-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/M6hPLCA0F-Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">give it up for four petal okay and early
someone showed the slide from some
really old Ellen gives a conference and
it was one item there was embedded NT
and it was actually my speech so then I
got to talk about windows and now i'm
going to talk about únicos I get to
hold all the popular speeches unison
yeah so this is not like a hardcore how
it works speech is more like a bedtime
story and therefore I called it the tale
of the programmer a date with character
cave and so on so just relax and think
about a fairy tale where you have this
little programmer sitting in the 8-bit
cave guarded by the mighty dragon of
backward compatibility and he wants to
move out into the fields of Unicode
where everyone can send like cool
messages and Japanese characters and
things like that to each other but but
this dragon who isn't really a mean
dragon it's just mighty dragon and it's
guarded by the king king Erickson who
uses the dragon to fire the furnaces of
like wealth telecommunication and things
like that so and also King Erickson pays
your wages so so you've got to do you
can't kill the dragon okay if you kill
the dragon he will be angry not to
dragon he's dead but but King Erickson
so so you sit there in your 8-bit game
and things or nice but you want out so
what do you do you you try to get your
remote control to work yeah which it
doesn't so no problem so what we did it
wasn't right one programmer but for the
sake of of the story it's one programmer
so what we did was start to read up on
what unicode really so when i got this
when
I think beyond came up to me and said
like Patrick can you do the unicode
support and he was he's always trying to
flatter me into doing things like that
so and I was flattered sir okay I can do
that I know what unicode is and I'll fix
it a unicode it's like that you get two
characters for each Swedish character
when you're right on your Mac and you're
really irritated that's what Unicode is
so but now I found this web page well
there's a Unicode consortium this was a
long time ago not as long as I would
like for the sake of looking cool but
anyway so what I found out was that
unico defines these code points and
there's a lot of components they're
actually more code points than fitting a
16-bit character contrary to common
beliefs and code points define
characters for all known that a living
languages character sets symbols
whatever and not really everything
contrary to common belief Klingon is not
including an eunuch on standard for
example it's in the personal usage or
private usage area of unicode and
defined by someone else but but like
real languages all have code points so
and they are compatible the code points
of the characters that are compatible
with us ascii the old character set used
when i was young and isolating one which
is the whole point used in western
europe and so the first part of the
unicode standard is Latin one characters
and then beyond 256 code point there or
the other funky languages so I wonder
why my removed isn't working
probably Unicode so but there's more so
if you have all those code points you
need to store them on the file or
something so you have the encoding and
encoding czar what makes unicode code
points be bytes so you have these code
points like 127 and the encoding tells
you this is a bite in utf-8 if you have
like 2024 it will be two bytes in utf-8
in utf-16 you have two bytes for almost
everything but four bytes for for some
of the really really weird character
sets for me weird for someone else the
natural way and for example 4711 will be
three bytes in in utf-8 and the thing
about utf-8 is that it's really common
so even though utf-8 is might seem
strange because it has variable number
of bytes per character and so on it's
really a common encoding so there's defy
there's three encoding is that there are
defined in the standard and there are
some ucs encodings that are very similar
to these three encoding so there's utf-8
used by Mac for example you would have
16 used by windows for example but not
really because Windows has forgotten
about the code points that's beyond what
can be stored in 160 characters and
utf-32 which is the nice encoding
because each character takes exactly one
unit exactly four bytes and as their
utf-16 and utf-32 have more than one
bites they have not decided on a byte
order of course there's little Mickey
onion of it
but what we forget is usually that we
had an encoding before when we we had to
think of it like we had an encoding
before we had isolating one characters
there were numbered from 0 to 255 and
when we wrote it to a file we decided on
a way to write it on the file we didn't
decide because it was obvious I mean you
had they all fit in one bite so we
encoded each character each code point
in our isolating one character set into
one bite in files or binaries or
whatever so we can call that by twice
encoding so each character one bite
that's what we used and sitting in our
8-bit cave that was all we needed so any
it had this enormous advantages is what
compact each character tech took exactly
the same amount of space so if you
wanted to count how many characters is
in this text file you just looked at how
big is this text file and so on and live
was good so good that we didn't even
think about how good it was but it
wasn't really good because if we wanted
to write Japanese characters we were
like fried so we had different character
sets for different languages and one
text file with by twice and coded
laughing one if you read it in in three
it looked like nothing readable so you
had to know what character said he used
and the wrong so it wasn't all that good
so but encoding and character sets or
often confused and I confuse them but
then I've said the mighty wizard of
Unicode came down to the little program
and said right is on the blackboard a
thousand times and I did that and I
didn't get it anyway but now I get it
so do not confuse character sets with
encodings you can encode whatever in
utf-8 you can encode us-ascii in utf-8
it's somewhat compatible you can encode
latin-1 in utf-8 and you can even try to
encode Unicode in by twice encoding you
will succeed until you have a unicode
characters that's beyond 255 let's look
at utf-8 because we like it in the
Erlang world so this little program
marines cave decided that utf-8 is cool
and looked at it and forth it's also
backwards compatible if you read about
utf-8 it's a backwards compatible a nice
wood us-ascii so all americans think
it's backwards compatible but it's not
backwards compatible we'd buy twice
encoding of isolating one because every
character beyond one hour and 27 will be
encoding two bytes so even though the
characters at isolating one is a subset
of the Unicode character set if you
encode it in utf-8 only the 7-bit ascii
is backwards compatible and that's a
problem and that's something that people
get into trouble with so utf-8 encoded
characters is not backwards compatible
with by twice encoding isolating one
characters always remember that and
write it on your blackboard ok so well
we decided on a representation and part
of the decision was already made because
we had some parts of the UTP that
actually could represent unicode
characters and that was their call by
implementation if you have euro everyday
you score by huh ok but at that time was
still popular anyway you
the code was represented as lists of in
tears each representing one goal point
and that's like a good thing because
lists of integrals is strings in a long
and one string takes about a gazillion
abides every time because i have like up
to 64 bit numbers for each character so
so moving to to unicode didn't change
the space usage of the string it was
still a gazillion bites i wasn't worse
so so we could utilize the fact that we
had place for unicode characters in the
strings and just went on using Unicode
screens as by twice now as code point
wise lists of of integers but in a
binary binary is essentially a bite
oriented thing it's like a file or
something so you can't just say okay put
the unicode code points in the binary
how that's when you have to have an
encoding and we decided utf-8 East the
encoding in binaries it's not the only
encoding but it's the encoding with a
capital e so utf-8 is the encoding used
when nothing when we don't communicate
with the outside world so if a module in
OTP can handle Unicode binaries it will
handle utf-8 it will possibly happen
something else too but but it will have
the utf-8 so for example the Unicode
model handles a lot of n codings and the
bits index but anyway so and if you
programs a mailing you also seen the ire
lists which is a weird possibly deep
list of integers and binaries and
binaries in detail and things like that
which you can sound of port or something
it's a couple of bites and coded either
in lists or in binaries and then
mashed together and there will be a
stream of bytes and to the port or only
in TCP socket or something we have a
similar thing now which called the
Unicode car list which is unicode code
points in lists possibly deep and so on
and then utf-8 binaries mixed with them
so that's a unicode girlist and it's not
a nihilist because the unicode code
points are not bytes so you have to come
if you want to send it on on a bite
oriented device like it TCP socket you
have to convert it to bytes in some way
as long as it's the only binary this
bites but if you have characters they
have to be encoded because if you want
to have unicode characters put on a
device you have to have an encoding so
so the first thing we wrote was the
Unicode conversion module which is
called unicode tada and what it has is
basically two functions characters to
list and characters to binary and
characters is usually this core data
thing so it can be a list of characters
you write it directly in the shell you
write your funky and Japanese characters
in the shell and convert it to a binary
in utf-8 by using characters binary or
you have your binary and convert it to a
list what characters the list so but
characters to list can also have an in
encoding which tells you what encoding
you have in the binaries so if you say
it's Latin one it will be by twice and
coding and so on and heresy and this I
hadn't read the blackboard i have
written full of do not confuse encodings
and character sets and that's actually
because the common way to describe
by twice encoding is letting one
encoding which is wrong because it's by
twice latin-1 encoding possibly but but
as an encoding it's by twice but it's
called Latin one in Emacs if you say i
have x twice and code and laughing one
characters i right encoding latin one
and so on also to emphasize that utf-8
is the default encoding for unicode
characters in binaries we called unicode
is an alias for utf-8 that's bad
decisions that are already there and you
know the dragon of backward
compatibility say you can put that back
in the box okay so we have the other way
around character Spiner you can encode
anything in a bit utf-8 binaries you can
encode anything yes whatever you want
and so that's basically all you need to
gain able to handle unicode characters
you can encode them as binary so you can
put them out on whatever device can read
a special encoding and so on so just to
make you happy and we added it to the
beat syntax which was done by Yann I
think that was good because when I was
wrong with how to do encodings I could
always look at what he had down and and
in theory vice versa but in reality only
in that way so you can match an encoded
character as utf-8 from the BL from
anywhere in a binary you can construct
in all the encoding utf-8 utf-16 utf-32
you can have a literal directly a new
program and write some encoding then
after if it's if you want it encoded so
this syntactic sugar that's always been
there in in binaries for pi twice and
coding is also there for you
alonzo and this is a decision in Greek
characters which you can write directly
into your source file nowadays but you
always have to tell how to encode it so
if you're right if you hadn't written /
utf-8 there how long would have expected
that you you meant by twice encoding 1
by per character which will be really
hard as all those characters are larger
than 255 and the result would be
surprising because what does the bits
intex do if something is too large and
one knows truncates that's right Kenda
knows it truncates so we would truncate
this to something really surprising so
don't forget to put the encoding there
so so any string literal can contain
unicode characters literally written so
as in this example if your input device
can support writing unicode characters
which is often the case with with the
shell or you have a terminal that that
can input unicode characters when we
wrote this this wasn't common so this
has changed over over the years so
having a terminal that could input
unicode character was mostly a Windows
thing at that time you were happy if you
could input 8-bit characters and your
kermit connection would eat the ace bit
all the time but anyway so then you want
to do I oh of course of this and diu
system Aveling is one crazy thing which
has these are you servers which takes
messages written sent from the i/o with
the i/o module and things like that word
of
I'll model and doing this in a backward
compatible way wasn't really easy
because everything was liked by it
oriented so you're always expected all
characters to be bites but we did a fair
job by using the i/o module which is
mostly used know what's mostly with four
terminal are you and made that unicode
aware so the i/o module handles
characters which is possibly unicode
characters while the file module handles
bites except for file open which can
handle unicode but that's another thing
but so if you work with the i/o module
actually everything that's in a binary
is more or less supposed to be in utf-8
nothing I of format become policy and
that's not a big problem because the i/o
module was is mostly centered around
characters in lists so if you have a
binary okay you had a small
incompatibility but there was a long
time ago and you all forgot about it and
so the iu server that takes the thing
that the i/o module sends to it in
Unicode also has an encoding to tell it
what to do with it when it puts it on a
file for example so you can do get up
and possibly set up to see what encoding
it has so if it has anything else than
letting one you can send any character
to it it will know what to do with it so
there are you sorry sir to say them the
machine that we saw in the earlier
picture the thing the cyber punk
machinery that translated from unicode
characters to one encoding so the
encoding translation you can see by
doing get-ups on any iOS 7 that's a file
for example and you can also open a file
so Philo and can open a file and you can
tell that the characters are going to be
in utf-8 on the file so you can do the
translation direct
the IO service and that's dumb for
example in terminal the standard i/o so
if you do are you get ops on standard
i/o you would probably get encoding
unicode which is utf-8 okay but
regardless of the encoding in the i/o
server the i/o module takes Unicode
parameters and handles Unicode so the
only thing that happens if you have
encoding latinum one on on your server
is that it fails when you send
characters beyond 255 to it so it
doesn't like change the type
specification depending on whatever you
send it to it so are you put course
takes a unicode core list as parameters
say if you send a unicode Gore list it
will send it directly as it is to die or
serve and the i/o server is responsible
for translating this to an encoding to
put on the file so actually for example
for the terminal the i/o server can take
any character regardless of if it's
actually able to have any to encode it
on the pfizer will output a lot of back
/x curly brackets blah blah blah instead
if we can't encode the characters but a
file for example we give you an error
that says no translation a unicode
character beyond 255 has no translation
to buy twice encoded file so and the
file module on the other hand handles
bytes so don't send in a unicode Corliss
to it it handles io lists which is like
kind of nearly a subset but not really
so and do not open a file for output of
utf-8 or input of utf-8 characters and
then use the file module to read a ride
from it it will be confusion so the rule
number two is do not use the file model
to read and write files that are not in
Latin one encoding where laughing one
means by twice and coding because I have
broken the first rule of Unicode okay
everyone's with me yeah great okay so
now you can open files you can send
unicode characters to it you can handle
unicode characters you can write a mini
program and now you want to use io
format and here's where where the dragon
of backward compatibility really was
really angry at me in the beginning and
then he forced me by briefing fire in my
face to add the T modifier the T
modifier it says okay this is unicode t
as in this is unicode you was taken okay
so so if you do till the s in our format
means this is a string it takes a binary
or string or possibly a deep list of
characters or something and puts it out
as a string that everyone knows that
until this means all of that binary so
by poison coded because that's how it
always been so we can change that so
till the TS means that the unicode we
have unicode characters in the list that
means it's a bigger range of characters
and the bynars or utf-8 and again to
help the sloppy programmer if utf-8
conversion fails you will actually
accept the by twice encoded binary and
don't rely on that but it does so and
but upside of this if there is an upside
is that if you do not use the T modifier
you will get a nihilist back from for
example I'll informant and that was one
of the important things when it came to
backward compatibility because a lot of
systems use isleib format to format
things that I directly send reports and
they need to be bytes so if you don't
you
the team modifier you will not get
unicode characters and you will get a
list with bites from ireland format
which is a good thing them supposed to
be a good thing till the pee it's this
heuristic function that tries to find
strings when it prints them and it will
do as it always done with dilip e with
till the t t it will find strings in
utf-8 encoded binary stew and it will
find lists with unicode characters in it
so what will happen is as still EP is
what you use in the shell so if any
unicode character will be interpreted as
part of a string what will happen when
you write lists X something you will get
really funky characters in your terminal
and they're probably Ferengi because
every list of integers will more or less
be interpreted as a character list so it
will output it as a string most probably
a string with characters that your
turn'll I cannot handle so you will get
its funny faces and things like that on
your terminal so Yuri sticks for
determining if a list of integers is a
string it works well if you have a
limited number of numbers that can be
characters it's still limited but it's
like seven eight thousand characters out
there in unicode character sets every
list of integers more or less will be
interpreted as a stream so we have to
have a notion of the language in the
language the language you like the
language that will contain that your
strings will be written in and as it is
now you can only limit it to the latin
one character set so if you start along
with plus pc latin-1 it mean printable
characters or latin one characters you
can also use a plus pc unicode that
means printable characters over every
character
and you will get surprised but I often
used plus pc unicode because I will work
with unicode encoding but most people
like letting one better and that's the
default so let's look at IU for magnum
tility of okish barca which is a common
Swedish word if you're right okish
pocket as by twice and cody binary or
and as utf-8 and then write this in
utf-8 if you have + pz letting one only
yeah yeah well if you write till the
peel only work is packaged in bio I
think everything will be all right and
the rest would be interpreted as a
binary and print out as binary if you do
with till the TP it will find the utf-8
characters of a worker's party but it
will ignore or disservice because it's
not latin-1 characters so instead if you
do this you started with plus pc unicode
and then do the same thing you see with
till the TP all the orcish burgers and
adhesives will be print out as you see
ff8 binaries but if you do list 6sec
2010 2720 you will get these really cool
things on your terminal which is
probably work is work in some other
language I have no idea what what kind
of character that is looks at Arabic but
I have no idea so and you is so if you
have + pz unico you will see a lot of
lists of integrals really badly
interpreted so we'll see what to do
about that in next step or in if I ever
come to future work slide I will talk
about that again so and the shell it's
it will handle your characters if you
have a more than terminal which you will
have if you use linux if you use Mac if
you use windows if you use
vxworks I don't know okay so it
determines if you have a 8 utf-8 thermal
from the language environment so the
best way to confuse everyone is to set
lang to something using isolating one
and then turn on utf-8 handling in your
terminal then everything will look
really funny and it's fun for a while
but probably you want to keep these in
sync so you say my language is Swedish
with utf8 characters and then set the
terminal to be UDF at a terminal
everything would be smooth so there's
actually use this guide a few people
know that in standard library if you
look in that there's two things there
there's one using Unicode in a line and
there's one how how would the i/o system
works finger and read them they're
really interesting in its a really good
writer who has written them promise to
story but it's they're actually kind of
readable anyway so you can also
specifically set the terminal to output
utf-8 characters if for some reason it
doesn't detect a utf-8 so you can do set
often that you can do regardless of what
kind of terminal the detection by
language or LC ctype is done in the new
shell which is the owner shall we
installed along but if you start with
minus old shell or mines no shell you
will get another I or server that's for
pipes and things like that if you're
writing a field during our land or
something like it and that one has Latin
one or by twice encoding default for
backward compatibility reasons so then
you have to do you sighs adults to set
utf-8 encoding you can always use I'll
get ops to see what encoding it is so
and when we're done all this
you can write things in unicode you can
get them encoding in utf-16
little-endian and things like that and
it's easy you just do our format and you
work like you did before you just set an
option when you open the file and then
everything will be written in this
encoding and everything is nice and then
the first thing you'll try is to name a
file orcish partying all these cells
possibly and then you see that there's a
whole new aerial problems when it comes
to file naming to begin with you read up
on Unicode file naming in different
operating systems and they are really
proud in Linux of the transparent file
naming we have transparent file naming
it's the way to do it that means we
don't care that's the way to do it you
can name your files however you want and
you can use any encoding and encoding is
by convention so you could say no
encoding is the same as for the terminal
you can see it from the Lang environment
yeah but like files will stay there even
if you change terminal so whoever
created a file had one encoding whoever
is reading time to open the file might
have another encoding so transparent
means we haven't fought about really but
we're really proud about it so that's
how we do it not a butt but they did it
too so so the convention cannot simply
be assumed by but sometimes it can be
assumed or it's probable that if your
language environment says that you use
utf-8 characters the file names will be
in utf-8 characters but it's not so
probable so you can rely upon it so on
the other hand there's other operating
systems like the mac OS x and windows
which have done the right thing tada
they enforce it so if you however you
name a file it's always a valid you
filename so on on those operating
systems it's on by default handling
unicode file names for backward
compatibility reasons tada when in doubt
we regard every file name as by twice
encoded because that always works it
looks like shit but it works so if you
list a directory you get really weird
violence but they're there if you list
the director with by poison collabnet
one file names and have Unicode file
naming what would happen yeah you can
translate the work is parking letting
one encoding to utf-8 because you don't
really know what it is you can maybe get
two files with the same name if you use
your wrist exterminating and so on so
you can't do that so and when in doubt
we use by twice and coding for file
names if you want to be brave you can
turn on Unicode file naming which you
can be if you have a modern computer and
this your own computer and you have nod
or uses there that ruin everything so
then you start all along with plus FN
you which is five names in UNIX those
weren't taken and you can also have F
and eww which means file names in
Unicode and warn me if I get into
trouble so then you get all these
warnings if you have finance in your
file system that are not properly
encoded and you can also be see my brave
and look at the language environment and
decide from that so f and a full file
names automatic and you can also have
file names automatic e which means
ignore all violence that I cannot be
translated so what this also affects for
example open port how if you do spoon
executable to start a program how should
I interpret
by name of the executable so if you have
said financing unicode named your
program or bishops in Greek and want to
start it you can use spawn executable if
you've started will plus seven you
otherwise you will find out what's the
8-bit or utf-8 encoding of the file name
on the file system and then don't do
that so I'm also environment variables
if you have environment variables with
the orcish working if you have started
with effing you it will expect them to
be in utf-8 encoding which is the way
most operating system do it nowadays so
f nu is probably a good idea on most
modern Linux's and then the source files
which is the new thing in or 16 together
with some of the other things is that it
can be in utf-8 they cannot be in utf-16
or something they have to be in utf-8 or
by twice letting one encoding and just
as in Python you specify this on one of
the two uppermost lines in a comment or
whatever you want that can be read by
the compiler and you have a line that
matches this regular expression coding a
number of spaces colon or equal sign
number of spaces and then a bunch of
characters including dashes and the
bunch of characters which is the sub
expression there should match either
latin dash 1 or UTF dash 8 and that's
the same convention that a lot of other
programming language use so so you can
write for example code encoding utf-8 or
I've settled for encoding equals Latin
one or with coding kuplung latin-1 I
mean by poison coding which you can
write a lot of times on your blackboard
to so so a little roots in the source
code as in the shell you can write alpha
beta directly that will be a list with
two integers representing in the code
point
for alpha beta you can write like I did
before you can write a binary with an
encoding the encoding can be anything
and but if you do the last thing you're
right characters beyond 255 in the
source file you will get a horror of
truncation so by twice and coding of
characters that don't fit in a bath will
be truncated it will not be an error
that's important so if you had by twice
encoding of the source file did this
video produced an eight utf-8 binary
because if you input utf-8 characters
and by twice encoding you could take
character per character create a binary
with it and it with back would by
accident be utf-8 this has been utilized
don't do that don't ever do that always
tell what encoding you should have
because otherwise the encoding of your
source file has impact on the semantics
of your program which is not what you
want so don't ever do that yani again
so and what's not there I have one
minute to tell what's not there it's so
little that's not our so it's no problem
we don't handle graphemes I think and
management graphemes that agora theme is
what you perceive as a character and
that's not always only one code point it
could be for example the letter in
Swedish could be represented either as
what's also the Latin one number four it
can be represented as the code pound 40
followed by the code point for two dots
over the character that's before me
really clever isn't it so and it looks
the same way when you print it so
there's no real graphene support in in
our libraries brothers we'll see how to
handle that and how long has no notion
of language so two upper and lower
cannot be implemented and you say what I
need those thank you but it's actually
true if you have no notion of language
you cannot properly implement to upper
into lower so you can use open source
projects to root will come to the rescue
for example I 18m library mapping of our
line that's the thing to use probably it
has added all the language specifics to
our line so you can form a date strings
for Taiwanese you can do anything like
it and it has two upper and lower also
the beautiful language of elixir have
what's called language independent case
app case and down case in the module
string you can use that if you don't
really care about the language specifics
of up case and down case so for example
this if you use alex's ring down case on
Odie civ you will get something that
kind of right it's correct if you have
no notion or language because if you map
up case characters to down case and
don't know if this is a word or
something it this is what happens so
correct in some sense if you use i 18 n
you will get this which is correct in
some other sense because down case Sigma
in the end of a word should look like a
sea which has thrown up that's all I
know about it so I 18 in and thus the
right thing elixir does whatever it can
do because it has no notion my language
it doesn't know that in Greek your
assume you're supposed to do down k
Sigma and ask the lost character in this
way I hope yeah because this is nodding
and you look at German you have sharp s
you do up case and lower case and you
get two aces this is like hopeless you
can't do anything about it this this is
supposed to be two different words
muhsin or Howard's browns with sharpies
and muscle with 2 s's is two different
things but you can't do anything about
it no one can there's no solution to it
it has no uppercase version and in up
case sharpest is to assess and however
are you going to find out that it was a
sharpest so that's hopeless so even i 18
n library cannot do about anything about
it the I 18-year n library is a mapping
to the C library which is the C library
of handling things like that so it does
whatever it can as best as it can so
then if we look at i 18 n and take the
turkish i think it's a city and it's
pronounced I don't know and it has a
couple of eyes without dot
small I without dot if you capitalize
that you will get large I without dot
and if you down case it you will get
yeah you know what you do with a big I
you don't care city too small I with the
dots so and then you have not realized
you're speaking Turkish so if you tell
it my language is Turkish you will do
the right thing it will down case
capital I too small I without dots but
then you have to know all these things
about languages and we have no support
for that in our line yet so there's a
summary if you download my my thing
there there's a large summer of all the
options but you should read actually for
really you should read this part of the
line the standard lip users guide which
is actually have although some reason
also explains a lot of things that I
haven't got time to explain here I
haven't explained anything I've just
ranted about it but anyway so what we
want to do is make unicode file naming
default probably because when we started
with Unicode file naming which is
interesting enough I think down there
told me that I had to fix the Unicode
file names and I said that one is easy
i'll make it next week it took me like
three months or something it was really
weird and he laughed at me all the time
anyway we want more options to plus pc
letting one and unicode is enough
there's other options you want you want
say for example I speak Greek and
Swedish or I speak German and sweet you
saw something like that so strings that
are in German and Swedish I want the
heuristics of a line to output the
strings other things like Japanese is
not my thing so we want to support
installation unicode path and in this
case I've had a chance to get back at
downer because he is fixing that one
so installation in the unicode path
means that you can put along in a
directory that has characters in the
name that all beyond 255 and that sounds
like really easy because we can handle
those but that's not easy there's a lot
of programs around Erlang that has to to
find the directory and they have to be
converted to hand the Unicode violence
and things like that open ports porn
executable hand is unicode but open
ports porn does not yet that's
conceptually easy to implement because
it takes the string not a binary and the
swing is backwards compatible so that
may be in our 17 maybe up case and lower
case we have to solve it I mean that's
what everyone wants to do when you have
a string you want to capitalize it so
either by adding language support to the
language that will be easy I'll do it in
a week or a simpler approach like an
elixir okay you get some characters
wrong but most characters right or fix
that scheduler and implement i 18 n or
integrate i NN because now it's
implemented as sniffs and if you sound
like a book to it it will produce a book
in one schedule and you won't get half a
there your real-time characteristics the
schedules will blow up in your face and
and wicked will send evil emails to you
and whatever so if we fix that the
scheduling which means schedulers that
that or can be put on hold for a long
time we can integrate I 18 and probably
atoms in Unicode is not supported so the
language is still has the Latin Wang one
character set except in string literals
but we hope to bring your full Unicode
range to atoms maybe to the variables
there's a big debate or has been a
debate we reach you to Keith the one
they told you held a speech that no one
understands things we should have it in
very
and I i think i agree but others don't
so and we have to have a string library
that's better now obviously and we may
want if you look at elixir have you
looked at elixir has anyone looked at
elixir yeah it's really cool look at it
and they have all the string leaders or
utf-8 binaries and it's so much easier
to write yeah we can't do that the
dragon you know of backwards
compatibility but maybe a simple little
syntax for you David binaries as it is
now a less than less than double quote
blah blah blah double quotes slash utf-8
less greater than greater than isn't all
that fun to write so we'll see oh I've
tried for all its speech to use the
remote even though I know it doesn't
work isn't that interesting I'm so
stupid ok questions ah none um no I like
smash the schedule
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>