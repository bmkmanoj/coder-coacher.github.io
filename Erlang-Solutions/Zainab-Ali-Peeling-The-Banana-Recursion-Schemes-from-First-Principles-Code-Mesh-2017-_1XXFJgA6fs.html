<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Zainab Ali - Peeling The Banana: Recursion Schemes from First Principles - Code Mesh 2017 | Coder Coacher - Coaching Coders</title><meta content="Zainab Ali - Peeling The Banana: Recursion Schemes from First Principles - Code Mesh 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Zainab Ali - Peeling The Banana: Recursion Schemes from First Principles - Code Mesh 2017</b></h2><h5 class="post__date">2017-12-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_1XXFJgA6fs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so yeah I'm going to talk to you
about peeling the banana it's a bit
obscure so first of all I just wanted a
show of hands how many people actually
know about the banana that we're going
to peel it's called a cat a morphism
okay so I see all right I think that
that's around less than 5% of you and
that's a great sign because it means I
can tell you all all right okay so the
kind of banana we are going to peel is
not a snack unfortunately it comes from
a paper where the rather friendly title
functional programming with bananas
lenses envelopes and barbed wire and
yeah it's really friendly right I mean
if what we've got this title we know we
can go and understand it right and this
paper it was published in 1991 around 25
years ago and so you'd kind of think
okay we've had enough time right these
techniques they should surely be
something that we're using today all the
time because it's an absolutely
fantastic paper but unfortunately that
didn't happen and you know I'm not quite
sure why I think perhaps part of it is
because this paper deals with recursion
and recursion itself is a pretty
difficult concept I don't know if you
guys can remember the first time you
wrote the factorial function back in the
days you know when he started learning
functional programming I don't know if
you can remember the pain that he must
have gone through in trying to get it to
work and the Enlightenment that you got
at the end when he could finally write
one that actually terminated and I think
that we all go through this and
recursion becomes something that we
don't really want to touch and
understandably stone right because so
easy to write programs that don't
terminate or do the wrong thing and
they're so hard to debug if they
recursive but I think that there's a bit
more to it than that
perhaps it's also because of notation
now I don't know if you guys you all saw
yesterday's keynote right about the
hazards that notation can bring to a
discipline and this paper does have some
rather obscure syntax in and in its
defense it explains it all so they do
define it and if you did take the time
to read it just take it slow but
everything's there
I think perhaps the biggest reason why
it's not being adopted is because this
technique doesn't arise from
conventional functional programming it
doesn't arise necessarily from lambda
calculus and you can't see it quite
easily when you're looking at code it
actually comes from category theory and
for a long time category theory has been
a completely different discipline and it
hasn't really pervaded functional
programming as much as it should have
done and so what I want to try and do in
this talk is show you how we can use
category theory to solve some problems
which you know you might not think would
be solvable and how we can abstract over
what we do taking something from a
different discipline okay so what we're
going to do is first take a look at
recursive datatypes themselves and see
if we can find out what they are we're
going to dive into category theory to
try and solve some problems that we get
when we try and generalize them and will
derive recursion schemes now I want to
say one thing which is don't panic I can
see a banana that's great that's
fantastic yeah we're already there half
way anyway yeah don't panic because
there are going to be a few terms in
this talk which you might have not heard
before don't concentrate on the terms
concentrate on the concept and what they
represent terms are useful when we know
what they mean and we're trying to
communicate with other people but when
we're learning a field they get in the
way okay let's make a start recursive
data types I'm sure that you guys have
probably all worked with lists before
and this is probably a most basic
example this is Haskell I figured that
house called B ok here I do have a
backup presentation in Scala if that's
more preferable but no
all okay all right yeah so this the
recursive data type in highschool
I've removed the parameter on list so
this just represents a list events and
we know it's recursive because it
references itself now I've got a
question for you if I gave you one of
these lists would it terminate could you
be sure that it would terminate
no you couldn't not in Haskell anyway
now in some languages you could if
you're working in Scala this list would
terminate but Haskell is a lazy language
which means it doesn't evaluate things
as soon as it gets it and you know this
is a major problem it means that when
you're writing functions you're not
quite sure if they're ever going to end
if you're operating on a list you have
to be very careful and unfortunately I
don't have a solution in this talk so
what I want you to imagine is that all
the data structures that were dealing
with all of them are terminating
structures so the basic example of a
list of three numbers here now the cool
thing about a structure that terminates
is that I can write a function to
collapse it I've got two functions here
one multiply which multiplies all the
elements in our list and one length
which calculates the length of a list
now again I'll reiterate if I did this
on an infinite data structure it would
not be good but I can do it on a finite
one so they look pretty similar don't
they in our nail case over here we're
returning one in nil over here we
returning zero we're doing something
else in our concert case in our cons
case we are calling again our function
and so you kind of get the intuition
that if you want to collapse a recursive
data structure you're going to need to
write recursive function to do so and so
that gets really annoying luckily what
we can do is that we can take a look at
these functions and there are a few
things that are similar and a few things
that are different and we can take out
the parts that are similar and put them
in something else default
how many of you have used folds before
great you're all doing the right thing
that's good yeah we shouldn't write
recursive functions using explicit
recursion we really should use folds
they make life so much easier what we've
done is that we've taken the recursive
part and we've stuck it in this function
and now for all of our actual logic the
thing that doesn't do the recursion but
is necessary to compute multiply or
length we've taken that out and said
let's pass those in as functions and so
over here I've got a function multiply
the same function but now to find using
fault and it's a lot simpler now these
functions which take a recursive data
structure and collapse them down are
also known as cata morphisms so it's a
complicated term for something which
we've all been doing now the interesting
thing is that I can actually write this
for a different data structure I can
take a binary tree yeah I don't know
where my binary tree is I can take a
binary tree and write a fold for such a
thing if it has a leaf then I can write
a function to collapse a leaf if you
write some node then I can write another
function to collapse the node and what
this does is that again I've captured my
recursion inside my fold and again if I
want to write now a recursive collapse
for a binary tree all I need to do is
provide a function for what I want to do
in the case of a leaf and what I want to
do in the case of a node and so again
I've got a fold function on a list and
the full function on a tree now
if you take a look at these two data
structures and these twofold functions
that we've written they're pretty
similar aren't they in both of them I
have to deal with each case I have to
deal with the nil case in the list on
the Khans case in a tree I have to deal
with the leaf and with the node and they
both collapse them but apart from that
they don't have much similarities and so
if I was to pose the problem to you how
would you generalize this could you
write a single function which would do
the job of both of these folds how would
you go about doing it and you know it's
hard to make a start on that maybe we
could you know launch into the world of
dependent types and see if we could use
interests for something like this it
seems to me the solution to almost all
our problems these days that wouldn't be
a good thing to do maybe we would get
somewhere will be interesting to see if
anyone tried but there's actually a
better solution
we're going to use category theory and
category theory okay it's a very
different discipline and it's a lot more
abstract I'm gonna explain what this
diagram means it's basically the whole
of category theory by the way so if you
understand this diagram then you know
you've understood whole field it deals
with composition we essentially say that
okay I've got two things I've got
objects which aren't that important
they're just points and I've got these
arrows which go from object to object
and they compose so I can perform arrow
F and then perform our G and that's just
the same as performing F and G and this
is a composition rule I also have a
special arrow called ID in which I go
from an object to the same object and
that doesn't do anything so you know if
I can do ID and then F and that's the
same it's just doing F and then ID on
this one which is just the same as doing
F so ID does nothing and also if I have
composition if I'm composing F and then
G and then something else H that's just
the same as composing F and then
composition of G and H and this looks
really similar to function composition
doesn't it and so we can actually use
category theory to model function
composition in programming
the way that we do that is that we say
okay our objects in category theory are
a B and C those are types and these
arrows here those are functions and so
we can use this to represent what we do
when we code so let's pose our problem
in category theory I've said that what I
want to do is take a general recursive
structure and collapse it into a single
value and all the things I have in
category theory the only tools I have a
composition so the way that I need to do
that is I need to find some arrow that
goes from a recursive object recursive
type a to another type sorry recursive
type R to another type a and the only
way I can do that is through composition
so I need to find some other stuff to
compose to make this function but before
I do that I'm going to take a step back
and I'm going to take a look at our
recursive data structure again a list
and I'm going to do something
interesting with it I am going to make
it higher kind it but not higher kind
and in the sense that you normally see
lists I'm going to pull the recursive
part out of it
this thing used to be list I'm going to
pull it out and make it a type parameter
and so if you look at this thing it's
not a list anymore because I can put
anything in there I can put for example
a string I can write fewers cons F of
one foo or what I could do is that I
could repeatedly apply it to itself now
if I repeatedly apply it to itself it
looks kind of like the list that I
initially had doesn't it so that's
trying to find what this kind of like is
what we mean is that I can convert from
a list F of a list into a list without
losing any information so I can go from
nil F to nil I can go from cons F of
head and a tail to cons of head nor tail
provided that this tail is a list so I
can go from a list after list and you
know I can also do the same I can go
from a list - a list of a list and again
the only thing I do is really replace
these constructors instead of nil I go
to
instead of Kahn as I get to concept and
so okay that's kind of interesting right
but I basically can go from one to the
other and the way that we write that in
category theory is something that's
known as an isomorphism and it's just a
complicated term for saying these two
things I can convert between them
without losing anything so we've said
that we've got our recursive type R
that's our list right we've got some
other type F R that's our list F and
I've written some functions in but go
from a list F of a list - a list and out
which go from a list - a list F of a
list and these two functions are such
that if I compose them if I go in and
then out that's just the same as ID
because I haven't done anything right
and just as well let's say that I I
start with my initial recursive
structure and then I go out and then in
that's also the same as ID because I
haven't done anything so okay that I
said this is a useful concept but you
might think okay well it's kind of
useless right I mean I'm just saying I'm
not doing anything
what's the use in that and it turns out
that all this death is useful because it
brings us a few new tools to work with
and one of the things that it brings us
is a function so here's work with
functors before okay most of you that's
good a factor in category theory means
almost the same thing it's something
which takes some object a into some
other object F a so I can take a type
list and take it into a list F of a list
it's something that takes a morphism
so that's this arrow from A to B and
turns into another morphism from FA to
FB so I can take some function f and
I've got some operation I'm going to
call it map which takes this function
and turns it into a function from FA to
FB so this is the same as the functors
that you see in
High School in Scala in whatever
language it's just a map operation plus
this thing that takes types in two types
so this is what a functor looks like in
Haskell pretty simple right just this
map operation I take a function from A
to B and turn it into a function from FA
to Fe and I can implement this for list
if I can say that map or nil does
nothing map and cons F means I apply it
to my tail and you know it's pretty
interesting because you can actually
derive this I think probably using some
language extension maybe you can you do
it in just standard Haskell I don't know
you can actually derive this in Haskell
and it will derive this factor for you
because there are rules behind it
so if I'll just give us something else
they give us something which is called
an F algebra which is just a complicated
way of saying that I want to go from an
F a to a and I'll have an arrow together
so this is just a function right it's a
function that goes from F a to a and I
can code this up in Haskell I can say I
can put a type alias for it type its
algebra for something that goes from F a
day and you've already seen one of these
before
in fact the function list that I defined
earlier this thing oh sorry the function
in that I defined earlier this is
actually an F algebra it goes from this
stuff of list to list so I'm going to
define another one here called multiply
algebra just arbitrarily it's not as
though I'm doing anything any kind of
multiplication of course we are we
define one and we say okay in my neal
case i'm gonna return one in my cons
case i've got two integers here remember
and i'm going to multiply those together
okay so um let's try and put all of this
together and see what we get
remember we've got three ingredients
here first of all what we had is our
recursive type and what we want to get
is some other type a we want to collapse
it onto this type a
we started off by defying a higher kind
of data structure list F which is this
type F R and we said that that's kind of
interesting because we have an
isomorphism between them we can go in
and out between those two and we also
said that hey this thing is a functor
that means I can map so if I did have
this this function cata I could also
write the function map cutter which went
from fr to some other thing F a right
and we also looked at algebras and we
said well an algebra is just this arrow
that goes from FA to a and remember I
said the only thing that you can do in
Category Theory when you're trying to
prove something it's through composition
can any of you see a way of composing
some of these arrows together to
actually come up with a definition of
the Cata morphism I'll give you a moment
you can take a look
okay so this is the one I came up with I
think it's the only possible one if we
start with that we can go out and then
we get to Fr Wickham in a format quatre
to get to FA and then we can operate our
algebra and go back to a and we can
write this like this we say out and
their map quatre in then out and this
translates really well to Haskell
so this is what it looks like in Haskell
I can say I've got some function cat Oh
which provided that F is a function take
in an algebra and something that should
be my out of my isomorphism and I can
return a function that goes from R to a
and a define it like this it's pretty
pretty straightforward and so what I can
do is that I can now say okay let's say
that I take my multiply algebra and I
take me out that I defined for a list F
and I put those together then I actually
get the multiply function that I started
out with so I actually get a recursive
collapse and I just want to take a
moment here and you know congratulate
ourselves on what we've done because
it's actually really cool right this
function is going to work for anything
which has a functor right what
particular kinds of functors wrote
anything which has a functor for any
kind of algebra that I provide which
means that what I've done is that I've
achieved what I set out to in the
beginning right I have now written a
function which is equivalent to my fold
on my list and my fault on my tree
together and this will actually work for
any recursive data structure all I need
to do is define some function
representation for it and then what I
can do is that I can collapse it and you
know the other really cool thing about
this right is that because we've done so
using category theory it's not just
applicable to Haskell
it's actually applicable to any language
provided you can model that language as
a category provided that you can say
what the objects are and what the
composition is you can use this
technique
and so maybe maybe we can go further
than that let's not just stop here what
about another problem what about the
problem of building stuff up of
unfolding let's say that what I actually
did is that I want to construct a list
now and I want to construct a list from
an integer I want to construct a range
of numbers and I'm going to define a
function here range and I taken in a
number if it's greater than zero then I
want to do a con sub n and n minus 1 and
if it is zero or less then I wanted to
return nil so what I'm going to do here
is that I'm gonna build a range of
numbers going down so I'll be something
like three to one and this thing has a
technical term it's called an animal
fizzle in the paper I think it's also
it's a lens in the paper now I should
say that this lens is not the same as
most of the lenses that you will
normally see in functional programming
don't get confused just call it an
animal fizzle or call it an unfold
they're equivalent the same thing and so
we might think okay well we've used this
technique to derive cata morphisms maybe
we can use it again to derive this thing
anamorphisms so we want to go now from a
to R we want to build a recursive data
structure and this is what we've defined
so far
maybe there's a path maybe there's a way
of composing all these things together
can you see one no no confused faces
that's good that's good that's because
there isn't one over here but what I can
do is instead of providing an algebra
what if I provide a car algebra what if
I say ok my function now should go from
a to an ebony now if I do this then is
there a way of composing yeah we just go
around don't we yep and so
using this path in green I can actually
come up with a derivation of an animal
fizzle I can say I want to have a CO
algebra then map of my animal phys 'm
then in and similarly I can write this
in Haskell and it's also fairly simple
I say provided that I have a functor and
I've got Co algebra and I have something
which is to represent my in then I can
write a function that goes from a to R
again for any recursive data structure
and so I can write my range like this I
can say here's my range car algebra if n
is zero then I want a cons f of n and n
minus 1 or I want to nil if so this is
looking pretty similar to the initial
function we had and I can define this
now using an animal fizzle so that's
pretty cool maybe we should stop there
should we stop there we can keep going
can't we can keep going come on
what about recursion itself
let us say that I don't actually have a
recursive data structure I've just got a
recursive function this is a factorial
function it's one of the ones that
plagues us when we start functional
programming factorial and Fibonacci I
just discovered that you can get worse
than that
there are worse recursive functions that
you can write but yeah when I was
starting out this one was terrible it
looks simple but it's not right so we
take a factorial of n and what we say is
that ok n is greater than 0 then n times
the factorial of n minus 1 or 1 so we've
got a recursive function and actually
factorials kind of special because what
it does is that it builds up a cool tree
and collapses it and so we can call it a
high-low morphism and maybe we can use
the tools that we have to try and tackle
this problem so let's try I'm just
putting everything that we've done so
far onto a diagram and seeing what
happens right this this is you know if
you're not too familiar with what you're
doing just splurge stuff on
might get an answer so yes this is the
stuff we had from cattle morphisms this
is the stuff that we had from animal
physics and this is what I want to do
I've got some type a I want to get to
some type B maybe there's some
intermediate recursive data structure
for it possibly and so we can say is
there a way of writing this
can you see one yeah there are many ways
actually to define a high-low morphism
using this I could go here and in here
and the path that I'm gonna choose is
this one I'm going to say let's apply
our Co algebra then let's map our holo
morphism and then let's apply our
algebra and this path is kind of special
actually compared to the other ones
because I'm completely bypassing the
data structure in the middle and that's
really important because it means that
when we're actually running this
computation it's a lot more efficient
than if we were to actually construct
this thing so this is what it looks like
again we need a functor we need a Co
algebra and an algebra notice that we
don't actually need the isomorphism we
don't need in or out here and that's
pretty interesting I think that we kind
of need them to exist
so we can actually write our factorial
in terms of this because we can say what
if I take my range Crowder bruh the
thing that built up a range of numbers
and then I take my multiply algebra the
thing that multiplied a range of numbers
and I put those together I can get a
factorial function and the reason why
this is so cool is that these two things
range Kaja bro multiply algebra they
were defined in terms of our lists
weren't they they were to find in terms
of our list F in fact our list functor
but factorial itself we never think of
lists when we're doing factorials do we
but now we've discovered a relationship
between them and it's actually because
the tree of a factorial if we were to
actually examine it would be similar to
a list
and so maybe we can try and get this
intuition about other recursive
functions that we deal with Mabel you
can take a look and see what their core
trees look like maybe they look like B
trees or something more revamped but
okay there is something which I haven't
shown you right I should make a
confession here we've discovered this
really new to cool new technique and we
can apply it to so many things and it
can give us so much power and out
because we can now apply generalize
collapse to any kind of recursive
structure but we need to define quite a
few things for it in particular what we
did was we had our initial data
structure then we defined a functor for
it and then we defined a way of going
between them these two functions in and
out and that's a lot of stuff to do
right we don't want to have to do that
for every single dated structure that's
almost the same as saying ok you have to
write fold for every single data
structure so maybe there is a way of
getting around this boilerplate what we
really want to do is save it let's say
that we define our list effort our
functor maybe we can come up with some
other data type foo
such that in and out are defined for
that data type food for any factor that
we have this is actually pretty
difficult to come up with them you can
stare at this for ages you're probably
not gonna find an answer but there is
one and it's called fix it looks a bit
bizarre
because it essentially takes some higher
kind of type F and wraps it and so we
can actually write in an out for it for
this bizarre type because in if you take
a look at it closely it's just our
constructor here and out is just this
unfix operation and so if we write
whatever recursive data structure we
have if we write that in terms of fix
and our functor then essentially we get
these things for free so we can actually
depend on some library to provide us
with this and we can just write this
stuff and that's really cool
you know I I could go on and on and keep
going with this because then we've done
some cool things but they're they're
away more we could take a look at fusion
for example you might have heard of
fusion with functors where where you
take two functions and you put them
together and you can actually perform a
map over both of them instead of
performing individual ones you can
actually do that with Falls and that's
really exciting we could even take a
look at comen apps and see where they
come into the picture
they make our diagrams in category
theory even more exciting and
complicated but they give us some really
really cool things and in particular
what they give us is even more ways of
folding over our data structure because
we've only looked at one way we've only
looked at the cattle morphism the normal
collapse there are actually others we
could go and look at Paramore fizzles or
Zygon more physics which sound confusing
but I tend to look at the signatures
more than you look at the words and they
make a bit more sense but unfortunately
I think we we probably don't have too
much time so what I will say is go and
do those later definitely go and play
around with them you know what what I
want the takeaways for this to be not
only that we've managed to define a
generalized collapse that's a great
thing that we've managed to do but also
that we could have actually done this 25
years ago we could have actually done
this when Haskell was starting and
integrated it right into the language
and so maybe every single data structure
in some kind of parallel universe every
single recursive data structure that
people deal with in functional
programming automatically comes with all
these recursion schemes but that didn't
quite happen I think that at the time
maybe people didn't spend enough time
learning about these other disciplines
and learning about category theory and
seeing what it can give to us and so
what I want you to take away to be from
this is that if we go and try and look
at other disciplines and transform our
problem into other spaces then we can
get a lot more insight on solving
problems than the way we would normally
we could have stared at those functions
in the beginning for ages you know
stared at our lists and our tree and
tried to combine them probably wouldn't
have found a way unless we'd gone and
transformed it into another disk
and so category theory I'm trying to use
in functional programming it's really
awesome and there are loads of other
disciplines too and we can try and use
those now some of the stuff that I've
mentioned actually already does exist
there's a library in Scala called
Marasco which is where I started playing
around with them it's by slam data there
is recursion schemes in Haskell by the
wonderful head met who's done a load of
other amazing stuff as well
and recently I've also discovered one in
interest and be interesting to see how
that one actually works because I reckon
that it should work in a slightly
different way to Haskell and styler
because of the way that the language is
written so I recommend you to go and
pick your favorite one of course we all
know that your favorite one is going to
be Idris right out of all these it's the
mainstream language now go and play
around with it and see what you can do
and if you want to know more here are a
few resources a few things that pretty
much summarize what I've done as well
definitely look at the paper I think a
lot of people don't give it enough
enough of a chance because it has a lot
of confusing notation but if you just
take these diagrams and draw them next
to it it'll make things a lot clearer I
think there's also a article on
understanding if algebra is by
bartokowski bartosh has done a load of
he's written a load of blog posts and a
few books recently on trying to make
category theory approachable to
programmers and I think they're a great
place to start if you're more interested
in thick's because that is a really
mind-boggling thing take a look at
recursive types for free by Philip
Wadler it goes into how the fixed point
type well some of the problems with it
and where it arises from and if you
actually want to see a really cool use
of recursion schemes I'd recommend this
one because it's data type Genetic
Programming and what it does is that it
tries to use recursion schemes to model
object-oriented patterns which is
something that you know you kind of
think how do you do that right it's
really cool the fact that you can take
this and you can go and moral things
like visitor patterns and stretching
patterns that's something else that
hasn't quite gotten be interesting to
see its applications
and yeah thank you for listening
oh cool that's great shall we go back
had a lot more size than I thought okay
so get the pointer first of all this is
a we're trying to get this function this
cat a morphism we're trying to get it we
don't have a big mission yet but what we
do have is that we have this type F
which we know is a functor so what we
can say is that if we have a functor we
have a map maybe if I get a few slides
back I'll show you the functor this one
so what a functor does is that for any
function here f we can basically define
another function map F by mapping that
and I can show you this isn't example
right so this is our functor for list we
take in some function f from A to B and
we say that okay that's now a function
for list F it goes from list F of a to
list ever be and it does that by
operating on the a inside okay following
so if we have that that means that for
any function we define up here we can
defined a corresponding one down here
and so couple that with our isomorphism
and also some other algebra which we
provide the multiply algebra was
something we wrote then we can actually
loop around like this
yes okay
what's the interpretation of the int in
the type signature of list F why do you
mean do you mean this int yes right so
we're representing lists of integers
yeah only lists of integers so the
important thing to realize here is that
this isn't our normal list even though
it's parametrized by a type right the
thing that you normally see as these
swapped around right need to see a list
on the tail at some value a and that
would mean that ok I've now defined a
list which I can put any type in I can
have a list event or a list of strengths
or it is for something else what I've
actually done here is said okay this is
just a list of well it's something which
contains an int and some other thing a
which means that I can do this right I
can put a string in there it's not a
list anymore so we could also
parametrize over int as well oh yeah you
could certainly do that it's just for
concreteness that we yes and the
interesting thing right is that that
would essentially mean that let's say
that we did put two parameters here we
put an A and a B normally what you'd
want to do is you'd think of your okay
I've got a list of a my list is also a
functor
that's normally what you'd think to get
that functor you would actually define
it using either a cat a morphism
or an animal fizzle and that makes sense
if you think about it because if you
think about the definition of a functor
for list if you try and write one you
actually do collapse a list and you
build up another one as you're doing so
thank you
hi there was another part that I didn't
get in the definition of high-low maybe
I should just kind of flick forward like
this the codes implemented the
implementation of it yeah you're calling
high-low again it looks like recursive
function without stop condition so how
does it work how would it stop this
recursion
it actually comes down to our functor so
if we were to take a look it's a really
interesting question it's one that I got
confused about a lot when looking at it
the first time as well
if we take a look at this when we have
nil we don't do anything with the
function anymore so even if this thing
here is a recursive function which calls
itself I'm not going to call it anymore
as soon as I get to my nil case so in
Heine morphism we had an animal furs a
much build up and a cattle morphism
which folded down as long as that data
structure terminates we'd have we did
encounter this nil and we'd basically
throw away the recursion exactly yeah
that make sense okay
hi it's an interesting talk and lights
David I've been playing around with some
ideas like this with my PhD student to
vite Castro and so we'd like to chat you
a bit about that afterwards
but I want to say you said if Hosford
known a bit if the Haskell designers
have known a bit more about category
theory we would have done things
differently and I would say that when we
were designing Haskell we have spent a
lot of time learning about category
theory it's very very popular at the
time so we we looked at a lot of things
in not necessarily these things exactly
but monads of course come from an
understanding category theory and we
also look to things like vibrations
which you haven't mentioned which are
really quite complicated
we felt the time Haskell supposed to be
it was supposed to be a conservative
language design this was this was in the
job description yes the job description
hassles it was supposed to be
conservative although we could see this
really nice patterns here we thought it
was just too soon to try to introduce
these to the maths of out of the world
at large we didn't think people did cept
Haskell if we did that now my conceived
world has changed and this is great
thank you
hi the the type parameter in the functor
yeah what's the role of that you're
collapsing into what is the role of the
type parameter in the functor this death
the lister okay so if I go to back to
the definition of the lister okay so
what we've done here is that we've taken
the recursive part the list and pulled
it out and made it a type parameter here
right what that means is that this thing
does not necessarily need to contain a
list right it could contain anything
else and if you think about it not in
terms of category theory but in terms of
what you're doing in the code what
you'll see is that you're actually
substituting the thing that you'll let's
say you're doing a collapse you put the
thing that you're collapsing inside
there the thing that you're accumulating
so if we take a look at the algebra it's
further on yeah if we take a look at
multiply algebra right this thing that
I'll get here is the multiplied value
that I'm accumulating at that point
right so let's say that I have a list of
three two one and what I have in the
head is is three what I have in the tail
is well that should be two because only
two times one and then I'll multiply
those together so you can think of it
almost as though what I can do now if I
make this thing higher kind it is that I
can contain the thing that I'm
accumulating or folding out of if you're
building structure thank you
okay any more questions
no you sure
so perhaps what I should have asked
earlier when I was asking about what is
the interpretation of IND is if it was
string
what would the factorial function be oh
so okay so let's say that I wanted to go
to from string to string right I would
still have to write different algebras I
don't know what your range algebra would
be for a string and I don't know what
your multiplication would be but you'd
have to define those but if you did
define those then you could come up with
a factorial function for a string you'd
have to define what multiplication meant
okay thank you
okay so it's definitely a list right if
we look at the type of algebra here it
goes from FA of a f of 8a so this is
going to go from a list F of int to int
wish yeah so this thing is definitely an
end</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>