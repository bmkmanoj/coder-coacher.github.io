<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What Elixir is about - José Valim -  Erlang User Conference 2015 | Coder Coacher - Coaching Coders</title><meta content="What Elixir is about - José Valim -  Erlang User Conference 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>What Elixir is about - José Valim -  Erlang User Conference 2015</b></h2><h5 class="post__date">2015-06-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QXcedVc2LQM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so thanks everyone for coming to
the talk this talk is about the elixir
programming language and to me this is a
very interesting talk to give because I
think today we have a very clear
objective for the language and what the
language is about but it was not always
like that
so it's really nice to look what we've
did in the last year's and say like okay
I see this is what it is about and
that's what I want to show this talk and
I have to have the slide
Francesca kind of spoiled it but it's
not about the syntax so Alex Siri was
never created as a syntax reaction to me
it would be not enough reason for
example to create a perimeter image you
need to have more than that and try to
offer other things and that said okay
the way I so in order to explain what
elixir is about I want to go to how I
see how the airline code works or coded
runs on the Erlang virtual machine and
the Erlang runtime how I consider it and
how I say it okay so when we are writing
code for there named brutal machine
there are really three things here they
are the data type so integers tuples
lists and we have modules and modules
where we actually have our behavior our
code okay and then we have this other
thing called processes which kind of
ties everything together so the
processes they contain most of the data
types right so when you have an integer
when you have a list it belongs to a
process and a process is running a code
defined by a module and after we have
all those things right we want to we
were we heard a lot about tolling this
morning right so we want to package all
that in a very nice tooling and when I
look at this now the way I consider it
is that we have for those three things
they are two that are very well
developed right and and two others that
dairy they could be improved and they
could be better citizens right in this
round
time and on the language as a whole so
processes they are clearly the main
attraction of the show right
that's our distraction for concurrency
our abstraction for distribution we have
great tools for introspective monitoring
processes is excellent right superb and
then we have modules that they are very
expressive to is where we write our code
we have four you have other great things
associated to modules for example it's
our abstraction for doing things like
hot code swapping but when we look at
data types they were really not as well
developed with time as everything else I
think a very good example of that is how
long it took for us to get a very good
support for an associated associative
data structure like maps they are here
I'm really glad they are here it's they
are fantastic but it took a while and it
kind of shows that you know this part
kind of like always or a little bit
behind lagging a little bit behind and
there are more evidences of these right
so for example we still have no custom
data type ok records aim to add tagar
tuples to the language but we have
thousands of discussions about the
implementation kind of backfired the
communities kind of has a love and hate
relationship with hackers records to me
maps are improvement in when compared to
records but they do not officialize
tagging and what I mean by that is that
there is so records one of the main is
that they are compile time right there
just a compile time there is very little
you can do with it at run time run time
because everything gets compiled away
and maps they are run time only so there
isn't a way from and say hey I have this
map of this type and if I try to match
this map with some particular field that
doesn't really belong to it I would like
to have errors also at compile time if I
tag it okay so we don't have this idea
of tagging the Richard O'Keefe proposal
for frames before he had maps they it
actually talked a little bit about
tagging so you don't have this yet
another evidence about how it could
improve our data types of art in general
there is a paper from Philip waddler
from 88 okay where he's saying you know
we need to make ad hoc polymer fees we
are going to talk about is that the hawk
apartment this is the main form of
polymorphism we have in Erlang we need
to make it less at talk and he goes into
detail why other forms of polymer fields
were important and what we gain with
expressiveness on that and another
example okay and this is just to tease a
little bit there's actually some Java 8
code okay and Java 8
they added lambdas finally to Java and
with lambdas they added all these
functional vocabulary that we are
familiar with ok so I now I can filter a
collection I can map I can reduce and
this is something very interesting it
was actually one of the first things I
missed when I came to airlines that
Erlang has no idea of collections yes we
have lists we have sets we have
dictionaries but there is no API where I
can work with those things as
collections ok so far as I point is Java
8 code I have a widget with the
collection I don't really care if it's
in a hey and an array a set I don't care
about it ok and I can filter it so I
have widgets I can filter getting
widgets with the color red and then I
can map it getting their weight and then
I can send the result ok so to me this
was a very big deal I want to have a way
to express things as collections and one
of the big benefits we come from this is
that I don't need to learn new api's
every time i'm going to work with
different data set even more if i'm
treating it as a collection i can have a
filter function that works with a huge
variety of data types and not only that
right we see a lot of function well we
see a lot of functional programming
language is doing is that they do not
only have the idea of collections but
they also bring the idea of laziness
right when working with collections so
if we go back to the previous code what
is going to happen here is that if I
have widgets and then I filter them I'm
going to traverse the whole collection
and
to them and then if I want to map I'm
going to traverse the whole collection
again mapping and getting some value and
then I'm going to sum which is going to
get this latest traversal and some
traverse everything again and get the
final result if disease even more if
we're talking about the functional
language that is immutable if we have a
large collection here it means we're
going to generate a bunch of garbage
right because they're going to traverse
the widgets once right and then we were
ready to traverse it again and then
traverse it again and it can be
expensive in terms of memory many times
the whole idea of laziness what we can
do is that we can say hey I have these
widgets stream and what a stream say is
that all the computations we call from
then on it's like a recipe it's going to
be stored so it's a wheesh it's not
string and when we call filter we're not
going to traverse the whole collection
at that moment we just store that
computation when we call map the same
thing we aren't going to traverse that
we're just going to store it and finally
when we call sum we kind of fold all
those recipes right all those
computations together and then we are
going to do it just once because sum is
going to realize a final value which is
an integer okay with this in mind right
so what is that clear about well what
elixir brings to the table you probably
have an idea right from those first
slides and every time I'm talking about
elixir I like to talk about it through
the language goals perspective okay so
we have three goals as a language we
have the goal of extensibility
productivity and compatibility and the
rest of the talk is actually going
through those goals and giving examples
of what we are doing to express them so
let's start with extensibility and the
point I want to make about accessibility
here is exactly about polymorphism and
I'm going to call it data type
polymorphism it's not the correct name
for it but I'm calling it because I hope
it's going to be very clear what we we
are aiming with such kind of polymer
fields okay so if we go back to the
previous slide right to the the second
slide at the top were saying about data
types modules and processes it happens
that modules and processes they are
polymorphic in their way okay so for
example we write code like this I want
to send
message to this process okay represented
by this PID and when we write code like
this what we are saying is that I don't
really care what is that process I don't
care which what is it the state I don't
care which module code is running all we
care about is that that process know how
to handle that particular message so we
can write a code to say hey I want to
send this message to any process that
handle this message so you can pass me
any PID as argument as long as the P
idea that process know how to handle
this message okay modules they are also
polymorphic right we can pass modules
around as atoms and you can say hey you
can pass you can give me any module as
argument as long as this module
implements this function are those set
of functions this is exactly how the gel
server the behaviors work right gen
server supervisor what we do is that we
call the gym server module passing our
module as argument and we and the
implementation doesn't doesn't really
care how many functions it exports it
doesn't care about the module name right
it just cares like do you implement this
contract right are you implementing
those functions so we can say hey give
me any module as long at this mall to
export this function however when it
comes to data types we don't have that
right there is no there isn't we can I
cannot even talk about it right because
there isn't anything I cannot say hey
you can pass this argument any data type
that does this thing okay and and that's
one of the issues we we try to solve so
in order to to show why this is a
problem okay and how these limits
developers I want to I like to give you
serialization as a as an example so here
I pick JSON sterilization okay so we
wrote this airline code we need to
serialize we need to encode the stuff to
JSON so in this cover it is that we
define the JSON margin then we are going
to define a bunch of clauses right and
say hey if I want to encode this item to
JSON and this item is a list here's the
code that's going to do the encoding if
I want to encode this item and it's a
binary to JSON here is the code okay we
are going to define a bunch of clauses
right and are going to
probably handle the major data types
that comes with OTP and you're going to
encode off all of them and then you are
going to ship this library right you're
going to put it on github and anyway to
be there what is going to happen in the
future is let's manage that this library
it becomes very very popular a lot of
people start using it and in the future
is going to happen is that Robert he's
working on the rural project as an
example okay and he says oh I want to
add JSON encoding support to this laurel
project the issue is that the laurel
project uses a special dictionary
implementation okay to part the looool
objects and the json library doesn't
know anything about this especial
dictionary implementation okay
so the only option Robert really has at
this point saying okay I'm going to fork
the JSON library because they really
want to use it I'm going to go to that
code we just saw and add a new clause so
it works with my code okay and then
somewhere else we have the same thing
Joe's work on or Chu Lin said hey what
what jason Cody support and then he has
his new data types that the json library
does not know anything about so what i
was going to do he's going to fork it
and he's going to take to go on his fork
and change that code to work with those
different data types and what is the
problem here right the problem here that
is that it doesn't really compose if i'm
working on a project that needs that
uses laurel and wrote you i need to pick
a fork right and picking a fork means
that if I choose Roberts fork Joe's
library is not going to work as expected
as expected and if I choose the other
one the other one's going to be broken
right so I probably need to create a
third fork right that has the changes
from both of them so it doesn't work
basically it doesn't compose and the
issue is because we are adding all the
clauses right to the module right we are
trying to embed all this knowledge about
all those data types into a single place
and this is not correct because the data
type
No
so there's a very good point causes so
why would they porky they could just add
one special clause that handles it
before calling the other code the
problem with Jason that's why I like to
sterilization example is that you can
have their data types with a list inside
with their data types inside with some
other data type inside right you can get
the data structures that you want to
sterilize they can be nested in
arbitrary ways right so you cannot have
like I just want to call it before
what so are you suggesting that we need
to call them stupid core particular
module in their code beforehand yeah
okay so let's let's entertain this idea
okay so we're going to do
waita need to mirror this let's have a I
need to count this we have three minutes
I have three minutes to convince yo
costs okay
so otherwise that would be out of time
so they're ready say main code okay
and they are going to say yeah so their
way to say they have a special item and
let's say it's a record that it's it's
the ethics a special ticket and here
they're going to say okay this is how
I'm going to encode my ass kicked right
but let's imagine that this a stick I'm
going to use the map infrastructure
representation here it's a key value
okay just to represent but this value
here could be a list right so I'm going
to encode the key
yes okay perfect even if I do that my
value can have a list and who knows how
to convert the list is not my code is
the original code so unless I teach my
code now how to convert both lists and
the other one right I will end up I'll
need to implement half of the library
here because the data type that can
merge in a recurring ways right I can
even have my dictionary containing a
joke for example he can have his
dictionary containing one of Roberts
dictionary as a value so you cannot you
need to be able to go back and forth
right we can we can go back into this
like explicitly into this example but
the idea is that so it needs to be
recursive right I need to be able to
let's say like hey now I'm coding this
and then the value can have a list that
is written in this library and then
inside the list we can have the
dictionary that is in Roberts library so
there is no single point of entry I will
need for example the JSON library to
call other modules be able to dispatch
to different places but recursively and
that's what we are doing right that's
what we need to do and that's what we do
in Aleks here the datatype instead of
asking one single place right like hey
how do you know how to convert itself to
JSON or having a single entry point what
we need to do is that we need to define
define a place you say like hey if if
you can encode you have the daily
structures if you can eat called
yourself to JSON right you just need to
implement this protocol so this is some
Alex your code right the way we solve
this that we added this idea of
protocols and what a protocol does is
that it says you know I'm if you want if
you implement the JSON protocol all you
need to do is to implement this in code
function and what anchor and the encode
function you can call as any other
function in your code so this is how we
call any other function in the India
lecture code and now all we do is that
we implement this protocol for all the
data types that we know so we say hey
the implementation of JSON for list is
this right implementation of JSON for
bit string is this other thing
elimination of Jason for number is this
other thing so what Robert can do is
that in his library now all we need to
do is delete to change the original code
because the original code defines only
the contract and the dispatching logic
based on the type so all he needs to do
is that he would go to his gonna say hey
the implementation of Jason for this
particular type that I have defined in
my library is this and now the code can
recursively write dispatch to the purple
place and do the conversion and this is
this is just one example of protocols
right so what it means is that I can
write a JSON library that is accessible
to any data type because I'm defining a
contract we are applying the same ID we
have in our link for processes right we
can do i oh
within the process we can define you can
define any i/o device as long as you
respect some message contract you can
say hey you can give me any data type as
argument as long as this data type
defines this protocol so we have
answered this question right you can
give me any data type as argument as
long as this implement this protocol
that has this particular contract so
here are some other examples of
protocols
so in LXE we have the enumerable
protocol and what the numeral protocol
does is that it's able to it defines all
those collection functions like map
filter reduce and it can work with a
huge variety of data types as long as
this data type implement in your
protocol so here is how we can map a
list okay or we can use the same code to
map arrange and so on the nice thing
about the numeral protocol is that it's
based on something called hash quarry
charities and what it means is that it
works not only with remember collections
like lists SATs ranges but it can also
abstract how interact with resources so
here's how you can for example get the
first five lines of a file with Alex
here all you do is that you create a
fiery stream giving the path and we saw
the extreme we get the idea before the
day strings are lazy right so what we
are doing is that we're creating a file
stream and then we pass it to annul take
to take the first five entries and what
we call in don't take what that's going
to do is is that it's going to open a
file right iterate the file getting
first five lines and then close it at
the end and everything is encapsulated
here because the newer protocol knows
how to work with collections beat them
in memory or resources like IO or events
coming to your system and so on another
protocol that we have in Aleks here is
the inspect protocol so if you call dict
from list in air link right you're on
the on the shell we get this as a result
right we get all these representations
we are not really suppose about to know
about this right this presentation is
actually opaque but the the terminal is
going to show all of its contents unless
you teach it in particular how should we
handle the same render this thing as a
record and again is the same issue right
why does this happen it's because we
have one central place that is doing
that the term printing what we should do
is that we should ask the data type like
hey we we need to print you to a
developer right now what is the best way
to print you to a developer that's
working on the terminal right now and in
Aleks here is the inspect protocol so we
have a hash dict
with an equivalent to the earth to the
sorry to the air link dict and when you
create one in a literal term now you get
just the parts that matter and if you if
you need to pick inside you can give an
option say like hey show me everything
as they are internally but mostly you
want to have justice okay so that was
the first part about accessibility and
and it was basically about having
protocols right and being able to
express polymer fees at the data type
level right now I can say hey you can
give me anything any data type as long
as implements this particular protocol
and you are going to come back this a
little bit more later there is also a
point about the second goal of the
language productivity and not going to
go long into this because it can be a
long topic but we and we heard about it
in the keynote right one of the big
points about productivity it's kind of
hard to argue which language is more
productive than the others but one thing
that we cannot argue about that having a
very good tooling makes us productive
and in LXE we have this combination for
example of mix which is our
to build to the hacks package manager'
and having very easy to read and write
documentation so with those timelines
Africa is after install Alex here with
those five lines you create a new
project you compile and run its tests
you publish its package and you generate
the documentation for the package and
put it online for everyone to consume in
access ok now we can talk more about
this later I want to go to the more
interesting part of the talk which is
about compatibility which is the third
goal so to talk about compatibility it's
really interesting because at the
beginning when we added this go we were
exploring so the first Alex redesigned
the first version of the language when
they were not even lounged right it
really sucked because I was really
exploring and trying to push the buttons
of the runtime and of the virtual
machine and try to to see how far I
could go and I even I was able to break
some stuff like a hot code swapping was
not working properly because I was
trying to feel a lot with the byte code
that was generated so at some point I
realized like hey this is always not
going to work so that's when
compatibility came as a go that if I am
writing this language to run on the
Erlang virtual machine because of their
name virtual machine it doesn't make
sense to break the features that the
virtual machine offers right and that's
how compatibility came and it was a
really big thing for a good while so for
example if you came to Alex here and he
wanted to define a supervisor or you
wanted to define a junk server you would
say hey go go read the Erlang
documentation and use their link module
and create your own just servant grade
your own supervisor and it took a while
for us to to feel confident enough to
say okay we have this foundation but
there are places where we can do better
and we'll try to do better and this is
the point about compatibility which is
interesting because in the past it was
like we have this compatibility and we
respect it but now we are we have this
compatibility and we respect it but we
also want to embrace it and extend it
and that's why are things like so for
example
calling Alex here from our laying in
this versa there's no performance there
is no performance cost there is no
bridging cost whatsoever so and and what
this means right now for Alex you will
know is that we are starting to say hey
how can we see things that we have in
OTP like the behaviors a little bit
differently and how we can think about
those things so I want to talk about two
things for this part of the talk the
first one is a Jung server which is my
opinion is a very successful example of
when we got something that was in OT p
and extending it a little bit and the
other one is something that we are
planning which is called Jenner altar so
the gel server if I'm going to talk
about your server it's really it it's a
very honest name right because it's
really a generic server so we have a
just server it's it can be up it can be
about computation just perform a
computation periodically it could be
about keeping some state and many times
it's a mixture of both right to have
some state and have some computation
some work you are doing that state so
it's really generic the problem with
that is that there are some times where
we create a gen server only to keep
state for example and it's hard because
I'm going to to look at some code and
then I have all those callbacks and I
need to take some some time to look at
the code look at the call back and say
oh wait I know this this is just keeping
state it's not doing anything special
and the same happens with computation
right sometimes just want to do
something and then you need to have the
overhead of defining init sending
yourself a message so you can start
processing something on the handle info
for example so what we did in elective
is that we introduced two new things
which are called tasks so if if all you
want to do is to create another
processed with Acutes of computation you
can use a task for that and if all you
want to do is to create a process agent
server that's going to keep state you
can use an agent and and the way it
works so let me talk a little bit about
those two abstractions so tasks for
those familiar with Erlang internals
it's very familiar with properly upon
you just spawn a process and we're going
to take care to do everything that all
TP requires like setting the proper the
proper diction our variables and so on
okay and that's how it started was just
startling can you would run some code
okay and when if it crashed it would log
something is useful and so on but with
time we started to notice more
interesting patterns that fits this so
for example async/await so a lot of
times what we are doing is that we are
in spawning on process to perform some
computation right and then that performs
the computation you want it to send a
message back to you and you're going to
read it back it's a very easy way to do
concurrency so this pattern is very
common right to spell something have it
send a message back and then you receive
it so we said okay we already have tasks
which are about computation so what if
we stew a little bit from c-sharp and
just add two functions called tasks we
think that is going to spawn this task
to perform some computation and then I
can do whatever I want and when I'm
ready to read the result I just going to
call task await okay so that's also
there something that is also became easy
with tasks is because because there are
only about computation we can assume
some particular some of the supervision
strategies don't really make sense for
them so what we do is that we ship with
a task supervisor that make it really
easy for you to do distributed tasks so
I need to set up a distributed task with
Alex is that you start a supervisor
probably in the supervision three of our
application right to give you the name
and then if I want to do some async
computation on another node I just call
the desk supervisor async passing the no
love the supervisor right that is when
supervise a task and the function and
the function I want to use to compute
that so this is an example where we were
able to say like hey what if we
specialize this just a little bit and it
grew with time and we added some
conveniences that are really useful for
everyday development okay and similarly
we did the same with agents so if tasks
is about computation thank you
the task is about computation agents is
about stage so if I have if I need a
process that it's all responsibilities
to keep
State I can just create an agent and
that's really all we need to do right we
need to create an agent passing a
function that's going to give the
initial State
and then we are going to every time we
want to update the agent we just call
agent with an increment function and
then if we need to read the state or
part of the state I just call agent not
get and I'm going to read it so this was
really nice because after he added those
abstractions even going for a Lakota
base there were different places where
it was only about computation and are
only about state and we could clean up
the code quite considerably so there's a
nice improvement but I think the main
benefit that we get about adding the
specialized stuff is for example when it
comes to agent we can start we are kind
of teaching developers like hey you have
this abstraction that is just about the
state and just about keeping state so
what if we take the next step for for
example there is a bunch of interesting
research happening with alvars
which is lattice based the researches
for the terminus pearl is which is see
what if we could have a set of agents
okay and operations that are guaranteed
to be deterministic for parallelism
because sometimes we have different
processes is accusing something towards
a common state and in Aleks you're
likely going to put that state in an
agent and what if we have a subset of
agents that say all the operations you
can do if the agent they are going to
guarantee that the result of all those
computations is going to be
deterministic okay so this is one way so
this is not Alex here I think I said so
far wasn't Alex clear this is not but
it's one of the ways we are researching
how we can use these state-based
properties to assert use these
state-based agents to assert more
interesting properties
another example of that that's familiar
to a bunch of ireland developers is okay
so what if we have a set get some of the
shared active research and have a set of
agents that are guaranteed to be
replicable across nodes because there
are only about state anyway right so if
you're guaranteeing some property about
this state we can have that right so
this is one of the things we're
exploring and
and besides that we are also exploring
other things related to parallelism
right so if we are thinking eh I have an
agent state here that I want to have
deterministic parallelism it means I
would have a bunch of processes
computing usually toward some common
goal okay so what if we could explore
this even further and that's the last
part of the talks when we talk about
parallelism so before we get to
parallelism I want to talk there are
three bullets here I want to first talk
about laziness and then I'm going to
pipeline parallelism and then I'm going
to briefly mention they data parallelism
because I'm almost running out of time
so at the beginning of the talk I said
hey Java 8 has his idea of collections
and later I said that in a lecture we
have this thing called protocols that
adds the idea of collections within a
module so here I have that that Java
code kind of translated right so I have
my widgets I can filter them I can map
then in this case I'm taking five and
this is bigger right so it has the same
issue if that Java code where if I have
a large widgets list for example when I
filter it I'm going to traverse it one
time then when I map I'm going to
traverse it again and then I take five
so in Aleksey we have this idea of
collections but we also have the ideas
of laziness and all we need to do to
have laziness is to replace the inner
module here by stream okay so only
things that we replace the module that
we are calling and the stream has almost
all the functions in the numb but
implemented in a lazy way so I can say
widgets and then I want to call with
stream filter this is not going to
traverse the widgets right it's just
going to restore the computation when
you call map the same thing is not going
to traverse them just going to restore
this computation and then at the end
when you actually need a result or you
need to sum you're calling them for
example to get a list right and it
starts to give a bunch of interesting
properties because now since this is
lazy we can even work with events coming
from other places or even if you need
collections right because we are never
girly evaluating the whole thing we are
evaluating items as they come and along
the same line what we can do is that if
we are already at each step here at the
filter map and take if we are already
exploring the
computation right maybe we could get
this computation and is acute in
different processes right as a way to
start exploring parallelism because you
know we already storing them anyway
we're already collecting so what is
going to change if I decide to execute
that somewhere else so for example what
we could do in this code is that I could
add a little bit of pipeline parallelism
by doing just one line change right so
this is the code we had before okay but
now I can have a little bit of pipeline
parallelism plea adding this function
call here and what this is doing when
you say stream that they think what is
it going to do say you know all the
computations I have so far what I wanted
to do is that I wanted to compute this
in another process and it's going to
send the results to the current process
I want and if I call this multiple time
right if I have a huge data pipeline of
computations that I am processing
map-reading filtering taking whatever
flatmap and so on if I call the stream
async multiple times that I could is
that going to create a bunch of
intermediary processes where the data
flows through them so if I have this
where I call it three times they're
going to have something like this right
I have the input and as soon as I have
the first data coming right bit from a
least bit from a file or whatever as
soon as I have the first data right it's
going to go to the first process and
then the first process is going to
perform the computations that make sense
to it and then it's going to forward to
the next process and then the next
process is going to receive this first
event started computing things in it and
the process before is going to get the
new event and they are all computing on
this data at the same time right and we
are looking at the singer saying okay so
we are thinking now about having all
those processes that are receiving data
and computing stuff on the data okay
is there a good pattern to do this in in
OTP and if you if you saw this talk at
San Francisco there the answer was jenna
vent but we are working further on that
and we say like wait wait Jen event is
not going to work as we expect so right
now we are considering a new behave
which is called general tur which is
similar to Jenna vant the difference is
that the Jenna vent you have the event
manager and the handler and they are all
in the same process and with the general
tur we want to have all the handlers in
different processes and this is also
going to give us their base to choose to
whom we should route some particular
event okay so what do we mean with the
general term we want to have a new
behavior that specifies the message
format for connecting different
processes so as long as I sending those
events or being a particular format all
those processes they are going to be
able to communicate with each other and
it's going to effectively replace Jen
event because it's similar to Jenna vent
but it has one process per handler which
actually increases parallelism - and
concurrency inside the generate handlers
themselves while allowing Kusum dispatch
rules okay so I'm going to skip this
part
but the idea if the router router is
that we could do something like a
broadcast which is what a gentleman does
so every event that comes so we have
three events here one two and three we
could broadcast them to all processes
but if you want you can write a callback
for this behavior that customized hey I
want to send the events in the round
robin fashion right or I could have a
custom sharding rule that's going to
send to particular nodes based on the
event itself or even random right
whatever when the data comes I'm going
to send to whatever chosen at random and
with this right we are we started
thinking like hey I know I have those
processes right and I have all those
computations and I know how those
process communicated to each other and
this is bringing us what I said a
pipeline parallelism I have those is
those stages right that performs
something and the data is going through
but sometimes moving date is expensive
even more in Erlang right like every
time we send data between processes it's
going to be called copy it unless it's a
large binary so since we have already
all that specified we can consider
taking even further which is and then
also functions that are related to data
parallelism and we have a bunch of
interesting talks regarding that on this
event itself right algorithm skeletons
and how we can have those computations
try to spread it to different places
sometimes CPU or something GPU based and
so on so that's the area that we are
working on activity right now and trying
to find the proper abstractions so we
could build more on top of parallelism
make parallelism easier right because
the point is we have these great
vertical machine we have this great
runtime right
with all those abstractions that we're
talking about the data types the modules
the processes but when it comes if I
have some chunk of data and then I want
to process this data right using
different processes it's actually today
it's easier to do in if all I want to
process that quickly it's easy to do in
Java 8 then to do in Erlang or elixir
okay because they already have the
abstractions right they have the
laziness and then at the end of their
relation stack they can say like run
parallel right and you can choose
different strategies to run that in
parallel all right they don't have a lot
of the current ease we have here
regarding building a robust system right
they don't have all the framework about
thinking what is going to happen if
something goes wrong but if I am a
developer and I have a problem and I
want to get started quickly and solve
the particular problem they are going to
beat us right because it's much easier
to write there everything's already they
have a bunch of tutorials everything's
already in place they're going to try to
call you and say hey this is using my
all my cars
I am happy so so I think we have a great
VM and a great one time and we can
provide better tools than we see
elsewhere right because of it
but we need to work for it and the and
the benefit of it all is that right now
I'm talking about concurrency but
because different Airlink nodes we have
this rebuild Erlang and having different
nodes talking to each other is fairly
easy it should not be hard to get this
set up to something distributed right
which could be a wean on the long term
when we compared to the other frameworks
out there so I want to finish the talk
by saying that there are many
interesting challenges here and if you
have feedback I would love to hear them
so I was talking about protocols at the
beginning right but what is the most
efficient way
really of doing polymorphic dispatch
okay or a bunch of languages they use
inline caches to optimize polymorphic
dispatch and how can we have this here
in their link or if our going to do
pipeline parallelism how can we provide
backpressure efficiently because if you
have a pipeline parallelism one of the
issues we have is that's that one stage
that is re going to be the slower the
slowest of all of them right so how that
stage can give back pressure to
everything before and say hey it slowed
down right you're giving me items too
fast but while keeping everything
efficiently or if you are and there's a
bunch of research on this last topic in
particular right if you're going to
choose data parallelism what what are
the the algorithms that are really
important for us and that we can
leverage efficiently with Aleks your
inner link so if you like the talk and
if you are interested in Alex here go
check our website we have a getting
started guide we have installation
instructions there we have a page with a
bunch of learning resources
I think these slides outdated all those
books they already came out they already
published it I need to update it and I
want to finally just thank my company
platform attack for investing on me and
investing on Alex here and you know
guarantee that I can do all this work
and research in some way and that's it
so thank you very much this was the talk
about elixir
thank you and we have three minutes for
question okay okay yeah
how does it know how to dispatch to it
okay okay so that's a very good question
the question is you can see this yes so
we had that elixir code right that
defines the JSON protocol and as you
said we are obviously going to have
something like encode and an item and
when we are going to inside they're
going to have code like this okay how we
are going to encode them this item as a
list so when we define a protocol
internally we are defining this clause
we are defining this clause and we are
defining some all the other all the
clauses for the Erlang data types okay
and then there's the question if joel's
define his own type rights not we're not
even going to have a word for it okay
how we know how to dispatch to it and
that's where the Kusum data type it
comes in okay so this solution is
heavily based on how they solve this is
exactly same problem in closure and in
Aleks see we have maps right so as we
have in our link and if the map has a
special field called underscore struct
it's giving it a tag and I can dispatch
it based on the tag so if you have a
custom type in Alex here so here is an
electric mat for example foo bar okay if
I have a custom they researching a
lecture it's going to have a field here
that says hey this is a struct of type
jose datatype and based on the tagging
of the map i'm going to i know how to
dispatch to the proper implementation so
we have qu some data types and those
Huson data types are tagged and based on
this tag I have
I know exactly to which implementation
should spatch to because they have this
name very good question take you also
we're enough time sorry you want to ask
questions just come
yes so the question is about full day's
programming and I've started so to be
honest I started to read one book the
book was not good and I gave up in the
middle and I haven't come back to it so
the answer is no you're not the first
one to say like hey look at flow base
flow based programming and I'll try to
put more attention to it and see if they
are which are the ideas that could be
relevant here thank you yeah yeah thank
you thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>