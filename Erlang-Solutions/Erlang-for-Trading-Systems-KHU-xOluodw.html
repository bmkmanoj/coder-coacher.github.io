<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang for Trading Systems | Coder Coacher - Coaching Coders</title><meta content="Erlang for Trading Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang for Trading Systems</b></h2><h5 class="post__date">2016-05-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KHU-xOluodw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to the erlang
solutions monthly webinar
my name is blood and milkshake I'm the
VP for the AMIA region here at erlang
solutions today's webinar represents a
continuation of a series of webinars we
are organizing across topics of interest
in the world of our lang and dealing
with solutions based on the Erlang
programming language today we will be
hearing about sports risk broker and
distributor of risk management solutions
and products focusing on the sports
industry we will be specifically hearing
about sports risks decision to migrate
components of their python-based core
platform into our life and the
motivation behind those decisions and
the outcomes this produced now will be
running this event live so please be
patient with us if there are any
technical issues but to start by telling
you a bit about allowing solutions we
are a products and services orientated
company completely devoted to the
airline programming language and
increasingly elixir we work with
organizations and individuals using the
Erlang and elixir helping them evolve
the language and supporting people and
businesses using it we are headquartered
in London we have offices in Stockholm
Krakow Budapest San Francisco and we're
nurseries we run projects that span
industries and the globe itself and we
develop a line based products as well
some of those include our Mongoose I am
messaging platform which is open source
the react distributed database one bardo
am our monitoring and management
technology for Erlang and elixir systems
and a number of other products I'm
really pleased to say that our speaker
today is Sports risks CTO
Justin Worrell now please allow me to
finish by saying you are very welcome to
post questions throughout the duration
of the webinar by using the chat
facility on the webinars interface our
speaker Justin will answer as many
questions as time allows at the end of
the webinar but should any questions go
unanswered you are most welcome to
by email using the following address
webinar at Erlang
- solutions comm if you are interested
in learning a bit more about our
language in general or wish to
understand whether whether it will help
you and your own business and by all
means feel free to contact me directly
my email address will be displayed in
final slides we will share with you
today I would now like to hand over to
Justin who will be glad to start us off
okay
all right well good afternoon everybody
I hope you can all hear me
successfully I've had a few problems
with my Windows setup here so if there
are any issues I'm hoping the erlang
solutions people will be able to jump in
and correct them but I'm very hopeful it
will all go successfully other languages
have told me that I can't actually see
how many attendees okay oh that's great
it's good to have a few people
interested in Erlang and sports which i
think is a an interesting topic I hope
you know over the next the course of the
next 40 45 minutes second maybe it's
going to say educate but that sounds a
bit prescriptive maybe I can you know
tell you a little bit about our story
you know our journey from sort of
pythons like maybe educate you a little
bit maybe make you laugh a little bit in
it places so that that's basically what
I'm going to try and do here today a
little bit about me first
I am so midway through my career I
started work in the 1990s working for
Morgan Stanley the US investment bank
which are joining straight out of
college and I did a lot of work for 15
years their pricing and trading and
structuring derivatives fixed income
derivatives that if bombs or swaps and
stuff like that and when I joined Morgan
Stanley I knew nothing about computers I
was not a child prodigy even though we
had one at home a kid I was not a child
prodigy but when I started
in my first week the guy was working
basically put a fat manual on my desk
and in those days this is all pre wind I
was pre Excel it's that long ago we
basically had UNIX Sun stations with
copies of C and APL on the money that
was fat APL men my death said get
learning if you don't want to be fired
and because I was in my early twenties
that was what I did I started learning
stuff and I don't know if any of you are
familiar with a it's the uninitiated
it's extremely terse it makes pearl look
boats but you can do an awful lot with
it Morgan Stanley in their wisdom had
actually built their own dialect of APL
called a plus which they said they
subsequently regretted because they
found no one wanted to come and learn it
but I cut my teeth on APL an A+ for 17s
before deciding that that was a bit of a
dead end career-wise and branching out
looking at other languages looking at
Java and deciding also to me looking at
Python this I didn't like that that
actually looks pretty good
working with Python for a number of
years and ultimately really sort of
bumping up against the limits of what
Python can do as an enterprise system
particularly with respect to things like
its global interpreter lock and it's
like threading discovering other
language weird language finding overtime
that actually yeah solved - was leading
us into and really just what a great
application environment Erlang is you
know that's been a journey of it's been
a journey of sort of 20 25 years but I
mean this fortress part is much shorter
but we'll get it we'll get on to that
anyway so I'm gonna click the slide
write some apologies let's get this out
of the way you may have gathered I have
no formal training in any of this stuff
so if you're looking for a hardcore
computer science presentation this is
probably not for you because I majored
in philosophy and I know enough to be
dangerous but not always to be useful
the second apology is that this was
advertised as a low latency event so I
should probably explain a little bit
about what that means I mean it's not
low latency in
Jim Simon's Renaissance Technologies
high frequency trading Calais takes we
are not doing C C++ optimizing every
byte we are not building you know our
own hardware to do this stuff quickly
the talking sort of latency that we have
in our industry is about half a second
to a second and most of the API is that
we're dealing with our web base so that
you know there's a certain latency in
that you know and if we're able to do a
lot of web requests in parallel 50 to
100 web requests in parallel to API is
its frequency they're about half to one
second that works pretty well for us so
it's not traditional C C++ high
frequency stuff but it's certainly stuff
that Python finds hard and but on the
other hand
erling trying Erlang finds fairly easy
so that's kind of the that's kind of the
place where we are so position insurance
okay well this is a little bit about
what sports risk does
okay so sports risk is in these sports
insurance business but what does that
mean technically what the example I
always use is this one I mean imagine a
team which will remain nameless who are
expected to finish tenth of me pregnant
ship now if they do well and finish six
couple of things happen they will
qualify for Europe which means more TB
money that's good if they do so it will
likely trigger more goal related bonuses
that they have to pay their players and
that tends to be bad now if football was
a well-run business you know those
things would generally offset but we all
know that football is obviously not
always a well-run business and so you
often well I won't say often but
occasionally you get situations where
teams actually finds that they're the
better they do you know the worse off
they are because they haven't managed it
properly well they may have sort of
explicit goals they may literally have a
schedule of gold bonuses that they need
to hedge you know for their players and
so the question comes in you know often
we get situations where it's like okay
we're expected to finish 10th but if we
need if we finish 6 we're going to need
now if if you're familiar at all with
finance or insurance you'll see that
that
like an insurance product or an option
product it's like it's like a contingent
thing you know if the team finished less
than six then there's no payout but if
they finish more than if they finish
higher than sixth but it's a lower than
six then potentially there is there is
an obligation there and as soon as you
start to realize it's an option it takes
you into probability territory into
pricing territory and you know a lot of
issues which are similar to financing
potential it can be quite fun and
interesting to figure out so that's kind
of an overview of what sports says or at
least one aspect of sports recession I
shouldn't say that's the only thing we
do but that is that is an interesting
product where we've done well so
finishing positions this is a graphic
this you know we spend a lot of time
focused on graphics like this now it's a
bit small this side I hope you can see
that I'm not going to increase the size
of font because every time I do windows
seems to crash so I'm just hoping that
everyone can see the X's here we spend a
lot of time focused on graphs like this
you know which show where different
teams are going to finish at the end of
the season now this was taken a few
months ago so it doesn't reflect
Lester's rapid rise but even so you can
still assuming this was taken in March
we still see some interesting stuff like
you know man you even in March we've
pretty much nailed on to finish fixed
which is as our Aston Villa you know
finish finishing bottom that was pretty
clear early on also if you sort of
squint your eyes up a bit a little bit
you can see that the the division sort
of forms into various blocks you know
sort of a square block for the top five
there's then another sort of square
block for numbers five to ten and then
down at the bottom from eleven to twenty
there's sort of a bigger more indistinct
block you know and the intensity of
appetit to the chart shows you you know
how how nailed on certain teams are for
certain positions you know and who their
nearest competitors are and and that's
interesting for us because you know
we're pricing a lot of contracts whose
payout is based on these finishing
positions if you think of a lot of
contracts that are out there you know
who's going to win who's going to finish
in the top four who's going to finish in
the top six who gets relegated who
finishes in the top half bottom half all
this kind of stuff
it's all
all related to finishing position so a
lot of what we do is focused on
finishing positions how do we do that
okay so sportswear it's workflow
well we take a lot of publicly available
data and then you know we do stuff very
similar to what a lot of big data
companies would do it we have to clean
it all that's the data cleaning part
core to our business it's given all the
public data we try and assess exactly
how good each team is and by that I
don't necessarily mean you know where
each team is in the currently grading
because often the league table you may
have people say the league table can lie
well in our opinion the league table
certainly can lie on certain occasions
you can see that quite easily just from
Lester's position I mean Lester of won
this year but does that make them the
best team in the league well if you look
at the prices for next year probably not
I think Lester or something like thirty
to one to repeat their feet of 2015-16
where's the favorites Estill Manchester
United and Manchester City with their
new managers respectively so a lot of
our focus is on trying to gather from
publicly available information
stabilized ratings for exactly how good
and once we've got those ratings we can
do a like quite a lot with them we can
basically simulate the rest of the
season and once we've simulated the rest
of the season we can get position
probabilities for all these teams we can
calculate contract values such as you
know who's going to win it's going to
finish the top form of all that stuff
and we can also assess risks so we can
do a lot of what-if simulation what if
Lester win the next match what does that
mean to these numbers you know and those
risk numbers and marks are very useful
for trading for risk management and for
a variety of sports risk products so
that's kind of our workflow and it's
split you know split with between the
public stuff on the on the left-hand
side and proprietary on the right right
next top four okay so the here is a
quick chart of what happened in the top
for this year lots of volatility
again taken say
can i think sometimes in sometimes in
March now what can I pick out from here
that looks interesting well you could
see man united in the dark blue they've
had a precipitous decline they haven't
been very well tall they sort of
declined sometime I guess it would be
clearer if the axis on the bottom was in
actual dates but instead I've done it in
days since the start of the season but
you can see man you have to suffered a
fairly Christopher distich London and
mr. van Hoff about mid November December
and Chelsea did even worse you know they
were they were out of it I looks like
September October and then you've got
the newcomers you've got Tottenham in
purple who have risen all the way
throughout the season and then of course
you've got Lester who rose a slower pace
in the green but obviously we're right
in there at the end so it's been a very
interesting season teams wise you know
you will all know this is nothing new
that the incumbents have done very badly
with the guys you know the the only
cotton is it were very badly but the
newcomers have done very well and it
makes next season that's not to look
very interesting in terms of what's
going to happen so this is now this is a
standard output that we would track a
bit less volatility here but actually
potentially more of interest this these
are our internal ratings graphed over
time you measure them on a range from
for each team between Norton's three
three means you win every game zero
means you lose every game and the big
trend here is is how you know how much
the dispersion of the different rating
this is narrowed over time so you've got
all the guys at the top man cities big
Man United's the Arsenal's you know all
declining Man City from two point one
down to one point nine trying to pick
out the green but I can't ask them a
pretty much stable and then on the
bottom half you've got all the Rises you
know you've got Tottenham all the way to
about one point eight and then you've
got yet Leicester sort of rising from
the deep like two wards in purple you
know all the way from 1.2 to 1.4 1.5 so
there's a couple of interesting things
you can say that when first is that
you know even though that's the one
they're not rated as the top team list
or maybe seven or eight best initially
but also how next season's going to be a
lot more interesting because all these
teams in terms of rape team are much
more tightly packed they were before and
you know potentially there's teams there
which I haven't even included which
would be in the mix I mean if I include
West Hanley Crystal Palace as well they
would also be so again very exciting
next season markets okay just a quick
markets cloud not very interesting this
is just a range range of different stuff
that we can price now does it all work
well we like to think it works I mean
let's talk Leicester again I mean at the
start of the season the start of the
season you know we would all well you
might have read in the press that's been
an awful whoa
talk about risk management how much
money the bookmakers have lost unless to
buy off four eighty five thousand to one
odds you know to people and maybe take
to the cleaners and that's all true well
our model would have done even worse you
know we would have said it mess that we
had a million-in-one chance of the
season doing anything to but we wouldn't
have we wouldn't have made any money so
that's okay what's more interesting is
that we is that our models have turned
around that quickly by by beginning of
December late November it was already
flagging Leicester as probably likely to
do something and if you look at the
price there you know in at the beginning
of November you were still able to buy
Leicester in the betting markets at a
price three point two five and
probability terms that's about thirty
percent not just a win but to finish in
the top six which if you think about it
based on their performance so Sarah's
quite impractical quite incredible you
know that you know they had a 30% they
were priced as having a 30% chance to
finish in the top six not to win midway
through the season and this was after
Jamie bodies record-breaking run so you
know what does this say well in it on
the one hand yes we can profit
personally for that but also you know
this is very interesting information for
our clients you know we would
potentially be you know flagging this
kind of stuff to them we can flag it up
as you know here here's a great example
of why the markets are inefficient and
potentially something we can do about it
so yeah we do think the whole thing
works
right I'm gorgeous I have talked about
any other line yet but don't worry it is
coming we've got some interesting
problems of sports risk so team matching
how many different ways can you name
Manchester United how many different
ways can you say Borussia
mÃ¶nchengladbach you know what if you
get accents in this mix well the problem
is all the data that we get in from the
web it all needs cleaning there's no
central naming repository but all these
team things so you know we have to run
them through various different match
it's exactly matches partial matches
abbreviation matches levenshtein match
as 11 to do matches a very interesting
they're sort of fuzzy string match
interested now the rhythms but you
should look up the levenshtein
levenshtein fuzzy string that it's very
interesting and then you've always got
the irregulars as well you know Spurs
the Tottenham Saints the Southampton no
algorithm is going to be able to deal
with those so you know we have a we have
a whole module dedicated to team
matching for example well traditionally
written in Python but now written in
early and I'm indebted to my friend
Robbie Rasha Rasha of Erlang solutions
who worked with on some of this stuff
and he actually wrote an open-source a
small amount of open source code or
fuzzy match which you might want to look
at if you're interested in that sort of
thing and a free idea yeah q-tips for
sports things well in the finance world
you have these things for q-tips which
are like global identifier for every
security that you trade you have nothing
like that in the sports world so maybe
there's a business for actually q-tips
was Portland it's where you know none of
those team matching stuff would be be
necessary you know it would certainly
make an interesting software as a
service project just a thought
parallel events okay this is where we
start to get a bit more Erlang e so this
is this is kind of this speaks to the
sort of parallel nature of the problem
on any Saturday afternoon we have
matches going off at various different
points you know what I put them every to
our brackets when it should probably
which should have been everyone out but
you know it at 2:30 in the afternoon you
have all the Bundesliga going off its
repair me after Premier League the late
Premier League game there's some Spanish
games have a whole lot of French Ligue 1
games at 7 p.m. and that's
9p well so potentially you've got to
trade all these in parallel something
that is hard to Python you know even if
you're doing event-driven Python or you
know you're hacking - sometimes make it
look like no Jess you know it's it's not
ideal at least in my estimation you know
but you can see that you know having
trading processes that run in parallel
to handle all these matches you know
makes it a very very sort of natural
actually even if you don't know anything
about fan you know it's good for power
work you can see from a chart like this
that you know this might be a problem
contracts okay so this is this is just
the last in a series of slider that's an
interesting problems that we face you
know in addition to long term markets we
also are active in the short term
markets which are bets or hedges on
what's going to happen on an individual
match and often we want to try and find
out what is the best value you know in a
in a particular match you know if we
have a hedging position which will be
actually executing that naturalization
handicap can we do something with
correct score now the thing is here is
that all these well I'm going to go back
a bit and sort of explain what all these
contracts mean Matt Ross is probably
something you're very familiar with it's
just who's gonna win who's gonna lose
and who's gonna draw so if you look at
the match odds thing the the home team
down the vertical access axis and these
are the numbers they're relate to the
number of goals at home awaiting score
so down the the vertical axis you've got
goals scored by the home team down the
horizontal axis you've got goals scored
by an away team so anything in blue on
the match odd signs mean the how you
teams won anything red is the away team
down the middle in white that's where
the draw lies now all the axes for these
different charts the same the asian
handicaps a bit like a match odds except
there is a handicap applied to one side
or the other so instead of saying you
know it's a little our Liverpool gonna
be Everton you might say Liverpool with
a handicap to go
something like that and that starts to
look very like match odds it's just that
the the split between the blue and the
red zones get shifted along one of the
axes along the along the top left to
bottom right axis total goals is very
similar it's just a question of whether
you're in combination the two teams
score more than a fixed strike or score
less a correct score simply whether you
guess the correct score correctly but
the interesting thing about this I don't
want to belabor it too much because we
need to go on to tech is that all these
contracts basically are functions of
goals so you know match towards contract
of the function of those agent and two
cups of functional goals total goals
function does
so those interesting problems faking are
figuring out things like okay
you know if you have different prices
for different different contracts such
as these on the same match which is the
most efficient which is the cheapest
which one would you want to hedge it
against something we started out with a
Python library but now have an early so
okay bit of code but not other like just
yet so traditionally we've done all this
stuff with App Engine Google's App
Engine program and we're big fans of
Google's App Engine I don't think it
always gets a great press to be honest
you hear a lot of people on the web
complaining oh it's expensive or it
involves lock-in to Google libraries
blah blah blah don't like this don't
like that the fact is happened is
absolutely great you know when you get
to you get to work in Python and
increasingly it feels you know in this
space that everyone's working in Python
and you should read the link there you
know about why that's happening and it's
cool I call it the Everglades effect
because of the than if you read about
release of pythons into the Florida
Everglades and they belittle the
wildlife and some nothing but pythons no
no well it feels like that to me that's
so you get to work in Python so that's
great and you know it's to do engine
applications auto scaling is great it's
done it all for you
deployment
or for you they have lots of great sort
of non standard libraries that deal with
memcache email fetching URLs that don't
come with a normal Python setting and
they have tasks which absolutely great
which you can just fire off processes to
run in the background you know that
could fetch fetch URLs clean data or run
models do whatever and the overall
effect ru Earling in disguise I mean
sometimes it feels that way sometimes it
feels like Google have taken they can do
and try to put a you know a Python type
front-end on the whole thing or make it
work in Python that's not exactly the
same obviously because I know all the
Erlang purists are now going to say well
thing has you know these lightweight
threads and that's all true but at the
macro level you know if you'll is
building an application and trying to
run a business you know App Engine
actually does a pretty good you know
impersonation of probably the basic bits
of so if you know if you're working with
Python and you're just working on the
desktop you know you're not ready to
take another Lang step yet you should
probably check out App Engine of what
you do because you can get a long way
down the road building a scalable
application with it you know even if
it's not quite but App Engine the bad
right Lockean we mentioned locations
well it can be difficult because you
know you have to move will only have a
certain range of locations regions where
you can have servers maybe not a big one
um cost cost is a problem because it's
expensive
I mean effectively you're outsourcing
the system administrator stration
function to Google which can be a pain
you know it does get expensive and you
know we said it's been quite a lot of
time actually optimizing the cost with
respect to App Engine so it's not
perfect bigger problems task
optimization and this starts to get to
be a really big problem with that
patient because the thing about App
Engine or the thing about Google is they
want everything they want you to do
everything entirely sort of chunks you
know you can't if you're used to sort of
taking two giant databases performing an
SQL join on them you know and it taking
two minutes you can
get about with App Engine because they
want you to do everything inside uh sort
of ten-second window which means you can
only only launch you can only fetch and
limited amount of data and you have to
spawn lots of tasks and end up with sort
of MapReduce like processes to make it
all work it's not impossible to do but
sometimes you just like golly this
really should be a lot sleep like you
know there's got to be an easy way
that's for smashing these data related
tasks apart and then gluing all the data
back together which is generally the
only way to do it so that is pain and
the thing that really got us to what we
do is a task scheduler which is that if
you want to try and do stuff at fairly
low latency to inside you know around
the one-second lucky it's just not
possible because you're very much of the
mercy of Google's task scheduler and you
know Google doesn't think you should
necessarily want to run tasks on a
precise one second interval so they're
you know if they will they will accept
your tasks but if you know if they
decide to run it ten seconds late well
they don't really care you know it's
just if the tasks use delayed it's fine
Google so it's fine well it may not be
fine to you especially if you're running
a sort of business that needs to run on
a one-second frequency so ultimately I
would say the task scheduler with App
Engine it's probably the thing that
broke the straw that broke the camel's
back for us and forced run off forces
but gradually led us to the awareness
that we should be looking at this way
and here's the standard three-tier web
stack which you're probably familiar
with not particularly interesting I'm
going to open this in a second but
you're familiar with sort of browser at
the top of the web layer in the middle
and then the DB at the end and I think
what a lot of what happens is a lot of
people start out with a structure like
this and then they want to do something
like this okay so they say okay right
you know I've got this basic three-tier
web structure now I need some feeds to
go now I need some tasks work to do
stuff in it but the problem with the
three-tier structure is the only place
really to connect your feeds and tasks
and workers up it's via the database and
you end up with this horrible anti
pattern which i think is called database
as a router where really what you want
to do
you want to stream data from your feeds
you know via the web lair directory of
clients or you want to do the same with
your workers but the only thing the only
way to do it is via the database so you
end up with tasks pushing stuff into the
database and the you end up with other
tasks which then pull stuff out of the
database and push it to the you know
push it to the web player and the whole
thing is basically just a mess so my
advice to you is if you if you basically
find yourself in that position just
saying no don't do that
because that is a bad thing and will
lead you to lots of pain you know I have
seen it in the past and it is generally
not turned out well for myself or for a
number of other people that convention
so if you find yourself doing that just
don't do it really you should be looking
at something completely different which
looks more like this okay and this is
this is I guess what you would called a
message based architecture and again
this is this may be old hat to a lot of
the people out there but certainly when
I this was new stuff to me about two
years ago and initially you think why
would I do that but actually when you
come to think about it it makes a lot of
sense because the the biggest problem or
the problem with the database is a
router structure is the fact that the
linkages between all the different
components are hard-coded right they are
completely centralized so you have a
hard-coded link between the database and
the web layer and the big problem with
that is that's basically what then
forces you to connect your feeds now
what the message bakes the architecture
does is it decouples all that okay so
you have a big message router sitting at
the middle and you have all the other
bits of your application sitting around
the outside and that's really nice
because then your workers can connect up
so the message rata your feeds can your
database can a new web server can as
well and it makes it much easier to
route stuff between different components
in your architecture so you know if you
want your feeds to go into your database
that's absolutely fine you can if you
want your feeds to go into a database
that
absolutely fine if however you want to
stream your feeds to some clients that's
also very easy they just go by the
message router so adding a message
router into the middle basically gives
you an awful lot of flexibility with
respect to your application architecture
and so we're moving from sort of one
year the sort of general sort of 60,000
view is you know a movement from a
standard three-tier web architecture
which I think lots of people know and
are familiar with to a message based
architecture which I think less people
are that's the general story now of
course wireline okay well actually let's
go back a bit let's go back a sec right
I'll talk about the message router of it
but why use Erlang for this because the
truth is if you've got a database that
feeds your web server and workers
effectively it's satellites orbiting
your message router son well you don't
have to write them all in earthing you
could write them in whatever you want
get stuff in Python you know why don't
they well
this slide from the elixir book did it
for me
it's basically because you it's just one
technology to do everything you know
instead of given that we're a fairies
you
is to a couple of pieces you've got your
message router which we'll talk about in
a minute
and then you've got your actual app
itself which has a series of processes
within it which handle all the different
components so your database you're
processing it feeds you name it you know
Erlang can basically do it so it's it
was definitely the sort of one-stop shop
aspect of Erlang the fact that you know
within a particular application you can
have all these different types of
processes written it over all you know
under the same language which was very
very appeal and at the same time it has
less of a sort of Heath Robinson feel to
I say Dan if you familiar with the term
Heath Robinson it's to some English
phrase and it means - it means sort of
jerry-built like you hacked it all
together you know you can have all these
different Ruby on Rails go register
stuff together you know but does it
really feel good at the end you know
does it really feel maintainable and
sustainable I would argue possibly if
you're good but maybe I'm not good
enough or maybe I just don't feel that
way so for me you know doing in doing
all those components in there like start
very natural you know in a very good way
to go about problem so messaging
rabbitmq this is rabbitmq well actually
it's not rabbitmq this is actually I
think a buckler modular synthesizer but
whenever I think and grab em cube this
is what I think about it's basically
just a mass of waters um that you need
to plug in and you know if you plug
stuff in the right way you're gonna get
certain behavior I don't know if any of
you ever played with something like a
modular synthesizer but you have sort of
oscillators and filters and amplifiers
and you know if you plug different
things in different ways you make all
these funny celebrate where-where-where
sounds like a beloved of people that
nightclubs and stuff like that and it
can be a lot of fun but the big problem
is if once you've wired something up the
problem is if you change the wiring you
can never make the same sound again but
actually how you wire and that's very
much how I felt about rabbit because the
big problem is that well it's not a
problem necessary but rabbit has a very
complex topology
rather it's just just just to go back a
bit rather is them we're now talking
about the message router right within
within this structure so rabbit is what
rabbit is what we chose is our message
router now I think I guess there was a
number of different options we could
have chosen here I think the fact that
rabbit is itself written in was written
in a and probably helped probably also
because the ESL guys also you know
suggested that the patent would work
well so we chose rabbit as our but
visibly the wiring certainly from the
perspective of the newcomer it's very
it's quite complex topology you know you
have connections
if channels you have exchanges of cues
you have routing keys and you know the
behaviors that you get from rabbit very
much depend on how you wire up these
different components of different ways
you know and it may be very intuitive to
a specialist but it's definitely not
that intuitive to a newcomer I did go on
the rabbitmq mailing list at certain
points and ask questions they were they
were friendly but they weren't that
friendly they were very much liked
anyway one of the way this guise of
getting it but it wasn't clear to me at
all and we had a devil of a time with
one actually the unit of currents
concurrency was an individual Channel
and was not queue spent we spent a
number of weeks they spent quite a while
trying to figure out why I work who
wasn't getting parallelism this will
finally hit C on it again yes I'll help
thank you and it worked fine so wiring
stuff have been rabbit you know
initially can be tricky but that said
what we found is that there's very much
an 80/20 principle at work here which is
a couple of patents give you almost all
around you and in particular for us it
was a pub sub router and a worker pool
and once we had got you know gen servers
which encapsulated those two patents
they worked very well it rabbit worked
pretty much without a hitch was routing
messages left right and center without a
problem
and you know we didn't have any troubles
I mean so much so that we thought maybe
these things should be baked in at the
language level but perhaps elixir
so I pub/sub router let's go over this
quickly actually I'm not gonna go over
this quickly I'm gonna I'm gonna just
leave it for later because I'm looking
at the time I mean these were the
particular facets of our pub/sub router
this this is basically the wiring for
our pub/sub router with prefetch count
equals one and I italics because if you
get that wrong you're going to be in a
lot of trouble and the four bullet
points at the bottom were the API that
we eventually came up with which
described our pub/sub router so any any
client wanting to subscribe to the
router have just used those four for API
methods at the bottom and it worked out
very simply worker pool almost exactly
the same slightly different API at the
bottom but if you take time to go
through the bullet points at the top
you'll see that they are slightly
different there's a gem server in this
case I think the pub/sub router used a
topic exchange this is a direct exchange
we have to declare a couple of extra
records the queue behavior was different
the way work has bound to queues with
the way workers were bound to use
slightly different but you know once
this was working this worked fine I
would say that the the there was some
good documentation of rabbit with
respect to Python clients which uses a
libel piker and we basically just
translated those patterns in turn and it
worked out very well at their code okay
I didn't want to show too much code but
this was this is just to show how simple
it then was to build a client which in
this case subscribes to the rabbit and
cute pub sub router so again apologies
if you're not laying vision but
hopefully if you are proficient you'll
see you'll see that this is fairly
simple all you're doing is you're on
initialization you're asking the gen
serve to subscribe and when it does
subscribe maybe I can move my mouse try
doing that because I'm sure it's great
so here we are up here we are
initializing the router with a set of
routine kiddies we ask it to subscribe
over here which causes a timing message
down here to be generated now in this
mess
here we actually subscribe with our
routing keys and generate a consumer tag
which is added to the state and then
once we've done that was that worth of
termination method down here but once
we've done that this gen server can
happily receive any messages that come
from the router provided they match
their routing keys that it's subscribed
with so you see that in this handle info
block here the first thing we do is we
acknowledge the delivery track and then
I've commented now need to do something
with payload and that pan worked very
well for us we have a lot of subscribing
clients to our pub/sub router which in
orbit this message routers son no more
Kota koalas a Manning star cache okay a
bit about application design when we
started because we were new to early he
started off generally building
everything as kind of like a giant big
ball of mud panel where everything was
into the same application and my friend
Robbie Rashmi said no no no that's not
the way to do it you should be you
should be in the designing applications
and of course being a newbie I was like
what do you know I'll do it this way but
of course he was right and we figured it
out over time and eventually you know we
ended up this is the next few slides it
was quite a few different applications
which are all bundled together under the
same release and I think one of the most
interesting is the idea of a cache and I
call this a Manning stock cache because
it's laid out in detail in the Manning
book on Erlang and OTP which is a very
good book and this this is an
interesting example because it describes
about how to build a cache in early and
when you first come across it you know
it says what you should do is you should
have an individual process every value
in the cache and you look at that and
you think how can that possibly be true
that just doesn't make any sense at all
this thing is going to be so inefficient
it will never work and I could do it
much easier but as you get deeper into
it you realize how much sense that makes
because we realize that well the moment
of the the Scylla means the lightbulb
moment for me was when I actually just
when I actually needed to design a cache
which had time-outs value so so I don't
think this is actually in the book but
you know every value in the cache
I needed a timeout after six and second
given a particular time and I realized
that if every value in that cache was
described by a gem server gen servers
crucially have you know life cycles
which you can describe as permanent or
temporary and you can set up a temporary
gen server which expire to the server
point and when I figured that out I was
suddenly oh my golly that makes so much
sense because you could create all these
processes which have explicit life
cycles and you can set them up with
certain ages and then when you want them
to expire out of the cache they just
disappear and that that truly was a
lightbulb moment because I considered
how would I do that in Python you know
how I would do that title involved
someone holy to the sweeping method that
would clean up various processes after a
certain time you know just thinking
about it disgusts me slightly but the
Erlang the Erlang way of doing things
for that cache really is absolutely
brilliant and I think if you are new to
early it is well worth buying a copy of
the manning book and just implementing
the cache as they describe it and then
thinking about what you would need to do
if you wanted to implement a cache
timeout you know that's that would be
one of my key bits of I of advice for
any anybody who really wants to get
early and I get Erling I mean not just
the language itself but actually the
sort of OTP level and the sort of layer
of application design so get the Manning
book port client ask more code can they
really go through more code I'm just
going to talk about ports in general
ports were a big win for us in Erlang is
not known as the fastest language you
know in terms of clock speed I'm
guessing it might even be slower than
Python but what it is absolutely greater
is interfacing with other language other
languages and in particular we have an
all our algorithms that we described
earlier described a written in go to
speed and you know we found that it was
very very easy to interface go processes
with fire ports the code is sort of just
at the top here and literally it's as
simple as opening a port with their
defined
external count server pushing a request
to the court and then receiving all the
results back from the court and that's
it and it worked very very beautifully
and III have some experience working
with sort of trying to interface - and
see which is definitely not a beautiful
process at all but again one of the
things that's not always apparent from
the start is just how well line does
interface with other languages and you
can do that with with various levels I
mean with with golang I don't think
there was an explicit goal and port
likely so effectively we just hacked it
and what we did this is such a bit of
goal encode here and we basically built
a very simple JSON interface where some
Jason was passed over the port with this
delimiter here just 8 /n delimiter and
then once the delimiter is reached
dealing the goaline process determines
that the requests been received
you know runs an algorithm over it and
then returns it so it was a very very
basic sort of API but it worked
incredibly well but also you have
explicit libraries for other languages
to interface with via ports Amina's
there's a there's a port as a project
out therapy to a project called Airport
which does the same for Pais and then
for Python and Ruby but at a much higher
level and we had a lot of success with
there and so Erlang is a sort of
interfacing language because you have to
accept that anything isn't you know it's
not it's not going to be perfect for all
parts of your application but it becomes
very easy to glue various other bits in
which has been a big win MapReduce well
this harks back to some of the models
that I talked about earlier you know
this is a kind of tacky that we do an
awful lot in turn when we're concerned
with scenarios because for every so
every mark that we generate we're always
concerned but oK we've got a match
coming up what let's take a match little
vs everton you know what often we need
to know okay what happens in at home
with what happens in a way with what
happened to their job and this this sort
of you can map this very successfully
onto a MapReduce
where you fan out inputs you fan out a
set of inputs for each of the different
matches you get them to calculate in
this case each one with a goal-line
process marshal by Ola and then you fan
them back in and actually calculate the
the net changes of each one so this is
this is just a map would use pan but we
do an awful lot of this within lang and
worked very well and you can see our Map
Reduce router in this this is how our
core pricing model works and each each
unit on this page is effectively an
application in itself so again we said
if I had written this slide when we
first started there would just be one
big circle in the center of the page
which is just about one big application
but ultimately we managed to split it
out into our whole series of different
applications you know which could be
used in various different projects so we
ended up with a while rabbitmq worker
pool which we talked about a MapReduce
router which then fanned out tasks to
the worker pool such as our risk
generation process I talked about there
the pub/sub router which was basically
responsible for for routing messages
within the application and then the core
pricing model itself and with you know
once we had actually managed to split it
down into these separate applications
you know it becomes very very manageable
you know what had seemed at least on our
first iteration to be quite a complex
application you know with a lot of
different consent once it was actually
split down into separate applications
yeah it it seemed very manageable and
you know it was useful because a lot of
these components on the left-hand side
of the screen were able to be used in
subsequent applications and you know
potentially will be used in the future
as well algo traders and this is a more
complex application which we use for
hedging a lot of our positions over
various matches on every weekend and you
know we ended up with a lot of different
applications here I I'm so I'm sort of
emphasizing a lot of applications here
because again this one stood out was one
big application but we ended up with
separate applications for the the
Manning cash which I talked about the
the the pubs that were out her the team
matches stuff which we talked about and
then various betting related
applications as well want to do with
authentication another to do with data
feeds bet feeds and then actual broker
to place bets as well so a a more
complex application and but again one
which has worked fairly flawlessly I
would say over the course of the season
all Abele marshaled by the pub sub
router distributing messages between
these distributing messages between
these components okay a quick thing on
application design so yeah sort of one
of the themes that I've been trying to
push in over the last few slides is you
know we started out with one big
application then we gradually broke it
down into components it's not always
easy to see or to decide where your
different components should lie I mean
this is the problem that we face that
you have a number of api's within
industry Betfair matchbook and pinnacle
names might recognize they are betting a
POS but within each of those betting api
is various different sort of aspects to
those api this authentication market
data and then sort of bet entry as well
so the sort of problem the application
problem group if you will look something
like this now the question is how do you
cut it you cut this thing vert you don't
want one application for each of these
nine blocks right what you want is more
you need to decide whether to cut the
problem vertically or horizontally you
know so which way would you do it well
if you come from the Python know you
probably say I'm going to do this
vertically so I'm going to have a bet
fair library which encompasses
authentication market data and bet in
the tree and I will do the same for
matchbook and then the same for Pinnacle
and that's the way I'm going to do it
very natural fact we found it much
easier to do it horizontally which I
find kind of slightly counterintuitive
but it it became quite clear that sort
of all the authentication round for
different API is you know should be done
in one application all the mark get
daddy to stuff to be done in a separate
one and all the bettin crunch-ry' stuff
should be done the third and of course
if you're building stuff in other
language this betting these betting
aspects won't be directly related to you
but my point is in general if you're new
to line it's not always easy to design
your applications upfront and you know
get them right get get the get the
cross-cutting aspects correct you know
it's fine if you are if you're well
versed it's fine if you're well versed
in the problem domain and you have a lot
of early experience but I think often it
application design by application design
I mean earning applications which has a
specific meaning it's almost easier to
build everything as one application to
start with and then reflect on what
you've got and start abstracting
different components out of what you've
got in order to make things more
manageable now yes sir link solutions
will say that's definitely not the right
way to do it and I agree
but you will probably learn more by
starting with one application and
cutting it that would be my advice right
we're nearing the end I'm conscious it's
10:00 to 5:00 so a few things that work
well for us and then go m'kay yes
there's always this holy war between
pbar-lnk-ctr that you use the guy who
runs it I'm going to mangle his name but
I think it's Loic Oh Queens a French guy
he's a really nice guy and is incredibly
responsive to changes and ideas and
problems that you may hurt he's great
but from my perspective Erlang time came
really made working with Erlanger
proposition you know I had a bit of
experience before with make files and
rebar you know coming from Pikeville it
wasn't that great but working with MK
you know earlier okay really actually
made working that not exactly as easy as
working with Pisces but not far off it
and it certainly removed it certainly
removed a barrier for us in terms of
making me other practical propositions
so I would say if you're someone to
check out early okay it's really great
logging we had a great experience with
an application for paper trail which
looks like that come back in a minute
and a library called syslog so paper
trail is basically a logging application
which uses the syslog protocol you know
we had we had a we were generating a lot
of log data because we're running stuff
you know once every second we're running
a lot of process at once every second
and you know how do not do we use larga
do we use something else do we set up
our own logging thing and I got a
recommendation of the web by a guy
called Patrick McKenzie and he said you
know use paper trails absolutely
brilliant and he's right it is
absolutely brilliant all you need to do
is you need a system of library which is
done by a guy called Tobias Schlag guy
he is also very nice guy and very
responsive and literally it's a single
line of configuration in your land okay
Cisco config file and then once you've
got that set up info messages are just
one line very very similar to how they
were in marker but you've obviously out
sourced all your logging you don't be
the logging server or anything like that
so for a start up or a small business
you know paper trail and syslog is
absolutely great for logging and I would
say you know if you're generating a lot
of log files go and use that it's a big
win
that's what paper trail looks like so
the paper trail interface is really
lovely if you like pushing this a bit
too hard but if you've ever used if
you've ever used
Google's cloud console lock I mean the
thing is literally like wading through
molasses it's so slow it's just
unmanageable and paper trail by contrast
isn't
salute delights incredibly reactive you
could set up alerts and filters you can
it really gives you a window onto your
application and assuming you're going to
be doing stuff with fairly high
frequency I'm it's a good logging
solution it's pretty much essential next
deployment a little bit on deployment we
hack our deployment together we don't do
anything particularly sophisticated we
use ec2 we use Python and boto to deploy
our releases to ec2 the great thing
about Erlangen MK is it just finds
everything together in in these Erlang
releases which can then be tarred up and
copied to ec2 so it's a very primitive
deployment we don't do anything
sophisticated particularly but it works
it works just fine we are potentially
going to look at ansible which I think
automate some other stuff I'd say the
message here is yeah if you're building
Erlang releases you probably don't need
that at least if you are working it with
a single machine probably don't need
that much you don't need to complex a
deployment configuration to get
something working with ec2 I have a
feeling somebody's going to simplify the
whole ec2 thing at some point because
it's still too complex in my mind but
you can get away with just just you know
the bare basics with ec2 Atlanta and get
something going so that would be my
advice there right bit more advice what
can I only do another language if you're
familiar with the Erland community you
may have seen some of these some these
quotes I picked a few off aware what can
I do in Erling is a great email worth
reading I mean it sort of mirrors our
experience exactly from a guy started
off in Python you know was doing a ball
of stuffing pythons and you know
ultimately reach the limits of what
pison can do and you discover the Erlang
and you know it's solved a lot of the
issues for him and the the the phrase
that really resonated with me is that
you know we were doing this in Python
without realizing that is you know
basically writing an entire framework if
you said we'll find yourself writing a
framework and piety to do something you
are probably doing something wrong right
you would be better outsourcing it you
know and in particular sort of something
that looks anything like a middle works
great work you'd be better stopping and
saying okay this has probably been done
before there's probably better ways of
doing this and certainly if you're
working in Python the better way to do
it is to think about doing your
infrastructure layer there in early and
then plugging Python scripts into it
using ports but go on read email because
it's it's well worth it one more
linguist is your favorite language I
won't say what your favorite language is
because this one this one has an element
of the flame war in it I don't want to
start a flame war but it's basically
again it's an interesting thread about
using Erlang versus using event-driven
frameworks of the same language and you
know again this really resonated with me
because you know consider going Purell
which works exactly the way you're
looking for it to work call a function
you passes or you pass which passes
around messages and gets the result for
you and the result comes back along with
the function call and all the not
blocking is handled by the LLVM Tokyo
transparently and that really just nails
the value proposition of early right you
know if you try and anything else you're
going to be messing around with
callbacks and you know nested stuff you
know maybe some of these communities
have figured this out but you know they
figured it out 25 minutes after links
figured it out and if you're trying to
build a business you don't want to be
doing that you don't want to be messing
with callbacks and stuff like that
you've got better things to do like
trying to grow your business and produce
an equity value you know so that that
statement really nails it I think you
know it's the fact that the non-blocking
is hand but again a bit of advice but
advice
olan got on k use that cowboy cowboy is
a well-known
HTTP web server written by Loic over
wean again he has some great
it's worth going through those the
manning book is very good what can I
only do in other languages reference why
I program in our long it's another link
that I enjoyed by Kevin Levin and in
summary one of the most interesting
things I think about Erlang is everyone
thinks oh it's this functional language
and indeed at the micro level it is very
very functional you know it's a
functional programming language but once
you get up to the application level you
know everything starts to look much much
more object oriented because you have
these gen servers which aren't exactly
objects you know but they behave very
like objects because they have state and
you have methods on them you know which
change the state and they can do things
you know and once you have you know a
lot of these gen servers all connected
together and talking to one another you
know the whole thing feels like a very
object oriented system but not a sort of
flat oh you know it's an unmoving object
oriented system like you might have in
Java or something like that
but one which is really alive one that
you can really inspect and you can
monitor the messages between them you
know in a very very dynamic
object-oriented system and I'm sure I've
seen somewhere there's a great quote
okay I couldn't find it unfortunately
anyway but it's something to do with the
fact that Erling is the most
object-oriented of all languages which
when you think about it is quite a
paradox but it's very true a few things
on the future so what does the future
hold
is App Engine dying well no we're going
to continue to use it but I think you
know the platform as-a-service market is
going to change you know in 2008 I would
have said that you know the platform of
the service thing was gonna was going to
stomp all over Amazon's ec2 AWS product
you know on platform as-a-service was
the way forward well I could not have
been more wrong
because AWS is now a billion-dollar
business I think in terms of revenue and
you know Google's commitment to app
engine
it's still there but they're focusing on
other ideas like Google compute engine
and and generally copying what Amazon do
but I still think I still believe that
you know the platform-as-a-service
market is going to be
it's just it may need to change somewhat
you know maybe the initial product
offering it wasn't ideal and what Amazon
is doing with AWS lambda looks very
interesting that's that's that's
certainly a next-generation platform of
the service model comm boxrec is a
start-up which puts a whole layer on top
of AWS to give it a platform as a
service type feel
what else are we looking at react
everyone's heard of react react is
absolutely great if you're doing user
interfaces in anything other than react
then you know you're crazy
in my opinion except if you're using Elm
which looks even more interesting than
react you know it's certainly next on my
list of things to take a look at Elm
looks absolutely fabulous elixir I put
with a question mark because having used
Erlang for a couple of years now you
know I'm not sure I'd feel the need to
move too early personally I mean I can
I'm sorry move to elixir I mean I can
see that definitely the syntax is
appealing you know and if you're coming
from a dynamic language maybe it's
easier that way but part of me says
economy part of me thinks about links
there that it does too much trying to
hide the underlying message passing you
know it may be who tries to make things
too easy for everyone and actually you
know I should be a hard-ass about it and
just tell people to go and you know
learn about message passing yeah because
that's really what's going on under the
hood so alex is great brings people to
the platform and whatever but you know
personally I'd government and finally
reason I saw this the other day that was
a new interface to the ML language I
have no idea what it's about it looks
cool and that's it I hope you've enjoyed
this presentation I hope you've learnt a
little bit about Erlang and Python and
how you might move from one to the other
if you have any questions I'm more than
happy to take them now or alternatively
if you want to get in touch with me
after the presentation that would be
fine afterwards that's interesting thank
you so much for a very
talk on our line I really really enjoy
that and you know we do these webinars
once a month but you you've brought so
much in a Missa tee and personal
experience into the presentation which
is really where where the value comes
from now I'd also like to thank everyone
who's been asking a lot of questions
there's more questions we've received
and we can answer but we'll certainly
try and justify and sort of honor as
many of them as we can so to get us
started immediately just in the first
question I'd I'd like to ask you from
one of our audience is how does AWS
lambdas play together with Erlang /
elixir the member of the audience is
basically saying it seems like all the
advantages of the bingham are lost in
the lamda context so again how does AWS
lamda played together with Erlang and
mixer golly I have no idea off the top
of my head what I would say is I mean if
you think about my sort of general
message throughout this presentation I
mean I I'm a kind of practical guy you
know I love Erlang I think it's great
but I also think you know it's like
different tools for different jobs so
one of the things you should take away
from this is yeah yeah we user like an
awful lot now and it's brilliantly said
things but we're not going to be
abandoning App Engine or Python for
certain jobs because it's just great you
know for sort of plain vanilla stuff
that doesn't require you know super high
frequency type concurrency I would say
don't bother with Erlang you know don't
just stick with Python you'll stick with
Python for what it's good for
so you know the sports risk approach to
different kind of tools is very much
polygons proach you know we want to be
driven by what's the best tool for the
best job or for the current job not by
you know what do we want to play with
today now with that in mind you know the
reason I'm pointing out
what was it AWS lambda is not to say
merge it with LA I'm not really don't
know how you would do it or anything
like that what I'm simply trying to
point out is that I think that's
something interesting it's on our radar
screen as a very interesting tool for
the future and if you're into building
practical type applications it's
something that I would have a look at
you know how you integrate it with
Erlang yeah I don't know cuz I haven't
looked at it yet but you know if
somebody wants to go ahead and let me
know then I would be all this certainly
sorry about that thank you thank you for
that Dustin I think that actually makes
perfect sense and thank you re for
asking that question now hello hello
hello I I can't hear anybody I'm afraid
I can't hear anybody can't hear anybody
sorry
oh yeah I I can only hear you into
process what are something you've lost
Aladin are you there okay can you hear
me now sorry I can hear you no sorry I
yes I am a tremendous I lost you for
that 20 seconds could you repeat the
question that's fine that's fine so
Felipe is asking how would you model an
object orientated world's inner line
could you equate a process and and an
object orientated model so to speak can
you can you hear me all right now I can
yes okay well yeah it's it's a good
question I mean I'm not sure if you
asked Robbie Robbie Russia I mean he
would say that a gen server is very like
an object-oriented singleton now I am
NOT an expert on object oriented systems
I haven't you know not read the Gang of
Four book on patents
or anything like that so I'm not sure I
can compare the two in a theoretical
sense but what I do know is if you build
an OTP application which has a lot of
communicating gen servers
it feels very object oriented because
each gem server has its own state which
is very like a for example Java object
you can mutate that state you know with
the aid of functions you can get aspects
of that state and so on and so forth and
so you know my advice would be I can't
give you sort of theoretical answer to
it but what I would suggest is you know
if you're into object-oriented languages
and you like designing things that way
don't rule Erlang out because you may
find that it's actually much much more
object-oriented than you think and again
I would probably point you to the
Manning book and the cache example or I
would even say just just experiment with
a sample application which fires up a
series of gem servers and try playing
with them because again the result will
seem probably to you possibly not very
object-oriented and from my personal
perspective is it's it's a very nice way
of working you can once you have all
these communicative processes you can
reason very simply about system and
again I mean oiling has all these
tracing tools which actually I'm not
familiar with yet you know where you can
actually go in and literally inspect the
various messages between them so I'm not
sure it's from a theoretical perspective
how that work but I would say give it a
go and give it a try thank you for that
Justin let's move on straight to the
next question
Larry is asking is it Erlang suitable
for building things such as higgs
engines fix engines yeah that's Fi X yes
I would say I I'm not
% familiar with fix I know it's a
financial protocol I would say it's
probably extremely extremely good for
building fixed type protocols or at
least or at least applications which
need to communicate over the fixed
protocol I mean certainly you know if
for example again I don't know so much
about fix but I'm guessing it is you
know not dissimilar to you know
connecting up to a TCP stream at raw TCP
stream and and consuming that and Erlang
is everything is very good at that and
that's something that's virtually
impossible in PI 3 quite frankly I also
know that I don't know if you guys have
heard of a guy can sergey elena card or
a book called it was one of the Michael
Lewis book but Sergey Elena conference
of famous guy worked for Goldman Sachs
and was working in high frequency
trading and was sued I think wrongly but
Goldman for supposedly stealing some
code he actually did it but he famously
was kneeling expert and and did a lot of
work of exactly this type he went into
Goldman and I think found that their
systems were not that great and
ultimately started splitting it down
into various different applications and
you know cutting it down and he you know
he was an ER languorous listener like I
think that still works in high frequency
stuff and I would bet my boots that you
know he would you know he would have
done a lot of thick style processing
within early and in fact if you google
around the web for the name Sergey Elena
call you will probably find a lot in the
Erlang space about that he's posted out
he certainly has article out there about
how to build a gentillesse a gen TCP
server in early so I would say yes if
you're looking at fixed protocols Erlang
is probably a very good choice thank you
for that Justin I can only apologize for
everyone joining us for the webinar is
we're receiving questions much faster
than we could possibly answer them but
we'll try and answer at least a couple
of
yes sure so just just in one of our
members of the audience is starting to
learn her life and this is actually
quite an interesting one he's basically
saying he's been reading in a lot of
articles that Erlang should be avoided
for the reasons of CPU intensive
intensive tasks now have you personally
ever come across any such tasks and
would you sort of agree with that reason
to avoid mine no I would say it's
absolutely ridiculous I would say
whoever wrote that basically doesn't
really understand how langworth know if
you have a CPU intensive task the best
thing to do with it is to write your CPU
intensive task in a different language
you know that is suitable for fast CPU
work such as C C++ or go and then have
Erlang communicate with it by our LAN
port and I can say from experience that
that works absolutely fantastically so
that's that's the first thing I mean
even if you're just working at the
single CPU layer you know you can do it
you know you Erlang's
perceived slowness is you know is is
just not an issue it's it's the same
reason that's it's the same reason it's
the same reasoning which says that
python is slow in our Python library is
slow but you know what you find is
actually it's pretty fast but if
somebody has taken the CPU intensive
bits out and just written them in C or
C++ and is then interfacing them from
Python so you know what you need to
think about is not necessarily a pure
Erlang approach but you know a a mixed
approach with you know your CPU
intensive it's talking to Erlang via and
Erland cause you know and that's just
without considering the parallelism you
know so you know already that you're
going to get a pretty good speed pickup
you know by by outsourcing the CPU
intensive bit to go but once you take
into the fact that airline can do it in
parallel right I mean you're off to the
races I mean you know the speed is only
really down to the number of CPUs on it
so yes I would say that Erlang is a very
very good choice
you know frankly for cpu-intensive stuff
not you know you have to be careful
saying that I don't literally mean that
in that you should write with the you
shouldn't write an image processing
library probably in Erlang what you
should do is write it and go or C and
then interface it into an Erlang
application does that make sense I I do
agree Justin thank you for that and just
to say we'll move straight onto the next
question well thank you so much for
everyone sort of keeping posting the
questions to our chat facility now next
question comes from Susan and it's a
good industry-specific so Justin you can
sort of comment on if you want to I'll
give a very brief response myself Susan
is basically asking why you think is
Erlang so popular in the advertising
community now Susan I can tell you that
you're completely right we have a number
of customers and projects we have run in
advertising we have clients who serve 30
billion ads per day and I guess that
sort of answers your question you know
to achieve that kind of massive
concurrency scalability and
fault-tolerance
you know people normally look at
languages well look at Erlang really as
sort of the top tool for a job
now Justin would you like to add
anything to that well again I don't
really know anything about the ad
industry except that you know I
understand that you know there are
people out there we're running sort of
ad auctions and this that and the other
and real-time bidding for ads you know
stuff like that you know that kind of
problem looks very similar to sort of
some of the problems that we have where
you know where we're pushing lots of
bets in parallel around the system you
know you could say they're a bid for it
you know a bid for a you know a bid for
an advertisement you could consider very
similar to you know a bid on a betting
exchange or a price on a betting
exchange so you know if you have a
problem which involves a lot of these
messages you know these little bids and
offers flying around the system and you
know in needing coordinating you know I
would bet my boots that you know Erling
is going
you know a good fit for that I mean the
canonical example here is probably
what's out right I mean again they built
some sort of giant SMS type machine
there's very little I don't know
anything about what's that doing they
rather like but just thinking about what
an SMS chat application involves there's
not a lot of CPU processing going on but
there is a very very very high number of
small messages flying around the system
at any one time that need routing from
one endpoint to the other you know
that's the sort of defining
characteristics of a chat system now you
can see why our lungs so good at that
because it's not it's not a CPU
dependent problem and because it does
parallelism of concurrency so well it
becomes large to just a matter of how
many CPUs you can bolt on to route the
messages around so you know my own
sports risks own problems are not
dissimilar to that sort of chat
application because you can consider you
know a lot of these messages that are
flying around our system whether they're
placing bets or for running scenarios or
this that and the other you have a lot
of things that have got to be managed in
parallel and I would have imagined an ad
engine although again I know very little
about it is not dissimilar you know
you've got a lot of people bidding ads
you know a lot of people trying to sell
ads a lot of these bids and offers are
going to be generated algorithmically
you know from a 60,000 foot view
perspective I would say that you know
the message flow probably looks very
like a chat system and ago that probably
Erlang is a very good choice you know if
I was involved in that sector I'd say
yes certainly
the thing I would pick Thank You Justin
I I do have to apologize to our audience
but because we've already over run on
the time we'll only be able to answer a
couple of other questions so Justin
here's an interesting one and before I
ask it I'll just say that we are not
sort of into the types of conversations
where you you know confront two
languages and then try and sort of you
know score points off them so to speak I
mean it's it's really all about right
tool for the job but one of our audience
audience members is asking could you
compare Scala and Erlang and what what
would your view
to be it's very simple no I cut they
don't know anything about Scarlett I
mean I know I know a little bit about
Scala to be honest I have always shied
away from Scala because I wasn't
massively enamored by what I'd heard
about it but I don't want to you know
diss a language or a platform really
without knowing anything about it you
know so I I will probably if it's okay
pass on that one that's acceptable
I'm sure that Erling is better really
well it really is you know as you play
all about the use case and the specific
bit of technology but just to move on to
our penultimate question Marian is
asking what's the best way in your view
to migrate from a language such as Ruby
to something like our lang okay well
that's a great question I mean the the
best way is to try some baby steps with
early right you know it is different you
know it's a functional language you know
it looks different from Ruby it feels
different from Ruby you know you have
this whole it's not just different at
the language level but it's also
different at the framework you know so
in just the same way that writing a an
Erlang script is quite a different
proposition from writing a simple Ruby
script you know so designing an Erlang
OTP application you know it is quite a
different composition from you know
writing a rails application for example
you know they just well when you've got
a bit when you've got a bit of
experience you you know you start to see
the similarities but when you're
starting off you know they definitely
look very different I would advise you
know you just take some baby steps in
Erlang and you know try and get a few
things running you know buy some good
books the manning book is very
good but it's more on the application
side you know Joe Armstrong Serling book
is very good but that's just on the Earl
inside I mean it's it's it's it is it's
very much about practice you know it's
not as easy as say picking up - from
Ruby because they're quite different
what I will say is it's very worthwhile
you know it's it's a bit like learning a
foreign language you know if you're
English you want to learn German you
can't be fluent overnight you know but
if you can just try little scripts and
little examples and get a feel from it
it is well worth it but I think it's
very much down to practice and small
steps but very worthwhile thank you
Justin and to try and sort of sum up
with our final question so baby is
asking he's working on an orchestration
project where he has to handle a lot of
aggregations and transformations and
he's asking do you think our line would
be suitable for such a use case I guess
I need to know what an aggregation and
transformation means because that that
sounds kind of general I'm not sure
really what in an aggregation of what
and the transformation of what no
there's nothing specified but I do agree
you would need a bit more details I mean
if if it's if it's a mathematical
transformation or a mathematical
aggregation then I would say not you
know it sounds if you're writing some
algorithm if you're writing algorithms
in Erlang then you know literally image
processing algorithms you know search
algorithms literally see style
algorithms that's probably not the right
thing to do you know they're better off
in a CPU intensive environment I mean if
you're writing an application which
needs to do a lot of independent
algorithm calculations such as the one
you know we're doing or you know you can
imagine something which needs to do a
massive amount of on-the-fly image
processing but say you need to do a
massive amount on the flame processing
well you wouldn't do the image
processing itself pie
I mean in LA you know you'd want to
outsource that to see or go
but you could have Erlang orchestrate
the whole thing especially if you've got
a machine with the large number of CPUs
you know you could basically plug in
image processing algorithms into early
via ports and I think you probably have
a very successful solution there which
would scale very nicely
you know because you get to use the CPUs
very efficiently so I think the answer
and guess I'm sort of inferring a bit
what do you mean by transformations and
applications but assuming you mean sort
of hard core you know algorithm type
stuff then yes I think it would work but
you've got to be careful how you're
separating things out how you're
separating the CPU intensive stuff from
the actual out application layer Thank
You Justin okay I'm gonna succumb to the
temptation of asking one final question
I think we can sort of finish this so
one of our audience members is asking so
what are your top three reasons for
anyone to switch to our lang I just
can't resist asking this no it's a great
question um I I think well number one
reason would have to be because the
stuff works right it just works
you know I got tired of writing stuff in
Python and just eventually bumping up
against its limits you know bumping up
against the the you know the global
interpreter lock you know bumping up
against their lacks reading capabilities
bumping up against the you know the lack
of you know native app okay you know the
lack of an application framework I love
- don't get me wrong but it's not great
for you know writing applications I got
fed up if you want to write applications
which just work and you can focus on the
problem at hand and building a business
then you know Erling is the one for you
because you just you just assuming
you're doing things the right way you
know you just thumb you just get into
less bottlenecks it seems to me you know
it scales
buckless Lee and that's a really
pleasant feeling so that would be the
first thing the second thing I don't
know if I have I don't know if I have
three reasons but I probably got to the
same reasons I really actually came to
like the syntax because you have to
ultimately what you find is you have to
think a bit more about what you write
and you have to think of it because
you're sort of working within its
application framework because Earling is
probably not quite as an expressive
language as pison you ultimately have to
sort of plan a bit more about what
you're going to write how am I going to
let out this module how am I going to
get this like module how am I gonna have
as much and I find actually having
having a sort of slight barrier to sort
of you know immediately getting down a
writing code to be a good thing I find I
would probably actually write in better
code because I was just I was forced to
lay it out better within the context of
these OTP frameworks and I think having
having that OTP pattern to you know
build against is just a wonderful thing
you know you've just got this framework
you just have to lay out the code the
right way and yes it may take a bit more
time than - but it's actually it's
actually a very very simply sharable
things to know that the sort of
framework is there and you could sort of
lean against it as long as you can write
code in the right way you know it's just
going to work in many ways it's a weird
thing I mean in many ways writing an
Erlang is is definitely more
constraining like that but you know
constraints sometimes can be liberating
because ultimately you know you're
forced to sort of you're forced to
observe a few more things and you would
otherwise but by doing so you know it's
almost as if the framework knows better
and the framework saying well don't do
it this way you know just do it this way
and if you find yourself fighting the
framework you know you're generally
doing the wrong thing but if you go away
and actually think a bit more about what
you want to do you're going to end up
with better code and so having the
framework there to sort of code against
you know was a you know and I there is a
final reason actually which I think it's
the only language
which is really solved the concurrency
problem I may be wrong there but
everywhere else I look you know if
you're doing these kind of applications
concurrency is a big issue I don't
actually see any other solutions that
get it right
- gets it wrong the node in my opinion
gets it wrong here any event-driven
callback thing gets it wrong Java gets
it wrong because threads are awful
you know akka in Java is just a copy of
the Lang you may as well just program in
the original well that do Justin thank
you that I think was a very very helpful
answer so we're getting questions as we
speak and we can't answer any further
ones thank you all for asking them I'm
sure everyone will join me in thanking
you Justin for a very inspiring talk
many thanks to everyone who has joined
us for the webinar as well please join
us again for our next monthly webinar
and following today we will send you a
short survey to make sure that we
capture your feedback of today's webinar
please also note that the recording of
the webinar and the presentation that
was shared today will also become
available for you to collect on online
solutions is corporate website at
wwlp.com thank you all once again and we
very much look forward to seeing you on
our next webinar thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>