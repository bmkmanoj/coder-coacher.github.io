<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang metaprogramming made easy: Richard Carlsson | Coder Coacher - Coaching Coders</title><meta content="Erlang metaprogramming made easy: Richard Carlsson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang metaprogramming made easy: Richard Carlsson</b></h2><h5 class="post__date">2012-06-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/z4Av8amtI8U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so yes master said this is kind of
me busting into this track but you can
see it as a way of getting out of
farming and writing your own to
yourselves and so forth getting a bit
help for that okay so first of all
what's meta programming is my definition
it's writing programs that create or
manipulate data structures that
represent programs so one very nice
thing if you want to do this is to work
in a home iconic language to quote rnk
who actually coined the phrase that
their internal and external
representations are essentially the same
so if you look at some list here which
is a quintessential home iconic language
the code for adding two and three and
the list data representing the program
that adds to an free look almost exactly
the same and there are there's built-in
facility for in the language
interpreting this representation in the
same way okay however owing it's not one
of these languages okay so you know so
the Earl encode for adding mix plus 1
and typical representation of data in
our line looks very different so in our
line if you want to work with parse
trees and so on you know first the first
thing you typically stumbleupon is doing
scanning and parsing so you have some
text a simple call to module Foucault
bar the first thing you do is tokenize
it to a call our scan on the string and
you get a bunch of tokens and then you
pass those to all parts to parse it and
you have to know what to parse it ass so
in this case I know it's an expression
it's not a it's not a function
definition
or something like that expression cycle
so I positive to parse experts and then
I get a list of the this a yucky
representation of this syntax tree or I
could also have used to parse for more
the parts term functions depending on
what kind of expression of whatever kind
of phrase I want to parse and this is
kind of messy and if you look at the
abstract format instructions duensing
something like this so function call has
a couple of sub trees one saying that 01
or I'm a call to remote thing consisting
of the the module name which is Madame
foo and the function languages Latin bar
and I have a bunch of arguments the
first which is not on when the second
which is an integer and so on now this
is sadly they say documented the
documentation is a long and you don't
want to read it also there are line
numbers everywhere in the description
table so it's not really nice to work
with now and it's not nearly abstract
enough so we have stuff like both be the
explicit representation in terms of
using tuples there's a lot of details
that you don't really want to want to
think about in the common case like the
line number of that particular
expression and the representation is
very sort of ad hoc and dependent on the
context so some things are something
some Adam tanks are reused to multiple
things like if you see a couple tech
record feel it could be any one of two
or three different things depending on
where in the syntax trees it occurs and
you should and you also have to also
always remember if it at a particular
point in this representation it should
be the concrete Adam foo or if you
should tag it up as it the abstract
version
second estimate line something and food
and of course if somebody adult p adds
something to the language you'll get
changes to this format used new stuff
comes up in this format and breaks
existing code so you have to go into all
your parts transforms or whatever and
try to fix them so they don't break it
work also there's no no room for adding
information to these trees because
there's no way really no way to know
where to put them if you want to make a
detent annotations on certain functions
something like that so it's not abstract
enough that's why I once upon a time
rope same text tools so the old site X
module is an adt for for working with
syntax trees so it basically takes this
old representation hides it under
function of API functions and adds
extensions upon it so you can you can do
all these things you can put in comments
and annotations and you don't have to
know exactly where in the in the tree
you are over there are some generic
functions like doing mad over whole tree
things once you've done if you want to
pass that back to the compiler to
generate code for it you have to revert
it to that standard double format but
working with the the Earl some text
module is also a bit cumbersome because
can get rather verbals you have to
explicitly say everything like okay I
want to build a tree that's an
application function call consisting of
module qualifier and colo f4 the syntax
with an eye on food when a Latin bar and
so on so this it's very purpose as well
even though it's more abstract but when
you pretty printed you seem to get
perhaps the most annoying part is that
if you want to decompose something you
have to use all these functions for
analyzing what you have so you have to
call else index type on the tree in find
out that oh I have a fun I have a
function called application now so let's
look at the operator and figure out that
always a module qualifier so I have em
colonized here and so on pick out the
subtrees whereas if you work with the
plane tuples you can do matching you can
write something complicated like this is
it's not beautiful to look at but at
least it's quite compact which is why
pretty much everybody does it this way
sometimes you I'm the only one ever you
see I was in Texas ABI directly yeah ok
so what if Earl centex had some kind of
patterns and I have that idea a long
time go as a PC student and say 97 or
something but I had some beer drinking
something so let's look at something
else for a while so that's a very young
company Clara had all our business logic
directly in airline code which is not
really optimal it means that management
and finance couldn't really read what
the business logic was so any time they
wanted to find out like what would
happen if this kind of customer did
isn't this in Norway they had to find a
developer who could go into the codon
scratches head and go I don't know come
back in two hours so that didn't really
work so he needed developers both to
change the logic and to explain what the
current logic and fetch it was and of
course anytime you may wanted to make
any sort of change you had to do code
upgrades and so on and there was not
really no trace on how decisions were
being made so what what the flow of
execution from this business logic was
it wanted to figure out what happened to
this particular customer info master day
it was a bit of an upset that we denied
him with this purchase can we find out
how we made the decision that he wasn't
allowed to to buy this and one that when
that was an airline code we couldn't and
so toker made a first draft he
recognized that and what you really need
to do is just to heaven an or else
operator and also operator and a bunch
of basic arithmetic and stuff and some
variables and he represented this as
there are like tuples this so you gotta
kind of a language in early so this
improved things a bit it meant that the
logic was at least in single place and
not sort of disperse the world with the
code but these sort of squiggly things
are still mostly unreadable to
non-developers really
even though Toby totally try to show
them to to the business guy said okay
it's obvious they go home so we had to
do some more about that so one day I
bumped into our CEO in the corridor in
those days we were not that many people
say 50 or so so it wasn't really
unlikely that I would bump into him
fairly awesome and he said something
like this because he'd also seen these
new tonight can't you fish slice through
these rules for us somehow like in the
wiki with labels and bullet points that
because we recently started using the
wiki or all over the company and most
people like that so I had a thought when
try to use the wiki syntax as the dsl
for expressing these things because they
seem to match this mediawiki notation
fairly well so you can say you could use
the syntax for writing a title for
giving a name to rule and then you could
write some comments and let you write a
bullet list with some statements or
conditions that have to be true and we
decided on using javascript semantics
for values and names and operators sort
of not let too much of the early
implementation be true and the input
environment to this would be a JSON
structure so it would be fairly obvious
to anybody and even even somebody who
hadn't programmed before this will do
you can also very easily nest
conditionals with this syntax so first
up that's that's an or else operator
just pick the first one that matches and
in all of that would be an and also so
all of these have to be true so you
don't have to fiddle around with its
begin and brackets or something like
fairly obvious do to people how this
worked and of course this is just
hypothetical examples something like
this is what it could you to look like
so another interesting thing is that we
use the syntax for four links as a
syntax for calls which meant that they
simply became clickable you could click
your way around between between rules
because the syntax for calling a rule
was the syntax for the link we found
that wasn't really much worse than any
other simplex I've seen for making calls
the various languages so and you can
even make rules take parameters by
adding any initial bullet saying that
this rule has input X okay so the good
thing when this is that non-developers
can read and mostly understand these
rules so they could fairly easily
starting stop right from writing their
own rules and modify existing rules and
so on and rules got updated separately
from code so we could we could load code
and separate operator loaded rules a
separate operation we could keep track
of versions of rules when they were
update and so on so that when you when
he wanted in retrospect to find out why
a particular business decision was made
in a particular way you could see that
at that date we were running under the
under these rules so and we also could
save evaluation traces for analysis and
debugging to figure out what paths are
being taken in these rules systems on
you keep all the rooms in in one place
and don't make some system
implementation
so that's the good thing the bad thing
is that language is quite quite
simplistic and as in Prolog negative
rules become kind of tricky if you know
negation as failure works and of course
requirements changed as they always do
so the initial requirement was that the
rule system would simply say yes or no
but that's some change to oh yeah we
also like to compute some kind of output
scoring value of this and actually to
about I don't know by the way it doesn't
so we had to somehow extend the language
to manipulate kind of state in a way and
that combined with this backtracking
that if you if you failed on one of the
branches you went back and discarded
that state and try it again that was it
intended to be so easier for them to
reason about since they didn't have to
sort of keep the state in mind but they
couldn't understand this either so I
don't quite know what non-programmers do
understand him and okay so where do we
go with this now we have some thousands
of the lines of rules they actually have
some service quite well for a few years
because it did take the heat from us so
we didn't have to maintain these
business rules and the business guys
could actually understand them maintain
them themselves I would like to take the
lessons learned from this project and
sort of rework the entire thing but as
usual there will probably not be time
for that so and we're discussing
switching to real business at rules
engine and will that be we've looked at
era see for instance or should we pick
some enterprise-e system we don't know
quite right right now ok so the
implementation of this
the first version was a simple
interpreter remainder lack of course it
was easy to write and it's easy to tweak
in debug it while you're just doing an
interpreter and the fact that the the
dsl language itself is definitely not
our land that's not a big problem when
you're interpreting when you're writing
an interpreter because the
interpretation can easily be very
different from the language it runs on
some implementation details was there
it's it's hard as we probably now to
share a large data structure between
processes in our line so if you have
this pretty large syntax tree
representing a few thousand lines of
rules and you want to share that between
several processes you need to copy it
and that would be some overhead so we
decided to start out easily with a
single server that actually helped the
st. extreme did the evaluations for you
and we didn't think that this will be a
big bottleneck because evaluation
typically was very very fast anyway but
as the system load got heavier we saw
that sometimes due to also some so later
tweaks to the language there were
situations where it suddenly could take
a little while blocked on a couple of
things which meant that other requests
got queued up so decided to try to
parallel eyes this and of course in our
line being modules are shared objects if
you will between our line processes
there and read only takes chunks you can
connect on us so there's not really an
execution bottleneck there so what we do
is that we compile one a rule namespaces
we call it tool to single airline module
so they're actually quite this is one to
one to one correspondence between
namespaces and around modules here so we
had actually planned for doing this for
doing compilation of this language from
the start that's general general advice
that if you ever create your own dsl
start
right away by start by writing an
interpreter because that's easily easy
to toy around with your language but
always keep in mind how you intend this
to be compiled Monday because you
probably will want to compile it for
making ok now for cogeneration we
actually generate Earl and code we're
not generating coral angle beam or
something like that just to ensure that
the code that we're running is
completely safe and has all the signs
normal sanity checks that you get from
from planar line code but we compile an
low director to memories we're not
creating any immediate files r anything
Wow however this difference in semantics
between the dsl which were some JSON
structures and so on and Erlang course
it's quite an generated code to be
pretty horrible so currently from the
input file of say 5,000 miles of rules
to get something like 50,000 rules of
our like if you pretty printed some
bottom of looking statements and so you
might be able to compress that a bit too
if you abstract out some stuff and that
compiles to like a 600 kilobyte being
language takes quite a while to compile
but it does show that the the dsl
expresses some very these ideas very
compactly so you can single line you can
say quite a lot of things but of course
only in a kind of a limited language ok
but while I was working on this code
generation got me thinking that that old
idea about patterns and stuff
all sometimes maybe I should try it out
and that leads to this little library I
know how called Merle also know that's
why the hell didn't I do this years ago
how okay so the first thing that I
wanted to do was just to have a single
clever parser function that
automatically understands what what kind
of thing so you don't have to tell it
that olam parsing expression I'm parsing
a function definition they don't have
you don't have to do anything special
here so the Merle quote function you can
pass that any single expression or a
number of expressions by separated by
commas or just a function pulse or a
cake stalls like this or a complete
function definition figures out where it
is and returns the corresponding thing
it also allows you to distribute easily
the text that you're quoting over
several lines so if you put a list
around this text and use coma as
separators it will insert the line
breaks for you and and that's kind of
nice because it means that you can trace
back to your worth well if if you get
parse errors in these things which you
typically will do you you write them and
then you forget a comma somewhere and
then you scratch your head this way you
can find out that it's particular line
of these four three lines maybe top so
much but if you have 10 more words help
ok
so now it's getting a bit more
interesting we can do met a variable
substitution so the moral term function
it takes a normal erling term and so
lifts it up to the abstract syntax tree
level and the Q quote Kwazii quote
function takes a string representing our
life syntax as that's for the usual
quote function but it can also take a
list of tagged elements and do
substitution so if you do this and then
you're pretty print the result t there
you see that you have inserted the list
123 in food so in general a quasi quote
it's just a phrase that contains meta
variables and turns out that you need
some special versions of these so to be
able to sneak them past the normal
parser and tokenizer and then afterwards
recognize that oh this is mega very and
so we can do substitution so for for
most cases you can use normal variables
wherever you can have a normal work
variable you can write a meta variable
starting with underscore at but in some
cases you're only allowed to use atoms
for instance that start of the function
the parser will complain if there's
anything except an atom here so you have
to be able to use atoms as meta
variables as well and there are even
cases where you have to make use of
integers that's the arity part of a
function arity parent or in extreme
cases even the string in a file
declaration I think that's actually the
only case we need this game
there's another complication is that you
may need to do some lifting so if you
add an extra underscore after that
initial act it means that you're this
variable actually is going to sort of
engulf the behold level above it as well
and that's needed if you want to do
something like a meta variable that
stands for this whole function / Garrity
parent if I didn't do lifting it would
just represent this atom here but I
wanted to represent this whole pair but
there's no way I can just put them a
single meta variable here in the export
declaration because of the partial
complaint so instead I have to do this
little thing where I put the meta
variable here and then I say that back
up one level and let it stand for this
whole thing and then i can replace it
with whatever so there are some tricks
that you have to know about in certain
situation but mostly you can get a vague
way with just playing normal metal items
so let's add some macros on this to make
it easier to write some things so first
of all the upper case Q macro replaces
all these calls to world quote quote and
cross a quote so thankfully these days
we have if you haven't discovered it
before you can write macros that take
different numbers of arguments to
justice with functions so if you're not
doing any any substitution you can just
you use Q with a single argument and if
you want to do some substitution you can
use key with something containing matter
variables and list of tag tag titles
also these macros does do another extra
nifty thing they take the the current
line number from your source code and
automatically inserts that in the call
to
Merle so that if you write something
stupid in these strings it will actually
tell you the precise line in your
oscilloscope source code where the error
was that helps a lot when you're when
you're writing these things now but
creating the stuff isn't really enough
you want to do matching so say that you
use cue to just create a pattern that
contains meta variables and then you'd
like to match out certain things so say
that I much this pattern against this
concrete term here by calling Merle
match now and if the match works I get a
list of the corresponding tag tuples
saying that okay the Sun first is bound
to the subtree of one here and second to
the subtree of two and if they don't
match you get the item error instead and
if you don't care about certain fields
you can use enormous matter meta
variables in the match so something like
this for instance in indicating that
much any tupple to couple with arbitrary
first implement and just extract the
second element ok so in London last year
I showed an early version of this to
Simon Thompson he goes own and it's a
lot like when we play for writing the
factories did you see on top so yeah
that kind of raised the stakes of it now
so I did some conference driven
development I I agreed to talk about
this stuff in San Francisco this year
and that gave me the motivation
we work on improvements so first of all
I had to implement globe materials
because silent had that so that means
that you can do stuff like this you can
say f of argument list and then these
attacked things will be bound to the
whole list of arguments no matter how
many arguments there are of course you
can combine that with a lifting thing if
you want to extract a number of
functions / charity pairs and make sport
now and it even works with static
prefixes and suffixes so you can say a
function call with with first argument a
second argument be and then a bunch of
arguments and on the last argument see
you can match these things out and also
for convenience they result from from
match if it works it's always ordered on
the meta variable names here so you can
actually take the result and and match
that out automatically on country you
don't have to use you find or something
like that okay now if you really want to
do this a lot to find that when you when
you call quote or you call that isn't
use the Q macro you get an abstract
syntax tree but if you want to do when
you do variable substitution of matching
these trees first have to come be
converted to a little bit more efficient
formula i called templates so what
actually happens is that the cross a
quote function first parses the thing
and then it transforms it to a template
and many calls the substitute function
rebel is the substitute function that
transforms into a template if it's not
already a template but if you want to
reuse same template over and over again
you don't have to do the parsing all
over here
again so you can do the two called
template yourself if you want to but
that's typically not something you need
to do okay so let's have some more fun
with parse transformed now if you
include the Merle dot hrl file it
enables this transform and you can
disable it if you need to what it does
is that
ok
yeah all right ones yeah what this does
is that it value eights all calls to
Merle functions that are just have
constant arguments does kind of a
partial evaluation if you want and it
parses coated strings ahead of time ten
date at compile time so let at runtime
there's no there's no real point in why
why the parsing of this fragmentation
parsing of this and turning it into
template and soul that doesn't have to
be closed at runtime so this post
transform does it at compile time for
you and actually translates into
something like just a single call to
instantiate this template and you get
the constant template structure in that
place is in so most laudable overhead
and in fact the first transform is used
to compile the parse transform using
some makefile trickery does two passes
and so on but that makes post-transplant
faster
so one thing is that so far all these
things and then calls to you using the Q
macarons on that all that can be done
actually without the mark transform so
you can include the Merle up hol file
and turn off the transform and all this
stuff will still work except for this
feature which is very nicely so any of
it any meta variables that look like
normal airline variables IE floating
with an uppercase character character
like this are automatically 52 they're
like level by the by the first transform
so instead of doing as before finding
this to something them then passing a
list of something tagged foo and saying
replace this fool by by this others
industry what actually happens is that
you get the template here with just a an
airline variable in it so this is
automatically inserted here so
substitution gets fast and there's no
need for tag titles anything but that
requires the transform
and there's a final trick which I found
to be quite useful when you're writing
when you're going but you're using this
right something is that you very often
come up on something that you need to
you need to take something like a number
or an atom or at least stud numbers or
something and you need to lift that to
the syntax level sindh extra level and
insert it in another st. extreme so we
said other instead of doing something
like this that you call Merle term on
the thing food which is absolutely level
and then do substitution you can just
use naming convention but this so a
normal and water abstractive variable
looks like this it has had to start and
at the end that means that the food is
constant 42 in their eye level it won't
be automatically turned into abstracts
industry before the apt and 42 and
inserted at that point so that removes
quite a lot of the need for an
intermediate variable names because I
before I get as I found myself writing
these silly temp through all over the
place just like to insert them in the
next flight and also most of these
explicit cause tumor all terminally also
disappear finally I've been nice
parenting bit with simplifying key
switches so you can write something like
this to take an incoming syndics tree
that you don't know what it is and you
do something corresponding to switch
this kind of thing
do that so I'd like to make across
transform Ashley's expand these things
in line to just real pattern matching
we'll see about that the Merle module
also has a simple API for building a new
module so what you do is you you call in
it until it the name of the module that
you're generating and then you can start
adding function definitions and record
definitions and important export
statements export segment when you had a
function you say whether or not it's 40
minutes before you you can update which
is the source file for this thing if you
want to try to debug information so once
you're done adding functions and stuff
you just say give me the same text
reforms for this module so I can do
something with it there's also a couple
of functions were actually compiling
these two binary like a little directive
memories we never have to go go dancer
this was very very easy to to generate
your own or lack modules on the fly at
runtime basically just call in it
functions take the folks in compartment
done so
when I was in sometimes it gave his
speech like a month or so ago I said
that it would be okay talk soon and
probably in purdue still not there
because i've been very very resistant to
go home and i hope to but i hope you get
it out very very soon I'd like to submit
it for inclusion HP one day it's not
clear what this should simply be a part
of simplex tools in the next release or
something or without meaning to words
make me parts index tools it's just one
module a decomposing system trees for
instance if you wanna use this try to
parse transforms to a bit messy so we'll
see I can do this switching idea
Oh
so yes I thought that make a new example
I had a couple examples already bit of
action making you want for this
presentation so yesterday I started
writing a basic interpreter and it's 68
lines
and here's the little test suite the
most important thing is this last
examples actually shows how it works so
you have a representation of the basic
in using Erlang couples or even imagine
that the partial states already done
what you have is a list of my numbers
and the corresponding statements on that
line number so this covered in duty
black so this was the interpreter as I
said it's often very easy to write an
interpreter first
and this is the corresponding compiler I
wrote that today it's a bit longer
because I had to do some special stuff
but it's no more than one hundred and
forty nights what you can see here is
some of the some of the uses here so to
generate code for comparing equal specs
of why you generate code of the
expressions x and y and then you
generate code for actually performing
the comparison inserting the code for
and sub expressions
that's the basic combiner has some
support support from time functions here
you often find when you're doing stuff
like this that one of the trickiest
things when you're writing dsl is
figuring out how you're going when
you're going to compile it how are you
going to map the ideas of the dsl to the
ideas of the language or implementing it
it will typically find that oh dear i
can do presents the incremental basic
you expect to be able to say go to line
40 but if there is no line 14 volt of
line print if there is x 29 just come to
the next line but how do you represent
that in our line you just generate so in
this case
this is some of the generated code for
one of the examples I generate a
function for each statement so you can
see that go to line three it updates a
variable and then goes black 10 but of
course to be able to jump to an
arbitrary line between any two lines
like this I had to make a table on the
sight that met buying the next table
that lets you associate any my number
with any function label that's usually
the trickiest part figure it is
for my
my previous version of this I wrote a
list so here's a small list it's 150
lights as you see it's very similar to
the basic implementation sexually full
full done my calculus with with a y
combinator
and here's the corresponding compiler
Felicity turned out the compiler was
actually smaller that's just under a
hundred ice
that's the Y Combinator there so this is
this is a bit different it generates a
single airline function for your entire
this program and execute side so
different solutions for different
diesels okay this is
yeah no because it's not actually doing
any not doing any kind of reasoning or
searching or anything like that it's
just it's just linear code but written
in a way that most most people can
design
you mean</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>