<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>HTTP/2 Plug to Phoenix, Cowboy Too - Gary Rennie - Elixir.LDN 2017 | Coder Coacher - Coaching Coders</title><meta content="HTTP/2 Plug to Phoenix, Cowboy Too - Gary Rennie - Elixir.LDN 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>HTTP/2 Plug to Phoenix, Cowboy Too - Gary Rennie - Elixir.LDN 2017</b></h2><h5 class="post__date">2017-09-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/R5xTuw7NYg8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">[Laughter]
alright hv2 plug to phoenix cowboy - if
you need help with your top titles go
see someone else hello
so let's talk about plug who's use plug
show of hands okay if you've used
Phoenix you've use plug by the way so
you know show of hands again okay left
people have used Phoenix and volume I
usually like to get the audience's you
know level and then discard that
continue the talk of already prepared so
there are two parts the plug there's the
specification for composable modules so
that's what you'll hear refer to as a
plug so you'll get like function plug or
module plug and then there's the other
part which is the interface for web
servers so plugs adapter based and there
are loads of adapters available there's
a cowboy one there are others I'll come
on to layer and the other thing about
plug is that it's for so HTTP 1.1
feature set so that means it supports
the options method and it sports
chunking but it doesn't support like
WebSockets or HP to and any of their
features that's just an example of a
module plug it's quite a simple one if
you can't read the code if it's not big
enough there's heaps of space on the
floor over there so go and stay over
there and you'll see it better so the
the hello world plug you add the
behavior module attribute for plug and
it's quite common to import the plug con
so you don't need to write out the fully
qualified function name you can just
write you know send response instead of
plug kondo-san response and then plugs
have an init function I'm using the Alex
1.5 in pour module attribute here that
says this function is an implementation
of the callback for this particular
module the plug module so that'll war
and if for some reason the plug behavior
changes and the init function can call
the compile time as well so the options
from in it are passed in as a second
argument to the call function and the
call form to the first argument Zarkon
which is a struct it's a plug construct
which has many fields that relate to HP
requests
so you have things like headers in there
you'll have like the response body
request headers and and so on so in this
particular example I'm taking the con
I'm saying the content type the text
plane and then sending it 200 with the
string hello world and that's probably
most basic plug that you'll you'll see
here's a slightly more advanced example
so it's called post finder and the idea
is maybe we've got a controller
somewhere in Phoenix and there are some
like you got you show your update and
your delete for example they all take
they all require this resource to be
available so we pop this plug in topic
controller to call for all the actions
that need it and again in in call and
let's assume there's a blog module
somewhere that has a get post function
so we'll take the params so this will
either be body params query string or
your L parameters in this case it'll
likely be the URL and if the blog post
is found then we will assign it so
assign is a map of data that's available
on a plug con and you can just put
whatever you like in there and it'll be
available for subsequent plugs so
normally when you use plugs use them in
a pipeline you'll start somewhere you'll
perform some sort of transformation on
the con and then eventually you'll
return a con and that'll be passed into
the next one the other thing that can
happen here is you'll get an error and
the resort can't be found in which case
we'll send a 404 not found and will halt
the pipeline as well so subsequent plugs
won't be called
we'll just stop there but that's not
what I really want to talk about as much
today as I do the adapter part so as I
mentioned there is a cowboy adapter and
a test adapter there are other adapters
available there's an experimental
chatterbox adapter which is a HTTP
webserver there is an Eli adapter as
well to another web server but largely
it's this cowboy that's used so I
thought it was anyone used cowboy on its
own without plug one part okay you go
he's Erlang I assume and has anyone done
the office does anyone use plug doesn't
know does anyone use plug without cowboy
literally no one not even Peter who
fine the other adaptors a test adapter
says that allows you to perform
assertions and your tests on the
responsibilities and things so that's
you know if you've used either
plugged-up contest or phoenix contest
then you'll have use the test adapter
and the adapter is stored on the plug
construct in the adapter key so that you
can use it later you normally unless
you're writing you know an adapter won't
reach for this but it is available if
you need to and there are some cases
that you may need this so this is a git
log on the plug repo and you'll see that
the first commit is the initial commit
as it usually is and then the second
commit is start with cowboy support so I
think it's safe to say that when the
plug is being developed it's certainly a
cowboy in mind and cowboy will have some
influence on the design decisions if
you're wondering how I get such nice get
logs by the way here's my git config I
promise this is my only get slide
probably so
yeah take a foot with that let's talk
about cowboy so cowboy is an Erlang web
server it's probably certainly the
elixir ecosystem it's the most popular
web server it's it's pretty high on the
list on hex
it's I think just below ranch and cow
illiberal trace dependencies so if you
want to make you know the number one
package and hex probably find something
that ranch depends on and you'll get
straight to the top or even better
something that poison depends on which
is the number one it's used in
everything so it's been developing for
quite some time maybe four or five years
and it's got two primary dependencies
ranch and Caleb
so ranch is a TCP acceptor so that will
handle the communication over the TCP
protocol the SSL protocol and the other
is Caleb which is it contains lots of
utility functions that are web related
so you'll find things like mine parsing
in there and and header part as they get
so on so if you're writing your own web
server then you can include Kerala visit
pensee to do a lot of the heavy lifting
for you I think the specific reason that
it exists is to support both cowboy and
the
kind of equivalent client which is gun
you could probably see a theme with the
naming convention that the author
chooses they're all based in the Wild
West
I think the kids Apache so yeah cowboy
works with handlers so a handler is a
module that looks like this
so it has an init function and it takes
a type which is the type that the
requests that can either be HTTP or
HTTPS and then a request which should be
a record from Erlang that cowboy uses
and then you can when you start cowboy
you can pass it some options and make it
passed as a third argument and if you
return ok request and then the third
argument the tupple is the state then
cowboy knows that the next thing you
should do is call the handle function
and the handle function takes the
requests you passed from in it and the
state you pass for a minute
and then you start doing things as a
request so in this particular example
I'm calling the reply function which
takes four arguments it takes the states
code which is 200 in this case a list of
headers that are represented as pairs
couple of two elements where's the key
and in the value a response body and
then the request and then you can return
that and there's also a terminate if you
want do any cleanup and then there's
this function we call call in the cowboy
trooper module which is compiled and
this takes a fairly simple data
structure where you've got the host and
then a list containing three tuples with
the path the handler to be used and a
list of options and this returns a more
complicated data structure which I'll
show in a second and you pass this so
Cowboys a star HCP function the first
time is just a name so I've called a HCP
in this case a number of acceptors
that's the number of concurrent handlers
for incoming requests the pour that you
want to use and then the dispatch that
we generated earlier so that's a hello
world handler what was that do have a
you can see a demo sure no problem
um so let's run the arts just off
screaming on Linux there we go so let's
run the hello world we needed a new
whole argument so that it doesn't
terminate this will be worth it when you
see the results localhost 5000 there we
go right there
so that is hello world so if you're
wondering what the compiler function
actually does it takes this data
structure which is a list of tuples that
start with hosts and you can also pass
an underscore it's a catch-all so in
this example I've got food comas the
host and I've got this path which is foo
and in a required foo ID and then bar
and then an optional bar ID and now go
to the food handler and then everything
else will go at the bat handler and when
you call that you get the second list
here which is like a list of tuples
appear it's quite complicated data
structure which is why the compile
function exists you can write out like
that on your own if you want but I'd
recommend compiling using the compile
function so slightly more complicated
example now that uses some more code
where functions so this is a handler the
will handle post requests in it's the
same and this time we're fetching the
method from the request and it returns a
pair with the method and then a new
request and we have a private function
called handle method which returns two
states code a response string and
request which will pass to the reply
function and then we check and if it's a
post request we will read the body and
if there's a name president will say
create the user and return a two or one
otherwise we'll turn a 42 and say there
was a missing parameter and for any
other method will return a 404 and say
in valid method and the method you
passed a four or five is probably more
appropriate here because that's method
not allowed but I've already I'd already
written the slides when it came to that
realization so it's a four
before and then we just passed these
argument since we got the status we have
the content type text plane the response
string and then two new lines and those
are important because if I was to demo
this then I didn't have those in it but
it up against my terminal it wouldn't
look nice
so in fact I'll show you that's a good
idea sem if i run the post example then
I curl it put request say then I get
invalid method put because that's what
we'd expect and then if I there's much
in you I see and then if I get post
request
it'll say missing name parameter and
then I can say like name equals Gary
Gary to announce they created user Gary
so again slightly more complicated
example but but nothing too too advanced
there and I've got one more example and
then I'll stop doing my silly little
examples so this is a chunked handler
this calls a different function calls
chunk reply which take the state's code
in the request and then we send a chunk
and then we wait a second we send
another chunk and we wait a second and
then we return the response so and
because I'm just ignoring the parameters
and things it's just I can do a post
request here I just need to start the
server with a chunked example and you'll
see this says hello and then world and
then chunked so yeah
chunking so that's how cowboy works in
isolation but plug normally if you're
using plug you don't write these
functions you call functions on plug
card so when using plug with the cowboy
adapter there are three modules in play
really the first one is called Kawada
adapter and it's responsible for
configuring cowboy and also starring the
server so kind of what I showed at the
bottom of all my slides with the star
HCP this module here I've taken from
plug and I've deleted all the covert
elite SSL which is most of it to make it
for the sake of example but the module
does compile and it does run plug with
cowboy so there's an HTTP function which
you use to start the server and it calls
this run function with the same
arguments so the reason doing called run
directly is because in the real version
there's an HTTP one as well which calls
run with HTTP and then the run function
checks that cowboy started and end calls
colonel to apply which allows you to
dynamically dispatch function on a
module so the modules cowboy the
function start hcp and then the ARDS
because it's Erlang Interop we need to
do a little bit of manipulation on the
arguments to get in a format that cowboy
likes so that's what this function does
so in a lexer for options we've got
keyword lists which are quite nice you
can just write the keyword call on and
then the value but in our line we don't
have this but in elixir keyword lists
are implemented as lists of pairs so
with that knowledge what's happening
here is it's looking for all tuples of
element size to and extracting those
into one variable which is your keyword
arguments and then everything else is
the non keyword arguments so that could
be just atoms on their own
if you've used our long-term storage you
folks like name table on its own
alongside keyword arguments but could be
like three tuples for tuples so on so
they're just being split and this allows
functions from the keyword module to be
applied to the the keyword options one
of which is the dispatch and this again
just calls cowboy dispatch or compile
rather and then there's default
arguments and this looks quite similar
to the the other arguments so you've got
a catch-all so it's just saying for
everything go to the the cowboy handler
and pass in the plug and the plug
options and the plug options are what
get pat gets passed in it and then
subsequently to call and the handler so
this is similar to the handlers I showed
earlier but this is for handling
requests and then taking them into plug
so this is like the entry point for a
request when using plug and it's very
similar to the handlers are showed
earlier so I'll just quickly go over it
instead of returning okay requests and
then the module name sorry okay requests
in the state we return upgrade protocol
module and this tells Kowboy that we
want to use its sub protocol feature and
most the reason we're doing this is for
error handling so you don't get the
Erlang error handling we can your own
error handler here and then we repair we
pass through a request and then the plug
options that we specified earlier and
then instead of calling the handle
function this no calls upgrade which has
this additional environment that's
passing into the second argument and we
call connection calm so connections are
module it's the adapters that cowboy.com
module and it has a con function which
returns a plug con the word cons gonna
have no meaning by the time I'm done
with this talk but that's how that works
and then it's matching to get the
request out of that so the corne
function returns of the request and then
we repair and matching this when we call
and there's a maybe send in there as
well so then maybe send
plug allows you to set a response
without sending it so maybe send says
okay you've set your response we haven't
sent it yet so we'll send it out and
then the response
prepares result okay to the environment
and that's something that cowboy deals
with and then it was the results okay so
there's one more module and then that's
kind of all there is to the plug adapter
which is the cowboy con module and this
is how functions are called in cowboy
from plug there's a behavior you need to
implement which is the plug Condor dr.
behavior it takes it has five callback
functions used to have six used to have
one for multi-part parsing for file
uploads and things that's now handled by
plug so you don't need to implement it
yourself so it makes implementing
adapters a bit easier but the five
function need to implement or send
response and file sent chunk to chunk
and read request body specifically send
response and chunk chunk and read
request body may seem familiar from the
examples I showed earlier so I don't
spend ages on this because we've seen
most the code so influenced the talk on
adapter behavior then this is the con
function which is the first thing it's
called so this is what I did when I
fetched the method using cowboy so I'm
doing the same thing I'm just doing a
few more times with other parts like
path and host there are more but I've
commented them out for the sake of the
slide but this returns a plug cons
with all these things available to you
and you'll see in there is the adapter
and specifies the module in the request
and that's relevant for the callbacks so
the same response implementation it
takes four arguments and it calls the
cowbell req reply function which is what
we called in hello world and then it
returns a three tuple a triple with okay
and then the second language the
response body which isn't used but the
cowboy adapter but is used on the tech
test adapter and that's how you're able
to assert on the response body and the
original request send file of stub it
send file is like a an optimized way by
the operating system of sending day over
a socket the implementations fairly
complicated so it would take a while to
talk about so I've stubbed it chunked
just does what I did in the chunk
example so it calls the chunk reply and
the chunk function again calls chunk and
read request body calls body so you can
see that there's actually not a huge
amount to the Interop between plug and
cowboy it's quite a shallow abstraction
phoenix is a little bit different so
phoenix uses a custom handler it doesn't
use the plug one well it kind of does it
falls back to the plug one but it has
its own handler the happens beforehand
and the way it works is in your phoenix
endpoint you use the socket macro and
then in your socket you specify
transports and iterates over all these
and builds up a you URL that'll Beor a
path it'll be like socket slash web
sockets like sockets like a long pole
and they have their own handlers and
it'll go to those first but for
everything else it just uses plug and
that's because as I mentioned earlier
plug doesn't support web sockets so
phoenix has to have its own web socket
support you can configure the handler
using the endpoint handler config so if
you want to write your own handler there
are some use cases for this one is maybe
you're writing an adapter and you want
to use a different web socket Handler so
maybe you've got an existing protocol
using web sockets and you can't use
phoenix channels a custom Handler is one
way to kind of have your own protocol in
use before it gets to the phoenix
channels part or you maybe got an
existing application in cowboy and
go there first there's another way to
configure it as well The Dispatch that
you passing can be configured in the
endpoint as well so you could also
implement it that way if you wanted but
you have to specify them all because
once you implement a custom dispatch you
then have to pass in all the defaults
the Fenix implements for you but most
people leave it as default use channels
and it defaults to the Phoenix cowboy
handler I'm not gonna show the code
because it's not super exciting but
let's talk about cowboy - so cowboy -
has been in development for a while and
it's it's gonna be released at the end
of the summer I didn't know when summer
ends so I googled it and it's the 22nd
of September ahem it didn't specify
which summer so I assume 2018 but we
know the assumptions maybe aren't good
so if you want to see all the changes in
cowboy you can watch this talk called a
tale of 2.0 Cowboys that was at the
airline user conference 2017 the links
at the bottom here it's really easy to
read yeah useful so most well many of
the changes in coyote or internal so
it's things like how it handles
processes for connections but there are
there are some external changes as well
they're quite minor in my opinion one of
the big ones is that all the options are
now mapped instead of lists of pairs and
the same with the headers as well so for
plug if you want to use an existing plug
application you're going to neat at some
point convert them from a list appears
to to a map and the same length of
dispatch that you pass in that's we pass
the map now and then there are some API
changes as well so start HTTP is gone
and if start clear instead and you see
the error is changed as well so the
number of acceptors argument which was
the second argument has been dropped
you can now configure that with ranch
instead and the same we start TLS as
well so there's star ETS has gone and
star key Isis in its place and then
other functions as well so things like
path and method the previously returned
a pair with the thing that you wanted
return them the request since there's no
side-effects on the request they now
just returned one argument which is the
path of the method or wherever is that
you're after
so that's a little bit cleaner you
keep rebinding the request and in terms
of the handler it's much cleaner as well
so before you call in it and then handle
now everything's handled everything's
done
performed in the init function which
just takes the request in state so this
is what the handle function used to look
like it's now there in it and the
difference here again is that the the
arguments are passed as a map and same
here as well so the and then the
dispatcher passes maps and if we look at
the differ
this is kind of a get slide I did a get
diff so I don't know if it counts but if
we look at the in here so the transports
gone we don't have that anymore but
other that's the same and then instead
of passing upgrade protocol module we
just pass module and cowboy says oh ok
you've passed in a module I'll call the
upgrade function on that the upgrade
functions the same and we've just
brought the transport which was actually
been ignored anyway so it doesn't really
matter so we can just call : and instead
of pretending the result
it's a map as well so we use map dot
putting you but fairly minor changes for
that particular part of the upgrade a
lot of the other changes were in the con
where we had to change the average of
the functions and things so if you want
to use cowboy to with plug there was a
fork by andrew bennett who is potato
salad of github he forked plug add
phoenix as well actually to make them
both work with cowboy and I stole this
code and we implemented as a library so
that you can use plug I use cowboy to
with plug but not after fork plug so you
can still get the changes to plug
without having to maintain your own fork
and the big difference here is when you
start plug normally you normally don't
call the star HP you normally add it to
your supervision tree and instead of
calling the cowboy child spec you call
cowboy to child spec and that will work
okay so that's cowboy too one of the
things that clarity does support is HTTP
2 so quick overview of HTTP 2 is it's a
binary protocol instead of textual so if
you curl HTTP request you'll see in
plain text the
the response but if you do whether the
age of queue requests you're gone
because it's all binary you can upgrade
from hey cheffy 1.1 to HP 2 using a
header and it supports HP and HP s but
most browsers have the requirement that
you use HP s so in plug and well in
Phoenix now when you if you go into your
config it shows you how to generate yes
the self signed certificate for
development and if you're using HP 2
features you'll want to use that and
then as header compression as well so
there's like 4 - tables that are used as
look-up tables there's a lot of common
headers and when a request comes in it
also know which ID that header is of a
fetch it from the lookup table and then
the other part of pipelining as well so
there's a persistent connection to the
server and then streams are opened up
from either the client or the server can
initiate streams as well and all handles
over happens over one connection so
Saul's head of line blocking one of the
features a lot of people interested in
from HP - server push and server push is
a way for the server to say oK you've
requested index dot HTML but I know
you're also going to need application at
CSS application not Jas logo dot PNG so
it'll just start sending these to the
client and then it's up to clients say
whoa I don't want your application or
Jas cancel that stream and it'll send a
reset stream frame and how cancel a
request so this is most used by static
assets you know you'll have the the
relevant assets on the page you want to
serve along with it and you'll serve a
push them and it uses the push promise
frame which you can read about in the
spec so if we have to implement this for
plug plug doesn't have HP - semantics so
you can use a different module called
plug got caller h2 we can implement a
push function this is very similar to
all the other functions in the callback
or in the behavior and this one calls
adaptoid up push and then in our adapter
we have a push function that takes the
requests the paths and the headers and
then convert the headers to a map
because cowboy requires the headers to
be in a map and then we can call the
cowboy request push function the cable
request push function if you
hp1 just as a no op it doesn't do
anything and if using HP to initiates a
server push the only caveat here is that
you need to call it before you start
sending any response otherwise it will
error and if we look at how we could use
it you can call plug Conda a chewed-up
push and then the the path and the
accept header so if we have a Phoenix
project we can see the page controller
that's going to use this this is
separate so this will tell you on the
page whether it's using HTTP or not I
said earlier you don't normally have to
reach for the adapter this is one case
where you can reach the adapter and pull
out the version from the map there so if
it's hp-2 then we'll set the heats to
flag to true and then we'll have a list
of assets apps ESS app GS and some
images and then we'll go over all these
and call push on them the my module is a
module that ships with plug is used for
working on the mine types of files and
one of the ways you can workout is from
the the path and it will return you know
application slash CSS or whatever the
mime type might be and then we render it
so if we have a look at what this looks
like when I run mix Phoenix server
you'll see it starts to it starts one an
HTTP and one HTTP so if we go to the
HTTP 1000 to see that the page loads in
slowly I have a plug called dial up the
just artificially slows down everything
and you'll see that the image is loaded
in and you'll see that they were all
requested here I'm going to bring up to
the inspector here and you'll see that
they were all requested individually
here and they've got their own timeline
associated with them I'll just run you
through the images quickly so so the
first image is a chart the I managed to
sneak into the talk the second image is
the book Gary Potter and the order of
the Phoenix which is the best-selling
Phoenix book available it's a really
convoluted name for the changelog but
that's that's ways here's a picture of
me Keith in a unicorn and then the final
slide
this this whole presentations actually
just being a pitch for my magic show
because you guys probably know idea how
I've done that it's witchcraft you let
me talk so if we load the same resource
over HTTP though this will be exciting
you'll see the it's the same pictures
but they load it in much faster and then
the logo comes in afterwards because it
wasn't in the server push list and it'll
says we know it's using HTTP tooks it
says at the bottom and I wouldn't lie to
you
and we also know that the assets have
been pushed because it tells us these
all say that they've been pushed so that
is a fairly simple invitation of server
push and how that works so yeah back to
the slides okay
so yeah this of that works the other
thing I want to talk about is phoenix
transports so phoenix ships with two
transports by default there is a
WebSocket transport and a polling tech
transport a long flowing transport and
these are used by Phoenix channels but
you can implement your own transports
and the way you implement the transports
you define a module that implements the
behavior which has a default config
function on it so HTTP to supports
persistent bi-directional streams which
sounds kind of like a WebSocket so
that's an ideal candidate for for a
Phoenix transport I gave this talk as a
lightning talk by the way Alex comfy you
called writing an HP adapter for Phoenix
channels and it was five minutes as you
can tell with the clock in the corner
and someone came up to me after the talk
and said Gary how do you get a clock on
your slides so I was thrilled that
someone really enjoyed my talk
I really had some key takeaways so if
you want to know how to slide to ask
clock on your slides come and talk to me
it'll be fun
all right let's look at some more code
so this is the HP to Phoenix transport
there is Phoenix Phoenix module called
transport is there for you to write your
own transports it has a connect function
which takes many arguments but the
transport function will return either ok
socket or an error and if the socket
returns has an ID present then you can
subscribe to that channel because the
hell probably the channel for the user
and then will enter a loop so the loop
has a ref on there a/c realizer so
that'll be jason or whatever
serialization format you choose and then
we saw channels and channels in verse
and that's so we can look up in either
direction so we can look up for me the
topic to paid or paid to topic and a
socket most of this code I took from the
long polling implementation so it looks
similar to that if you've seen it and
the loop function has the con in the
state and most of code at the top is to
make a unique reference right here where
says McGriff and what we're doing is
we're sending a message called read body
with a reference and a timeout and then
we're calling this on the paid that is
responsible for the connection and
cowboy doesn't have a way at the moment
to asynchronously read a body which is
why we're sending a message as long as
the time it's less than 30 sec air less
than 60 seconds it'll work so after 30
seconds this little time and send us a
message and want to continue on the loop
with a new reference so we start
received block and then there are two
messages we can receive from cowboy that
were interested in one is request body
fin which means it's the end of the
request body and the request has been
terminated the others request body no
fin which means the there's more data to
come upstream from the client to server
and either case we want to handle the
message that's came in but if it's a no
fin then we want to clear out the ref
and keep looping so you want to continue
execution the other message that you can
receive is a socket push and this comes
from Phoenix and the Phoenix sends data
from the server to the client if that
happens then we'll want to format the
reply in a way that the channel
specification accepts and then continue
looping and for everything else we just
loop when we handle an incoming message
we want to decode it using the serial
i/o specified and then we can dispatch
this is a function spelled on the
transport module as well you pass it the
message and the channels that you've got
and the socket and it'll work out
whether you need to send a message or
just just keep executing so if it's a no
reply you don't need to do anything you
can just return okay state if you get a
reply tupple with a message then you'll
want to encode a reply with the message
that came back so if you for example
call Phoenix join and you'll want to get
a reply that says Phoenix join so if you
have a Phoenix Channel
when you handle an in you can optionally
reply and if you do that'll be what goes
down you can also join a channel and if
the channels being joined you want to
add that to your local state so that you
can look it up later
so that uses this private put function
and if there's an error again you want
to tell the client why there's an error
and the important thing here is that
we're using Cober request stream body
and that's how we actually send a
message down to the client and we send
an orphan as well because we're not done
we want to keep going so I have an
example of this if I start my Phoenix
chat example this is gonna be fun where
I try and match the browser up let's
just wait
so my slides were formatted for a
different resolution than I have
available which is why I have to jiggle
things around a little bit but I think
I'm done right so I'm gonna just switch
the client to long polling mode but I
can't do that because JavaScript doesn't
work so I'll just a bit more right so
this is the Phoenix chat example that's
quite you've probably seen so I can say
browser here and then I can send
messages and they appear in the list and
then I can so I have a Phoenix channel
implementation over HTTP - I've written
a client for so the first thing we wanna
do is call start link and that'll return
a pig and we pass it the path that we're
using and then from that paid we can
open a stream which is HTTP - stream
coming from the client to the server it
gets a odd number so streams are
initiated from the client have odd
numbers and streams that are initiated
in the server have even numbers if you
do it the other way around it's it's an
error so we've got a stream and we've
got a paid we can join the channel and
then when we join the channel you'll see
that we start to get some debug
information so we have a Phoenix reply
because we've joined and we get we're
getting the pings now that's a thing and
if we also say oh my god it walks then
you'll see that that message has
appeared in the in the logs and then if
I turn the logging off because it's
annoying but the message are still
coming in is just have to turn it off
the debug logging but then what we can
do that's even more exciting is we can
send a message from the server to the
browser using HP - and it says hello
from server so that is an actual Phoenix
transport working over HTTP - I'm using
chatterbox for the client which is such
a box the he - server and client it's
implemented as a state machine so it was
fairly easy for them to build both you
may be thinking well you've said it's HP
-
how do I know you haven't just
implemented a WebSocket client because
you're probably a liar and that's that's
a fair question and to that I say that
the WebSockets are broken they don't
work at all so that's how you know the
not using WebSockets
I've probably fixed that one day so yeah
that's most well done so some some
things that we can do in the future with
with cowboy 2 and HP 2 one of the things
that Phoenix does it offers a static
path helper so Phoenix when it digests
its assets it generates a shower on them
and then that's what's used when you
download the asset but you don't know
what that is ahead of time so you use
the static path helper and then since
it's your server push you need to know
the path and then you can work out the
mime type what we could do is whenever
you call static path we could say ok you
need a static asset
let's call server push on that and then
when you load the page at a lotta
matically push all the assets if you're
using Phoenix
so that would be quite quite helpful
another thing so as I said the the range
of adapters is quite limited there is an
experimental Chatterbox adapter there is
an eli adapter and there's the cowboy
adapter that ships with it and now
there's a cowboy 2 adapter as well which
is incompatible the cowboy 1 adapter so
something that would be nice
ecto has lots of adapters and it has a
like a test suite and integration test
suite the driver developers can use and
run all the testing and Sacto and it'll
integration test them to make sure that
the adapter is compatible with actor and
the actor version so it's possible that
we could write something similar for
plug so if you're developing a plug
adapter it'll run a set of tests to make
sure that the response body sent
correctly and the status codes and
things so that's one idea I've been
toying with the other thing is when
cowboy two is released before the 22nd
of September we'll want to include this
in plug and Phoenix I'm not sure what
sort of form that's going to take yet we
may want to support both and then
eventually pull one of them out as an
external dependency so if you want to
continues in cowboy one then maybe we'll
ship
what you were default but you can
include the cowboy one adapter we may
just not do that I don't know
and then Phoenix as well Phoenix will
need some internal changes to handle the
custom Phoenix handler for the
WebSockets so I think plug will be the
easier of the two to implement but the
other thing I forgot to mention is that
there is an example Phoenix so the the
repo showed earlier with the plug to
cowboy library there's another one
called Phoenix to cowboy and that's how
you can use Phoenix with care too so
that's that's all I've got this is me
with a Jenga tower in my mouth I'd like
to just mention voice search the company
I work at they a lot of the hb2 stuff
that we were working on has come from
our own needs so a lot of the transport
for example I I built when I was working
on a feature on voice layer so yeah
thanks very much
thank you questions no not good you were
almost safe that's great thanks so it
seems like there's a small amount of
overlap between WebSockets and hasty
releases Phineas is concerned do you see
things changing in the future like maybe
Venus would use so that's a good
question
no so the heat feed to adapter you'll
probably if you were paying attention
you'll notice the the client I have on
the Left isn't actually a browser and
that's because H to support in a browser
you only get access to the features the
browser lets you have access to and you
can't get access to the the raw
underlying stream so you wouldn't be
able to do the bi-directional at least
not at the moment there are some some
protocols being developed by the G RPC
guys to kind of find a way of doing this
in the browser there's a one called wish
that they're working on but at the
moment there's no way to get access to
online stream so WebSockets are your
best option for that anyone else
from what I've read about the whole
http/2 push is the holy grail and
everybody loves it but equally the
challenge of it is how not to push all
of the assets there in cash every time
I've seen a common name that there's
another not nginx was another web server
that is quite HTTP to people it could be
but they've started doing things like
putting cookies on to try and figure out
what the client might already have so
they can push the things that you might
not have have you even started to think
about how you might I have not I know
that there is some some research going
on in the area and in terms of the
Phoenix thing where we had the stack
path helper you could like explicitly
disable one if you didn't want it to be
pushed at all but in terms of toggling
on a prayer request basis I'm not sure
the best way to handle that yeah I don't
know how you would best handle that I
mean you know who the client is so you
could maybe do it for like a single
connection but I don't know if you could
do for for subsequent connections after
the connection has been dropped anyone
else
No okay good thank you Gary thank you
[Laughter]</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>