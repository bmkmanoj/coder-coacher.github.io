<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2015 - Michal Slaski &amp; Sonny Scroggin - MongooseIM + Phoenix | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2015 - Michal Slaski &amp; Sonny Scroggin - MongooseIM + Phoenix - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2015 - Michal Slaski &amp; Sonny Scroggin - MongooseIM + Phoenix</b></h2><h5 class="post__date">2015-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/1TpK4NDEEVA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone thanks for coming so
we're going to talk about Phoenix first
and then some ways that you can use
Phoenix too and xmpp and join them
together to create some really
interesting applications so first off
Phoenix what is it it's basically a
distributed web services framework and
it's an MVC framework so if you are
familiar with MVC we have models views
and controllers it's a great way of
separating your code into nice organized
bits we borrow a lot of things from the
rails community as pretty much most of
the core contributors on the team where
we come from rails background so we take
what we like from the rails community
and trying to apply some of those things
that work really well to a web framework
in elixir so we have web sockets all
built in and bundled which is really
nice so you can take advantage of real
time events coming through your system
and one of the biggest things for
Phoenix as well as even within elixir is
that you don't get any productivity
sacrifices for performance and obviously
the reverse of that is no performance
sacrifices for productivity so we want
to provide a nice DSL for you to to work
with that makes things very productive
fast but also leveraging the Erlang
ecosystem to give you nice efficiency in
performance so I'm kind of gonna just go
through and show you how to install
everything and then break down all of
the bits and components that make up
Phoenix and how it works so you install
it you clone the the git repository CD
into the directory and just get the
dependencies compile it and then run
this command called Phoenix new and give
it a directory
which will generate your application so
what that looks like is this it creates
all the files it asks you some questions
for installing different dependencies we
have the option of installing Brunch IO
which is it's an NPM node package that
allows you to build your assets so your
static assets like Java scripts and CSS
and things like that so it's an optional
dependency but it makes building your
front-end assets really nice so next
steps would be to CD into your
application and run mix phoenix server
which will give you a nice landing page
for you to start with so of course
that's not really an application yet so
I'm going to introduce to you some
things that we have which are called
generators and generators allow you to
scaffold out an application very very
quickly this concept comes from the
rails community where you can just run
to run some commands and have the
framework generate code for you and you
can move on from there and it really
allows you to build applications very
quickly especially if you're prototyping
and you just want to get off the ground
and start running and it's also good for
people starting out who don't know you
know not really familiar with the
patterns you can generate scaffolding to
see kind of what these patterns look
like and then you can move on from there
so Phoenix ships with octo which is the
database library that is really really
awesome and so out of the box you get
mixed tasks for ecto and so one of the
first things you want to run is mix ecto
create which will actually create your
database for your application and by
default it'll just use Postgres so if
you have that installed and everything
will just work and then phoenix comes
with these different generators as well
so we have phoenix gen HTML which will
generate your model which will also
include your database migrations it'll
give you a controller your views and all
of your templates to actually have full
interaction other other things would be
just if you want to generate a model you
can do that and so forth so if we wanted
to create a blog we would create a post
model so it's a mix Phoenix Gen HTML and
we give it the model name which would be
post and then the table name which is
pluralized of the model and we give it
the properties that we want so we want a
title which defaults to a string we'd
have a body which would be of type text
and then we'd have an author ID which
would be an integer we run that and
it'll generate all the code for us and
then it gives us some nice messages to
say hey stick this in your router and
then that way it'll generate the routes
for you and then you'll run mix ecto
migrate which will actually migrate the
database so migrations this is what that
looks like for ecto this change function
when you say mix ecto migrate it
actually runs the change 0 function and
in this we have a nice DSL that allows
you to create a table so we create table
posts and we want to add these columns
here and then time stamps will
automatically generate inserted at and
updated at fields in your database and
after you migrate creates the table and
all that good stuff
and then we can run phoenix server again
and now if we go to the posts slash
posts URL we get a list of our posts
since we don't have anything yet we can
click the new button and if we fill out
the form you have a title a body and
then say we have we leave out the author
you submit the form you'll actually get
your errors on the page automatically
which are validation errors because the
author ID can't be blank since it's a
required field submitting the form again
with the appropriate stuff filled out
you'll now be redirected back to your
index page which you'll have a list of
your posts with full show edit destroy
and of course you're seeing the index
section right now so out of the box you
get really nice crud actions create read
update destroy automatically we also
ship
this this is actually provided by the
plug library which is what Phoenix is
built on top of and plug is basically a
middleware library that sits on top of
cowboy it's actually it's a webserver
kind of abstraction so you can actually
provide your own adapter for other web
servers like le or any others but right
now Cowboys the only one that we have
but we also have pretty error pages
because of that with within plug so it
gives you stacktrace right in the
browser can show you where your errors
are coming from and you can go down and
dive in and find out where you're having
problems so models models represent the
database interaction with your
application and this comes from ecto
which is a fantastic library that just
basically works with with Phoenix now so
you can tell it your your schema and you
can define validations and things like
that within these change sets but
well-well that this could probably have
its own talk on its own so we'll skip it
for now so the router the router
provides routing to from HTTP verbs and
your resources to modules that will
handle the actual business logic your
typical router looks somewhat like this
we have an awesome feature called
pipelines which pipelines allow you to
build up basically interact or
transformations of your data of your
connection that's coming in you can say
you know we have pipe pipeline browser
which automatically will say we're gonna
accept HTML which works with the accept
headers if it's not set it'll
automatically work with HTML by default
plug fetch session will actually fetch
the session information from like the
cookie and things like that and then
down here we have the scopes which so
you can say scope slash which will be
the root of your
application and you'll say pipe through
the browser pipe through the browser
means that it's going to pipe through
the pipeline that's called browser and
you can actually have multiple pipelines
if you want which is really nice because
you can really craft routes that are
only have what you really need through
your pipeline so and they really awesome
things here is we have things like this
resources so resources slash posts goes
to the post controller and then it's in
a do block we have resources comments
common controller and so that actually
allows you to have nested resources
within your router the router itself
those resources are macros and macros
allow us to at compile time generate
functions for you that will
automatically do things that in you know
will make so much easier so this up here
actually ends up turning into this these
are just the function heads themselves
but since it's at compile time at run
time the vert or line virtual machine
will just go ahead and do pattern
matching on the the function itself and
pick the right one and route you to it
so and this is another example but
actually showing you the body of what
the match function looks like so it
takes the connection and it pipes it
through different plug functions and
then it ends up calling your controller
that you specified and then pipes it
through the pipe line which in this case
was browser so so mix Phoenix top routes
will give you a list of all your route
helpers so in your application code you
can call page path and send in some
parameters and it will give you a route
specifically to your resource and gives
you the actual path and then the
callback functions and the modules and
stuff so controllers are are basically
plugs themselves plug basically comes
comes in it's and you can do stuff like
this so you can say plug find paid
which will actually call this function
down here before it actually calls the
action itself and then afterwards we
plug action explicitly to say that we
want to actually call the action that
you're you're doing so and that takes in
the connection and then some parameters
for the request and here's some more
examples of that so if you're if you're
going to want to get the index of users
you'll get it do a get request to slash
users which we'll call the index
function and that you will typically
grab all of your users out of your
database and then render them to the
page get users / ID you'll have an
actual ID that's posted into the
parameters for your call so that you can
find the ID of the user and render that
to the page so new this is would be an
action to set up a form so that people
can actually so you can create a form to
submit stuff to the create action and in
the create you're just gonna basically
take the params from the form put it
into the database and redirect back and
similarly for edit and update and then
of course delete so views and templates
views are modules that allow you to
render templates but you can also
they're just functions so templates are
actually compiled down into functions
their pre compiled so at when you when
you call them it's really just doing
string concatenation which makes it very
very fast which is nice so views serve
as the presentation layer so you can
actually put in functions in your views
to have helper functions and things like
that and this is what if you typically
can look like you can take for example
if you have a user and you have the
fields of first name and last name but
you want to use name in the view you can
use name passing in the user and it'll
just return
a concatenated first name and last name
and then you can have functions like
render index like JSON so if you have a
JSON API you don't care about rendering
HTML anymore you can just return a map
that will then end up getting serialized
into a JSON so HTML templates you can
call render from within these as well
and you pass in a dick a hash dick or
I'm sorry a keyword list of variables
that you want to be passed on into the
other template so in this case is the
form so we'll have a change set in
action and then down here we'll have a
change set in an action and also in this
case we don't
I'd never mind just thinking about
something different and then in the form
we have form helpers that help you
generate forms without having that code
a bunch of HTML so you can say form for
change set which is the model from the
database and so all of these helpers
like text input take this form object or
take this form data structure that's
passed in from the function up here and
can make different decisions on how to
represent that field which is which is
nice so so channels is something where
is kind of the the big portion of this
talk and how it all kind of works in
with X and P P so channels allow you to
route messages through your system and
by default
Phenix ships with WebSocket transport
and long polling support as well and so
channels are similar to controllers but
they're bi-directional so you can send
messages and you can also receive
messages and of course it's you keep the
socket open and it ships we ship with
Phoenix Jas which is a JavaScript client
that you would use on the front end to
set up your socket connections and
handle all of your different message
events and stuff like that so in order
to use channels you just plug it into
your router
so you'd say sock it and then you give
it some type of path that you want to
use so in this case with WS for
WebSocket and you set up a channel so
Channel and then you give it a name then
the names basically it's a is a topic
and then you can do :
subtopic and in this case we're using
asterisks and the asterisks is just a
wild-card which means that anything you
can use here any string whatever it'll
match on it and use that so we could
have for instance we could have XMPP :
lobby and only the lobby messages would
be handled by this one and maybe you
could have a separate lobby channel for
instance so and this is an example of
the the JavaScript that you can write to
set up the channels and this is the new
es6 syntax which is far better than
regular job ID really not a big
JavaScript fan so the es6 makes it a
little bit more pleasant so in this case
just really simply we're just grabbing
some metadata from the HTML
representation on the page when you
render to grab the current user and then
pass that into the socket so we have the
the socket itself and then the channel
which takes the socket and actually
tells the socket to join on a particular
channel all right sorry a topic and then
we can pass in that user so that on the
server side we can interact with it and
then we'll just set up some handlers for
instance this would be like a message
Handler and our views which would be
able to respond to different events so
we have the new message event which we
would get past a message from the server
and then we can check different
properties on it and do different things
for rendering messages so server side
the channels are somewhat like this you
create a module and you say use Phoenix
channel you have to have a join function
a joint function is what basically sets
up the socket connection and allows you
to do authorization on the channel so
you can at any time if you if you get
past in the data you can take that data
and maybe it's like a token that you've
generated and rendered something to the
page and then now the JavaScript is
using that token to pass back through
the channel to join and you can use that
to do authorization for them from in
this case I'm just doing a trivial thing
which uses a UUID of a user just for
this example and then you you can do
your business logic and I'll explain
kind of some of this other code later
when we get into the XMPP specific stuff
but and then you just need to return ok
socket which will actually set up the
the socket itself for the transport and
then in this case this has actually
changed this other Clause join clause in
if if it doesn't match then you would
just do this one here but the the return
value is now just ignore instead of this
tuple structure so and then leaving you
can also leave the socket as well and
then there's handle in which will handle
your incoming messages there's also
handle out as well but I don't use it in
this particular example so Hedwig Hedwig
is a XMPP bought that kind of framework
that I've been working on and it's built
in elixir it allows you to basically
just say hey here's here's how I need to
connect to an XMPP server give it your j
ID password and maybe some rooms that
you want to join all that kind of stuff
here's an example of that so set up my j
ID the password the nickname that i want
to use for like multi-user chat rooms a
list of rooms that i want to enter and
then some handlers then handlers are
jenn event handlers that will pick up
messages and parse them and you can put
in your business logic that you
how you want to respond so this is an
example of a handler
we have handle event when we receive a
message we're going to broadcast that on
to the topic that we had set up and that
will actually put the message back up
into the client so on the browser side
you would get a new message in your
JavaScript handle event for presence you
can handle those separately and me how
we'll probably get into some more of the
details of XMPP semantics but you can
handle different different messages this
way so the channels work with JSON data
structures you can choose different C
realizations as well but JSON by default
and we Phoenix ships with or one of the
dependencies is a JSON encoding library
called poison and it actually it has a
protocol called encoder and so the
poison encoder allows you to define
implementations for your own data
structures how you want them to actually
be encoded into JSON and so that's what
we can do here we can say poison encode
def empal poison encoder for Hedwig ji D
we pass in the ji D and then we can
actually take that and create a JSON
response that way
similarly for messages this is how I
want messages to be passed up through
JSON to the the JavaScript and even
other simple like for tuples we can
specify the tuple structure of the e XML
records that come within the XML library
that I'm using so some more details on
the channels so when we call join in
this case this is setting up Hedwig in a
channel we call a client which calls
this function which will say find or
start client and based off this user
data and then we will take the socket
that we get from
the function and we will assign the
socket a sign on the socket the client
that we get so that we can have access
to it later and then we're also give
just going to assign the user into the
socket as well and handle in just
basically uses a function called send
stanza which will send the stanza
through the Hedwig client itself so I
just go straight out TCP to the XMPP
server without any other problems so
finder start client would try to find a
current process of like a Hedwig client
that's already running in case like you
disconnected and you need it to when you
reconnect you can just find the original
client that you had before and so we can
just return the pid' and then we start
the client which takes a user spec or a
client spec which is basically that
configuration that I showed earlier so
just you specify your jabber ID enter an
identifier your password and all that
good stuff and in this case the password
we're just doing a one-time password and
using a module on like Mongoose I am has
a really cool
each ever D off HTTP off or something
like that right so you can actually call
over the wire to check on passwords and
things like that for users and so this
would just be like a one-time password
use case so a couple of different things
that you can do there's so many
different ways that you can really kind
of set up these systems and so me how
and I've been talking about all these
different use cases and scenarios and
we're trying to figure out really kind
of the best way to do this but I don't
know if there's any like one you know
best way it kind of just depends on your
situation and so in this case what I
have is I have everything running in a
single VM mongoose i am you can install
it as a dependency because it's an OTP
compliant application so I can just
installed as a dependency in my elixir
application
and set all this up in the single VM so
at some point the hedwig can actually
call directly using Erlang to talk to
the XMPP server without sending
different other messages and things so
you can do other things other than just
mess the messaging portion for the
particular client so you could like do
regice regice tration of users you could
provide a form on your web page that
allows people to sign up you know for
instance and they could type in their
you know username and a password and
then it goes and registers it directly
into the server so different things like
that there's obviously a lot of other
things you could do with it
but then also this also allows you to
interact with the internet of things and
you can have other other things
connecting via XMPP to the XMPP server
and interacting with within chat rooms
and things like that and you can have
wire up handlers that will take and
process those messages that are coming
in and do interesting things with them
so I think I have a quick demo that I
can show of this kind of in action and
I'll have to maybe not I'll just show
this real quick I just wired this up
pretty pretty quickly so that I can on
this web page I can click here and join
this this chatroom and in another tab I
have I have a head wig bot that's just
on its own it's called I call them
Alfred and Alfred just basically has
some commands that I can send to him and
so I can say things like you know I'm
I'm tired and when when people say
they're tired then Alfred says pansy so
and you can do things like say yes great
success and he'll send you a link to a
Borat video or so
thing like that saying you know great
success so those are some obviously less
useful things that you can do but you
can also do things like ask ask for help
and Alfred will give you a list of all
the things that you can do with them
some of these are actually tied into
some stuff that I set up for work where
we actually have like our staging
servers and QA servers that we can on
our team we can kind of reserve for for
each other and say like hey I'm taking
staging because I need to test this
feature and so we can actually keep all
that stuff going and of course there's
like Alfred ping so you can make sure
that he's actually online and stuff like
that which presence will give you that
and that stuff but but with that I'm
gonna pass it off to me how and he's
gonna tell us a little bit more details
about XMPP and things that you can do
with it directly
okay
let's work yep all right good yep so we
already had a short demo I would like to
first inspire you so what kind of
applications are we talking about what
is it that we will want to build in the
near future and so I borrowed some
slides from Erickson who produce a very
interesting video named the social web
of things and in this video we have an
application similar to what you just saw
presented by Sony where you have a chat
you are the landlord the owner of the
flat so you appear in this chat but also
all your things appear in this chat so
imagine if you actually log off from
your office you close down your computer
and then the things at your home they
actually realize whew David is heading
home and David is having a date in the
evening so he wants to impress the lady
so he there will be some cooking and so
oven is preparing itself and those
things they start to chat with each
other there is some gossips at house and
so Cooper top also says that all right
I'll be here in standby mode microwave
says whoo if we want to impress a guest
and probably I have this evening off
right and it continues those those
things they continue chatting as you
would do on a group shot so now the
carpet says that all right there must be
some cleaning it has been quite some
time since last cleaning cleaning so
vacuum cleaner says all right let me
just check with the electricity provider
and so that I can negotiate a good price
so it got some good price so it can use
somewhat few watts of energy to do the
vacuum cleaning and now the washing
machine says hey hey hey so we have some
cheap electricity fine I'm gonna do the
laundry
excellent do go for it
and when umbrella says oh gosh
there was the like hood of having the
rain was like you see 76% and the guy
didn't take me with him I'm still here
so what's gonna happen is probably David
will be really upset he will be wet he
will be angry that sort of things say
let cheer him up right so - sighs all
right I'm going to download his favorite
music but it's not good enough TV says
no no let's order some good game right
so some football game for tonight this
will cheer him up all right good and so
this conversation continues and
continues those things will talk to each
other this is really what is going to
happen so the challenge here is how to
make applications for home that will
help you human beings interact with your
things now we have heard the talk in the
morning the keynote talk that there is a
lot to do in this space but the value
proposition that Sony and me are trying
to bring here to the table is that
actually there are already existing
technologies that you can use which are
open source open standards proven
because they've been for like years in
the news and so you may want to actually
take your things I have quite a few with
me I for example have my Raspberry Pi I
bet that some of you have ordered
Raspberry Pi some years ago you boot it
you saw it actually this dust boot and
then you didn't really know what to do
with it right so now it's the time that
you dust it off and you start playing
with this this is really cool stuff if
this is too big then you can have one of
those Intel Edison computers this is
insanely small and it is a dual-core so
mm along SMP support is better anyway so
what I would like to say here is that if
we take what sorry described which is a
good established method of working with
web web applications we connect them
through the concept of channels to some
distributed systems like XMPP systems
that a lot of interesting interactions
can be done so the web of things that we
are going to present here is based on
XMPP on IP networks it might be that we
will not use only IP networks but for
the time being IP seems to be working
fine as I far as I can tell so HTTP
WebSocket whatever you can transmit over
IP and of course we don't warm all of
this wiring that I have here on my table
so there will be lots of different
wireless technologies Wi-Fi everybody
knows the Wi-Fi but we could also have
becomes so beacons is the Bluetooth Low
Energy
we could have also NFC stickers and it's
easy to actually well this is an NFC
sticker on my Raspberry Pi you can
actually put some data on it if you want
so before I go to some demoing I would
like to explain quickly XMPP how many of
you are familiar with XMPP already quite
a lot thank you all right I will not go
into details I would just say that this
is an open standard so you can go to the
XMPP dot org and check it out it's
secure it provides some encryption
provide some other interesting features
which make it almost spam free Network
flexible it's based on XML there were
times when XML was popular
XML is really extensible it really is so
it's not a bad thing to have XML here
and it is decentralized I think this is
like a really really good thing to have
because there are lots of different open
standards of protocols but this one is
decentralized what it means is that you
can actually feather rate between
several domains this is this is really
something cool because when I can have
my internet of being server at my home
each one of you can have your own XMPP
well server server of things at home and
some of our things can talk to each
other all right and it's proven I mean
proven as in we've been using this for
years there is lots of projects that
start as an XMPP project there are some
established software
larry's both on the server side and the
client side which is good
Mongoose a.m. is one of them Mangum is
an XMPP server implementation which has
been used already in quite a few
installations where we design it for
hammock volume so this is the focus of
Mongoose I am it's scalable so it powers
some quite large installations around
the world which have to scale to
millions of online users millions of
online users and recently we've also had
quite a lot of features which help it
work in mobile environments mobile as in
mobile network mobile phones mobile
users were always on the go but that's
that's what it is today
we would like to bring it to the next
level and this is why we are actually
teaming up with Phoenix and elixir
community to not only provide a
well-established XMPP server
implementation but to also allow people
to develop web of Things applications
which will be a mix of what we know
today as a web application and of
something that is still unknown because
not many people have built Internet of
Things applications
mangu Shyam is an open source projects
you can download it from github or from
airline solutions website and here what
I would like to present if this appears
ok it's how this could look like as
Sonny said it's not like there is one
way of doing this but I will show you
some something I have here ok something
doesn't really work well let's see
you can barely see what I have here but
that's okay I'll try to arrange those
screens right Lee
okay
what I have here you can barely see it
unfortunately but it's it's a multi-user
chat so I'm using one of Mac clients for
XMPP Adam Adium and here is a room in
which we have two people or actually one
person and one thing in the room it says
MacBook here and then it says NFC reader
and NFC reader happens to be connected
to this or Asbury pie I have here so NFC
reader if we take some NFC sticker will
send us an ID of the sticker you could
for example have this ID already saved
somewhere so that you can connect it to
some name this is for example a barrage
from one of the conference's and it goes
with a sticker you put it here and it
says me how so okay this is not rocket
science but what I'm trying to prove
here is that XMPP as a general-purpose
transportation layer which solves a lot
of different communication patterns can
help us start to experiment with
different interactions that will just
inspire you to bring new applications to
the market new web of Things
applications I have also some other toys
here for example I wanted to show you
some beacon
traffic but when you turn on beacon here
in this room there's so much traffic
going on that this is this is something
that you cannot really read so I'm gonna
skip the Bluetooth Low Energy demo and I
think I will I will conclude here if
anyone is interested in looking closer
to what we have here what things we have
on the table you are invited to join us
right after this talk there is still a
couple of minutes that we can use for
questions both me and sunny are
available for questions and I hope that
you liked it and that actually you will
start to experiment with something which
is still very unknown land thank you
yes sorry I didn't get this yeah so the
question is what XMPP really is and what
how does it help here XMPP is an open
standard for a protocol messaging
protocol and has some interesting
features like presence like Federation
or regular chat feature so it is being
used to different communication patterns
as in messengers instant messaging and
such in here what we are showing that
this is applicable not only to my human
to human communication but also human to
machine or even machine to machine
communication any other question yes
so the quick so the question is what CPU
is required and RAM were required for
this Mongoose a.m. is RAM memory bound
system it's typically not a CPU bound
system so we have seen systems with up
to 1 million tcp sessions per box per
one machine as long as ram allowing this
many sessions so this is the old good
raspberry pi with the ARM processor on
it and we can easily handle hundreds of
TCP sessions on it any other question
here to each other so the question is
how does Mongoose am compared to each
other D it's a fork of each other D some
years ago we decided to fork and it has
now like it has been developed so much
there is now a different project really
different project it has some common
road with each other D but it is
bringing some other value to the table
when each a birdie we believe that each
other DS like most feature-rich server
out there it supports almost every
extension to XMPP protocol that has been
published on XMPP dorg on the other hand
we focus on large scale custom
installations this is the main
differentiator we install it in places
like booboo grinder where they have to
run very many concurrent users any other
question is there a question or is it a
comment sorry
thank you know what we say is that there
is no one-size-fits-all in XMPP
deployments and which is precisely why
we focused at Mongoose I am team on
supporting custom installations so we
sort of we know that this is for granted
that you will not take a jeopardy or
Mongoose I am and install it out of the
box and use it as is because if as soon
as you are trying to build something
custom something bigger
not XMPP compliant necessarily you have
to customize so we don't try to support
all extensions we just support the ones
which are most popular and very scalable
for example adding some ryuk support or
other things which will help you scale
to really millions of users and will let
you customize it the way you need it so
yes users of Mongoose I am also end up
customizing Mongoose I am but hopefully
not necessarily because there is some
issues with the server per se but
because they require some custom
functionality which is not there any
other question
we have also Sonia
you're talking about on the channel side
for when you if you send a message from
the JavaScript to the channel or so I
think the you know when you use phoenix
channel there's a default that will
automatically override that but in
general you should always say you know
do a handle in with you know you know
that's your default that you don't want
to handle the message or you it's kind
of something you figure out how to do
yourself I guess so you you would want
to either ignore the message or
something like that
any other question yeah so the question
is about the generators in Phoenix and
the models
so yeah the that's all integrated
there's a dependence there's a product a
separate project that we call Phoenix
ecto that is comes by default in in a
brand new Phoenix application and those
mixed tasks get included automatically
and so you just run them run the
generators and it runs and actually
creates the model code for you
and allows you to run run that and get
the migrations and build your tables and
all that very quickly so without much
effort at all yeah yeah
so right now Hedwig is the question was
is his Hedwig integrated as a plug no
it's it's basically it's just a module
or it's an application that gives you a
client that you can pass in some
configuration and it just starts up the
TCP connection to the XMPP server and
returns you a paid that you can use to
send messages through and receive from
also so it's nothing super tightly
integrated right now it's very like just
kind of packed in there right now so
it's not like some special thing at the
moment I'm trying to work on ways to see
if I can build some kind of abstraction
that will make it even easier but as me
how was saying you know with XMPP
there's customizations that you really
have to figure out how you want to
handle certain things and so the way
that I'm building this application
allows you to put the business logic in
your web application so that message is
traveling back and forth between you
know your XMPP server and your web
server allows you to you know maybe log
certain things or filter out messages so
that they'll still go to and through the
XMPP server but on your application side
you can really kind of do whatever you
want to with the messages that are
coming through
now you have another cushion I was just
wondering how so there's a lot of
scaffolding
so the question is about generating new
our application scaffolds right now it's
we have the HTML scaffold but we have
talks about allowing kind of a JSON
scaffolding which will basically not
render or not create the template files
themselves so right now if you just want
JSON you can just either do the model
portion yourself and then add the
controller and then your views or you
can run the scaffold for HTML and then
just delete the templates but at some
point probably very here in the near
future we're gonna have its separated so
that you can actually choose which kind
of style you want to go with which is
pretty nice I guess and then when you're
generating JSON you can just use the
view itself to create your maps to be
serialized into a JSON object
I think it is already put the past we
need to ask us to take a plan so I guess
I think we're out of time but yeah maybe
we can talk about it afterwards</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>