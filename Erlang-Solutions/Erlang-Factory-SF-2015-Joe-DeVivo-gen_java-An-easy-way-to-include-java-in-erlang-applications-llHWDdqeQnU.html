<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2015 - Joe DeVivo - gen_java:  An easy way to include java in erlang applications | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2015 - Joe DeVivo - gen_java:  An easy way to include java in erlang applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2015 - Joe DeVivo - gen_java:  An easy way to include java in erlang applications</b></h2><h5 class="post__date">2015-03-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/llHWDdqeQnU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is jen java easy java for early I'm
gonna make sure I stand over here so I
don't get blinded by that thing every
time I think it's tough all right i'm
joe devivo i work at the chef and you
can actually go to this site right now
this whole deck is going to be up there
right now is you be a lot of source code
in here if you want to read along there
they're also github link so you can see
things in their proper context if you
choose but pay attention to me um so so
yeah I'm uh I did this in org mode on
emag so if the slides get a lot crazy
just you know forgive me yeah I want to
get my cred there so I writer laying at
Jeff I used to write a lot of Java and
those things are coming together right
now when i started at chef i worked on
the analytics team and our analytics
platform is a stream processing of all
data that flows through chef server and
it's used on clusters of up to I think
it's 40,000 those that they got this
number wrong and that's fine it doesn't
matter it's big is the point it sends
alerts to various endpoints when various
things happen on a chef server various
endpoints like HipChat smtp and web host
and more events coming soon like really
soon like come to chef comp next week
and learn more if you want to know more
about this by my configuration madman
management infrastructure you can get it
at chef taio there's analytics
documentation all of these links are
live links on the HTML version of this
that i linked to earlier so you'll get
there eventually so yes come to chef
conference next week I'll be there so
our pipeline for the analytic server we
called the Alaska Pipeline it's a storm
pipeline and Alaska has pipelines and
this is a pipeline so we called it
Alaska because we're very clever people
and what you do is you wind up running
rules for this pipeline and here's an
example of one and it's you know it's
pretty straightforward it just make sure
that you're compliant your PCI compliant
and viewer you can't telnet into this
machine in your infrastructure out there
which is good you want to know that and
this is a complicated set of things that
says that if we're listening app or 23
email security team at financial corp so
great so we have to parse this thing in
order to know what to do with it and so
we have this
Alaska rules antler grammar and it's
based on this complex event parse
processing language that you can find
more about at these two locations but we
don't really to go into that now because
that's not what this talking about so
what this talk is about is our is our
configuration of this system these rules
and how to set them and we have this
Erlang stack for that we use Erlang web
machine and squirrel to manage the
configuration of the pipeline and we
want to validate these rules and we had
this antler parser but Dave loves
writing parsers and Dave's in charge of
the project so he gave us the Alaska
rules project in the ER last controls
project was like the ER line version of
Alaska rules and it was a neotoma parser
and the important thing you need to know
about neotoma and antler is that they
are different so we had to write two
grammars and elastin rules only ever
validated that syntax it never actually
parts them and Lasker rules is compiler
and that code actually rides up running
in the pipeline so we're parsing these
rules in two different ways but the
Alaska rules was easy at first and we
just had this little case statement
inside our malformed request callback in
web machine and that's great because
it's easy we just send this thing in it
tells us is this thing working yes or no
you know return uh I don't know I want
to say malformed request if it's wrong
Sean will correct me though so is the
problem is there a problem here well
this worked fine at first but every
change to the grammar wound up being
duplicated in two places and every time
we had to add features just you just
kept creating more work for ourselves
and it didn't even matter because we
never actually got one hundred percent
compatibility between the languages
there were a couple of edge cases where
like one things that it was valid and
one thing said it wasn't so what if we
could just use the antler grammar in
Java that would be I mean we already
have the code it's what's correct about
the the rule anyway it's it's what we
want to actually know is this thing
going to be validated by our antler
grammar if we did this we cut our work
in half which was sad for Dave because
that was one less parser he gets to
write so the easy thing which we just
use this antler wrap it up in a static
main function and you know pipe it out
to poor command and call it a day but
uh I didn't want that was that was too
much I've seen those go bad before so
back when i was at bosch oh i did the
react jmx plugin and that that uses j
interface and does some stuff and you
know has a gin server and it monitors it
and monitors the poor that's running the
JVM and that I remember being a pretty
sound solution but it was way too
specific to the problem at hand so let's
let's make a generic and then I thought
well if I'm making this generic anyway
I'd love to sort of obfuscate the job
apart and just like I mean if you got a
right to me job you got a ride from Java
but then hide it inside the Erlang and
then you know basically will hide it
with parse transform later and you won't
even know you're using Java which is
fantastic and I decided to want to do
that with an RPC call actually use the
RPC module to talk to Java so gender
face is a thing that we've had in inner
line forever it's been here longer than
I've been using Erlang so as far as I'm
concerned it's always has been there and
I'm just I'm sorry it understands the
concept of nodes and EPMD and Erlang
data types and process messages which is
uh which is great it's a lot of building
blocks that we can have to build an
actual interop layer and you can see
more about j interface here the user
guide the javadocs actually really
important for writing your own gin Java
functions so good thing that link is
here for your use later but there's no
RPC but I do know a few things about our
PC already coming into this problem and
that that and that's that they're
managed by this gents our walk I don't
know it's a gin server yet it's managed
by this process called Rix it's a
globally registered process and it
stands for remote execute or or remote
execution process or whatever so I go
grubbing through the code base of Erlang
and i find it deep in RPC girl actually
the the define is right at the top but
deep in do call somewhere like many many
lines in I can't see you again see the
link 344 lines in you'll actually see
this do call function and this thing is
doing a gin server call to the Rex
process on node node with this request
object that's a mystery to me and a
timeout which I know because it's jen
server call so let's keep digging what's
this request looks like well that do
call phone
Jin is called by call and this is call
which all does is wrap it up into a
different kind of payload so RPC call we
all know that it's meat hooks basic
arguments are node and then MFA right
module function and arguments so what
we're doing is we're taking MFA and
we're wrapping in this tupple putting
call on the front putting group leader
on the back so we can do some I oh we're
not actually gonna do any i/o so don't
worry about that and that's it so it's
wrapped in this five temple now so this
so yeah so if you want to dig into the
source of do call there's a link right
here there's some RBC magic in that we
don't need to worry about what we care
about is that calls Jen server call
there's some cool stuff with monitors
and trapping ages and stuff go read the
code it's interesting not for us not now
so this what that request topple looks
like we just pulled it out of RBC call
and it's this call Adam module function
arguments and the group leader pin but
there's more why wouldn't there be more
so let's dig into Jen server call Jen
server call will take this request
object and it will call Jen call with it
and Jen call likes is actually this uh
for argument here look I can highlight
the line because horde mode and acts and
awesome so so yes we've got this jen
call dollars Adam because Jen call is
money we got this room we got this
request the here and that request thing
coming in from the call which is that
five couple that we just talked about
before that it yeah so we come over here
and then Jen call actually deep in gen
call you've got this erlang send and
look at that look at that request it's
just a little part of it but this whole
line what you're going to highlight
again because I can this couple is this
label this self mrf and then request and
this whole thing is the actual process
message that's going over the pipe so
that's what's that's what's actually
going out on an RPC call this three
topple with a five temple inside and
here I lined up the entire stack trace
for you and I tried to line up the
arguments you can see how this thing
just sort of bloats as we go so you know
RBC call is just no to mfa and then
obviously do call wraps it in that tub
bowl and then this thing make sure that
it's going over to Rex on the node you
want
and money gen call then this self MF
thing and then this big Erlang thing is
the thing that's actually getting sent
over the wire which is great because now
we know that so yeah Jen calls the first
bit that's getting sent over the wire
the second thing is a pig mrf double and
the pig you know that's just from we all
know from we love from mrf is our return
address we're asking a bunch of
questions over the wire we're going to
get a bunch of answers what's the answer
what is this the answer to and where
it's going to tell us and then this
request which we've already seen and
we're all friends with now so great
knowing is half the battle we know
what's coming over the wire so let's set
up Jabba to listen to it now Java gives
us this Jenner face thing which gives us
this node so we create this note object
wrapped it up in a little main function
lets you specify the name of the node
and cookie in stuff like that we create
the mailbox rex because we know Rex is
the thing that RPC call is looking for
and then this while loop just kicks
around and receives messages and puts
them out on the console it's the
simplest OTP node ever so let's
deserialize this message this this three
tupple this little itty bitty three
tupple that we could pattern match and
be done with in java no this is just the
part that makes sure it's a three temple
and if it's not we throw an exception is
its java and then if that first element
is jen call money that's great and if
it's not exception then the second
element in that trouble is it this to
tumble is this to topple a kid rebel if
not exception now we check that last
five temple this is the one we're really
excited about and if you notice when we
see that the charity is not five on this
element we're throwing an erlang remote
exception instead because the Erlang
remote exception is this thing that
we've created which actually can send
back error tuples to Erlang we've gotten
far enough deciphering this RPC call
message we've got the from Pig we've got
the MRF so we know how to send a reply
why not send a bad RPC message back
instead
explain what went wrong and then we
validate the mfa and we do lots of casts
because why would this be easy and I
mean this this is you know this is a 65
line constructor just just wear like a
one case that pattern match would have
done but you know the life I chose so
here's my error message here's my
exception class it actually has a to
Earl an exception which just creates
error topol so we can send back over the
wire and creating an airline couple in
Java is also annoying because you have
to create a list of objects and then you
have to actually populate that list and
then you have to create a new tupple and
then stick the list in there so you know
when you're used to ER lying this is
terrible but java guys probably like oh
wow four lines only that's fantastic so
this uh this exception we actually
constructed it with the MRF and the pit
in it so it's got this send method and
all you need to do is pop a mailbox in
there and it's the Rex mailbox in this
case and it will actually send we create
that we send it back to OTB so we create
this Erlang object and this is creating
what the response looks like the
response is back to Java is this other
temple which is the ref that we talked
about before I'm sorry the response back
to Erlang is this ref that we talked
about before and then this reply which
in this case happens to be the error
tube will just error in the string that
the error message is so we wrap it up in
this OTP Erlang object list populate it
make the tupple and what we wind up
sending back is a top bowl of mrf error
whatever and we send it and it goes but
sometimes not this slide is mostly an
artifact for for the HTML people but
since you're here we already talked
about it so then when we do this
constructor for this incoming RPC call
what's happening is that's it we just
catch the two different types of
exception if it's the airline remote
exception we send it back to Erlang if
it's not we dump it out to the console
and on the Erlang side we're monitoring
the console through the port command so
we'll be able to put this in our logs
anyway if this doesn't work out let's go
back over there now and check that out
so the gin Java module
gen server it kicks off this a jar of
your choosing in the you know with the
port command and when you build that jar
you include gin java jar file so what's
the gin job of jar file well let's talk
about the gin java project for a second
this is on my github there's links in
the talk obviously it's got to source
trees source main java and source main
Erlang and one builds a jar that goes up
to maven central and 11 bits of rebar
dependency so you can pull them both
into whatever projects you use here yes
so we do that so we start the gym
javaserver you open a port running on
your jar and you've made this jar and
you've included by jen java jar and your
jar and you're using well well get to
what you're using later so what we've
got here is a basic start up for this
this is in Mayan it of my gin java gin
server and what it does is it
essentially just keeps asking this java
serve job node what's your name what's
your name what's your name what's your
name what's your name and it's gonna
keep saying bad RBC bad RPC about
oversee until one day it doesn't and
when it does it when it doesn't it's
going to say well here's my name and I
know what your name is cuz I just named
you like three lines up in the internet
call so because that was the command
line argument to my main method right so
then when that happens we actually can
call we can link to this process we can
do a set up a monitor we'd set up a call
back and we've you know we've been
fetching name all the time but we
finally have made fetch happen so that's
actually animated it'll be animated on
the HTML deck I couldn't I couldn't
animate gifts in Emacs there's only so
much man a single man can do so this
handshake yet this explains what the
heck did we do the RPC call for node we
do a link we do a monitor we do this in
it call back this init call back is
something that sets up state on the JVM
side so if we want to make RPC calls
over to Java and that Java process
happen to need some initialization may
be read in a file or something
hypothetically then this init callback
will actually do that and then this
error log this is the handle info of my
gin server and all it does is it looks
for the port that's running the JVM
and it matches this data tupple and then
it spits it out to lager so anything
that comes out on the Java system
console it's coming out in your locker
logs so you don't have to look in like
many places for this stuff it's all
there so yeah so now we're sending RPC
calls to java node we can send error
messages back and they can come over as
either console messages or RPC responses
so what about actual RPC calls I mean
this would be pretty stupid if all I
could do was send error messages back
well the easy way is to hard-code son
and I hard-coded these six because
Erlang node and Erlang link you've
already seen me do RPC calls to these in
my hand shake so I have to have them and
Erlang absolute values just sort of my
proof of concept method that i could do
java absolute value and send the answer
back and then I did some Java inspection
stuff which is really cool so like Java
system properties can just come back as
a prop list for you if you're interested
in dumping that at the beginning your
logs or whatever so what is this Java
module I made it up I have a Java class
in Java Java it's fantastic but let's uh
let's let's I think we get to that maybe
two more slides in so let's talk about
Java functions that you're making
yourself I kind of use methods and
their methods in Java but by the time we
get through with them they're going to
be functions because they all have to be
public static final they also have the
arguments and return type specified by
Jana face these are defining your
Haskell I mean yeah sorry that's forward
right these are defining all of your
Java your Erlang types in Java and
Erlang those have a interface knows how
to send them back over the wire it's a
job reflection is it's been expensive
we're going to actually cash these
method objects as we find them so how do
we do that well we create this method
cash and it's got this Erlang function
cash k thing and that's essentially our
MFA from before right it's our module
function and our type signature of the
the input arguments for the function the
return type is actually not involved
here and it's that Java varargs thing so
this absolute value the thing takes one
argument it's an OTP Erlang double aight
actually create two signatures for this
one for long and one for double because
it can send both across the wire and I
want to answer the same question
with both data types so basically now if
I ask for our PC Erlang abs and I pass
it a double it's going to find this
method from Earl in class and it's going
to run it for me if I pass it along
it'll run that one which is bad because
I can make them behave differently and
that would be but I have to be a good
job for remember to don't I so here's my
job at that job of module no it's not
it's the RBC cash for it and it's just
these simple things that I'm doing you
know I've created these three functions
that they're all rappers for Erlang data
types for java functions and here's java
java here system properties as an
example you see it's annoying stuff I
have to do to all the doing all this
typecast but the meat of this thing is
right here system get properties and the
rest I just iterate through and are
basically creating a prop list which
eventually gets returned here and that
looks like this I connect to my job a
node and I run system properties and
sometimes they look like little single
quoted atoms and sometimes they don't
because so we render things but yeah
that's Java system properties so what
about your own methods your module is
going to be your full java class name
package and all the function is going to
be the method name and the are just
going to be a list of argument types and
you should know what they are because
you wrote the function and then we just
go into the cache and looking for them
when a message comes in via our PC and
we've already processed it using all our
casting and Erlang tuples and stuff like
that then we pull it out of the cash and
then we tell the message oh you want to
write execute this method and then we
throw it over to the pool otherwise it's
not in the cache so we try and find it
if we find it put it in the cache set
the method on the object and put that in
the pool otherwise it didn't work and
send bad RPC we need to send bad RPC
well I got scroll down a little bit look
at that that too bad RPC we've all seen
that right I built it with Java so i can
answer bad RPC calls when you don't have
when you have an undefined function i
actually send it back and say that's not
as a fine function this this link is to
that java function and it's really long
because you remember how annoying it was
to build 12 bulletin like four lines of
Java look how nested this tuple is it
was a nightmare but you know it's always
the same so why not I you just did it
one day and so the payoff here is that
reflection is only two months for method
now we talked about the pool right
that's what we're aiming for what we
want to do is we want to just do multi
threading on this thing in case you know
we ask it hard questions we don't want
to bottleneck the whole thing and just
have one big line of processes waiting
for messages to come back so we just a
job some Java connection pooling and
each message has this run method that
just kind of you know does a method run
invoke and if it works then that's great
this is our result otherwise we catch an
exception and we do this error rapper
thing which I thought was going to be on
the slide but it's not but guess what it
does irritable Aaron string send it back
this sends the result you know the
result might be the exception output
might be the method invocation it might
be the OTP or lying Adam null probably
won't be and then that's it but now
we've got to wrap up this response
because you know we can send things back
to the front page and then we're
wrapping this response but the wrapping
the response well this looks familiar
doesn't it clearly repeating my code
here and I'm gonna have to go back and
refactor this but I didn't want to do it
before the talks I already had all my
links below my line numbers hard coded
so I'll do it later and this end make
sure to send it to the right place wrap
response is grabbing our firm ref from
before so we know where it's going back
to and then send it back so what's the
Erlang developer experience actually
look like well you might remember I'm a
little crazy about user experience and
if not go check out my cuddle fish stuff
this is all your Java module really has
to look like your module is whatever you
want to call it and throw this parse
transform on top then you can figure
this thing Jen Java can have multiple
modules in your projects so you have a
list of modules this one is my java this
is where you find the jar and that's how
many thread you want that's it the
Erlang server node thing is all part of
the gen java jar so it all knows
what package at all knows what package
to use and everything like that you want
to start it up you can start it up with
start link or this slice little child
child child spec weird startling come
from it's it's all in the parts
transform guys so here's an example of
one of the things we do it's a rapper 45
Jen Java functions the first one is call
actually I thought I'd do it more
complicated example so i did call here
but what you can do here is just say my
java call then give it your package name
your function name and your list of
arguments and you'll get a response and
what can your response can be anything
your heart desires i guess so you five
functions for free here what do you get
you get a start length start call call
stop and all they do is take these gents
or functions that we already know and
love and we just sub our module name
into all of them because i didn't want
you to have to type your module name all
the time but that's it that's all it
does I thought it would be very
convenient for everyone see there we go
and then so you can throw your in a call
back in here this is the this is the
thing that actually runs that state
initialization stuff and I'll show you a
real world example that in a minute and
then you could read convenience wrappers
which I really like and I do this all
the time first of all I gave you that
dialyzer type for bad RPC so you can do
your own you could say this is what I
want to return but I can also return a
bunch of stuff that Jen Java will try
and return and then you can just create
your method create your arguments and
then wrap it in this call to your you
know your module and function and
everything and then this is what your
use case looks like this is this is what
the program actually does when they're
trying to call java so that's that's
pretty I think hope so let's bring it
back to my analytics problem at hand or
less per rules the neotoma parser is out
and Alaska rules jars end we set up our
system fade to have some parallel
threads and to point at our alaska rules
jar which includes the gin java jar and
here's our module is just declares the
module it's got the parts transform a
couple of functions so you got the valid
rule function which jen has a couple
types of can return including bad RBC
and it calls our chef analytics rules
Erlang
validator which is a rapper with OTB
types for our actual rule validator
function we have another kazem called
google groups which is more than one
group at parses a little differently but
it's the same general idea and then we
have our okay here are those funky row
those functions on the Java side right
there very simple this class has some
state which includes the compiler that's
been initialized once and just lives in
memory and then we you know we'll take
the binary in will turn into a string
will partial through the antler parser
and then we'll send back an answer and
the answer cannot either be can either
be yeah that's great or nope here's an
error string it actually gives you like
a meaningful your rule did not parse at
line 12 v 0 character 17 so that's
that's great now on if you notice our
rule before it had sunlight it describes
some events in chef and some attribute
of those events and those relationships
we actually have described in some JSON
schemas so this R in it callback will
actually send over the jason schemas
over to the java node and it will load
them into the rule compiler before we
actually accept any RPC calls all right
to bring it back to web machine now I
can use my Alaska rules Jen Java module
call this valid rule group function get
the rule out of the web machine request
state and then see if it's good if it's
good great this mallet request is not
malformed if it's an error we're to send
back an error message that's actually
going to be some sort of essentially
error toppling JSON that goes back to
the UI and the you I said you know nice
cute little red like text at the top oh
my god your rule is a little bad but you
can just tweak it and we love you so
much so just do this one thing for us
and then if that and then if you know
java is broken them you know it's a
server-side error we're just going to
stop the activate all right so wrapping
it all up this is just a wrapper um all
or lengthen the really hard stuff for me
it gave me all these nodes and classes
and stuff I just dropped it in the gen
server that monitors it and integrates
it really well and put it to parse
transform around it so we forget it's
Java but that made the project easy
didn't have to make it easy I wanted to
kind of prove that I could do this that
this wasn't limited to like a
a thing and I've meaning to learn some
Haskell and it always seems really
really hard so I figured if I can make
this work in Haskell then I can make
mocon any language so I'm going to give
you the source here to my attempt at
that the Erlang Haskell interface odot
to y 0 da too because ODOT one existed
Erlang gave me no Haskell but somebody
did I mean it was somebody eight years
ago and it doesn't work anymore but
there was something there so I went and
looked at it and here's what I actually
got out of it somebody made me a data
types for Erlang so I used them there
were these packaging functions for like
putting bikes and stuff on the wire so i
used those two and they gave me half a
protocol it looks like what they were
trying to do was implement a way for
Haskell to send requests over to Erlang
and I wanted to do the opposite so it
looked like they didn't bother doing
that other side of the protocol so I
that was my goal it used this nano md5
dependency which no longer works oh I
had to replace that with pure md5 which
wasn't which wasn't that bad knees
extent documentation isn't great it
could have been me that was the problem
that could have been operator error
there so I tried to spin up an erlang
note in Haskell and this is what i did
and i'm gonna walk you through that
right now I've got this creates elf
thing which does that same thing that we
were doing essentially with our main
function before we're creating this node
and we're just gonna sort of listen
there and then you know we've got this
mailbox that we're listening for
messages on where to start writing those
messages there's a lot of forking or see
a lot of 4 kayo here and then I got my
little Rex mailbox down here to actually
listening for Rex requests in theory
let's see if it actually does anything
well this creates elf thing it's going
to run these two functions basically
this serve and self and they notice down
there there's also a little create
mailbox for net colonel because if net
Colonel's not running that you can't
ping the box for camping the box that
you can't do anything so there's this
serve function and that thing connects
the EPMD and opens up a listener and
then puts messages in an mbox let's talk
about EPMD
here are some great links that you can
read and when you read them and realize
it like I took like a week off at
Christmas time for my name you know from
my family to read these documentation
you're gonna feel a little bad for me
but what any PMD does is it reserves eep
induce it's there and it reserves ports
tells you what airline knows are
listening where and what it does is it
it sends this message over which is
basically the same always except for the
port I can do this which port it's
reserving this usually the same as an
erlang node tcp/ip this hasn't changed
since our six I guess just doing that
what you will this is how long the node
name is is the no damn and that other
stuff we didn't even use thinking like
chess remember and you're like kidding
you play chess and you move the piece
but you like wasn't sure you're going to
move the piece so you just left your
finger on it that's EPMD you move the
piece and you're like yeah I'm gonna be
poured 65 well I can't be 65 but like
maybe six four three two one is hold it
there and this socket stays open forever
just letting you know on that port it's
not open on that port it's just talking
about that port if you close that poor
if you close that socket the port is no
longer reserved so what's that look like
well Wireshark apparently understands
EPMD which is fantastic look at that
we've got a we've sent our little signal
and we get to the live to request and
there's the port number and there's what
it's good where it's going to fantastic
my little high school node name there
look at it in the bytes there it's
fantastic it answers looking at a live
to response there's my answer it's a lot
more gibberish e but I'll take it it's
an answer meant to understood the
question right so here's what we do it
in haskell right we've got this little
put putting on that thing that you just
throw these little attributes on to it
this is the port number this is the tag
of the message this is the version stuff
like that and it goes and then you keep
the socket open forever this is really
difficult to get that working actually
but it they work now so yeah so that's
just that that's just EPMD now the two
Erlang nodes have to
talk to each other and they've got this
little song and dance that they do here
where I you know what's your name oh
that's a great name this is my name oh
well that's great are you ready for a
challenge yes I am ready for a challenge
Oh what's your cookie oh well we don't
really know each other that well so you
know eventually we you know we tiptoe
around it and like you know 18 months
later we're married and this is an
example of one of the package that comes
over that um so yeah so this is a short
way of saying that it opens up so that
sir function right it opens up a socket
on port X then once that port is open it
knows what X is so tells EPMD yeah sure
i'm open on this port and then it does
the distributor lang you know Buffalo to
step and then it you know it eventually
winds up just receiving messages on that
socket it's open from for dispatch
what's that well we'll get to that first
but i'll show you the i'll show you the
house club does that so this is the
serve and it opens the socket and then
it sends the alive to requests which of
course has to be a fork because that's
stay open forever and can't do anything
else and then we have to create this m
bar which is just a place where we store
a state for this connection and then we
process requests well what's process
requests this we see here we just read
stuff in off the socket every time we
smell something coming in and we just
send it off to process messages which is
cool because process message is just
sets up a send and receive buffer and
just starts pulling information and
sending it back and that's it in this
Earl connect thing here this is the this
is the handshake you know back and forth
thing that eventually winds up giving us
a to and from you know pipes to send
information over the socket and then we
then now that we are connected we
actually tell the state of the whole
self node that we are connected so great
so no to see what does this thing do
well it just sort of sits there and
listens for stuff and sometimes it's
just a heartbeat it does nothing and
other times it puts this Earl dispatch
tubule thing on the outbox what's this
Earl dispatch tuple thing well it's it's
this this is the distributed Erlang like
middle syntax here and there's like you
know to maybe 13 different things you
can send we're only interested really in
number two and number six which are
registered send an actual send send is
just to a paid registered sentence to a
named pin name kid like bricks so maybe
six is the one really care
so we have this self thing which is
dispatching all these things the
dispatch call comes in here and that's
the pattern here and then we say well is
this thing on number two I left out a
bunch of this because it's like a really
long okay statement but is it number two
yes then we look our pin mailbox and we
send a message over the number six all
right we'll send it all will send it
over to that pad instead but these pins
are all little empires that are taking
information off some high school thing I
didn't quite understand but it works so
I just backed away so there we go and
then here's the net connected note that
just manages the state of what nodes are
connected so that net kernel of my last
we opened up this one was really easy we
just sit here at anytime anything comes
in we go yep which is the answer I want
from paying and I never got another
question for Mexican at Colonel so this
made it work again so what's an RPC call
receive by haskell look like well if I'm
in the ER lang syne they send RPC calls
to this haskell node would you look at
that gen call money Earl tupple pit ref
Earl temple call module function args
Earl pig that's group leader this we're
familiar in familiar territory i'm
actually getting a message that i
understand from my java days which seems
so far away and while they were met
there were manual labor but it was easy
to understand so yes and I have this Rex
mailbox handler and this thing I can
just do this pattern match that puts
together this temple and understands the
pigs and the refs and everything and I
can start hard coding functions that I
need from my handshake right like
remember Erlang node nothing well here
it is and it just um Haskell doesn't
like when I something about the IP
address so we have to manually add it
over here it's fine this is not very
brittle but you know what it works every
answer to every other RPC call here is
going to be just haskell equals various
um well I'm almost done so yeah notice
that mr. doing Haskell equals very yes
for everything I'm just excited it's
working there's plenty more to do is
there anything more on the slide don't
know like gin Haskell oh my god did this
yesterday because I got the idea and I
thought maybe I could pull it off before
the thing and i did so here's a github
link very yes
Jen Haskell which is a pretty much a
copy paste of gin Java only where the
port command starts if spins up this
Haskell process instead of the Java
process so I mean the idea is we could
even make gin you know underscore
asterisk language and just set up the
callback for the poor command but that's
that's even further in the future work
so yeah and it works look I created this
RBC test app which you can also see and
has two dependencies Jen Java and jen
Haskell and I can start it up here and
it starts up Java look at those look at
those output getting caught by the you
know by the output of my java and my
Haskell here we go and then we get down
to our console and I could say my java
call Erlang node and it goes great there
it is it's got this gob convoluted name
because I do it as an underside is a
combination of the gin Java and the
module name that we created and the app
that we created so that would be unique
it looks and I can do for Haskell too
and it creates the gin Haskell my
Haskell RBC tests the node and they
answer that question correctly so I
tried you know sending Haskell my call
about Erlang node one an erlang notice
undefined so it's just going to say
Haskell equals very yes because it says
that to everything and then the javab
one just says we do try our line node 1
and her line node 1 comes over and it
goes yeah I don't know what to do with
that but I'm Java so here's a
classcastexception and then I get out of
here and look it tries to send Rex a
stop message to shut down java goes
great i'm going to shut down and Haskell
goes you didn't implement that yet so
this ghd process goes rogue and kills my
computer so this is all supposed to be
an animated gif and you can see that on
the thing but since we are done now I'm
going to quit out i'm going to open it
so you can actually see my demo if and
then we'll be done and then I we can
answer questions of so we're going to do
open index HTML there it is that looks
terrible because I'm not connected to
the internet but the important thing is
this animated gif which I'm going to
open in a new tab so you can see it
there it is and look I'm opening up EPMD
in debug mode and we are starting up an
erlang node and you see EPMD debug mode
is saying all this cool
stuff about what messages it got and
then you see over here in the Haskell be
i'm going to start this Haskell process
down here and it's going to register
with UPMC look at that whoa there's my
Haskell node it's this demo of this
contrived Emmett was fantastic i can
just narrate it and then over here i'm
gonna start asking questions about
something maybe i'm gonna try and ping
the haskell node look I did and there's
some output about what message of
pattern matched and this codes all on
gate up for you to play with there's
tons of links in this thing so you can
go to Joe to viacom / GF 2015 and check
out all my source my slides and stuff
like that and you know throw tomatoes on
me on Twitter or something or you know
we can talk more languages if you want
Thanks yeah um yeah yes they yes they do
like I said Dave loves parsers and he
was head sad to see his go but um but he
was glad that he didn't have to maintain
the two grammars to the end of the day
she has lots of other work to do but you
know once I made this Java thing and got
taking care of that I realized I was
working too much java so i switched
teams now I right or lying on chef
server all day anybody else yeah you yes
we talked earlier what
Oh fantastic yeah um so I wrote Haskell
for one week ever um this was my not
only excuse to learn Haskell but to
prove that if I could do it and ask why
I could probably do it and other things
too but yeah that's that's fantastic
John Hughes yeah yes everybody John you
just told me that would be awesome if I
can make one side look like cloud
Haskell one side look like her lying RPC
calls and absolutely would that be
fantastic so um yeah I saw cloud Haskell
about two years ago and I know it wasn't
ready for prime time then but I wasn't
even ready for like ground Haskell then
so now that now that I'm sort of
tiptoeing into a school I'm gonna y'all
get read ravers show me cloud Haskell
and make me feel like you knows
everything again all right um we good on
time yeah it seems about right all right
get anything else anyone um so it is a
lot do you mean the java stuff the
Haskell stuff everything ok so the java
stuff i got to do as part of my day job
but also sort of like interspersed
through other things so it's harder for
me to quantify like how much time that
took especially because we tiptoed
around it took us a while to sort of
discover that we didn't want to use the
native calma parser and then we did a
really bare bones version of this that
wasn't generic at all that just spun up
a Java server inside the Alaska rules
jar and did all this you know did all
this stuff very hard coded and then you
know once that was done we naira fide it
in genera fiying that i would say took
under a week but it was getting to that
point that was probably you know took
maybe a month or so you know off and on
the Haskell stuff out there was other on
the other hand was very time box
um I had a week and if I couldn't you
know we had I to we I two weeks off for
for winter break you know the first week
had Christmas in in the second week my
wife said you know I'll watch the kids
you just you know if you get this done
by hurling factory would be amazing so
you know no mad mad props my wife for
that was right there and yeah so that
took it took a week I I had this thing
sort of ping-pong and back and forth
friday around noon and i was pretty
excited about it and then some of these
other the gin Haskell stuff the the app
that we did that last sort of console
trace from that thing took well it
didn't exist before I got here so um a
couple hours India yeah yes so far it's
gotten everything we need like you know
we're running analytics on you know
systems with worry about 40,000 nodes
and it's now granted it's not a
high-traffic part of the analytics
pipeline right this thing's getting
events all the time and it's you know
it's routing them and everything but
those rules are already compiled and in
storm this thing just validates rules
when somebody in the UI changes the text
and like you know hit submit to web
machine so I don't know if we've really
pushed this as hard as we could Casey
oh you know I um we talked about was it
s / I think I don't know you know that
those decisions are above my pay grade
um I just wanted to write her lying they
said they want to do it in storm so Dave
went did the storm and I did this all
right it was that next language I don't
know well that will that like so the
biggest problem with the high school
thing right now is like if I leave it
running for too long and starts paying
into cpu so maybe fix that before I it
works it doesn't work well yeah sure I
now we've got a we've got to give web
machine some love next that'll probably
be the next project all right guys stick
a fork in me I'm done</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>