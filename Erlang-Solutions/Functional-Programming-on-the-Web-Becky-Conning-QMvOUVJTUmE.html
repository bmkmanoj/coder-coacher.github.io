<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional Programming on the Web - Becky Conning | Coder Coacher - Coaching Coders</title><meta content="Functional Programming on the Web - Becky Conning - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Functional Programming on the Web - Becky Conning</b></h2><h5 class="post__date">2015-11-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QMvOUVJTUmE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi um I'd like to and as it and also I'm
going to go out the project exits right
right and I just like to start by
thanking Francisco don't know if you're
in the room for taking my spot yesterday
and I arrived a few days ago and have
been horribly sick in my room stairs and
the Ibis ever since day hopefully it
won't affect the talk too much but I'm
alive and standing and according to my
doctor not contagious so you're all very
safe and but yeah that's a greatly
appreciated because I don't think I
could have done this tomorrow let's see
if we can doing that so my name is Becky
conning I'm an application developer
from Sam data we're a company that tries
to take analyzing data visually and
bring it to anyone regardless of where
their data is coming from whether it's
coming from MongoDB or a spa or elastic
search or Twitter and an or so
regardless of whether or not you have a
IT budget or a degree in data science
and the way we do that is we use
functional programming both on the back
and the front ends and so to start off
with I think that um within software
development web technologies get a
pretty bad rap it's sort of quite
divided between people who look to the
future and say everything will be in a
browser in 10 years time and people will
say well that's just kind of going to
die out or at least I don't like it or I
don't think it's very good but web
technologies are actually a really great
solution and the hop has provide the
latest features of our patients to
people as soon as they're ready no
pestering people for updates no people
running old versions that were no longer
supporting and that has its pros and
cons but it certainly has its pros and
be able to allow you to provide the same
features across multiple different
platforms and devices and provide
familiar sort of interaction
for everything from navigation to
uploads to notifications and requesting
location filling in providing
information using a form and even
buttons and and there's I mean the
buttons great right we think you know we
just need a button out of the box and we
need it to work on 20 different
platforms and across this entire
cooperations entire and every single
computer in that cooperation and we can
do that but actually once and I was
damaged something to her clients and
they told me are the buttons rubbish and
I'm like what you're talking about it's
a button it's just a button it's being
the same forever and they certainly kind
of swiped it across the screen and I
said well it's not going to work if you
do that but the app was a taxi booking
appt and as they said all the punters
are drunk so we did this we instrumented
it and we worked out that actually and
we made a better button for that
specific scenario we actually worked out
that that there were loads loads of
sales of taxis have just wouldn't have
happened if that button hadn't been
changed from the default one so that's
another interesting thing is that it
allows you to define these custom
interactions quite easily and right so
it also puts your features on on a level
with features of millions of other
applications whether you're a global you
know International Cooperation he's
trying to put your features on the same
level as some cool indie startup or some
indie starts at trying to you all are
accessed by the same web browser and
emotionally there's a big difference
between downloading an application and
visiting a website and again Liz pros
and cons we tend to see more unique
Hughes
on the web and less return use on the
way we see more more more interaction
over time on native apps as opposed to
on the web and it's you know it's proven
in every sector that from social gaming
to banking to medical but the way that
we provide features with web
technologies is very more complicated
when I started out in my career and it
was quite standard to lock up the entire
user interface recompute it and then
send it back up again and that worked
quite well that was then that was quite
a simple thing to do he had some
endpoint that you would send some data
to some use would book a taxi or order a
pizza or leave a message for someone and
then we'd make some changes to the real
world or request some data from outside
of our application and then we'd
recompute the user interface and send it
back up to them and over time and we
don't we don't really want to do that
anymore and we want everything that
we're presenting to someone really to be
the latest not the last time you press
refresh but latest possible that they
can get right now or if they're just
gone under a tunnel then instead of Oh
couldn't reach the thing just some
friendly reassuring message that says
you're under a tunnel
sorry um
but we don't really want to do any of
this ourselves and at least for
front-end developers we tend not to want
to do this we want stripe to handle our
payments and we want firebase or or
hoodie or the backend team to handle
storing and retrieving information and
letting us know when that information
has changed and what we want to focus on
is wrapping these up things all these
different effects and different ways of
changing the world up into engaging
features which people can use features
that produce value for someone and I'd
hope one of the people getting value out
of that situation would be the person
using the feature and although in the
case of betting applications that's not
always the case and but the problem with
this approach is that it requires us to
carefully reeve together all these
different requests the information and
to change things from outside of our
program that could be fulfilled any time
along with user inputs that could happen
at any time and that's complicated and
you know basically you have well
beforehand you wouldn't your code when
he could even not be correct you could
have memory leaks in your JavaScript
that's going on to serve it doesn't
matter that users going to refresh in a
few seconds or quits or a new page so we
have to have increased correctness of
our code as well but and but sorry I'm a
bit from next and
so how did we achieve this through
achieve this in JavaScript with
callbacks and which were great because
they made the problem solvable we could
at least make something that seemed to
work but we all know what happened with
callbacks even if we wrote our call
backs out explicitly as as functions
with references and we still had the
issue of from it not doing what we
wanted it to or a callback being called
more than once and essentially what was
happening is we had too much power we
were we had this callback that we were
allowed to call more than once even
though it was required of our
application to for it to keep running
correctly and do what we actually want
to see for it only be called once and
you'd have it bug that capsule coming
back repeatedly like the Facebook they
give the example of vm the messages box
saying you've got a message when you
have it and that being deeply
disappointing for that users and that
was caused by similar sorts of issues
and so we tasked you know you have bug
bug reports come in you have a look at
the program and try and work out what
went wrong so that's when you realize
that there that when you're approaching
these problems with these procedural
languages you you kind of have three
different things you or even procedural
approaches mostly you have three things
you have the source of the program which
details a machine that hopefully
produces the features that you want and
then you have the features that you
actually want themselves as experienced
by you and the users and then third you
have / developer a model of how the
application should work and there is not
really a one-to-one mapping between
these things and it's very hard to tell
what your application is actually trying
to do in each specific moment so
so
right so basically the problem comes
from the fact that from a lack of
abstraction and we are and when I talk
to people about friends who run
consultancies and things like that about
functional programming and functional
paradigms and what they do use and what
they don't use they often say I said why
don't you why don't you use more at this
stuff and they say because our
developers aren't clever enough and I
was like okay well that's first of all
that's bit insulting and secondly and
instead of trusting your developers to
learn how to use abstractions that have
been provided for them and that have
been well tested and proven over time
you are trusting these people that you
don't think the clever enough to do that
to write custom data structures and
custom control structures every day all
the time writing I equals 0 and looping
over things and all of this you know and
for example so you have a stock price
that is on an end point of the server
and you give an update sequence achieve
that so you say this is the 46 stock
price change today and and you go up to
and you see you um
you get some initial value from the
server you constructor URL / of it a
long pole on that URL wait for a
response and then produce a new URL
using some value from that response to
Repole server and this is a pattern that
like happens a lot where you were just
trying to get some things sequentially
from a set but like programs only move
in certain ways this is one pattern of
how you might get information from
somewhere but repeatedly this is written
custom for not just each application but
each end points in each application and
and and so I understand the fears of
people who say who worry about
extracting too early but when the
abstractions already been provided for
you in that example we have a library
called and sequential FK routines in in
Pierre script that will do that for you
and the barriers entry is on a lot lower
and so
so what we're trying to do is we're
trying to give up responsibility towards
these um to these things you're trying
to put it on to someone else's back and
stand on the shoulders of giants and
learning to use and these are valuable
abstractions instead of designing her
own and control structures
so one of the ways that we try and
abstract / building interfaces for the
web and building application features is
T and use a Model View controller and
and and similar paradigms and frameworks
and and that's that's brilliant for
small applications and if you are trying
to do something extremely simple and
then then then that's probably probably
actually going to be faster but it
doesn't scale particularly well because
for every set of models speeds and
controllers that you have those are
interacting with each other and they can
all change the state of each other via
each other and so at any point in time
you don't know what the state of one
specific thing is and and so so anyway
that some of these for example an
angular they provide a promises
implementation and who's familiar with
promises in yeah so basically your
promises is flipping the thing with the
callbacks on its head it's basically
saying instead of you providing a
callback for a thing what we'll do is
give you a call back and you tell us one
thing that you're doing is done and then
the information will be passed down and
the
it's it's it's a way of abstracting over
a piece of information that you don't
have yet you have a value which which
you can pass around and then you can
provide with another function and you
take your promise and the function and
and and the function that you've
designed and then you see in that
function that you've designed you act as
if you've got the thing as an argument
and then you you can chain these
together by repeatedly using vents and
do this go get this thing from the
server then mess with it a bit and then
do this other thing and and yeah so
sorry I'm suddenly feeling more hell
than I was before and so and then
there's also reacts jrs and other sort
of reactive programming paradigms which
i always think covers promises that can
be fulfilled more than once essentially
you now have a provider function instead
of that function being called only once
for when you've got the value it can be
called repeatedly so you can have some
emitter that allows you to repeatedly
expose these this new information to
whatever you want and you get some nice
better ways of combining these together
you can sort of sample one from another
from an Ender so
and so coming back to that model view
controller situation so and and any sort
of direct Dom manipulation because if
you make if you make a change to the DA
yourself then you then have to keep that
in your mind and write all of your code
keeping in mind the fact that you've
written to the Dom but there's nothing
to say that you've done that there's no
there's no context which you are within
to do that so and as I said you have to
keep this idea of like if if you do this
and then this and the Miss then it works
but if you go under a tunnel when you do
this then it doesn't work but but when
we haven't done that it said it the
offline mode worked perfectly fine so so
what's going on here and basically
what's happening is that we've with
we've lost confidence in our code we can
fix the issues the sort of symptoms of
this problem but we can't address the
the underlying issue which is that code
is fragile and so and so we use promises
and we use a reactive programming
paradigm switch and and and over time I
found that these that I kept some coming
across problems I couldn't solve right
that I kept on having issues with
applications that i was developing and
and whenever that happened it seemed to
be that the abstraction that came along
and helped me out had its roots and
functional programming and so that seems
like promises and reactive programming
but but there's a problem there is that
you might say okay go go get this thing
from the server and then do this other
stuff right but the problem is that that
other stuff is normally coming out of
that context now so you say go go get
this item from the server and
change this model that's outside of this
context to be something else too as soon
as you've done that you've lost control
we've lost composability you've lost the
ability to talk about to reason about
this this process and as I wrote more
and more JavaScript and I I wanted
absolutely everything to be in a promise
and then I came across reactive
programming and plug it and libraries
and I started to do you everything
inside of that and then I would show it
to someone else like and they would be
like why's that that's like just lying
noise what it's it's pretty confusing
and i'd say i would say i was saying you
know it's it's more readable it's just
it's just less familiar and to a certain
extent i was right but with JavaScript
you can only get up to a certain point
of composability and things before it
actually starts being more difficult
than not there are things that are
better to do procedurally in JavaScript
than they are to do and then they are to
do functionally if you're writing in
JavaScript the brick you can bring all
of this stuff up to a point and then to
a bit then it becomes actually harder to
read so at this point I was like well
these good things are coming from
functional programming so I should check
that out and there are a few still being
invested in the web web technologies and
I I wanted to sit with something like
compile to JavaScript and there a range
of options and a really brilliant one is
called Elm which uses functional
reactive programming and to create a
graph and four values travel along and
then be rendering the user interface
based on on the
and but it's and it's and it's really
good but it didn't do everything I
wanted to do I couldn't get that
sequential polling stuff working in
there and I also couldn't that it also
seemed quite difficult to compose
together one Alma program that I'd
written and another one it was sort of
felt a lot easier to to write it all in
one big project which seemed like maybe
a group of fragility to meet so i kept
going and i looked at a bunch of every
option so they came across pierre script
and i only started learning this stuff
about a year ago and but and and and i
think that i think a lot of people so
you here in this room has learned a
functional programming language oh wow
okay I wasn't expecting that and okay so
I who for humans from was functional
programming at first their first
language or depew everyone learned oh
that's run the back so and for most
people functional programming is
terribly scary it's like learning a song
on a piano and then channel and you play
that song add new when your friends can
move or wherever and then suddenly
someone puts a piano referee it says
play something different you're like no
I can only can even play that one teeth
and so you might sit down and try and
learn another tune but you sort of get
frustrated yeah I can I could do I could
play something satisfying that there
isn't this so why should I bother with
it and so I think a big part of
functional programming is really keeping
your confidence and just sticking with
it so that you can learn these new
paradigms and and get used to it so what
so what what is it about functional
programming that we want and we want
directness we want a declarative pneus
and we want purity so by purity we mean
that there that there's only an input
output there are no indirect inputs or
outputs and that simplifies everything
because we come back to that point for
about chains of promises where you have
you do one thing and you get thing from
a server and then send it up to another
server and then then you've got the
value so then to get something some
other information that's based on the
first request and then you then you want
to update your data model using the
second result of the thing that's that's
fine up to that point because as soon as
you got at this point you're using the
result of that one inside of this piece
of code only this is going this dot then
and then what you want to do with it
that was the only place where you were
dealing with that front with that
information but then because because you
can in JavaScript you move out of that
context and you create an effect
external to it which isn't which isn't
an abstracted or recorded or or or what
happens hot inside of the inside of the
promised chain and
so that's where functional programming
using a more pure language is a great
thing because i used javascript in a
functional pattern for a very long time
and i was very i was very happy with it
and i was actually running a team at the
time and code reviews for painful
because to me there's all this stuff in
javascript that that seems like dirty
like i should stay away from it like
it's dangerous like a mutable state
essentially and and i found that to them
it looked like gold and they were just
rolling around in it and and and and
they they adored it and that's fine like
I'm not here to say that I'm somehow
better than these people that's not the
case functional programming isn't better
than you and you shouldn't stop your
project and restart it in in Pierre
scripts much you're really really
running into issues and related to these
sorts of things in general like it's
it's just another approach which many of
us like and it has a load of positives
and but I I started training myself just
wanting wishing i could turn off those
features off turn off the musical say
make sure everything is a Conte them of
a bit so we develop all these best
practices in JavaScript and we have to
keep them in our minds all times and and
and but but why bother when we can move
into an environment that that only
allows better these best practices at
your pointer and doesn't let a new hire
do something that you don't necessarily
want them to like changing meets both
state and
so is everyone in the room comfortable
with the concept of a peer function I
put your hands up if you're not
comfortable with pure function
so purity is great and apart from it
doesn't really do anything on its own
you have to change something in the real
world eventually you have to print
something to the screen or get some
response from your user so with so you
need to have you need to be able to make
these changes and and and request and
and be able to abstract over them so
those two things seem to be at odds with
each other and but something so i'll
introduce a pier script a bit more so
pure script so pure script is a non lazy
haskell that compiles to JavaScript and
it doesn't have any runtime and it just
creates really basic just JavaScript
that can run anywhere and um and it
looks a lot like Haskell
so let me find an example here so this
is a this is an application that i wrote
the other day it's a bit messy and but
because I've been ill and I plan to tidy
up that I haven't had a chance but
essentially if you look at this function
here this is a pure function right it's
very simple have if if the we're using
pattern matching so if people aren't
familiar with that here we're saying
that the search is a function from a
string to an array of contacts to
another array of contacts so these are
the two arguments and that's the return
type and we have searched and if we if
we are searching for the empty string
then we just give back whatever we are
given so we make no a change to the
input that we're given and then after
that with if otherwise we filter it by
the by predicate so whatever array were
given we filter it by this predicate and
then down here all we do is make sure
that if we put them both into lower case
make sure that one the second one
contains the first one so we can see
that and doing its thing here oh we have
to create some contacts list
so um and then
so um so if I type in David here and
what what I only have David and as such
so this is doing that but it can't do
that on its own it can't this isn't
actually changing anything so if there's
something wrong with this with this
function if our search is is acting in
correctly if then we can look at just
this one place and discern it without it
being affected by anything else in the
world which is great like being able to
reason about your coding these small
reusable blocks is so so so useful and
and and gem and it really helps me sleep
at night behind this it's a case of them
you can you can really reason about you
things easily however it again it
doesn't it doesn't do anything so so how
can we do something that does something
like in the real world what we do is we
we use a foreign function interface so
the idea is that you write some
functions in some other language and
then you provide types for those so that
you can reason about them afterwards
it's your responsibility to get those
types right and and I have come across
errors where I've downloaded a library
and gotten the wrong thing back because
the wrong thing is in the library and
but you know that was quite a long time
ago a hat that was the one time and I
saw it but it does happen and and a
functional areas and you know this sort
of programming isn't without its flaws
but essentially here's an example where
we've defined just a common jas module
very simple common J's module that just
has two functions which are basically
just exposing the get item and set item
of of the window dot local storage thing
now you can make this function better by
making by providing the window some
other way such
if this code is run on something that
doesn't have a window you can probably
an alternative implementation or have it
inside of some contacts but for this
example it's very simply exposing this
and thing and then we provide some types
to those so here we're saying that a gat
is a function that takes a string and
then gives you a subrange
my way okay even if this is wrong it
gives you an effect it returns a string
so it gives you a context and which we
can see here we have the row of a fat
types as well in this case we define
this up here and you actually apply them
to them yourself such that if a function
if a context doesn't support this then
you kind of say when you're defining a
function what affects you want it to
support for some added safety and but
essentially and then the other one it
takes a string and another string and it
gives you back an effect of unit which
is basically like we don't care what the
result is we just need some value and
then those can be can be used for
example here every do set and actually
his brain ism sec on a set contacts and
then we can just provide and an array
here look at this okay yes how are using
it and and so anyway sorry actually
we're using up here so then this is the
this is the the basic things that's just
returning very simple things and then
we're using up here with a library that
helps us to decode Jason and and and to
do some fancy things such that we can
then serialized deserialize information
and but sorry I know I'm feeling a bit
queasy but I'm fine to carry on but and
I know it hasn't been so great so far
but does anyone have any questions at
this point
oh sorry sure so the we can see here the
inside of inside of this function we're
returning we've kareem it so that we can
actually be carry these things but I've
heard it for simplicity and then the
last one is a function that takes
nothing and that's because we don't want
this to be computed and when we ever
white if we didn't do that when we ran
this we get the result immediately what
you want to do is get the result at some
point in the future and so here we're
saying get get the local storage with
this key and then pass that to the json
parser so this bind here is everyone
who's familiar with bind ok it's not
everyone so basically this is a
genericized and you can make a dot then
of promises out of this and essentially
what this is doing is it's saying this
function on this side and is to be
passed the value that comes out of this
context when it's available and and then
at the end you can see it says pure and
that simply says rewrap it back up in
the effect type and again we're using a
nexus were and know how to screw it
we've got a for all f at the start here
and then at the end and we've got this
um this f here
which says that we can also accept any
other effect so if we're working in a
context that it's doing other things we
can we can we can allow that we don't
have to just have local storage and in
fact you don't necessarily mean to use
local storage if you have if you have an
effect in here it doesn't throw an error
if you don't use it it's just showing
you what is available and and if we try
to use something else in here and that
wasn't local storage like Dom or OEM
console or whatever and then it wouldn't
refer an error because you have to
explicitly say and what what you're
doing but then this F here is sort of
like they get and they get kind of
nested inside of each other and then
flattened out so you can put any other
thing that does any other effect into
into there and so so
so coming back to that point from
earlier about about reproducing the user
interface every time a user does
something right rear end during the
entire user interface and well it turns
out that was a really good idea it might
not have quite done what we wanted to do
but it was really simple because we
basically defined a language for
interacting with our application that
was the API of our application the HTTP
API and then our and then we are we had
our interface provide those torque in
that language back to us using
hyperlinks and forms and and and send
and post requests using its food for us
and then we would rear enter the user
interfaces pass ups then recently
there's been like a resurgence in the
Sun in this approach but on inside of
the FAFSA and so I don't know how many
of you are familiar with things like
react and virtual Dom and put your hands
up if you're not familiar with the
concept of a virtual Dom okay cool so
okay I can talk about this so basically
instead of using the real actual to life
effect for Dom you know actually we're
actually going to change this this
buttons to David and directly instead of
doing that we'll have some data
structure which represents our document
object model so we might have a list or
we might have some custom date structure
or a tree or something which says this
is our user interface and then we make
changes to that we have functions which
which fear functions which when they're
given some input from state will then
produce this virtual model of a brand
new user interface right but that's no
use because if you were to then just
take that and map it one to one to the
thing again you'd be locking up the user
interface
you'd be chucking away all sorts of
values and it would be off it would be
like it'd be worse than refreshing but
instead of doing that you have a library
or some other abstraction which takes
the last representation that you gave it
and the new one and dips them and then
produces just the operations that are
needed to make those specific changes
and it turns out that can actually be
more performant in many cases than than
doing it the other way and it certainly
reduces the complexity of the situation
because you can start afresh from your
perspective your sauce as a developer
writing applications using these things
you're starting from scratch every
single time you're just rear ender in
user interface so reactors really really
really great and it's like to have a
whole bunch of it's just fun to bring a
whole bunch of really good things to the
industry and but and but it is it still
has all of the problems that of being in
a procedural language even as a sort of
functional type and paradigm and I have
to really okay and so anyway I will oh
if I knew it only had that long i think
so i'll show you an example of this here
so here we go we've got em so this is a
halogen okay so this is sort of the
Perth Krypton to react and flux mix
together and and essentially you have
these components that you can put
together so in this example there's a
render function here and we're using
pattern matching here to do to say if
this if we're editing this contact this
should really be called edit edit and
sorry component a contacts component if
we're editing then show the Edit
interface otherwise
this has just show the cancel button so
you can go back or no only what does it
say render cancel okay I wrote that
wrong it should be render present but it
basically it says we Iver edit it or we
present it when we present it we're just
showing some fields and when we're we're
just showing some some values and when
we're heading then we're presenting text
fields and and you can you can see that
and actually so it is we're not editing
and here we're editing and and then a
core part of this is why wire this is an
why this is like so and you'll notice
that when those render these render
things all have they output component
HTML edit queries edit query is now the
language that we use as if we were
talking to a back-end server but to talk
to ourselves to then change our state
and then we rerender so we can see here
this is all the things that the compact
the contact component can do and see
that it can be done it can go back
cancel edit contacts and change the name
to these three things we have a very
explicit thing who are doing this with
the back end this is what we'd be doing
as well and so we can happen render a
representation of some HTML which of
some user interface which has some query
inside of it and some query language
such you can talk to yourself and make
changes to yourself which allows you to
be I was going to do a demo but I've got
like minus one minute left and I should
have just done the demo and the yeah
which allows you to make these changes
and then just one last thing that the
nice thing about this is that you can
doing this in this specific thing is
that you have this thing called SWAT but
allows you to slot in another component
so you can write these components to be
reusable and use them inside of each
other
and you provide sort of a route for
these queries to go down children can't
query their parents but parents can
observe queries that evaluated by their
children in a in an abstraction that
prevents infinite loops and sorry that I
was ill and I'm perfectly happy to
answer any questions on my free time
afterwards and and thank you very much
for sticking with me
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>