<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tailflow - An Openflow Controller Framework - Torbjörn Törnkvist | Coder Coacher - Coaching Coders</title><meta content="Tailflow - An Openflow Controller Framework - Torbjörn Törnkvist - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Tailflow - An Openflow Controller Framework - Torbjörn Törnkvist</b></h2><h5 class="post__date">2013-05-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ug5grhyCAuU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right thank you so
great fantastic so my name is student
and restore Toby topic for short so I'm
gonna talk a little bit about open flow
and the work I've been doing in that
area the recent months
it's called Tate flow so I'm working for
a company called Calif founded 2005 and
I only been working at for one year now
so but it's run by a lot of my old
buddies from from back from Arizona so I
know them quite well they have two
products called MCS and confident and I
would mention them a little bit because
the whole work can be doing is is
supposed to fit into these kind of those
two products that they are producing
lots of customers operators and
manufacturers all over the world so sort
of two parts I have to set up the scene
a little bit so I'm going to talk a
little bit about SDM and what that is
and what I think it is and where
OpenFlow fit in to SDM and then I'm
going to dive in to tell you a little
bit more explicit to show you how it
works etc so network management I won't
talk that much about network management
but network management every one of you
probably know or have a feeling for what
network management is you manage your
network sort of and it's kind of tedious
work where you have to work with sea
lice etc - - and four large operators
that often is a very costly costly sort
of way way of of implementing new
services because you have to do lots of
manual work in worst case and worst case
is often in the normal case whereas as I
have been told so I'm not in in I'm not
coming from the network engineering side
I'm coming from the software engineering
side so but I want to talk a little bit
about not this traditional view but
network management with a twist solo but
what was important to realize is that
network management normally requires
lots of tedious manual work which is
very error-prone
I mean imagine if you have a if you're a
large operator and you you have a
customer that wants to a new VPN leg for
example you have to set it up and that
might be realized by manipulating a
couple of a number of network devices
etc and if you get something wrong you
have to sort of go back and find where
there were and etc and it's all a very
costly process and so that's where Sdn
comes in because when you have a very
complex system like a large operator you
have a huge network very complex and in
general when you deal with software
which is very complex you sort of try to
cope with that complexity in some way
and the normal approach is to abstract
in some way so if you have this huge
complex system you sort of can take a
bird's-eye view point for example to
outline a couple of large components and
how they sort of our connected and
interact to each other and then you can
you can zoom in on one on the components
and then some of the other sub
components appears within that component
so you have various layers of
abstractions to be able to cope with
that kind of complexity so what if you
could do that for for for network
management that you could abstract and
at the network sort of itself and to be
able to apply sort of modern software
engineering technique to that kind of
problem the answer of course as I think
is yes because as I going to show you on
the next slide we can actually do that
but the result of that is that we can
reduce time to deployment when you for
example add this new kind of service
like this new beeping like for example
and in the end that what it all boils
down to is to reduce costs so here is a
sort of a jam-packed slide but what it
shows this is the telev product called
NCS up here controlling a number of
network device
firewalls switches routers etc from
various kind of manufacturers so by
introducing a kind of abstract model of
each of that each of those devices how
they work you can actually start doing
interesting things if you have a way of
modeling that you can represent it as
data structures for example and it has
not manipulating them and doing
interesting things so and that's exactly
what what we are doing at Alif so the
way we are modeling things is by using a
modeling language called yang which
makes it possible to model those kind of
network devices we can bring them into
our system and represent them internally
in various kinds of data structures to
make it possible to for example manage a
number of heterogeneous network elements
as one single homogeneous system so that
you can manipulate many of those devices
in one consistent way and by
representing stuff like this as data
structures you can starting to do things
which is sort of normal when you come
from software engineering side for
example cancer auto render see lies you
can you can introduce concepts like
transactions for example so that we can
actually introduce changes into the
network as on a transactional basis the
other product that tell if is doing is
producing is called comedy and that's
actually a thing that you can put on a
network device so southbound from down
from the from the comedy you can have
lots of hooks which you can integrate
into your product your your network
device and describing that device with
this model makes it possible for County
to to auto render like network
management api's northbound like that
Kampf
or sea lice or resting faces us etc so
down here we have Network elements
device devices and up here we can
control them in a consistent way so that
that's the way we are using the
abstraction to to apply that onto this
complex world down here but we can take
that kind of abstraction to yet another
level which we have done with this
product
MCS so we can introduce something called
a service model so for example this VPN
leg that as mentioned we can represent
that thing that service as a model so we
can have that model the service model
for for the victim service then by
adding some kind of mapping logic we can
actually take that service break it down
in the end we sort of spit out all the
kind of operation commands that needs to
be done on all those devices to set up
this new service and when I started
reading about Sdn I thought Sdn has been
so the DC world with which has come up
quite so the recent and become very hot
I thought but we have been doing that
for quite a while now and but we didn't
call it just down but this is really
what I think is SDM how we by using
abstraction and software engineering
techniques can get a whole log of the
complexity of complex network
environment so so for me as a program
it's very easy to get get excited I all
right I can program the network so I
need to put that we slide up just to
remind myself at least that it's not
really about the program in the network
it's the services the network services
that we want a program that's the
important thing because that's what what
makes the revenue at the end so so now
let's see what overflow is returned
which are related to SDM and for me
a router or firewall is a sort of a
pizza box you buy on the shelf somewhere
and it's sort of to my imagination at
least to consist of some hardware and
some software that controls that
hardware and if you move that software
outside of the box and then you figure
out sort of a protocol so that this
software can talk to the hardware then
you have open flow because that's what's
open flow is open flow is a protocol
from this software to control this so
the general hardware thing and the soft
trained open flow terminology is called
an open flow controller so how does it
work the hardware's very simple is sort
of like a forwarding table as we heard
the previous speaker talked about a
little bit so like ether packets is
coming in to the hardware switch like
that and the hardware looks up in the
forwarding table what am I supposed to
do with this packet it tries to match
sort of the packet various kind of
packet headers in the in the protocols
does this coming in from from Ethernet
for example you try to match that and
then you try to figure out what to do
for example send it out and another port
in the switch so if you don't find
anything in your forwarding table what
you're gonna do well you have to ask
someone and you're gonna ask you
controller your software what am I gonna
do with this packet and the software is
gonna figure out that okay it's a Eitan
packet who's gonna go to a certain
source address so let's send it out on
that port so it's gonna tell the
hardware send it out to that port and it
can also install a flow describing this
kind of operation into the hardware so
that the next similar packet won't have
to go up to the controller because it it
makes use of the existing flow and trend
and sort of finds its way out so so
that's basically the essence of open
flow so this is just a little bit more
detail about the matching so so this is
sort of
a sketch of how a flow table entry look
like so you can match when Packers come
in you can match on this or the English
port of the switch you can match on the
ethernet source destination address the
IP source does TCP UDP ports and some
other stuff like VLAN tags and stuff and
when you find a match connected to that
flow entry also have a set of actions
what you're going to do with this packet
so for example you can say that I want
to send out this this packet on a
certain port or I can say that hey I
want to rewrite some of the headers here
I want to rewrite the ethernet source
address and then send it out some pork
or I might say that hey this packet this
shouldn't be allowed to continue through
this switch sign it's gonna drop it no
actions at all yes just drop it on the
floor so that basically how it works but
to me who comes from Taylor where we
deal with this network management
problem I want to be able to manage this
kind of device to me it's just a device
and open flow application is just
another device in the network which has
to be able to live and coexist with
other kind of traditional network
devices so I mean you have this
management interfaces in app kampf SNMP
sea lice for those traditional network
elements but if you write some kind of
open flow application to me it's also
just another device that needs to be
managed either through the software in
some way or perhaps you should put some
of the management straight on the
OpenFlow protocol level it needs to be
managed so to me open flow is it's a
component understand it's not it's not
Sdn it's open flow is not the same as
then it's a component of a stammers
aside as I see it so so that's that's
how Sdn and open flow related to each
other in my mind so when I started to
look into this I wanted to figure out
how we can deal with open flow devices
for open flow applications so I started
to well
read up on the protocol of course and
try to figure out how to do it and
started to experiment with implementing
sort of simple program a program
programmer patch panels some simple load
balancers and stuff but it was it is all
very low-level looked on the protocol
level so it's like assembler sort of
those flow state table entries that
you're sending down to the hardware so
actually structured that the software
was was made a problem that I wanted to
to be able to manage it I have had to
sort of come up with some idea of how
the software could be structured and I
try to find information on on the map
and most of the examples sort of stopped
with a trivial learning switches on from
them and you were on your own so I
couldn't really find any approaches on
how to on architectures for how to write
open flow applications there were some
research papers that I found out about
but not much and for me it was also very
important how to do management network
management of those kind of systems in a
sort of consistent way so the open flow
controller that the actual software from
its point of view the the the switch
just generates lots of events not lot of
events like sort of perhaps 10 10 events
or oh and the most common one of course
is is when a packet don't match any
entry in the flow table down in hardware
then you get this packet in event from
the switch to the controller and you
have to act upon that but you can have
other kinds of events for example when a
new switch connects to the controller
you have this data path join amount or
when a flow times out in the hardware
because every flow flow is is attached
with a time timer then you can get an
event or hey this flow empty timed out
and has been removed so you can act upon
that so there are a couple of others
events too but
what you want to do when this packet
empties is to apply some kind of logic
onto this kind of event
t2 to create some kind of reaction it
might be that you want to drop the other
thing or but you need to act upon that
event so so is when I broke my small
experiments so I usually I I was
thinking in a functional programming way
where I sort of tried to my solving the
problem I always sort of sort of solve a
little piece and then put the rest of
the problem down into the next function
and then you sort of continue like that
to abstract this sort of problem in
various layers but after a while I was
started to think about a some
experiments I did for like 15 20 years
ago when I was still at Seijas lab very
soon because at that time it was kind of
a research topic around something called
micro protocols so Cornell for example
they had a market protocol framework
called Horrors and they were actually a
book written called computer networks by
Peterson and Davy which described the
Xcode which also was a sort of market
protocol framework and the basic idea
was that normally you have those kind of
huge large protocols like TCP well IP
etc but instead try and break out sort
of a minimum sort of amount of logic
that makes sense for example you could
you could think of sliding window as one
little piece of a protocol a market
protocol you could think of a
fragmentation or reassembly fragment for
a fragmented package as one sort of
microphone and put them in a graph and
that as a whole forms your sort of
protocol so I did some experiments
around that for 15 20 years ago and I
started to think again now perhaps that
could be something that I could use here
so I started to to try to build
something so I came up with this name
flow let's to describe this kind of
micro protocol so here we have a stack
of flow nuts which implements sort of a
a a virtual a2 network device sort of
the significant the control software of
such a device a switch with the
capability of supporting sort of virtual
a2 networks like VLANs but so we have a
number of flow lots and when event curse
or empties the controller from from the
switch we send this event through the
stack and each flow that are able to
look at this event and take some actions
or just ignore the that amount so in
this case we have like five floats here
and there are each doing just a small
amount of work to keep them simple to
understand and simple to write a simple
to debug etc so the first one called a
Mac learning for example it's just
snoops incoming packet the stores okay I
see a packet coming on that English port
from that MAC address that's stored into
the database there's four fillet to use
for anyone else other for example other
flawless can make use of any information
so that's the only thing it does and
then a packet can continue to flow
through this stack of flow let's the
next flow that the ARP reply makes it
possible to to act as an art proxy for
something we simply if you your your
application here wants to act like focus
on by default gate or something so
someone is asking for your RP address
then you can say hey gonna answer to
those kind of IP addresses here for
ProQuest's that's the only thing that
that floated does and then we have the
lay to field that was the most sort of
complex one of those five so it makes it
possible to to introduce some kind of
filters for to decide whether packet
should be able to continue down down in
the stack or if it should sort of drop
it or should jump to another stack
because actually introduced after Wally
introduced the possibility to jump to
name stacks like this and then I could
jump to other stacks sort of inspired
from IP chains or you can do
that and assuming you you are able to
continue down through this LTL to filter
thing here
you came down you come down to the ARP
flooding fluid flow light which only has
one thing to do one toss to do and that
is to orb sending our pre quests which
we don't know anything about send them
out on all the ports on the switch and
lost the last floated here the l2 flow
maker it whenever it gets a packet in it
just connects the ingress port with the
egress port and makes use of the
information we have in this Mac database
so each of those are doing just a very
simple thing but together they form this
sort of learning switch with this
virtual aid to capability so I wanted to
do to explore this and try to write some
kind of proof of concept which was
enough complex to see what I could sort
of if this was a reasonable approach so
actually did that but before before I
showed that which I gotta tell you a bit
about the components in in the total
system so the flow that itself consists
of the Erlang code learner module which
implements that logic and then the
configuration which is specific for that
flow that is described in a giant module
and yang is this modeling language I was
telling you about
so the flow lets them are sort of
ordered in this kind of execution stacks
and when a packet enters through the
stack the flow that can sort of decide
by returning either of those three
possibilities here the flow let when
it's executing when it has finished to
execute it can return break which means
that okay do not continue to execute the
floats in the stack stop executing we
are done or you can say continue and
that means all right continue
call the next float in the stack or it
can't say jump jump to another stack and
continue executing each flow that has a
local state which is maintained by this
tail flow controllers so at the store
above the system each float is called by
this controller which makes it possible
for it to read its configuration from my
configuration database store that into
some kind of local state which then
controller maintains so the local status
is injected into the earlier module for
each call and then it's retained by what
might have been modified by the module
so it's retained onto the next core
there's also an event state so so
actually during the lifespan of the
event you can actually have a state
which lives through the stack of flow
let's but then or discover the other key
thing here is something called switch
logic and the switch logic is actually
what defines this that is actually the
actual open flow application itself that
the complete sort of open flow device
software that we have created so it
contains of all those floated
configurations and all the stacks and
the thing is that the controller can of
course work with lots of switches so you
can apply this software which called the
switch table configuration can apply
that either to a particular switch by
using all this unique identifiers from a
switch called a data path ID or you
could apply to any other switch which
doesn't match any data path ID so if you
looked at a little picture here so to
the right we have the open flow switch
is generating events coming in to the
tail flow controller this switch logic
is looked up by looking at the data path
ID which comes with with an event and
then we apply the correct sort of
stack of Lola's we start executing here
northbound so this is sort of the tail
flow controller device sort of say so it
makes use of comedy which is this
product from tariff because northbound
we will have this kind of interface with
not concealed eyes rest api etc so that
it can be managed in this kind of
environment if you remember this picture
showed before where all the network
devices were at the bottom and NCS at
the top managing all those kind of
devices so this forms a networked device
which may deal with lots of different
kind of software applications for lots
of different switches so but on this
side you can see that the actual code
here the flow LEDs and the configuration
which is modeling yang is actually use
of written and injected into the system
so this is a component which is can be
delivered to a customer the customer can
where I start writing their own flawed
flow leads which is the software which
is gonna implement their functional
functionality whatever that is and the
configuration is also injected and
provides us with all those nice things
with the proper api's northbound and a
way to manage the device in a consistent
way so here's some yang code so this is
the model of the controller so the yang
you can you can compare to for example
an HTML and the doom module so it's like
a tree of boxes so here at the top we
have a container called controller and
it contains something so this is the top
in the tree of the configuration tree so
the most important thing here is the
listen port we have two very
to set up a listener in this import'
where all the switches are supposed to
connect to then comes all this kind of
switch logic so there's a list of switch
logic each which logic configuration
consists of a name and then we have this
data path ID either it's a specific one
or it can be any switch which connects
down here we have the list of all the
floats in a particular stack which can
be named so you can have several florid
stacks and they are sort of really
containing earlier modules in a list so
they're going to be executed in order in
according to the order in that list this
container here is empty doesn't contain
anything because this is sort of an
augmentation point for all the flow that
configuration specifics so all the flow
leads have their own yang models
modeling their own configuration and
that configuration is augmented into the
configuration tree at that points
underneath the flow that node in this
configuration tree all the flow less
compression is going to live the yang
has lots of nice features that for
example we are making use of for for
example you can see down here that this
identity ref here for example makes it
possible to validate that you can't
refer to a flow that which doesn't exist
in a way if you don't have a model for a
certain flow that you can't refer to it
in your configuration so yang consists
of lots of those kind of things which
makes it kind of neat to work with and
here is an instance of the configuration
so it's actually this is wrong it should
stand should say controller up here so
this is just an instance of the model we
saw previously so here we have the
switch logic we have given it the name
switch we have said that okay for an a
switch and a data path ID we should
apply this kind of this configuration
and down here we have specified the flow
data execution stack with all the other
modules that can be called
and since we can have multiple floated
stacks we have to also define where
you're going to start the start floated
stack okay it's gonna be this one which
we named switch stack the flow lead
container which was this augmentation
point contains will contain sort of lots
of floated specific configurations so we
can have a look at at that on the next
slide here first we have the model of
one flow lat in this case the l2 feel
the flow rate so it's it's a container
for the for this which we named l2
filter and what it really contains is a
list of rules conditions and actions for
this kind of filter flow rate so a
condition could be for example is this
an arp request or is the max source and
deaths are they on the same lay to
network or is it a dead ship DCP packet
whatever you come up with you can
specify a condition here and when a
condition matches you can do something
here in this flow that you can either
you can pass which means okay continue
executing with the rest of the flow nuts
or just drop it or you can go to another
flow rate stack so this is simplified
model of this l2 filter flow rate and
the instance an instance example of the
configuration could look like this so we
have the l2 filter we have two three
rules one named allow or proquest the
condition is is ARP requests true then
go to ARP stack so we have some kind of
floated stack named ARP stack somewhere
and we're gonna jump there and start
executing that floated stack another
room saying okay are we on the same lay
to network then return pass and we don't
continue executing with the rest of the
flow that's in the flow rate stack in
the last room just don't have any
conditions and the action is just
dropped so we're going to stop executing
the flow lots
summer long code just showing you a
little little piece of the sort of tail
flow let behavior which is just sort of
defining those kind of functions you
need for Babel to receiving the events
like packet in will call the packet in
function and we also can see that there
is an init function which is called at
startup so what happens is that your
role encode connects to sort of the
configuration database extract all the
configuration which is specific for this
flow lot and store it in a local state
which it returns and which then will be
sort of provided with each call which is
called back into this module in this
case we get a packet in so we got get
our local state and we get sort of the
message the packet which came in and
here you can see here is here's my
middleman which actually is some thought
you talked about this I'm transforming
this packet coming in from the wire into
an earlier structure which I can deal
with later on where I'm executing my
rules
I've sort of implemented this kind of
rule engine for this particular float so
so there are a number of functions for
each of the events there's this init
function and they're also a completely
configuration change function when
whenever the configuration change you
can do things we reread the
configuration or something else and
ideas that those flow lots could be the
earlier modules could be of course
easily loaded over the networks if you
have large network with lots of
controllers where each controller is
sort of like a network device from the
answers point of view we can sort of
load and upgrade code the flow that's
over the network to all those kind of
devices
so I wanted to write this kind of or
increment a little larger example from
the first one I did the programmatic
patch panel and the load balancers so I
wanted to implement sort of a simulate a
data center where you have a n number of
racks where each rack has n number of
hosts
you have topple racks which is connected
to aggregating switches and you have a
knotted firewall somewhere so it
actually okay
before I show you that I should have to
tell you something else so I did that
with the help of open V switch so after
just one slide to give you an open V
switch Prime open V switch as was
mentioned before it's a virtual switch
extremely cool little software which is
extremely fun to play around with
so basically open V switch makes it
possible for you to create bridges which
is sort of open flow switches which can
be controlled by an open flow controller
so you can create a bridge open V switch
bridge they call this it's case I call
it my gateway and into that bridge I can
attach network devices on my physical
host so for example I can add my my
physical interface if 0 on a Linux
machine I can add another bridge another
switch here and then start a virtual
machine connected to that switch so
start the virtual machine connected that
switch and then I can simulate something
to simulate patch cables to connect
those kind of switches so in in Linux
there's this kind of virtual Ethernet
pairs you can create so basically you
get a network device where you write
something at one end it pops up at the
other end and vice versa so creating
that you can put the one end into this
switch and the other end into a data
switch so then you have a patch cable
and you can communicate from the virtual
machine can communicate all the way
through out through the physical
interface so I made use of that to
create this
kind of large similar simulated this
sort of data center proof-of-concept so
this is my physical machine here I
simulate number of racks and number so
each of those boxes here machines topple
rack switches aggravating switches the
knotted firewall the Gateway they are
all open V switch bridges from one sort
of machine I have a patch cable going to
the top Iraq switch so each machine has
a patch carried onto the top Iraq switch
the top Iraq switches are connected to
the aggravating switch which also are
connected to is connected to the
firewall and then have this gateway and
out from my machine to die greatness
which also was running a DHCP server so
that I were able to start virtual
machines on those machines
I mean connected to those kind of
machines everywhere here they got so
their IP addresses from this Adina's oh
this DHCP server the thing is that when
you start this is everything is empty so
when this virtual machine tries to send
something it actually will pop up here
as I event entered my controlling
software up here the tail flow system so
so when a packet enters here I will solo
ok it's a request ok let's install a
flow for the ARP requests to send it to
the top rack switch and etc etc so
basically all of those switches here
we're running the same switch logic the
same flow let's tack this one on the
other hand was a completely different
thing which actually implements this
sort of a knot the firewalls so I could
I could ping for sample a machine on our
local network here and I rewrote sort of
the addresses etc taking care of
ARP requests matching that with reply
matching the ICMP requests with a reply
acceptor to get everything back here and
of course I had this lay to network
separation so the controlling software
here was checking that VM were only able
to talk to VMs on the same lay to
network and that was also done by by
this general switch logic so on it it
actually worked quite well so that was
kind of assuring that it wasn't
completely stupid way of implementing
flow applications now I mean
implementing I think like this isn't to
the solo something you want to do but
you want to do something more realistic
and the problem has been that lots of
people are talked about open flow and
it's kind of Oprah overhyped customers
are asking us we want to use open flow
blah blah what do you have do you
support it and we asked you what do you
want to do with it I we don't know yet
but probably gonna use it some some
times so so no one has sort of really
come up with some some some valid the
sort of use cases okay we have this
Google routing thingy they did for some
years ago but important that I haven't
really seen that much until recently so
I'm gonna show you a use case which is
actually a bit more valid it deals with
something called service chaining so you
have open flow switch here connected to
that open flow switch you have the
controller of course and we also have
this is the logical view here of the
traffic but physically we have network
devices like deep packet inspection
firewalls connected to this switch here
and what we want to do is to to chain
this kind of services deep packet
inspection the firewall
depending on who is sort of where the
packet comes from we what might want to
send it only into the firewall or we
might want to send it to first to the
firewall then to the deep packet
inspection or vice versa and that is
very easy done with with open flow
banner of the flow switch we have full
control of the other control logic and
this was actually described recently in
personal review this year number two
this year they described this kind of
scenario so when we're using this with
ICS those traditional sort of network
devices they are modeled and managed
from NCS as we have been doing for many
years now with the with those techniques
I explained earlier with this yang
models etc and we are configuring those
but we are also configuring this kind of
service chain which we describe as a
service model so service chains has a
very high high level sort of definition
and it all boils down to a number of
operations both here and there also end
up a flow switch to actually realize
this service chain so this is actually a
a use case which is customers asking for
order and today my castle erickson has
written about it also so I think open
flow has has a great use for those kind
of specific scenarios where you have
certain kind of solutions you want to
solve but in a general case you will if
you need a firewood in the bar if I will
of course off the shelf
you're not going to melt a king in with
the open flow so so basically that's my
talk we went first I thought so
pharming that's great any questions yeah
yeah the question was if n of the code
is available I'm sure I think it would
be possibly to make it available but it
doesn't make that much sense without
sort of the NCS and conf stuff coffee
stuff because management isn't so
important part of the whole thing the
actions that architecture is extremely
simple I mean you sort of apply those
kind of earlier modules on events coming
in so it's very simple but as a whole
you need sort of to be able to deal with
Jiang Medusa scepter and to be able to
manage it in a sort of consistent way to
text you to sort of make sense of it I
think
well the the transaction thing is is
something which is done within the NCS
product itself and I haven't worked with
that part of the system I kind of knew
at the company so I can't really answer
your question how they do it but I know
that it works
apparently so but that's a very
important part we're able to do to
manage the heat we use that route to be
able to do things in a transactional way
and be able to back out if some device
fail you want to back out everything and
they have sold it within some kind of a
way which I can't explain really so
sorry
well first of all it's it's a sixteen
low level I mean you can do it of course
but it's you have to have to like
reinventing the wheel you have to take
care of everything you have to well is
to me it seems like a waste of time I
mean there are excellent fireworks you
can buy of the health but for certain
scenarios when it perhaps you you just
want to do some some kind of small
subset of over a full blown firewall
then you can sort of on a budget sort of
implemented by using an overflow like
that absolutely so sorry yeah I had had
different sort of completely different
hadn't separate flow that for actually
doing the fire warning and network
address translation stuff and that
became sort of a rather complex quickly
so perhaps I should have tried harder to
to try and speed that up into minor
smaller parts if possible so so I think
yeah I I at least liked the idea of
being able to speed up the logic into
smaller parts and then connect them
together but whether that is a realistic
idea in in true life I'm not certain
really since apparently this this
research from the mid nineties didn't
really turn into something at least
nothing I know but</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>