<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Michał Ślaski - 'Lessons from Erlang VM'  ElixirConf EU 2015 | Coder Coacher - Coaching Coders</title><meta content="Michał Ślaski - 'Lessons from Erlang VM'  ElixirConf EU 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Michał Ślaski - 'Lessons from Erlang VM'  ElixirConf EU 2015</b></h2><h5 class="post__date">2015-05-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TkCftBMJyy0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I must say it's quite an experience to
be here I can imagine why but you said
there are a lot of emotions to see so
many of you here he's been working on
the language for many years now here's
the air leak circumference others who
are writing books are here and they also
have some emotions right this is so good
the community is growing i was born in
crackle I live here was also a special
event for me to see so many of you
coming to my home city I'm very glad to
what hosting in the city so on just to
let you know this is great perseus well
in my home city i will give you quick
background of what myself when Joe
started to work on the airline game I
was six years old I didn't know much
about programming computing nothing it
was released as open source as you know
and this was more or less the time when
I started to study computer science here
in crackle by the local university and
when headline vm got sub support for the
multi-core multi CPU architectures in
2005 it happens to be us of the year
when i graduated and i joined our ranks
solutions so for the last 10 years I've
been working at their length solutions
with airline would align vm on different
projects in different roles and i had a
chance and pleasure to learn what
features pay off what what really
matters in a long term and this is
something i would like to share with you
today because many developer conferences
like a lexicon they highlight features
of the language of libraries of
frameworks while we are developers so
this is what we are interested in how to
build systems what is the computing
model that the vm proposes but if you
look at it from
years perspective after development of
the system you also need to put into
production and then maintain the system
for a year maybe four years actually
typical life cycle of an airline system
is not months it's years it might be
slightly different for for the Ruby
system which is not necessarily run for
many years you actually want to iterate
fast and this is what Ruby developers
appreciated with Ruby on Rails and other
frameworks so this might be that the
elixir use case for the airline vm is
also leaning towards being able to
iterate fast but at the same time you're
coming to the airline vm ecosystem
because of reasons and i believe that
some of those reasons is to have better
life maintaining the system which may
leave for years maybe even 20 years so
if we look at it from this perspective
apart from well as i said paying a lot
of attention to how we design and
develop systems we also need to think
what will be my life in one year time of
somebody else live in a one year time so
i had few slides now where i try to
highlight the features that you have
already learned about or heard about
over the last two days and i'll try to
give you some rationale so in long term
why does this pay off to have those
features OTB behaviors well we know what
those are design patterns where you have
some generic parts abstracted away like
well client-server application release
what form in long term longer term it's
it helped build consistent maintenance
procedures if the whole system is
building on top of ltp principles you
can have
those consistent procedures which will
restart the system the same way
distribute upgrade the system the same
way when we heard a talk today about
like upgrading live systems this would
not be possible without having all
processes in the system all applications
in the system built on top of the ltp
personal principles and as we have seen
also the systems are distributed as one
type of artifact so in my next slide I I
just AM referencing to some airline
workshop I have on my github account but
this is the same experience you will
have with elixir that at the end of your
development cycle that is some built to
build machine will spit out a terrible a
horrible and this is what you install it
contains everything you need you can see
here it has the bit binaries the runtime
system some back bingham start screens
and all the libraries so this is very
useful for operations of those systems
another set robustness so we talk about
fail faster data crash and then program
for the correct case so avoid defensive
programming and so on and so on why
because those systems indeed are
resilient to bugs so it does not mean
that they do not have bugs they do but
they are more resilient to those errors
conditions and it's not uncommon to see
system running with like reasonable good
service and health and when you look
under the hood on your logs things are
crashing things are going really bad but
the experience of the user of the
someone monitoring the system is like no
it's all good it's all there but it
skips are starting it keeps crashing and
you don't even notice so this means
resilience doesn't mean no bugs it means
just that you can survive of course you
need to monitor in to capture those
cases but it's not going to bring
necessarily your system right the way
down so supervision trees I believe most
of you already know the overall idea of
a supervision tree I can also see very
interesting development within the
elixir community of bringing new LTP
behaviors that thumb have not only gen
server but also the task behavior agent
behavior app and other behaviors this is
all good however there's one thing I
would like to highlight here the
supervision three is the principle of
building this resilient systems so no
matter what your behavior is about what
new abstraction it brings to the table
remember to hook your processes into the
supervision trip if the process crashes
you don't want to miss this fact you
want somebody in the system to get x
signal as we call it so some
notification something happened and the
other way around which is equally
important if you have a process running
in the system and your father or your
grandfather has to shut down because of
some restart strategy you need to be
able to get hold of this process in
other words without linking any process
in the system into the supervision tree
you will lack this opportunity to shut
down everybody gracefully to get hold of
everyone in the system so in other words
I very much like that there are some new
design patterns being captured them and
implemented by the elixir community
which is great we need to stick to some
principles altiverb it all to be a
principal here and I think supervision
train is really the one of the most
important ones when in a few months time
you get to connect to your airline node
and there are some processes hanging
like zombie processes this is not
something you want to end up with
can we have distribution it was said
today that some environments may be
alexeev distributed system is not
necessarily built on top of airline
distributed protocol it may need some
other external components like readies
or other things and that's true but the
distribution that is built-in into the
airline vm also brings us some goodies
for example we can connect to running
notes when once they're like and I don't
mean connecting to them over a unix pipe
so like be physically present on the box
on winter system runs but we can connect
to them over network and we do so for
example for maintenance of that node so
we call it sometimes the remote headline
shallow remote elixir show what it means
is that you spawned a new airline vm
instance just for the sake of running
some shells and maintenance tool which
connects to your elixir now over a long
distributed protocol and now you can do
the same things as you would typically
do if you would start your interactive
elixir this foundation is used for
building interesting observation tools
which are very easy to use you just need
to know the cookie of the elixir known
and you're good to go well again
assuming you have access to the vm to
the necessary tcp port or the ssh
terminal the way it works is that
probably most of you already know is
that we have a mesh of TCP connections
between any nodes in the system assuming
you have some nodes each square in this
picture represents an airlink system and
elixir node we are connected in pairs as
you can see so they know it about each
other the moment you connect card with a
dog we start to gossip around
other known knowns and so that as a
result we will get a full mesh of
connections in other words once you have
connected your observation tools from
other maintainence tools to one of the
nodes in your classroom you already get
hold of all of them right this is not
bad we need to be careful whenever we
build big clusters because this
uncontrolled connections or uncontrolled
creation of full mesh may be actually
the bad thing but as long as we are not
building huge headline clusters elixir
clusters this is a place and connect one
of the nodes and you're only get can get
hold of any other now in the system and
so that you can indeed reach any one of
them now so as a result number of tools
are being built that leverage this
airline distribute protocol I believe
you have used the linux on unix top
command every once in a while I connect
and Linux Walton you want to check
what's going on so which process
consumes most Memorial each process is
busy at the very moment with some
computing so this is quite well
understood and everybody knows why you
would want a pod like this when you
connect a linux box a similar tool can
be built for airline or a leak signal we
get to see all the elixir processes
running and we also can sort them by the
number of reductions which somewhat
translates to how computing intensive
operations this one is executing a
memory of message queue size or any
other thing little I'm presenting here
is n top this is not part of the
standard all to bits nope
contribution there is also eat hope as
part of the standard out EP release so
those two that have been built there are
even top like tools for web or wxwidgets
what I'm saying here is that they all
leverage headline distributed protocol
this is very powerful thing to have
and then hot cold loading I've been
working with systems of different size
and frankly updating system life systems
with hot code loading is not something
that we spend a lot what did we do very
often the reason for this is that
despite all the excellent features of
the DM to support this case an OTP can
also support this it takes extra testing
extra time of development and testing so
we always have to ask ourselves a
question if you have ten amazon
instances on which you run your system
does it really make sense to put extra
development time to ensure that all the
live health upgrades were or not or
maybe it's just easier to indeed
redirect traffic to some half of the
system and then bring down half of the
system bring it up again with new
version so I think here the hot code
loading feature although it is being
advertised as useful for life system
updates has to be always carefully
considered what is the associated cost
of the development of such upgrade
package so but well this has been used
for hot code blogging fixes for example
I remember quite a few systems with a
hundred thousand users connected and we
did not want to disturb this system yet
we had some very small fix that we news
tested and it was worth just hot crowd
loading this patch I'm not recommending
this because again having consistent
upgrade procedures is what I would bet
on but using hardcore loading production
system that's happened the other use
case for hot cup loading is the shorter
development cycle this is actually
something that I do benefit every day
from so the elixir our command in your
shell
just reloads the module so when you work
with Phoenix that as we have seen today
in the morning during the keynote
there's some extra features built on top
of the well web framework that also
allows you to reload the web application
in the browser but the same applies to
the live reload of your elixir code this
really does shorter shorten the
development cycle and this this is
something that you can benefit from
right now I would recommend to to take
advantage of this kitchen you don't need
to restart the whole system to see the
effect of your just committed change
when another feature tracing which is
built into the Erlang vm tracing which
can be turned on and off so this is good
it can be turned on and off why this
system is running it can't raise
function calls message passing garbage
collector events scheduled event some
other ingredients what it means in
practice it practice it means that first
we have the chance to do live debugging
of a system and believe me if you have a
system running and something is going
wrong for one user and then you go there
and you try to figure out what happened
so the first you do is probably check
logs and when you realize oh but I don't
have print out or log or something put
in this brand of my code at this point
of time what would you do well instead
of reconciling the code to put more
instrumentation to the source code we
can actually turn on tracer on the live
system and as long as we we are
carefully narrowing down the scope of
tracing by which I mean it can be very
precise which process you want to trade
which module or functions from that
module you are interested in tracing or
even what exact parameters you are
interested in and like forget about any
other function calls so you can be very
precise and this way narrow down events
you want to train you can turn on
tracing and immediately get feedback so
what is going on with your system right
now this does have a little bit of an
overhead but not much I will explain on
my next slide but I would like to stop
here for longer tracer the way it is
implemented in Erlang vm i think it's
the only way
the debug concurrent systems I guess
everyone had a chance to use the
standard debugger of any work dot net or
any other visual environment where you
set the breakpoints and then you go
through the steps of your code and then
you can better understand what has just
happened but imagine you try to do the
same thing with a massively concurrent
system like a leakster system you have
let's say even thousand users just
thousand users and you want to set up a
breakpoint to get 500 windows to look at
impossible with tracing you can get
almost the same understanding of what
has just happened so what function has
been cold but what arguments what did
the function return so the same
information that you would typically
found find in a in a visual debugger
with breakpoints you can find out from
the tracing events that are printed to a
file or to shout but this actually helps
you trace and debug a concurrent system
we're having a break point is in no no
because the default time out in a gen
server is five seconds the moment you do
a break point somewhere some other gene
servers will be timing out soon waiting
for this guy to finish yeah so in other
words it's not only about the feature of
being able to trace live systems which
is nice which you can turn on and off
again but it's also about the philosophy
of the backing which is different
compared to let's say the web browser
where you have well break point to your
JavaScript code and you can understand
what has just happened
I promise to explain a bit more about
how tracing works inside the vm i borrow
the slide here from matts if you had no
tracing enabled the long vm will
interpret their called operation by
operation or interacting by instruction
if you turn on tracing effectively you
replace one of those instructions with
some extra jump which takes you which
take the vm to some trace pattern
matching and it will pattern match
against well the event that operation
that it is about to execute and then
well depending whether this did or not
trigger an event you will continue with
your instrumentation so what I'm trying
to say here is that this is not having a
huge overhead well unless you are
generating thousands or hundreds of
thousands of events right so it's again
important to now you're tracing tools
enough to be able to narrow down the
scope of what you want to trace
otherwise it will give you some overhead
but it's not going to bring you down
there are some libraries tools that have
been built on top of the airline tracer
that help you work with it here I have
well an airlock tool and I believe
singer tools are being built or have
been built for elixir already just to
show you one red bug where you provide
some pattern this is the first line in
this code which says I am interested in
tracing module lists a function sequence
sick from that module which takes two
arguments and I want you to return also
what the function return and then later
in the second line I'm trying out this
function call and as a result I got to
trace events one is when the function
was called and then when the function
return
easy and powerful other tools that have
been built on top of airline tracer
flame graphs there is another
interesting project here i'm just
showing a flame which can produce you
some frame grabs and flame grabs try to
visualize what is happening with the
call stack over the time right for which
is a typical call stack for a process
thanks to tracing you can also see
there's this blue line which is so when
does the process sleep but where is the
blocking call which when you measure
your concurrency efficiency via if you
like so how parallelized your code is
this might be very important to
understand which processes wait for
other processes and what is the reason
the reason is so found thanks to the
calls back ride and so again despite of
what this particular tool does i'm
trying to show that heading tracing
having distributed air like all of this
this does help give you interesting
instrumentation tools after you work
with the airline vm for four years and
it's no longer about trying to
understand the syntax of build tools own
to how do you deploy systems once you
have all of this running then you will
start to ask her some other questions
why the system means behaves here why it
does not scale the way I would like it
to scale what is that the system
actually does and then you will start to
dig into the airline vm behavior this is
when you look at the airline mailing
list those are quite often questions why
the airline being behave this way or
that way and so i was experimenting with
some different ideas how to help
developers visualize better understand
what is going on probably the most
obvious idea that comes to mind is is
using something like one but that has
been presented yesterday or other
similar tools where you just plot some
metrics on the timeline and then well it
gives you some idea of trends of the
current snapshot of the system so I've
experimented with this a bit then the
next idea is maybe we don't even need
the browser to get the same information
so you could maybe just use some semi
graphics and just put it in the shell
for some people having a browser is a
luxury when they connect to some
embedded devices or some remote systems
it's not always possible they will open
the browser so maybe tools what this
kind will be helpful this is those are
the ideas i'm playing with or maybe we
need completely new way of visualizing
what the vm does i had a chance to play
around with another one where you
actually use 3d view to visualize how
processes are connected to each other or
sending messages to each other right so
what in this particular view you
actually get to see a ring which is
elixir or airline processors passing a
message in the ring why this is not
always obvious when you look at a tracer
or longer what happens in the vm when
you look at such visualization it might
be much clearer quick you can quicker
understand what's going on so what I'm
saying here is that for me being an air
leaks in programmer is a new experience
I've been learning a lick sir I had a
pleasure to deliver the OTP elixir
tutorial two days ago it's very
encouraging to see enthusiasm and also
what new design patterns and new use
cases the elixir community has found for
the airline vm i'm thinking also how the
airline community can help here what is
it that we can bring to the table which
would help you advance and i think one
of those areas is understanding of the
vm so developing some tools that will
help you even quicker understand what's
going on so provide you some yeah
expertise around the vm which at some
point of time everyone will need when
the system runs for months or even years
and this is the focus of my work now and
in the coming months that's all I had so
um thank you is there are any questions
I'm happy transferable</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>