<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Kelley Robinson - Why The Free Monad isn't Free | Coder Coacher - Coaching Coders</title><meta content="Kelley Robinson - Why The Free Monad isn't Free - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Kelley Robinson - Why The Free Monad isn't Free</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7EQWNiwgT4o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">a couple of years ago I was working at a
small start-up and our code base was
written in Scala and there were so many
issues with it that we decided to
completely overhaul our architecture but
we were gonna do it right we were gonna
be functional we added Scala Zed we
added the state monad it was going to be
beautiful until we started seeing Stack
Overflow errors and this was just in
testing we hadn't even deployed this to
production yet so my coworker says let's
just trampoline it and add the free
monad and this was me being very
confused what he meant that was the
first time I'd ever heard of the free
monad I had no idea what my coworker
meant or why he intended it to solve our
problems and then fast forward a couple
more years I'm in a different Scala's
startup and a different Scala code base
and there was this one application that
no one ever wanted to touch and I looked
at the code and I understood why we were
using free monads to do a very
simplistic datastore operation the
purpose of the application was really
straightforward but the code made it
look really confusing and that made
small changes take a long time
essentially I wanted to know if I was
justified in being annoyed with this
application so I decided to learn what
the heck a free monad is so you don't
have to so today I'm going to talk to
you about why the free monad isn't free
my name is Kelly Robinson I main
engineering team lead at an advertising
company called share through in San
Francisco and let's get into it
so before we talk about why it's not
free we're going to talk about what a
free monad is in order to do that we are
going to explain monads using mana
lights and functors and then we're gonna
get into what it means to be free why
you might use some of these abstractions
and then maybe why you shouldn't if
you're not gonna use them what are the
alternatives available to you and
finally some of the applications people
are using of this stuff in the real
world this presentation has a lot of
code not everything on the slides is
going to compile if you try to do that
so all the examples are my github you
can look
them there and I just tweeted that link
all right monads mano AIDS in the
category of endo functor we've all heard
this but what does that mean Oh photo
that you want the picture so let's start
with mana lights I'm gonna use these
examples using Scala code quick poll how
many people don't know any Scala raise
your hands fair okay I like half the
room that's unfortunate but we'll make
this word anyway so traits similar to
other object-oriented programming
languages you can extend them the
methods available to them will be
available to anything that extends them
type parameterization here means that
this will take any type a method
signatures hopefully are straightforward
take the append method will take two
parameters of type a and return a
parameter of type a so that is starting
to sum up what mano eights are a mano it
is just some type that is going to have
a couple of methods defined on it and
it's going to have this append method
that's going to take two of the type and
again that can be any type and return
one of that type and then some method
usually called identity that's going to
be a no op or empty if used with the
append method so again mono it's two of
one type coming together to create one
of its type there are some properties or
laws that apply to mono AIDS like I said
there's this identity value that's going
to be the no op and then the idea of
associativity which means that the
grouping of the append method isn't
going to matter and that could be with
parentheses or any other way
buzz lightyear is right there are mono
it's everywhere so we can look at a
couple examples string concatenation
really great example of amyloid you've
got the append method is putting two
strings together if you take two
instances of a string and combine them
you're left with a single instance of a
string and the identity method there the
no op value is going to be the empty
string another example of a mono I'd
integer addition you can append two
integers together and you're left with
another integer and then the identity
value there in order for it to have no
fact is set to zero alright let's move
on to functors a functor is going to be
some family of types some container
that's going to have the map method
applied to that that F would be
underscore next to it means that that's
a container type it's going to take
something in its type and the map method
as we might know is going to be some
method that will take a function and
then apply that function to everything
inside the container so for those of you
that don't know Scala visual
representation if you've got some
container that triangle that has some
values inside of it that takes a
function multiplying everything by two
you get a new container returned that
has all the values that have been
multiplied by two functors and pictures
functors also have some properties the
identity value that means that there's
gonna be so some function that will have
no effect if and done with the map
function and then composition like
associativity that's to say the grouping
doesn't matter so you can chain a bunch
of map functions in a row or you can put
all of the logic inside a giant map
function
all right following me so far now we're
on to monads so I really like this quote
from a stack overflow post that says the
term monad is a bit vacuous if you're
not a mathematician an alternative term
is computation builder so the science
might have some academics or
mathematicians in it but for the rest of
us I think this is a really helpful
mental model so a monad isn't going to
be another container type it's going to
be another family of types that's
implemented the pure and the flat map
methods it's going to be this container
a context some kind of collection the
pure method there is going to lift the
value into that container into the
context and then the flat map method
this is also bind for those of you
familiar with Haskell it's going to wrap
a flat map will map all the values
inside of the container and then flatten
the context that that creates so the
interesting thing about this is now that
we've defined the pure and flat map
method
we can kind of work backwards to define
the functor and motto it operations so
here we've used pure and flatmap
to define map and we kind of get this
for free once you've defined the monad
operations and we can also use flat map
to define the monoid operation of a pen
and I've been pretty explicit about how
we've done this here evaluating the
functions in order to get to the next
step so that we can flatten the context
and return the result that we want as
we're chaining and appending things
together like the other two monads have
some properties there's also going to be
some no op value it's going to be a
function that when used with the flat
map method will have no effect and then
the composition to say the grouping
doesn't matter and again that's you
could chain a bunch of flat maps
together or put it all together and it's
going to be the same thing in order for
it to be a monad so revisiting our
pictorial example we have the count text
of the triangle you map and you get
another triangle but what happens if
your map function creates another
context then you're left with all these
nested triangles and this is kind of
unfortunate and this is what monads buy
us when you flat map it flattens that
context and so you're only left with a
single wrapper at the end and this is a
pretty arbitrary example but monads are
really useful because you can use them
to compose values in a context and your
programs this is going to be things like
lists and futures at the end of your
program execution you want to be left
with a future of a result not a future
of a future of a future of a future of
results and that's why things like
monads come up so often in programming
languages that was a pretty brief
introduction but now we're going to talk
about what it means to be free before we
get into that we need to define what we
mean by free let's clarify this we mean
free to be interpreted in any way
this means
no interpretation this is not about the
cost of doing this or for the fans of
Richard Stallman out there free isn't
freedom and not free as in beer so there
it is already the free monad isn't free
unless any of you want to buy me free
beer later so free mono Ed's let's start
with this to build up our understanding
of free monads quick refresh mono Ed's
the append method to of something coming
together to create a single instance of
its type so what does it mean for a mono
e to be free well again we want to keep
it free from interpretation no am i
stepping on something and we can't lose
any input data when we're calculating
the result so that's pretty vague but we
can look at some of the examples we
talked about earlier in order to see
what this means
so this concatenation is a good example
of a free mono and that's because when
you append two lists together you're
just shoving the day to the other you're
not losing anything about the inputs and
it's important here that we defined this
with a generic type a because this can
be done with anything we don't know
anything about the input the contain
type in the list it could be in sit
could be strings it could be functions
or other complex types but the fact that
we don't know what it is means that the
only operations we can do are the mono
it operations that we've defined and
that keeps it free from interpretation
and that's why this is free in contrast
if we think about something like an
integer mono I'd this isn't free because
when we're combining two integers
together we lose information about the
input there's a special algebra that's
happening here when we combine these two
together and it's an explicit
interpretation for that type and that's
why this isn't free so that brings us to
free monads so the important thing that
we need to remember here is that we
can't lose any data as we're flat
mapping and chaining operations together
and that means we can't evaluate any of
the functions
so if we think about the example we were
looking at before the result here on the
right
loses information we don't know what the
inputs were we don't know what the
function was and that makes this not
free so how do we do this in a way that
lets you evaluate this at a later point
in time that keeps us free from
interpretation so again we're gonna
build up a syntax for how to do this
we'll start with some idea of a free and
then we'll add a class return that is
going to indicate that there's no more
computation and this is going to be used
in our pure functions and then we'll add
a class suspend and this is going to
lift the container that f of something
into the context and suspend it until
we're ready to process that later and
then we'll add a class flat map that's
going to take an instance of free and a
function from a to another instance of
free this is gonna look familiar to the
flat maps method signature the bind
method signature and that's gonna help
us out finally we will add some helper
functions on the trait that will help us
chain the operations together and this
helps with some of the Scala syntactic
sugar that we need so let's look at an
example of how we would actually build
this out so let's define a free monad
for actions on a to do list basically
the most basic program you can write as
a programmer except for hello world so
we'll add some some syntax for the to-do
list actions things like creating the
tasks completing a task and then we'll
add some operations that will lift that
into the syntax with suspend but again
we're not doing anything right now we're
just talking about what we want to do
and we don't know what this means to
actually create a task or complete a
task and that's why it makes it free is
because we haven't defined the
interpretation so let's see what this
looks like
so when Scala's is pretty cool you can
chain these operations together using a
for comprehension this is syntactic
sugar for flat mapping and you can chain
all this together to get the result and
this might look familiar to some of the
Scala programs that you might have seen
but again nothing has happened yet so we
could look at the resulting data
structure here and this is what it's
going to look like and we've expanded it
explicitly into its types you can see
how we're creating this lists like
structure that chains all these
operations together with all the inputs
and the functions and how they've been
chained but again nothing has happened
yet there's no operations defined and
that's why this is free if we think back
to what we had before the result didn't
have any information in it what this
might look like with the free version is
something like this we take the input
data and also the functions that we're
applying and previously we think of this
as the star value being some kind of
multiplication but again that's an
explicit interpretation for that
operator here we've said okay 1 star 2
but we could later define that to being
whatever we want and that's part of the
reason that this is free alright so why
would anyone do this
it seems pretty complicated there are a
few reasons first of all when you're
deferring the interpretation you're also
deferring all the side-effects you're
composing functions without actually
computing them which means that you can
delay and defer all of the side-effects
all the i/o all the errors until a later
point in time and then that syntax tree
that we defined that to-do list operator
the complete task create task we can use
that syntax to later to find multiple
interpreters like I was talking about
with a star operator it's like if I
created a list of something and handed
it to everybody in this room you would
all probably interpret that a little
differently and then you can think about
something like this and use your
imagination for what these do something
functions do they could be doing some
kind of i/o or they could be adding
another thousand function calls to the
stack but in the course of your programs
things are going to start to look like
this every function in the monadic
context is going to be added to the
stack so remember my coworker let's just
trampoline it and add the free monad so
when we talk about trampolining we
talked about wanting to express all of
the control
floo all of the function passing all of
the chain functions in a loop instead of
putting additional functions on the
stack alright where is this any help I
just don't think it likes it
it thinks it's connected
never different dongle I can try we'll
try turning it off and turn on again I
think the dongles broken all right so
trampolining we want to loop things we
don't want to put additional functions
on the stack so the free monad is what
this is about the free monad is going to
use trampolining to achieve its goals of
achieving stack safety it's going to
exchange stack for heap trampolining and
the free monad all come down to
exchanging stack for heap so if you
think about are not free example you're
gonna be building up some kind of stack
putting additional function calls on the
stack but in the free example we built
up that data structure where all of the
information is contained and so your
result is going to be just bigger all of
that info contained within that data
structure that we created expanded here
so we created this list like syntax and
what are we gonna do with this how are
we gonna actually evaluate this well we
want to utilize trampolining we want to
use a loop so let's talk about what this
would look like it was a little crazy
but the important things to get here is
that you're gonna have a generic
function that you can run using multiple
interpreters that will take your input
so it's going to take some kind of free
input the monad that you want to
evaluate and then some kind of
transformer that's going to take that
and transform it into whatever output
type that you want to use there's also
this implicit condition that the
transformed type has to be a monad and
I'll get into that a little bit
so the functor transform is a little
tricky you might also hear this called a
natural transformation I wanted to be
more explicit and so I named it what it
is turning one functor into another and
we'll look at examples of how these
interpreters actually work in a little
bit but first let's look at the method
body this is already a ton of code so I
cut a lot of it out but in
pieces the important parts to recognize
are the tail recursion and Scala this is
going to utilize the trampolining this
is going to avoid putting additional
function calls on the stack this is
going to turn it into a loop and then
it's going to pattern match on those
return suspend and flatmap cases in
order to do the evaluation and I do want
to highlight what happens on the suspend
cases this is where the transformation
happens remember the suspend is going to
lift some kind of functor some kind of
context until we're ready to evaluate
and that's what's gonna happen now in
the evaluation context we're going to
take the transform or the interpreter
that we defined and apply it at this
point one point that I wanted to make is
you can do this even more explicitly
this might look a little weird using a
while loop in a functional language but
this is what's happening under the hood
and I just wanted to illustrate that
this is very possible the logic here is
exactly the same as using the tail
recursion so again
evaluating we want to make sure that we
apply the transformation step on suspend
and we want a trampoline for stack
safety so let's revisit the functor
transformers and talk about some of the
interpreters that we can define for our
to do list so we'll start with a test
interpreter this is a pretty common use
case for free monads so you'll create a
some trivial context some aid contexts
and have a method that will take your
input and turn it into the new context
and this is where the cool stuff starts
to happen so our test interpreter is
going to take some kind of mutable map
and in the interpretation we're going to
pattern match on that DSL that abstract
syntax tree that we created for our
actions on a to do list and this is
where the interpretation happens this is
where we say what it means to be a new
task to be a complete task and here
we're modifying the state we're mutating
the map adding tasks mutating whether or
not they've been completed building up
that model so we can test against it and
then when we run it this is what it's
going to look like we'll take our to
Do's well feed it to our run free
function and also give it a test
interpreter but we could feed
any interpreter that we want there and
then we have the expected map that we
can compare this against and this is
pretty useful for writing tests that
would normally have side effects but
this test might shadow some business
logic and we're all good testers in here
so we don't want to do that so let's
write a different type of test
interpreter and this is going to be an
action test interpreter so instead of a
mutable map this is going to take a list
of actions and we're going to build upon
that as we see them come across so when
we start to pattern match here instead
of mutating the state of the map we're
going to add the task to the end of the
list that we expect to see and when we
run against this our expected list will
now test that the order of the methods
and the order of the tasks that we see
come in the correct order and also that
we see everything that we wanted to and
the useful thing like I said is because
your production interpreters are
probably going to be calling a database
or doing something inside effecti and so
the good thing about testing with free
monads is you can define special
interpreters that can bypass all of
those side effects and test your
expectations about the actions of the
code without ever having to hit that or
use any kind of testing mocks we all
know how much we love testing mocks but
if you could find a way not to use them
about some of you would so a production
interpreter might look something like
this instead of transforming to that
trivial aid context instead you're going
to return an option and an option in
Scala is either going to be a sum or a
nun indicating that either either
succeeded you know maybe like a maybe
type and Haskell or that it didn't in
some way and so here if your database
right fails you can return a nun on this
new task and then this is why it's
important that that returned step is
also a monad because then when you're
flat mapping when you're doing that step
it will stop the execution it will stop
trying to do anything additional if the
transform step fails
revisiting some of the justifications we
talked about deferring side effects and
it's also useful for the multiple
interpreters like I said you're probably
going to be talking to a database we all
need to talk to some kind of outside
service at some point or our programs
can't be completely pure so we need to
incubation talk to a database do some
kind of HTTP request and then you can
also define the test interpreter that
will suppress all of that and do the
action tests that we described or
something like that the other thing
about free monads is that this is a
solution that's pretty neat but a lot of
people introduce this into code bases
because they can they think it's a cool
solution but usually there's an easier
way so Jessica Kerr Program Committee
for this conference gave this great talk
last year where she talks about blue
skies Scala and she talks about the fact
that there's the easy stuff in our
programming languages the green grass
the interest off the hello world and
then there's outerspace the complicated
stuff the free monad isn't free because
it falls into that outerspace category
and the path to learning to get there is
pretty broken it's an impressive
application but not everybody
understands it you are all attending
this talk presumably because you wanted
to learn something about this so there's
this good quote that I like from Marius
Eriksson who's a programmer at Twitter
that says programming isn't math and
sometimes we hoist vocabulary that
confers similar means this is somewhat
controversial but I agree with them here
some people think programmers need to be
mathematicians and no category theory
and in order to be expert programmers
but not everybody does part of the
reason we've been successful as an
industry is because programmers are
really good at adapting ideas and giving
them to computers to execute them more
efficiently so our biggest skill is
exactly this we can do that we can take
programming languages things like
programming languages that are designed
for humans otherwise we would all still
be writing bytecode or assembly but we
want good abstractions abstractions that
are going to make our lives easier
things that are going to make it easier
for me to look at code I wrote three
months ago or even three days ago and
understand what I was trying to do
Jessica also talked about this in her
talk earlier about
elm how you want these good abstractions
that make the maintenance of the code
easy to understand and I haven't even
touched a lot of the magic that's
happening behind the scenes here so the
reason that this is problematic is
because there are a lot of abstractions
out there that are more confusing than
they're worth things like the free monad
our mathematical concepts that have been
applied in the programming domain and
they have some good abstractions but for
most of us it's not necessary for our
day-to-day at work so some of the
reasons you might want to avoid things
like the free monad why isn't this
necessary for everyone and why should we
avoid it well I talked about that
boilerplate that DSL the abstract syntax
tree that we defined for the to-do list
that was three actions on a to-do list
if you think about your programs what
you would have to do in order to insert
a free monad is make all of the implicit
actions in your code explicit datatypes
and that's gonna be a pretty big
undertaking and somebody told me that
now Scala Z is doing this for you but I
still don't trust that you wouldn't have
to touch that code and it's easy to be
frustrated with concepts like this and
it's not because they're necessarily
difficult but because a lot of times the
learning curve the path to get there
it's broken that staircase is broken
especially in the Scala community people
often assume that you should know this
stuff but the explanations that they
send you to our based in category theory
and assume a prior knowledge or a math
PhD or assume that you came from Haskell
which a lot of people don't and that
makes it hard to maintain this it makes
it hard to maintain projects like this
we want to stay in the blue sky if you
were in the space monad talk yesterday
that's you know the outer space category
we can avoid that the blue sky is for
the 95% of us so if we're not going to
use the free monad what are some of the
alternatives available to us
well before we talk about that I think
it's important to mention that we should
know the domain that we're in know the
domain that you're going to be
programming in like everything in
programming this is gonna be about
trade-offs and totally dependent on your
domain so know your domain this spectrum
very relevant for Scala but also you can
think about it in your programming
languages and environments that you
operate in in Scala you're gonna get
some code styles that come more from the
Java side of things and some that come
more from the Haskell side of things so
no the expertise on your team a lot of
my team came from Java and so we try to
make use of a functional style but we're
more likely to end up hiring X Java or X
Ruby programmers than we are X Haskell
programmers so we're somewhat centered
on this spectrum so think about your
languages what is your language good at
is it opinionated you want to make sure
that you're going to be able to maintain
these projects if you're doing something
Greenfield ask yourself are your
co-workers going to be unable to
understand the abstractions you're using
do you have the time and the tooling to
make these worthwhile and is this
necessary for your business logic all of
these are trade-offs that you have to
consider before you're going to
introduce something like this and that
motivates how we think about things like
maintaining stack safety so if you're in
a language or if you're in a code base
that is using more object-oriented or
imperative styles and it's really easy
for me to suggest that you just use a
loop but that can be hard if you're
really invested in monadic constructs if
you everything in your programs is
already using monads then it might be
hard to introduce things that are simply
looping but as functional programmers we
need to keep in mind that sometimes the
less functional style can be better
especially in Scala this is very true if
you look under the hood at the Scala
standard library everything is built
using loops and mutable state and can
build from zand it's really ugly and I
don't know what this is doing but it's
good it's a good abstraction I don't
have to think about this this is
sit away in the standard library and I'm
very grateful for it so if anybody does
know Scala this is quite funny there are
also plenty of alternatives for managing
stack safety for maintaining stack
safety you can use plenty of other built
in monads things like options or maybe
in Haskell you can air handle exceptions
not all side-effects are bad though keep
that in mind things like logging are
really helpful you don't necessarily
want to suppress that and in the free
monad if you're using the free mode on
your cond in your in your programs
you're not gonna be able to do any
logging because you're not gonna be able
to do any of the side effecting stuff
until the very end and I can make
debugging this stuff really really hard
but we can look at an example of some
code so this there was a talk a couple
of years ago a guy wrote a library
that's a JDBC rapper called doobie that
uses the free monad as the wrapper in
the wrapper for the JDBC library wrapper
around getting data out of databases and
so his argument was that there are too
many problems with code like this it's
not safe the result set operations on it
can throw exceptions
you can't chain this and that's all true
but using the free monad also isn't the
only way to solve it and that was his
argument so this is some code that I
wrote for some of our applications
you know like six months ago and keep in
mind error handling is good but
functional programming overlords aren't
going to smite you if you decide to
introduce a try except block that's okay
I just want to remind you of that so
this code is just introducing some
safety around our database poles and for
our purposes this was enough I think
this took me like 10 minutes to write
and get into production and it was much
more safe than what we had before and
for our code base if there's a more
functional way to write the code that's
easy enough to introduce I'm usually
gonna take that route but again it's all
about the trade-offs that you want to
make
I didn't want to introduce a free monad
into this application because we don't
touch it that often and it's an internal
API and so it doesn't really matter if
something unsafe happens every now and
then so keep in mind your domain so if
you want to look at this kind of stuff
on your own if you're interested in
doing or experimenting with this you're
not gonna have to write these yourself
you don't have to go and reimplemented
own ad
somebody has probably already done it
for you in your language some languages
have it built in Haskell definitely does
the language like Scala has libraries
that have done it for you and I know
most other languages even non functional
languages have ideas of some of the
functional concepts that are available
and exposed at different libraries and
we can look at a couple examples of
things in Scala that I think are doing
this kind of well so for all my talk
about do be it does have pretty clean
abstractions there around the JDBC it's
pretty heavyweight it's not something
you're just gonna introduce in an hour
but it does make things composable and
more safe and then there's a method
called the task that you can use for
concurrent programming and this is an
example from our code and this is
awesome queueing messages for sqs it's a
good abstraction for multi-threading and
I think this is pretty straightforward
to understand especially if you're
familiar with Scala it's a very clean
abstraction and I'm grateful for it
because under the hood it looks
something like this and I don't know
some of you might looking at code like
looking at code like this and trying to
understand what it's doing but I really
don't want to have to think about this
this is too much for me to try to put in
my heads mental model of how I'm working
with a computer but this is the kind of
code that motivated this talk this talk
kind of came from a place of pessimism
because we were seeing code like this in
our production services and you had to
edit around code like this and that's
really really frustrating when all you
want to do is change the name of a JSON
string so what happened what happened
with my experiences
so the first company the guy that
suggested we just trampolina at a free
monad shortly after he said that he quit
but that was okay because he left the
company we never added a free monad and
it was a good thing because in that
situation the fact that we were seeing
Stack Overflow errors was a really
really bad omen we were writing an API
for a very simple web service there was
nothing complicated about it and the
fact that we were seeing this means that
we had grossly over complicated our
business logic so we did a little bit of
refactoring and even though it made our
lives a little bit more complicated it
actually made things better in the long
run and then there was a datastore
application with all the terrible code
but I eventually realized that even
though it was using the free mode and I
thought that was the problem a lot of
the problems that application were
unrelated the thing about it was is that
application was really over engineered
and it's really easy to do that when you
start introducing concepts like this you
start thinking about these things and
they're kind of cool and they're fun to
play around with and eventually you end
up with a lot of tangled code that only
the person that wrote it can understand
and the thing is as industry software
engineers most of us are getting paid by
a company that's using us to make them
money and a lot of us don't have the
large-scale problems that necessitate
these kinds of abstractions again know
your domain so after talking to a lot of
people about the free moon and I'm still
not convinced that it's the best
solution but I do see how introducing it
in certain circumstances can make your
code more composable and safe I think
the thing if you take away nothing else
from this talk is that we just need to
be judicious when we introduce
abstractions like this just because we
can doesn't mean we should sometimes
it's okay to trade the most functional
style for the sanity of your code and
the sanity of your team but if you're
somebody that understands this well we
need to make sure that we're spreading
that knowledge if you're somebody that
wants to introduce this in your team
make sure that you're willing to teach
other people your way isn't how
do this the thing that we have to keep
in mind is that you should assume people
are competent but you can't assume that
they always have prior knowledge you
want to make sure that you're
introducing these concepts using links
and other things that will make this
accessible that doesn't mean we have to
go overboard with those kinds of
explanations but we want to make sure
that we keep this accessible to people I
used to think the free Mona was pretty
awful I don't think that anymore but if
you're like me from a couple of years
ago and someone's proposing introducing
this into your codebase I hope I've
given you some tools to determine
whether or not that's a good idea
once again I'm Kelly Robinson here's my
contact information and thank you for
listening
questions will you stop giving it home
the higher kinda type disrespect okay
well having a park bench in the pub
later there I asked this yes I dare
there seem to be two threads going
through your talk one that the free
monad technique used wisely is a very
good one used wisely
I really enjoyed that the other was it
seemed to me that skull is quite fragile
for his higher abstractions is that fair
that is very fair I originally wrote
this talk for a Scala conference and so
it was very very applicable for that
domain and I think Scala is one of those
languages like I showed with that
spectrum it's not opinionated and you
can do basically whatever you want with
the language and so you get a lot of
camps of people that are on one side or
the other and so it's pretty divisive in
that way there's certain people that
write scala in a very very functional
Haskell way and a lot of people that
write it just basically using Scala
libraries and api's but in a very java
oo way so a lot of these problems are
mostly relevant to the Scala and my
experience is there but I think they can
be applied to other domains
like how long do you think it takes a
person to really get to grips with this
kind of approach of programming is it
like a year or two that's a good
question I think it depends on if you
need to do this for your work if you're
looking at it in your spare time I think
it took me like a few months to grasp
this trying to develop this talk
honestly I think there's there's
definitely resources out there that are
friendly and if you start playing around
with it with the code it also depends on
your learning style like I finally came
to grips with this when I started
actually playing around with code and
seeing how it worked and making it
compile on that kind of stuff but it's
not gonna be like if you're using this
in these abstractions in like a
production application and you've never
dealt with it before it's probably gonna
take some time and I think that's
basically the argument that I'm making
is if even if like two or three people
on the team are really familiar with
this stuff and come from category theory
or Haskell as soon as you bring in
someone more junior even not someone
junior but that just comes from a
diverse background then the rest of your
team that came from Java or something
like that you're gonna have a harder
time integrating that person into the
team it's going to influence the hiring
that you do for your team and so if you
want to only hire X Haskell people or
people that are very invested in these
kinds of paradigms buy more by all means
go for it but I think the learning curve
and that whole point that Jessica made
with the the blue sky is really
applicable to what I was trying to
achieve cool taking that a little
further
how is Java rate and introduction of
lambdas changing the sort of Java
developers that you've been introducing
to Skylar over the last few years
that's a good question Scala 2:12 is
only like officially released yesterday
I think which is the one that takes into
account a lot of the Java 8 stuff so I
don't think I have a good answer for
that yet because
that's a good point
I I don't know yeah oh so the question
was now that Java eight is introduced
which introduces things like lambdas and
other more functional style programs
does that help with the kind of learning
curve and it might help with like a lot
of the blue sky skeleton type of stuff
that you're doing like even mapping is
new to a lot of Scala developers that
came from Java that's not something
that's necessarily like you don't get
that necessarily if you're coming from
Java or Python or something like that so
those types of more I guess I would call
them straightforward functional styles
might be easier but I still think
something like the free monad is going
to be pretty pretty brutal for someone
coming from Java 8 there's an old paper
by Henry G Baker called cons should not
cons its arguments you would find it
very interesting is that a question okay
thank you do you think it's possible to
sort of use these abstractions without
having to learn them like the free
monads like understanding its deep
structure and all that stuff seems
really powerful but can it be used as a
tool without knowing that deep structure
yeah and I think that's on library
developers to do that so the thing that
I mentioned about like tasks that uses
the free monad under the hood I don't
think anybody on our team knows that
except for maybe the people that watch
my co-workers that watch me get this
talk but I think it's up to library
developers and us as programmers if
you're going to introduce that to do
something to make the api's into that
abstraction accessible hi
as you mentioned Scala provides the full
spectrum from oil to pure functional
from your point of view do you see that
as a pro or con for example in a
situation when you start with pure
functional way and deadlines come on and
then you are starting to think should I
have some kind of escape hatches to
maybe introduce some impure solution
they're fully pure so yeah it's more of
a con in my mind I think some people
like it because it makes the language in
some ways it makes the language more
accessible because people from different
backgrounds can come into it and write
in a style that they're familiar with
but it makes things very very fragmented
so what was the second part of your
question oh yeah so if you just need to
deliver something so I think that's on
teams to decide how you want to build
software and I think this is comes in
and you know not just Scala but a lot of
languages if you want to trade you know
maintainability for getting something
out the door we all know how to hack
together a solution that will get
something to production tomorrow but it
might break a lot easier than if we took
the time to design a system that's going
to be more maintainable that's the we
had time for thank you thank you can we</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>