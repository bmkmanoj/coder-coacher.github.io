<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Functional Tao of Bash - Garrett Smith | Coder Coacher - Coaching Coders</title><meta content="The Functional Tao of Bash - Garrett Smith - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Functional Tao of Bash - Garrett Smith</b></h2><h5 class="post__date">2015-11-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yD2ekOEP9sU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">let's get going thanks for coming I'm
Garrett Smith we're gonna be talking
about some weird things here so if
you're in the room and you came to this
talk either a weird person so welcome I
appreciate it
okay so originally this was entitled
what was the functional dowan bat a bash
I changed it it's something different
it's now entitled refactoring and bash
functions and my personal neurosis and I
wrote this title just like ten minutes
ago because I finished it like okay this
is the right title this is what you're
gonna hear but you're probably Bill
disappointing cuz you're like I really
wanted bash to be a functional language
you're gonna learn that it's not a
functional language but just to appease
you because I know that you wanted to
hear functional language things I've got
two points here okay there is a little
bit of functional stuff going on in bash
I'm gonna give you two things and then
we're gonna throw those away and then
get into the really the really bizarre
stuff of the talk all right so this is
unfortunate no one can see this this is
not going to work so we need to turn the
lights down enough so we can see the
screen yeah how does that look at
everybody can I turn this up somehow
that's not gonna work is it yeah so you
can't see this but this is a list
comprehension I actually I tweeted it
something like I wish there was a list
comprehension in bash but there actually
is a list comprehension this is a list
comprehension in bash so we're doing
here is we're finding a bunch of files
with find type - uh - type F so it's
gonna find Phi you can run this now if
you have laptop core it's super fun pipe
it into X arcs so this is a generator
I'm going to define my variable here as
being the line items coming off of each
of these so this is going to generate a
bunch of lines they're going to get
passed in as as standard standard into
this guy I'm gonna use f as a variable
essentially there's a representation of
that and then it's going to transform
that F by pulling off the base name
that's a list comprehension it's also an
example of a higher-order function in
bash what's the higher-order function
here X args so X args knows - how to
handle standard in and parse it and then
pass it on to a command okay that's
functional it really is all right so you
should be satisfied at that point but I
have one more check out this I just
created a map this is a map function in
bash so so look at this is the code map
I'm gonna pass in a function to apply
and then I'm gonna pass in a list right
so here's a map I'm basically you're
gonna grab this as a string because it's
bash right and I'm gonna evaluate it
because it's bash I can do crazy stuff
like that because you take a string and
evaluate it a loop loop through my list
of arguments and then apply each
argument to that function that's
functional that's it that's all I'm
going to talk about it really isn't a
functional language but I'm I would
consider myself a fan of a functional
programming by the way thank you for
coming Phil I believe that Bash is a
discovered language I don't believe it's
invented you discover it's always
existed right bash has always existed
and anytime you search for something you
discover more of bash its bash it's
everywhere it's something discovered I
think that that's the universal or on
the omniversal language it's the thing
that says go do stuff all right that's
like the most fundamental thing of the
universe we just just it does stuff and
bash is the best at doing stuff that's
my I prove that is that sufficiently it
would like prove that I didn't as
probably you don't seem convinced thank
you well I will accept that check right
okay so that's my that that's my take on
bash as a functional language we're
going to get into some functional stuff
so that's that's that's still going to
come all right this is really a real
life story it involves a bash script a
single bath script we're going to take a
look at that it's short so we're gonna
be able to get through it 140 lines no
problem it's named CI dot SH now CI in
this case stands for continuous
integration I work at cloudBees we are
the Jenkins shop so we do we do our own
CI and that's what C say I stands for
continuous integration if you're not
using continuous integration it's okay
if you discover bugs in production weeks
down the road after something's been
committed CI will help you fix that but
it's not strictly necessary so right off
the bat I'm going into this thing
uncomfortable because I don't
the SH extension I just like it to be a
command so that's kind of bothering me
you can kind of see I've got them a
little bit of OCD going on here you'll
learn more about that and then the CI
name bothers me because that basically
is like do stuff
run run Don Sh so that's bothering me I
don't get into this as a backstory but
let me defend bash for a moment who are
any DevOps people here see this is a
word I reject
I also reject the word cloud because I
like to use the word Internet so DevOps
I don't reject how you sysadmin because
that's what we used to be called but the
difference between a sysadmin and a
DevOps engineers DevOps engineers 210
use Ruby right
you wouldn't any no self-respecting
sysadmin would use Ruby and so Ruby came
in this language for you know back-end
scripting it's like well we need a new
space for this we need a new like a new
term so this is this is old good
old-fashioned bash the reason that we're
using it in this particular case is
we're deploying software we didn't want
to have a bunch of prerequisites bash is
basically everywhere it's pretty
portable across system so it's actually
quite portable as long as you can stay
away from certain niggly parts of it you
can pretty much run this thing on any
non Windows platform there's also a zero
impedance mismatch with shell scripting
it's a bit of a circular argument here
but let me show you what I'm talking
about
we're installing software in this case
the point of C is H is to wrap a bunch
of things but the things that we're
using in in this particular application
mostly install things so I personally
like zero impedance for those little
impedance mismatches as possible what I
mean is this if we're installing for
example nginx we go to the nginx website
this is literally a screenshot I just
took yesterday and you'll see this this
is easy right we can install it easily
because it's in boone to team bla bla
bla and that's the code right now that
is shell script right this is what's a
command is represented you can run that
in the shell every single website that
you go to every single one 10 out of 10
will have this representation 0 out of
10 will have this representation now
this is the same thing in Python right
so we're gonna do the same thing in know
what nobody's gonna do this so I like
Python as a sort of alternative
scripting language but you're not going
to see this so
I wanted to something here that looks
like that simple straightforward so but
we don't have to do a bunch of
translation and a bunch of for ceremony
around basically just doing this so
that's the defense of bash all right so
let's go back to this script here so
before I do that I want to give you a
background on where I'm coming from and
why I'm even telling this story what I'm
getting into here this is a colleague of
mine and he he tweeted this he says I
can recognize a Garrett this is me
Garrett code based anywhere in any
language and I didn't understand what he
was talking about there and then I
thought about it I'm like you know I
actually do have a little bit of a
different style and it does tend to show
up quite a bit so I took a look at this
and here's some code that I write I've
written in bash and so get into more
bash but there's some bash code there's
some Python code it looks kind of has a
similar shape to it and that's some
Erlang code and you can kind of look
across these and there's a there's a
similarity to that we're gonna see in
direct contrast more traditional bash
which looks nothing like this at all so
I'm wondering about myself if I have
some sort of different problem that
other people have cuz most code does not
most code and I've looked at this most
code does not actually look like this
this is fairly rare and that's why
Michael says this is somehow a signature
of mine really what we're talking about
it's sort of well-defined small
functions that's really the only style
here I don't think that's something that
I've invented that's certainly not
something that that is unique to me but
it's seldom used so I'm starting to
wonder do I have some sort of compulsive
problem to do things my way like I've
got a certain wiring and I've got to do
it my way and if it isn't my way I have
some sort of problem that's the basis of
this entire story so we're gonna get and
that's the neurosis part so but there's
some technical side to you so don't
worry okay my goal in software is this
this is it this is what I live for I
want something to be completely
absolutely perfectly clearly obvious at
a glance that's a wonderful thing to
experience in software when you sit down
and you can read something very quickly
and understand the intention of the
author in this case the author is
describing fairly obvious monitor to
this object I agree with that
that's an Apple so my goals is I want at
a glance obviousness I don't like
surprises once I understand something
once I think I understand something I
don't want to be surprised and so I
don't like surprises and I have this
sort of thing about correctness versus
intent correct this is this is an this
is a niggle this is not a really big
point but this is something I kind of
talk about we talked about correct this
is correct code you know is it
verifiable is provable in practice I
find that the problems that we define
are really the problem what problem are
you carving out you have a choice when
you write software as to what you're
gonna do do you do a B C or D or some
derivative that's the problem that we
face is what problem do we solve so the
idea of correctness is this volatile
thing it changes right what's correct
one that one moment could be incorrect
the next once you discover something so
it's very much a process of elaborating
what it is we want to build so that's a
difficult term to apply as a standard to
changing what is correct so it's almost
a moral term what I like rather is
intention so that when something is
written you see what that author
intended so when i read code what is the
author doing what is the author saying
then I can reason about what it is that
may be correct or working or what it is
I want to do with that code in some
other context so I like clear intention
in code okay let's go back to this this
is what my story is we have this
integration this continuous integration
script that runs all the time and if you
commit something to code in source and
it breaks something you're gonna get
emails and you're gonna make people
upset and I've had a personal problem
with this because I tend to just be
really HAP hazard and like I just
figured in time people will fix it I'll
fix it I don't worry about it so I'm
breaking builds constantly people like
yeah would you just stop this please and
so I now have to get into this I have to
understand what's going on so I'm so
taking a little bit of ownership and
getting plugged into this thing so I
needed to make a very simple change to
this script what I thought was simple so
one of those things you think it's
simple and then you get into it and you
realize it ain't that simple alright so
let me let me make
sir what I'm gonna do is I'm gonna get
into some code that is actually not my
code my refactoring talks in the past if
you're here laughs or did a refactor and
talked in Erlang and it was on my code
so I didn't beat the hell out of myself
I don't care right I don't mind it's fun
but is it someone else's codes this is
kind of sensitive right I don't want to
be an asshole
they say this guy or this terrible code
right but this is this is an honest
problem we're right in the middle of
sort of a problem that we all face right
when we are working with other people
wolf will run into code that were
tempted to call terrible or bad or ugly
or whatever whatever judgmental negative
term and so I initially came in and I'm
just like oh my god then I'm like look
this is not right this is actually not a
very scientific point of view here this
is a moral judgmental tribal primitive
you know it's not my form it's not my
camp and I took a step back and said
this is not as a professional programmer
this is not my my right this doesn't
make sense this sort of moral judgment
doesn't even apply what I want is to
understand what this script is doing
what it is sort of meant to do and then
I want to be able to change it in a way
that is sustainable is intelligible is
you know not going to cause entropy down
the road so this is now scientific I've
got to understand what this thing that
works does so I'm shifting from this is
bad code to you know this is actually
good code this is a code this is code
that is running all the time it's
established a correct process and it has
accomplished something that it was set
out to do whether I like it or not
whether it's easy to understand or not
is really not an issue and so that I'm
proceeded along this term to understand
and then to clarify there's no judgment
here this is an iterative process of
improvement taking something that works
that may not be that understandable and
chipping away at it to make it more
understandable so that's my approach at
this point I did get permission from my
colleague who talked about this I said
I'm going to be nice and I'm going to be
so nice but it is a little touchy
because it's not my code so I want to be
sensitive to that
okay what I'm gonna do here is I'm gonna
walk through let me show you I've got a
stretch down here the code at a glance
okay so I'm gonna scroll down this thing
and see that okay I'm gonna scroll down
this and you're gonna see how big this
is
alright that's it I'm at the bottom I'm
gonna go back to the top that's the file
I'm talking about so it's not that big
I'm gonna go through each of the
sections but I'm gonna focus on one in
particular and we're gonna go through an
exercise and this is an exercise that I
tend to apply all the time in any
language and it's why Michael Neal says
this guy has this weird signature so
this is why no intention to do that at
all
but this is the process that gets me to
that signature so we're gonna go through
that now okay so my story is this I open
the file and then I read it as we would
all read it from top to bottom because
it's a script and execute it executed
sequentially so these are variable
definitions and I see this export and I
get a little concerned right away
because I know that this isn't being
made available to other programs that
are going to be running and I'm starting
to think about state I'm starting to
think about where it's defined when it's
defined who consumes it and what that
interface is that's all kind of
functional down mean it's good
programming
but in my experience with with
functional programming it's very much
about controlling state and you know in
a function and a pure function it's
pretty it's pretty simple these are
arguments that go in you get a result
out it's a transformation in this case
we're side effects City here and side
effects make me nervous on a good day
this was really kind of makes me nervous
so I'm reading that going okay it's a
bash script relax it's fine it's not
gonna hurt you it will hurt you but I'm
just trying to talk myself through this
this is the next block alright so this
is very very common in code any code any
language even functional languages I've
seen this in ml it's you know cam I've
seen an Erlang you'll see a big block of
code you'll see a comment at the top now
I have a Pavlovian response at that
point when I see a comment at the top
what does this comment say it says
update the development Tiger CLI docker
image I'm thinking well if something
took the time to write
comment there what if we could just turn
that into a function so it turns out
bash has functions thankfully so what
I'm gonna do here is I'm gonna just do a
very simple refactor I'm going to turn
this block because this actually is a
function it's just kind of executing in
line this is a function so let's just do
that so I'm gonna call this thing update
the development Tiger CLI docker image
because I don't know what it does I'm
just gonna take I'm gonna take it for
granted that that's correct
I'm not gonna judge that's fine it's a
good title alright so update that's my
function definition here and this is a
this is the syntax for a function in
bash and it looks a lot like JavaScript
a lot like JavaScript it reminds me of
how similar javascript is to bash all
right as a language to maybe not use
okay I had a joke but I pulled it out
cuz I don't have time okay so I'm gonna
now just put that code into this thing
now that block of code which is a
function I mean it has a sort of logical
continuity to it it probably it
hopefully does it probably does and this
is a script that's working so I'm gonna
I'm gonna give this thing the benefit of
the doubt so now I'm gonna just put that
in there now I look at it's like okay
now that's cool I got rid of that
comment and now I've got this thing sort
of identified as a functional as a
function but I can call and then I start
to read it I'm like okay if this thing
now this is this is an odd little syntax
in bash to say is this variable set so
we need to work with enough bash you'll
recognize this as other ways of doing
this but this is actually a really good
way of checking then there's a bunch of
stuff here but my eye goes right down to
this I'm like oh that's a comment I know
to do with comments right I use an
existing release well that's probably
what this does right so I'm just gonna
put a function there use an existing
release there we go all right now I'm
starting to call my blood pressure
starting to come down starting to chip
away at some of the sort of ambiguity of
this thing alright but now I've got this
clump here but there's no comment
so without really reading it I'm gonna
come up with a function name for this
what's the right function name for this
well this is what I came up with
I sure wish that it was a comment here
hack just do stuff
that's the name of this function right
there's no comment so I don't know what
its gonna do it does stuff some
expressing a little bit of regret and
ultimately it's just doing stuff I'm
done look at that that's a really nice
oh wait a second
this is weird if you don't know bash and
at a glance it's not obvious at a glance
so we want to make it obvious at a
glance so let's change this bit here
look what can we do does anyone know
what can we do in bash that could
possibly clarify this bizarre syntax any
ideas if I can use a function excellent
well let's do that if skip release
environment is not set I'm using kind of
obnoxiously long names here kind of
didn't make a point because I really
don't know and I don't really care to
refine the perfect short terse name I'm
just kind of just kind of stumbling
through this stuff but that looks pretty
good to me right I'm ready to commit I'm
ready to get this thing in a sort of
revision now I don't know about you guys
but this is probably not gonna that
would be funny right but that's not
gonna live very long and reap your repo
so I want to go and examine what this is
so let's go back to the original block
and try to figure out what this stuff
does so so push D is a convention in in
bash to basically change directories
with the intention of getting back out
to the original directory so it's very
common to have to run a command in a
particular context it's a little like
object-oriented programming we have to
set instance variables you have to get
your state just right and then you
invoke something that's kind of what
happened here I'm sorry
mmm it was a battery problem no nope Oh
wrong direction all right sorry about
that there we go let's get back to the
there yes okay yeah so push to use a
convention we're gonna run this in this
object or in some in a set it's like you
know set my state here effectively I'm
setting current working directory I'm
gonna run and make clean I know that is
that's gonna make a run a make file I
know
clean as a target that's commonly
defining to make file which means
basically just delete all the artifacts
okay I know what that's doing I'm not
sure why we're doing it but I know
what's going on there I'm gonna set that
aside for a moment because it doesn't
really help me understand what's going
on this is interesting so I come back
with the pop I come and now I'm going
into the release directory I'm gonna run
release and then I've got some arguments
here so it looks like I'm running a
release that's what I believe is going
on here so why don't we name the
function this create tiger release I
think I think that's what's going on
here and I believe I think I think we
should use this convention more often we
should use the suffix I think or you
know - or underscore I think or
underscore hopefully in a lot of our
functions that would be honest I think
we would be like looking ourselves in
the mirror and saying that's the right
name for this because that is the right
name for this particular thing except in
the back of my mind I'm really bothered
by this this is weird right I can
understand this is making a release but
why am i why am i cleaning a different
seemingly completely unrelated project
and now I'm starting to get worried like
what is going on here so now it might I
really think the name of this thing is
this create tiger release I'm pretty
sure with some odd CL I clean first
that's the actual name of this that's
about what this thing needs to be called
right so this is it I'm done right I
really am this is this is actually the
right this is this is the code that's
been written and I really am done as far
as my knowledge and my understanding the
problem here and this is what sent me on
a really a fairly radical journey is I
became very skeptical that there's a
good understanding or
it's probably understanding the
mechanics here but there's something
wrong I believe that there's there's
probably something wrong there's this
this bit here seems strange to me it may
have been an artifact from some other
who knows where this came from but it's
not logical it doesn't strike me as
being clear and cogent and when I run
into something like that I'm very
resident reticent to just hammer at it
and add things to it it's a little bit
like pouring gasoline potentially
pouring gasoline on a fire
so my tendency at that point is to step
back and say you know what this is
bothering me I don't know enough about
this you know I'm concerned that I might
be making things worse I'm gonna I'm
gonna take a different tack here but for
academic reasons let's go through the
rest of this thing and imagine what we
might do with this code upgrade an
existing upgrade existing cluster what
do we do with that comment
what's our Pavlovian mechanical
refactoring instinct the function
absolutely right but not a lot else we
can do here too I mean what else we can
make it a better common more descriptive
but I um shion's are good here so that's
a very clear I don't know maybe I don't
know what's going on there with a move
thing pass on terraform that's a really
long that goes actually past the past
the 79 characters here but that would be
a funny name for a function that'd be a
function this would be a function we've
got creating configuration and I'm
reading the code I'm kind of tracking
with it so I'm like okay I'm optimistic
that this might make sense but as I got
into this I realized there's some
complexity to the script that I was
uncomfortable with I felt like this
script might be doing too many things
and as it turns out it we're gonna keep
going here for an image and so we've got
more code that could be a function okay
it could be a fun you get the idea here
right and we're getting toward the end
I'm seeing some things wow that could
really go into a nice clean function and
I don't have to look at that that's a
big mess of curl crud Wow look at the
curls being used a lot so I'm getting
I'm starting to kind of weaken and then
give up and I did at that point I'm done
and I'm just like you know I don't feel
like working with this file right now it
does a lot it was overloaded I know it
worked so what do I do at this point I
knew what I needed
to do so my tack at that point is to go
in and create something that is is
separate right you can go in and hack a
file and make it do what you want or if
it's a little bit over its overloaded or
confusing or complex or you're not sure
what to do a lot of times it's good to
just take a new parallel initiative and
create something on the side and let
them live together the thing on the side
may not be a drop-in replacement but
that's good because you want to focus on
the thing that you want to build so here
are my concerns going into my work
of course I want clear obvious intent I
want to understand state life cycle this
is kind of getting into this is really
not functional I mean this is this is
universal you want to understand where
how state is created where it's modified
where it's read modification is
generally something you'd like to avoid
and it turns out in bash you don't have
to modify things you can actually do I'm
going to show you some pattern that I
like to use that makes bash a bit more
read only because modification of state
is a tricky business and strictly and
bash it's tricky in any language so
that's definitely a pattern we can apply
to our bash interfaces are concerned
specifically in bash we're talking about
variables we're in particular talking
about exported variables because those
have all sorts of side effects and then
are the arguments that we're using in
our commands slash functions and really
this was it for me right does anyone
know what this reference is the rubber
duck doesn't understand okay so what's
the what does that mean rubber duckie
right so when you have a problem you're
trying to solve something you're working
through it a really effective tool is
you take a rubber duck and you put them
on the table and you're facing the
rubber duck and he stares and listens
carefully and you explain your problem
to the rubber duck and you will you will
know at the end of your statement and
explanation if the rubber duck
understands you'll know he'll tell you
is like you could look in his eyes and
they'll say I understood that I didn't
that exercise is incredibly valuable in
forcing you to articulate what it is
you're doing this thing failed the
rubber duck test I did this with my son
a few weeks ago he was doing a math
problem one of these sort of story math
problems
those are difficult especially for for a
young learner to sort of get his head
around this thing and I wanted him to
start to describe the problem in a way
that he understood so that I could
understand he understood it so I said
Eliot the rubber duck doesn't understand
and he didn't understand so I tried to
find a rubber duck and the best I could
come up with at the moment was this
thing this is rainbow wolf so we had a
rainbow wolf on the couch and I'd put it
down on the table and he is very
interested in this point it's like this
is the most interesting math lesson I
think I've ever seen and I said Elliott
explain the problem to the rainbow wolf
and he wasn't kidding so he's eager to
try this so he did any pause and he
struggled with it says dad this is
really hard to do I'm it's hard for me
to articulate this and explain it I said
this is exactly the point this is like a
little aside for rubber ducking and if
you don't have a rubber duck I encourage
you to go find the rainbow wolf because
it's more colorful and it's got nice
eyelashes that bad back at you and so
this failed the rubber duck so I wanted
you to go and create something else now
we're going to go into sort of my my OCD
Pavlovian model of a programming in bash
all right so here we go so let me show
you that file quickly here all right so
this is this guy all right so this is
the top of the file I'm going to scroll
down alright that's it up and down so
it's pretty small and we're going to go
through it
I'm going to explain what this is so let
me give you an overview of this all of
my bash programs have evolved into this
pattern they all now follow this and I
find I found this is work I haven't
changes this in a while so I'm
personally happy with this I'd be
interesting here what my colleagues say
they usually disagree with me so don't
by any means think that this is right
but I can defend this I think this is
right all right so we have some what I'm
going to call header ceremony we'll take
a look at that variable definitions some
includes as libraries quote unquote take
a look at that function definitions lots
of these lots of these and a single
usual
very simple script implementation and
that's basically my what a script would
look like in and bash conceptually so
here is that script I've commented out
the sections here because really the
main point is the implementation when
you run this script this function which
is defined above this is implemented
it's one function can you guess what
that function does can anyone guess what
that does it initializes the new cluster
that's what that does
so that's Apple right that's got an
Apple signature right on it it's really
clear what this does and it also lines
up thankfully with this thing
C I in it cluster though I'm sorry did
say Apple Apple I get it I get what this
does there is no reason that every
program can't be like this this is
simply a matter of talking to the
rainbow wolf understanding what it is
you're doing and then articulating that
in a very clear and obvious way there's
no reason that every program can't do
this this is actually really really
simple okay what does this look like
here's the ceremony of the the header
header definitions variables definitions
and and then the library included this
is also very simple I'm going to get
into some specifics here if I've got
time I might not have time I probably do
I'll explain what this is I'll explain
what this is that's ceremony that really
every bash file should have it be nice
if you could have a look a little macro
or include there but this is bash you
don't ship libraries with it you just
are opportunistic and use what you get
so you have to have a little bit of this
stuff this falls out of the scope of
this of this talk so I'm not going to
talk about that that's a trace flag
that's pretty simple this thing here is
a variable it's certainly not exported
but what I'm doing is I'm getting the
source directory of the bash file itself
and this is weird sort of boilerplate
for doing that it's one of the ways it's
a better way of doing it and now here
I'm sourcing a library file the library
file there it quickly just contains
functions so
support that's all this does this is
just defining a handful of functions
that are included effectively the
sourcing will load that and evaluate it
so what I'm doing is simply defining in
line a bunch of functions and now I've
got a bunch of stuff available for me
this is this is like the basics of any
language but unfortunately it's seldom
used it's really fairly rare apart from
like complex OS and NIT libraries people
tend not to use this in its but it's
very good it's very effective it keeps
sure it keeps your main scripts fairly
readable and of course it allows you to
reuse code okay so that's that's all
these three things these I'm going to
get now into the function definition so
I'm now getting into function
definitions so NIT new cluster consists
of this I'm going to read it here
there's no comments there's no confusion
it's simple direct sequential code
destroy the existing cluster okay
makes sense clean the project okay got
it it knit the project so initialize the
project got it
initialize the configuration okay
there's a lot of steps here but they're
clear and they make sense to me then I'm
gonna initialize the cluster okay so
this is sort of the prereqs and then I'm
gonna do that and then gonna test the
cluster that that's correct Oh correct
round this is what I want this is my
intention this is exactly what I want to
do so there it is right there
every single bash Python Ruby Erlang ml
program can look like this some
languages encourage this but you can do
it in bash bash it's crazy
okay here's some more we don't need to
get into the implementation details but
this is destroying the cluster so we now
we see some of the implementation
details here but it's really fairly
simple I have an echo which is not a
comment it goes out to the users sort of
see progress there's like a log and then
I get the implementation refresh destroy
it can destroy again taking sort of
complex conditional logic putting into
function right basic stuff here's the
rest of it initialize the project and
you can read very simply what each one
does the intention is clear what am i
doing I'm going into directory I'm
running a command coming out that's it
there's no you know scrolling of things
that I've got to go parse and and
Ferrand to decompile and understand it's
all the work is done here for me
and this works this isn't this this is
all done alright that's it
that's it so what I have now is a
refactoring not of the whole thing but
of the snippet that I'm interested in it
now is this a matter of is this a matter
of of going from bad to good like I'm
going from some you know evil thing to
some virtuous thing there's a temptation
to think of it that way but that's
actually completely wrong the first
thing is good because it works the
second thing is good because it works as
a by part to the first work I couldn't
have gotten that stuff done because I
just copied that stuff in place so the
work that was done initially which is
very ad hoc it's I'm just getting this
thing to work all right that's good that
that's good code it proves out the
problem
it runs the problem it verifies it and I
could be very happy with that code if I
never had to modify it if I never had to
read or understand it and in fact I was
very happy with it I didn't know it
existed I was perfectly happy until then
I had to modify it and that triggers
another change another iteration in the
process of writing software now we need
enhance clarity because we need to
verify the logic that were that that
were involved in here it sounds basic
but we often don't do it we can be 20 30
or veterans of software I see this all
the time we don't do this but we ought
to I think in terms of a progression
okay so really quickly for Bosch do they
want to get some time for questions I
have some specifics here in case you
were wondering about Bosch but this is
not a tutorial or an exhaustive listing
of all the things that you need to learn
in Bosch just like as it wouldn't be in
any language but there's there's sort of
interesting things that I think are not
always obvious but it blur valuable so
we know this is true Global's are bad
and K so we know and we think Bosch is
like global city well there's ways to
deal with Global's and Bosch that I've
adopted that I like a lot so first of
all you've got you've got Global's
everywhere so there's no way that you
can get away from them so don't for a
moment think you're gonna start to like
get away from global state and
side-effects and bash again it's not a
functional language that was a joke
there's a
now that we can apply to this but there
ain't no function was no monads here I'm
sorry okay here's what I like for
Global's first of all I'd like to avoid
using an environment variables as an
interface to a batch I'd much rather
pass an argument and where does that
come for is that instinct come from well
that comes from my use of functions
where I prefer to see arguments passed
in as opposed to the poking of global
state by the way instance variables in
an object global state global variables
their global to that object right and
all the badness associated with global
variables is now associated with the
instance variable so that's just an
aside it's a rant on the idea that if we
just reduce the scope somehow they're no
longer as global
there's a reduced scope they're still
global so I'd like to avoid this kind of
pattern of configuring vyas poking a
bunch of state up in environment
variables I like to minimize the script
variable so minimize the interface keep
a clean interface as minimal as possible
and then what I do is define scripts
that are effectively used as variables
and I'll show you an example here so
define script variables using args so
who are you sorry this is what I mean
use functions to compute derived
variables here's an example this is
setting a variable using the argument
here and this is a very odd notation to
say it's required so fail if it isn't
started and use this as sort of a
message to the user it's terrible it's
bash
welcome to bash so if you just get used
to see in that and just relax it's fine
right it is fine so if I don't provide a
single argument to this it's going to
crash and we're gonna see a really weird
looking but I'm gonna see this very
primitive so it's like a very primitive
get opt help system very primitive but
it works so now I have a project which
is my first argument now if I need a
derivative of that I create a function
that is effectively just generating
write so this is now a subdirectory the
temptation would be and this is what
I've done in the past would be to say
scripts derp and define it now as a
function as a as you actually define it
now with project up here as a literal as
a
as a variable rather I like this this is
virtuous for a number of reasons the
main reason is it simplifies and it
reduces the number of global variables
here which ultimately reduces the
complexity of your context context will
kill you a surprises this is if you
could eliminate context altogether
you've got a nice you've got a nice
interface to some operation so that's
what we're trying to do we're trying to
chip away at context and here's how it's
used scripts directory is and this is
the syntax for calling a function
returning a standard output into this
string this is echoing so he's gonna
call this and evaluate it so this is now
returning this so this is a way to
inject that and you can use that as a
variable variable reference you're a
handful of other patterns this is kind
of a cool pattern this feels very
functional I guess I'm not really not
trying to make it a function you
understand right yeah that's clear I'm
not on record saying it's a functional
language so this is the usage so skip
that for a moment and just take a look
at the usage here so I'm gonna call some
list I'm gonna pipe that I've actually
wished this was this this feature was in
more language it's very nice I'm gonna
pipe this in to use read which is going
to pull off the it's going to read a
line and assign that to variable X and
then I can do something with X and in
this case my generator of values is just
echoing lines now that gets that gets
enumerated here so that's gonna be each
each one of these is going to read off
of that until it gets to the end of the
file and that's gonna stop then I'm just
doing something with that
that's a nice pattern and you can use
that very easily and elegantly so take a
bunch of complex things for loops and
other things put them into generators
and use this pipelining I like that
boolean checks we've seen this we can
take you know really insane and complex
logic that we'd be tempted just just
embed it and give it a name all right
now we have a function we can understand
what this is going to do we can reuse it
all the good things here and there's a
couple of valid examples this one I like
test test is a program that will allow
you to evaluate different expressions
you can do boolean's and file checks etc
this or
turn a zero exit code if is successful
or one if not and zero in bash generally
and indicate success so that that's true
and in this case we're going to call the
true command which always returned exits
with zero false always exits with one
you get the idea so this is a nice
pattern as well you can eliminate and
clarify logic quite a bit getting to the
end here
these should in my opinion be used and
every single thing you do this says
crash on an error if you don't set that
explicitly your bash program will
continue to run happily in the face of
any error happily just plowing through
and I just I don't understand why that's
the default behavior it is I guess it's
the universal do something it's the
dogged ly determined to just you know do
what you tell it to do so setting that
will cause that behavior to change this
will fail if you use a variable that's
undefined that's a bug like if you don't
have a defined variable in my opinion
you shouldn't continue in it the odds
are you mistype something the odds are
not that you expect in some cases you
may expect something I'm going to show
you an example how to handle that and
then this is finally the last one in the
Trinity of fixing bashes terrible
default settings if you pipe something
and that something fails it will succeed
so you can eat errors through pipes
unless you said that okay finally a
couple things with arguments I use local
arguments but you've gotta know a few
things I use this syntax here to
indicate it's required because it'll
fail if it's not set even if set E is
not set - E or such R - u you can
provide default values this way so if
you are using set u meaning crash if
it's none defined you can define a
default value and these are both
explicit I know what's going on here so
this is sort of idiomatic but it's
expressing an intention this says it's
required this says it's not required and
I get a default value if you wanted the
default value to be empty just default
is delete it's just - curly bracket this
is a terrible feature it is the most
shocking and horrifying thing ever
the source of all sorts of bugs if you
use this notation back ticking would
also do the same thing any exits that
you call here are eaten any time any
type of failure that you want to
generate and crash your program will
fail
happily fail and you'll continue and
you'll have a bug in your program the
reason is you're both simultaneously
defining the local and assigning it it's
very strange
there's an ordering issue get into it
you understand why it happens but it's a
terrible problem here's how you fix that
you declare it locally above and then
you assign it on a separate separate
line it's probably the biggest pitfall
that I face in this language but that's
it I mean other than a ray passing which
I don't really want to get into it's
terrible all right
finally use local I was afraid of local
I said don't use local locals terrible
because of this but and then I started
using this underscore convention which
kind of comes from Python well probably
comes from all sorts of languages but
it's very common in Python to denote a
private or you know don't use me
argument the problem of course with this
is that if somebody else decides to use
the same name and you call him you've
redefined your value that's bad that's a
surprise that's a terrible thing
so look use local but just watch out for
this thing so that's my that's my Dogma
there okay well I'm gonna wrap up very
very quickly and hopefully have time for
a question
so bash is not function language that
Oaks that was clear programming is not
either-or it's not a moral debate we're
not talking about evil and good here
we're talking about a process a
programming writing terrible code is
actually probably a misnomer that so
called terrible code is code that's
experimental and trying to prove
something that's fine
prove it understand it get to work learn
from it and then make it clearer make it
better as needed right I was perfectly
happy not knowing about this but now
I've got to own this I've got to get it
into it and I would like to understand
what it is I'm doing so that's my
refactoring somebody else might not have
that point and it might be fine I don't
think that there's a mole topic here
okay everyone has their own moral issue
issues that are wrong of course and I'm
right haha just kidding one or two
questions before we close comments
disappointments that fashion
in fact not a functional language yeah
yeah well so yeah so you would what
language should we use yeah yeah that's
a good idea I mean that's certainly what
the Elm closure script space is doing
absolutely right that is another example
of why bash and JavaScript are basically
effectively the same type of thing they
really are same types of problems same
types of horrible horrible problems no I
think that's right and that's a really
good point I do believe though that
there's there's something to be said for
sort of idiomatic use of a language and
I think that this I so that's true now
new newcomer so the projects are going
to have to get into that and that may be
completely justifiable that this is a
critical system we wouldn't be using
bash for this so you know in that
particular case I don't know but that's
a really good point the ability to know
not worry about having to do two
finely-tuned all these things with
patterns and conventions but using a
proper modern statically type language
to Dinn to generate this code could be
yeah question comment I'm over time I
think I think I am but should be any
other I like questions any I sorry I
didn't leave enough time John
I was very careful thank you for point
yeah that's a great question so the
question observation is I was very
careful because I really do mean I work
with amazingly talented people full stop
and and I do think that there's some
pretty horrible things going on there
but it is a function of evolution in it
I think it's closer to the truth that
this is good because it establishes the
basis of working code but the question
is observation is what Wieck you know is
it impossible to write you know the
second style or a different quote
unquote better style initially it's
absolutely possible when I started to
adopt this this mode I would often write
something in a slightly more clumsy and
awkward way and then we factor it
immediately and then in time I got very
good at just doing it directly so I
don't go through the intermediate er
step in intermediary steps now and I
think differently and I think that's
virtuous I would advocate for that so I
would encourage people to adopt this but
I'm taking a bit of a pragmatic approach
in a collaborative setting here so I
don't encourage everybody to use this
and get better at it there's absolutely
no reason that you have to go through
that initial stage if you don't in fact
have to so okay one more then we're done
one more you have to it has to be one
more otherwise we're not going to be
done so somebody
I really hesitate to talk about it in
the room with two creators of Haskell I
really hesitate to even say a single
word other than what I just said no I
certainly wouldn't I think that using
lots and lots of functions can get you
what was it a pan universal truth I
think that seems right to me but I'm
really not the expert
I found it practically I'm sorry I do
this daily for a living I don't know if
it maps to to truth in I don't know if
it goes beyond the four walls of like my
my office out in two different different
versions of our universe I'm gonna take
I'm gonna take doctor doctor Wilders
word on that because I don't know you
probably right I'm not gonna answer it I
don't know I really I'm terrified by the
people here in the room so with that I'm
going to close thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>