<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang in finance - Next generation of automated payment systems | Coder Coacher - Coaching Coders</title><meta content="Erlang in finance - Next generation of automated payment systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang in finance - Next generation of automated payment systems</b></h2><h5 class="post__date">2013-08-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jKdLvEcSa-w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to the airline
solutions monthly webinar my name is
Martin military time the solutions
director here at erlang solutions
today's webinar represents a
continuation of a series of webinars we
are organizing the cross topics of
interest in the world of our line and
dealing with solutions based on the
airline programming language
our topic today will be dealing with one
of the most significant areas of
implementation of Erlang based solutions
with the real world impact on the
financial services industry and related
sectors and also on how we live our
daily lives and how we depend on
advanced and sophisticated monetary
transaction services that we have come
to see as commonplace the story of
Erlang in finance and the next
generation of automated payment systems
will be told with the backdrop of
practical implementations erlang
solutions have performed as well as for
testimonial by our guest company kakuka
who operates as an issuer of prepaid
debit cards as with any live event
please excuse any technical issues we
may encounter today to start by telling
you a bit about online solutions we are
a products and services orientated
company completely devoted to the
airline programming language since our
founding in 1998 we have worked with
organisations and individuals using our
line helping evolve the language and
supporting people and businesses using
it today we have about 80 people across
our offices in London Stockholm Krakow
and Budapest and working on projects
across the globe we promote the airline
cause and are keen on creating value and
competitive advantage for our customers
across industries and through the unique
features and characteristics of Erlang
as a language we are ambitious in
development of Erlang based product and
we work to create lasting partnerships
with our customers now I'm really
pleased to say we have two speakers
joining us today and whom we have
carefully selected as best invited to
tell you about Erlang based payment
systems
firstly my colleague and the erlang
solutions senior architect rudolf von
braun will start us off with a technical
overview of our lying-in financial
systems
financial transaction processing and
financial switching Rudolph has spent
many years working on and with financial
switching platforms and has led a number
of projects delivering key
infrastructure of solutions in payment
processing now of course her line
characteristics sound unrivaled on paper
but ultimately the proof of the
capabilities of our line based payment
systems must surely lie in their
practical implementations to date this
is why I'm pleased to say that our
second speaker today will be Sean
Hotchkiss the technical director at
Tituba having run Erlang based payment
systems in business practice for years
Sean will be in a very good position to
share the intricacies the pros and the
cons of living with such platforms on a
daily basis please allow me to finish by
saying you're welcome to post questions
throughout the duration of the webinar
by using the chat facility our speakers
Rudolph and Sean will then answer as
many questions as time allows at the end
of the webinar if any questions do go
unanswered you are welcome to raise them
by email using the following the dress
webinar at line - solutions.com that's
webinar if you're interested in learning
more about Erlang based payment systems
or simply wish to establish whether they
may be a solution for the challenges
your own business may be facing and then
please feel free to get in touch contact
me directly my email address will be
displayed in one of the final slides of
the presentation we will share with you
today the same goes for any other
questions you might have feel free to
contact us I would now like to hand over
to rudolf von Braun who will be glad to
start us off
you
hello everyone and this is
speaking as nod and said I've been
working on for very long time I think I
present I'm almost at 14 years I've I've
spent most of those 14 years as a
director and co-founder of a company
South Africa called Patmos technologies
but in the last two years I've been
doing a lot of work outside that
specifically in Ireland based payment
systems
so my experience started very early I
think it was in 2004 was highway our
very first customer was to cheetah and
they presented us with a very
interesting challenge which we're going
to tell you about a little bit about the
work we do today and in the in the last
year or so I've been working as a
payments architect for a prominent UK
company and we've we've built and are
currently deploying a major payment
system in the Far East so my
presentation today I'm gonna cover four
different areas so first we're gonna
start off with just talking about the
two systems I just mentioned and then
I'm going to move over to a little bit
and talk about what transaction
processing is and where that fits in and
then you will hear me mention that the
the notion of a financial switch few
times in this presentation so I'll just
cover off what it is what is a financial
switch and then finally I just want to
dig into a little bit more technical
details and show you what what the
messages look like that these switches
process and that's about the ISO 85-83
standards so in our experience as I said
we started off with with Jajouka now
they approached us and what his company
an artist group to to design a solution
to connect their the existing voucher
system to financial switch using eight
ISO 85-83 over the years we
built up that simple gateway into a
fully-fledged furnace a switch that
connected to various customers and this
project is what started off my
enthusiasm for financial transaction
processing now I'm going to discuss two
different types of payment systems mr.
chuka we're talking about a card
processing system so a card processing
system in in in the sense that anytime
you use your debit card or credit card
at a shop or ATM and that god is take
his information is captured from that
card and it's then passed through the
financial networks to your bank and
that's done in order to take a payment
from you as person and to pay the
merchant
so the dukkha system sits on the one
extreme of the payment systems describe
it it's what we call an issuer system so
issue of a card in other words a payment
card and this is what to do card eyes
they've built all the infrastructure to
issue prepaid debit cards prepaid in the
sense that someone has to deposit funds
onto the card so you load money in a
certain way and then those funds are
used for payments no dukkha system uses
ISO 85-83 might see there's a title on
my slide messages for
for interacting the financial networks
now there's a lot of cryptographic stuff
in the system and so that we used
interfaces through what we call hardware
security module and we built a native
airline interface for that so just on a
very high level the system stack is
consists of three levels so it's a very
bottom there's a Microsoft sequel server
database that stores completed
transactions and keep track of all the
balances and helps with reporting and
then there's a Treasury which is where
Shaun comes in and it'll tell you a
little bit about that which is
essentially where the money is skipped
and tracked and then at the top there is
an airline payment switch which handles
security the connectivity to the payment
networks manages the the messages so at
this stage I'm going to hand over to
Sean and he's going to tell you a little
bit about this system thank you
hi everybody this is Sean speaking
thanks very much for the introduction so
far or as has been mentioned I'm the
technical director at two chuka yes we
had a quirky comm domain name all the
way back in 1999 long before it was
trendy the basis of Africa we actually
chose the name because it's a Zulu word
for growth or progress so it'd be fair
there's a bit more meaning to our name
they're just having run out of vowels we
see ourselves as a technology company
that builds software to power prepaid
accounts these prepaid accounts can take
any form which would typically be a
credit card and network we'll focus on
today but could in fact be any token
from a printed voucher to a text message
code for example a most recent claim to
fame is winning the best prepaid
processor in Central Europe Africa and
Middle East at the global prepaid Awards
we won from microlending card program
that we power with MasterCard we've been
a third party processor for MasterCard
since 2005 and a Visa third party
processor since 2010 where we were quite
proud to have our first card with them
be the official FIFA World Cup 2010
South Africa Visa card finally dig in
the database I can see that we've got
about 20 million active accounts and on
average we processed about 50,000
transactions each day so obviously this
fluctuates hot wildly by the day of the
month as well as the month of the year
but getting all these transactions to
our core account system is an erlang
switch which we've been running in
various iterations for pretty much the
past ten years now that you have an idea
of who we are
let me give you a better idea of where
we sit in the transaction processing
world then I can give you a close up
look of where lol exits within our
environment so looking first at the
typical transaction flow for a
MasterCard or Visa credit card you can
see it originates as you would expect at
a merchant the terminal or the pause
device of the merchant will switch the
transaction through their acquiring
institutions until the transaction
reaches either the master
card or visa network the fitting of
which brand is associated with the card
and then from their respective networks
Visa and MasterCard are able to identify
us to to cut as the processor for that
card based on the first six digits of
the card number which is known as the
VIN
then we have within our data center
vault a device from MasterCard which is
known as a myth and a similar device
from visa known as a Dex and these are
basically the last mile connections to
which we connect using out their lengths
which and the Erlang switched and the
rest of the system obviously faltered in
our own environments so if we take a
closer look at what within our own
environment and how all the elements are
connected you can see we've paved it for
redundancy at every level arrow is
pointing away if you'll see that the map
and Dex devices are listed again on the
left and looking at them in more detail
we actually have multiple map and fix
devices then our network is segmented
into multiple zones and the one of the
most interest is what we have very
imaginatively called switch blown since
it's the zone to perform switching this
zone contains multiple servers running
the Erlang switch software together with
our hardware security modules or HSMs
which were obviously used for a pin
cryptography we have our connectivity
spread of a multiple servers which in
turn connected multiple HSM devices and
this provides us with redundancy
regardless of whether we use a bank
connection or server or one of the HSM
devices you'll see the diagram also
shows a data zone and a webs on these
urns have their own redundancy in place
which I haven't reflected in the diagram
because it isn't pertinent to the
discussion but in terms of connectivity
the Erlang switches connect to sequel
server for their own data storage needs
and then they connect to our webs on for
their primary responsibility which is
the actual posting of the translated ISO
85-83 financial transactions to our
quarter council system so now that you
have an idea of how we make use of
Erlang and where it fits into
environment you might wonder how we
ended up with another lang system as is
often the case and despite us being a
technology company we weren't interested
in any specific language rather we just
knew we needed ISO 85-83 online
transaction processing switch which had
the usual simple how LTP requirements
and like multiple incoming transactions
of ones and being able to scale up as
our transaction volumes increased well
of course at the same time being 100%
reliable and fault tolerance if any
problems do occur and so on the previous
screen there are lots of systems and
interdependencies in processing any
transaction and it was imperative that
the switch not be a new point of failure
so our research for ISO 85-83 skills is
what led us to patent meta technologies
which was run at the time by rudolph and
he of course just happened to be an
Erlang evangelist and at least according
to his assurances at the time the Erlang
happening to fulfill our requirements
and fortunately turns out Rudolf just
happened to be correct interestingly I
suspected rarer technical skills such as
ISO 85-83 transaction switching and pen
cryptography are more often found in the
same habitat as Erlang developers rather
than for example PHP programmers so in
hindsight seems unnatural allotments
skip forward 10 years an hour long
switch software continues the process
increasing transaction volumes without
fail patent mesh technologies in South
Africa they continue to develop our
regular new feature requests that allow
us to meet our growing needs and we're
fortunate to have Rudolf spoke to
provide ISO a 5 a 3 &amp;amp; Erlang consulting
from the UK some of the new
functionality the product has evolved to
provide include catering for the
additional ISO 85-83 variants that
relock mentioned there's the
cryptography and pin validation on the
hsm devices which we didn't implement
until about 2009 offering multiple
cluster away connections is something
that we are still in progress with and
another project that we're currently
busy with is integrating
transaction processing in addition to
the solution requirements that I
mentioned previously I want to highlight
the one of the biggest advantages is the
lack of downtime when patching bugs or
making small changes and this is
actually something so simple to do that
we do it ourselves just using patch
files that are provided to us even
package updates can typically be
implemented really quickly and with
minimal effort although we would
probably fail over to another server
while making a big change and a final
point that may be of interest is there
being a Windows house we originally ran
the switch under windows and this
original Windows version actually
continues to run to this day handling
some of our legacy x.25 connections
which we haven't translated in the newer
versions we did however migrate to
solaris as we became more comfortable
with it and so our newer versions will
run on Solaris which has obviously
provided benefit from managing them
that's it for me thanks everybody for
your time i'm going to hand back to roll
off now to continue these more technical
examination of Erlang but I hope that
I've given you some insight into how
Erlin is provided to go with them
enterprise level payments which the
presentation back on um is that working
I just need to check yes sir okay so
that was a card focus switch and then
the last two years I've been working on
on something very different which was a
payment switch now in the UK there's a
service called faster payments which is
used when you make a bank to bank
payment so for example if you log into
your internet banking and you select to
pay someone directly into their their
bank account that payment clears
literally within seconds so the
recipient of that payment or that
there's a beam of funds would be able to
check his bank account and the funding
funds would be in that bank account
within seconds now we were I was part of
the team that we're working on a
very similar service for the same
company that operates that service but
where's Foster payments runs on
extremely expensive hardware
specifically tandem non-stop hardware
and specialized switching software
called district we were challenged to
build a system that was going to run on
commodity hardware and on Erlang so
instead of having literally millions of
pounds of cost
this system was was meant to be running
on on Hardware which question there in
the order of thousands or tens of
thousands of pounds now we built this
system again in our line and it also
consists of of very similar components
as the t2 care system so there's a be an
eternal switch which deals with
financial messaging and then there's an
an administrative back-end which deals
with reporting and settlement I just
want to say something about settlement
because I've mentioned twice now
settlement is is a process that happens
between the banks at least once every
business day so essentially what happens
is they all add up the payments that
they make to each other and that they
receive from one another and then at the
specific time during the day and it's a
cut off and then what happens is the
money is moved by by the central bank
between the different banks and then the
switch and its associated administrative
back in it's responsible for calculating
the values of the settlement now for
this process we had to use a different
messaging standard which is not ISO
85-83 as will Accord payments but an XML
based payment format called iso 20022
which is creasing the new but used for
for doing interbank payments we were
also in this case asked to provide a
dual data center operation so in I'll
show you know and one of my other slides
that a traditional system runs Act
passive and this system there are such
to create an active active system which
was really really challenging so the
difference between this system is its
bank to bank both do cardholder to
merchants and also mean to be part of
what would wouldn't UK's called national
critical infrastructure well that means
you can't take it offline and it has to
function permanently so if anything goes
wrong it impacts the national economy
the backend system as some of the
functionality is as the one we recreated
for two dukkha but in this case um it
needs to deal with the the messages in
XML opposed to the binary format of
85-83
and we also had to implement
cryptography support however in this
case we did not build a native Erlang
interface to use the HSM s we we built a
Java bridge that interfaced with the
Java security modules now what is
interesting about this system is the
fact that it has to operate in two
datacenters at the same time so
logically the system looks like like my
diagram on the screen so you've got a
set of switches in each one of the two
active data centers with a link between
the two switches that I used to
communicate now as the transactions
complete they they post it to persistent
views which we used an off-the-shelf
product called rabbit in queues also
built in in in Erlang for and then the
transactions are DQ'd from the
administrative back-end and persisted
into the database now we use standard
odbms again in this case it was Oracle
and the admin interface is responsible
to calculate the settlement based on the
complete the transactions I'll show you
in further on in the presentation how we
actually calculate the values of the
settlement and how this Indian
reconciliation in this in this whole
system
now active active operation is really
tricky bit imagine that you've got two
institutions and one the top one the
bottom that needs to say in the payment
to one another and the ones the bottoms
got a connection to two datacenters of
the red arrow in the white arrow and one
at the top has only got a connection to
the the rightmost data center data
center - there's a problem with they
were had to solve is that the
institution at the bottom can send a
message to the first data center but
this the second institution is not
connected to that I descent so we had to
building an awareness between the
switches of who is connected way and
building a capability to send the
message from one data center to another
which will then forward it on to the
first institution now there's a very
tricky problem in in that we had to
solve here and one of the functions of
the switches is to prevent duplicate
payments now if you if you think about
the the the card payments which um what
essentially happens is when you use your
card
the merchants pause the vod's requests
your bank for payment so it asks it does
the debit on the on the accounts of it
it takes it asks whether that bank is
willing to deduct the funds so it always
reduces the funds on on the cardholder
side and then what happens is the the
merchant receives payment a few days
later but for a payments which in this
case the payment is pushed it's not a
pool like in the card switch so moment
you go into your internet banking and
you push the button to send the payment
what will happen is that the funds is
deducted from the first institution and
essentially within a few seconds it's
credited to the second institution in
and your bank account so if if that
transaction is for some reason st. twice
you will end up with twice the amount of
money in your bank account and there's
nothing that prevents you from spending
now Vegas want to avoid this at all cost
so what we need to do is due to building
specialized logic in the switches to
prevent this from happening that's
called the credit risk so one of the
major challenges we had to solve was do
to build a mechanism that works for fall
for protecting the the institution's
from from double credit and works over
to data center an active-active
operation now we build a solution based
on on the inter switch link between the
two switches and on what we call a
duplicate screaming function in the
switches now we use be easier and and
some some interesting algorithms do to
build the logic fullfil Pro for
preventing double credits unfortunately
I can't say much more about it I just
thought it would be interesting to share
that the actual problem with with
everyone now the question might come up
too why use Erlang for all of these
things now I'm not going to go into too
much detail but essentially urlan is a
very very small and compact language so
it's there's not a lot of libraries to
learn and there's only one or two ways
of doing anything and it's it's very
simple to do to build quite complicated
systems in it now one of the things that
that's interesting in payments is that
because learning is a functional
language it makes it very very easy to
build the logic that understands um
these these payment protocols and I'll
show you right at the end of
presentation what what ISO 85-83 looks
like now we managed to build logic and
libraries that that makes it very easy
to connect you the different payment
networks and one of the challenges is
that that for example the master god
protocols are very different from visa
but we still managed you to two great
abstractions that could handle all these
networks without too much code
obviously that the fact that Erlang is
made for distributed operations so to
the function in the payments which were
we where we run multiple switches in one
data center and we have the distributed
database for for the duplicate
screenings that functionality is natural
in an online system now one of the the
best things about Erlang is the the
capability that you had have to upgrade
code and I think June you mentioned
about this and we used to do do to
gradually small patch files do to fix a
bug and then we would just describe it
the patch files and load I eat you the
switches while they were operational and
then if we screwed up we would be able
to back them out at a very short notice
without taking the switches down and
that's really critical when you when you
need to have almost continuous uptime
now obviously in in some cases it is
necessary to do a complete system
upgrade now in our experience we could
do that without doing that on the fly by
just designing your system in a way we
would have multiple switches and they
could take over the load from one
another it's reasonably simple to take
one switch offline upgraded bring it
back online and take the second one but
if you've got the resources and you've
got the the process in place Erlang is a
very very good platform to do this live
on so you can create procedures and
those the mechanisms to do our hot
upgrade where you actually replace the
entire systems code while its operating
now another aspect of Erlang that's
useful in payment systems is is the
supervision capability now imagine like
you've got five or six or hundred
transactions on the fly now
in other words running at that time you
don't want a problem in one transaction
to interrupt the other transactions so
we would encounter that resultant dukkha
system if we for example get someone
using the card in China and they would
include Chinese characters in in the
merchant names or we would get some
strange runs in condition somewhere in
the network we would have it that the
transaction is actually impacted but
because we structured it in a way we
used Erlang supervision logic it was
only that transaction of this impact of
the mum of the others now the supervisor
if you can set it up in a way that
suppose it's supervising a logic that
deals with a database query now if you
encounter a transient error and that
process dies the supervisor can in some
cases restart that process and resume
functionality if you've designed it in
that way now in some of the systems in
the payment system we did it exactly
that in other systems for example ikuko
system due to the nature of i/o 85-83
it's not necessary to restart the
transaction the upstream and downstream
switches will retransmit messages and
they are very complicated rules for how
you deal with that but the superevil
supervision function is very useful for
dealing with for example database
outages or TCP connections that file or
it storm down for whatever reason now
I'm just want to talk about two specific
issues we faced that makes it quite
interesting in the payment world now the
first thing is has to do with decimal
support our line does not have support
for fixed point decimals in other words
where you have 10 pounds 5
fence we need to have like fractions and
all that it's only got support for for
floating-point numbers and for integer
numbers now if you look at my first that
the first red line there one of the
major issues with with floats and Erlang
is that it's not exact so example I
showed you there the case of where you
type in one point zero zero one and you
multiply it by a thousand and in other
language don't a very surprising result
which is a thousand got lots of nines
and you can see that they're surrounding
error now because Erlang has that what
works with floating puts you can't rely
on that for for dealing with with money
now we had to create a specialized
decimal library and to deal with this
now I've just shown you three lines
there where we did exactly the same
altercation and in this case we got the
exact answer so it first was due to
convert the floating-point number to an
accuracy of three digits return the
decimal structure the second one we
assigned it to a variable a and then in
the third line we multiplied the decimal
a with a thousand and it formatted the
end result correctly as as one thousand
and one so this is absolutely critical
if you want to to do or if you want to
build financial system is do work in
decimals are not in floats and then the
second big challenge we faced is is a
thing called PCI compliance no the
audience who works in payment systems
will know that this is an absolute
nightmare and it means that you need to
implement a lot of procedures in your
company which means this is you're
supposed to have access control to data
you've got to have security policies in
place all sorts of things but you also
need to write your software nnessee way
that makes it PCI compliance now PCI
compliance from a software point of view
essentially means that you're not
allowed to store any information that
can be used to originate
transaction now
card processing system the the large
number in front of the card is what we
call a pan a primary account number now
if you've got the pan in some cases you
can already any show the transaction now
there's also a little three digit number
or sometimes four digit number printed
on the back that's called the CVV it's
it's a security code used to to prove
that you've got a card now one of the
golden rules in payment processing
systems that you're not allowed to put
the pan into a database or log it into a
log file you're not allowed to store the
CVV that the the three-digit code the
back in any way and you're supposed to
use cryptographic a hard way do you
validate the the CVB's now the the rule
is it has to be hardly done in hardware
so you cannot use for example Erlang's
crypto module so even though it's got
support for some of the operations you
need for payment processing it's a
complete nono now that means we've got
to do to build HSM support hardware
security module support into our systems
and we had to do that in both of the
system so in two Dukas case we built a
direct Erlang interface which use tcp/ip
to communicate with the hardware
security module and in the payment
system case we went via a Java driver
which did essentially the same now the
purpose of this whole thing is to store
the keys um
now in Lucas case there are lots of key
search for example a key that you use do
to derive the pin code
the reason the pin code that you when
you apply for a debit card and debit
card and and the issuer would mail you
the pin code to that debit card in a
secure envelope
now that pin code is generated by the
hardware security module and there are
various ways in which you validate it so
we had to do that and we managed to do
to build all of these things in our line
using the the ITSM and it was it was
quite tricky but I think it
it worked really well now I just want to
now move on to my transaction processing
section I just talked about these things
that I the switches do the transactions
now the the the most fundamental thing
is a transaction is about buying and
selling so if you if if I as a person
wants to buy a coffee from a second
person he would give me the coffee and I
would give him more attend all the
payment if it's that expensive so it's
about paying someone for goods an
exchange of value my cash in exchange
for your cup of coffee now this was done
in cash now in the last 40 years or so
these things have started getting
electronic and now that's essentially
the only way in which you can can buy
things so what is a transaction well if
you think about it in a very simplistic
way it is the act of entering
transactions details into the accounting
systems by all the parties involved so
if I'm making a payment for my bank
account my bank would record that you've
made the payment staying around ten
dollars and the merchants bank would
record that he's receiving $10 payment
so the one deduct and the other one -
the one debits the other one credits and
then at the end of the settlement period
each one of these banks have an account
at another Bank
usually the central bank and I would
move that thing dollars from the one
bank to the other bank's account which
is it gives actually the same thing
so the switches are responsible for
coordinating
this
the entries into all the accounting
systems so what is a transaction switch
and what this transaction switching so
it's essentially the process of agreeing
that the transaction has happened or
that can happen I mean the whole color
collaboration of entering the data and
settling everything off back now this
set the switch itself this response will
keep track of all the transactions that
are in progress now because of your
message is involved and I'll show you in
a while what one of these messages the
sequences look like a switch needs to
track which transactions are running and
what this type is so for example if the
transaction is is not completed properly
it has a procedure fork for coordinating
what we call backing out the transaction
or reversing it for example if you
receive the same message more than once
need to take action and then if the
donor action is approved or it captures
that and send it off for settlement and
then there's also a function of routing
the messages between the different
connections so I'll show you that at
once which would usually have
connections to lots of different
entities and one of its primary purpose
is to look at the message in the side
where I need to forward it to and all of
this has to happen continuously and
concurrently now
can be connected like my diagram shows
you there so it can be connected
directly to a bank or initio system like
Lucas system or it couldn't be connected
to another switch which could be the
Master Gardener which in turn is
connected to another one eventually
connected to a bank
now if receives formats and roots
financial messages so it ensures that
the transaction is captured consistently
and it works in tandem with other
switches now inside the switch there are
a few different components so in the
case of the Dukas which there's a
component that deals with formatting the
different messages that you receive from
the institutions in a concise format so
for example if the bigger system is on
the right the system that are shown is
Treasury the switch would convert the
messages from there in one invariant to
into the single format now that's
already a quite a significant job and
you need to study most economies that
documentation of thousands and thousands
pages long in order to work out how
those translations need to happen
anything needs to look after the
security of the messages now inside the
switch we've got compiler that we called
implants now what is essentially a
logical component and it connects to a
specific institution so if we've got a
connection to MasterCard we would create
at least one endpoint that talks to
MasterCard and that runs the most ikot
variant we'd have another one for Visa
and so on now routing is essentially a
set of database tables that um tells you
that if you receive a primary account
number with this bin the prefix of 36
digits then send it on to that system or
do the following with it but also a
subsystem in there called
store-and-forward
which deals with
failure cases so for example if the
issuer system is offline or it doesn't
respond quickly enough
MasterCard would send you a message it
says we have declined the transaction
please reverse whatever it is you've
done in your in your Treasury and the
store and forward subsystem is
responsible for taking that message and
delivering it regardless of how long it
takes
you could have limit logic which has to
do with for example preventing that
preventing someone from making more than
14 productions a day that's primarily
for purpose preventing purposes you
would have the encounter the accounting
reconciliation subsystem which we'll
talk about in a short while I'm security
which deals with checking that messages
are or ivalice
so that the person other then that
entity that sent them usually signs
these messages digital signatures in the
security system would check that these
things are valid and then the duplicate
prevention logic that I've already
discussed and then it connects onto our
DBMS and HSM all the security modules
now reconciliation is a very very
important process in the switch now
imagine we've got three different
financial institutions and during the
day
each one of them sends messages back and
forth that results in debits and credits
to accounts so credit if you receive
money debit if you send money now the
switch maintains a set of reconciliation
totals for every what we call a
reconciliation period so as I've used
the numbers 89 and 90 to indicate this
so every time that the switch sends a
debit to a financial institution or
credit to a financial institution it
increments those values and then if you
add all of them up in the end the devid
should match the credits if they don't
you've got a bug or you've got a stuck
message or something like that now this
is the way in which you ensure that all
transactions are always captured so you
can easily detect that there are missing
transactions of transactions that have
not been captured by checking the
reconciliation titles now the
reconciliation totals
all maintained on in lots of different
places every financial institution
maintains his unsaid to switch maintains
one for all internal components it
maintains additional totals for each
institution it's connected to and it's
also forwarded to the backing systems
for checking that all the transactions
been received um
that's been pushing into the queues for
capturing so this is really really
important obviously it's not as
simplistic as I've shown you here you
need to keep track of the number of
transactions you keep track of how many
have been reversed there's also a multi
currency issues involved there are
issues with synchronizing the different
accounting periods but that's all
functionality built into a switch now
one of the interesting problems that
that switch and payment companies need
to consider is disaster recovery so I've
already discussed the active active
topology that we used on all that we
built in the payment system but in a
traditional system it's it's it's normal
to run in a primary and a and a disaster
recovery topology so you would have your
switch the single switch running in the
primary data center and all the
transactions would be sent there I mean
if something would go wrong with that
data center you would have an outage of
power failure there would be a procedure
that you'd invoke and you would switch
over to the secondary data center the
disaster recovery site and boot up the
sandbox which now in order to do this
you typically need to migrate and
replicate your your your databases from
primary to secondary now fortunately the
switch has only got two types of data it
means to replicate obviously
configuration as one and the second one
is the information dealing with
transactions that are in flight or just
completed so in in the in system like
the dukkha what we would do is we would
have database setup for example
Microsoft sequel server and we would do
the replication based on the database
but in the payment system we we had this
to the in decide link to do this in real
time so this is one area that that when
you build the payment switch that you
need to think about very very carefully
so I'm going to move on to the last
section of my presentation and this is
to do with looking at actual messages
that flows in a card payment system so
this this is the typical messages with
CMT dukkha system so ISO 85-83 is useful
card payments so this is the the
protocol that's used when you interact
as an ATM an automated teller machine
withdraw cash or when you make a payment
in a shop or restaurant now ISO 85-83
has to do has got four major classes of
messages those groups of messages the
first one has to do with authorization
so authorizations what happens when you
make a payment so as soon as you did so
the merchant would go into the point
sale device he would enter the demand of
of the payment I would ask you to swipe
your card he would enter your pen and
then of course device would send an
authorization request to the payment
system so I would easily end up in the
MasterCard or Visa networks and Visa and
MasterCard would then forward it on to
someone like Jukka and it would get into
the payments which in this case the
Erlang switch did you go it would open
up the message and decide whether that
Kartal has got enough funds for that
payment and then either prove or
disprove it presentment is
it's about banking the funds moving the
funds did the presentment messages are
used when you withdraw cash in an ATM so
you can imagine you already get the cash
immediately so that money has taken off
your bank account immediately
there's reversal messages which has to
do when things don't work out so for
example if Dukat would take too long to
respond the reversal messages would kick
in and then there's a fourth class which
you're to do with inquiries so these
messages are used generally when you do
a balance inquiry at an ATM and so on
now an ISO 85-83 message consists of
three major area of it carries three
types of data first is the type which is
a four digit integer number which
indicates whether it's authorization or
presentment and then is a thing called a
bed map so it's a it's a 64 128 bit
binary structure that has a flag that
indicates the presence of specific data
elements so for example the the number
on the front of the card is called data
element 2 card number and so the bit -
if that's it
DD - is present and so on for data
element 4 which would be the amount and
for 4 mag stripe cards data element 52
so this
needs to understand these formats and
what's what makes it really hard is that
it is the first Alma it's almost
guaranteed to be different for every
type of switch or payment institution
you connect you so switch has to
understand all these different messages
now
I'm not going to show you a binary
message but this is what the decoded
binary message looks like so you can see
on the top left there's a I think Alden
MTI
and it says 100 so that's code for this
is an authorization request and then in
middle you can see all the data elements
DB 2 3 4 7 and so on to te 63 and then
to the right of that is the values of
the data elements now the first one to
the card number you'll see that it's
it's been masked out in the middle so
it's not a complete power number that is
where PCI compliance comes into play
it's necessary to do that because we're
not allowed to show these messages or
that the panel goes to anyone and it
can't be recorded so the switch hides
the fool card number data element 43 is
also interesting because that contains
the name and the location was the
merchant so if you see a name on your
credit card statement that name for that
merchant is transported in data element
43 and the master God specification and
then um data element four there's an
amount you can see right at the end this
is 200 that is that would represent an
amount for two pounds so this is what
the mess to just look like and they they
are a vast number of these things that
you need to understand and there are
rules for for dealing with each one of
them so this 100 message would be sent
from the merchant all the way did you go
system and Yuka would receive this I
look up that that card number in date
element 2 J key there's at least two
pounds of funds available if it is it
would reserve the funds and then send
all the way back responding with a 110
message so that looks a little bit like
the following diagram so I'm not going
to go through the whole thing but you
can see on the left here that the the
merchant ended in a transaction of ten
dollars the point of soil device would
then interact with with the cardholder
asking for pin saying through a 100
message the acquiring bank forward to
just switch to another switch would end
up at the issuing bank or in this case a
to touka ticker would do the check for
the ten dollars I don't reserve it and
then send 100 and then message all the
way back and whenever the point-of-sale
device gets that hundred and ten message
receives it would then print out
the receipt now the money's not moved
yet so this then this is the first step
in the process so by the end of that
value maybe even two or three days later
the merchant would go into a
point-of-sale device and you press a
button since I'm now banking this money
I'm saving it for settlement I mean it's
an entire new set of messages that flows
from the point-of-sale systems back to
to touka that that actually leads the
transaction and that triggers the
settlement process so they are in some
of these specifications there are many
dozens sometimes almost a hundred
messages that you need to support in the
switches and that makes this very very
interesting problem to solve so that
brings me to the end of the formal
presentation so I'm gonna hand over to
Lada now I'm he's email addresses on the
screen now I mean I think we're going to
take a few questions thank you thank you
Rudolfo Thank You Shawn and I'm sure
everyone will join me in thanking you
for a very inspiring comments and
obviously in regards to next-generation
payment systems now I'm glad to say that
we have received a lot of questions
during the respective thoughts and
hugging by the time we have available I
can already see that we will not be able
to all of them try and provide a couple
of answers one of the interesting
questions that have just arrived it's
concerning PCI compliant compliance and
disaster recovery in depression is
effectively asking them with the
restrictions on storing PA ns how can
one ensure that split transactions
actually survive a disaster so I guess
either Rudolph or Shawn can address this
once again the question is with respond
storing PA ends how can you actually
ensure that quick transactions will
survive a disaster this is Shawn
speaking sorry I was just going to start
off by saying that as an issue
which obviously to touka is we have a
necessity to store the full card number
but PCI compliance is obviously ensure
that we store those encrypted and they
aren't actually in the switch itself but
stored completely separately as part of
the core accounting system only the
system is that uniform all the switches
in between are not allowed to store the
card details at all and we need the card
numbers though to actually match that
transaction that we receive up to the
account that needs to have the funds
diverted from it I can also say
something I've got to gather that in my
presentation there's a technique called
tokenization where you can substitute
the pan that's printed on the card for
another placeholder number and use that
in your databases so if you have a way
usually that's done through photography
you can do a translation from a fan
number that's not valid so a token do a
real pan number and that's essentially
the the accepted way of dealing with
that so you would translate this number
into something which is not usable for
payment so it's it's it's it's not in
the route able and and that's how you do
that
balkanization is the answer Thank You
Shawn and thank you root of one of the
questions that have just arrived is
quite interesting and coming from Hector
Hector is asking do any of the solutions
we've discussed supports ATM or ABM um
okay this is rid of ATM can mean two
things so on ATM is a communication
protocol but it can also means automated
teller machine so I'm assuming this is
automated teller machine that you
referring to Hector and in in the case
of the the card payments which yes ATM
transactions are very much part of your
day-to-day operation and that's one of
the first things we've implemented in
2004/2005
it's it's it's slightly different from a
card processing using the 100 message
sequence that I Sharky in that the
clearing of the transaction happens
essentially immediately excellent well
thank you Rudolf ah another question
that I'd really like us to sort of try
and address coming from Michael Michaels
asking allah is said about Erlang
capability to run updates without
downtime now he's specifically asking
how true is that in real-world business
practice so how how realistic is this
capability of our line to run updates
without downtime in other words to
perform hot carb-loading ok I'll take
that um like I said it's very easy to do
small updates you don't have to do a lot
of pasting so we deploy one patch file
at a time but as soon as you do
something more significantly in Erlang
so where you want to deploy an entire
distribution a whole system at once I
would recommend that you do a lot of
testing before you do that so you would
still really taste that your upgrade
works properly
and you would spend a lot of time doing
that before you do it in operation so in
telecom systems the the hot upgrade of
system reused essentially all the time
but it's because they test extensively
in my experience it is sometimes easier
to design the system that it's not so
that it's not stateful in a way that
I've showed you with the payment system
so that it's easier to take one switch
offline upgraded while it's offline
bring it back online and state is
migrated then to you to try and do a hot
code upgrade and just you just sorry to
reiterate something I previously
mentioned in terms of just small bug
fixes is actually something that we is
essentially the client of the system
doing a regular basis so we'll receive
just a small patch file from the negraph
is providing it and implemented in real
time just
taking the system down at all and
obviously you would monitor carefully
after that is sure that hasn't broken
anything rollback if necessary but
assuming that there were no further
problems it wouldn't notice the impact
whatsoever thank you for that Rudolf and
Sean one final question we can
accommodate is an observation and a
question so Sheena is saying
lying is massively concurrent but also
known as a slower language so can the
concurrency of Erlang would make up for
its lack of speed in high-frequency
trading environments where extreme speed
is pivotal well I'll take that one and
that's not okay in a high-speed trading
which is something very different from
what we've discussed latency is more
important it's not speed so there are
numerous sources of latency and in
systems and you would have to deal with
that for example if you've got a slow
Network that adds hundred or 200
milliseconds of latency to your system
you will have to deal with that along it
is not going to be your bottleneck but
when you get you to like none even
microsecond lightin sees you you should
be able to do that in our lying if your
hardware is fast enough and I wouldn't
worry about that we've had a few
customers that's that's actually using
our line for our frequency trading and
yes they had to work hard to do to get
it to perform but it was capable of
doing that but that's no different from
any other language thank you thank you
Rudolph and thank you Shawn
we've had a fantastic talk and the time
has sort of run out on us there's many
more questions to address and we will
commit to answer all of these questions
and send you an email response to
everyone who hasn't specifically had
their question answered now to sort of
close off the webinar again please join
me in thanking rudolph and shawn for a
very inspiring talk many thanks to all
of you who have joined us for the
webinar please join us again on
september 17 for our next webinar which
will be dealing with the
distributed key-value datastore you will
have a chance to hear about the superb
scalability the high availability and
the fault tolerance of reactor as well
as how easy it is to start using it on
dedication I'm really glad to say that
we will have with us Alex book the
technical director and systems architect
at Google communications as well as Runa
scoreless in a senior consultant from
Phi Hawk where Alex will be speaking
specifically about how react can perform
from the perspective of its daily usage
in Google's business practice and where
Runa will address the topic from the
point of view of deploying react across
customers projects and news cases now
following today we will be sending you a
short survey to make sure we capture
your feedback of today's webinar please
note that the recording of this webinar
and the presentation that we'll share
today will also be available for you to
collect on airline solutions is
corporate website at WWF and solutions
comm thank you once again and we look
forward to seeing you in our next
webinar</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>