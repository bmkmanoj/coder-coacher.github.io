<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Polyglot in the Code - An Elixir/Ruby Mashup - Johnny Winn | Coder Coacher - Coaching Coders</title><meta content="The Polyglot in the Code - An Elixir/Ruby Mashup - Johnny Winn - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Polyglot in the Code - An Elixir/Ruby Mashup - Johnny Winn</b></h2><h5 class="post__date">2014-05-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Fy3eXXDuuAA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so thanks for the introduction here my
name is Johnny win and i work at hash
rocket i know i guess you guys probably
aren't familiar with that it's a mainly
a ruby shop we're located in our home
office is located in jacksonville beach
florida but we also have offices in
chicago and boulder now we're primarily
a ruby shop so but we also do iOS and
Android development so my main focus is
sticking with web and mobile
applications that being said we're
always trying to keep eye out on new
technology and just so happens that
elixir has caught my eye starting last
summer and since then I've on and off
again kind of taking on little small
projects so Justin tlie announced a
couple of libraries that I'm trying to
contribute to like I said we do a lot of
web applications trying to do some
internal stuff with it one of the things
that we use a lot is Hamill I don't know
if you guys are familiar with Hamill or
not so i wrote Calliope which is a hamel
parser for elixir then i also did a
couple smaller libraries in flex for
inflections and Chronos was actually one
of my first libraries that I tried to
write to handle dates I know we were
kind of talking about how much I love
dates in Erlang I guess that's kind of a
universal problem but they seem to be
extra special other than that I also am
a curator for or the curator for elixir
fountain it's basically a weekly
newsletter that goes out it will be
going out today goes out every Friday
and basically died sum up everything
that's happened in elixir I get into
some Erlang like I'll announce the
releases and things like that major
releases if you haven't signed up yet go
ahead and sign up you can also follow it
on twitter so some relevant information
some of it you know now I play semi-pro
rugby for a the USA ARL the Jacksonville
Axman I also train muy Thai That's not
me by the way
I'm the guy kicking so just in case you
were wondering and also like long walks
on the beach live in Florida so you can
follow me on twitter at johnny
underscore rugger that's where the
record comes from everybody always asked
me where the writer comes from so yes
it's from the rugby days so I also blog
on hash rocket com / blog I try to do a
weekly thing that's been a few weeks
since I've read on it called the elixir
cauldron where I actually do some
comparison between Ruby features and
elixir now there's a few more relevant
tidbits about my life that'll kind of
help and kind of see some motivation
behind this talk or at least it's going
to drum up some sympathy for me um it's
just like sharing I have seven kids I
have a beautiful and brilliant wife that
we actually homeschool most of them or
at one point in time most of them have
been home schooled 3 are currently still
being homeschooled needless to say we
spent a lot of time looking at different
learning methodologies and trying to
figure out how to best teach these kids
most often that trying to transcends
into my professional life this being one
of those cases so why am i sharing this
stuff about my family well because I
like to share pictures of my kids see
their some more of them no not really
stay with me i'm actually going
somewhere with this i'm so the first
time i gave this talk i told the story
of when they were younger actually this
is the pitcher is everybody knows if
you're a parent how many people are
parents in here most people you have
kids especially dance you always have
this idea in your head about events and
you remember them certain ways this is
not actually the event that i'm talking
about but it's one such event this just
happens to be a pitcher they were young
about this age and they used to
experiment they would do something very
similar to this they would throw a bunch
of stuff and the thing and they would
say they're cooking and they would make
stuff and you know being a dad they made
a mess well my wife had always tell it a
little differently you know she said
that there's a learning experience
you learn through play and each time
they play they would go back and they
would learn a little bit more and they
would build on those skills that they
had they picked up a form so it's
important to remember our prior
experiences even as we get older and
build on those as we move just like the
kids we're all noobs at some point like
they were saying earlier I mean you know
I don't know how long you guys been to
an erlang or if you're new to elixir but
at some point you were learning and you
had to find something to kind of hold
onto to help move forward and so whether
or not it's cooking or learning a new
framework or learning a new language we
tend to fumble around with things until
we find our way now my wife and I aren't
the first to notice these patterns as
much as I'd like to take credit for
being that brilliant there's an
education there's the theory of
constructivism this is actually kind of
a known theory that knowledge is not
acquired it's built so over time you
build on the experiences that you have
and you can learn more from your
successes than your failures and that
really kind of goes back to an
evolutionary standpoint when you think
about it if you're trying to learn how
to build a fire does it matter how many
times you've failed and how many ways
you failed or does that win time you've
got to write so you want to kind of
build on those experiences so if you
look at learning as building it only
makes sense to add a scaffolding and so
you can gather the resources around you
that are going to help support you in
your next learning experience ironically
scaffolding theory came around about
language acquisition and that's what
we're going to talk a little bit about
today e-excuse me so the scaffolding
includes any type of resources or
templates or tasks that you might
compile when learning
and it's and they're going to help to
bridge your knowledge gaps me being a
rubios I took Ruby and learn to lick sir
but I mean I also built when I learned
Ruby on things i knew when i was doing c
sharp and prior to that vb.net and prior
to that pearl and PHP you tend to build
incrementally on your knowledge so the
idea of the scaffolding is you gradually
add it over time and you modify it and
then eventually you remove it when the
necessary skills are in place so what
does this have to do with the liq sir
well to tell you the honest truth it's
just a premise to show more pictures of
my kids see there's one right there
needs more scaffolding I mean if you
guys remember that needs more cowbell
thing that was awesome so the thing with
the liq sir is it still young language
and it's still maturing and when I first
got into it back in June it was kind of
frustrating I was like well this isn't
here and this isn't here and you know
you can't really step into something
necessarily and it's a hey this is great
it's fully featured I've got everything
I need especially when it's that young I
mean the lecture itself I think is only
four years total now if anybody can
correct me on that it's a good thing
josei and Dave aren't here because now
so over time we're going to put that
scaffolding in place and whether or not
it's early and dependencies that you're
depending on or rubygems you're going to
change that over time and eventually
you're going to remove those
dependencies and elixir will stand on
its own so this talk actually embodies
these theories it's itself a scaffolding
for your next for learning elixir so how
do we get started
well we're going to discuss the
resources that we're going to use the
elixir resources that we're going to use
but we're also going to discuss the Ruby
ones since we're laying factory assume
that everybody is erling somewhat who
knows Erling most people really oh let's
go because we're not gonna talk about
any early but there will be one slide
that you'll need kind of but I guess you
won't really need it how many people
have seen the lick sir how many people
have used a lick sir how many people
have written web frameworks that are
currently going to be discussed in this
talk there's one so good news there's
lots of elixir in this talk and how many
people know Ruby good okay that's good
so you'll probably enjoy this so Ruby
actually gives us a big advantage when
we want to try to learn a new language
because it's dynamic and flexible you
can actually use it alongside in
parallel with another language or you
can actually inject it right into it
we're going to actually use a scenario
where we use the mix the mix tool and
we're going to actually run our Ruby
inside of it so you'll actually be able
to take advantage of the current
environments that are running an elixir
so the first thing we're going to talk
about is just enough elixir
in this section we're basically going to
go over some of the common elixir
features we're going to look at how Ruby
compares one of the things that they
talked about earlier this morning which
is kind of running I'm sitting there
listening to it I'm going wow is this is
egg way into my talk sometimes it helps
when you actually look at a new language
to see how it compares the features that
you have and ruby has a lot of very
functional properties and structures so
we're going to take a look at some
comparison with that and we're going to
look at some of the things that we need
to know about elixir looking to look at
the rest of the code will finish this
section off by putting in place our
tools or elixir tools to build our
application and then we're going to add
a touch of Ruby so well fill in the gaps
with Ruby we're going to cover sass
everybody's familiar with sass correct
we're going to cover behavior driven
development with cucumber capybara and
our spec and then we're going to finish
up with some migrations with active
record now one can argue that ecto has
migrations and yes there are testing
frameworks already in place there's X
unit and elixir but sometimes now grant
this is also a moving target so when the
talk was originally written some of the
stuff wasn't necessarily where I wanted
it to be but it wouldn't be much of a
polyglot talk if I just talked about the
elixir tools that are there too so we
have we're actually going to have to
sprinkle in some of the some Ruby to
kind of cover some of those gaps and
finally
my super spiffy slides are running slow
on me there we go we're going to mix it
all together so we're going to take a
look at the application we're going to
put our tests in place we're going to
get those tests to pass and then we're
actually going to go back and do some
refactoring and we're going to look at
some bits of that we can take advantage
of and refactoring some of the elixir
code depending on how much time we have
so let's get started with there I know
it's gonna happen i'm going to click
this thing too many times one time
that's going to jump five slides so bear
with me so let's get started like any
modern language elixir has a count or
console tool called IEX similar to IRB
if you're familiar with it and that's
mainly where we're going to spend a lot
of time right now but we're going to
start it's a functional language we're
going to start by putting the fun and
functional it supports but named and
anonymous functions although that's
similar to Erlang there are some
differences I don't know if you guys are
gonna pick up on these but we'll talk
about him anyway can everybody see that
probably not maybe oh no I should be
fine hopefully so here we have an actual
anonymous function where we do something
pretty simple it's uses the keyword FN
pass it a parameter pretty simple stuff
but this shouldn't be in a new concept
to rubios because we have lambdas and
prox it's the same sort of thing you can
actually define a lambda do basically
the exact same thing minus the FN and
move on so it does look similar yeah
well there's actually a blog post where
I cover some of this with the functions
out on the hash rocket blog now there's
some stuff that I do like you typically
wouldn't do the greet dot but that's
another way to call lambda you could do
call but then it doesn't really look as
much like elixirs if you do it this way
so yeah I do what you gotta do you know
now there are some differences in the
way these work so an IRB we can do
something because we have the global
object we can just create a named
function and execute it and then boom
it'll give us the output if we try to do
this same thing in IX we're going to run
into a problem
I thought I was typing faster than this
I swear here let me go help no it
doesn't speed it up at all yeah we're
going to get an error so named functions
in a lecture have to actually be within
a module now we can do this if we create
a module and then put that named
function within it execute it and then
call today trust me I type a much faster
than this one it's not in a presentation
now it actually does better indentation
Ruby tends to not do the indentation or
my RB doesn't it always just kind of
drops it kind of funky and then we go we
call it execute it and it said hello
viola everything is awesome lego movie
fans okay we'll move on so funny story
about I tended like through our little
stuff like that and I did a talk on a
lick sir a couple weeks back for one of
the local user groups and i put in New
Kids on the Block reference in there and
I didn't realize how old that made me
sound that I put a new kids on the block
what was worse is I was the only one
that found it funny so everyone who's
that guy oh I'm getting old um so this
would typically be where I would talk
about pattern matching i really wish i
would have kept the pattern matching
stuff because i thought i was gonna be
talking to a bunch of earlier so i just
kind of put this slide in here these are
some of the differences the way that
atoms are declared the way the variables
are declared there's no periods at the
end which is kind of nice but there is
an end there's always an end and you can
check out more if you want to see the
differences you can actually go to our
Erlang elixir laying org and look at the
crash course and I'll kind of show you
some of the differences
so now everybody's favorite and
functional topic is recursion is
everybody can see that right does that
look okay to everybody does everybody
understand what's happening there
essentially you're just basically
looping through each of the items in the
list until you finally get an empty list
and you sum them all together this is a
common pattern and functional languages
different ones implement it slightly
different but this is using a method
arity or functionality to iterate over
the list so should seem pretty familiar
this is probably not going to work I
don't know if you see that number there
this is actually Ruby and we're talking
about 50,000 we're going to take a
basically make an array of 1 to 50,000
and then we're going to pass it in and
try to get it to some anybody get an
idea what's going to happen ah yeah
stack level too deep so well there's no
way possible then that we can do this
and Ruby is there well yeah there
actually is as of 192 Ruby actually
ships with tail call optimization rolled
in it's just turned off by default so
you can actually enable it through a
compile-time flag or you can do a
runtime option it looked kind of kludgy
for a tox line so there's another way to
do it you can actually use the reduced
statement now what this is actually
doing is the reduced statement goes to
the top of the loop and 10 sends control
back over to it so it essentially starts
the thing over now I've actually added
an extra 0 here and when we run this we
get our number recursive Ruby
so before we get too much further let's
move into some elixir and we're going to
throw throw in the old mix I don't know
if you guys are familiar with mix if you
guys use it if you're working with
elixir much you had to have it's
basically the equivalent of closures
line again and it's used for a number of
tasking type things you can bootstrap
your electric projects with it manage
your dependencies you can compile and
you can use it to execute your test
suite makes uses configure our
configurable environments though and to
scope your compilation settings and this
is going to come in handy later
especially when we start wanting to fire
off our cucumber features so let's look
at a mixed ask mix you know generally
has like new test depths these are a
series of the the most common ones but
you can also do custom task I don't know
Chris does this look familiar this is
actually Phoenix's knew I didn't get the
whole thing it's a little bit longer but
it's just to give you an idea how you
can actually go in create your own mix
task when you compile this the myth the
phoenix dot new will be available to you
to run through mix and that will set
your project up for you there's a couple
other ones one of the ones that we're
going to look at is routes so let's
start and throw together our Phoenix app
we have a Phoenix app and then we're
going to do our mixed depths get trust
me this does keep downloading but we're
not going to watch it we got stuff to do
no see I told you it did now we can
start this by running mix run e we pass
it the the router and start give it a no
halt and give it the the mixed out exs
and boom we have everybody every
programmers favorite thing to see hello
world we should really change that to
say gotcha or something I don't know so
but looking back to this and no offense
to Chris this is a little bit verbose
for me I don't want to type that every
single time I'm a lazy I'm developer
right so let's write our own little mix
task we can actually do a custom mix
task that where we take and we put
basically that same thing and pass it
off through mix shell to the command
line and it will spin it up for us so
now all we have to type is once we
compile make server start and boom our
servers running pretty cool I had to use
the rise of the phoenix sorry there's
just you just can't get over that right
i mean that's too perfect so let's look
at our web framework phoenix it's one of
the newer web frameworks is rapidly
gaining some following I'm a little bit
biased I've done some contributing to it
currently I'm working with Calliope on
it to try to get the compiled templates
to help speed up some performance and
actually Calliope runs really fast
anyway but everybody keeps telling me if
I compile them they'll be even faster so
that's basically what I'm looking for
them currently it's a work in progress
but its goal is to be a full-featured
framework and to build fault tolerant
applications we're going to look at some
of the boilerplate stuff real quick just
to give you an idea this is basically
what that new builds it gives you a
router yes I know this is not current
but for the sake of this talk this is
what it does
so it basically gives you a router that
supplied the does it using for the the
Phoenix router and we supply a port we
also have access to the macro get which
will set up our set up a route the route
is basically the path the controller
that we're going to use the in or the
action which is going to be indexed and
then how we want that to appear in our
routes which is the ass page so we're
going to add a couple static pass to
this because we're going to use style
sheets so this is actually the dispatch
will actually send these over to send
these static pass to cowboy through us
now it actually uses plug which is like
a middle we're sort of thing between
your elixir web framework and your
cowboy so when we run our mix routes we
see our route page get it's basically
our root path let's take a look at
controllers I'm sure you guys have all
done tons of rails development right
okay so you've seen this before maybe
not the text part but huh almost
identical you know rails does a lot of
things really right for it you can say
what you want to say about it but it
does a lot of things really right and
having a controller it's very simple
this is pretty beautiful so yeah
essentially that's our controller we use
the Phoenix controller setup our action
and then we can move forward now what
I'm actually using for this and so if
you go to my github and you pull this
project down and you want to take a look
at it I'm actually using a forked
version of Phoenix because i have
Calliope in here so remember Calliope
Tsar hamill parser it's supposed to be
Calliope as in the muse the Greek muse
Calliope if I'm saying it wrong just
grin and smile and everything will be
fine
so here's actually my implementation of
the first pass we've got line 11 is
basically our Hamill call it's really
just going to take and run a compile are
the Calliope render it's going to pass
in the string Hamel and then it's going
to take the any type of prams and
combine it with any type of arguments so
that Calliope can actually run through
it does do it protects against cross
script cross server scripting we've got
if you wrap your calls everything is
cleaned all the arguments are cleaned
prior to evaluation but if you put this
safe dot script in your hamill it'll
actually not it will assume that you're
guaranteeing that whatever is going in
is fine and just kind of execute it this
is a bit of code that I wrote doesn't
this looks so clean like you see these
like huge you know methods all the time
and most languages but the nice small
functions are pretty beautiful if you
want to see Calliope in the wild outside
of this project though you can look at
are you guys familiar with the elixir
sips yeah if you the beam project he's
actually using my fork and he's been
using Calliope with it hasn't had any
issues he does he actually solved the
partial problem by pre compiling and
then passing in his partials so he
basically does his partials sends them
as his arguments into the nether and to
the next one and so that they kind of
keep going through so I would check that
out if I were you
you know and one thing that I was
thinking about doing was taking it if
you notice it's Calliope not safe and
all the evaluation and the escaping is
in one file now it's one module and I
was actually thinking about extracting
that out I love the idea of having very
small libraries that do things and then
just kind of pull them together I know
some people are like oh that's crazy
then you got all these dependencies but
to me it's like have one thing that does
it's the UNIX mentality have one thing
that does it really well and then focus
on that and then you pull the pieces
together that you want and so it's in
the process of possibly being extracted
but I mean then again i take pull
request if you want to extract right
yeah i just put it in like about a week
and a half ago I don't know do you
remember it was a couple weeks ago
something like that so yeah and I
haven't actually updated the docs on it
yet I don't think that was my bad but
I've had a whole talk to give ya so hi
I'm just kidding so let's go ahead and
add ecto sorry no I'm now you gotta
watch my time ecto dependencies are easy
to add in you just go ahead now then the
kicker which most people forget is to
add the adapter if you add the adapter
it's kind of gives back that whole
programmers don't redox sort of thing if
you read the dogs and says right there
at it just remember to do that otherwise
you'll give yourself a headache well it
gives you database interaction so you
may it's like a data map room if you're
familiar with links and tax from
Microsoft's link linq it's got that same
sort of layout where you do like the
from something where select it's kind of
a little backwards sequel sort of thing
we'll look at it in just a second so
what's missing so how many of you guys
write tests everybody writes test right
yeah well we do so that's like an
important part of what we do we're
consultancy so a lot of what we do is
we're building applications that we're
passing off to another team and test can
be part of your documentation it says
how the system is supposed to work
so putting tests in is pretty important
and it's nice to have them easy to be
easy to read if you're from you're
familiar with cucumber and the the the
gherkin syntax given this then they win
this then this that's that's something
handy the other thing is is there are
other testing frameworks hound being one
of them that does integration testing
which is relatively new i haven't had a
chance to actually get into it and try
anything with it i would like to look at
it I me because there's always a
possibility of adding a Gurkha and type
syntax to something that exists like
that the other thing that we're going to
deal with is data migrations I mentioned
ecto has data migrations but we're going
to be calling a lot of our stuff from
cucumber and so then we would it would
be much easier just to have active
record we do a run on migration through
active record that being said the idea
is to we're going to eventually pull
this stuff out and then have a full lick
sure remember we're just building a
scaffolding so it's time for a touch of
Ruby so Ruby really shines because it is
flexible and it's an established tool we
know that everything that's in it that
we're going to put in it we can count on
we can just basically say I'm writing
that one off I don't have to worry about
my cucumber stuff I know it's going to
work I'm not fighting that plus
something else and it can not only run
alongside your elixir code but it can
also run in the same environments you
can inject it and then run it in the
same environments and so let's start
looking at our Rivi solutions we're
going to start with sass which I'm going
to kind of go a little faster through
this so I can make up some time because
you guys are mostly rubios and you guys
are probably all familiar with this
stuff so the sass you know it's sassy
remember our makes the first thing we're
going to do is compile so we need to
make sure that it actually builds the
CSS so we're going to go back to our mix
task that we did and we're going to
actually make sure we compile prior to
now in if you look at the code that's
out there on github for this project I
also went as far as to add CoffeeScript
and so what I did was I actually pass in
flags and if you you
by default it loads everything and tries
to look for different directories
essentially what i'm doing is i'm giving
it the pass to the SAS files and telling
it where to put the CSS and then i'm
just running it but I mean CoffeeScript
is basically the same thing so you can
pass in different arguments and it
basically just loops through whatever
arguments are there so that's simple
right so let's move on to something a
little bit more complicated as the are
the behavior driven development part
everybody's familiar i don't have to
really go see I had this whole little
bit here while gonna have to go over and
explain what cucumber is and talk about
the little rats from South America they
don't have to do that so we'll make up
some time so to cumber capybara and our
spec you guys know it you love it you
want to use it all the time we're gonna
go ahead and add them once we bundle
we'll be on our way now keep in mind
capybara wants to control everything
they're very powerful rodent so we need
to actually stop it we need to say
you're not in charge of running the
server we go ahead and add this false
flag and we tell it where the app host
is going to lie this is really just that
port that we said now we could do it we
could start up a separate port if we
want to get really fancy so that when
Phoenix started up we could depending on
the run time environment we could give
it a different port so we could run on
testing and we could run on and we could
run in development but that's a little
bit much for this we're going to do
something similar to that and see how
that would work anyway so we're just
going to run on the standard port the
other thing is is because it's not the
default behavior we have to give it the
selenium driver that way we can actually
drive that browser
so once we have our tests that are
cucumber stuff in place we can go back
to the test under school or helper which
is basically for mix to run the test it
starts up X unit so we can just go ahead
and drop the start for the router we
only want it to run within that test
process so we don't want it to stay
running after that process dies we just
want to get it started it'll run through
the life of a mix the mix test process
and then it'll drop and I'll go away and
everything's fine so we need a test so
our first test that we're going to do is
we're actually going to just call out to
that command line again and we're going
to say run cucumber well what that does
is remember we're starting test in the
mix test environment so everything that
runs is going to be based on that test
environment capybaras should pick up on
and that all on everything so we write a
test this is a pretty okay test it's
basically we get a list of posts
everybody loves a good blog right we're
going to give it some that are published
and some that are unpublished and we
only want to see the ones that are
published that should be a good test so
now we're going to move on to the
database schema anybody have any
questions about the that should be all
pretty standard stuff for typical stun
them now we're going to use active
record but active record of course here
having a little spiel about what active
record is because I'm assuming that I'm
talking to a bunch of earlier so I'll
skip ahead to that we just basically
need a rake file set up so we're going
to add our active record an hour
postgres if you just call active record
for for you actually have to add the
builder dependency to a specific version
just so you know that's a little hang-up
that's why I have builder in there
separately the dependencies don't work
out right which is kind of odd
um I don't know it's blood I guess if
you see my previous talk which I don't
know how many have you have any of y'all
seen this talk before okay good oh well
this is great so this is all new stuff
for you guys so what I've done is I've
actually put the support models folder
so i can actually keep all my ruby stuff
all nice and neat in its own little some
little spot i'm going to loop through
that i'm just going to require that it's
every time rake runs so that anything
that inherits from active record
migrations i'll have access to it so
then i can actually call connection i
can establish my connection to whatever
database that I need to call with a
configuration file and then here's this
actual loop for the descendants where
any descendant it's going to ascend to
that model the direction it's going by
there and so here we have the top one is
actually just the standard DB my gray or
DB colon migrate and DB colon rollback I
just say down and give it the original
spec that's just my configuration to go
if I for but if I want to put it in test
I can just merge the database that I
want so when i call that everything is
scoped to the test database and i use up
and down very rails like so we can go
ahead and here and i call these to
cumber post because it only really
exists for the sake of cucumber and a
type of is basically for fabricating
cucumber objects in the database so
we're going to actually go through here
we have it down we have it up as long as
long as your migrations have those it
will call them and you can add as many
of them as you want here so we'll run
wait wow that was kind of act like yeah
anti-climactic
I don't know how about some fireworks
that's better than a lot cooler wouldn't
it yeah wouldn't it be awesome every
time you ran rate DB my great you get a
little celebration if everything went
right so yeah well just trust me it all
work we've established trust now right
come on so we're ready to address our
step definitions and one so we'll throw
our steps in here together this is all
pretty standard stuff we're going to
we're going to visit the homepage we're
going to check to see if certain content
is there certain content shouldn't be
there now the kicker one is the the
table which we're going to need to
actually fabricate things so what I've
done is in this cucumber posts I've
added the ability to initialize it and I
can pass in a hash and then iterate over
that hash and build out the object then
I can pass that into insert and it will
actually go through and insert the
record so i can give it at a tartan take
that table i can map over it and for
each one of those rows i create a new
cucumber cucumber post and then insert
it into the class method insert and
viola
so now the one last thing before we do
this is we're going to end up creating a
whole bunch of Records every time we run
it so we want to make sure we do clear
I've actually put a clear method in
there I don't remember if you actually
saw it but it basically just deletes
everything so when that after everything
is run we just want to loop back over
those descendants again keep in mind
already loaded and we'll just send clear
which should clear out all of them and
clear up our database then if we run
this
we should have a failure yeah our
cucumber stuff failed it's almost like I
knew that was coming too so let's mix it
all together the quick recap where we're
at we set up our Phoenix project we put
our integration test suite together we
added our migrations and we have failing
tests so now we're ready to go implement
a solution so let's put our elixir hats
on and kind of look here first thing we
need to do with ecto is create a repo
now remember I said that everything runs
in particular makes environments what
we're going to do here is we're going to
actually when this is when this worker
started up we're going to actually grab
the mix environment and use that to
build our URL to the actual database we
want to connect to and then just right
there at the end just interpolate the
database oh I'm running slow hurry up
here if I yet so we're going to kind of
go through this a little bit faster uh
yeah oh wait that's what
now one of the things that you need to
do is make sure that you start that repo
up so we can add it as a worker for our
supervisor for a Phoenix project so that
when you start the Phoenix project up
it'll start ecto up and the repo we can
start using the repo sorry I'm going to
go a little faster cause I'm running out
of time we have our ecto model which
essentially we define what's queryable
in it we give it the posts the different
fields and set the types there's our
beloved date time but it also separates
that all out into the actual data the
behavior and the storage we have our
repo or model in our quarry module so
what we've done here or what I've done
here with the query module is I actually
do an all which would pull all the
records and then I do a filter on that
to actually just pull the ones that have
been published so let's hit our
controller real quick we can take that
those queries published pass it as the
argument to our hamill we're going to
read in the handle document which we'll
look at in just a second so you can see
and then we're just going to render that
out now our Calliope does not handle
it's not fully elixir compliant I so to
speak it does in lines script
evaluations so if you can put it on one
line it will evaluate it for you and
give you output and it also does list
comprehensions I hit those two areas
first because they seem to be the ones
that would be most used and need to be
implemented before you could ever do
anything so it actually takes that now
the one thing that say I'm going too
fast and I didn't one thing to note on
here is this filter map I'm actually
taking the record that comes back from
ecto and I'm turning it into a tuple
that makes it actually easy to handle in
the list comprehensions plus two it's an
easy way to clean the data for me for
Calliope so
that whole lazy programmer thing this is
this is the ecto that link syntax that I
was talking about from basically here
over that yeah that's ecto syntax and
basically you define the query and then
you pass it to get all and it just
execute whatever than that I could do
some stuff where I have like the
published method does just get published
records and then that it's trying to
extract it out a little bit the idea
that at some point I could build yeah
with my free time all those kids yeah
active actually I was actually part of
the elixir laying the general repo so
it's right now let's the preferred the
data access layer sort of framework
integration the mapper so it's basically
the one that most people are using it
only uses postgres though there is what
well there's works people are talking
about getting an adapter for my sequel
and things like that my thought is
actually trying to do a middle piece
that basically will take any type of
sequel AST and generate code for
whatever database that you're trying to
that's another side project at some
point right let's get back up to where
we want to be so now if we run mix tests
are we gonna pass yeah we pass so let's
wrap this up real quick um yeah because
I'm running out of time so you really
got to wrap it up so this is all pretty
good but I think we can actually make it
a little bit better one of the things
that we're going to look at that I
really want to refactor is the test
suite if you notice when this ran the
output from it
other than seeing that pop of them if
you can look really quick we see them
the test run but we don't really see
like if you saw the other way we didn't
see the output from cucumber to say it
failed yes it it popped up a message but
the the mix did not fail you saw the
r-spec messages but you're mixed test
did not fail so that's you know for
somebody that's just looking at this
real quick you might not even notice you
is what if you do pretty and you don't
actually pay attention to what's the
output is you could totally miss that so
let's refactor that real quick and go to
our test now this is a anything to know
what there's a couple key things to note
here I switched that she'll to a module
this mixed shell is a module and there's
in that module a command that command
takes two arguments one being what
you're executing and the other being a
function for callbacks so you can
actually get in it then what it sends
back is the data from the data as the
output from the command that you just
ran so what I do here is I actually as
data comes in I look for this line of
code because it's the one thing that I
can say no matter what you're going to
have failed steps and so if I look for
this I can refute that it didn't happen
so if it comes back as false now what
I'm gonna do is I'm going to break a
test and run this again and we'll see
our output
what I actually did to break the test
was I made them all publishable now I
know that something failed which is
pretty cool mixes very powerful and it's
it was when I first got into elixir it
was like one of those things I just kind
of pushed aside I was like all right
I'll deal with that later sort of thing
now that i've been using it for a while
i'm getting more into it and doing more
with it and it's a really powerful tool
to work with so there you have it here's
a quick introduction to the polyglot
lifestyle i hope you guys all enjoyed it
if you want to learn more about a lick
sir here's a few things you can check
out the elixir lang sigh of course lots
of good stuff the docs they do a
phenomenal job of trying to get the docs
easy-to-read elixir sips episodes I know
most of you have heard about it a great
thing check out the Phoenix web
framework the docs are really good for
that he's actually even got at the
bottom of it like a to-do list sort of
thing and what's checked off and what
isn't and so if you want to contribute
Calliope I'm always I love feedback so
if you have any feedback for me or if
you want to contribute you're more than
welcome to check that out and then the
ecto project so derive like 30 seconds
okay just as a final wrap-up you know in
listening to the talk this morning
languages are going to change there's
always something new to learn there's
always you know you can't just sit up
yeah well we're this inclusive group and
we're only going to ever do what we do
because we do it right well but you want
to bring people into the full I was the
guy not in the letter but I was the guy
two years ago trying to learn early and
I had like 5 10 minutes here 5-10
minutes there and I was like you know
what it's just not time wise i'm not
going to use it daily and so if i'm not
gonna use it daily i don't have the time
I can't even see the benefit because I
can't get into it and when I first
started using elixir the docks were like
really easy to get to jersey made
himself very available if i had
questions or things like that in fact
actually when i gave this talk get Ruby
comp I had made the mistake of updating
a bunch of stuff right before my talk
and he actually helped coach me through
figuring out what the changes were that
were actually causing me a problem
that's why if you notice everything is
in a slide the last talk I did I
actually was supposed to pull up my
browser and show the app in it and
everything was broke so it's like this
time I'm doing slides so but yeah I mean
that's the thing is is it we need to if
we can build a scaffolding around our
learning experiences and Ruby is a great
tool for that it'll it'll ease that
transition we can kind of say these
things are taken care of I don't need to
know how the testing suite works I don't
need to know how data migrations work I
can just focus on what I'm learning
right now and then get to the point
where I can remove those other things
when I feel more comfortable in the
language and that's it yeah
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>