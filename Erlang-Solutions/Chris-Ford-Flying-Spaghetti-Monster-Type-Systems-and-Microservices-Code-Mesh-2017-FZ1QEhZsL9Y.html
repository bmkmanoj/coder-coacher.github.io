<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Chris Ford - Flying Spaghetti Monster - Type Systems and Microservices - Code Mesh 2017 | Coder Coacher - Coaching Coders</title><meta content="Chris Ford - Flying Spaghetti Monster - Type Systems and Microservices - Code Mesh 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Chris Ford - Flying Spaghetti Monster - Type Systems and Microservices - Code Mesh 2017</b></h2><h5 class="post__date">2017-12-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FZ1QEhZsL9Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">cool thank thank you everyone so the
title of my talk is obviously a little
bit of a joke but hopefully the rest of
the talk won't be so the Flying
Spaghetti Monster
is the deity of a joke religion
Pastafarianism and it's a reason I think
in 2005 well something like that as part
of a satirical response to discussions
about intelligent designers of
philosophy versus natural selection I
think it actually makes quite a nice
mascot for conversations about
distributed system and software because
I guess unlike the real world we don't
get to go one way the other with
intelligent design and evolution my
evolution especially in micro-service
architectures is a fact of life we
cannot even in our wild architecture
average how fantasies live in a world
where the single mind conceives of a
whole system and that's just it on the
other hand we do need a bit of
intelligent design because unlike
natural selection we can't really you
know tolerate countless deaths in a way
to to get to kind of the design that we
want so the conversation I want to have
with you today I'm gonna use address as
the medium so he just is a hipster
programming language it has static types
it's functional so if you're familiar
with things like Haskell with F sharp
with Scala you probably know a bit about
it I'm so like those languages the
compiler checks the type so it's not a
dynamic language it's in fact very one
with a very expressive type system it's
also one way of functions of first class
and that's probably not something that's
very surprising to this audience we've
kind of got to the point in the industry
where the idea of functions being passed
in as arguments being returned being
calculated upon is it's just par for the
course but the feature that idris has
that not all these other functional
programming languages do share is that
types are also first-class so by that I
mean types can also be passed as
arguments can be returned and
calculations can be done on types and
they might seem at first to be a
slightly weird idea I think probably
first
class functions may have seemed like a
weird idea the first time some of you
saw them but it turns out that it's
actually a great simplification to not
have to treat the world of types in the
world of values as distinct worlds so
once you get used to it I think you'll
actually find that it's a simpler model
of understanding programming and maybe
just like with first-class functions if
you do end up getting used to it you
might wonder what the fuss was ever
about so you have the pleasure today of
hearing a talk potentially by one of the
great experts on interests in the world
his talk is a twenty-first for this
afternoon his name's David Kristensen I
on the other hand of a great enthusiast
of a dress so I think that it's a really
interesting programming language it's
really helped me understand the kind of
the nature of types and and proof to a
much greater extent than I did before if
you are like me and you want to become
an enthusiast about it this book is a
really excellent book on programming in
general Andy dress in particular so just
like I would say all great programming
books it starts with a specific subject
matter so how a dress works how
dependent types work and broadens it to
become an actual philosophy of
development so it does explain how you
evolve a program with expressive types
it gives you hints with how the editor
works and just how your workflow it
works so if you're someone who is like
me quite enthusiastic about this but
isn't necessarily deeply steeped in the
academic work on the subject I really
recommend this book so the motivation
for my talk is as Bodil kindly pointed
out microservices so we're going to
start with my kind of cottage definition
of microservices but I think one of the
big problems with conversations about
microservices is definitional all right
so it's it is a buzzword right everyone
talks about doing it everyone means
something slightly different so the way
that I would define microservices is
that by their very nature they're about
shrinking or abolishing transactions on
many different dimensions so the obvious
one is at runtime processing data so if
you have a cooperative set of micro
services responding to a user's request
perhaps some things operating
synchronously
other things operating asynchronously
then you're actually dealing with a
series of events rather than one big
transaction that you might in a Model S
you can also change code a little bit at
a time so you could see this as a
transaction in the evolution of your
system over time if you have a monolith
you can change everything in one go you
can add an argument to the function you
can add an argument to all the cause of
that function in one transaction one
deployment in a micro service
architecture that's not true and finally
you can understand systems a bit at a
time so the human factor the ergonomics
of micro-service architectures makes a
different trade-off the idea is that
each piece becomes simple to understand
so my colleague James Lewis who talks
about micro-services jokingly says the
the right size for micro service is
something you can fit in your head so
it's not just a division based on
technical concerns but also the human
factors but whenever you get rid of or
shrink transactions and do things across
transaction boundaries if they're for
accepted the burden of having to
coordinate of having to manage the
eventual consistency so you're going to
have to deal with partial failure what
happens if one of the bits of the data
that you're processing succeeds and
others fail you're going to have to deal
with what happens when you have an
ecosystem where people are in different
versions of the JVM or different
versions of programming languages and
you're gonna deal with the fact that
while you've broken things down so they
can be understood one piece at a time
you still need a way to zip that
understanding back up into an
understanding of the whole which I think
the biggest problem that I encounter at
the moment so this is one of my favorite
pieces of programming folklore any
sufficiently C or Fortran program
contains an ad hoc informally specified
bug-ridden slow implementation of half
of Common Lisp now on the surface this
is kind of a pure I'll like language
Wars thing so I definitely don't want to
engage with that but I think the
underlying point that Greenspan is
making is that if you incremental e
evolve a system adding complexity over
time unless you achieve breakthrough
abstractions in how you organize your
thoughts and how you understand them
you're gonna end up
in in pain you're going to end up with a
problem so I see this is a way of
talking about computer systems and
having to bridge the gap between that
evolutionary angle and the intelligent
design angle if you don't come up with a
way of thinking about it the equivalent
of the Common Lisp abstraction you're
gonna kind of just incrementally get
more and more spaghetti and I think that
that that applies to micro-services very
strongly so any sufficiently complicated
microservice architecture contains an ad
hoc informally specified bug-ridden slow
implementation of a distributed protocol
and that I think is a problem because
distributed protocols are hard anyway
you know understanding how paxos works
is kind of a proverb for you know
straining your intuition yet this
architectural practice which we do for
very good reasons
puts a lot of extra burden on our
ability to understand distributed
protocols so we're actually in a way
playing to our weaknesses here if we
don't achieve this breakthrough
abstractions these better ways of
thinking about things then when were in
trouble
and I'd say that narrative is not enough
so I think that industry best practice
austere standard I use best practice
kind of skeptically is that when you're
being taught about how microservice
architecture operates it's done through
narrative someone sits you beside a
whiteboard and tells you the happy
potentially fictional story of a good
request - gets everything they deserve
and has a happy ending and that's a
great an important part of communicating
information as developers but but it's
not enough and I think probably
companies that do this really well they
kind of have non fictional narratives as
well so really good observability is
also a very important way of keeping a
handle on the complexity of a micro
service architecture but I don't think
cue a narrative of just what stuff
happens after what is enough to get us
out of this hole so one example of an
actual useful abstraction of the
protocol level is finite state machines
and when I'm talking about the protocol
level here I'm talking about application
protocols so not tcp/ip although there
can also be abstracted with finite state
machines but the kind of protocols that
are about how the bits of your system
that you've designed bespoke operate
together and cooperate to achieve your
business goals so finite state machines
can
model protocols it might be something
that a few of you have already familiar
with I just put this comparative picture
up because as I was googling for FSMs of
diagrams of finite state machines it
struck me that just literally the
structural similarity of both this
Flying Spaghetti Monster and an ordinary
finite state machine was kind of
striking so a finite state machine is a
system where you have one or many
meatballs that represent states of your
system and strands of spaghetti that
connect them together that tell you the
legal transitions so in this particular
case of the door you can open a closed
door you can close an open door you can
knock on a closed door but for example
you cannot knock on an open door that's
something that's not allowed by this
protocol this abstraction
I'm finite state machines aren't as
expressive as general-purpose
programming languages and that's a good
thing because the less expressive your
abstraction assuming it meets your needs
the easier it is to reason about so if
you can have a slightly simplified model
of computation if your common protocol
can fit into finite state machines that
means that it's easier to reason about
there's less of a burden on the reader
so in our programs we often do actually
have finite state machines whether or
not we model them explicitly so this is
a little bit of I guess kind of pseudo
JavaScript that works with that door so
first we open the door then we're not
gonna than we close right and if you're
paying close attention to what is legal
with the door you might notice that this
is actually an incorrect program we open
the door and then we knock on it so in
the case of really agraria stipe errors
so for example if this snippet of code
had a method that did not exist that
would actually be something that's quite
easy to detect and using normal methods
your unit test would crash in the middle
of it or something like that
but when we're talking about incorrect
sequencing even ordinary or naive
application of type systems isn't
sufficient to capture that but there are
ways of doing that so there is a
technique developed by Bob at key called
index monads I prefer to think of them
as dominoes I guess you can kind of like
you've got known as common as dominance
because the key element is that they
track the state at the start of the
operation and the end of the operation
so a door session is a data type in
interest
like the calculating types here it's an
algebraic data type so there are four
ways of making a door session you can
have a not action and a knock action
takes your state from close to closed
you could have a closed action which
goes from open to closed and you can
have an open action that goes from
closed to open so each of these actions
has three type parameters one thought
what the action returns and two for the
start and end States what the bind that
kind of double Chevron equals thing at
the bottom does is it applies the domino
rule right so if you place Domino's in a
line you have to make sure that the
number on the end of the Domino matches
the number the number on the start of
the next Domino you have to line it up
like that because that shows you that
you're legally progressing through the
finite state machine so if you see just
down the bottom you've got no closing
open that's kind of a domino
representation so if you're not familiar
enough with that kind of static
functional programming syntax just think
about it in terms of the dominoes and
you'll have the relevant bit for this
talk so if we try to render that
incorrect program we saw earlier will be
not too late that will be a compilation
error in this particular case so the
dominoes are lined up down the bottom we
started in a closed state we opened it
so we went from a Domino from 1 to 2 and
then we tried to knock but that breaks
the Domino rule and because in this case
the compiler is enforcing the Domino
rule it's able to tell that this is an
incorrect program so if we did do it
though right correctly then we've got
the green there the Domino rule is
obeyed we've knocked first so we've gone
from close to closed then we've opened
it close to open and then finally we've
closed again so we've we've got where we
need to go we've traversed our way
through the finiteness state machine
without breaking any of the rules and in
a way that the compiler is able to check
so index monads are quite useful for
this so there is a concept that I've
heard that I think is a fallacy
especially in micro-service
architectures that I want to I guess
talk about which is that if you have a
network boundary it makes the idea of
type systems irrelevant so I can see
that's kind of a seductive concept
because types just
degree in force what's going on in your
own program and then as soon as you get
it out into the wide world you could say
well you know what help is that but I
think it's actually not quite true so
what I'm gonna do in I kind of guess
time-honored rhetorical fashion is I'm
gonna set up three strongmen and then
I'm gonna spend the rest of the talk I
guess a knocking down my own straw man
so forgive me of that same
self-indulgent but first of all you
might say that types can't help you
because of FAL ability right if the type
is about everything happening in the
right order
just like my earlier example with
knocking on the door then when things go
wrong in the real world doesn't that
mean that you know it doesn't that mean
that we're outside the type system we're
off the reservation nothing is gonna be
checked anymore
I'm distribution is another problem so
if I do have this kind of like cast-iron
mathematical guarantees how do I make
sure that everyone I'm working with has
them there might be other teams working
other parts of the system there might be
people evolving systems over time how do
I actually distribute these protocols in
a way that we can consistently have a
common view of it other than narrative
in whiteboards and reciprocity is
another interesting one because when we
have these protocols across systems
people aren't all playing the same role
so you need complementary interactions
to get to the right place you can't just
distribute the same kind of series of
actions and expect everyone to do
exactly the same thing they've got to
cooperate before I get into just the
knocking down the straw man I wanted to
go back to this picture of the flying
scary monster pilot part because I think
it's a work of genius if you're familiar
with the ceiling of the Sistine Chapel
this is a you know a Pastafarian version
of that I'm but the bid I wanted to call
attention to this time when we go back
is is the white space between the Flying
Spaghetti Monster and Adam because I
think that actually that detail in this
painting
well definitely in the Michelangelo
original but also here is the really
interesting poetic part of it so they're
not touching right they're interacting
they're trying to communicate they're
trying to reach an understanding but
there is a gap between and an
unreachable gap there's always going to
be some room for the network to get
involved or for there to be human
misunderstanding so regardless of how
well your states in your flying
spaghetti monster implementation work
you always have to deal with the fact
that there will be missing
understanding and that you don't have
that omnipotent control over your system
and I think that's what good is going to
distinguish successful type applications
to the network from unsuccessful ones
that if you see types as a way of
controlling everyone else so they don't
do the wrong thing that's not a
successful philosophy what you need to
think about types as is a
self-discipline so that your system does
the right thing regardless of when
things go weird or things go wrong so
it's a way of making sure that you've
done everything you need to do to be
robust in an uncertain world not about
imposing your will on other parts of the
system which i think is actually a kind
of a an ivory tower architect philosophy
that just doesn't work in a rapidly
evolving system
so first availability so this is really
important because failures happen in all
sorts of ways so this is the first
sentence of Anna Karenina by Leo Tolstoy
that every happy family is alike and
every unhappy family is unhappy in their
own way so you could apply that to
requests the Anna Karenina principle
right so a successful request might
follow that simple path and that's
really easy to whiteboard really easily
unit test really easy to system test
it's the multitude of combinatorial
unexpected failure cases that really
makes this hard so a simple way of
incorporating failure into our finite
state machine model is to have
non-deterministic state machines so in
this particular case and I've borrowed
this from Edwin Brady's book on interest
the door when we're trying to open it it
might Jam so we try to open it we can't
assume that that's happened because this
might be a literal door that we're
interacting with it might be you know
Internet of Things enabled or in our
living room maybe the battery has run
out and maybe there's something in the
way so we have to deal with that
circumstance so at the finite state
machine level or we can we can draw that
and it turns out that at the type level
we can also account for this with a
little bit more subtlety in how we
define our times so in this model which
is a bit more sophisticated of the legal
types of a door
we can still construct the door session
by knocking but what happens is we go
from the closed state to another state
determined by a function of the result
so that exit state is no longer a
constant value it's a function
so in the case of knocking we always end
in a closed state so just constantly
return closed in a case of closing the
door what we always assume that succeeds
in this model so that is the constant
function closed but for opening a door
this is where we get a little bit more
type through their door session of
opening returns of all it starts in the
closed state and depending on the result
of that ball whether it's true for
successful or false for unsuccessful the
exit type will be either opened or
closed so we're actually I said earlier
that we had first-class trip so we're
gonna do calculations in our types this
is an example of where we've actually
baked into the type of the action this
ability to handle what actually happens
in the real world so it's not so much
the types can't handle fail ability as
naive types can and so if you have an
expressive type system you can get there
you probably don't need to follow up
with the bind has been the the
combination operator down the bottom has
been slightly enhanced to make this work
but it's still fundamentally following
the Domino rule so if you think about
what this actually means back in the in
the Domino world it's a it's a
multiplayer game of dominoes right which
as I guess the fun kind we knock on the
door and that's fine but then we have to
handle the case or both cases of when we
try to open the door so what this says
that is if the open returns true we
continue on the program and then close
it so we end up in the closed State
that's fine if it's not the case if it's
false then we do nothing as the door is
is closed
so basically what we're saying is
regardless of which Domino at the top
our opponent the real world the horrible
real world with all sorts of things
happen regardless of what Domino they
play we can make the line work out
either if they play the jam one then
everything works out because we're
always closed or if they play the open
one then we know that we need to close
the door to end up in the right state so
that's the way that at runtime
we've got checks because this is
definitely still a compile time series
of checks but they guarantee that we've
covered all the cases we need to Atlanta
alright so the second one distribution
one particularly I think perhaps
underrated in bin
that exists in the type world is type
providers so I think they come from the
f-sharp world so probably done some who
deserves the credit boy in the f-sharp
world they hook into the compiler and I
think generate byte code so you could
actually potentially generate in invalid
programs in the F sharp world but what
happens is that they operate on any kind
of schema so if you've got a JSON schema
or an XML schema relational schema it's
actually a pain to go through that
schema and create stubs to statically
type it right so you have to keep those
up to date you might break them you just
don't really would have to deal with it
because that should be automatically
inferred you've got the XML schema there
why do I also have to maintain kind of a
stub file that says what the name of the
attributes are its kind of just a waste
of your time
so what Don Simon realized was that you
could do that automatically
so at compile time it reads in that
schema and it generates those types so
Idris also has that and in fact in
interests it's very easy to think about
how type providers work because he dress
already calculates types calculating
types building them putting them
together pulling them apart it's just a
normal language feature so the only
thing that was needed to happen to
implement depend type providers in a
dress was just to allow that at compile
time some of these operations to do some
IO so I'll show an example there is a
proof-of-concept that I'll give a link
to at the end but it's a sample text
file for what you can do with a vending
machine so it's not written in a dress
at all
but I can import those text file
transitions that says you know if we
insert a coin we can go from waiting to
paid if we returned a coin we go from
paid to waiting the Select can fail
because they might not be a chocolate in
the vending machine
so select goes from paid to either
selected or just stays at paid if
there's nothing of that item time and I
can consume those types within the
program as though I've written them out
in interest itself so I do insert coin
and I try to select and this actually
can potentially assuming enough
languages get on board with this this
could potentially help to solve the
problem of distributing protocols that
can be type checked across a system
because if you've got for example an F
sharp and an interest system at least
you could potentially generate the same
set of interactions that can legally be
type checked from the same schema so
this is an example of how saying that
you cannot distribute types when you
have a multi-language environment ain't
necessarily so it might be that we don't
really have the pieces in place now but
it can be done right so the last thing I
wanted to talk about is reciprocity
because there's some really interesting
theory here so I've got a protocol and
two parts need to cooperate if they do
the same thing then they'll deadlock so
they have to have complementary
operations so they're known in
literature session types so I'm only
going to talk about a very brief
introduction to it the most much
simplified but what session types can do
is represent from a global perspective
interactions of a bunch of actors so the
example I think I read in a paper most
recently was around an auction so
there's multiple bidders there's an
optional administrator and they all have
to do the right thing in order for the
right outcome to happen one of the key
advantages of session types is they can
be projected to local representations so
if I'm one of the actors in this
multi-part system I can I can do a
calculation that gives me an account of
what I personally have to do to be on
the side of the right and the good and
it turns out that this might be slightly
surprising that assuming everyone does
the right thing by their local type you
can check and get that make guarantees
about the system as a whole so an
example of where you might want to do
session types is for example if you have
your channel that you're sending and
receiving so at the top I have session
state and I build it by creating almost
a list of types that I send and receive
so I can send is one operation that
takes an existing session and Chuck's
are send on the front of it receive
takes an existing session and also
extends it with a receipt of something
accept and select are interesting
because they deal with branching so
accept means I'm going to allow the
other party in this interaction to
choose which branch we go down in the
protocol so I'm going to allow them to I
know select the size for us lately use
case so that's actually something that
is another
example of the non-determinism I need to
handle because I don't know in ahead of
time what my client is going to ask of
me and select as if you're the active
party in that choice so you can go down
one one branch or the other and finally
there's a constructor for if a session
is finished and depleted so the trick
you get for and this is only for dyadic
sessions I'm not going to talk about the
multi party example here if you've got
two people talking to each other it's
very easy to basically flip the session
the states around so that the person on
the other end has the complimentary set
of operations so dual is just a function
I've written to do that so the dual of
sending an A and then continuing with
the session is to receive an A a
continuous session right the dual of
receiving an A and then continuing is to
send an A and continue the dual of
accepting either any ami-nee
is to select one of any or Meeny and the
dual of an empty or finished session is
clearly just an empty or finished
session so well that's lets you do is to
define the type once and then flip it
round to apply it to both the client and
the server so if you think of it
addition as an example of where I know
why you would need an addition server
let's say you have an addition server it
receives an integer it receives another
integer and then it sends the result
back so that's kind of the protocol of
states it means to go through negation
well that just takes one integer and
returns an integer back so the protocol
we have as a whole the calculator
protocol is that we as a server accept
because we've got this wide range of
features we accept either addition or
negation is something that we're willing
to do for the clients so if we want to
create a calculator someone who actually
consumes this we don't need to
separately write the types or the series
of actions and hope that they're
consistent and hope that there aren't
any deadlocks
we can generate the types for the client
based on what the what the server has so
the calculate ease type is just the dual
of the calculator type so it's another
example of of using calculations at the
type level to achieve things that you
might not originally have thought work
were possible so in the end what it
means is that you end up with
complimentary state machines on both
sides of the of the network so the one
on the left is the server so it has
receives
in the place where the one on the right
has sent and so if they both sides of
that follow the right thing and both
sides check their protocols then we know
that overall things will work out
there's much much more theory in this
area much much more complex that's just
a general introduction to the fact that
you can have the concept of global
protocols and project them to individual
roles in a system so in conclusion I
want to make the argument that we're
building systems that we don't fully
understand so in in particular in micro
service architectures but not just
micro-service architectures that's just
the example that i've encountered most
strongly
we've got situations where because we're
evolving different parts at different
rates using different human beings and
just communicating what's going on
through I think mostly narrative we
don't fully understand what's going on
we don't fully understand the
implications of the decisions that we're
making we're creating bespoke
distributed protocols that manage small
pieces of big transactions and that's
really hard even in the case of well
understood protocols that have been
studied for years by people who are
experts in it but we're creating these
on-the-fly we're creating even
unexpected ones that only exist for a
short period of time when we've upgraded
one part of our system and not another
part of our system so I really think
that that's a strong argument I can make
for the present that we don't fully
understand the systems we're building I
think that leaves you naturally to the
next point which is that we do need
better ways of understanding systems
like that we need breakthrough
abstractions we need better ways both to
communicate our expectations amongst
ourselves and also ideally to check that
they're right but it's both of those
things it's not just a machine
verification that I think is important
here it's also to just get better to
level up at explaining to each other
what's going on when we have a big
system with many fallible moving parts
and I don't think we do that well at the
moment I think that it is a fallacy to
say that types can't help us once the
network gets involved like I think it's
a really easy thing to say in a really
easy thing to to believe but because of
this concept of self-discipline because
of this concept of the types can guide
you and all the legal actions you can
make and all the things
have to check to make sure that you're
adequately acting within this system I
think it's definitely true to say that
types can help us once the network gets
involved now I'm not making the claim
that types other solution to micro
services or anything like that what I'm
saying is that there a meaningful
contribution to the debate and a
meaningful contribution to the toolkit
things like monitoring observability has
many other important aspects to making a
robust system but I do think that types
are worth thinking about when we're when
we're looking about how to build these
systems better and so in the in the
spirit of continuing to follow the
finite state machine metaphor this is
code mesh right so many people are
talking about quite similar and
interesting ideas probably in greater
depth than I've gone into today
so if you're really interested in the
verifying of finite state machines um
Oscar is giving a talk about how to
apply that to languages you probably are
going to be allowed to deploy to
production for example Haskell
I think this let his slot is immediate
after this one so if you're interested
in the detail of encoding finite state
machines and index monads in Haskell and
pure script then I would go and check
out Oscar's table if you're interested
in dependent types so the first-class
types that you can do all these
calculations on David Kristensen is
giving a talk on that this afternoon and
if you're interested in channels and
those kind of formalisms around
concurrency I believe that Michael
Sperber is giving a talk and current
email tomorrow so those are the legal
transitions to go to from this talk if
you're interested enough in the subject
to continue there are many references
that I've got here I've kind of cobbled
together my own superficial and
beginners enthusiasts understanding of
these different topics for many
different papers if you're interested in
it all the links are online and if you
want to follow up on the example of the
dependently typed type provider that
read in from the text file and generated
the types that's on github as well and
in this repository as it happens thanks
very much
Thank You Chris that was very touching
we have got time for a few questions
thank you very much I was wondering in
your experience how deep how long are
the session types for example you give
us the type of the calculator and you
said the calculator would first add and
then subtract but that's actually it
would either add or subtract so yeah my
hunch about session types is that we get
pretty simple session types where there
is a union of possibilities and there is
a little interaction for those
possibilities and then we go back to
square one
that's something I think that's a very
good observation that the sessions that
I observe in practice are not long live
they're often for example just a series
of interactions on the basis of a single
user request so they're not often kind
of cooperating long term like that so it
could be scoped to requests or possibly
sometimes to subsequent actions that are
triggered off so I've seen you know
systems where the single user request is
around an application for some kind of
financial product or whatever and that
does involve potentially a cooperating
series of of states that get dealt with
asynchronously afterwards but most are
quite brief and definitely the session
types that I think you'd observe would
be scoped to a particular request not as
I've misleadingly kind of implied a
global session where there's a state
so you I have to forgive her or the
basic question but it's this in the
situation where I've got an interest
program which has been written in such a
way that my session interaction is
muddled in in real life I'll have
something on the wire some Jason or
something yeah which is the actual
protocol itself how does what you're
talking about help me in establishing
that when I receive from the other party
is well was well formed so if you're
asking how do we make sure that what we
get from the other party is well formed
it's not so much that you can make sure
that it's well formed as that you have a
well-defined path to follow if it's not
well formed is the way that you would
handle it so yes something comes in it's
a blob of Jason you want it to have all
the fields you need for your particular
processing you don't know whether or not
it does you could for example pars that
and return a some type that either
returns a value or that return some kind
of error in your finite state machine
you could have a state that said I
receive a string and then depending on
whether or not the string conforms to
what I need it to I go down a success
path or if not I go down a failure path
and the nice thing about doing it at the
FSM level is that you might be able to
do things like work out how to do
compensating transactions so if what
comes in you can't pars and that means
you need to cancel some other order
because you need to restore consistency
of the state you could make sure that if
it's not a valid JSON string you don't
just crap out and log you actually do a
bunch of cleanup actions okay I suppose
really after is is really is this a
magic going on here certainly not a
silver bullet no okay okay okay so that
it's not as if I I'm having to do less
work in order to establish that the the
input or the thinking for the wire is is
yeah you're not gonna have to do less
actual computation right but it does
give you maybe the explain it would be
it gives you guardrails for making sure
that what you do in the various
situations that come into you right
you've covered them right you know I
would say just as a general statement
because I as it happens also being
someone from thought works I'm very
in other ways they're verifying programs
like test-driven development and so on
but I would say that where types are
really shine are when you have some
types that give you alternatives because
when you've got a combination of many
different alternatives keeping track of
all the combinations of those is very
hard so what they do is allow you to
kind of have guardrails that make sure
that you've thought of the cases you
need to think of okay thanks very much
sorry we're out of time I just like to
add that if you mean to follow Chris's
advice about going to the Oscars talk
that's happening in room two right now
in about five minutes</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>