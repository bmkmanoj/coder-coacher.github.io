<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tech Mesh 2012 - High Performance Financial Service Integration - John T Davies | Coder Coacher - Coaching Coders</title><meta content="Tech Mesh 2012 - High Performance Financial Service Integration - John T Davies - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tech Mesh 2012 - High Performance Financial Service Integration - John T Davies</b></h2><h5 class="post__date">2013-08-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tw1AKDrOUsE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">what languages because this tends to be
quite a sort of mixed audience here so
what languages have we got predominantly
Java the C C++ real program is cool
other things are laying scarlet closure
sugar well this is going to be fun okay
I'll kick off at a politeness for sort
of kicking off on time what I'm going to
do I'm going to walk you through a
number of different the main parts of
financial services system again this
applies to pretty much any banking
brokerage obviously some of the
brokerages just have the front middle
and they tend to outsource to the banks
for the back office and I'm going to
walk through them and I haven't put a
huge amount of technology in there I've
gone through the messaging so what I'm
going to try and do is annotate those
through the talking in terms of the
technologies we use in those there's
about 35 slides in total and as we once
we go through the sort of scenarios and
setting the scene and looking at the
sort of technologies that we've got the
problem space that we've got then I
going to get a little bit more into sort
of some of the architecture solutions
that were looking at for this I'm not
going to go into code this is not
something where I mean we're talking
about Investment Banking architecture
here and from a talk for 50 minutes
we're not going to get time to delve
into code but if you want to ask or feel
free to put up your hands obviously
we'll finish at enough time to ask some
questions but feel free halfway through
particularly with the numbers that we
got here put your hand up we can sort of
go through some sort of scenarios and
questions in detail my background C C++
assembler predominately low latency high
performance architectures a lot in Java
I've dabbled in most of the other
languages at some points I'm a great fan
of multilingual sort of environments so
I'm certainly not against these so let's
see a huge amount of nets in my
environments
oh that's probably the only part that's
probably out of my scope and this so
just very quickly go through these just
to put them into his concept so you
understand what I'm talking about the
front office is where all the trading
happens this is where the typically the
movies that you see you'll see these
guys sitting at a dealing room with
literally six eight ten screens and
they're all just growing large graphs
they're talking to their colleagues
across the phone across internet Reuters
that sort of thing and they're
effectively waiting for prices or
triggers to change or for someone to
give them instructions to say you know
here's the policy we're going to sell
dollars we're going to you know sell
this particular equity or we want to
come out of energy or move into
something and it's their job effectively
to manage the bank's positions to make
sure that there's not too much exposure
in a particular area so they tend to
follow a crowd and they're instructed to
do certain things so they're the people
where all the energy is and if you ever
get chance to sit or work in a trading
floor it's it's the most amazing sort of
energetic area if you can actually sit
there and code when I started
programming I had the great fortune to
be able to sit next to traders and I'd
code stuff and in those days testing was
basically if it compiled it ran so you'd
segment off a small number of the
trailers you can pilot you just copy it
straight over to the machine obviously
distros in those days but that's that's
effectively where the trades are done
that's not the whole story because that
goes back down now into the middle
office now the middle office is where a
lot of the accounting happens where they
effectively they're managing the risk
for these and they're defining the
policies that of course the the traders
will be will be working on this is where
all of the interaction between the the
clearing etc happens with the
corresponding bank so if a trader has
traded something from Bank a dabangg be
than Bank a and B communicate in the
middle office to make sure that these
things are matchup though finally
typically ideally the same day but quite
typically two or three days later it
arrives on the back office now every
time a trade happens it doesn't
immediately get paid because the traders
will be trading
literally hundreds of trades soft earn
hundreds per per hour and what happens
is we aggregate these up and we make one
big payment at the end so it's all part
of the middle office to try and sort of
aggregate up what the positions are
these things and then finally the
payments happen at the end and of course
overnight in an ideal bank if this is
done in real time but again typically
overnight the process is recalculated we
work out how much money we got in the
bank what our exposure is globally
around the the world what the trends are
what the currencies what the markets
have changed etc and we find out that
we're a little bit long or short meaning
we've got too much of one currency too
much of one particular commodity and we
decide the next day that this is our
policy we're going to get rid of this or
we're going to buy that instructions go
up for the traders they come in at five
a.m. in the morning pick up their
instructions and that's what they do for
the rest of the day so that's
effectively the cycle the back office is
I wouldn't say the most interesting part
personally at least I think things don't
happen with the same sort of speed and
that you find in the front office so in
terms of sort of interest if you wanted
to go and find somewhere exciting start
from the front office and go through the
back if you're one of these people that
just likes to turn up on a nine-to-five
job and back office is probably the
place for you so games a little bit more
detail on these and I'll go through
these in a little bit more I start with
the really high end so this is the low
latency high frequency trading this
isn't so much what you find in the banks
this is the effectively the brokers the
hedge funds to them they work in
microseconds one millionth of a second
the time it takes light to travel three
kilometers if you were to build a
trading engine here let's say it was the
fastest thing in the world worked on
quantum computing or something it would
still not compete with the C C++ trading
engines that are sitting over in the
city or in the Docklands because the
time it takes to travel from Russell
Square to the city exceeds the time it
takes them to do the processing on these
so when these people do trading they
physically put the machines into the
buildings where the exchanges it's that
important it's they look for the number
of Reuters it's not so much the quality
of the copper cable but it's the length
of the copper k
if somebody has an extra coil in the
copper cable in this case someone trips
over it that's causing latency it's it's
down to that sort of level of obsession
the thing is here these guys are trading
unbelievable amounts of money hundreds
of millions billions if they can notice
a difference between somebody buying and
selling something maybe five hundred
million dollars euros pounds and they
can notice the difference of that in
maybe point 1 million twone milliseconds
100 microseconds if they can buy and
sell in that amount of time they can
make a huge amount of money but if
someone beats them to it they could lose
a huge amount of money so it's it's not
how fast you are it's being faster than
the competitors so when we talk about
real time it's effectively making sure
that you are faster than your
competitors and so as the competitors
continue to to work in this environment
the time that we have to process this
becomes shorter and shorter and shorter
and we're now really down to the
completely crazy three kilometers of
Lightspeed time in terms so we're down
to sort of single single microseconds in
this so what's happening is we're
finding that the the processing is
actually done on the network card people
go out and buy cards these FPGA cards
which are effectively gate arrays that
they program says it's now hardware
doing this not software so what's
happening is the the messages are being
decoded in these ghetto raisin which is
firmware if you like and then
confirmations can be sent out we can
aggregate the feeds the amounts etc so
this is this is the sort of realms that
they're working in you can forget Java
in this environment this is this is
really not an environment for Java in
the banks however your average bank they
have a different sort of clear on tell
they're not looking to to perhaps make a
massive amount of money in and literally
a thousandth of a second they're looking
for they their clients are much larger
corporations that one perhaps a lower
but more secure investment so they're
they're not looking for these perhaps
crazy amounts of return for fifteen
twenty percent on their investments
they're looking for a nice regular
steady two or three five percent these
days is quite good
so on your average bankim millisecond is
quite reasonable so if we're working
sub-millisecond that's great if we're
working in 3 5 10 milliseconds that's
generally quite acceptable in this realm
and in this environment we find a lot of
fix fixes the standard that tends to be
used in this area so if we move across
to in the banking environment outside of
this sort of hedge fund environment this
is where we can start to get into the
realms of using languages that
programming languages as opposed to
hardware if we were standing up here
talking about the different cards it's
literally down to the manufacturers as
opposed to the the work that you and I
could do in terms of optimizing this so
what they're effectively trying to do is
to take all of these different feeds
from various different exchanges the
London Stock Exchange New York Stock
Exchange Chicago etc etc they're taking
the prices that are often quoted across
all of these different fees aggregating
them and then trying to if one client
comes in from New York and another
client comes in from London wanting to
buy or sell the same thing if they know
what all the prices are across the
versatile exchanges they can match those
trades without having to go to the
exchange to do that so we effectively
have these crossing networks crossing
exchanges which means they can match the
exchanges with in the bank and that's
effectively what they're trying to do so
these brokers are now connecting to two
very large numbers of exchanges this is
a fixed message anybody I know you
recognize the fixed messages it's not
particularly complicated to look at any
program are pretty much in any language
would look at this and think I could
pass that five minutes work fair enough
yes your posit its tag value pairs
separated by a control a 01 hex
character and as you can see you've got
tags numeric the values are effectively
ASCII strings problem is that this isn't
quite as simple as it seems it actually
has a lot of repeating fields in it so
when you see one of these particular
numbers that might be a field which has
repeated several times it may be much
double payments for example on an
interest rate derivative it might be two
parts of a foreign exchange if the
foreign exchange has an intermediate
currency it might be the three parts by
one currency sell an intermediate by the
intermediate etc so this starts to get
complex give you an idea of this a trade
capture report this blur here is
effectively the trade capture report in
its hierarchy so we have the parent
three little bit so you can just see as
a couple of pixels here on the screen
but we have the header the body and the
trailer obviously you can see that
they're naturally the vast majority of
this blur here is the body of the
message most of these are optional
fields but you have to account for them
if you're going to store these in a
database so you're going to process them
you've got our account for these so if
we look at this one two three four five
six seven eight nine different levels so
we're into a pretty nasty relational
database if we're going to store this
and that's basically the sort of an
enlargement of it so if you're trying to
pass that although you'll be able to
pass it if you're just thinking oh I'll
just create a hash table and create hash
you know hash values in this it's not
going to work because you're going to
end up recycling and we're using
Lebanese so it's it becomes a little bit
more complex middle office is much lower
latency this is this is where things
start to get a little bit easier to
understand architectural but a lot more
complex when it comes to the complexity
of the message that fixed message was
nothing compared with the sort of stuff
we have in in the middle office this is
where if you're if you're doing an
interest rate derivative for example
you've got multiple buys against
multiple cells you're selling multiple
payments over a period of time and each
of those has payments a tribute to it
and when those payments are the
conditions of those and what happens if
you default and what's the amount that
you pay back is in terms of you know how
it's defined and these are defined and I
think all def pml so this F pml itself
is nicely defined so we've moved into
the realms of something fixed which is
basically designed specifically for
low-latency into something which is
defined now which is complex
so the complexity is now in this
particular case defined in schema and
give you an idea of the source of
storage volumes one we're sort of
picking this this this is one of the
problems that we have now if you're
trying to show that you provided the
best execution for example for your
client you've got to store all of the
fixed messages you've got to stall the
prices you've got to store obviously or
your internal messages so give you an
idea of this sort of volumes that we're
talking about a fixed message is
typically a few hundred bites but let's
say it's 512 bytes for easy calculations
100 hundred thousand a second is not
unusual it's quite a common feed so we
can sort of work on that that's fifty
megabytes of seconds now most disk
drives almost all that nice and easy but
that's per channel and you'll have
multiple channels in a in exchange and
then that's across multiple exchanges so
we have one client which has hooked up
to 28 different exchanges and now you're
looking at sort of four terabytes are
now we're looking at one-and-a-half
gigabytes per second even on SSD that's
starting to get into the realms of sort
of difficult so it's the sort of thing
where where you know starting to have
some interesting challenges even with
today's existing hardware for these
sorts of things not only that but you've
now got to generate the indices on this
it's all very well storing the messages
but if you imagine after a year you've
got eight petabytes of data if you can't
find the message that you're originally
looking for you can spend an awfully
long time searching through eight
petabytes of data so you've got to store
the indices you've got a you've got a
partition this up and be able to to work
on it if another thing that you want to
do is you want to do back playing so we
want to store the messages let's say we
have a complex event processing engine
that we want to we've got a scenario an
algorithmic trading scenario where we
want to say well something happened last
week and if we had put this into
practice we could have made some money
and that's the theory so you know how
could we test that well let's take last
week's data and let's replay the data we
had with with this new theoretical
scenario so you've got to then go
back if we're looking at 36 terabytes a
day you've got to go back in and load
that 180 terabytes for the for the
week's data and then trawl through it
and then prepare what you want to test
that scenario so it becomes an
interesting challenge and typically we
do that up in something we load this
stuff onto ec2 and it makes it much
easier we can use the sort of elasticity
of the cloud to process and prepare this
data so we say this is these are the
dates we want these are the the fields
we want or you can prepare that and then
we can send it back down to our local
machine where we can actually run
through it and test it which is
typically what we do so in the middle of
this this is where the complexity is
where you've got sheer complexity of the
messages where we've got banks with
literally tens of thousands of clients
and each of those clients have hundreds
thousands of tens or hundreds of
portfolios each of those portfolios have
tens and hundreds of different equities
I'm sure most of you I'm not sure most
of you in fact some of you probably got
pensions some of you have probably got
investments and those investments will
be sort of ten percent Asia you know
eighty percent European equities or
something like that but each of those
are managed by banks and those they
decide to come in and out of the
different commodities and those
effectively is there's a lot of what the
economists are trying to work out to
make the best return on these so these
things have to be bought and sold the
problem is when you suddenly say right I
want to move out of let's say energy in
Asia and I want to invest in stock in
South America for example it doesn't
just happen right let's let's sell 100
or hundred million dollars of in one and
buy a hundred million in the other
because you have to send out the
instructions and you've got thousands of
traders who are executing these things
and when they put out the orders they're
only filled I there any exchange when
someone wants to buy them or sell them
so you never know the actual price that
you it's like you selling something on
ebay if you suddenly decided you want to
serve sell everything in your room on
ebay you you won't know the price you're
going to get for
it until you've actually sold it and so
this happens in little bits and
sometimes you might want to sell it as a
job lot here's and here's my entire Lego
kit Thank You of my kids here so here's
my entire Lego kit but there's someone
else want to might want to buy it in
little bits and pieces I want all the
red bricks I want all the you know the
the car kits etc so again it's the same
with the trades you might want to sell a
million dollars worth of one trade but
other people want to buy a hundred
thousand of something and you get these
little bit so it becomes very
complicated and this is the this is
where all of the different parts of the
trades need need to be hooked up so the
complexity of this we have a lot of a
lot less messages typically in the tens
to hundreds per seconds and going
through this but you can see the sort of
level of complexity that we get and this
is where we find a lot of grid computing
the banks were grid computing many many
years before cloud was or the name cloud
was associated with what we have today
those days it was fluffy things up in
the sky they typically by thousands of
CPUs and they'd run these things they'd
use coherence gigas basis terra cotta
all these technologies that were around
almost ten years ago now and these have
become common practice the vendors have
now spotted this and that now goes on
into into retail and various other areas
where of course they're selling these
solutions so what we've got to do is to
process these complex events we can't
simply put these five to 15 sometimes 20
kilobytes of single messages into a grid
and expect to process them FP ml is a
good example it's literally I mean 15
levels of hierarchy over 3000 sometimes
4,000 different elements I wouldn't say
a lot of those are optional a lot of
them are actually mandatory so it gets
quite complex than these things another
new standard which has been used more
and more these days and is one of the
most sort of widely used canonical
formats starting to be used across all
of the banks and started to become the
standard definition for all of these
things like
corporate actions is I said 20 or 22 as
the definition of was separate is
defined on this twenties anybody used 20
or 22 here the 22 is an interesting
standard swift originally was defined on
a standard called triple 75 and then 15
no 22 and 20 or 22 is the new one 20 or
22 doesn't define any messages it just
defines the metadata behind those
messages so when you have the messages
that the banks are using for separate
for example for the payments for
corporate actions those are defined
using the metadata repository of ISO
20022 so it's a very good repository for
for defining standards it's a sort of a
standard for standards if you like but
as the European area of the eurozone
they have to now use although the moving
to two separate amons between the
various different countries so it's a
huge change for someone wanting to pay
money from Spain to Germany for example
through a French bank and they all go
ultimately through sever there's one
extra complexity on these messages just
because you can understand the messages
and any one of us might choose any
particular technology like Xerces or
something to parsley it's and there's
loads of technologies in every language
would come to choose from is that they
inflict these mandatory rules on us and
so just because you've managed to pass
the message you now have to understand
and execute these rules and there are
quite often hi tens low hundreds of
these rules / message and you've got the
message but you've now got to say if
this bill has this and this field has
that then you can't have this unless we
have one of those and I won't even
bother to read those out for you because
they're there are about as cryptic as
they sound but you've got to implement
those and so if you end up sending a
message that does not comply to one of
those rules then your your message is
effectively net and you'll get this nice
ird interest rate derivative message
number 57 saying you did not comply to
this rule some of them are obvious you
can
see this you can sort of understand why
they might have those but these are
things that you can't imply in schema
you can't check a lot of these rules in
an XML schema so it's very high
throughput very complex high values and
now we've got these extra rules on top
of it backup is very quickly i went to a
huge amount of this it's the importance
of the sort of what happens in the back
office if you've got a billion dollars
bear in mind banks every single day
hundreds of billions of dollars go
backwards and in and out of these things
every single day if you're late paying a
billion dollars today one percent is not
an unreasonable rate the banks are
charging those sort of rates and
interest you're late by one day one
percent in one day as twenty seven
thousand dollars or if you're doing
sterling its twenty seven thousand
sterling it's the same amount of money
what's worse though is if you're trading
a currency and the currency changes by
in this case the US dollar sterling and
in one day changes from 160 to 161 in
one day that's point six percent which
is not unusual we know this watch the
currencies go up and down sometimes as
much as two percent in a day two percent
of a billion dollars is a hell of a lot
of money by anybody's standards so
that's the sort of reasons why we need
to make sure these things arrive if you
make an error in one of those messages
and you accidentally send a message off
as the bank closes for payments at 429
and you have not it put this particular
message in then it snapped you miss the
payment date and you could potentially
be up for a very serious amount of money
of course the banks have to cover that
so this is why they it's just very
important to make those payments this is
a swift message nothing particularly
complicated about it it's tag value
pairs as you can probably just about
make up tags and numbers 22f for example
the one there in blue 20 see that's the
tag the value is multiple values in this
bit now pausing that is again relatively
simple but as you see it has multiple
so we've got to pass that and map that
into to something but then we've got to
apply the rules on top of that as well
so point I wanted to get to it on this
you're very quickly where does where's
this used now this is a typical bank
this is actually a architecture diagram
stolen borrowed whatever it was from a
from a bank somewhere long enough ago
that it's now no longer relevant and
small enough that nobody's going to
recognize it that give you some sort of
idea simplifying this a little bit we
look at the functional landscape looking
at this we've got the front office the
middle office and the back office
effectively so front at the top middle
in the middle back at the bottom these
are all the different functional parts
each one of these boxes could itself be
an entire project could have 20 maybe
even 50 people looking after it it could
maybe have a thousand CPUs behind it
some of them will just be one machine
some of them are very commonly one
laptop sitting in a corner that nobody
dare touch because it's the only thing
that runs it has been there for 15 years
I've seen I've seen a lot of those quite
quite amusingly and then they say Oh
could we virtualize it and then you
can't find the diskettes that you need
to actually install that particular
version of you know windows 3.1 or
something yes so 311 what was it term
when some some weird version of windows
networking or something but but there's
a lot of those and it's quite common and
we take one transaction all the bits
that it particularly touches the
different types of messages so we see
the fix promptly in the front office a
lot of common delimited files so these
are things we can't ignore blue parts
proprietary XML so these are be internal
xmls quite often iso 20022 some of them
will be f pml and then finally after the
bottom you'll get for example Swift
coming out of there but that's one
transaction in all different parts that
it would touch as it goes through the
bank okay not not too bad quite a lot of
work to do
is that goes across multiple geographies
and lists we're now working in a global
environment so you've now got to manage
your risk and all of the different
payments across all of those geographies
and in each of those of course because
we're working in a banking about the
whole point of banking is that we
exchange money with other people so of
course that then adds all of the
corresponding intermediaries and etc and
again all of those introduce lots of
different standards so they gives you
some sort of idea of the the large
amount of complexity that keeps
certainly myself and gives you guys lots
of opportunity to go into these banks
which still today have all the money
despite the fact that they're very good
at losing it or spending it on houses
that don't exist and those sorts of
things but there is still plenty of
money there and the 30-odd years that
I've been in banking through numerous
recessions they still seem to have money
and because as I said before they
compete with each other and they only
remain in existence while they compete
they they're looking for these
technologies so it's a tremendous
opportunity and quite exciting to to
work in these things to dis ol them and
and you know work in these areas so
let's look at a few solutions around
this and how do how do we sort of get
around some of these bits what one of
the things that we've come across over
the last right now 15 odd years I
suppose I suppose we were doing it you
know even 20 or more years ago but it
was slightly different we were using
macros in C++ in those days and a little
bit sort of slightly different way and
in even in assembler we were doing
self-modifying code but it's getting out
of that into reality in the Java world
we can actually generate Java this isn't
unique to Java obviously we could
generates Carla we could generate F
sharp for example but in the world that
the banks are today they're
predominantly Middle office is
predominantly Java on linux Java on less
and less UNIX but what we can do is we
can generate the Java because the Java
is then compiled runs inside the JVM and
is often just-in-time compiler as well
it runs extremely fast and is almost the
perfect language certainly the imperfect
environments because I saw
the number of people here are not
necessarily Java programmers so when I
talk about Java all right I'd sort of
tend to include scholar and Jay Ruby and
anything else that sits and runs in the
vm but in real life it tends to be Java
will use the dsls on the outside and I
see those more and more coming in but
sitting on the Java side so what we're
doing is we're going back to those
messages you think back to the fix the
the tag value pairs if we can map that
fixed message into a Java message we can
create a effectively a large array of
objects which are which have the tags
and the tags actually have the names we
can call it field eight field nine field
10 except or whatever it may be but when
we want to get those we can use the
getters and setters we could potentially
put those into the the name sir as the
fix protocol defines those messages we
can then map those into the generator
Java code as objects if we then redefine
the serialization of those we can
actually make them very very efficient
not quite as efficient as fix obviously
because it's designed purely for that
sort of efficiency but it does mean that
if it's already in an object we don't
need to consistently repast it out so we
don't have to go through the object
posit as you would with a sax parser in
XML it's effectively like going from if
you're treating XML you've got a number
of options you can use obviously sax
very fast to go through find the value
you want if you're picking up many
values you'd be better to convert it
into a Dom for example where you can go
back and get the values very quickly
Don's aren't particularly sort of
program friendly you've got nodes which
have nodes which have nodes and node
lists and these things and so the the
programmatic approach to that is is
rather tiresome so we tend to use
binding we use a JAX page of X caster
these sort of things and what it does is
obviously generate the code based on the
schema and we can go back in and now
picking up the valley sis is exactly
what we're doing now so we Java binds
fix we Java by and obviously the XML and
we can java bind the swift so that makes
it very very fast and very easy for the
programmers to work with so if we take
the comma delimited file remember going
back to the what we're looking at before
we take a comma delimited file now where
any programmer can pass this in five or
ten minutes start to add a few rules on
this so we could we can add some obvious
rules I'm sure some of you know these
these credit card numbers have to have
what's called a lunch XO they have to
have a mods 10 so basically the last the
last digit means that they have to be
all add up divisible you know with no
remainder from 10 obviously you'll know
from a credit card that the payment
dates must be before the expiry date now
these are rules that you've got to
follow so if you are reading this comma
delimited file effectively you've got to
add these rules on top of it this is not
dissimilar from XML from anything else
so this is just the most basic sort of
stuff so if we can map this comma
delimited file directly at the Java we
can add the rules interestingly though
regardless of whether this isn't a
comedy limited file or XML or fix I was
you're not going to get credit cards in
fix or whatever it may be the rules
remain the same so what you have to
remember is if we go back to a metadata
concept of this if we go into for
example ISO 20022 I'm using credit cards
because it's easier to understand if we
can define the basics of credit card
transactions and payments the rules are
the same regardless of the way that it's
transfer between machines so if we doing
comma delimited files the payment dates
must still be before the expiry date the
credit card number would still be the
same it doesn't matter on the format so
what we now do is we create a metadata
repository that defines what is a
payment dates what is a credit card
number we define rules on the credit
card number we define rules on payment
dates and expiry dates so we now start
to create a metadata repository of
rounds credit cards and again I'm using
this as a simplistic example but it does
mean that as we process credit cards
let's say if we were doing it from the
front of the middle to the back office
the rules remain the same all the way
through so if we're working in the
trading environment we take our fixed
message here we're reading out a date in
this case field 52 it doesn't matter the
fact that it's displayed in ascii in
this particular case
it could equally well come in XML in a
my silly what is it 890 one data or
whatever it is in fix it comes in a
different a saurian Swift it comes in a
different format but if we can now say
that these are in fact both the same
date all of the rules start to reapply
so we can now start to put use this
technology to apply the same logic
regardless of the format it's in so this
is how we don't do enterprise
integration I think everybody learned
this lesson a long long time ago you
don't simply just map everything to
everything else but pushing this into a
bank might seem the obvious way where
everything goes into a canonical format
but it does actually become more complex
there's what happens is you end up with
a project up here that was started three
years ago and you changed the canonical
message because these guys are now
trading something different now these
guys now have to change their message
type that goes across here but they
don't have any budget because that's a
project that disp ended three years ago
and so now you have this problem of
multiple canonical messages going up and
down your system and then very very
quickly you end up with this sort of
mess with canonical messages here here
here and here for example and so it's
it's very hard to sort of push through
this concept so what we try and do is
basically create a metadata repository
we used FP ml for a number of years
because it was about the best thing that
was defined today most banks are looking
at ISO 20022 because it's defined for
that specific reason we take the various
different formats so his fix as an
example here's a date format and we
basically say this is a payment date we
can do the same with the swift swift is
defined on a similar standards as much
easier to do that and this on Swift
actually managed the ISO 20022 so it has
made life easier but if we say this date
is the same as this date we can now
follow through from front to middle to
back office all the different parts of
the the trade as we go through so what
it means is when we come back
to our integration a lot of the mapping
from from here across to the canonical
format we've already met what half of
the fields are in here so we can start
to do auto mapping we know that this
date is is in fact the date defined by
our standard we know that this amount is
that is the amount defined by the
standard so a lot of this messaging
canonical messier interactions gets done
for us so effectively what we do is we
we model every message any endpoints any
internal external we create Java binding
of that and it means we can now create a
bus which is predominantly Java objects
if we're doing high-performance
computing where we're putting we're
modeling for example complex derivatives
and looking for various difference say
numbers out of that effectively because
it's in Java or because it's in a
language that we can understand we don't
need to pass it it's already effectively
past if we do get price it comes back
with a double and it's much much quicker
than trolling through the message again
re pausing it and converting the ASCII
back into a double the messages were
typically using there's variant in
creating yet and other standards so what
we're trying to do generally is to map
these two existing standards and a lot
of the banks are now something we did at
JPMorgan Chase we created a I BML
investment bank markup language and it
was based on FP ml and then of course as
we found things that didn't map into FP
ml we would we had a lot of the people
that were working on the FP ml standards
we would then commit those back into FP
ml so we start adding to the standard
same sort of thing as possible with the
iso 20022 so you can start to create new
sort of effectively requirements around
the iso 20022 standard so these these
are the messages that are now been there
created but what's important again is
we're now adding the validation to these
messages so if a payment date and a
settlement date obviously the settlement
date is always after the payment date
but that's the same
the front office the middle office and
the backwards these rules get carried
all the way through persistence is much
easier doing this way we don't need to
map these horrible messages into
relational databases one of the most fun
exercises I like doing when people say
are you know Oracle rules yes it does it
is definitely the best relational
database I know out that's great but try
putting one of these three thousand
elements messages into an Oracle
database yes you can do it and I've done
it it's very easy to do you can use you
know jpa hibernate whatever you want to
generate the code then try changing the
message and it changes the tables then
change it again changes the tables again
now try reading an old message the first
message you had the second the third and
the fourth each of them which is
different and try and straw all of those
at the same time you'll end up with a
new schema every every few weeks and
these are the this is the main issue
that we have with the rational databases
is being able to follow these and like I
said before we were doing some internal
cloud computing before what we were
doing was effectively putting these
complex messages into databases as clubs
and retrieving them and today we have
technologies like MongoDB ready etc that
will do this for us and make it much
more efficient so last couple of slides
here effectively when we walk into a
bank certainly as a service provider or
you go in as as I word as an architect
of something the the business people
have got a particular solution in mind
they they want to go from the left hand
side of the right hand side with a new
line of business for example I've got
messages coming in here I want to do
this that and the other I want to
process them all to see what I've got
and I wanted to pop out the other end
and then you're going to go back and say
well especially 59 years because we got
fixed on here we need to understand that
we've got to apply all the rules and
we've got to model this into FP ml to
hook up with the middle office then
we've got six different formats of comma
delimited files coming from your
corresponding counterparties and then
finally the outputs got to go out and
Swift so something which is
predominantly simple becomes
horrendously complex and so this this
ability to now
model all of the different messages
using a model of an architecture into a
metadata repository is vastly reducing a
lot of the time that we spend in the
banks and keeping up with the
performance requirements and the way
that we have so last slide I wanted to
just give you a couple of sort of tips
and I'm sure you know most of these but
from number of years of practice keep it
simple the other s is suppose that we
keep it simple stupid so keep it simple
I'm a great fan of if something if you
can do something on a command line in
Unix then do it don't invent something
around it you see people in bed they
have a technology and they try and use
the technology to do something when it's
not designed to do that there are
technology has been around for decades
that do these things object relational
mapping it's it's one of the things that
adds anything up to a third sometimes
half of the entire complexity of your
applications you're working in an
object-oriented programming language
usually and then people work on
relational databases and the bit that
goes between them is the vast majority
of the complexity distributed
architectures you need performance these
days if you're working in a sort of
resilient redundant high availability
architecture you can't do that on my
machine you need to program with the
concept of your objects being
distributed even if it's internally
multiple VMs multiple virtual machines
for in the operating system and multiple
java virtual machines for example or net
whatever it may be but you need to have
this concept of a distributed
architecture echoes I'll mention a
second is very good at providing a
framework for that the model driven
architecture I've mentioned before said
frameworks I see used increasingly and
quite given a great pleasure to see
these when you go into a client liselle
we designed all this around a sort of a
an actor based concurrency architecture
and we're using echo and you just think
they've got the right idea it's going to
work it gives you a great framework
first for modeling this sort of
distributed architecture so
unfortunately the only talk are probably
would have turned out for today
mine would have been the appletalk which
is on in parallel so I apologize for
keeping you away from that talk because
I think acuras is going to be a great
future and you know this this world test
I didn't know really how to put this
test code test code test code it's
amazing how many people will sit down
for two months in code and not tested at
the end make sure make sure you work on
an iterative basis some of these
processes for swift messages for example
we generated 88,000 tests for these
88,000 different tests so we go through
these regression tests and because we've
got high performance we can run through
those 88,000 in a minute quite easily so
it's a sort of test scenarios that we're
pushing through these things to make
sure we don't cause problems we test the
performance two transactions people get
obsessed with transactions you can work
on compensation all transactions you put
a thousand messages in if you don't get
a thousand messages out something went
wrong go back and fix it afterwards
things don't generally go wrong if they
do you know go back and compensate
afterwards or go back and fix it but if
you start the transactions particularly
a distributed transaction you are just
going to cause yourself no end of
problems and for every time that I've
been called into to a large architecture
that's having problems in performance
nine out of ten times is somebody's
started say oh if we send this message
we want to make sure it ends up in the
database therefore we're going to start
a transaction here and then we'll follow
that on to there and then into the
messaging system and when he's an ex a
compliance one that goes into the
database and we're write it and they get
five messages a second through you take
all the transactions out count the
number of messages that go in count how
many got in a database and if you're
missing one go back and start it again
it's still quicker to run the entire
day's messages through than it is to
mess around with the transactions you
can get a thousandfold in performance by
taking transactions out so think an
entire life without transactions
multiple languages is a sermon great fan
of these I'm not particularly good its
programming in scanner or closure
although I've dabbled in them and I
started to get to like scarlet quite a
bit but I think they have a really
important place same
if you go into any bank you'll find
people using Excel if people think in
terms of formula using Excel then you
know that's that's what they're going to
use and unfortunately that's the reason
why Microsoft is still stuck in banks is
because they were clever enough to
provide Excel spreadsheets and they're
here to stay so if you've got a language
which is better at doing something then
use it and stick with it oh and the
object relational mapping as well it's a
which i know i've mentioned but i'll
mention it again object relational
mapping is probably one of the sort of
biggest causes of code I hope I've
covered some bits that have kept some of
your wake I noticed through the session
after lunch and the heating was turned
up to 26 degrees when I walked in so
it's been hard to stay awake so if you
have any questions then your level of
depth please fire away yes
so no validation rules said you're
asking where we find the valley where we
find the requirements for the validation
rules
right
if we go down into the microseconds no
job is not we don't see java in that
sort of area at all in the milliseconds
yes we find a lot of areas in that and
so measure and how to measure the
performance this is a totally different
game because it's almost like a
Heisenberg thing that you start putting
in measurements you start to affect the
performance but it's yes and it's
interesting to see we for example the
taken messages like Swift messages or
fixed messages and we put validation in
and then sometimes you find because
we're using the simplicity is to use
something like xpath to do validation so
you say if this field you can supply
xpath for is greater than this field
then message fails but then you find out
that the XPath because somebody's used /
/ for example takes a long time to
evaluate because it's got a tree walk
the entire message and you find the
validation takes ten times longer than
the parsing of the message so it's
interesting when you pass messages
through frequently we will take a flow
or read the messages in will read them
into memory so we'll take a million
messages read them into memory then
we'll pass them then will validate them
then we'll transform them and so in each
part you measure it and generally we're
you know we're sort of 45 man company
reasonably good turnover but we're not
one of these sort of US companies like
10gen that gets 75 million dollars to
sort of sit around the suspended on you
know lots of nice things without
actually having sort of necessarily
revenue I'm sure it'll sure it will come
because it is good technology but we
tend to follow what a client wants and
so we won't optimize a message until
somebody says we need this to go faster
so you know we will process fix if it
goes fast enough to to demo and use will
use it but for client comes back says we
needed to go 10 times faster then we'll
go back in and
and optimize it and that will frequently
mean writing those validation methods in
Java for example or scholar or something
something that compiles at least because
XPath is not the best one now the
question that is that that you always
have to be faster than the competitor so
how do you actually help measure this I
mean through being the consultant for
birth or was that good question I won't
repeat it because you've got a
microphone Sam it's a good question it's
it's a very secretive environment so
you'll be surprised what they do this
and there was something quite recently
where I think the one of the large
exchanges the New York Stock Exchange
had ten percent of extra traffic on it
and it was basically somebody that was
just doing us almost a denial of service
attack just to slow things down so they
could see how other people's behaved
there are other things they do when I
started in the environment traders used
to take a let's say a thousand dollar
deal and they divided up into a hundred
ten dollar deals because they used to
get commission for everything that went
across the Reuters network these days
they're automatically traded so what
will happen is people will put out
fictitious trades or they'll take
something which doesn't really matter
and they'll see how other people's
machines react and you've got people
with asperger's syndrome that are sort
of all sitting down there that you know
sort of like this working on the in our
and matlab and things working out ways
of perhaps trying to fool someone else's
machine so it's an amazing world it
really is fascinating every time you go
back you see somebody coming up with
some new idea of of either purposely
slowing down someone else's machine or
trying to get a little edge or creating
something fictitious it's really
fascinating but to find out how fast
someone else is going you don't know
until you start to make more money so
it's a bit of a gamble awesome any other
questions
okay I think oh yeah we have a question
sorry maybe you can show a slight of the
transaction flow I don't know before the
one with the arrows different scheme us
another one I'm looking for errors no I
think was this one there was one like
this with arrows yes this one come on so
so this is sort of the the Florida
transaction goes through I understand
it's a typical transaction is yes so my
question is how do you scale and
configure all these different surfaces
to work together how do we scale is this
a good question this is a very a
synchronous environment there's so
effectively as stuff goes down
everything's in in queues there's there
is no no synchronicity on this at all
that's obviously one way to scale it so
each of these can scale in its own right
as a trade is made it may go on to risk
control for example or we'll look well
in in the risk for example you'll be
doing a lot of computation in there but
the result of that doesn't necessarily
have to be used further on down we've
got payments will be going off for the
matching for example all of these are a
synchronous flows between the external
parties as well there was a thing about
ten years ago called GST PA the global
straight through processing Association
and it was trying to define the
interaction and it's using choreography
as opposed to sort of you're not
managing one of the differences with
trying to manage this as sort of work
streams to say first you go here then
you go here then you go here then you go
here is that this is so asynchronous and
complete everything is completely
independent it's based on a event
condition action I get this event on
this given this condition I perform this
action so it's a it's choreographed each
one of these behaves independently and i
think it's a it's been around for a long
long time it's been a human process for
hundreds of years the banks have always
done this for hundreds of years
and I think it's a very good model to
scale out and it's a sort of thing where
retail these days is has never had the
scale you go back 20 years ago and
retail was just done it was just didn't
have the scale it has today amazon
didn't exist thanks did exist and so I
think they've taken the human modeled
and they scaled that and it scales very
well any other questions another one
over here one JVM specific question I
saw the presentation a few years ago and
you were talking about other systems oh
yes what's now are using hey other
systems now no we're not actually I was
great fan of the adult system with did
some demos on his own and now they've
created effectively a software version
of that and I would have tried it if it
had worked at the time on amazon which
it didn't and it didn't work on my mac
either so in terms of trying it out I
know a lot of banks have are trying it
out so it is it is a popular option but
again I think they promise whatever it
is twenty thirty percent I think it's
good but there are still banks I could
give you two very very large banks that
still work in Java 1.4 when I was at
jpmorgan chase I forget which version it
was but we we justified moving from one
point three two one point four on the
twenty percent performance increase it
saved tens of millions of dollars on the
number of machines we were able to
reduce in production based on the
performance so moving from 1.4 2 1.5 etc
etc if as all is another one of those
steps that's fine but banks with
production where they're charging
typically twenty thousand dollars per
machine per year to be able to save
machines is massive but the impact of
using a third-party software is is is
risky perhaps I think just for fairness
we'll we'll cut it there so thank you
very much if you have any
please feel free to come up and ask me
afterwards thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>