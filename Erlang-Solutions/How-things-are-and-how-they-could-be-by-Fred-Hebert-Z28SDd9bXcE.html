<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How things are, and how they could be by Fred Hebert | Coder Coacher - Coaching Coders</title><meta content="How things are, and how they could be by Fred Hebert - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How things are, and how they could be by Fred Hebert</b></h2><h5 class="post__date">2016-09-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Z28SDd9bXcE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so little fun story this morning
actually got into the wrong conference
got into the JavaScript one just told
them I was a speaker they gave me a
little bracelet we go through to give us
a free swag I got a free cap to go with
it and we keep going it's like God know
nobody in here just keep moving on
moving on yeah where is anyone I know no
idea and then we try to get onto the
networks like I don't see the airline
conference network here and that's when
I realize it was the wrong conference
yeah so I'm not leaving for JavaScript
I'm staying here which i think is a good
thing yeah as Garrett mention I do work
at Heroku and one of the interesting
things about Heroku is that we have very
critical components written knurling
that are leaving in a production stack
all the time
the other interesting thing in there is
that Heroku is mostly Ruby and now a go
company even though Erlang we have a
team of really competent Erlang
programmers we have very critical
components in there it's still mostly
Ruby and go and so in my time there I
tried a lot to try to convince people to
join us on through the bean virtual
machine and getting them interested in
there and so I told them about our
language is that very very cool fancy
virtual machine and environment to build
services into the school blaze for
services you get all the fancy tooling
property-based testing you've got
tracing you've got all that kind of
amazing stuff you have everything that's
oh is the video terrible the video is
terrible it's not getting any better is
it all right I have a different adapter
in my bag though am I gonna try that
Wow there we go doctor is the problem
come prepare to the wrong conference
okay
and so yes really about telling them
this fantastic stuff we could be having
a great environment again LiveCode
deploys all that kind of stuff great
uptime and they see that it's a yeah
that could be really really interesting
and they start playing with the language
and the questions they start to ask are
going to be about how do I get history
in the shell and then you go and tell
them well okay you have to download that
component patch your install is gonna
corrupt this file every three weeks but
that's okay and then to tell you about
how can I change the keyboard shortcuts
in there and say you can't you have to
patch the actual library send that
upstream just don't bother with that and
they might be asking which database
drivers should be using and you're gonna
tell them well I mean if you're using
that database a pose grab something
there's about 15 of them and three of
them are trying to reduce a count but
they're still very very many of them and
so you might get other questions and
other questions of that kind how do I
run tests after changing a branch and
bhagavaan especially with the old rebar
you had to RM dash RF depths even then
go rebar get depth compile and then
rebar CT - - Kip depths equal true - are
and tell them to forget about the
warnings and everything and so what I
what really I sold them was that fancy
plane for the future with all the
magical tools to make their services and
what they got is that hand crank in
there and what they could think is that
the airline team within the company is
really that bunch of really enthusiastic
people really loving to fly their planes
that they have to start by hand and
roughly that's maybe the state we're in
in a lot of things we're just really
really good at getting everything hand
started we're still selling this but
we're still experiencing that and so the
tools really that we have there's stuff
that makes our line shine you do have
the Erlang and OTP model in there does
the one everyone knows or most of people
know in here the concurrent CD
everything you've got property-based
testing which is amazing you've got
we tools to do it at least a quick check
proper and trick most other languages
that you're gonna play it are gonna have
one of them maybe and it's going to be
half as good as any of the three we have
already tracing and production is a
thing that I think most people playing
with other languages don't even think is
a possibility you don't get to go on a
production system and debug it live in
most cases and so that doesn't even come
to mind as a feature that is clearly
vital dialyzer is really good
a lot of people like statically typed
language and without it they're not very
happy more testing tool cuter can wear
or mind blowing for a lot of people
great stuff and we have really a
crapload of libraries about everything
distributed systems and whatnot mostly
people don't know about them or not this
aerial know how to use them so this is
dumb Swindon magic roundabout it's a
roundabout in UK made out of five
smaller roundabouts I think this is a
kind of good explanation of the Erlang
experience you want to go on the road
and then you get this roadblock of going
like I know how these things work but
there are so many of them at once and
really a lot of confusion and that
reminds me of being in college trying to
learn about data structures and we had
to do it in C++ at the place I studied
at and a lot of people never had seen
the language before and the interesting
bit is that every time they were playing
with data structures they could easily
conceptualize linked lists trees doubly
linked lists all these simple data
structures were easy to conceptualize
but many of the students were having a
lot of struggle just getting them
implemented because they had the
complexity of the language they didn't
know to cope with at the same time as
they were learning in language and in
the end the data structure teaching I
think took a hit because of that and I
think it's a bit similar to what we see
in Erlang and I like to call that the
compounded hardships this is the Spruce
Goose it's a really cool plane that was
designed in World War two in an attempt
to carry cargo across the Atlantic
without using aluminum because of the
war
Hertz so the resulting thing is that it
was not a plane it turned out to be a
plane boat with the largest wingspan in
history it flew once after the after the
war was not shipped on time and mostly
it's a relic of kind of crazy ideas but
I think Erlang is a bit like that just
building a plane which is the system we
want to build is already a challenge in
itself when we build it in Erlang one of
the things that happens is that when you
have to play with all that weird
integration tooling and all the other
difficulties like the basic stuff is
gonna be the syntax which is fine you're
gonna have functional programming
recursion pattern matching concurrency
functional data structures immutability
all that kind of stuff is already hard
and when you get in there and give the
experience of a harder or more difficult
environment to play with
that's a compounded hardships and so
people in this room are probably very
good at building wooden airplanes but
most people just want to build an
airplane I don't want a challenge of me
making them out of birch wood the same
way that the Spruce Goose was made and
so what I think happens is that we have
grown a kind of tolerance in there if
you ask people like Joe I'm strong how
programming was back in the day he's
gonna give you really really cool
stories about needing to write
everything on paper or maybe the punch
card sending that to university
department they would compile that run
them for you and after a few weeks you
might get the result back and that was
maybe just a compiler or parser or the
equivalent of that and then he learned
to break up the tasks in multiple parts
and running writing and running a
program with a thing that could that
took multiple weeks and so by comparison
what we have today is extremely amazing
is tremely awesome but the idea that we
have that reference point in the past is
one of the things that makes us accept
subpar experience I think and I'm not
singling out Joe in there because I'm
doing exactly the same and I mostly I've
grown in the airline system and we got
used to it and kind of nefarious thing
in there I believe is that this
community as a whole gets used to that
support experience and it becomes a kind
of a rite of passage or maybe it's the
way we perceive it without realizing it
and the thing with that is
you have an entire community who is fine
with that difficult tooling that
difficult experience that learning curve
that we have and mostly ignore it
because everyone who is using Erlang
day-to-day has had to go through with
that has the capacity and we forget
about everyone who is not able to do it
and so to give an example of that in
action I want to go through the kind of
history of the airline build and
dependency tools we have fantastic tools
for testing everything like that build
tool dependency tools I think they're
pretty bad and I'm working on one of
them so in 86 Erlang was created it was
that kind of prologue II weird thing
there's one paper out there that you can
read about that I had no idea it was
built and then from the 90s to the 2000s
it was mostly make files there was no
way to get dependencies you mostly
install them somewhere in your system
put them in our lives
and then tried to build a thing and
maybe it would work now there's been a
few other systems in between sin on
other ones there stuff that's been made
in a lecture have not included them but
in 2010 rebar came around and that one
was a big change because it added
dependency management it was in Erlang
configured in Erlang term and really
stuff in this community really exploded
at that point because it was easy to
share code easy to deal with it and
really to publish and share what you had
and that was a big improvement
rebar however really showed its age
sooner than later and Erlang bit MK was
written to replace it her lying that MK
is of course a bunch of make files so we
did have rebar which was make files in
Erlang and Erlang that MK which is rebar
in make files so make files and make
files it was faster added and index was
direly needed and we recently got rebar
three out in stable version which has
package management so in 30 years of
tool-making really what we've done is
make files Erlang make files Erlang
we've got package management but not
really we just borrowed the entire
infrastructure of it leaks here and even
though Erlang people have that really
big pension of saying we had that 25
years ago concurrency 25 years ago
reactive programming 25 years ago and
all these things 25 years ago
good tooling we're a l'heure
we really really never had it in terms
of bettering the workflow of people and
languages like Alexia or NGO that are
five years or so in terms of age a zoom
past us in even if we had 30 years or
five 25 years of head start there's a
lot of good stuff in there package with
viral ink solution and everything like
that but really we don't have a lot to
show for for that 25 years Head Start
we've had and so I think that it's
because we've become insensitive as a
group and the analogy I want to use for
that one is the one of boiled frog if
you've never heard of that one is that
if you put a frog in boiling water it's
just gonna jump out and avoid dying if
you put one into cold water and slowly
warm it up to a boiling point the Frog
is gonna die now actual experiments have
proven that frogs just get out of warm
water no matter what they don't really
care about that but I think it's still a
good analogy so let's pretend it's true
the relative temperatures in this
community I think are going to be about
the ease of learning of using Erlang in
day to day tasks and so when we just
take our time and do all these little
hacks that we have every day on the
comment line to make stuff a bit faster
or in whatever kind of - only everything
that is suboptimal that's relative
temperature growing in this company
compared to other languages where you
get started if you've ever tried a
language like Elm which is totally for
front-end applications and that kind of
stuff but they have fantastic compiler
warning you can get going in ten minutes
if you've never used it it's a tiny
package you just run it and everything
works so that one for example people
coming from Elm going into Erlang would
be in a very hot bath by comparison and
the problem is that people maintaining
running writing systems are completely
critical to higher reliability and so
all of the technical stuff that we
Dettol up to have safer languages better
systems and stuff like that is entirely
useless if we don't have people to
maintain them and if we just keep
letting the relative temperature of this
community grow by an action and having
less than optimal workflows we're just
going to get ourselves in trouble where
there is nobody to maintain what we do
and so
I think we have to be aware of that
insensitivity that I think is already
there within everyone in here and one of
the right attitudes I want to have there
is Garrett Smith you might not be able
to read that at some point Garrett Smith
wanted to help Tristan and myself with
rebar tree in terms of printing better
messages regarding path and we're
telling him like how to rerun the
project just like you call bootstrap and
everything Gary is like 10 seconds do
you have time to read comics during that
operations like that's the right
attitude to have I didn't realize it
we're just we did have a better commands
at tens times faster but just like
repeating - Garrett that's the way I
know how to do it it takes ten seconds
you run it that's what you do and now I
think Garen is the right attitude of
calling on these kind of things
where really there's a better solution
to be had and if there is not we must
have a good reason for it so every time
there's a kind of tiny frustration we
have with the system we should be able
to work to fix that and I want to show
that this works this is possible we've
done it multiple times in this community
at least in terms of tutorials and
everything like that but we have more
work to do so when I joined the
community close to six seven years ago
or something everyone on IRC and whatnot
we're asking like how do I run code out
of the shell and that was really a kind
of tricky one because nothing really
told you how to do it every tutorial
we're doing we're just compiling in the
Erlang shell with the little C function
call and then the L function call and
you run everything and there's no way to
run anything outside so I decided to go
dive into the programming books
underlying that we have sure Armstrong's
books first edition doesn't tell you how
to run code outside of the shell until
page 113 and chapter six Francesco and
Simon's book with O'Reilly didn't tell
you how to do it until page 289 in
Chapter 12 learning some airline my own
book that doesn't do it before page 120
in chapter 8 the knr book in C 2008
Edition tells you how to do in page six
so really how come we didn't have a
better experience in there you have to
learn the entire language before you
able to even run a program show it to
someone install it somewhere display it
without some really really janky and
occations and that's pretty bad but it
got resolved with time we got the thing
going and right now pretty much nobody
asked a question you're gonna know about
east trips fast enough or even gonna
build a really is really quickly after
that the big question became what is OTP
and everyone had this kind of bunch of
modules randomly scattered in a
directory with no dependency because
nobody had dependency management tools
and you saw that thing where everyone
told you defense you're like people in
big corporations are using OTP they have
that stuff that's really there you
looked at the documentation nobody
really knew how that worked
mmm it was a bit of a problem eventually
there were a blog posts websites helping
books and everything like that and
things really got better and now most
people know about OTP and its importance
they know about it within the first week
or even within the first day the next
big question was how do I build a
release and really even today that not
that one is not that easy if you go get
to the OTP documentation and you look at
target system and there are stuff in
there that looks like black magic I
still don't know if that page of
documentation has to do with an actual
tool something it's just a definition of
a structure it's not very clear and back
then you had to work with sis tool you
had to work with rel tool it was that
big big scary thing and for the longest
time what everyone would do is just copy
paste that rel tool configuration from a
rebar that config or someone would build
config put into their project and hope
it worked for them
and if it did it's like well screw that
I'm gonna run this in a screen session
or something and that wasn't a great way
eventually Tristan slaughter and Jordan
will mayor took stuff out of scene on
which were to build tool and made relics
out of it and now relics really makes
release is easy everyone in Erlang uses
it every tool and LX here seems to be
built around it and people can build
releases within a day or so but we went
from what was maybe a year
year-and-a-half before you use your
first releases to being able to do it
within the first week of learning the
language and that's been a great
improvement that we've had and there's a
lot more we can do right now a lot of
the frequently asked questions we have
are probably how do I do relapse that's
really hard the stories from Erickson is
just like you test the live code of data
much as the real regular code all that
kind of stuff nobody really knows how to
do it xrm and the elixir does it there's
plugins to do in rebar 3 I think they
need to be discovered but we're starting
to get solutions data which back then
was just like it's so much effort don't
even try and now it should be a thing
that really soon I think we'll get into
the workflow everyone that's a great
improvement how do I make my own hex
mirror and that one is interesting
because it's a problem both in the
elixir and in Erlang and the other
interesting thing is that if we looked
at releases and OTP is just like the big
corporate people are doing that how do I
do it at home
how do I make my own hex mirror is the
opposite problem it's big corporate
people going I have a server that
doesn't talk to the internet how do I
build a project my developers want to
build and we're seeing a reversal in
there that I think is pretty cool where
the open source efforts or try are
starting to really take over the
Ericsson led efforts in terms of
toolings and that kind of stuff for the
word flow we have and that has to keep
going on but we have to be conscious
about that and then we don't really know
what is next so I think a night with
Erlang back in the day the Joe Armstrong
experience if you let me call it that
way of sending punch cards and
everything was just kind of making your
bed can't make your own fire in the
woods and then at 5 in the morning you
have to get up to pee and then the fire
is off and everything is wet and it's
terrible just great camping experience
everyone loves that and that where
they're lying is probably a bit more
like that it's a pop-up camper you just
have to build it it's everything it's
much nicer it's still close to nature
but you have a toilet you might even
have a shower and have a place to cook
it's much nicer who came to this
conference and slept than that nobody
but it's so nice it's Deerling
experience now most people pick
something like that this is hotel I know
16:42 that's the one that I think was
recommended for this venue and so most
people came here and slept in a hotel in
a bed that was pre-made you don't need
to build your bed every night no reason
to do that and I think that's really the
experience we should be aiming to have
an airline like there's no reason I'm
building my own system from scratch and
I sandal in my own bed in my own bed
Stan in my own bedroom and building my
own alarm clock every morning or every
night with Earling should really be a
thing like that we want to learn Erlang
to solve a problem and right
now in a lot of areas Erlang is the
problem we have to solve that's not a
good thing and so how could things be
how things could be how to get there
there's a few broad ideas there is no
quick fix I think yeah that's an airline
programmer in the making I think we have
to really stop with the quick fixes and
by that I mean everyone has or has had a
project where what you carry around is a
makefile
where you just put all the little quirks
that you correct for every one of the
tools and then when you move from
project to project the make file gets
bigger and bigger and bigger and if you
have a library where you have to make a
patch you fork it to your own github
repository or user then you make the
patch there and you leave it there and
you move on and so what we're creating
like that is just someone who at the
start has a tiny tool belt which we just
feel and feel and feel every day until
it's something that weights
like a hundred kilograms or something
like that is very hard and someone
starting in a language for the first
time we're just joining your team for
the first time has to wear the hundred
kilogram tool belt for the first time
it's very heavy it's very uncomfortable
and you just leave you don't want to
boil in that water and so the culture of
quick fixes has to end where if we do
the same thing two or three times really
we should really start a discussion
about how can we fix that more
permanently have a way that is not so
manual every time and stop carrying that
burden of everything and fixes upstream
the person upstream is not responsive
we're gonna have to realist our
discussion about the forks and
everything like that and I think hex is
gonna be interesting there because you
cannot have 150 forks of the database
driver on hex with just like a number
after the end we're gonna have to start
doing that stuff a bit more cleverly
than what we've done for the past
multiple years it's gonna be a good
thing but really about the everyday
workflow you have someone joining your
team they're struggling I want people to
take note of that and start thinking
about solutions for that it is gonna
come and pay us back in multiple ways we
should be making the tools shine and
this is maybe a bit more for tutorial
people writing tutorials writing guides
but it's about really
anything we do I think it's a general
mindset they're really awesome stuff
with Erlang is gonna be yes the
programming model said we yes OTP but
it's gonna be tracing is gonna be
probably based testing it's gonna be the
community the libraries the kind of
mindset you have where academia meets
the industry and you have really really
clever people that making lists and chat
rooms that do fancy stuff on the edge of
research if that's a very very valuable
thing but every time we learn Erlang
we've all done that little exercise
where we build a database with the
recursive functions that you call which
seem IDB and then you running it there
and you see database a cool I wrote a
database that I'm never gonna use ever
again how good would it be that we would
have instead an exercise where within a
day we build that abase that's based on
C Rd T libraries that type checks
through dialyzer and has property based
tests it would be pretty cool right now
it seems impossible I think most people
here don't even have a property based
test testing suite or something like
that right and it could be really an
interesting approach to take how do we
get there that's really a good challenge
but part of it is making your own tool
shine I think everyone here is writing a
libraries using a library has seen the
frustrating parts of that first thing a
library should have is really the simple
documentation tell me what the library
does why should I care
how should I use it when I should use it
and where to look for more information
if you're not able to answer these four
or five questions
you're not giving any hope to newcomers
just getting to that github page where
the only thing you see is a readme
that's the default template in the
library doing that build it we rebar
through come file or make it just
garbage and it's I think a lack of
respect to your users so yeah what it
does why I should care how I should use
it when I should use it and where to
look for more information if you're nice
you're gonna want to have a few examples
and they're telling people how it runs
what the output should look like if you
have time and regular users you might
want at that point to have a reference
manual which means that's where you get
a doc and that kind of stuff going so
that if I have an idea of how to use
things just
to take a little bit more and stuff like
that I'm able to get the information I
need I'm able to look at things and if I
just have a hole in my memory where I
don't remember what a function arguments
is like I could go and find it there and
then if you really have more time and
you have enough users you can tell me
how to help you what's your timeline
what are the features that were missing
what do you need help with what
standards do you enforce and if you have
that then I should have to look at your
source code but before then if the
solution is look at the source you're
just giving people a terrible experience
shouldn't be how to have so that's
really it for the basic documentation
but there's a lot of stuff that we have
to do there otherwise how do I find your
library you need to have visibility
github is a terrible place for
visibility how do you use github search
it is pretty bad you're looking for code
and you're gonna find code but not the
code you won't you might want to search
for Google you're gonna find 25 Forks
they all have different patch levels you
don't know what you get put your library
on hex it's at least it's not a perfect
system it's the best one we have right
now hopefully even something nicer will
come through but hex is a really really
good thing to have there is the central
name for the library you can search
through them you can put your links to
documentation in there people are gonna
find it it's gonna be much much much
nicer all the dependencies aren't gonna
be stored there there's not gonna be
problems with that you might want to
make Twitter mailing list slack
announcements so that there is common
knowledge being built about your library
being in the wild if you don't do it you
just dump it on github nobody's never
gonna be using it another interesting
practice whenever you get questions
about this take note of them and that
becomes your documentation as you answer
them if you just get the questions going
and you never know them down you're just
forcing yourself to repeat it to
everyone every time and it's gonna be
terrible for you because it's a loss of
time it's gonna be terrible for your
users because they have to go find you
to know how it goes and that means that
nobody else can maintain the library
about you because you're the only one
having persistent knowledge of
everything in there that practice
documentation might be published there's
tools to publish documentation there
the docs website that lets you fetch it
there's even one that goes with hex that
comes with it but nobody uses it at
least and the airlines had a thing it
like sure people do it find that one is
good they're like we don't care I don't
even do it myself I should and realizing
one of the big points is that it should
be fun right now learning airline is an
investment you have to set aside two or
three weeks you have to buy a book so
it's not just a time investment it's
also a monetary investment and then you
have to go dig down and play with it and
you don't play with it you work through
it until you get to a point where you
think okay that's how I put a system
together I'm able to deploy it I'm able
to do something with it but for the
longest time you're alone in the little
book universe of just doing the basic
stuff and almost not using any community
tools just learning what the hell Erlang
is then you get out there after three
weeks a month of learning and you go
into IRC or slack or something like that
our Twitter is just like hey what's a
good project in Erlang it's like I mean
that's not a question you want to hear
the reason you have that question is
that someone that's done going through
the book they don't feel they have a way
to learn by themselves and they now ask
people around there what more should I
learn how do I learn something actually
real with this and they don't do it
before I think that points to a crew
lack of self-directed learning
experience and they're lying everything
we do I think is self I want to say old
school where it's someone in front of
them telling them what to do a bit what
I'm doing right now but really just
telling them if this is what you learn
now this is what you learn tomorrow this
is the exercises to go through now go
free in the wild that's not cool
really the best way to do it is to get
someone the basic tools to do what they
want in the environment that lets them
want to explore and play with it and
have fun with it and that's really when
they're gonna have a better time
learning airline and I think the
indirect result of that today is that
when you look at the early learning
experiences really a lot of people
learning late in their careers and want
you to you see an interview about a
company using airline they're gonna say
something like it's really the only tool
that could do the job and that's cool
that's cool you're the only piece of
technology that's able to do what
they really need doing the problem is
that this is the last man on earth kind
of strategy right it's just it's really
cool nothing else could do it so I had
no choice to learn Erlang that's the way
most people do it and we're proud of
that it shouldn't it should be fun
Erlang should be a thing that you do you
explore in you play with and at some
point you just never regret making that
decision because it is the only thing
that can do is thing but that's not a
factor you choose it because you wanted
it to be fun and you want it to use it
so I want to try a thing I okay meri
displays cool how do I send that okay
I'm gonna make it a bit bigger so I've
put together a thing that's just really
cool just really a basic project and
people are read that's fine I need to
make it bigger
show of hands bigger people with
terrible eyesight I blame you all for
the problems of my lack of preparation a
second bigger again show vents bigger
yeah people at the back I could ask you
to come closer but that's I think
contour intuitive is the solution I'll
just make it somewhat bigger again it's
so small on the screen here - okay so
what I have here is a file that's just a
regular rebar config with a plug-in I
don't really care where the source is
for that one I'm writing it and it's a
crud project really it's create read up
they delete API is it's super boring we
should have a framework for that we have
cowboy but I don't believe it to be a
framework at that point it's more of a
library or toolkit so I made a templates
in there that's gonna run the thing
you're about three new crud project it's
gonna fetch it hopefully is gonna be
fast enough okay so it compiled the
thing if I go into the readme file I'm
gonna have how do you create a new
handler resource you do this and then
you're gonna have a little file to put
and
me so I'm gonna run this little command
and I have a crud handler called my
resource gonna take a little while to
run oh that's faster than home good
Network Sweden so if I go in there
there's a bunch of files that I've been
written if I go into my resource model
and there let me just actually shrink
that there we go so what I have is a
really basic handler in there where I
get the definition about what code path
I want it to have it's a simple thing
that's a thing a tree a framework would
give you
I have unit function terminate validate
create read update delete and if that's
the end of it if I just go to the thing
and oh that's a part that takes a bit
longer I guess yeah that's not your
network it's me not knowing my team oh
well enough it might be your network as
well so packages are smarter or a bit
faster but yeah and so I want to again
while of this build reiterate that the
really important point I think is not
that this is a framework this should be
done by your framework it's not a tool
for crud it's it's a tool to show what
we can do with Erlang instead how we
could be easy and right now building
that thing and just speaking to
libraries and everything that goes in
there took me multiple hours and I'm
gonna show you in 10-15 minutes what it
can do so I'm just gonna boot it with
the shell because I'm not it's bills are
release but I'm typing bad alright I'm
booting a shell and what I'm gonna have
is the application it started it uses
the same stuff as releases where's my
cursor if I go to that website we have
automatically generated documentation
for oh I don't because I forgot to
listen to my own instruction I have to
open the router file and add my resource
in there
I'm gonna I'm gonna restarted actually
because I think I haven't said that
stuff right okay now it runs where's my
other tab there we go
I have API Docs for and that's gonna be
small but I don't know that I can yeah
make it bigger and unreadable so delete
operations get operations right now I
want to try them try it out it tells me
there's a 404 I want to post the content
instead yes try it out the content has
been written there the API I think they
said that's existing tools I wrote none
of that it's really a little big thing
is that you have a quick way to test it
what we see in the background happen is
that we have colored logs coming with it
you have errors and everything logging
is taking care of you showing lagger
right now cool
we have lag or it's being pre-configured
for everything I need other cool stuff
we might have in that one is that if I
do rebar three check which is an alias
for commands ah compiling a PLT actually
I have a faster one going because I knew
that would be a problem hey we go I
think that one is free compiled
preparing for Alyssa networked yeah ok
so that one is not being used right now
there's probably a file missing or
something let's go back to I prepared
but not that well ok rely three check
we're going to wait true that little
thing there's any one of interesting
stories and bubble I shouldn't be that
long it's much faster than it was and
really what we have here already seen
there the cross-reference analysis
already took place on the third line of
the execution so xref does a quick check
we do have dialyzer going in because
everything that we could see in there is
already where's my cursor for the mouse
there everything is already typed check
for that one and if really I open
something like in my models I go to my
models I want to go to my backends
because I decided to use non-standard
directory that's an a hamster girl what
we have there is the super fun exercise
that we have by default everywhere
with little databases and it's being
tested oh there we go execute it on the
side property based tests gud they're
testing crud operations create really
daily there's no reason for me to ever
write that freaking test it's the same
for every single library you have out
there the tests are generated I get
fancy code coverage with them getting me
with my resource model is covered a
hundred percent the router module is
covered a hundred percent overall yet
eighty percent coverage without having
done anything and I have an API that
I've shown you is working I have tests I
have everything like that it type checks
there's no stuff being broken and so
this would be pretty cool but I think
there's like more stuff in there
everything we have to do has to have
some form of monitoring so why not use
the cool libraries we have in there let
me search a different thing for that one
it's a different port number it's yeah
so I had a lot of resources in there
yeah is that oh I killed the app
champion me the stupid app we don't need
the output in there okay no metrics for
that one that's normal because I haven't
run a single call let me go in there I'm
gonna run my post message again try it
I'll try it I'll try out I got a bunch
of log messages and now I have
statistics and metrics are ready to be
in consume and all that kind of stuff is
really stuff everyone here knows you're
gonna need you're gonna need metrics
you're gonna need documentation you're
gonna need all of that it's terrible
that we have to build it all by hand
even if we have fancy frameworks and
fancy tools it's all done for you
automatically based on the properties
that a crud app is always the same
stupid boring thing it's it's a skin on
top of the database and so that's really
one way to get it going but what's
interesting is that in working to try to
make this integration and the tool shine
where I want to show like I want to show
dialyzer I want to show property based
testing and all the tests are running
for you automatically if being written
already I make an environment that's
better for me as an experience relying
developer but it gets really cool if I
want to actually work with someone
running tutorials in there so I made a
little tutorial namespace command
there's a crud
tutorial can people read down there or
want me to bring it a bit higher in
there higher there we go we have the
little thing there hello this is a
tutorial for basic online using crud
blah blah blah add a new thing we're
gonna store fridge handler cool cool
cool I love fridges creating a thing I'm
gonna go back in that one reopen the
router that I have I'm just gonna add my
fridge and now I'm gonna run the
tutorial again and the thing is gonna do
is that it's able to use a test oh yeah
I just added the thing that's fine I
rerun the tutorial and it's able to look
into project because it's really a
standard structure why is it not their
fridge model should be there oh I called
it fridge handler you see my tutorial is
catching my errors so I don't have to
care about that is doing it for me it's
added in there so oh we have the
exercise database thingy deleted
database gives me the specification I
have to implement it does a tutorial
everyone has been doing for years I
don't care I saved it before yes I want
to write to the file don't want to write
it all in front of you that's boring
when I run it again the tutorial is now
able to use the comment structure I have
with the tool to run property-based test
and see yes your database implementation
is actually correct you don't have to
run this garbage in the shell again just
saying oh yeah I'm adding stuff to a
list don't know what to do once you're
done with that kind of project you
actually can just move forward you have
an environment a website you can deploy
you can put that somewhere everyone can
play with it but it's the same boring
exercise we always do except that time
it's done in a much nicer context I know
why the community tools are I know where
to move forward and someone can easily
glue something in there about making the
same tutorial but for really property
based testing and so if I do have my
thing there and I had the other one call
a recipe model because I'm gonna store
receipt piece and stuff like that and
then I could have a thing that I'm still
adding it
I could add a thing that really asked me
to recommend
food that I have into fridge to make a
meal and all the recommendation systems
there's a really clear path forward for
self learning I show all the tools and
the overall experience I think is much
nicer for everyone using the project if
you want to modify stuff it's still the
same Erlang code we would have written
ourselves so really I think that's what
I wanted to show for this little demo
it's an idea it's not a final thing
really it's a proof-of-concept we should
have something nicer I think overall but
I'm interested in finding solutions if
you're interested in finding solutions
also you can come and see me or just
experiment on your own I think there's
really cool stuff to be done and much
better improvements to be had into our
everyday workflow that we have
thank you
any questions or point of discussion
something like that
no questions was it that boring all
right then
oh you have questions I didn't see them
well yeah there's one there yes
yeah I'll repeat the questions yes yes
so the question is who's gonna pay for
that we're fine with writing the
library's deploying them but then
maintaining them putting them in good
condition writing documentation who's
gonna pay for that and I'm gonna say
that who's gonna pay for that if you
don't do it and it's gonna be you of
course because when you train you people
coming in on your team you own board
people to your workflow you're gonna be
the one having to train them either that
or you're gonna give them a terrible
experience we drop them into a big
repository and tell them this is how we
work here figure it out like the
investment of doing it comes back to
everyone working on it and the
investment of not doing it comes back to
everyone not working on it or at that
point in working on it because you're
still the person who knows about that
stuff so if someone has a question
they're gonna come back to you anyway
really if you have to teach that thing
to more than one person is gonna be
faster to write it down and have them
read it and answer maybe one question
instead of 15 of them over the course of
multiple weeks of training I think
that's the shift in mindset we have to
have it's really great how fewer people
talk to me now that I write more
documentation next question the tools
for that there's a doc in there I think
edik needs a facelift I think everyone
thinks that also I don't know who is
gonna take the responsibility about that
if you feel like you're looking for
project to do that's a cool thing to do
but really document
in there I just bought a readme file to
get up repo and then in the hex page you
put a link there and people are gonna
click the source link see you read me
like the five questions of what who
where the when and that kind of stuff
really fits in a readme it takes half a
page to answer it's not super long and
otherwise if you're just using a doc for
documentation in code it generates the
thing for you and you can upload it on
the websites with that Earl dachshund
Walla is one of them that generates it
for you and I think there's dark CX dot
PM that hosts them for you also if you
make a package so like the
infrastructure is mostly already in
place we're just not using it out of
laziness I think or ignorance other of
these I don't think anyone here is doing
malice I'm gonna write a super useful
tool but tell nobody about it they're
gonna be suckers for that no thing that
happens questions for Fred anyone
questions about channel selection before
we dismiss yeah that's the rule if you
have JavaScript question I just come
back from a JavaScript conference that's
right
where's your hat oh it's behind a stage
so uh Fred how have you found support
among you so Fred is championing this I
mean he he interested on the rebar front
I've been doing an incredible job and
this is tough work and it's based on a
vision I think of making this generally
accessible to build community it's based
on shame shame yeah so if I go back to
the beginning out there and that thing
that's because I had this happening with
like five six ten different people
trying it at some points just feeling
like a clown showing them a tool I want
them to use to work with me and them
just going out that's terrible like at
some point that's why I don't actually
enjoy working on rebar three I hope
someone makes a better tool so I don't
have to do it anymore
but I like working on it more than I
hate seeing people just looking at me
weird about why the hell do you use that
shitty tooling and so for me that's
really the big point I just got fed up
of not being able to find co-workers on
a bunch of things because they felt the
tool experience was subpar compared to
other languages and that's how I got
involved into that one for other people
I think there might be nicer motivations
that just getting to
all to stop complaining so so how are
you able to recruit people in this
effort though I mean I think yeah yeah
we have I mean we now have a new cork
emitter on rebar through which is
Alastair Sullivan and we're getting more
and more open contributions from people
and I think part of that effort is also
one of the things we can do better which
is when someone opens an issue one of
the approaches to take instead of just
like I'm gonna fix that in two weeks or
something you just here's how I think
could be fixed can you please help us do
that and really on board people into
helping you into your project if you as
a project owner kind of maintaining that
authority of I'm doing everything I know
what I'm doing let me do it I'm gonna do
it better you're never gonna get help
and it's about changing the attitude and
the openness you have in people
approaching you with comments and with
help and giving them guidelines and
realizing the idea is to become an
enabler of people helping you fix the
tools rather than just someone who does
all the work for them for free and at
that point I think it does change the
perspective a bit and we're trying to
get more and more help and there's a
bunch of tasks people want to work on
the rebar three or something like that
there's a few tasks labeled for
beginners otherwise you can ask us but I
think the same stuff is going on with
mix in the elixir community and stuff
like that so multiple projects are
looking for people if you have a bit of
a hole in your schedule just want to
know how the sausage is made it's
probably a decent way to get through it
any other questions
let's run applause for fray</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>