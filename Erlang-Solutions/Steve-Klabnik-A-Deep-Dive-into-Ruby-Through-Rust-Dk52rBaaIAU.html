<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Steve Klabnik - A Deep Dive into Ruby Through Rust | Coder Coacher - Coaching Coders</title><meta content="Steve Klabnik - A Deep Dive into Ruby Through Rust - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Steve Klabnik - A Deep Dive into Ruby Through Rust</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Dk52rBaaIAU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everybody I am Steve this is a talk
called exploring Ruby through rust and
we're gonna have a lot of emojis and
we're also just gonna talk a lot about a
lot of different stuff in general so I'm
gonna be going into like a pretty deep
dive on some things but relatively
quickly because you know we only have 40
minutes so this is more like I don't
expect you to necessarily remember all
of it because there are very few people
who know this particular intersection of
all of these different languages and
things that I'm using so it's gonna be
fun this this talk is sort of about this
combination as Bodil kind of said I used
to do Ruby and rails a lot I actually
have a ruby tattooed on my arm I have a
pearl camel too because I did pearl
before Ruby but I've sort of you know
gone from the the Ruby world into now
rust and I really like rust I'm working
on it full-time
it's my day job I authored the first
edition of the book and I'm a co-author
of the second edition of the book we're
working on right now and so I'm always
trying to connect these different you
know paths together and also briefly
before we get more into that I also want
to say like I really hate the tribalism
involved in programming languages I've
always loved learning lots of languages
and I've never really understood the
trash talk between them so I really like
rust a lot but it's definitely not a
thing for everyone so if you don't like
rust that's cool like it's fine
and so we're gonna be talking about rust
and Ruby and see all together in weird
combinations and also fundamentally a
little bit about like having fun with
programming instead of everything being
all serious engineering stuff like a lot
of the work that we do or the discourse
that we have about programming is
focused on how can we build something
that's better from an engineering
perspective but sometimes you need to do
stuff that's terrible from an
engineering perspective in order to gain
insights and or experience with things
and the freedom that's involved from not
having to worry about doing the right
thing so a little bit at - yeah so a
long time ago or I not that long ago I
used to build applications mostly in
rails and other things before that and
then as I got and built
more and more applications I started
moving down the stack into building
libraries so I worked on Ruby on Rails
for a long time and maintained a bunch
of different ruby gems but then I
started getting involved in working on
programming languages so that's my
current day job now working on rust and
then I have a hobby project I'm just
gonna mention in passing briefly
Intermezzo switch is building an
operating system in rust and the pitch
is kind of you know JavaScript let's
learn how to build an operating system
together so it's like teaching operating
system concepts to people who've never
done low-level programming before but
I've kind of worked like down the stack
constantly and I don't think that you
know people always think that the stuff
that's farther down the stack than they
are is like magic and the things above
the stack are like easy but I've always
found that kind of ridiculous like I
think operating systems is easier than
front-end development in many ways but
also you know coming from a dynamic
language background we always talk about
the the system's programmers as being
the ones who are like the super hardcore
programmers but the thing is even below
operating systems like you get into like
the hardware itself and that's like a
level below the software stuff and then
to really understand the hardware you
have to like understand physics but then
once you start getting further down into
the physics like eventually at some
point we don't know anything either so
really like it's not like there's people
who know lower-level stuff and it's
somehow more foundational I don't think
it's much more of a you know we're all
have our specializations that computers
are too complicated for individuals to
understand fully so I'm a really big fan
of trying out different chunks of the
stack and learning things even if it's
not what you always do so as part of
this we're gonna talk about and do a
little comparison between some rust code
and some Ruby code to show you briefly a
little bit of of it and this is sort of
like a semi real-world story about one
way which rust is actually being used so
there's this method that rails provides
on string called blank question mark and
what it does is you call this method on
a string and it returns if everything in
the string is blank character or not
according to Unicode so this is how it's
implemented in rails not with the actual
comparison to konichiwa but it's like
you know it compares a regular
expression to
the string that you give it and so it's
got the Unicode you know enabled space
stuff it text you know the beginning and
end zero or one space characters and so
this is an incredibly simple
implementation because Ruby is awesome
on expressiveness but it turns out that
it's actually really slow and it's also
slow in a way that's surprisingly
significant I still don't really
understand why this is significantly
slow in the sense of like so there's
this this project called discourse which
is a forum software for doing stuff and
it's a rails application on the backend
and an ember application on the
front-end and they found that this
method for some reason was a significant
bottleneck in their application and
that's the part I don't like understand
like I could see why the regular
expression would be slow and so there's
this journey to optimize it so before we
talk about how this optimization happens
I want to show you briefly I have a rust
file here I'm going to be doing a bunch
of live coding so you can see how
terrible I am at them it's gonna be
great so in here actually I'm in the
wrong directory already yeah I'm gonna
bump that up and probably do you like
the syntax on or off cool I just
switched color schemes to hopefully make
this a little bit a little bit better
okay so so rust is a low-level
programming language and so normally you
think that that means that you have very
little abstraction capabilities but one
of the cool things about rust is that it
often feels like a high-level language
even though it's actually a low-level
one so this is a whole pile of code most
of it doesn't matter that much the core
of it down here is in main so this is a
little bit of Russian I was like showing
off the you know non-latin characters
when I do string stuff but we create a
straight a heap-allocated string from
the string literal and then check to see
if it's blank and we make a blank string
and see if it's blank so you know this
kind of looks vaguely like some oo code
that you may have you know used in other
languages it's almost the same as the
Ruby except for you know parentheses and
there's a question mark but
the thing here is we can extend rust
allows us through a trait system so
traits are similar to type classes in
Haskell they allow us to extend types
with new functionality so I defined it
is blank trait here with one single
function which is actually a method so
is blank we use explicit self and rust
sort of like Python more than like Ruby
and it returns a bool and then here's an
implementation of is blank for Strings
so and this is the part that I think is
the best so it's self chars all check to
see if they're white space so this is
like extremely straightforward and of
course the is whitespace method is you
know built into the standard library and
rust but this is like a this is a really
high-level feel kind of to it right we
have a closure we're passing it to an
iterator we're doing all this kind of
stuff so the the core of this
functionality is just this one line and
it's really really easy to write so in
comparison so that's what the sort of
looks like this simple regular
expression match versus you know that
iterator closure combo and rust but why
why is this Ruby so much slower so the
thing is is that rust actually executes
as fast as a hand-rolled code does in C
so there's actually an implementation I
think I have a link to it later where
somebody implemented this in C instead
and it's significantly longer and and
stuff so I thought I had that link
before yeah okay I don't I'm not gonna
search for it and show you but there's
like a hundred fifty line implementation
in C that's much much more complicated
and much much more low-level but it ends
up being identical to the rest and this
is one area where I think that rust is
really neat or when I talk to people
from dynamic programming language
backgrounds you know sort of one of our
initial pitches for rust is it's just as
low-level as C is you can do all this
low-level stuff and a lot of people who
program in Ruby Python or JavaScript are
like cool I will never use that ever
cuz there's like a reason I'm not using
C in the first place right so the idea
that you can write this code that feels
very high-level but has the efficiency
and the power of being low-level is the
combination that I find like intriguing
about rust okay so now I'm
to show you a little bit about how we
can figure out exactly why that Ruby
code is significantly slower and what
it's actually doing so we're gonna we're
to look at some source code for the Ruby
interpreter next so there's a couple
things that matter a lot with Ruby
internals and there's actually a really
fantastic book called Ruby under a
microscope if you want to learn a lot
more about where B internals look like
but I have mostly learned it just
through like messing around on weekends
and so there's this include Ruby Ruby
dot H file which is where most of the
definitions for the things in the
interpreter actually are and this
contains almost all of the interesting
bits that you use when you want to write
an extension to Ruby and then there's
these two structs our object and our
basic because she doesn't have
namespaces everything is prefixed with
you know R or RB to you know make sure
that there's no naming conflicts our
object is kind of the equivalent of
object in Ruby which is not strictly
speaking the base class but effectively
the base class of almost every object in
Ruby and our basic is the true base
class of all the classes in Ruby so
these are two C structures that
represent those classes and then finally
value since Ruby is dynamically typed we
just cast everything to value all the
time and never pay attention to what the
types actually are so this is a type def
for a pointer actually and I'm gonna
show you what those things look like
okay so first let's look at our basic so
one of the things I like about looking
at the source code of the interpreter is
that you can learn stuff just by reading
it so normally you know if you if you
just do Ruby all day maybe some of the
syntax doesn't make a lot of sense but
with a little bit of illiteracy in a
lower level language you can learn a lot
about how your higher-level language
operates so here we have this struct our
basic and it has a value flags and then
a value class so this gives us a really
convenient definition of what a Ruby
object actually is it's a series of
flags and then a pointer to some sort of
class like at its core that's all an
object is in Ruby so it's actually kind
of very straightforward
and then we're gonna look at our objects
so our object is a little more
complicated but that's fine
so our object is one of these are basics
so that's where the class of the object
lives and then there's this Union and
the first time I saw this I was like oh
my god what is going on but then once I
figured it out it's actually really cool
so I'm gonna delete some of this code
first because it's easier to tell what's
going on without looking at this stuff
so let's focus on just just this bit so
I'm gonna get to because it's not
helpful okay so we have this we have
this struct embedded inside of our
object and it's got this pointer to the
num IV a value pointer to IV pointer and
a void star IV index table and I was
like what does this mean at all and then
I remembered oh IV is short for instance
variables so the Ruby object that's not
just part of the basic object contains
the number of instance variables and
then a pointer to the list of instance
variables in this in this table so this
is kind of how Ruby stores these things
you know dynamically allocates based on
the number of instance variables you
have okay that makes sense what about
this stuff that I deleted so unions and
C allow you to declare two data types
together and then you sort of just
decide which one you want to interpret
those bits as and you get whatever one
it is and you just hope that you picked
the valid representation and not the
invalid representation so what this
Union does is it unions that struct with
this array of values I was like this
doesn't make any sense and then I
thought about it so our object in bed
Len Max is defined up here is 3 so we
have three things or a list of a
dynamically allocated list of things Oh
ruby has an optimization built into it
where if you have three instance
variables or less it stores them in line
but if you have more than three instance
variables it has to manage this like
lengthy heap so I've kind of already
learned a little weird optimization
trick about Ruby if I have you know
when I go from three to for instance
variables things get slower just by
reading this ridiculous definition of
the data structure right and so I don't
know whether that will actually ever be
useful in any context but I have another
fact stuck up in my brain that I know
about Ruby that I didn't know before so
then I wondered why is it three like why
do they choose the number three and it
turns out the reason is is that you in
32 is 32 bits value pointer is a pointer
to 32 bits void star as a pointer will
be 32 or 64 bits based on whatever you
know thing you're using and so this is
three values so it's the same size
either way so it's not like using up any
space so it's an optimization based on
that stuff so yeah anyway this is how I
spend my weekends sometimes just like
reading random C code and the Ruby
interpreter and learning like what's
going on so we have all these structures
and that's cool but resource code only
gets you so far
and it's often tedious especially if you
don't have this like C literacy or
low-level programming literacy so you
can also learn a lot about Ruby by using
the Ruby interpreter to inspect it so I
wanted to figure out like what actually
happens we call the blank method in Ruby
and rather than trace through a whole
bunch of C code I want to show you some
some api's that work really well here so
I have this memo RB file so this is just
a ruby file and i'm gonna we're gonna
ignore this allocate count real quick
and I'll explain it afterwards so this
script does a couple things first of all
it prints out the size of an object so
there's this really really useful thing
that I found most rubyists don't even
know about called object space in the
Ruby interpreter and what that does is
that gives you an API to access the
internal state of all of the objects
that the Ruby interpreter knows about so
you can actually query these at runtime
in your Ruby script to find out stuff
and this is much more interesting than
digging through source code so if
instead of counting up the number of
bytes in that object I could have just
called object space mems eyes of a new
object and found out the size of it and
you know printed that out so you can do
this kind of dynamic querying
at runtime and that gives you all sorts
of really interesting benefits so I just
deleted this allocate count method we're
gonna talk about it in a second but some
more Russian where it compares you know
this is the source code from that you
know doing the blank check and then
allocate count returns a hash of all of
the objects that were allocated while
this block of code ran basically and so
there's two things in there that I don't
care about which is free in total and
then I also delete all the ones where
there were no objects allocated and then
I print out here all the different kinds
of objects and then do some math where I
sum up all of them times their size to
find out how much memory was allocated
so this allocate count uses another
really interesting feature of the Ruby
interpreter I didn't actually write this
method I should say aaron patterson
tenderlove who works on the rails
project i liberally borrowed this from
him but the allocate count method is
really cool so in order to figure out
how many objects that your system is
actually allocating you first turn off
the garbage collector by using GC
disabled which again ruby is so dynamic
it just lets you tell it's garbage
collector or whatever at run time and
then you use object space to fetch what
are all the objects that are currently
allocated then you run your block of
code with yield and then afterwards you
count all the new objects again and then
you diff the two hashes and that will
actually give you you know all the
objects that were allocated during the
run of that block and then you turn the
GC back on because that's important and
then you return that hash right so this
is kind of an interesting technique I
will use interesting again like I said
doing stuff that's not good from an
engineering perspective can teach you a
lot of things like this is a short run
script so I could actually forget that
GC table and it wouldn't really do
anything that bad like this is not
actually allocating that much memory but
you have these sort of tools when you
can reach lower into your interpreter so
if I run Ruby mem dot RB so we see that
a ruby object is 40 bytes of memory and
that in the process of doing that
comparison it allocated 54 strings 1
hash and an eye memo I still don't know
what an eye memo is
I think it has something to do with the
GC internal data structures but I'm not
totally sure that's another cool part of
messing around is you don't actually
have to be a hundred percent sure of
everything you can learn iteratively and
like figure more stuff out over time and
it's only one object anyway so it
doesn't matter but if we take the 54 55
56 objects and we multiply those times
40 which is the size of an object in
Ruby we know that this allocates at
least two thousand two hundred and forty
bytes of heat memory and so you know
that's not a whole ton but it's still
allocating stuff you know on the heap
and it's making all these objects and
deleting them and has to deal with all
that garbage collection stuff and so if
we compare this to the rust example
where we did that char is in the
iterator one of the cool things about
rust is that char is a utf-8 unicode
scalar value which means it's always
four bytes unlike one byte where char is
and c or at least a byte and so what
that means is we know that that's always
Unicode enabled but more importantly
char is like a native primitive type so
because rust is a lower-level language
you don't have objects with all of this
you know pointer to a class and all
these instance variables it's just four
bytes like just literally four bytes and
that's it
and so what that means is since we're
not doing any heap allocation we don't
need a garbage collector and in fact
rust doesn't even have a garbage
collector but we also have amazing
optimizations so all of that stuff with
the closure rust and LVM put together
LLVM is an amazing piece of compiler
technology I'm so happy that it exists
it's a great way to make a new language
and be able to actually compete against
people who have the engineering
resources of something like Apple like
Apple invest in Swift and clang it makes
LVM better and that also then makes russ
better so you know with open source but
rust slash LLVM is able to figure out
when I have this when I have this
charged ORS so it's able to say okay
even though this is a closure
it doesn't actually close over any
variables so let's just make that into a
function pointer instead and then with
the iterator it knows again the same
kind of thing like
I don't actually need to keep allocate
anything to do any iterator stuff I can
just reuse this small chunk of memory
and so this ends up allocating something
more like 50 or 60 bytes of memory on
the stack as opposed to thousands of
bytes on the heap and that's like one of
the reasons why this is so much faster
even though it feels really high level
so so that's really cool thing compiler
optimizations are awesome
it also means unfortunately that
sometimes your unoptimized build runs
like really really slowly so there's a
common thing where people will join the
rust IRC room and they'll say hey I
heard that rust is faster than almost
any programming language but like it's
slower than my Python is I don't
understand what's going on or like did
you remember the release flag to turn on
compiler optimizations and they say oh
no let me come back and then five
minutes later they're like all right
that's 120 times faster now
nevermind like actually this runs in a
fraction of a second instead of multiple
seconds
so yeah optimizations are magic and
they're cool and then also being a lower
level language rust stack allocates by
default and makes heap allocation like
semi explicit so you know when it's
going on and so you can control these
kinds of things really easily but that
control doesn't come at the cost of like
super complexity obviously I'm a little
biased
I don't think rust is overly complex
because that's why I work on it but you
know it's not the same as like oh wait
I'm malloc this memory I have to
remember to free it what is going on did
I actually free it or not because the
compiler helps you with those kinds of
things and so so that stuff's all real
fun aha here's the link to that C
project I knew I had to slide about it I
just put it afterwards instead of before
so let's talk about comparing that rust
code to some C code because that's
interesting
so I mentioned discourse earlier and I
open up a new tab with this testing the
conference Wi-Fi during my talk that's a
bold move so one of the things I love
about Ruby is how flexible it is and so
this fast blank gem is written by the
discourse guys that I mentioned before
and all you have to do is require a fast
blank and when you acquire this file it
overwrites the definition that rails
provides with its own definition which
is like extremely easy to use
but you know also kind of like so
dynamic you don't know what's going on
sometimes but anyway so how much how
much faster is fast so according to its
own readme it's about 1.2 to 20 times
faster than the implementation in Ruby
which is cool so here's a bunch of
benchmarks and you know standard
disclaimers about like you know this is
just a benchmark don't believe me
because benchmarks are terrible and
complicated and you know but that's cool
also it notes this gem allocates no
strings during the test so there's less
of a GC burden - so it's faster so
that's cool but anyway this is written
in C and it's written by really smart
programmers like I'm gonna show you this
code but I'm not saying this code is bad
it's actually really good code but it's
just it's just the C stuff that makes it
really complicated so compared to that
dot chars dot all Steve C whitespace you
end up having all this so we have to do
this you know messing with the Ruby
interpreter to fetch Ruby string details
we have to deal with code point stuff
and then this is all the individual code
points apparently that our whitespace
except there's a special check in there
for Ruby version 2.2 and stuff and then
you know here's the actual encoding
things and whatever blah blah and so
some of this stuff comes down to the
fact that is whitespace is defined in
the RUS standard library but that's not
even that bad I'm gonna show you briefly
what that looks like
it's here oh no click the wrong one it's
this one
come on I know I saw it down there
sometimes grepping for code doesn't
actually work what is I click the wrong
button
this is the one I want char okay so some
of it is like okay that massive switch
statement is hidden in the standard
library but even in the standard library
let me make this bigger instead you have
if it's a blank or it's from this list
it's true otherwise if it's that one
check that it's a if it's a whitespace
property not it's false so like even at
its core the part that's not in the you
know file itself the part of the
standard library is even significantly
simpler than the C and actually the rust
is slightly faster than the C is which
is cool the reason why the cheat is that
rust only deals with utf-8 and the C
code deals with other encodings as well
but in today's world almost everything
is utf-8 all the time anyway so and but
that's why I like to say just as fast
because like it's not really about who
is faster it's about could you write
self chars all is white space or could
you write this and so like you know it's
about the averages of your if you're
coming from a dynamic language rust is
much more pleasant to use than C and
gives you that a that same amount of
like low-level control and speed and so
the reason well so another thing that's
really cool about this so ruby has C
extensions naturally just what that code
was I just showed you an FF I but since
C is sort of the universal latin of
programming languages every language
knows how to pretend to be it so I can
actually write a rust extension to Ruby
and have the rust pretend to be C and
the Ruby Turbo door will call into it
thinking that it's just C code and
everything works so this is actually one
of the earliest production uses of rust
was as a ruby gem for performance
monitoring and rails applications and
this is actually an extremely recent one
too so I titled this rust + gems because
there's a ruby theme presentation but
this is actually about Python but you
know whatever is fine I said I saw a
tweet one time that said something like
do I have Ruby or Python experience man
I can control any kind of gem with any
kind of snake
which I thought was really silly and
ridiculous so Ruby and Python are super
similar and so there's this startup
century recently posted this graph you
know with a little rust logo rolling
down the hill but they took a hot part
of their application on the server
written in Python and they replaced it
with rust instead and this is the graph
of their CPU time going down so you can
sort of see after they deployed the rust
code it was actually such a bottleneck
in their application that it made the
average response time of all requests go
down significantly because of this thing
so this is kind of an area where I'm
seeing a lot of interest in rust and
sort of one of my big pitches of rust is
you know maybe you don't do device
drivers for a living or you don't do
embedded devices or you don't work on
operating systems or even web browsers
anything that needs to be low-level but
maybe you know you're spending a little
too much money on your ec2 bill or maybe
your application is a little slow in a
particular pathological case and you can
like put rust into your other
programming languages to speed them up
you know whether it's Ruby or Python or
closure or Erlang or anything else and
so that's that's fun yeah this is the
processing time went down like okay so I
promised you at the beginning that I
would do some silly stuff but this is
kind of mostly been serious with maybe a
little bit of jokes so here's here's the
really silly part so I would like to
announce my own personal Fork of Ruby
I have four Comeau G's so I as I said I
got bored on the weekend and when I get
bored on the weekends I do silly things
sometimes and so I have a link here it's
got four whole commits this is my
improvement improvement to Ruby is for
four commits and what it does is it
replaces one single function inside of
the Ruby interpreter with rust code
instead of with C code and then I glued
them together and part of why I did this
is you know so often times you talk
about you know writing good clean code
so that you know you can like maintain
it later or whatever this is not this
and the nice thing about that is it
actually lets you do things faster when
you don't have these kinds of constraint
so you example the first commit here is
called commit makefile
and what this first commit does is I
called dot slash configure to generate a
makefile
and then I just committed it into the
actual repository why did I do this
because I I did not want to figure out
and this is the you know junk that gets
installed is because I didn't want to
have to figure out how to get auto tools
to rewrite one file in rust instead of
in C so Ruby has this really complicated
build system that generates these make
files and I'm like this patch is never
getting up streamed so whatever let's
just like generate it and check it in
and that's fine because this is never
gonna run on anyone's computer but my
own so who cares
whereas if this was real serious work
that I was doing I would have had to
deal with and figure out Auto Tools and
that would have taken just as long and
been far more painful than actually
messing with the internal internals the
interpreter itself which is like the
whole point okay so I'm gonna show you
briefly a little bit of what the code
looks like here so this is my fix to the
make file so Ruby is really modular and
each of its classes is defined in its
own dot C file so I said okay I would
like to replace one function in the
array class so I need to first give it a
blank rule for array dot C so that it
doesn't try to build at the normal lay
and I took the lines that would usually
be used to build a raid out C and I
copied them and made a raid ah-oh
depends on Ruby array dot c and r array
dot RS I realized that the Ru nature of
both languages made the naming
conventions really bad so instead of
making it understandable I just named
them very similar things and like
whatever it's fine so I call the rust
compiler on the rust file and spit out a
static library and I ignore exceptions
basically and then I that's a whole
another complicated thing in rust we
don't really use exceptions in rust we
kind of have them sort of it's whatever
but you don't want those in C because
exceptions through your C code is like
undefined behavior and that just gets
really terrible so just panic abort if
you get an exception and then compile
the original Ruby array dot C file into
a ruby right
and then call the linker together to
smash the two things together into a
final radio output and then the rest of
the build script is expecting a Rea dot
oh so it proceeds on none the wiser that
I've just like jammed a bunch of Ruby
into the C code so again if this was a
serious project I would have to make
this good but it's just for fun so I can
not have to care about making it good so
then then comes another bit of joy which
is actually declaring the write function
signature so I'll show you briefly what
here's the C function I decided our
place I decided to keep it small at
first this is a function called mem
clear and what it does it takes in an
array and it replaces every element of
that array with nil so all Ruby
functions start with RB underscore for
that name spacing and so this takes a
pointer to a value which we know must be
an array this code does not check that
invariant of course we could pass
literally anything in here but I'm sure
it's fine and then the size of the array
which we hope is the actual length of
the array or not but again who knows
it's not checked and then same thing I'm
not gonna say bad things about the
maintainer of the Ruby interpreter
because this is good C code the problem
is that C idioms are just inherently
dangerous so while we decrement size we
dereference mem set it equal to Q nil
which is the Ruby internal name for nil
or null and then increment that pointer
so this is doing this like decrement
pointer integrand shenanigans and it's
very elegant and it's very
straightforward but like if you get
anything wrong this is just gonna
explode horrific lis right so like if
the size is like bigger than anything
you'll start overwriting memory
somewhere if you forget to do certain
these things it's just it's just C
that's just what it is
I love C but I also hate C so here's the
Ruby version or the rust version so I
have to do some shenanigans it doesn't
matter but one of the most important
things is we have to figure out the
values that the C code is expecting in
the Ruby interpreter and bind them to
rust types so here I went and looked in
the Ruby source and I found out okay
that value thing is actually a you int
pointer T type so I just alias it so I
can use the same names in my code as
they do in the Ruby interpreter and then
it turns out that
nil Q nil in Ruby Ruby has an
optimization where instead of storing a
full object for nil they just have a
special memory value at the end of the
pointer and that is 0 X 0 8 I do not
know why it is that but that's what it
is so we just make a pointer to you know
that special those special bits flipped
and that's how nil works which is you
know an optimization but also makes the
code more complicated so here here's the
same implementation in rust and I tried
to transliterate it as close as possible
to the original C so while the size is
not equal zero subtract 1 so we've
already made it a little more clear by
splitting out you know not doing the
subtraction and the comparison in the
same expression we dereference and set
the value equal to nil and then we
increment the pointer by 1 with this
offset method so you know rust has a
slightly you can still do pointer
arithmetic but it's not just at some
master numbers it's you know we have a
method that does the right thing and
that kind of thing and then this is some
stuff that you need because Russ needs
it it's fine this is like the code that
happens if you would throw an exception
but we're not doing anything with it so
we just loop infinitely and like
whatever it's fine so so that's like the
the immediate thing and so then I have a
second commit where I was like ok now
that I have this thing working and oh
yeah here's the way that I know it works
by the way so ok so if I if I run make
this will build all this stuff and it's
gonna sit here for like just a second
and it's gonna compile all the things
and it like works and then if you run
make check it will actually like run the
tests and the tests currently pass but
if I were to say if I were to say delete
the code in RB mem clear and then run
make I think I'm not sure if it fails to
compile yeah it's seg faults the
compilation process so this is how I
know that my code actually worked
because like that not only does it
compile but then the tests pass but you
know originally when I was first doing
this I just tried to do the function
signature and it turns out that arrays
are used a lot in Ruby code so if you
break a fundamental part of array
nothing is going to work
oh okay
uh anyway back to your so I was like
alright I'm gonna rewrite this an
idiomatic rust I'm on the rust core team
I've been programming rust for a while I
know how to make this better so instead
of doing this loop what I did was
instead is okay use an actual for loop
so loop from zero to the four I in zero
two sighs you know let's not do that
manual checking of the of the thing
ourselves let's just iterate over those
and then we can you know adds to the
original pointer the offset and then set
that equal to nil and I was like I feel
good about myself everything is you know
this code is much better look at how
awesome this is you know this is
actually working there's like all that
compiling stuff took a while in the
first place
so then of course you know what's the
best thing that you can do to like not
to ruin your good feelings about what
the code you just write post it to
Twitter so I tweeted a link to this and
one of my former co-workers was like
Steve what are you doing there's an even
better arrest implementation and so that
is rust has this feature called slices
and I really love slices but I don't
have a whole whole time to talk to you
about slices but as I mentioned before
in the code in the C code up here we
have a pointer to this array and we have
the length of the array but they're
totally disjoint so like this is a
really common pattern in C code where
you you take an API and you say here's a
pointer to a list of things and then
here's the number of things that exist
but since those two things are totally
disconnected they can get out of sync
and when they get a sync really bad
things happen so we have this feature
and rust that's in several other
languages as well it's not unique to
rust but it's one my favorites and
that's a slice and the whole idea of the
slice is if you put the pointer and the
length into the same data structure they
don't get out of sync and everything is
much nicer and happier so I can actually
construct slice from raw parts mute says
hey give me a pointer and a length and I
will turn that into a slice for you and
then that's really cool because I can
then iterate over a slice and say hey
give me every element of the slice and
then just set that equal to nil so now
we've taken that like explicit code
you know doing all the decrements and
the pointer arithmetic and stuff and
made this really nice loop where we just
say please give me all the elements and
set them to a thing so not only is this
like more convenient but it's also
significantly more reliable obviously in
this case we're still relying on the
caller to give us the right values
outside of this function but at least
inside the function we know we're not
gonna override and do our math wrong so
it kind of made this significantly less
error-prone inside of it and you know
for three lines of code whatever it's
fine
like I said nobody's gonna actually be
using my you know my Fork of Ruby in
production so uh this is kind of my like
side side side side project so I
eventually dream of replacing all of
array and rust I'm just gonna keep this
it's it's already out of date can't
automatically merge but whatever like
I'm gonna keep replacing these
particular functions as a way of
learning this stuff and you know as I do
so I learn more and more about Ruby and
also practice writing some rust and so I
think that having these kinds of like
ridiculous silly fun side projects to do
is a great way to learn more stuff that
you know you can actually use
practically speaking later so with that
that is all I have for you please go
forth do fun stuff and enjoy computers
for once thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>