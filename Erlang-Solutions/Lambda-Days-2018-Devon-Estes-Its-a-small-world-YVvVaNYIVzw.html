<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2018 - Devon Estes - It's a small world | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2018 - Devon Estes - It's a small world - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2018 - Devon Estes - It's a small world</b></h2><h5 class="post__date">2018-03-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YVvVaNYIVzw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm super excited to be here and it's
such an honor to be speaking on a roster
of so many incredible other speakers I
was looking at the other speakers and
all the things that they've done the
research they've done what they've
contributed to functional programming
and and these really impressive
credentials and great degrees from big
universities and justyou know I also
have an advanced degree so that's why
I'm qualified to be here speaking to you
today I have a master's degree in Opera
actually that was my my sort of first
career I started programming as a kid
and it's a continuing a break to do the
music thing and then went back to
programming and I've actually been
writing elixir now for two years
that's my functional language of choice
and a woman to talk to you a little bit
about today is is the examples are in
elixir but it applies to any any
language where you have a module so I
assume that's that's many of you all so
this is my dog she's much bigger now her
name's Miki she's about four this is her
when right after we got her she still
loves to lick my beard which is very
cute but I walk with me here every
morning and every evening about 45
minutes through the park in Berlin and
while I'm walking I'm usually listening
to podcasts and one day I was listening
to this episode so this is a podcast
called undiscovered it comes from
American public media back in the States
and it's focused on issues of science
and math and and the stories behind in
science and math it's great podcast I
really recommend it they're only a few
episodes they're gonna make more but
this episode in particular was about
this phenomenon called the six degrees
of separation the idea is that we are
all connected every person in the world
is connected to every other person in
the world in less than six handshakes 6
or less handshakes you may have also
heard this in another iteration so
there's this game called six degrees of
Kevin Bacon that says you can connect
Kevin Bacon to any other actor living or
dead in less than six degrees based on
just who's been in what with someone
else
so the idea that these networks exist
have been around for a little while
there's actually some initial research
back in the 50s by a researcher named
Stanley Milgram who you may know from a
very different type of experiment
but the episode of this podcast focused
more on the research of these two men
so that's Duncan Watson Steven Strogatz
and back in 1995
dokin Watts was a researcher studying
crickets in the basement of Cornell
University in upstate New York he was
actually a mathematician so why he was
studying crickets I still don't really
know but one night when he was sitting
in the basement of Cornell listening to
crickets chirp he was thinking about
something that someone had told him
earlier which was this idea of six
degrees of separation and being a
mathematician he thought that sounded
like a really interesting math problem
so he pitched the idea to his advisor
dr. Shah gods there and they said sure
let's dig into it let's see if this is
even possible so what they did is they
started off with the two known types of
networks at the time there was this idea
of a regular network something that has
very has structure and format to it this
particular network is called a lattice
Network and just so you know not a
mathematician I am going to use the
terms network and grass somewhat
interchangeably here even though they
are technically different but that's
just me so yeah this is a lattice
Network and these networks have a
characteristic two very important
characteristics one is that they have
what's called a very high clustering
coefficient and then the other is that
they have a very high mean shortest path
now if you're not familiar with those
terms that's okay we're gonna go into
them and explain what they are but these
regular networks are characterized by
those two things and then there was also
another kind of network that they were
familiar with and that was the random
Network now this example of this random
network has the same number of nodes
same number of edges but those edges are
assigned those connections are assigned
completely randomly according to just
random assignment and these random
networks had a very different set of
attributes these random networks have a
very low clustering coefficient but also
a very low mean shortest path what they
discovered was that if the world were a
regular network then this whole idea of
six degrees of separation cannot
possibly be true there is no way that
every other person can be connected in
six degrees because of that very high
mean shortest path that if the world
were a
network well yeah I mean we don't even
need six steps you only need four or
five to connect all seven billion people
on the planet
assuming they have a sufficiently high
number of connections and the real
breakthrough that they had was realizing
that this isn't how the world is
certainly not the world of people's
interpersonal connections is structured
we have cliques we have people that were
all related to family that all knows
each other there's a lot of connectivity
within those groups and friends and
co-workers so our connections are not
random they are very regular but how
could it be possible to have the six
degrees of separation with essentially a
regular network structure and what they
realized was this if you take a regular
network and they change just a couple of
those connections very quickly you get a
very low mean average path so what we
have in these small world networks which
was the term that they coined is a
network that has a very high clustering
coefficient but a very low mean average
path you sort of get the best of both
worlds from both of the other existing
network topologies so now I think it's
kind of important that we learn how to
calculate these two metrics this
clustering coefficient and mean shortest
paths so this is the formula that they
gave in the paper that they published in
the Journal of Nature in 1998 that's how
you calculate the clustering coefficient
for a given node in a graph and then the
clustering coefficient for an entire
graph is the average of those two nodes
of all the nodes in the graph so
everybody understands what this means
right if you're looking like me that
makes no sense to you like again
musician and there's a joke that you
hear in conservatories sometimes that
there are three types of musicians those
that are good at math and those that
aren't so we're going to go and actually
talk about in normal terms how we
calculate this clustering coefficient so
first you need to get the clustering
coefficients for a single node and for
that single node you need to say how
many neighbors do I have how many other
connections do I have and then of those
connections how many possible
connections are there between my
neighbors
and then of those possible connections
how many of them are actually there in
in the network how many connections are
there and then that is your clustering
coefficient it's the number of your
actual connection over the number of
possible connections all clustering
coefficients zero is no clustering and
one is is very high clustering so let's
look at an example let's imagine that we
have these four nodes and that blue one
is the one we're going to be calculating
our clustering coefficient for and we
start it has three connections to those
three other nodes and if all three of
those connections were there then we
would say that that node has a
clustering coefficient of one all three
of the three possible connections are
present but if only two of those three
if that middle one is not present then
we say that that node has a clustering
coefficient of 0.6 repeating
okay and down the line down to 0.3 and 0
then to calculate the clustering
coefficient for an entire network or for
an entire graph you go and go around the
circle basically in this case and we say
the clustering coefficient there is two
out of three and here two out of three
as well this bottom one only has two
neighbors and there's one connection
that's present and same thing over there
so we can do a little bit of math and
find out that the average for the entire
network is 2.5 over 3 or 0.8 3 repeating
now that's considered a fairly high
clustering coefficient and from looking
at this graph we can see that there's a
lot of connection there that's a very
cliquish
graph almost everybody knows almost
everybody else there and then the other
term we were talking about earlier was
that the average shortest path or the
mean shortest path and this one's
actually luckily quite a bit easier so
in a network or in a graph to calculate
the average shortest path you take all
possible pairs of nodes and then you use
some algorithm to find the shortest
distance between those nodes and then
you take the average of all of your
possible pairs luckily that that
shortest path length is a very solved
problem in computer science it's very
efficient there are lots of things that
can do it for you
so this quote comes from the paper that
Stroh gots and Watts published in 98
these things where I was reading this
paper sounded really interesting sounded
like something I want to have in my
software I want to have enhanced signal
propagation speed I definitely want to
enhance computational power and
synchronize ability sounds cool too I
was thinking that maybe this would be
something that would be great in some
sort of distributed calculations like a
MapReduce thing or some sort of machine
learning or Big Data stuff also the
synchronize ability would be great in an
eventually consistent database like
react so I was curious if these things
actually existed and I continued reading
the paper and luckily they had to have
proof for their assertion as well they
had this idea of a small world network
but they need to actually find them so
the first place they looked was here
that's a little worm called C elegans C
elegans is great for research because it
has about 208 neurons in what you might
call its brain and you can slide one of
these things under a microscope and you
can look and see all of those neurons
and you can see how all of them are
connected and lucky enough for Duncan
Watts
that information of how all those
neurons were connected was sitting there
on a floppy disk at Cornell and he could
look at it and assess that network and
see that those neurons are all connected
in a small world network and it would
make sense then that if brains of
nematodes are connected in a small world
network that actual neural networks are
connected as well many neural network
implementations are our small world
networks I can't speak us whether that
is intentional or not but that is
something that you find many neural
networks these days are small world
networks and how they're designed and
they also looked at the power grid of
the western United States
now that's something that you really
want these properties of a mean shortest
path because you don't want electricity
traveling too far otherwise it's it
loses a little bit of its power but you
also want reliability you want
clustering so that if something goes
down you can get it from a different way
so funny enough even though at the time
no one had come up with this idea of a
small world network that just happened
to be there it was designed in that way
naturally at the time their paper was
published in 1998 Facebook didn't exist
but later on after did exist and they
had a little over billion users they did
some research as well and found that the
connections in their social graph are of
course a small world network and they
even saw that you didn't need six six
handshakes you only needed a little bit
between four and five to connect most
people people have even seen smaller
networks in the relationships between
characters in Game of Thrones and in
natural language in human language that
has existed well before we even had an
idea of what what networks in computer
science were so these networks are
everywhere there's the phenomena that
you can see just about everywhere in the
natural and man-made world but that last
bit is what really interested me because
I wanted to know if these are in our
software these small networks if we can
find them in our software and more
importantly I wanted to know if we could
find them in our code I'm really
fascinated by how we create new
abstractions and how we organize code
into human understandable concepts and I
wanted to see if maybe these small world
networks could help us organize code
better so that we can leverage some of
this power to better maintain and
organize our code so what I did is I
wrote a little tool that could parse
elixir and see what modules depended on
other modules so and just so you know
what I'm calling a dependency is anytime
one module calls a function in another
module or calls a macro in another
module or includes that module because
at that point you don't know where
exactly the functions coming from but if
we assume that it's including it or some
function from it that's a dependency and
when I got what I wanted is to see a
nice graph so that I could see all of
those dependencies and I got that it was
great this is the dependency graph for a
library called bench II it's a bench
marking library in elixir that I work on
with my friend Toby down there and this
was like almost everything I wanted it's
a little blurry here but you can see the
idea is pretty clear you can see what
modules are using what other modules and
that
basically what I wanted I pretty quickly
ran into another problem so when you
started getting with bigger libraries
they started getting pretty hard to use
so this is the dependency graph for the
Phoenix application that serves the
website for the chainsaw com
that's another podcast I listen to
sometimes about open source it's really
wonderful but they serve their their
website from a Phoenix application and
it's huge and there was no way I would
be able to look at that graph and get
any usable knowledge as a human I needed
a better solution so I found this
luckily luckily it's called gay fior
Jeffie I'm not entirely sure how to
pronounce it but it's an open source
java application that runs anywhere
thanks to the JVM thank you for that
guys and it was everything I needed it
gave me a much better you interface to
work with these larger graphs but it
also gave me calculation of those two
metrics that we'd spoken about the
clustering coefficient and the mean
shortest path so I got to playing and I
put I put some stuff into Gaffey now
what I did is I started with 14
applications of these applications five
of them were Phoenix Web Apps so pretty
large and nine of them were smaller open
source libraries why 14 applications you
asked because I am NOT a real scientist
after 10
I saw a pattern and then I did another
four more and the pattern was still
there and to me I thought that was kind
of good enough I also have two little
kids that I like spending time with so I
didn't want to spend all my time
analyzing all these libraries I felt I
had something that was pretty cool but I
also do want to say that this is not a
substitution for actual peer-reviewed
research I would love if someone would
dig into this more who had the time and
the resources to really explore this in
depth I do think there's something there
but I just want to give that caveat that
musician not scientist so what I got
we're graphs like this this is the
dependency graph for the modules in the
web application that serves Hex p.m. so
this is the package manager for elixir
and increasingly for Erlang as well and
their web application is a phoenix app
as well
and I could get really great pretty
graphs like this thanks to Jeff you and
I could also do fun stuff like this I
could color the nodes based on
attributes of those notes so in this
case this is the pet the dependency
graph for Benjy again and the darker
green ones have the higher clustering
coefficient and the lighter green ones
have the lower Chloe clustering
coefficient you could even dig into the
specifics on each node they have a
really great breakdown where you can see
the attributes of every node in your
system and see how they relate I spend
frankly too much time doing this because
it was really cool and making pretty
graphs and stuff but I needed to get
back to the original question which is
are there small world networks in these
graphs in these networks so I took a
look as we can see not really that's the
clustering coefficient and this is for X
dot p.m. again it's a clustering
coefficient of zero point zero point two
one four that's really large zero point
one zero
that's really low and I also noticed
this which you definitely can't see but
up there there's a very tiny red dot
that shows that of the almost 350
modules in this application more than
250 of them have a clustering
coefficient of zero
no clustering whatsoever for more than
two-thirds of the application that was
weird but I kept going I thought maybe
this is an outlier and then I saw this
so this is plug another open source
library clustering coefficient zero
point 2 1 then this is post Beck's the
Postgres driver again very small 0.20
time X another open source library very
small 0.33 this was actually the biggest
I could find distillery very small again
zero point three one
and lastly X dock zero point three one
so I'm not lastly we also had the
changelog as well that big phoenix
application I showed you that's point
two so at this point I already know
small world network not found I thought
that would be there I really did but it
wasn't
and just to take it that next step
because you know there are these two
attributes it's the clustering
coefficient and the mean shortest path I
looked at the mean shortest path and
found that they're all very small these
networks were showing indications that
they were random networks which I
frankly couldn't believe there's no way
that we create modules randomly that
there's no structure or there's no
reason behind how we create abstractions
in other applications I just couldn't
believe that so I had to think some more
I refused to admit that it was possible
that there's no rhyme or reason to how
we create abstractions because that
clearly wouldn't make sense
and eventually I walked my dogs to Moore
and I thought some more and it came to
me that what we have is something that
we deal with all the time that has a
very low clustering coefficient and is
very efficient to traverse and that's a
tree and then it made total sense
because when you're trying to solve a
problem you just start with essentially
that problem you say I want to do a
thing so I'll write a function to do
that thing for example I want to write a
function that can benchmark elixir
functions and tell me how fast they are
maybe compare them amongst each other
and so you write one function that does
all of that and because that is just
madness and trying to maintain and work
with maybe you split that up into
multiple functions so now we're breaking
things down a little bit and at this
point we have a bunch of functions but
those functions are so really big so
maybe you break those functions up a
little bit more and now we have smaller
functions but we still have that one
huge module with like 150 functions in
it that's not easy to work with so now
we group some of those functions
together into modules and what we've
done is we've taken that problem and
we've decomposed it into its individual
parts and we've grouped those together
we've created logical abstractions that
make it easy for us to know what type
what part of the problem we're working
on and what we've ended up with is
essentially a tree we have that one
problem that we're trying to solve and
to solve that we've broken it down into
smaller subproblems it's like the basis
of Computing's decomposition and maybe
it's not just a tree maybe it's a little
bit more because maybe there's some
shared code that you want to extract
there's some duplication and when you do
that you end up with this sort of
structure it's almost a diamond
but you still have very clear levels of
abstraction and you still have really
unique structure that makes total sense
but it also has a clustering coefficient
of zero this graph has a clustering
coefficient of zero so it is not a small
world network I actually found this
somewhat frequently in the wild when I
was looking at those those libraries
this is the module dependency graph for
the HTTP library an elixir called HTTP
Zen which is very clearly a very wide
tree they did just that they broke down
that one problem they had into several
smaller problems and they ended up with
something that had very very low
clustering but I fought back and I had
another question now which is where's
this clustering coming from if we're
going to be breaking down problems into
essentially these tree structures with
almost no clustering how are we seeing
some libraries with a clustering
coefficient of like 0.33 these are
libraries written by programmers that I
admire and respect and I would imagine
that they're doing a good job so there
must be some reason for this clustering
and what I found were two more patterns
so we go back to this idea of some
shared code that we've extracted maybe a
little helper module which has some
functions in it it's used in a bunch of
other modules well right now this has no
clustering but if we add one more
connection now there's a significant
significant amount of clustering in that
application just by having that
dependency that goes down an extra level
now I wouldn't say this is really a
problem you're going to see this quite
frequently you know enum is going to be
used everywhere string is going to be
used very very frequently across many
different levels of abstraction I
wouldn't think that you would
necessarily need to solve this as a
problem I don't see this as a problem
but there was one other case that I did
see that was a problem that I thought
was a problem so what if we need to add
a logger to bench e that instead of
formatting and writing to the console
you're writing to a log file as well and
in that logger it's depending on some
functions in the console formatter
because they're basically just taking
raw data and format it in some nice way
and instead of writing it to the console
they're writing it to a log file so you
depend
those functions in the console for
matter as someone maybe coming into that
codebase later you might ask yourself
why is the logger depend on the console
for matter why am i calling those
functions that doesn't seem like a very
clean abstraction to me this is an
instance that I saw of when maybe
there's a missing abstraction clustering
was an indicator of something that can
be abstracted and an extra concept or
idea that can be named that can improve
the readability and the
understandability of that code to people
coming into the code base later so while
this is fine and this works and maybe if
it's just one function it's not a big
problem but maybe if it's several it
might be better to extract those
functions out into another module that's
depended on by both of those other
modules this to me is nice and clean
pretty simple makes sense
but it also has a clustering coefficient
of zero so we're back to that idea of
removing clustering now before I came to
elixir I spent a lot of time in the
object-oriented world and and in that
world there's this idea of a code smell
a code smelt means that not necessarily
that something is wrong
but maybe something might be ready for
improvement will say and to me I'm
starting to see this idea of clustering
as a code smell it might mean that maybe
there's an abstraction there that you
can make maybe there's another concept
that you can name to help you reason
about your code better it's not always
there as we showed in that original
problem with some of those very basic
abstractions where we pull something out
into a very very widely used module but
in other cases it might be helpful so
that's the thing that I really took away
from this exploration is seeing where
clustering is how it can be affected
when it comes from and how we can use it
to potentially write more understandable
software
so this quote comes from the last
paragraph in watts and Strogatz is paper
and I definitely think that they are
right there
these small world networks and these
small world architectures have such a
unique property that they are found
everywhere and it really does warrant
more research and I would hope that this
continues to be explored in our world
the world of computer science from what
I could find there was very very little
exploring these types of ideas usually
they were on the actual topologies of
relationships between a running program
and not between the in the code itself
and how that code might be structured
better and the relationships between
parts of code be it functions or modules
so I would love to see people dig into
that more the people that actually are
scientists and have the resources and
the time to explore ideas like this and
as I was working on this idea and
exploring it more I thought of a few
other ideas that I just want to toss out
there in case anybody knows anybody I
know there are a lot of very smart
researchers here at this conference so
maybe I can convince somebody to dig
into this more so I do think it's really
interesting one idea I thought of is
maybe there is some relationship between
types in a type language I don't work in
any type of languages I have no idea
maybe it's a thing maybe it's not but
maybe if you look into it there could be
something there that could help you
design your applications better this is
something that I actually really wanted
to explore but couldn't get a hold of
the data so I would be shocked if the in
large-scale OTP applications the message
sending between processes wasn't a small
world network especially in those
processes or those applications that are
modeling human human conversational
patterns things like whatsapp you know
but I would love to see how large-scale
OTP applications the relationships
between processes in those applications
how they're sending messages how they're
interacting what depends on what what
what communicates with what the most and
to see if there is small world network
there or if there isn't could we improve
by making it a small world network
similarly relationships between services
and a micro service architecture now
that those are becoming larger if people
have the data they might find something
there but those those attributes of
small world networks those that
consistency the synchronize ability the
computing power I would imagine that you
might want that in your micro services
architecture also consensus you can
gather algorithms in distributed systems
again about that synchronized ability
thing if small world networks aren't
being used for consensus seeking
algorithms maybe week admit design a
better consensus seeking algorithm by
consciously designing a small world
network I don't know maybe that's the
way it already is but if it isn't that
would be interesting to know and lastly
I sort of intended this as a bit of a
troll because I I'm like vehemently
allergic to hype and everybody is
talking about blockchain and Bitcoin and
stuff but I would actually be shocked if
there wasn't a small world network
hiding somewhere in some blockchain
application so if you do want to get on
my train please check it out
so that's all I have for you today thank
you very much for having me
thank you for great presentation and it
was very interesting but I have a
question which I didn't understood and
it is that you verse or like I could see
the benefits in like in between the
people and there is a small world
network hmm but you are speaking also
that we can improve for example the
messaging patterns in OTP application by
making it a small world network so but I
do think that this is an improvement
from for example the tree because like
the module system of an application was
was not a small bird network so what are
the benefits for writing this program
involved well when we look at the
characteristics of a tree which is
essentially a random graph the the
clustering in that the lack of
clustering in that means that it is
slightly more difficult outside of
normal cases to communicate between
processes so there might be extra steps
in in highly cliquish processes so I I
would imagine that for example if you
have a process that represents like for
example if you are whatsapp and you have
a process that represents a person
trying to communicate with another
person if you have a large sort of tree
structure of a look up to get to from
one person to another that will take
longer than if you need to have some
sort of click-click-click ashiness and
clustering within that smaller part of
the network so if you add basically
horizontal connections in a tree you
bring down the shortest path by
increasing the the clustering within
that small thing so I would imagine that
that's that increased synchronize
ability that they mentioned that small
small world networks have so I would
assume that that would help you
basically get two states that need to be
synchronised synchronize faster so if
you have an inbox for one person in an
inbox for another and you're trying to
make sure that they both have the same
set of messages that represent the
messages that they've sent to each other
and you need to synchronize those then s
mobile network would give you increased
synchronize ability
so that would be my assumption but I
don't know it could already be that in
those large scale to be applications
that's already there I just don't know
of any research that shown it yes or no
either way but then there are definitely
things like where the things I thought
it was like maybe Supervision trees but
it was like no clearly that's not a
small word no network that's a tree it
says it in the name and that's something
that that you don't necessarily want to
have as a small world network unless
you're doing like one for what is it one
for all so essentially all of your child
processes are connected because if one
crashes it's going to propagate down and
restart the rest of them so but yeah
clearly the way that setup is a tree and
that's set up for a very specific use
case and I don't think it can be
improved but it doesn't mean that there
aren't possible ways that we could
explore and see what's there actually I
have a couple of questions first thing
you wanted to mention something about
the statistics that you made about the
point which was high above is that the
kernel module are something else so
those that was a histogram of the number
of modules the number of nodes that have
a certain clustering coefficient so that
one point way at the top showed that
they were for example of that hex PM
there are about 250 modules that had a
clustering coefficient at a clustering
coefficient of zero
that was a huge outlier in terms of the
distribution of clustering coefficients
across that graph so it's not
necessarily that one module was being
used everywhere it's it that wasn't a
measure of connections that was a
measure of the clustering coefficient of
modules so the histogram of that so most
modules in almost all of these
applications had a clustering
coefficient of zero okay and the second
question while you are talking I was
also thinking about this the thing is
that how Erlang solves the process
management and everything is very
similar to how the computer works
actually it starts from one point and
it's a three in the more way and the
thing is how they accomplish the same as
the computer they have registries when
they have only hashes and dictionaries
with addresses and stuff like that
maybe this is for another kind of
architecture maybe it's an architectural
on another approach totally not this one
I don't know about quantum stuff maybe
that you're a musician and I'm a
software engineer but not much not that
much and so have you tried that have you
seen those stuff because ya know so like
I said I don't think that everything has
to be a small world network they're not
going to be necessarily everywhere but
because they are a unique network
topology that I think not many people
are aware of and that there are sort of
observational e proven benefits to that
network topology I think it behooves us
to at least explore the idea there could
be constraints like just the fact of how
computers work that means we cannot
implement a small world network but if
there are other ways that we can
leverage that network topology because
as programmers I know I think of
everything as a tree or a list basically
and a list is basically a tree like
everything is a tree but maybe
everything shouldn't be a tree maybe
there are things that we can improve by
using other structures and other other
other ways of designing an application
both at the code level and at the
runtime level they could give her some
benefits so if we I definitely think
it's something that is worth exploring
but it doesn't mean that there's
absolutely something there okay I asked
have a comment
I think the module structure knows tree
is really good so and the separation of
concerns for me to understand the
network is better that it's not the
connected network you so the only reason
is for speed so it's an optimization
thing some some places we probably will
benefit to having a connectedness yeah
but then that will cost understanding of
the network so it's just for the speed
and that's an optimization thing I think
oh yeah absolutely I mean like I said
the code smell doesn't necessarily mean
that something is wrong and often when
you need to make those sorts of
trade-offs it's a trade-off you have to
make it's a trade-off and everyone makes
usually the trade-off that people make
most when they're designing an
application is speed for for complexity
so that's a totally valid thing to do
that's that's something that we all have
to think about and that's why they they
pay us the big bucks is because we're
the people that can make those tough
decisions but that's yeah that's
absolutely something that that
frequently has to be done is that
trade-off of speed for complexity
building on that isn't that the case
that it's actually not beneficial for
like a module architecture to be a small
world network yeah so I think that's
what I noticed is that I my original
theory upon hearing it was that it would
be a small world network but after doing
the research I found that it's not and
that it is in fact not beneficial like
we can use the the measure of that
clustering to see where there are
potential things that we might fix so
clustering I'm actually seeing as a code
smell essentially not as a beneficial in
terms of how we structure the
dependencies between modules how we
break decompose our problems basically
if we're decomposing a problem cleanly
and making good abstractions we should
see a very low clustering there are
cases like I showed with maybe there is
some like the Ino module and elixir is
going to be used everywhere but in the
string module but in our applications we
should potentially aim for a tree or
something that is not a small world
network but I could only arrive at that
by trying to find the small world
network and then it sort of made sense
once I looked for that thing that I
thought might be there that oh no of
course it's not going to be there and
this is actually much better
we still have five high I agree that the
statistics you show might be a good
indication of whether we have a good
structure of our modules and I was
wondering if you have maybe an automated
tow and then can analyze the project and
show us the statistics because this
would be helpful to analyze why we might
have too much coupling and which modules
might need to be refactored so it's not
automated at the moment right now it's
still a two step process but I do have
that module dependency graph generator
up on github if you want to use it for
elixir applications it it right now
works on just about everything except
like the elixir codebase itself and ecto
because of some stuff that they do in
the ast with with playing around with it
that right now it can't parse frankly I
haven't developed that any further
because I wasn't sure if people would be
interested in it but right now for
simple elixir applications you can take
that run it on any set of files it just
reads reads the files and really as T's
the files and it will spit out a graph
that you can put into that tool I
mentioned efi or Jeffie that you can
find online and that will do all the
calculation for you and you can dig into
that dashboard that it shows you know
show you which nodes have a very high
clustering coefficient you can take a
look at just that part of your graph and
see where the clustering is and from
that you can see if maybe there's
something that you can extract maybe
there's a missing abstraction maybe
there's something that you could
structure a little better there so it
most of the hard stuff in terms of
parsing the alias or ASD and giving us
the new module dependencies is up on
github if you want to see it okay any
more questions I have one or two
comments actually so a few years ago I
remember when a Java and you know maven
dependency management was something new
and cool and then some of our students
also did similar exercise as you with
analyzing this dependency trees between
different modules and I think the
results were quite similar yeah so so
it's not exactly the the small world
network and you mentioned also the the
trace near the messages between actors
for example Tina in the system so yeah I
mean just behind this wall
there was another talk we had some
applause yeah so two other my students
have just presented the tool for tracing
actors systems innaka and what they
produce is actually a graph yeah so this
message is so probably it's also an
interesting option to feed this graph
into one of the tools yeah say and see
if there is some there are some puppets
yeah yeah yeah I'm the data is out there
people you know people have these huge
applications that they're running in
production and they have all that data
so if someone can get their hands on and
analyze and that would be super cool
yeah Oh still there's some question up
there it's it's not really a question
just thought that I just had maybe in
architecture of software
the thing that is both might be a sound
design and a small world network maybe a
layers of dsls so you did decompose your
problem into like layers of languages
and those are clustered together kind of
yeah I mean with within itself languages
are clustered together and they are also
connected to to the layer above and
below so yeah did you just just just
this have you encountered anything like
that so what I saw most frequently was
not that sort of layering but those
layers weren't necessarily connected so
for example here you can see up in the
top right there I don't really know how
this works
I don't use this type of thing before
but you can see up at the top right
those sort of sub trees and you can see
another one at the bottom right there
within those layers there are lots of
other Leafs in that that graph in that
tree but frequently they weren't
interconnected they weren't calling each
other they were independent or calling
something further down in the dependency
graph okay thank you when I listened to
your talk I was a thinking of a torrent
networks specifically the Khadem lien
Network for distributed hash tables have
you done any research or looking into
that and it seems like there's a lot of
back propagation and similar systems to
your small world network model I haven't
any research into that I haven't thought
about it but now that you bring it up
that would be another great thing I
would be shocked if there were not small
word networks in those sort of
distributed file sharing like like a
ipfs or something like that sort of
setup of distributed distributed
computing distributed networking
distributed anything these sorts of
networks I think you're going to be very
common although I have not looked into
it at all I haven't even looked to see
if there's research on it or if people
are consciously designing those systems
as small world networks or not but again
I would be very surprised if it wasn't
there
it seems like a sort of natural fit
based on what a small world network
gives you and what they want out of that
so
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>