<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Brendan McAdams - Quaich: A &quot;Serverless&quot; Microframework | Coder Coacher - Coaching Coders</title><meta content="Brendan McAdams - Quaich: A &quot;Serverless&quot; Microframework - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Brendan McAdams - Quaich: A &quot;Serverless&quot; Microframework</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/DfjTAUu7Szg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I as I think you just heard my name
is Brendan I work right now for a light
Bend I'm in professional services so I
do a lot of consulting and training I've
been doing scale consulting and training
around Scala play acha as well you know
we we do Java site on both akka and play
as well I'm involved in Scala for about
seven years now acha as well and I want
to talk a little bit about something
that I guess is a little bit of a shift
in it's something that's starting to
emerge which is idea almost of
serverless programming and Amazon what I
think last year and it was initially
just for node launching this framework
called able us lambda and I've started
to play a little bit about it with Scala
and so we're kind of introduced that a
little bit of the ideas behind lambda
but also what I'm building and where I'm
aiming and trying to make it easy for
these kinds of applications to just be
simple so of course I've gone way down
the rabbit hole with macros so we call
the framework quake if you're not
familiar with it a quake is sort of a
traditional bowl that one served whiskey
in and it's pronounced quake like the
earthquake or the game and so amazon had
released lambda micro framework for
python called chalice so of course when
we kind of came up with the idea we went
back and forth as to what other drinking
vessel to name and ultimately a whiskey
seemed like a good choice so the idea
here is you know I was talking to Thomas
lockni and he had pointed me a chalice
and we sort of liked what we saw and we
like the idea of a scholar version of
this and so we started going down that
road and explain it or explaining
exploring it as I said he kind of went
down hey what other drinking vessel can
we name this after since it was inspired
so of course the question now is what
the serverless mean because we all love
buzz words which of course now need
definition in order to nail down exactly
what it is that we're talking about the
idea is that
is a server lyst framework as they put
it but it's fundamentally event-driven
you know it is I almost think of it
closer to the concept of a trigger in
the way that it works is it you know
certain events will trigger it wake it
up and execute what you're looking to do
it right now it supports nodejs Python
and JDK 8 so obviously my first thought
was hey if it's got a jdk i can run
skull on it and you know again with the
buzzwords it's always you sort of
requires that definition and what I
guess distinguishes lambda or the idea
of serverless versus you know having to
spin up my own virtual machine running
whatever I'm doing having to pay the
cost of having a machine running all the
time especially if I'm not doing that
much this is where it sort of runs it we
don't necessarily have the server
instance now and we just upload a jar
amazon provisions it there's a machine
or whatever else behind it but when
there's idle periods the event loop is
essentially suspended so you can see
this with lambda where your first
request after a new function or a update
of a function will take a while but
after that it's pretty quick but they're
more or less suspending that event loop
when you're not executing so you're not
being charged for running a server so
especially if you're doing something
less frequently it's a great model then
you can build pretty quick apps on top
of it so this is you know driven with
events you write and register a function
which consumes Jason input now the Jason
will differ based on the type of event
the source of the event there's actually
a ton of them which I haven't gone down
the road yet mostly I'm doing the HTTP
side right now but they provide some
pretty interesting stuff you can do
triggers from s3 so you can invoke a
lambda function if s3 has a change or
dynamodb hdb calls through the API
gateway is what I'm focused on mostly
now but there's also some other stuff
and one of the things I'm having fun
playing with a little bit is I think
they just launched in the UK the Amazon
echo which is sort of their voice
activated speaker you can write Alexis
skills for lambda so if you saw the you
know the long-running Pinky and the
brain joke working on an Alexis skill
right now that you say Alexa are you
pull
wondering what I'm pondering and it will
come back with all you know any of the
possible responses from the many many
years of pinky and the brain so that is
sort of my exploration project for the
Alexis side but am sort of trying to
finish the HTTP as well as the more
challenging part that will talk about
which is actually trying to simplify the
provisioning because like many laid
eight of us things it's not necessarily
the simplest thing to provision and set
up especially when you're tying together
many systems so we also can wire our own
events we could you know put whatever
you want together invoke the lambda
function from whatever code we want but
right now I'm sort of focused on those
hey what are the pre-built events the
kind of stuff people could use but a lot
of what I'm building eventually could be
abstracted so the inspiration as i said
was around this python framework i did a
lot of python over the years i really
like micro frameworks stuff like bottle
and flask or it's very sort of decorator
driven if you've seen python so they
released this in july it was essentially
a demo they've updated a bunch lately
which I actually have to go back and see
what other interesting things they've
added but the idea is it's what we
really call a single page app it's one
class that defines a bunch of routes you
don't have to write all of the
registration of JSON parsing it takes
care of it for you and it just execute
to your app so it's a really easy way to
throw up a quick and dirty app now
keeping in mind as well that when we
talk about the HTTP supporting lambda it
requires you to respond with Jason so
we're talking about something to build
rest api's and not to you know build a
full you I based system but they used
python decorators if you're not familiar
with decorators they look a lot like
something like annotations but what they
actually are in python is a higher-order
function so your decorator wraps another
method or function and allows you to add
functionality or information so you can
define your HTTP routes pretty quickly
and easily so this is an example of one
of their demos of a chalice app where
you know they create their app with the
name but your routes so if you request
the route / you drop into index if you
request the route cities with City being
a substitutable argument
the open brace close braces what's
imposed by their HTTP gateway but you
now have access to the city which it
will automatically pass as an argument
this is kind of the road that I wanted
to go down how do I do this with
Scarlett I've spent a lot of painful
moments playing with macros to get as
close to what i want is possible and you
know looking a little further you can
also specify methods so you get paste or
put go poster put and I stayed pretty
close to this initially but I went down
a road that I think is a little broader
I didn't like as much the idea of having
one method handling multiple HTTP
request types and we've broken that down
a little but it's a good idea to start
with now it's not perfect it uses the
API gateway which you have to configure
by hand for the most part to route HTTP
to your function you have to configure
the gateway which is mostly driven right
now by velocity templates so let's go
back to 12 year old Java technology that
I can't remember anyone actually using
the only place i think i have seen it is
like IntelliJ is live templates but they
have added support recently for
importing swagger so that's one of the
things I'm looking at to simplify this
and the nice thing with chalices they've
provided an appt a sort of plug-in that
can automatically deploy set up your HP
I gateway and everything else so there's
a lot of interesting inspiration there
for what to go with and eventually we're
going to the same thing I'm working on
an SBT plugin SBT being the build system
that most of us use in the scholar world
that will simplify this so I will admit
to some degree I have no plan the nice
thing about something like this is I can
just keep playing with it until I'm
happy with what it looks like and anyone
who knows me may not actually be
surprised by this fact that I'm just
sort of winging it so we have started
hacking at it I've proven a lot of what
I want I've refined it i think i'm at
the point where i like the way the api
looks and it's pretty close to how it's
going to be and now of course it's all
the things behind the scenes you know
right now it's a little bit of a
Potemkin village so chalice only
supports HTTP events but eventually i
want to support you'll have simple bass
traits that allow us to support lots of
different concepts and ideas but i am
focus right now on getting something
nailed down for the HTTP
side because having a simple trigger
away HTTP gateway is nice for something
where I don't want it running all the
time and I'm looking in the next really
the next couple weeks to get a bait out
that supports and demonstrates over
there and you know it's as more I really
should get that done and finish it so
this is a rough example of a I guess my
equivalent of a demo app now where it's
actually my only mainly driven by an
annotation in this case in Scala
annotations unlike Java and the Java
world annotations are something that's a
runtime code modification in Scala
annotations can only be expanded through
either a compiler plug-in or a macro so
the idea here is I don't want to write
all the event loop and all the custom
handlers for parsing the request Jason
because Amazon gives you a request Jason
structure and then you've got to extract
the actual body that was sent so
everything's taken care of and that's
part of the thing let's make this simple
so our routes are defined you know here
I've got to get route that's taking a
username and a bar argument you can do a
simple response with complete and I'll
talk about the pattern that was used
here in order to handle that and the
same thing I mean we support all the
major HTTP methods simple response codes
and everything else but this expands out
in interesting ways so this is a put
handler that takes multiple paths
arguments but the other thing is
automatic case Class D serialization so
the idea is you can define a case class
that matches the spec of the Jason you
expect you pass it is your type argument
and you will get you'll actually have
request stop body will contain that case
class deserialize again we take care of
everything we try to make it simple and
the path parameters come in in a map so
right now I kind of haven't gotten the
point of making types work the way I'd
like to I'm still playing with it I've
hit some odd corners of macros but you
also have access to query parameters and
everything else so you can define a
pretty nice spec and ultimately HTTP
gateway allows you to define strict
schemas you could say this is the strict
JSON schema for request this is the
strict JSON schema for response
and a post handler looks more or less
the same the the difference here is sort
of showing as well two different types
of response that I can respond for
example with a tuple containing both the
response code and some content or just a
response code and there's a bunch of
other things using the magnet pattern
here but we still have that sort of nice
d serialization of the case class n and
you'll note as well then I'm you know
calling requests which is patched in
through the macro so the route methods
we support posts get put head options
and everything else I think delete is
not listed on there but delete is there
as well and they're provided via macros
so I kind of went down that road is
finding it was the best way to generate
the code minimize the boilerplate and
make things easy so they'll generate a
routing table entry that's the other
piece of course is all these macros
patch in a map that's used to route a
request to the right place so when the
request comes in it parses the body it
passes it to the appropriate route and
eventually the plan is to use those
routes to use those macros to kick out
the metadata configuration so that the
SBT plug-in can just pick up hey here's
the swagger definition that defines what
this looks like if you want strict Jason
schemas it's all there and everything
else so sort of having that Co gen gives
that potential advantage so the ideal
environment one of the problems that I
definitely ran into was how do I respond
effectively with multiple types of
responses but still keeping things
simple and of course the eternal thing
of well do I really want to lock people
into saying you can only respond with
case classes and they may have some
other complicated way of their do the
way they want to do things so the
framework generally should take care of
this serialization it should make it
easy for me I should be able to do
whatever I want within the guidelines of
what I want otherwise we're building
rails there's one way to do it and it's
the wrong way generally so I tried going
down the route of type classes but sort
of the broad general use of type classes
hits a lot of limitations
it's not quite the way we often think of
tight classes and Scala doesn't quite
fit what we need and what I ended up
against is the magnet pattern which
spray used now the magnet pattern is not
not type classes but it's a more refined
use of type classes in order to handle
this and it fits really well and there's
a really good post by Matthias if you
search magnet pattern it will I believe
come up as the first search result but
the idea was to use this for response
marshaling in fact the code for quake
looks very similar to the code for spray
because it was done right and I like the
approach the idea is to eliminate
multiple response types so he you know
Matthias talks about it in his post of
you don't want to have complete as Jason
or complete his case class or compete it
complete his fubar it would be nice you
just have a complete method and make
this simple however the next step you go
into ok let's use method overloading
well if you've worked with method
overloading and Scala especially if you
worked in Scala prior to 28 when default
methods were put in you know overloading
is painful and the other problem is that
when you get into things like type your
HR well now it won't compile because the
system sees clashes because from the
erase your standpoint they're all the
same method code duplication as much as
we all love cutting and pasting code and
introducing bugs every time we update
you have limits on parameter defaults
you have limits on type inference and a
bunch of other things so it's ok I mean
I kept going back to this idea of type
classes and the idea with the magna
pattern one method one parameter we have
implicit sand type classes to guide us
through what we're doing and it means I
can provide a bunch of defaults but you
can very easily just implement that type
class and go with what you need so this
is what it looks like now that's the the
code for the complete you pass a magnet
and it uses that to actually complete
the request so this entire method is
defined once the argument that it takes
is the magnet and instead of overloading
we use implicit conversions to what we
call magnet types
that's the park that you can plug in
whatever you want I want to return a
case class I want to return something
else yeah so there is a second layer of
type class here we use for the Jason
marshaling but this is where it looks so
the the trade at the top is the template
for the type class for the response
magnet you can define your result and
there's an apply method that takes no
arguments and the actual arguments you
provide is up to how you define your
type class so I have an implicit here
that takes a status object in this case
again sort of taking the spray approach
what they call status object is a tuple
of a response code and T where T is any
arbitrary type with a type class for
response marshal or so absolutely
anything that I want to use great I can
plug that in ultimately I don't have to
lock you into using Jason 4s here that's
something I'd like to in the long term
right now i'm using Jason 4s but I'd
like people to pick what they want
there's 3,000 Jason libraries for skull
and everyone seems to prefer a different
one and Jason for s is a good default
but I'd love to it minimizes the number
of github issues opened asking me to add
support for Sara say a or J or John or
anything else it's just depending the
bud ahead of time so the annotation is
sort of what drives a lot of this the
way that we expand its simplifying the
code gin and everything else it is macro
backed it's a skull annotation but the
idea is we generate the event loop
handler you don't have to deal with the
interface that AWS imposes on you which
of course is java based which means you
get java pojos for things like the
request body and the context and
everything else so I've got a case class
wrapper that makes it a little more
Scala II the default you know d
serialization of the Jason body and
everything else it will set up the
routing table based upon your route
request macros and it will set up the
request in context objects based on that
incoming request and it looks if you
look at the code gen for this which we
will in a minute the idea the thing I
like about chalice was its simplicity of
course Python being done
Amick they can get away with a lot of
things that we can't necessarily atom in
a compiled language which is we're sort
of macros become the golden hammer
because when all you have is a hammer
everything looks a lot like a thumb it's
an important rule remember but you don't
have to write all the hooks for event
handling certainly in chalice and that
was the direction I was going and I
don't there's no point in me writing
this if you've got to write everything
by hand it's useless so the parsing the
request body everything else as I
mentioned every sort of type of lamb
default every or trigger that you use
has a different JSON format so right now
we sort of handle the HTTP but
ultimately we can handle anything Alexa
or whatever else so I took that
extension to the macro annotation to
generate our boiler plate and if you've
looked at macros before i'm using kwasi
quotes which provide a lot more sanity I
don't have to write an AST by hand as
much as I've given macro talks before
where I have you know thousand line code
dumps of a estis which is the point at
which people get up and walk out of the
room the point where I want to cry as it
is the idea though is I generate a
companion object and that's the part
that Amazon calls so the companion
object implements their request handle
or trait and everything else and that's
the event loop handler and then every
request will create a new instance of
your handler class passing in the
request passing in the context setting
up the routes and this is the kwasi
quote template so if you remember I just
had lambda HTTP API class demo HTTP
server and that was it what we're doing
is patching in constructor arguments for
the HTTP requests in the HTTP context
extending the HTTP handler trait doing
the thousand imports for Jason 4s so we
can actually use it and just dropping in
whatever body code you have so really
just adding everything so that your code
compiles without having to do all the
Jason 4's imports without having to
extend the trait without having to write
the constructor well that I need to
generate the case the Ninth case object
the companion object and from the
companion object side it's the same
thing this is implementing our HTTP app
which is just a wrapper to Amazon
bass passing in a new handler object so
that will accept the request from a
table us and go and run but you know I'm
of course kind of patting myself on the
back here one other interesting thing
that I discovered the problem of course
in Scala with working with macros is if
you're in an IDE all of those lovely red
errors that tell you all your code is
wrong and I mean that's fine for me I
know what the macros do I know what they
look like but it's not terribly useful
now I'm working on a blog post for this
for type level but there turns out to be
a somewhat undocumented API as part of
the Scala plugin for IntelliJ that
allows you to inject synthetic
information so you can write a handler
that tells it when you come across this
macro annotation here is all the stuff
that the macro annotation does to alter
the decorated or annotated method or
object or class so I've actually written
a plug-in that's available for this that
tells intelligent well we patch in this
trait we patch in these methods we patch
in these constructor arguments so these
variables become available which is nice
because now I'm able to work on my demo
stuff and everything else and not at the
red errors have the autocomplete have
intelligent actually able to tell me
when I've coded the macros wrong even
though it doesn't know that say the get
method exists so it's a pretty
interesting then it's not entirely
undocumented but there's only a few
simple examples and it turned out to be
very easy to use your ultimate Lee just
returning a block of code where it's
things like def foo equals triple
question it doesn't care what the body
is it just cares about the signature the
one problem that I've run into here
though is really making the deploys sort
of what I think of as stupid simple how
do I actually make deployment a scene
thing and the goal really is an SVT plug
in here but the idea so far I'm
leveraging a plug-in that guilt wrote
unfortunately all it really does is
upload your lamb
jar into AWS in an s3 bucket provision
lambda but it doesn't do all the things
for the HTTP gateway the Jason
provisioning and everything else and
that's kind of what I'm dealing with
extending at the moment but doing the
rest is very painful by hand every time
I want to test I find myself spending 15
minutes and wanting to cry and hide in
the shower hugging myself endlessly and
that's something I want to automate
because again it's if it's painful for
me then there's no point in shipping
this to other people and this is an
example of the coding process that I
deal with when i'm working with lambda i
go through a lot of keyboards it's
complicated to with the health insurance
plans in the US now the benefits of
socialized medicine when you're that
frustrated so there is a road map there
is this is the place where a lot of my
development is focused at the moment is
the SBT plugin so I want to make this
Excel rapid development you should just
be able to do everything it should pull
the information the metadata from your
code as much as possible some simple
information configured in your SBT
settings and provision the gateway setup
optionally and you don't maybe don't
want it to be strict but have the option
of saying hey I know what the Jason that
comes in as a request should be because
I've said I want this case class so
there's no reason I can't define
adjacent schema there until AWS just
reject it on your side if the schema
doesn't match so I don't have to deal
with not being able to parse that Jason
properly in either patching in the
velocity templates or the swagger spec
or whatever else that it takes to
quickly provision that and have it be
consistent I mean I don't want people to
write that by hand because how do you
make sure that matches up with the code
that you've written and most importantly
automating the development and release
of your lambda function so the code
lives under might get up its BW mcadams
/ quake
and there's a separate repo for the
IntelliJ plug in at a separate reef
wrote the SBT plugin i think i'm the SBT
plugin is quarter cask right now again
you know continuing with the whiskey
reference if you like Laphroaig it's the
way to go and you know i think i'm
running a little ahead on time
unfortunately so i have plenty of time
for questions yes yes so actually what I
was most inspired so the question in
case the camera didn't pick it up was
whether I looked for my routing dsl at
examples of other things for the
inspiration and really the answer is yes
so i worked i was at netflix until the
middle of last year spent a year there
and we were working with skull etre and
you know for me I like scholar because i
like the python micro frameworks which
look a lot like that and that was sort
of where i looked at I like the
simplicity I think it worked better at
Thomas argued with me about Aisha Lee
did this with annotations and I think it
complicated things more than it should
and ultimately that's the route we went
down and squatcher was very much driven
as the inspiration for that to just make
it simple the one thing and I'm still
trying to fight with is potentially
injecting the path arguments as
variables and I can't seem to get Scala
to accept the variables I've injected
from the macro as something that
compiles unfortunately other questions
yes
so the question that would be
essentially all these other m creating
I'm reinventing the wheel with them
complaining about everybody reinventing
the wheel with Jason and then doing the
same thing where they should be
framework could we patch something in I
think conceivably yes so play would be
interesting i'm not sure where with the
dependency injection and everything else
it would be an interesting question to
explore i think somebody likes scotch or
h2b 4's would be really easy to drop in
there because really you're just
changing the event handler allatra is
capable of plugging into its own
standalone server or plugging into
servlet and you know there i think it
would be easy to hit put a handler it
probably could be doable with play it's
something i'd have to look at because
it's interesting and the question i
guess there is you know certainly you're
knocking able to prevent use so you'd
still be building just a rest service
but for a lot of these there's no reason
not it's a pretty you know basic API
from amazon it says implement this trait
have a method called new handler that
gets a request object in a context
object and go as long as you return
Jason you're okay yes
yeah I know the the big applications
honestly make sense it's almost nano
frame it's almost nano services a very
small execution method and that's
definitely something I'm really excited
to explore too is all the things like
Kinesis trigger that's three triggers
dynamos you know triggers because that's
the place where it's hey I just want to
throw something up I don't need to call
this all the time and those are you know
I'm kind of starting with HTTP i don't
know that hp's the the thing that
everyone's going to use but it's that
sort of gateway to all these other
things you can do it's the proof of
concept of you know hey we can make this
work we can make it easy for a scholar
developer to just quickly put things up
and prototype them because you know
running a native OS server is not
necessarily an inexpensive thing
especially if its not being called that
frequently the other questions right
well thank you everyone for your time
apologize i think i ran a little shorter
than i intended to but if you have other
questions feel free let me know</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>