<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory 2014 --  Software Defined Networking | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory 2014 --  Software Defined Networking - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory 2014 --  Software Defined Networking</b></h2><h5 class="post__date">2014-03-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/W59OEL3ESG0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everybody hear me can hear me back thank
you buddy oh ok thanks just a show of
hands who here has heard of
software-defined networking who here
knows anything more than that's what
it's called ok who hears a heart of open
flow alright that's pretty good alright
that's who here to hurt my
software-defined networking talk last
year oh ok that's good alright because I
I cover just a like four slides of the
same material um so this is a bit of
actually an update from last year where
I talked at a very high level about the
kinds of things what we're investing in
on very briefly infoblox is a growing
public company that sells control and
automation solutions to large
enterprises and service providers so we
don't have any cool sexy apps or
anything you know we try to help large
companies mainly in the fortune 500 get
a little bit better efficiency out of
their IT staff as they scale their
back-end infrastructure you could ask
why am I at an early in conference well
that's a good question i'm trying to
figure it out myself but you know as CTO
i have a suspicion that Erlang and the
OTP may provide a path for you know
creating efficiencies in large more
traditional mainstream enterprises over
time and so we've been looking at that
for the last couple years um
software-defined networking as a and I
won't go into it too much but as a whole
industry trend is at the very highest
level on taking one of the largest kind
of budgets in IT which is the networking
budget which is dominated by hardware
and shifting that to more of a software
from a budget perspective and that's
quite a big deal in the sense that
almost every other industry including
the auto industry has kind of become
software-defined over the last 20 years
and the networking industry looks much
more like
the computing industry in the 70s so
there's quite a big opportunity there um
if if to add a lot of value to
organizations but but it's still very
very early okay so in this talk I'm
going to talk briefly about our
motivations briefly about where we've
been investing in the last few years
around erling in the OTP we have no
aspirations of monetizing any of this
anytime soon this doesn't relate to our
core products fundamentally in terms of
bits today will it ever I can't tell you
but we think that the Erlang OTP
definitely points the way to properties
of systems that we think we would want
to build solutions on over time there's
a lot of stuff that we've been investing
in that we'd love for more people in the
ER line community to be involved in so
I'm going to talk a little bit about
some of that I'm going to have been
partnering with both erling solutions
and the company called cloud dozer i'm
going to introduce cloud dozer to talk
very specific because you know i think
you want to get some technical meat out
of it so I made sure I brought someone
along and give you some technical meat
and you can get something very concrete
out of the kinds of work we're doing so
I wouldn't expect you to walk away with
any very deep understanding but more of
a general idea of where we think the
markets going in industrial applications
and i don't mean industrial like oil and
gas I mean kind of mainstream enterprise
that kind of industry and where think
we're there may be some holes and gaps
going forward I'm going to go through
the material at a lightning pace because
not only is there a lot of it but I just
want to give you a landscape so if
there's anything of interest that you
want to go deeper just talk to us
afterwards what do I call it cause
Software Defined Networking erling in
the future of computing because you know
if you get to speak at the Erlang
factory why not talk about the future of
computing you know this is the right
place to do that there's a lot of places
you can't do that so first the
fundamental questions that we trying to
ask as we see the not only in mobility
but really in how manufacturing
organizations think about manufacturing
how retail organizations think about
retailing how oil and gas think about
digital oil fields these
kind of questions come up like how do
you program the Internet of Things
because it doesn't while it's huge you
know my speech is very buzzword enabled
but we also take some of the trends very
seriously there seems to be a need
growing to program the Internet of
Things how do we do that how do we
program a million course so many of our
customers that aren't google which
they're not a customer but you know
aren't Google aren't amazon still have
or plan to have you know millions of
course available to do the kinds of jobs
that they need to do that could be a
health care that could be another
organization so this seems a more
pressing question than ever before for
general mainstream enterprise of course
if you have that much hardware it's
failing all the time right I mean just
statistically it's just failing all the
time and most of the hardware that our
customers by isn't like you know
designed to last forever right it's
relatively commodity hardware so how do
you do that and of course you guys
already know the answer most of the
world doesn't know the answer so you get
to be in on the big secret which is of
course it's early right that's how you
know how to program an Internet of
Things a million course where
everything's failing all the time all
the properties seem to be here and early
I will caution this room as I always do
that the property seem to be a merging
in Scala akk a and nodejs and I'll say
very briefly that I think Erlang
technically is way ahead I think Scala a
kakaya has the JVM and the Erling
community should be concerned about that
and figure out how to deal with that and
nodejs is a very lot of bright people
from google pushing against it so even
if they get everything wrong this year
volume and velocity of what's going on
in OGS may be quite disruptive so don't
take these other efforts but I'm a
believer I'm into Erlang so you don't
have to convince me but if we think
about very scalable systems darling OTP
while it has a lot of things very right
as still as many of you know very
constrained on the network side and so
we really look at that first and that's
where the software-defined networking
came in there's obviously an answer if
you've had any kind of high performance
computing background that answers
InfiniBand right if you want to get
great performance and kind of properties
out of high
scalable clusters you want to use
infiniband go ask any HPC team the
problem is if you want to actually sell
products on InfiniBand that's not going
to work for you because it's too
expensive right and so one way to think
about software-defined networking as it
seems to be emerging today out of
efforts wit out of Stanford and others
open flow and others is that you could
get possibly properties like InfiniBand
at a much much cheaper more cost
effective way because Ethernet is
absolutely pervasive the story of
networking over the last 20 years is not
the internet so incredible which it is
it's that ethernet won the world today
is in Ethernet fabric ninety percent of
the ports the cisco ships or ethernet
ethernet tseverywhere so if you had a
model to remotely program ethernet to
remotely program every single Ethernet
packet and by the way whether it's Wi-Fi
4G are actually wired the software when
it hits a microprocessor thinks it's
Ethernet the ethernet frame is
ubiquitous abstraction so if you had a
way to remotely program devices that
handled Ethernet packets that may be
fundamentally give you basically open
open flow is such a thing that may give
you sixty or seventy percent of the
functionality of InfiniBand at a
hundreds of the cost and a cost which by
the way is dropping right so that's
quite exciting if you're starting to
think about these things and if you're
not it's not exciting at all so open
flow and I won't go big into that is one
way to think about open flow is it's an
instruction set for remotely programming
Ethernet so if you imagine in this
picture all of these greenboxes as being
hardware ethernet processing units like
it looked like a switch but they don't
have the intelligence of an ethernet
switch and i'm learning they also don't
have the intelligence of other packet
processing engines like firewalling or
load balancing their eight at when
they're put on there like a general
server they're ready to process these
ethernet packets but they don't have any
semantic behave
here before you plug it in and turn it
on and then you remotely connect to it
and ask it each one of these to start
processing flows which is the flow
traffic from endpoint to endpoint and
they can process those flows that each
one of those things in whatever way you
want at runtime so you need an
instruction set for that that's what
open flow is it's the first pass at an
instruction set for remotely programming
general ethernet processors it's the
first pass so I'm not claiming that open
flow is going to win or be the most
important over time but it certainly is
the most mature model for this and this
has been deployed all over the world now
there's less if you're interested
there's a whole community I'm leaving
here and going to open networking
foundation which owns the open full
protocol today that's very exciting but
that is a front I mean imagine for a
second again by not buying routers
switches firewalls and load balancers
which is a classic building blocks of
networks but you buy generic Ethernet
processors and then you're remotely
program in real time so you're buying
the data plane we call this the data
plane of the network like you buy
servers today so that's radically
disruptive to everything and it also
puts now the focus of attention at the
control plane and that's a software
problem so I mentioned before the way
the hardware organization was in the
computing industry in the 70s that means
that the networking could become generic
boxes like del Sol servers today and an
independent software market in
networking that's never happened in the
networking industry before so that's a
big deal okay any questions about that
yes
so how did these so how would these
connect together so um well you know it
depends on what your actual but the
model you can have is these are just
hooked together with cables that the
that actually the top the physical
topology could be almost random because
the logical topology for applications
can then be programmed in real time
given whatever the physical constraints
are so it's kind of like saying how is
my memory plugged in here well it
doesn't really matter the operating
system logically organizes all of the
hardware on your laptop for your
programs at runtime you can imagine the
same thing here so there's clearly has
to still be real on layer 2 links but
think about it that way you just have a
layer two mesh that's remotely
programmable does that make sense okay
any any questions about that okay so we
can talk more about that there's lots of
debates in the world about whether
that'll work and not work whether it
looks like a singer's transfer mode
whether it's going to fail blah blah
blah can talk about it but we think that
there's certainly something here here
all right and so we've been funding an
open source initiative called flow 14
org which is focused on exploring an
fully enterprise you know an enterprise
focused software-defined networking
stack one hundred percent in Erlang I've
taken a lot of flack for that so it'd be
nice if you could contribute to it to
make it even better so you know it
doesn't it can look like a good idea at
the end of the day we don't know if it's
a good idea but I think that it has
serious merit and I'll go into a little
bit why that is so you can take a look
at what we're doing there yeah huh
that's a rhino
yes yeah that's a rhino that's a rhino
our flow forwarding where I know okay so
what we did very briefly is starting in
2012 we actually hired Erlang solutions
to write a open flow soft switch which
runs on servers that's called link Li NC
we then and we've kind of made that
better we gave it away for free it's
totally free and if you want a hireling
solutions or other companies to modify
it you can we have no interested in
monetizing this um and we didn't write
it so professional Erlang people wrote
it we don't you know but we think
there's value we actually hacked up a
little application which if I have time
I'll talk to you about later all right
and recently we've been focused on the
control plane so first we did the open
flow switch which could sit on a server
so imagine 10,000 remotely programmable
data playing Ethernet things right that
are not routers and and load balancers
but they're ready to be those things if
so told imagine those that's the switch
part or the data point part and then the
control plane is the thing that tells
the data plane to do whatever it's
supposed to do with ethernet packets at
real time so first we focus on the
switching part and now this year we've
been focused more on the control plane
we call that loom and then we wrote a
little application called tapestry if
you've heard of open V switch which is a
software-based switch that VMware kind
of runs that link is kind of like that
except it's just focused on open flow
open visa which is focused on a bunch of
stuff can run software this is just
focused on open flow and we're not
claiming that has anywhere near the kind
of industrial integrity that opened visa
which are not trying to compete with
that but that's probably the closest
thing in the world that looks like link
any questions about that yes
yeah there yeah in fact we'll talk more
about it but just to show you anything
that is basically can run Erlang and has
ethernet ports is such a piece of
hardware so this is a $300 gig for ports
of Gigabit Ethernet with intel atom
processor this can run link and become a
remotely programmable open flow data
path element they call it I don't like
using the word switch because switch
implies kind of learning behavior and
stuff and it's really not that but the
general vernacular is a switch so this
would be an open flow switch you could
have a sea cliff trail as a platform
that Intel cells today it's 48 ports of
10 gige line rate programmable ethernet
for less than ten thousand dollars
broadcom has a box called the Trident to
that's like that trial and you can just
use general servers and I think Maxim is
going to demonstrate the entire behavior
on a laptop right so yeah the point is
that the actual data plane becomes just
another computing problem and you can do
it on general computing hardware and
that there's reasonable merchant silicon
the D to D D frame the frames the answer
your question um ok so just to take it
one level down so you can kind of think
of it as well why would you need this we
think big data is like reasonable
applications so again we wrote this
little toy application called tapestry
which in theory is a big data
application i'm not claiming that we
have those numbers today i'll talk to
you about that though as an example and
then there's the control plane part
which is loom and then there's network
there's any kind of hardware you want as
i just said and then there's the data
path elements which are linked right and
so link is a open flow switch on the
beam that runs on linux and that's what
erling solutions wrote and then loom
also Erlang solutions is contributing
the first bits to that as well and yours
truly wrote tapestry so it's a really
terrible piece of Berlin code so you
know you can send me email and tell me I
should get out of that business fast but
I already know that that's why we hire
other people do now what we found is
that if you're really doing a real net
working application link on beam on
Linux is okay depending on the
application I've let my son watch a
netflix movie through this box running
that code that you can download for free
so but there are other applications that
may have higher latency requirements or
more stiff latency requirements so we've
also been focused on and this is a big
project I mean you can imagine this is a
big project so we're trying to focus on
the key points so we hired on the cloud
dozer team to help tweak link and
maximal talk a little bit about that
yeah on the network boxes of the erling
yes so this is just a general white box
right it's running linux and linux
running Erlang so you basically have the
link code which implements the OpenFlow
protocol and allows for Ethernet packet
processing running on a beam right
running in a Linux environment so yes
does that make sense okay so but that
has a certain kinds of Layton sees and
other things so actually maxims team has
been working on ling which is a
replacement to the beam and ling on Zen
which is taking Linux out of the
equation so you can basically run the
beam like abstract machine much closer
to the hardware but it's still the same
Erlang code right and so they made link
X which is a he'll talk more about that
but that's like a faster version right
when we just were just releasing that
now but conceptually everything's are
the same but one of the points of this
is that wow look we're actually making
real strides and performance in a
software-only environment we're not
touching hardware we're still not doing
anything in Hardware not doing anything
special in Hardware right that general
techniques to make software run faster
on general purpose Hardware are going to
be applicable here to the point where
you know it just doesn't matter and
that's exciting any questions about that
okay just in the interest of time I
won't bore you with how an open flow
switch is organized this is right out of
the OpenFlow specification so if you go
read the OpenFlow specification it
defines that and it has this picture in
it and I won't bore you with that but
that's what we implemented this is more
focused on link which is an erlang
implementation of an open flow switch
erling solutions did a good job of
architecting it so you could have
different backends and cloud those are
made such a back-end that was closer to
the hardware right but we're able to
reuse all the protocol stuff on top
that's very exciting and again these are
great things that believe it or not in
the networking world it's not always
straightforward that you can make
serious performance gains just by
architecting the software right that's
new for networking people a lots of
networking people okay so with again
interest of time with that let me just
you know last year I talked a little bit
about this but it has been hard to show
exciting performance numbers you know i
can i can tell you oh we can kind of do
this and kind of do that but if you had
something really you wanted to do it's
not super exciting I think we're pretty
excited about what cloud dozers done
with link X so let me turn this over to
max okay this is a more like report for
for a stage of the project regardless
with the Infoblox so Infoblox asked us
to first to demonstrate so that our our
virtual machine our LAN virtual machine
called link is compatible enough to run
link switch and other software and also
then we realized so that it's me it
should be worthwhile to try to rewrite a
portion of links which to make it faster
so that's we kind of mostly completed
this this stage there are many other
things too
to pursue but the first results are
promising and so it's what i'm going to
share with you now so that's what as i
said so that's first we demonstrated so
that the links which which is a pretty
pretty big piece of software lots of
dependencies comprised of lots of
applications and lots of code and it it
runs on our virtual machine the same way
and passes all tests so that's that's
part one and the we were fixing the
so-called fast path so that the portions
of the of the switch which are called
for every packet so it may happen like
million times per second so this this is
the behavior of those parts up very
different from there from things which
may not called adult so the so the first
place this requires definitely more
attention from then when you developed
it such things okay so that's that's the
best baseline so what we wish I don't
know if it's if if we first you wanted
to show these numbers but these are
these are real numbers from there is a
real numbers from the
links which we run in the standards back
end so so I was was able to get two to
two hundred megabits per second from
from that software and so that's well
that may be good for some for some for
some applications but they the bad thing
is that this memory consumption was
outrageous was just ballooning and
consuming all the memories and so on on
lean it kind of behaves better because
of their so got this a slightly
different garbage collection strategy
and well I guess that they in people may
easily tweak tweak beam to to measure
those numbers so that's this is not not
this difference there is not that
important so what's important is what
what we've done later so we see that
what they the biggest biggest our
concern was this latency inside the
switch there's to 220 microseconds so
this is this is a lot of time for for
processing of packets so this is the
time then between the then the packet
appears on the interface and then until
it goes goes away so this these are
these are the latencies between various
elements order of this setup we measured
so in this this looks like like a
biggest biggest number so and it's also
a number under our control so that we
attack that
so what they did is that we implement it
in you back end and the first the first
thing that we do is that we implemented
flow tables open flow flow tables you
may understand what what what I mean is
essentially as in it's a matching rules
and certain actions which should should
happen if everything matches so it's so
natural to map those matching rules onto
onto pattern matching in rowland persian
but button machine so that we did
exactly that so what we what we are
doing we're taking OpenFlow OpenFlow
rules and we translate them dynamically
into early in code and then we compile
it and reload it using the the famous
hot code loading facility of early and
when we just use it to to to mesh
packets so it's also other things as a I
don't know what if it was important but
definitely garbage collection was
important so we're mostly avoiding
garbage collection in the only first
person we also almost never almost never
copied data so the packet arrives as a
binary and it leaves as the same binary
so it never never completely parsed into
different representation so we just
match it as it is so using all these
some binaries and stuff
so we also may I paid attention so that
I do not create stuff in memory just to
minimize memory footprint so that's how
you get the fastest the fastest airline
code so this how how the testing setup
looks like so we got this there's three
Zen domains so these two domains it they
actually four fours and domains this is
dumb zero and these are two to linux to
two domains with linux and this is the
links which which runs on on Ellen vm so
it's already there is no linux in in
this domain and they all breached
through the using the linux bridges so
that's the setup and what we saw here is
that the processing delay was like 100
times less oh just it's a micro second
range so usually what you will see the
processing of f of a packet with in
micro second make a second and a half so
it means that potentially the switch may
process a million packets per second
that's on a single core using a dynamic
garbage collection collected language
Erlang also the memory consumption was
was much lower and the throughput that
you could measure with I purposely it
wasn't in a gigabit and it's the memory
there throughput is definitely
constrained now with a north with Erlang
not with a you know ling vm it's all
constrained by the linux bridgen in
indem giro so we will fix that i guess
in a
later and we will have even by the
number soon so that's it that's what
what we can do we just make make it
multi-core because Lynn vm is is a
single threaded virtual machine it's
different from being in the end respect
so if you have multi-core machine you
just run many instances of fleeing on it
on that machine so they we need to
figure out how to to figure out how to
this brick this architecture may work
for foiling switch and also we may fix
the bridges and we may even think about
the pci bus through just by passing
kernel and everything completely so this
is the this is how you make essentially
wire speed switch in software so thank
you
this is this is absolutely a general
purpose so it's a more or less the same
the same thing as beam and we were this
is not the application we were thinking
in the beginning we're thinking about
that just you know web servers and stuff
like that and also I would like to to
save it so the first time I'm saying
this in public so there there is a
decision to make it open source really
soon as a as soon as I slept licenses on
on the files so that's
excuse me living
we call it compiles yeah uh-huh I don't
know yes I guess I'm not the person who
can answer that because I'm not a
networking guy I'm Erlang guy yeah so
what what we did today a we it's not we
tested the same thing in there not only
we am but in the real hard work again
with these always Linux bridges and we
saturated 1 1 gigabit interfaces and
well we didn't have a big interfaces so
there's no test of that but just repeat
that you can imagine my excitement
because the vm vm speeds are you know
several times higher than in that case
we had gigabit interfaces but then
they're in shooting distance to get
above 10 gig on the inside so you could
imagine now we're within shooting
distance maybe it's another year or two
to get 10 gig you know line rate on a
pure software based switch which by the
way is in a garbage collected dynamic
language which has a functional
interface from a program perspective
right I mean if you ever want to sit in
a room and see actually something
historic happening you are right now
actually right and you know it may take
a little while and we may not be the
only group and we don't care i mean we
think this is a very fundamental
demonstration of what's actually
possible in software when it comes to
networking and when you couple that with
a very strong model that's been well
developed over the last four or five
years for programming such a thing
remotely with open flow and all the work
going on in the controller and control
plane and other things which also lend
themselves to Erlang OTP model right it
starts to get a bit heading right so
we're quite excited but again there's
just a lot of there's still yet a lot to
go
yes well that's a great you should ask
them actually should present you should
tell them to watch this video and s and
what their reaction is you know I don't
know I mean I really don't know I'm not
you know I come from a company that
sells automation solutions into the
networking space but we don't sell any
data plane products so we're completely
on the automation or application level
control plane things like DNS dhp things
that are like that so we're not in the
data plane business our customers
obviously by a lot of data plane
hardware I would say it's a very high
level it seems like the there's a
tremendous savings to be had if all of
the rest is there which we are not
claiming that it's there and we're not
you know who knows when it's there it
seems inevitable from a market
perspective but the timing seems fuzzy
at best but there seems a huge capex
opportunity to fund software and create
great effects gains and that's exactly
what happened in computing in the 70s
right it's like all hardware but all
computing budgets were hardware focused
and then basically you know imagine a
company like IBM they had to compete
with both Dell and Microsoft at the same
time because there was an independent
software market emerging in the first
time in history that kind of thing seems
to be happening in the networking
business today but you know again
there's it could take a long time
there's a lot of market forces
well so that's very quick so the
question is how would you implement bgp
so the first line answer and I don't
want to spend too much time on this the
first line answer is you would implement
the semantics for bgp at the control
plane level level and then that would be
programmed down via open flow to the
switches at real time for the flows that
you want it to behave that way so one
thing and again I take you back to
InfiniBand right the semantics of the
actual flows themselves how packets flow
from an application or application
protector becomes completely programmed
I mean the main reason you have
standards in the IETF is because
hardware vendors had to spin a six so
you had to kind of agree on the
semantics very tightly in a software
world we don't have to agree very
tightly so it's not clear that the
Internet of Things really is the
Internet of Things in fact I think IDC
suggested it might be called the
interactive network of things so and you
know even companies like Huawei have
been investing quite a bit of research
into protocol oblivious switching like
this so you can think much more of the
the only real hardware based abstraction
that's important is the ethernet frame
and then after that it's all software
right and for tightly clustered
applications like you might find i'll
talk about one of them then you could
actually have your own protocols if you
want it just like you would if you're
programming InfiniBand right we don't
have to work so but you can also
interoperate with all the regular stuff
can kind of take that one yeah
say it say it again oh okay okay so the
question is so there's there's a couple
things going on with the label
software-defined networking how does
this story fit into that and the two
things you said are kind of network
function virtualization NFV and open
daylight and I would say also network
virtualization similar to what VMware is
doing an nsx so kind of those three
hotspots and i would say the openflow
style of a fully commoditized ethernet
based data plane which is remotely
programmable is well beyond any of those
right in every sense of the word right
like not clear what the market is for
that it's not clear what the initial
applications will be i'll talk about one
possible type of application and it's
not clear how the other market forces
you know what the timing is for other
market forces to even allow that to
happen network function virtualization
and network virtualization are kind of
on the ground demands for a certain
level of efficiency and automation and
you can buy products like VMware's nsx
product or you can think about
opendaylight as a way of kind of better
automating your current hardware to find
network right so i'd say they're kind of
pads along the way but they're a bit
paving the cow paths so when we're
pointing at a different kind of future
which is when software Trump's hardware
for the first time in history and
networking when price and
programmability trump performance for
the first time in history and networking
and when you can't just pave the cow
pads when you sometimes need
fundamentally better semantics in your
network then this model seems to be have
a lot of promise
yeah yes so I wanted that's when I saw
so one question is okay all right maybe
I'll off one slide so let me go forward
and say exactly that so let's just take
that good let's just take a look at kind
of the state of the art if we are
thinking about programming an entire
distributed application this is why I'm
here at the early hour Lang community is
one of the very few communities that
understands distributed computing right
truly and fundamentally um and so one
way to think about it is that today
whether it's cloud private cloud or
embedded systems what what you really
have are two are these four kind of
fundamental things going on at the
hardware level you have ridiculously
inexpensive commoditize ubiquitous
network processors and micro processors
mips arm x86 to me they're all the same
right if you ask harder people they're
quite different but let's just for the
sake of software people they're pretty
much the same as an abstraction you
basically have two fundamental
abstractions you can think about
software on top of one is the ethernet
frame and the other is basically we now
think of as the hypervisor on top of any
of these micro processors right so think
about Zen think about the ethernet frame
now we've got a very solid foundation
for doing an entire stack because we
just demonstrated doing Ethernet packet
processing in Zen on in real time and if
we're going to do make an application
like Hadoop which i think is a nice kind
of classic distributed application that
happens to be data intensive and needs
to move a lot of stuff around today the
state of the art is there's a tremendous
amount of cruft in the in the middle I
mean a lot of complexity all the
operating systems all the abstract
machines with its JVM are being whatever
all the clustering frameworks all the
databases is just tremendously
challenging to put up what seems
actually conceptually is a pretty
straightforward application so I would
make the argument that we're in a very
specific time in history because of this
ubiquitous hardware that ethernet plus
multi-core ubiquitously available
processors says look there's really a
new machine available
for us to program right it's a bunch of
cores that are connected by ethernet
that's exciting there's a guy in 1984
who worked for sun microsystems who said
the network is the computer this
actually may be the right time for us to
think deeply about what that means and
how to how to how to program such a
thing so one way you could say it is we
just need something better at that
scalable systems abstraction level right
we have these are there the ethernet
frame and zen what if we had something
that sdn inside distributed graph
databases functional languages looked a
lot like Erlang OTP right but modernized
for ubiquitous and huge number of
microprocessors and the vicar disability
program ethernet and then probably at
that scale everything has to be analytic
right you're not going to be able to
make a many optimization choices a
priori right you want analytic processes
is kind of deeply embedded into that
kind of control plane but you can
imagine writing and Hadoop like
application in a single stack and having
it all work right you're not and that's
that you know even if you get half way
that it's pretty exciting right so we
would say this is um seems like a big
project so maybe that takes 10 years but
that's okay we'd rather focus on this
and some of the other clustering
projects going on frankly it seems more
fundamental so if you're interested in
big ambitious project this we're
certainly happy to talk to you about
that and I think we're demonstrating
that you know we're getting there right
so if you think about erling OTP and
open flow in Zen you know we're starting
to see something rough out like a proof
of concept for such a distributed
framework I will tell you again that if
you have you know JavaScript engine and
a lot of bright people that you know
this could be done in node.js could turn
into this right skyla akk can turn into
this so we like erling but you know
there are no winners you can't predict
the winners a lot of it will be how much
energy attention and where the focus is
on applications and you know they're so
what's that you know
like what so this is a big deal right
because now you can say well at least
you know it's everything's possible to
monetize reeling in a very major way we
already knew that already no disrespect
anybody in the room has made you know
huge value contributions with early OTP
but this was attention getter but I
think that this still begs the question
if we had such a system that I talked
about earlier what are the apps I don't
know if you know we should talk after
the meeting if I did know I probably
wouldn't be just talking to you right
now I'd be doing something else but I
think this is an exciting time to
explore the application space and so I
want to talk about one application we
wrote on our little proof of concept
right that is a big data application
thats related to networking and it's
called tapestry so you can it's very
simply not very many lines of code I
wrote them they're terrible so if you'd
like to rewrite tapestry make it cool
and good i love that won't be offended
but it's a big data application that
computes a complexity number for your
network and i don't mean your
traditional network I mean your
collection of distributed devices that
are working together so one so so what
does that mean and we asked the question
could even do this can you compute a
number that's easy to understand and
easy to compute that does this so we
think so so we created this application
that does exactly that it's called
tapestry and it actually computes a
number we call the network complexity
index that rises as the natural
complexity of your organization's
network goes up that means you're doing
more bigger things on your network so
like Google would have the highest NCI
in the world right and everybody else
has an NC aight rejecting toward
google's number right as they keep going
that's the way to kind of think about it
you can download the paper and read
about it how does it work so the only
reason I put this up here is what is
because not because this I don't wanna
talk about this specifically that it's a
big data application in the sense that
we have to detect communities of things
right so it's like a graph processing
application so it kind of exercise all
the different pieces and it
getting data in real time from the
network itself so it exercises the
entire stack I won't go fully into that
I'll just say this to what we're doing
here is using we're just looking four
triples by monitoring the recursive DNS
layer of an organization and finding out
what endpoint is talking to one what
other endpoint right and that gets a
kind of graph right and so you can think
of just we're collecting a bunch of
triples up at this time this endpoint
connected to this end point right dns is
like a hundred percent predictor that
traffic is going to flow between two
endpoints so you don't have to actually
monitor traffic you're just modeling the
signaling layer right and then we get
these huge graphs and then we pump it
into a actual analytic that does
community detection we use label
propagation method which you can
download the code and read and then we
have a very very simple formula that
allows us to find the network complexity
index and again I won't torch you with
this but basically think of it this way
if you had a Hadoop cluster of like a
thousand nodes that would be one
activity on your network if you had
10,000 sensors doing something together
that'd be another activity on your
network and the index is basically a
balance point between how many
activities you have and how many big
activities you have so the more big
activities you have this kind of floater
goes up right and that's based on kind
of way of thinking about things that
came off something called the h-index so
you can read about that so here's how it
works which is pretty interesting you
have dns recurse like a large
organization like a large retailer may
have tens of thousands of internal dns
recursive servers I happen to know that
because I work for the company that is
the largest commercial provider of DNS
servers in the world so it's really true
and and but what we do is interesting
which is you have all these recursive
DNS servers that how all the endpoints
saying where is this where is this we
put an open flow switch link in line to
the DNS server so not in line to the
endpoint traffic point-to-point but in
line here and then we flow all of that
day
back into some data center somewhere
that's running loom not only the control
plane for these open flow switches but
actually doing the big data computation
on the data itself so we're doing it all
at once we're controlling how we tap the
network because these are general
ethernet processors so if you had
something like a gigamon you don't need
that right you just have a general
server you put in line we're tapping
network we're flowing that all the way
back up to the data center doing a
clustered large you know Big Data
computation creating the number putting
the graph out um yeah so I have all
these kind of crazy pictures one of the
reasons I have the crazy pictures is to
point out that we don't really think
about the physical infrastructure at all
this is kind of all logical but very
distributed infrastructure you have the
data center here which could be running
sdn itself as loom scales and then you
have the branch offices that are running
open full switches so we're really
talking about a model of fully
distributed computing not distributed
computing in sense of justice data
center and not distributed computing a
sense of just the out edge right but the
whole package right and so with one
fairly simple software stack we wrote
something that lets us do the whole
package soup to nuts and that is kind of
exciting but there's a lot of work to be
done any questions about that there are
we can talk about after line for line
it's like the fast but I think the two
kind of conclude just think about it if
servers equals switches if these are
really as what we're demonstrating the
same thing there's no real distinction
between a server and programmable data
plane anymore then that's a picture of
John gage you know may yeah maybe I can
only show this at the Erlang factory
this is why I like coming here you know
maybe we can look past the clouds right
to the internet of things right and
really realize that John gage the
network is the computer you pick what it
can be i think we are much you know
substantially material closer to doing
that and that's super exciting i I gave
these two slides at the last at the end
of my last talk which are there's still
huge problems right I mean I give one
which is
not representing this slide but if I
10,000 open flow switches like this and
I wanted to lay down a million OpenFlow
rules across 10,000 open flow switches
to do some set of applications I don't
want to think about that that sounds
like a compiler problem to me if open
flow is a instruction set for program
ethernet you know we need compilers for
that right so there's a bunch of stuff
you know you can't think of people in
the SDN community thing about northbound
interfaces that's not going to work I
don't want to think about it I need
compilers sophisticated compilers that
do things like the pattern matching that
we saw their need to go there so you
know we're just not there yet so there's
lots of work to be done i'm not claiming
this is going to revolutionize the world
tomorrow but there's a lot of
interesting problems to be done and we
just don't even know how to think about
it in the tractions um like the haskell
people say you know io is just a side
effect right well that's clearly not the
right model for this so you know maybe
there's a model where communication is
just as fundamental as compute right and
the Erlang community has been talking
about that for a while but there's no
deep theory that suggests that's
actually true so if you have any bright
ideas or your theoretician please talk
to me after the thing and that would be
interesting but really this is a call to
action for I think one of the most
exciting distributed computing
communities in the world today and just
to show you that you know you may be
like the pc people in 1976 it was clear
that it was all could happen right but
still a little bit far away but if
you're really focused now in the same
way that say Microsoft was in the late
70s their huge opportunities right over
the horizon and we'd love to certainly
work with you and and get you involved
in this organization ok any questions ok
thanks
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>