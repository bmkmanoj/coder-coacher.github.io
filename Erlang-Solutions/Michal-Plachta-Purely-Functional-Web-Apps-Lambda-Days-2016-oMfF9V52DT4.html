<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Michal Plachta - Purely Functional Web Apps (Lambda Days 2016) | Coder Coacher - Coaching Coders</title><meta content="Michal Plachta - Purely Functional Web Apps (Lambda Days 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Michal Plachta - Purely Functional Web Apps (Lambda Days 2016)</b></h2><h5 class="post__date">2016-03-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/oMfF9V52DT4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody thanks for coming to my
talk and let
to the chase so how many of you are
actually not a Husker developer not high
school developer okay thanks me too but
I love this language because every time
I use it I learned a new functional
programming trick and this is the
cornerstone of this whole talk so
basically whenever you use haskell in
your personal project or a company tool
project or a team tool project you can
become a better functional programming
no matter what language use in your
everyday job and this is the story of
such a project will do will do a full
blown application front-end and back-end
there will be lots of slides types and
functions so brace yourselves I know the
time isn't very good but hopefully it
will be okay so whenever during this
presentation whenever you ask yourself
why bother what this guy is doing that
or something like that it doesn't make
any sense remember this slide that's why
I'm doing it so we need to have
everything explicit explicitly set in
the code a configuration side effects
any external dependencies everything
needs to be there in the code so that we
can reason about that it's more readable
that way and six months from now whoever
is using our code maintaining it beat us
he knows exactly he or she knows exactly
what we are doing and of course sorry of
course the solution is to use pure
functions and types ok now the domain we
are using github for restoring the code
and version the code also we are using
it to do a code review process so get
get lab is a github alternatively you
can house or you're on your own and
merge request application magic with
stats application we wanted to create
this during this talk it's a it's a wrap
around this this github service so we
want to want to have more information
about the whole code review process for
example we wanted to see the correlation
between the size of the of the
change that is that the needs to be
changed it needs to be merged and the
time it can take so the developer can
know exactly what to expect based based
on the 1000 magiquest we've already seen
in our code so this application on the
right this is what we are going to
implement okay and this is the
application architecture it's it's not
very complicated and there is a good
observer at the bottom which which we
are you which will use and the backend
back in part we just get the merge
request from the server calculate some
stats out of that and then pipe it to
the pub it to the front end and we'll
use elm and haskell to implement that
back-end parties in haskell and elm will
be used in order to do a web application
okay and I owe you an explanation at elm
and haskell share very similar syntax
and you are all know not a high school
developers that's why I have one slide
tutorial for you and so one slide I hope
it can be seen right you see it ok so
this double column here is a declaration
of of the function so we will declare a
function which is called some free int
which sums for int so as you see in
haskell we say it that it takes three
inputs and the last type is always the
output type and there is a one line here
in haskell we don't have any bodies
function body so it's just always
expression so we'll if I we define
functions using this expression and this
is a definition using one expression so
some free ins ABC is defined as a plus B
plus C and the rest of this of this
module is just function applications so
some free teens of one and two returns a
function here is a function so it's it's
a partially applied function just one
end to the second one is one two three
so we return six of course because it's
a some of those three numbers and then
as you see the application is the
strongest operator the strongest bounded
operator and
there is a compiler error in the third
example some free ins of 12 and the
function is of course not something we
would type check and to get rid of this
compiler error we can do we can use
brackets of course and this is the most
scariest part for every new coming
Haskell developer what is this dollar
sign so the dollar sign is equivalent to
those brackets so we can instead of
having two characters we just place a
bracket and yeah it's easier that way
but it's totally equivalent and more
more complicated stuff we define a
factorial function here and as you see
there's just two expressions that define
this function with pattern match on 0 +
+ n and that's why that's how it works
and here the dot here is a function
composition so we've composed factorial
and length functions in order to get a
new function here and of course we are
using again in fix application operator
this dollar sign in order to apply it so
it returns 6 because the length of the
list is free and we pass it pass it to
the factorial function and returns 6 and
the last example is head of a list list
of any element a and that returns may be
so for you scholar developers there's an
option type this is a maybe maybe title
it's very equivalent for a not for a nun
case we have nothing and for a sum case
we have just so for the we part in much
on the list that we get and if it's
empty we return nothing if it's not then
we return the first element right so
basically now you know somehow school so
we can move on to a implementing our
first module of the application so this
is a HTTP client we will use servant
Haskell servant library this is a set of
libraries basically for HTTP programming
but it takes over all the HTTP stuff
from our hands and we can focus only on
the api's that we want to implement or
consume so all those AP eyes are just
types
this is a key texture again and we are
used this feature in order to fetch the
the merch request and then loop over it
then store in the memory inside our rum
and that's way we'll have always the
fresh the fresh batch of magic quest
running in our memory and this other
part can just use what we have stored
here and go to the front end and without
any blocking so let's go for the gate
get to get a github API very quickly you
you don't probably see it but it just
says that whenever you do get HTTP
requests for projects project ID and
then / magic quest it returns some kind
of Jason and this is a simple JSON file
a simple JSON the response so it's an
array and there are some I identifiers
state title of those downloads outer
universe or whatsoever okay so data
merge request there is an ID I ID title
and things like that so this is just a
haskell data data structure that we
defined in order to in order to fetch
fetch them and those are just two a type
class instances merge request is
serializable from and to jason so that
the whole code is enough in order to do
a sterilization and fetching from the
server okay so its data here in blood in
blue phone then merge requests in the
red phone and the equal sign and then
you can see the no you can't but you may
imagine that there is a blue kind of
font which also says mel request this is
a constructor of our type and then in
the greyish fund unfortunately there is
an ID I ID title state so everything
we've seen here basically the same stuff
that you've seen here can be found can
be found in this data structure and here
you have instance in yellow and from
Jason magiquest which is red and to
Jason made requests which is also read
so we just defined that your data
structure may request is a is
serializable and dis realisable from
from jason
and let's talk for a bit while waiting
for the lights to be turned off let's
talk about doing the smiley stuff oh
yeah where is that is it okay I know I
know yeah now we're talking okay it's
better right okay good so how to do a
smiley face then so you need to do a
colon and the angle bracket right have
you done that in every whenever you do a
facebook messenger or I message already
know like who does that evil smiley face
now you're using the normal ones so we
also can do that in order to define our
API type so this is the same smiley icon
you use in your messaging so this is one
type I must feel I will reap I will
repeat this quite often this is just one
type so as you see it corresponds to the
to the path you you all can see here
first we have api then we have v3 so the
smiley emoticon icon operator is just
something that we replace / with and
here are the most the red ones are the
most important that we need to focus on
so header is a private talking we need
to provide in order to our request not
to be it in order to do for the request
to be authorized on the github server so
with a shrink then the / projects then
we have a project ID which is captured
here so we know it's an int then / merge
request / query param page which is a
string because it's as I will talk about
that and the return type is Jason type
Jason type and here we have a page to
list the brackets list of my requests
page the list of my requests mean that
in the response get up sends us the URL
for the next page and that's why we have
that's why the pages in strings because
it going to be hash or anything like
that
so Paige just captures the the URL and
we can fetch then at the next page
automatically okay so in order to able
to query to query the github we need to
provide an a function so we will use the
API query function in order to get all
those magic west from the server and the
first parameter that we provide to this
function is a URL to query then we do
things that correspond to the API type
we we just defined so the first one is a
baby string which is a token the second
one and the second one is a project ID
then we have a page which is a string
also maybe type and a whole very big
complicated return type which is the
most complicated you you will see during
this presentation and we'll dive into it
in a minute so it also corresponds to
the JS to the type that we defined to do
part of the type that we define as our
API so either T serve and error io page
may request list so it's a long type
return type and whenever you see
something like that you can imagine that
this structure type so it's either t
which is parameterized with two types
the left one is servant error the right
one is io of paged marriage requests I
said you know what is the list of purge
of of merge requests the page one I just
described it just captured two response
that we can get a URL for the next page
two and IO is the one I want to talk
about briefly now so huskers say
everything is anything is in a out I oh
then ask or say that it's an action it's
a side effect so whenever you we want to
fetch something from the server we need
to go there and retrieve the list and
this is side effect right it's an impure
stuff so whenever we do something like
that in our case it's just fetching from
the server we just wrap it in il and we
can do any any side effect in haskell
without wrapping this in a 0 so this
means that whenever we see IO in the
type we know that it's an impure staff
side affecting stuff
we got from the real world or the you
know external world so to say for
example the merge request we fetched
from the server and we can't get work
get rid of it Kent so we got this io
impure stuff we can do calculations in
our function with with it and whatever
we return needs also to be wrapped in a
iot so we can't get rid of it if if we
don't do that we just get a compiler
error so just remember if you want to
say to the aisle leave me alone then it
will say nope remember and this is very
important that's why I have second slide
for that and the quiz for you what's the
difference between function one in
function to who knows return time but
what does it mean yeah the second one is
a side a side effect so function one we
know that the merge request list is
strictly defined as a argument of string
so we can only so whenever we put the
same string as an argument we always
return we always get the same list of
magic with the same cannot be said about
the second function function so for
example in Haskell whenever you do want
to do a hello world program or something
like that you need to you need to work
with IO type which is very hard right
but / put string kevin is a string
function that returns io of unit for
example so it's it shouldn't be so scary
anymore for you so this either t type is
the only one left that we need to define
it to explain from our return type
either t is something very similar to
toe to either it can be left or right if
it's left then it contains servant error
which is just a server error you know
this connection or timeout or something
like that and the right if it's
successful then it returns right with
the IO type and Paige murmured requests
ok so the so far we've just talked about
the type of the function that we want to
use in order to fetch them magiquest
from the gate web server and now we just
need to implement it and this is one
expression implementation servant gives
us
the whole generation based on our API
type okay so this is this is whole and
we can now just API query this and we'll
get a list of my requests from the
server but it's not very nice because it
takes forever elements so let's define
another function which will called page
to merge requests and it will just get
two parameters as input one of them will
be a app config now you probably can
either see it because it's grayish stuff
so it's token server host airport the
static things that we have inside our
application so its global throughout the
application we just pass it around and
everybody knows what to do with that and
that's why we get a function which takes
two parameters but the same return type
as you see so let's go to the
implementation is through its slightly
more complicated than the previous one
but it's also it's also one liner right
it's just a function application we just
wrap stuff around for example we create
a URL and the token which is is maybe
and project ID things like that remember
that maybe can be nothing or or just a
and the last function of this module the
one this is public we just get a all
merge request from just calling this one
function and it will also reuse the page
that the last one we defines of this
page one and as you see there is a
different in the return type the page 21
is gone so all merge request mean that
we get all the magic west from the
server not not just one page so remember
this return type here what paged merge
request returns because it's better for
you to understand this one and if you
get bored with all the slides with the
code the next one is with the image so
it should be easier for you to
comprehend this one and it's the most
complicated we've seen so far and it's a
it uses the recursion and the one the
recursive function which is internal is
a fetch page neg function it takes two
parameters current which is the current
set of results we have and it's it's
empty list in the beginning and the page
the current page we want to fetch which
is
one in the beginning also and remember
the type paged me request what what type
is it it's a dirty servant error I Oh
paste merge requests so page through a
page response is a different type so
this left arrow and do notation unpacks
unwraps the things from the either TI o
surrender or I oh and it's a type paged
merge equus so we we do this this kind
of stuff and get mrs concatenate them
with the current released get the new
page and then pattern much on the page
and when when there is a new page we
just continue recursive calls and when
there is not then we just finish with
the recursive calls and do a return all
mrs return is another function and it
returns those all mrs in the context the
whole do notation the whole do notation
is in which in this case is a dirty
servant error i oh so this works pretty
exactly the same like in for
comprehensions in scala and yeah so if
you get bored with the last slide then
you just need to remember that you can
do side effects without this without the
io but for example it can be raising
temperature of the cpu or computer right
it's it's a side effect that you can do
without i oh ok so this is the whole
module and all the things that i've
talked about just just now those are the
functions api query which is generated
by server and paste my request which
just uses api query and all my requests
that just uses the page magic quest
function and this is the type of our api
again this is just one type whenever we
change something in the type it the
compiler won't allow us to do anymore so
whenever there is a change in the API
itself for example gitlab changes the
api we just change this type and then
fix the compiler errors and it should
work yeah so the same story of comments
very similar situation we just we just
need to fetch from another path and
serialize two different type here Mel
request comments type but it's also a
list we'll use it later and
now on to our business logic business
logic which just takes the thing things
that we fetched from the gate observer
and transform them into a list of the
stats of the each of the merge requests
and there is a stats of course there is
a stats object also and this just can be
serialized to JSON we don't need it to
be just realized from json for now so we
just say that this instance of to Jason
and those two things will be calculated
for the just for the sex of this
presentation first of them is time to
merge second one is comments quantity
and calculate starts function which is
our business function first things first
so what's missing here what type is
missing here yeah so now I oh we just
with our business function doesn't have
to take anything I all related it's
testable this way right so it's a good
thing that we don't have any i/o here
and yeah what it does it just calculates
time to merge for us and the returns
emerge requests at object nothing
nothing more so to connect all the dots
we need to have one function that takes
the emergence from the server calculates
the statistics out of them and then save
into our in memory storage so that the
back-end service can reuse them and this
is the what the function does and it fed
it creates a config again say hello to
our do notation here but this time it it
works in a different context either t of
string cayo and we take an app config
then we fetch all the merge requests
then we fetch a comment then we define
the fetch comments function we map all
those comments into fetched comments and
then zip each mel request with the list
of comments calculate statistics out of
it and write to storage question yep
okay yeah a very good question so what
happens what happens whenever we get an
error which we got rid of because you
know all my requests and all comments
receive a servant error right now so
it's either tea it has io inside it so
everything as i said before on the
several size before when you see it so
it's also yeah either tea has io inside
it yep yeah and this is the case so I
this structure either t is not either
you know that t means just that what you
were guys all saying okay so in fact
it's I owe a debt as a top layer but
it's hidden inside okay just for you do
to have a better programming experience
so that you don't have pattern to
pattern match at different levels okay
so just just an easier way to program
okay and we at the beginning at the end
we just write to the storage as I said
so this function again fetches demers
request calculate the stats and serve
them in to save them into the stock in a
very storage and app config is either d
string io of app config because its
environmental variables and right and
error to string is something you if you
guys asked so we we just replace either
servant error with either string and now
we go to the back to the server side
stuff and as you see the API type is
also something that defines our server
side not only they consumed a client
site and so we have two end points mrs
and front pay and front stuff which is
row and mr three see on each get we just
returned
the list of my requests stats and there
is a definition of this of this of this
api path we just read from storage
whenever we get mrs and serve directory
with our front front page using the self
directory function and the main function
which is the last stuff we will see from
the back ends back back inside so main
function creates a new storage in memory
then a synchronously fetches all them
mrs and save them if saves them into
memory and then at the end we just run
in the main thread we just ran our
server on 88 ok and we did it this is
all functions we we've done and the api
stuff we done so all my requests fetches
from the server the same sorry for
comments then calculate starts our
business logic function and the fetch
mrs and save stats a function just
connect the dots and the server function
just returns the server nothing nothing
more so that's all all those free all
those three blocks are implemented and
the just a quick quick side note so we
have just one type as our API so our API
is a finding one type we can of course
implement the client for it we can
implement the server as you see as you
but also we can for example how to
generate JavaScript client for the API
so again API is just one place when we
change something and all the all the
changes that are needed in our code just
spreads across spread across all the
other layers of our application the same
for documentation so those two things
can be just out of general generated
based on the API type and this can be a
more descriptive than what I've shown
you here so the documentation in
JavaScript clients are really
nice-looking and let's do the front end
so we'll use em for that and elm it's
very ok I like and a lot because it has
all the three things i love about
programming this is stream streams types
and of course one more thing which i
don't remember it
now it's virtual Dom I just remembered
so it's virtual Dom and all those three
things I will explain a bit so the
requirement for this for this
application is just magic with stats in
the table and each five seconds will
just refresh all that is and that's also
dynamic table of our stats we calculated
on the server side so LMK architecture
is Model View update and update and view
our functions so model can be anything
we wanted to wanted it to be and the
update function takes model and action
as a input parameters and what update
function does it returns a couple of new
model which then become a model in fact
an effects and affects our data for
example an effect can be please get me
something from the HTTP endpoint this is
this is kind of effect and then this
effect can be replaced in Elm runtime
replaced with the action and action can
be for example here's the result of the
HTTP think you wanted okay and the model
also can be piped into view function
which then translates it translates it
into HTML object and this is what I've
what I've briefly spoke about just this
is a virtual Dom object so Elm rendering
just get this HTML object and checks
what's what's currently displayed in a
browser and dips it with with what we
want to display now and just does the
minimal list of Dom operations in order
to achieve this result so it's more
performant this way virtual Dom does
that so whenever use react J's for
example is the same story and so any
questions about about the automatic
architecture ok so the puzzles that we
need to solve here are just free three
pieces the one model and two functions
and the model looks kind of similar to
what we've seen so far and this is Elm
code so there's one obvious difference
which you'll notice in a bit but the
mesh request is saying the
request status is the same as on the
back inside and the model here there may
be one surprise for you this is a list
of my requests okay and but also it's a
last refresh time there so in Elm we
cannot take the current time so we
cannot ask Elm hey tell me what's the
current time because it's not pure right
every time we we call it we just get
another function so the constraints on
Elm doesn't want to want us to do that
so we need to be more pure and put a
last three first time in our model and
this is a actions that go into update
action so we define explicitly define
what kind of actions can be done inside
our application and it cannot be more
than that so in our application we can
update the list with the new list or we
can take the time with the current time
and the action large as defined update
list or tick are of course piped into
the update function alongside with the
model and we pattern much on it so
update list list we just returned a new
model model where Mr stats is a new list
and a tick effect and that whenever we
pattern match on tick with a new clock
time we just check whether the last time
we refreshed is five seconds ahead or or
something like that and then if it's not
we return the current model with the new
teak and if it's if the five seconds
passed then we return the new model with
last refresh time and the clock time and
that much request fetch effect function
which I'll show you in a minute it's
just effect we want to we want to do
whenever we want to do a refresh and as
you may as you may guess we have guessed
the mesh request fetch effect this is a
this is 1 colon instead of double colon
in Haskell so we get the we do H did we
get requests to our server this is a
decision decoder which I won't show but
then we pipe so this is like a pipe pipe
stuff so this this result isn't pipe
into maybe then it's transformed
it's nothing it's just done and when
it's just we just do mapping to the
update least we got from the server and
we create the action out of that so view
function yeah this is the scariest part
probably so each HTML element has a
function for example diff has a function
table has a function th has a function
and each of those functions take just
two lists the first is the list of the
attribute inside the HTML tag and the
second list is the list of children of
another HTML object so in this case we
can see that dave has this layout and
h110 stable children and table has this
kind of style a t hat and t body so each
magiquest at in the model is mapped
through the studs view which creates the
TR HTML object out of it based on the
things that are in the model so again
the same architecture but now with the
domain specific things we get the model
which are which is emmers made requests
and the refresh time we pipe it into
update function alongside with tick or
update list action so those are just two
actions that we that we defined no other
action can go into our update function
and we produce the new model and some
effects so effects are in fact the data
and order impurity is gone it's done
inside an llm runtime so M runtime just
cause our update function whenever it
fit it sees fit so a the same very
similar story with view each time the
model changes the view function is
called and we just returned and you
return a new view object if it's the
same then nothing happens on the browser
side if it's different than the
minimalist of operation is done on the
Dom side in order to render it so fame
and glory this is our application and as
you see the calls are done each five
seconds this is this is like set of
stats we did with it so this time to
merge for example three days five days
for this this mulch request and seven
hours at 93 minutes things like that so
and one side note whenever you use elm
you can do something like time time
travel
okay will you just write your
application you didn't just run it and
you can pause it pause it and get back
like 50 updates to the left or in the
past and see what was the model what was
the state and how to debug how this back
came to life and you can of course see
it for yourself you don't have to
install anything install anything you
can edit the code and play with Mario
this is like 70 lines of code or
something like that just the Mario Mario
stuff ok please do so all the links the
backend project the front-end projects
few movies to watch of course and yeah
this is my blog this is my twitter
handle and thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>