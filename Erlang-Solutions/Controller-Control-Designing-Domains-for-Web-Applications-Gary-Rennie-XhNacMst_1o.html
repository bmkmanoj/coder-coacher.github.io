<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Controller Control: Designing Domains for Web Applications - Gary Rennie | Coder Coacher - Coaching Coders</title><meta content="Controller Control: Designing Domains for Web Applications - Gary Rennie - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Controller Control: Designing Domains for Web Applications - Gary Rennie</b></h2><h5 class="post__date">2016-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XhNacMst_1o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is talk about controllers so I'm
not sure what the criteria for talks for
this conference was but entertainment
clearly wasn't one of them
so the format of the talk first-half
moving on web stuff at a web second-half
umbrellas done oh so the default Phoenix
structure this what happens when you run
mix Phoenix knew where you end up with
an application with most of codes and
web you'll have some files in Lib you'll
have like your end point in there your
repo in there like a application entry
point will be in there you may be some
gen servers and stuff but there's a lot
of stuff in web and it'll be split into
like controllers models views and
templates
there's also channels in there there's
like a static directory and it's all the
stuff that's kind of web really it all
goes in there
some of the stuff maybe shouldn't be so
it looks like this if you can't read it
in just use your imagination but the the
the Lib directory is pretty bare and the
web directory is pretty full and there's
a models directory in there and there's
templates and things and this is from an
application that I'd already built so
there's some stuff in there as well some
in the templates directory so let's talk
about controller is so it's kind of the
glue code between like your model in
your view and I'll talk about what I
mean by a model of you I was like well
not view of use like you know something
that outputs either HTML or Jason and
your model is like your domain model so
the controller should really focus on
your web layer so when you have an HTTP
request comes in via Kowboy it will go
through the end it'll start in the
endpoint and they'll be a series of
plugs in there and then they'll do
things like pars of the body and log to
the output and then they'll be like at
the end it's usually your route or in
there and then your route as a series of
plugs you may like guard a set of roots
behind authentication in there validate
your formats and things and then at the
end of your route or they'll be a match
somewhere in there or they will point to
a plug which could be a controller
action which is a foreign plug and then
you'll be into your controller and
you'll do some stuff in there maybe
you'll look up some cement trees and
you'll you know store them and signs
then you'll eventually action an action
will call your function which could be
like
show update or delete or whoever and so
it's kind of manipulating this plug
construct all the way through the
request sockets and channels are kind of
similar but for different purposes so
they don't interface with plug calm but
they're for like real time and the same
problems I talked about here will
probably also appear in there it's not
entirely web specific I'm going at this
from a web angle because Phoenix but
there are other applications where this
this applies so a controller isn't
though it's not like the direct
interface into your database so it's not
say you can't you know manipulate things
in the database from your controller you
just shouldn't do it directly there are
other ways you should move an
abstraction in there and I'll give some
examples as I go through so the one
thing that I maybe want to want to start
advocating stop using repo and
controller this doesn't mean if you
already have an application don't go and
like phone your team billing we need to
rewrite this now the world is on fire
it's fine but it's just something you
should keep in mind you know as you as
you go forward
so here's the RP of grep and I'm
graphing for a repo in my web directory
you'll see that it appears in several
the controllers and there's also an
alias for it in web DX which gets
included by everything I'm into this at
start but can I show hands for who's
used Phoenix before I guess that's a lot
who's used umbrellas before okay who's
he's both all right well you guys enjoy
your early lunch so removing repo out of
control has a 100% success rate because
this one person is tweeted me and they
said there was a great suggestion it's
been a massive improving their app and
so far no one has tweet you maybe go in
Gaza Lou I hate you this is the worst
idea ever so so it's you know it's
proven definitely so let's talk about
why Reapers in control in the first
place
you know it's it's got in there and
somehow people have kind of decided
that's where it should end up at the
moment here's the Phoenix guys I mean
team by the famous core team so I fall
under that category and you'll see that
I've put a piece in but it's not
involved in the guides by the way that's
me doing that so that you can see which
part I'm talking about and it's the
Reaper in sir and this is the courier
action of a controller it looks like it
creates a user here is a screenshot from
github where again the code in bold it
uses repo this is the generator for like
the HTML generator and it uses repo repo
throughout repo is the storage mechanism
from act oh by the way if you're if
you're not familiar with it it's a
pretty popular Phoenix book several
places in that it shows the same thing
like it has a controller and in there
I'll get changed set and it will insert
a record and then do something based on
the result not the most popular Phoenix
book though this is clearly the most
popular Phoenix book and here's a char
from that book and I mean here's an
answer from Stack Overflow that I gave
so I can't really blame everyone else
for this the question is should I use
sector repo and controller model for
Alex of Phoenix and my first line it's
in bold here again not involved in the
actual question or the answer I've done
that for dramatic effect but it says you
should keep your repo calls inside your
controller music those exact words I
didn't go and say if your logics
complicated then you should consider
moving logic out like a service module
so maybe I should go back and delete
that answer or modify it to take out the
first line and that would mean I
wouldn't have to show the slide but
showing it now so why sweet Flynn
controller we the fiends core team
people give advice on this you know
what's a blog post guides and things
said it should be about things evolved
here is a screenshot of a tweet of a
photo of a slide from Chris McCord's
keynote and it's the the new generators
in Phoenix 1.3 and you'll see the the
web directory is now instead of Lib
so before web was in the root it was
like the special directory and people
are confused if you like are so which
goes on web and which goes on Lib and
the answer you kind of dodge around to
be like well if you need it to recompile
and reload then put it in web because we
can recompile that directory and if not
put it in Lib but that's no longer the
case as a phoenix 1.2 so now the answer
just put in Lib and as a phoenix 1.3
there'll be this lib web directory this
is just a default so phoenix itself
hasn't changed it's just the generators
you'll see the assets directories
this would have been like your web
static assets you know one module and so
on so I wanted to do such an application
now it's called world of grand theft
pokemon gold 2.0 when I came up with
this I didn't think you'd be the Second
World of Warcraft reference today but is
anyone who was at my elixir Kampf us
talk and saw my tic-tac-toe application
there this is totally different this is
knots and crosses okay speaker notes so
here is the application and it's pretty
pretty stylish I'm logged in to users
here in the left I'm logged in this user
is damn calm and the Ryan login as Gaza
at gmail.com you can tell that because
I've just told you and if you look here
there's a list of challenges and there's
no challenges available yet and then
I'll hit this new challenge button and
it goes into the state where I've used a
UUID so it ruins the layout and it's
waiting for another player to join so
I've issued a challenge here I'm showing
this mainly for context but also just to
pad the talk up a bit so now if we look
at this channel I can join ah here's a
challenge which one of these games do
let's go this nail the first time so the
X always goes first and the way a
randomizer is the the one user I'll be
allocated each one randomly so the exes
can only go on their turn look I can't
promise I'm clicking there but I can go
on the exes and then the nos it's pretty
cool right it's a gen server in the
background that maintains a state I did
a whole talk about it there you can go
and watch when the videos are up because
I'm not gonna go over here and the game
continues until someone's declared the
winner like that and yeah that's that's
the game that's yeah so let's talk about
how not to repo how to not repo so what
we can do is we can create functions and
like a context this is that service
module I mentioned in my microphone
server you know with a better name so a
context like a module that has a group
of kind of related functions in there
that will do something that involves
your domain
and I should do everything that's not
directly web related so as an example
taking an HTTP request probably web
related saving to the database not web
related sending an email probably not
web related tracking - stats D not web
related unless you're tracking the stats
of your HTP requests in which case the
measuring of its web related but the
tracking of its not so a good way to
start doing this so just delete your
repo alias and web dirty X and watch
your compile errors just grow and then
you can go and fix them an xref will
tell you as well like if the module no
longer a point star function exists so
let's talk about registering a user
which is a pretty common workflow in an
application so here's a controller
action it's the create action the bottom
of this slide is not important probably
and we we split so we've got these
params that come in these will be the
HTTP params and what we're doing is are
splitting on them so the first the email
the password go to these off-brands and
the other params good for the player
params and i like to do the split in my
application because you've got this
internal representative a user or player
and that'll be like when you use for
your foreign keys for the games and the
challenges but then you've got this
authentication which is separate and if
you split this list away from the start
when you want to bring in a new
authentication mechanism like I don't
weld app there you could do that pretty
easily and all your foreign keys still
need to will still work so you don't
have like a massive update to do so in
order for this to work we need both
entries to be valid otherwise we don't
want to register that user so we start a
transaction and we try and answer like
the account which is the authentication
credentials if that succeeds then will
then generate this player which is kind
of what my user is it's kind of more
specific to this application and we take
the account ID that we got before and we
answer and then if that succeeds then
we'll take the email from the
registration and add on the players
let's assume that's like a virtual
attribute or something and if anything
fails we're all back and then if you're
one of the last lines do we PI bet okay
so if it succeeds and we redirect and
say hey okay you registered no login and
there's another case there that's the
error and that will rerender the form so
if we move this from the controller the
controller end up looking like this so
there's a lot less in there we're still
splitting
so this time we're matching particular
arguments out of the map the email in
the password and we have this accounts
to register player function which takes
the email password and the params and
there's not a mention of repo here at
all
and then we've got this accounts module
and in here that's register player
function takes an email password and
player params I'm using act remotely
here because I wanted to talk about it
and I need to crowbar it in somewhere so
this kind of works the same way as the
transaction before but XML is I guess
you think of it like a pipeline for your
database so their function like insert
and delete on there and the first
arguments like a name and the second in
this case the function the argument in
the first case I'm ignoring but that's
the result of the multi so far so in my
first thing I'm calling this other
module off throat register I haven't
shown the implementation but let's
assume it creates a user and then the
second function I'm grabbing the account
same as before and creating a new player
that is associate to that account and
then I am just calling repo insert there
and I then pipe this to to repo
transaction so same case applies if
either one fails the entire transactions
roll back and then this other function
handle new registration so this is
another part of it that we're using the
if it succeeds then we get okay results
which is the result the ecto multi and
we again attach the email it could have
before it's a virtual attribute and we
send an email some sort to the player so
you know welcome to the best game ever
hope you enjoy your stay and then we
return
okay player and that's the same as the
controller was using before so I'm going
to change that part of the controller
and if it fails then you get a four pool
with the error the the name of the thing
that caused the error then the change
set and then the result of the multi so
far and I only care about the error in
the change set so that's why I want to
return so that's what the controller
expects and now we've got this this
module called accounts which is like the
context so this is like our domain this
is the stuff that's you know specific to
my application I want to register an
account and a player and this kind of
contains all the database logic but also
handles the email and transforms the
response so they can be used by the
controller and it's also leveraging this
other contexts as well so you know you
can use more than two you can use as
many as you want and call other
functions they are just functions and
the benefits here is like our domain
is no longer tied to a controller or a
web interface at all so it means you can
provide other interfaces into the
function we could have a mixed task for
example mixed register user we could use
a more exotic technique and buy exotic I
mean old like telnet or email so I'm not
advocating that you handle user
registration by email but you could but
the most important thing in my opinion
is like you can test this now without
your web tier so before you'd have all
these tests in your controller that will
go off and register the user and check
that the users in the database or
however you're testing it maybe you try
and log in and then that works and
that's still a valid test you may still
want to keep it around but you've got
all these other edge cases you need to
consider what happens if an account
fails what happens if a player fails and
now you can test these in isolation in
the accounts module test which is a very
powerful testing technique so I've got a
few more of these examples they all
introduce something new so I'm not going
to go through the entire application but
everything should hopefully bring bring
a new thing so this one here I'm getting
the current user so let's assume I've
got a plug somewhere that takes to them
the IDE who's sort in a session and
fetches the authentication from it so
she's an acacia not the player and then
we'll go through the deleted code first
which is in red so we we preload the
player from that authentication and then
we fetch all the challenges that are
open so this is where if I go back to
the application
still looks awesome and if I view if I
create a challenge here and then view it
you'll see that I don't see my own
challenges I only see the chance for me
other user so there's a piece of code in
there that says you know that that
second part of the query which says and
not my ID and they're all open as well
so that challenge the their work to
forget or anyone was closed and we
preload the player as well so we can
show their name now what we do is we get
the challenge I think what we're calling
this accounts that get player which will
take like an authentication struct and
return the player from it and we've got
this game that lists open challengers
function and now it doesn't matter where
our challenges are fed from they can be
fetch from a database or a MongoDB or
like a gen server or could use a static
list it really doesn't matter you can in
fact delete your whole implementation
and start again and you won't have to
change this file unless you delete like
the whole application or something
when I say implementation I mean the
implementation
we still can challenge function and the
other thing to know is it's called list
open challenges it's got not called like
get all challenges like it's something
that's and I'm trying to convey what
this function does in its name so it
will only list the open challenge it
doesn't get all the challenges it's not
like challenge index or something and
that the implementations here are just
the codes I've deleted from the
controller
I've only moved the code and moving
coordinate licks is very easy and now
we've got this game context again it's
got all the database logic but could
have other stuff in there as well so
here's another case this one's different
because before it was using me to insert
exclamation mark function or bang and it
before we'd build the challenges and
insert them and if it fails then it
would raise and now we're calling this
game door issue open challenge function
again with a bang so it raises and this
is an easy case because there's no
matching to do here so we've kind of
ported the function and the again the
function name is explicit it's called
issue open challenge it's not called
like create challenge it's very explicit
in what it's doing so he still gets game
context but now we're you know it's it's
no longer using the controller so again
we get the testing benefits one more
which is the close challenge this is
what happens when it's got that waiting
screen and the other player comes in and
then both of them update over the
WebSocket I'm showing this one because
it had a more complicated match in there
so try and bear with me
so it's got the it's getting the
challenge and it's getting the current
player ID so let's assume we've got a
plug somewhere the gets the player from
the the user of the authentication and
then we're matching on the challenge and
the first match says if the player ID is
my own ID then it's my challenge and
it's fine I'm totally allowed to see it
something I didn't show is you can all
have two players in the game because if
your play not some crossed over three
people doesn't really work so well let's
do the signing of token and then
rendering and if it's a challenge there
if someone else has issued then we close
the challenge and update and for any
other case we say we couldn't find the
challenge of return and we replaced
these top two matches here now we've got
Gabe lock closed challenge which takes
an ID and the player and we're fairly
there okay challenge or something else
and the closed challenge function again
we get the repo so we get the challenge
from the database and we match on it
here okay challenge with your own if
it's someone else's child
Update challenge function which I
haven't shown here but you can guess
what it looks like and for anything else
it's an error it's not 5
so a quick summary of the way you can
rename this you want to remove the
replay list from your web DX to cause
compilation errors again use grep
liberally to see where you're using repo
this same thing by the way it applies to
channels and sockets and it doesn't only
apply to to Phoenix or web applications
like fuse and nerves or something you
want to isolate all your i/o with the
device in different modules so that you
don't of all this logic because in
nerves you have to boot an SD card and
burn it and then take it out and plug it
in and then you boot up and say ah this
didn't work take it back out put it back
in so you could save a lot of time doing
this and yeah you just want to move the
the it's usually just copy and pasting
code over the controller and into some
other module but you need to think about
what the modules are called and what the
functions are called I do you want
control at times well don't try and do
like everything at once because you can
have a bad time and commit at the end as
well this is actually get talked with a
little bits of elixir thrown in so I
will mention when to commit several
times so let's let's talk about models
well the norm are called models the
thing that used to be a model and actor
is now called a schema sometimes you
kind of take things away from people
they used to have and it causes outrage
like like for example in the iPhone 7
took away Jack
if twice as many people laughed that
time which means only half of you got
the joke which is fine so let's talk
about our model is it's kind of like a
representation of your domain hence the
phrase domain model so it's nothing
really to do with your database tables
you can certainly leverage the database
and you can do database related stuff in
there you can do like leverage many
transactions in there as well like I was
doing that the account and the player
and my domain model was responsible for
doing both creations there I become to
other things as well like showed email
tracking to stats D sending an SMS
calling to Jen server it doesn't really
matter but Lisa kind of capture a part
of your your application schema on the
other hand is a representation of your
table or usually it's a way of mapping
from a database to an elixir struct and
it can reference other schemas as well
so you've got things like has many
belongs to you've got embedded schemas
in there and you just reference the
module that has the struct that it's
using you can also perform data
integrity validations so these are
things that you know are important
before it gets persisted so you may be
like you know a required field can't be
blank or something must be unique which
you backed by database index I probably
wouldn't put things like you can't
create this on a Tuesday in the schema I
would probably handle that elsewhere it
really depends if your applications
really gonna fail if you save something
on a Tuesday then maybe but I would
handle it elsewhere so in order to
change the the models to schemas like we
could just move the models directly to
and call it schemas and that would work
and that's fine
we need ended up with files like schemas
challenge and schemas player but what we
can do instead is we can like nest these
schemas in the context the is leveraging
them so for example we'd have game
challenge or it off accounts player and
you get this benefit then you can see
from the file like kind of what it
relates to so a challenge relates to a
game and you maybe wouldn't get that if
it was you know just in this one
directory with a hundred schemas in
there one potential downside of this
that I've seen is like you can't find
out at a glance what your schema looks
like and that's true but there are
better tools that you can do an active
schema dump or something if you want to
just look at your schema too you have
other options there and if you're really
bothered you could like call the schema
challenger schema
and a listen whatever you use them you
also need to change model case the
database case because like models gonna
be a bad word in your directory
structure soon so so use something else
and when you've done all this you'll
have an application it looks like this
and again if you can't see what's
basically happened is my Lib directory
is grown and I've deleted models and oh
the web directory is still in the root
by the way here so so next thing you do
is move it and you can do this with just
like these commands you want to move
your web static directory into there and
move your package chasing your node
modules you want to make sure you get
ignore your node modules cuz it's
probably about 4 million files and they
probably four million of the own file in
there so definitely had that to get
ignore you don't to commit that get talk
and then you want to move your your root
level web directory into the Lib
directory and then here's a handy script
so what you should do is everything in
the web directory should be namespace
from the name application it's not
actually world of grounds of Pokemon
whatever I called it it's actually
called oXXO and I've renamed all the
modules in the web directory to oxido
web and that'll make sense when we talk
about umbrellas and once you've done
that it says again so the web directory
is now inside a Lib it's kind of the
same level as the the context modules
all right that's first half umbrella
applications is next so let's talk about
umbrellas so summer why you want to use
an umbrella application there are
several benefits and some have been
touched on earlier so one of the things
you can like develop each application on
its own without any thought for the lab
patient's and you can kind of allocate
different team members if you want into
their own application you can run the
tests on each application individually
which is which is very useful and then
you end up with these explicit contracts
between your applications like you're
treating your applications like you
would any other dependency and this
means you get the same kind of
guarantees that you are where earlier
when we were using a context module from
our controller and you can also build
releases as a part of for each part of
the umbrella so if you've got two
applications there may be like this
admin interface that only a few people
use in the sales department and you're
on this API that's used by lots of
people you can especially using
distillery which is like the replacement
for exo-m you can say these are the two
apps I want you to build from the
umbrella and then you can deploy them
and scale them independent
and you can also extract applications
you can get fill a branch from like your
apps directory and this will make up
repo out of it with the whole git
history intact
and if that's something that you know
you wanna share between your other
umbrella applications then you can push
that up and use it you know it doesn't
mix dependency or if it's something that
you think it'd be useful you can push it
to hex I know hex or maybe support like
private packages at some point and when
it does you could push it up as a
private package and use it between your
umbrella applications there are some
potential downsides like it's arguably
more complicated you can see at a glance
where to go for the code like if you've
only gotten HTTP requests then you have
to go into the web part and then find
the route in the root and then find the
controller that matches it and then see
ads using this application and then go
over there so can be a little bit more
tricky to find things and it can be
harder to test the entire test suite as
well there are things that for example
if you got one application in your
umbrella it starts up and registers
itself under a name and then you got
another application that's using that as
a dependency it starts up and it tries
to register the same name and you'll get
a collision and you also may be of
application started when you don't
expect them to start and the other big
one is dependency conflicts can be
harder to resolve so maybe you get one
application using poison 1.51 use
employees at one point to you're going
to use the override true flag liberally
to pick one and developing new features
as well means you have to touch multiple
applications so if you've got a new HTTP
requests or importantly to implement
then you have to go in the web
application and do and you have to go
into like the the other application and
add it there and then you may have to go
in like your authentication application
it's a weird way and then add in there
so you can't have to touch many many
siblings to get implemented should you
use an umbrella fication there's not a
good answer it depends if you have
something small that may not benefit
then it could cause more harm than good
but whenever I'm building in your
application I always reach for an
umbrella first because it's really easy
to to go back if you don't like it and
you can have an umbrella plication with
one application in there you know if you
plan on it being bigger in the future
the good news is you don't need to
decide today again you need to go and
call your team after this until you need
to use umbrellas weaving code run elixir
is very easy you take the code and you
move it and you're done
moving
moving codeine applications is quite
easy you may have dependencies which is
the other thing you need to consider but
again it's just moving the code it's
possible to go the other ways well maybe
you've got an umbrella fication and you
want to collapse it down into a single
application for some reason that I don't
know then that's totally possible and
you can do that so you're not tied to
whatever you choose okay so let's talk
about how you convert your existing
application to an umbrella application
so obviously the first step is to create
a new application even though you've
already got one and the reason this is a
better way in my opinion doing this is
it reduces noise because you won't have
a commit that just moves everything to
directories down and creates this new
root directory now get onto why earlier
this where's ago but yeah so create a
new application and then we want to
rename we already have this mixed file
because their application is called arc
so we've got this oxidant mixed file and
if we go ahead and do this and then try
and pour it we'll get a name collision
because we'll have two files the same
mixed file so I usually rename this like
that platform don't mix file or umbrella
but mixed file something generic that
you know represents what it's doing and
then we need to set up get gets gonna be
really important because I like to talk
about it but also because it's vital for
the next step so you want to if you use
an SVM then I have no idea how you do
this I don't
so we'll set up the repository and then
we'll make a commit because it's good to
commit before you make changes you want
to keep your commits quite small and
then you can squash them later you can't
go the other way on unscratched commits
but it's a lot more work you have to
interactive rebase so kind of start
small and what we do is we could just CP
the directory across right and that'd be
fine bit looser get history and you know
we've spent months writing commits is
like fix X and clean up and you know
we've got all these amazing commits that
we want to preserve and if we if we do
this then we'll lose the ability to for
example get blame so you can find
through a particular piece of code and
politely ask them why it works in a
certain way or even better just reading
the commit message because it will be in
there right or my favorite git command
we should all have a favorite - bisect
and this is for finding bugs so maybe
there's a bug been introduced and you
need to know where it was introduced and
it's on the master branch
so you'll mark the master branch as bad
and you're like oh this is working in B
1.2 so check out v1
point to mark that is good and then
he'll do like a binary search between
the commits and they'll be here the
committee produced in this commit here
introduced the bug well it doesn't say
that just says this is the commit you're
looking for it might not be a bug it
could be something else but if you if
you just see P again you get this
massive import commit and it doesn't
really make much sense too difficult to
find anything in there and there's a
better way that's pretty cheap as well
so I would use that and the better way
is it's called get subtree and the we
get subtree works it's unlike a get sub
module which is like a reference to
commit somewhere I get sub tree we will
import the code into your directory and
it will do so by maintaining the get
history and you can sub pretty much more
than once as well so maybe like a
long-running application and a different
repo somewhere you can keep subtree
merging it in to keep it updated and
then we subtree what add works is you
add a remote and then you fetch the
remote and then you call subtree add you
specify prefix and the prefix is the
destination for the application and I've
got my Knox a web in this case because
there's kind of more web stuff than non
web stuff but if there wasn't you know
all the config in there I've got my
endpoint and stuff so that's why I've
called it Oxford web but if it was the
other way around I might choose a
different application name and the
important thing to know is not only the
entire history preserved it's preserved
with the original shares as well so if
you've got maybe references on github to
a commit then that link will still
follow through so we we need to update
the app config as well we're now in an
umbrella mode so we need to tell her app
here you're in umbrella mode and it's
pretty easy there's just a few things
you need to modify to make it work so
build depths and lock file are also you
can use the root level one so they're
shared between all the applications and
this will speed up your compilation
times you do have a build and a depth
directory power application and as of
Alixe at 1.2 we can now share the config
as well so prior to this the way you'd
share configures you go into your
application you import the config from
the other application it's a bit clumsy
and the way it works now is you've got
this config you can point to the root
config in the umbrella and by default
that will cascade through all the
children in the umbrella and import the
config and what this allows you to do is
if you've got a web application that
uses the database at some point then it
won't be configured but you can if you
do this it will port the config from the
app that does know how to configure the
database and you'll be able to use it
you can also get m/v your lock file up
mixed up lock yeah you can there's a
space there but you can move up to
directories and that means that the lock
file you've you've been using before can
be used for the Umbrella application you
want to check everything works as well
it's pretty important this changes and
broken anything so you can on MIT's
adept yet and mix tests and all your
tests or pass because you've all you've
got now as an application with one
umbrella in it no an umbrella with one
application in it and that's fine you
want to hope everything works but it
won't because when you were mixed views
of server you'll realize that you've
forgotten to build the static assets so
they're in the this directory you'll
need to run npm install from there and
then then all look right so after we've
got this summer allocation one
application in there what we want to do
is look to split our into two
applications and because of all the
things we did in the first half of the
talk is going to be really easy
everything is already kind of ready to
go so web stays in the web application
and everything that's not web really it
goes so you probably know what I'm
talking about here and we're gonna
remove the concerns of other defenses as
well so you don't wanna fetch in and use
the dependencies of another application
because they're not your dependencies
you shouldn't be using them if you want
to use it add it to your own application
so in this case come on in which the
password hashing library that will be in
like why like to call the core
application which is what contains all
the domain logic and the other
applications like the web application so
the way that patient shouldn't be
hashing passwords it can call the core
application to check that the passwords
valid but shouldn't be doing it directly
and the same thing goes for comfort you
should configure each application for
itself you shouldn't you configure other
applications in there and you wanna make
sure you move the tests as well because
the test will probably still work
because all the module names are correct
but you won't be testing the application
that you think you're testing so it's a
good idea to move them along as well so
the way we can do this we can create a
new application to supervise the
application that's we're using sup flag
and we want to add this application as a
dependency in the web application we can
do this using the in umbrella option on
the the config and that will tell mix
that this is a another sibling in my
umbrella and we also need to add it to
the applications list although there is
some talk on the mailing list about
maybe not having to do this so if you
read the mailing list you'll know I'm
talking about there if not go read the
mailing list it's on there you want to
move the database configures well so
when you start
application I'm like when you run mix
Phoenix knew you only get one
environment so you want to make sure
that you've replicated the dev test and
production environments as well you want
to move over all the the config files
you've got ecto repos which is a new
thing in extra - which is a list of
repos that your application uses and in
there you'll want to make sure the the
web applications got an empty list and
the application actually has a repo has
its repo and this allows it so when you
run like a mix ecto command from the
root and those which people to use and
you want to like say update the
dependencies as well so the database
dependencies for ecto and anything the
ecto is using you want to move across
and you wanna make sure you've got in
the web application you don't want a
repo supervisor and in the core
application you do so remove it and then
you want to move the tests over as well
and this is by the way why we renamed
anything to oxidant web because now the
web application is a namespace so
everything that's not there can go and
if we move the test over against a few
commits got failing tests it's not good
commit so make sure you all your commits
or a working build copy the database
case over need to update they like to
see paths and mixi access as well and
what this means is in Phoenix when you
start generating your application
there's this elixir see paths and in
there it's the paths that will be
compiled and the important one we need
from there's test support and that
ensures that the modules you're using
for your tests or compiled as well and
update the test helper so it's using the
correct repo check oh and you know the
the sandbox things that ecto provides
and once you've done that your directory
structure will now look like this so
we've got two applications we've got
like Aqsa which is our core application
ox or web which our web application and
it's only got the web and anything web
related like the assets and the other
applications got all the logic in there
and the migrations as well so just to
summarize migrating at your application
to an umbrella it's it's not too
difficult like I'm not going to tell you
how many story points it is but but in
my opinion it's not too difficult and
you can do it in a way that again I
don't want to bang on a bug it but I
really do you can do in a way that
preserves your entire git history
so everything if you do like good commit
messages you'll you'll get the benefits
there and again use grep check your ox
or web repo
or application there shouldn't be any
repos in there the one exception you may
use in your tests but what I tend to do
in this case is in my core application I
will have like in the test support
directory if some helpers that are like
create user or create account or create
player and then using a combination of
that and the public functions I expose
in my domain application I've got enough
there that I can write good tests
without reaching for a repo directly so
going forward there can be more than two
applications I've used to in this
because there's an easy easy example but
you can have many more you have as many
as you want and you want to try and
think in applications as well and say me
want to kind of try and think in context
or domains so try and isolate them so
that they only do one thing and do it
well and you want to split your common
functions and throw in applications as
well so things like authentication is a
good candidate for a move and I wanted
so no TP application same with email and
notifications like push notifications
those are a good candidate and an
application specific example here like I
could have moved on my game logic I
wanted so an application if I wanted to
play from the terminal or something that
would have been fine but it's it's more
tricky to do if I don't isolate it yeah
that's kind of all I've got
I'm gas ler I'm the gas flow and Twitter
because I didn't register my care until
2011 I work at a company called voice
layer the code for my knots and crosses
github thing and someone asked me as
well this is the picture I use online
someone asked me yesterday you the guy
that eats Jenga I just want to confirm I
don't eat Jenga
there's no nutritional value in it but
but you can play it in your mouth Thanks
behind the pillar hello hi so I I got to
Phoenix applications in my umbrella
one is just having an API which is
separated out and the other one is the
main application and the thing is when
when I launched them how would you do
that right so I I'm referencing one one
app the main thing to have the same API
ul structure so I'm forwarding the
router to the second application so
actually I don't need the second
application running on its own port and
when I deploy it yeah is there a best
practice around that and or um not
really like you can if you want to
deploy it in a way that works on one
server then you can do what you're doing
forward if you want to have it across
multiple servers not a problem you have
a load balancer somewhere that will
redirect you know certain paths to here
and others to another place one thing
you can do which I've done is because
your Phoenix applications are just
functions that take a column and ops the
plugs why I've done before is built like
a proxy module there is just a plug
module and in there I do some sort of
match to say does this path of API and
if it does call this function and if it
doesn't call this no no only got one
application running as a server and it
only exposes one port and it's
forwarding to the other applications
that way
a question about controllers and Charles
so do you see any major disadvantage or
I don't know anything that would be
wrong to export many of the controller
functionality into the channels the
controller functions largely revolve
around using a comm and channels canna
less so they're sort of persistent for
handling events so the api's are similar
but probably quite different so they're
not similar but you know they do
different things so I'm not sure really
so yeah you'd answer I'm not sure it's a
great answer I was yea just thinking if
for example trying to build like well
let's say like a single page application
relying on the channels rather than not
the controllers so yeah you can do that
so if you build your applications in a
way that like your domain modules your
domain logic is isolated in their own
modules then it doesn't really matter if
you call that from a controller or a
channel you're gonna get the same
results so you can easily build it in a
way that you could like for example
handle registration over a WebSocket but
don't but you could do that and that'd
be fine or you can also do it over a
controller and you can call the function
either way okay
hey so if you've got a web application
that depends on this sort of core domain
application and all the behavior of the
web application it depends upon what the
core application returns so I say oh yes
you are successful in the request to
create a user or you were not successful
when you're testing the web layer do you
also run the domain logic code or do you
like inject something else in place of
that that just returns those success or
fail messages I'll probably run both to
make sure that the response is correct
but there's less like you don't test all
your edge cases you just need to check
the paths that are in your controller if
you want to get good coverage an
integration test is probably the correct
level of testing therefore for that</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>