<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>OTP, the Middleware for Concurrent Distributed Scalable Architectures | Coder Coacher - Coaching Coders</title><meta content="OTP, the Middleware for Concurrent Distributed Scalable Architectures - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>OTP, the Middleware for Concurrent Distributed Scalable Architectures</b></h2><h5 class="post__date">2013-03-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_NpQ414ePwE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm standing in between you and your
lunch
lunch is over there so
No
so what we're saying earlier you know
public well was in the stork said barely
fits certain types of problem we just
saw you know what a brilliant well
payment gateway has been developed now
in airline and how certain parts also be
migrated to our line and if you think of
it you think of the types of problems
we've been looking at at these
server-side problems but you know this
very much can relate also to embedded so
you know first of all you know what is
scalability you know scalability is
ability to handle traffic spikes to
behave predictably under extended heavy
load the summer platform you know gets
to Christmas everyone's using it they're
giving a Foursquare bang for the buck to
start getting into the US market it
needs to behave predictably you need to
know how it behaves and it needs to
carry the traffic it was designed to
handle you need to write a system which
is massively concurrent so you've got
millions of simultaneous requests being
handled so these are the pests which all
running independently of each other once
again take payments a payment you're
doing shouldn't interfere at payment
someone else is doing think of SMS TV
voting where it's all very quiet they
say don't vote so people start voting
and then all of a sudden vote now you'll
get a huge spike you need to make sure
that you handle all of these smss and
you handle them individually
high-availability what is high
availability now I bet affinity is no
single point of failure and if you go in
and you ask joe armstrong one of the
co-inventors of our line you'll say you
need these two computers Leslie Lamport
will tell you three and that it's not
just computers you need to return the
networks
you need to make sure that you know even
if the sysadmin trips over the network
cable your system was too we'll start
continue running you need in the case of
your the example we saw earlier where
you've got a base station running under
a palm tree out in the middle of the
jungle you need battery backups you need
generators you need to cater for
hardware failures you know usually it
would had to have that a bit more time
over there with some really interesting
stories I could have told you over
hardware failures which were handled and
you need to distribute your software
that's relatively easy much harder is
distributing your data and you know
software is important but it's not just
about software you know for tolerance
your payment gateway needs to be full
tolerance so even if things start going
wrong your sister needs to continue
working if there are bugs there crashes
people payments still have to go through
and your tolerance is all about the
ability two thousand eight and error
regain control and continue operating
despite things are going wrong so
limiting the scope of the error and the
way this you know this is an errand
conference after all and you know what
will you say well use Aaron and of
course you know its simplicity in your
design it's your makes life much easier
it's got built in distribution and it's
got software upgrade but that's not what
I'm going to speak about because if
you're going to need to write a
massively concurrent soft real-time
system system which never ever go
down a system will be a built-in
distribution which manages millions of
simultaneous requests you need more than
just a programming language a
programming language will get you just
so far you can go in and you can
complain about your curly brackets or
weird syntax that at the end of the day
it's just a language and you need much
much more if you're if you're developing
really complex systems yeah
if you think of it and none of the
problems your payment gateways sort of
solve are the same problem in your
telecom system sold they're the same
problems embedded software in cars will
solve and you know what happens is you
don't want to go in and reinvent the
wheel and you don't want to go in and
redevelop the same monitoring tools time
after time the same deployment tools
time after time and this is where OTP
comes in now Eric some you know when
they were working with Alan very very
early on realize the need for the OTP
middleware and we've had some examples
of what OTP is about we spoke in a bit
about the release handling we've spoken
a bit about generic servers and finite
state machines but in fact it's much
much more than that now Alison realize
it's very very early on and as early as
1993 when they started working the very
first commercial project which was the
mobility server turbidity with vector to
roam from one network to another they
had a project called boss the basic
operating system in parallel which you
know was the predecessor vote if it was
merged with OTP in the mid-90s and you
know to create here what is part of
darling released today and if you think
of it a line per se is just forty three
percent of the power you get from using
the stack the other thirty-three percent
is the virtual machine it's a way
they've implemented the scheduler the
garbage collection mechanisms and the
last thirty three percent is OTP itself
now how many of you here are here to
learn a bit more about airline okay so
do you know what OTP means
so we could mean on the phone or has
been suggesting a one prepare or oh this
is perfect and there's another
suggestion and unfortunately it's none
of the above and what it means is well
it's that what it stands for is the open
telecom platform a very very unfortunate
name from for what it actually does the
very very first consultancy Giga had
outside of Ericsson and this was back in
two thousand I went in that leg there
was my first code review with a company
who had picked up a long as open source
and I was giving him feed my first
reaction was why aren't you using OTP
and the response was oh we're doing
instant messaging service we're not
doing telecom the history of OTP well
the name OTP comes from stands for
openness and this world this the term of
DP was coined within ericsson ericsson
management in the mid nineties in the
mid-90s the ministry of propaganda
ericsson believe yo that they had to
push out the messenger the message of
openness it was before the Berlin Wall
fell not right after actually right
after but it didn't openness was was
important you'd walk down the corridors
of Ericsson and you'd see posters of
open fields know any man who could
really tell you what open meant but it
was a buzzword and he had to be buzzword
compliance owner therefore it was really
really good today well we talked about
openness referring to the openness
towards other programming language you
would the ability of JSON XML SNMP Java
Sea in on using air as a glue at least
you know that's explanation we try to
try to give telecom well absolutely
nothing to do with telecom yes you
download that and you might get the
diameter stack and you might get the
mega co stack
that these are just standalone separate
applications which in fact shouldn't be
part of the OTP release telecom OTP has
nothing to do with telecom you know what
it is is what we refer to telecom system
is distributed massively concurrent soft
real-time with requirements on scale
availability and I availability and
usually that's what the telecom refers
to a platform indeed the platform is the
true thing which in the OTP is it is a
platform it is middleware to help you
solve the problem now what is the
middleware itself a submitter where
instead of abstract principles and
design rules so you know the references
we've heard about a vote EP so far have
included your release and lame they've
included upgrades they've included
generic servers but it's much more than
that what ltp tells you is how to go in
and design your allen system how you
glue your components together into what
we call a release and then how you then
distribute and manage these releases so
in fact will describe this off to
architecture of your earning system and
you need to follow these principles to
make sure that all of the existing tools
which come as part of a leg OTP
distribution are all compatible with
them very very important is that it will
facilitate the understanding of systems
among groups so if someone who's been
using out OTP your needs to go in and
understand someone else's code they
won't spend time understanding the
generics parts the parts which are
similar from one system to another all
you have to do is focus on the specifics
now and I'm talking about the specifics
thinking of system systems will do very
very different things but they shoot
they need to resolve are always the same
and you know they're the fault tolerance
levels you need to deploy and upgrade
the systems and that's what all of this
middleware which comes as part of a line
actually resolves now
you know one of the questions well which
you were saying bringing up earlier
don't start without to beam absolutely
not don't start with OTP you want to
start with our line and start
programming in ionic it's part of the
learning curve you want to go in and
reinvent the wheel and only once you've
invented the wheel yourself we
understand the value of having something
which is round and spins and it's also
part of the learning curve as well then
I'm going to give you some examples in
my talk now the lot of life is which
come as part of LTP you include your
basic applications or darlin gruntin
system the compiler the standard library
you've got a lot of operation and
maintenance applications which already
built in so you've got the standard nib
the operating system monitor you've got
SNMP you've got other mid standardized
nibs as well you've got interface and
communications towards other programming
languages and environments TCP UDP korba
asn.1 crypto interfaces towards other
graphical applications as well and you
know quite a few tools as well you've
got tools for release now release tools
are you got tools were tested are
compacted early stools in a second but
you've got tools for testing so they
come with a unit and common test a unit
relatively lightweight common test heavy
and it just depends what phase of your
software development you ready unit is
good for unit testing common test is
good for system testing you've got
mocking frameworks you've got
release an upgrade tools some people ask
is it worth the hassle to deal with
release and upgrade tools and it
completely depends on your circumstances
you've got one instance of the system
yeah there it just depends on how big
you are as a company and what level of
maturity you've reached as a company
they've been instances where you know
we've come in and people didn't know
what in your what versions of modules
they were running in in production you
know you don't go in people who deploy
systems these systems will never go down
or fault-tolerant they'll heal
themselves and something does go wrong
and then four years later when something
does really go wrong you know what's in
the live system what's in the code
repository are completely different no
one has a clue and that's really where
or the release handling which comes to
go TP comes into the picture and yes it
is cumbersome what you do is you tend to
out to make a lot of it the truth the
release handling was never completed
because they started working on it and
they came to a certain level and at that
point the person was working the release
and luxury left Erickson and became one
of the cofounders of blue tail the first
telling startup which nortel acquired
back in two thousand and so what happens
there is that you can't the reefs and on
its own is pretty useless well it's not
useless but it's it's bulky and you need
to stop you're using Reba on top of it
and then you start writing your own
layers and if you look at companies
which have a lot of systems they will
have automated everything based on all
of the release principles which come as
part of OTP the letter pools low-level
debugging tools you've got dbg BBG goes
in and allows you to turn on the traces
on local
global functions trigger trace events
and functionality based on your values
in your variables or based on certain
parameters and messages or values and
you're able to do that without trace
compiling your code so just with any
coding production and with very very
little overheads you've got your tools
for profiling concurrency bottlenecks
serves on finding concurrency
bottlenecks for profiling your code
you've got the observer which is a front
end near too many other tools it allows
you to look at the states of the system
internally and so on and so on so there
are quite a few debugging tools people
say well use Emacs well the reason they
say use Emacs is that a lot of these
debugging tools are actually integrated
in Emacs and it's just I think a that's
a cultural thing a lot of ireland dubs
original irvin users and emacs users at
the time he makes was the most flexible
of editors so you know that almost
became the IDE and like developers use
and I think there is a big awareness
today that with more and more people
using air and coming from other
backgrounds a lot needs to be done with
IDs and integrating it so that people
feel comfortable while doing the
transition now
OTP itself is part of the island
distribution and you know at the risk of
repeating myself it's you know the
advantages of using OTP is that you will
use much less code you reuse a lot of
the libraries a lot of the functionality
which is there in your architecture in
your processes and as a result he end up
producing much less code I don't know if
any of you are aware of the study
heriot-watt did where they took some c+
heriot-watt university is a university
in edinburgh and they took some C++
applications which were in production at
Motorola and they rewrote them to
airline you just go in and Google C++
airline Motorola comparison and you'll
find quite a few academic papers which
were written in that area and what we
discovered was depending on how you
counted you got 4 to 20 times less code
than the secret plus plus counterpart
and the 20 times less code is when you
actually included OTP as being part of
their land language and four times as if
you included in your OTP because we've
C++ you didn't have that type of
middleware Motorola had to go in an
implement its own middleware which it
did really well but it was they had to
do it and they couldn't just go in and
reuse something out of the box so it's
you're less bugs it's a the end up
having a much more solid tested code
base and solid code I've actually only
found one bug in behaviors myself and it
was actually visually reading the code
and that's using behaviors now for the
past 15 years and most
I think airline developers are known to
write beer and using OTP will give and
develops much more free time the
original fort behind it was actually the
95 programmer so your programmers in
large companies will go in at work
o'clock in at nine and those are doing
your work is start doing a brilliant job
and at five o clock off and dog off and
move the loans or collective stamps or
go fishing or whatnot and clear their
minds and then this is unlike Google
programmers who you know once they've
clocked off work and they're walking
home you're thinking about this complex
algorithm you think you have actually
covered all of their possible error
cases what happens you know if this
system goes wrong how will that river
yet revert into the bay into the system
itself and you know what did what OTP
tries to do in it through its behaviour
is try to hide a lot of that complexity
now ltd behaviors per se see them as a
formalization of design patterns now
think of an airline process Ireland
processes you know what's of doing very
different things they'll share a similar
structure you have to start a process a
person will receive message it will
handle the messages it will terminate or
possibly even crash will send replies
and so even if they perform different
tasks they will perform them solving a
certain type of pattern or a certain
type of problem and what they've done is
they've looked at the most common
patterns in OTP and you created a
framework containing the generic code
for each of these patterns and so what
you're getting is actually a library
module which is your generic behavior
module
and you've got your process your process
actually runs in a generic behavior
module loop and what the developers need
to do is write their own specific
callback module and it's in the callback
module where all the specifics of what's
being done or pretending so if you think
of a generic behavior module you know
that's where you'll start your system
that's where you start your process
that's where you'll stop it that's where
you'll handle termination and that's
where you store your state that's where
your you trigger off your stuff to
operate that's when you send messages
and receive them in the specific
Corvette what does specific or bag
module knows nothing about the generic
behavior module and all it does is it
exports a set of callback functions
which handle the very specific code of
what you're doing so in the case of sum
up you'd handle you'd have a call to
handle a payment a call where you
reserve the firm the call for accredited
so on and each one would be as a call
that function which would win them
return everything back return control to
the behavior module itself and the
behaviors they found include things such
as generic servers so the whole
client-server behavior I think that's
the behavior of all behaviors although
the blog all other behaviors are
actually a variant of the generic server
there are finite state machines so
generic fsms if you think of finite
state machines you know what is generic
with final state machines includes
you're starting the fsm stopping it
receiving the events and state
transitions you know what is specific
are the events themselves and the states
you're actually in and what your next
state is once you've you've actually
done whatever it is you need to do now
we've got event handlers event handlers
are there to handle different types of
events so you receive a request you go
in and you handle it you do something
with it and once you're done you send
back a value and yeah and you can do
that and you can do for the same event
you have different handlers so assume
you receive an SMS and for that SMS what
you want to do is you want to love it
you want to parse it and you figure out
who someone is voting for in your
favorite TV program and you want to
forward it on and store it in a database
this would be three different handlers
the event would be the SMS coming in and
then these free and this would be called
in successful and then further you've
got a supervisor and I'll give you an
example of a supervisor sir later on but
all supervisors do is go in and monitor
their processes and is a very very
simple error handling mechanisms in
Ireland which I'll show you in a minute
and supervisors will go in and the
monitor processes that's all they do and
when the process terminates they're
going to make a decision over how to
handle that termination so it could be
you know they could decide to terminate
all the children and restart them they
could decide to go in and restart a
particular child or not do anything at
all and in turn you know they could
escalate the problem so they realize
that you have to have any restarted a
child many times that they're actually
not resolving the problem by restarting
it so they could decide to terminate
themselves and so supervisors and then
finally we've got applications an
application just a way of encapsulating
everything so let me give you some
examples of what your typical maybe 95
programmer might not resolve a think of
from day one so we've got two processes
we've got a client and we've got a
server now if a client sends a message
to the server and it's a former it's a
tube of the former request so this is
just a tad the posts identifier of the
tribes itself and the message this
message is received by the server the
server then goes in handles that message
could be a payment and that sends back a
reply to the client so it's in back a
tuple with the tag reply and the reply
itself so the reply could be a payment
accepted or payment rejected and the
cloud receives the message and the oak I
saw if your payment was rejected or
accepted but there's a slight problem
with this code can anyone spotted
what happens if we've got another server
and this other server because in a
central message of the format reply
common reply to a message of the exact
same format to that client it's not
necessarily malicious could just be a
bug in your system which happens 173
years because of a race condition the
client receives the message from server
to believing it's a response from this
server and starts giving the wrong reply
back to the client I know we were
working on a system the bug wasn't ours
but it was an instant messaging system
and all of a sudden in the chat boards
external chat ports your Scottish you
started seeing messages actually in
German saying hey we received someone
else's someone else's instant message
you know who's receiving mine is the
system safe and yes if something similar
was happening right there where as a
result of race condition people getting
each other's messages now this was not a
problem hardcore Dorian airlink was
actually in the load balancers but it
did take quite a while to reproduce it
and trace it so obviously what we need
to do here is you know whenever a client
sends a message to a server we need to
create a unique identifier and that's
what we're doing right here this is a
built-in function called may crack and
returns a unique identifier known only
within the scope of this function we
send that unique identifier to the
server the server receives it at hands
with its message and it handles the
message and sends back the response and
the response we send Mac includes that
reference this reference is already
bound so we will only receive this
message if the second element in that
message is the reference we sent to the
original client so you know that will
result and ref is unique dish so I think
it will take a couple
years before the same reference is
reused so it's you know this will
guarantee you that the reply you're
actually receiving is the reply you're
expecting and not another process
sending your message everyone following
me
so these are one of this is one of the
many things of the ptex care of behind
the scenes another one is the following
well think about pide sending a message
to pitt be and piddle now starts waiting
for a response that pd crashes p days
waiting and waiting and waiting and your
PO Gustav is there with us demoing his
his payment system and its demoing it
and it's coming through now it's coming
through now nothing happens you know
this is another very typical problem
your programmers don't think about and
what we want to know is that something
has gone wrong with the server and if
something has gone wrong with server we
are your transacting a payment we want
to make sure that when we retry we say
hey we first check if that payments gone
through or not and if it hasn't gone
through only then do we go in and retry
it and so what does LTP hide behind the
scenes what do we get into generic
behavior market well we've got sorry
apologies
so what we do here now is we start
monitoring the remote process oh sorry
okay what's happening
the supervisors restarting this right
so what we start doing now is we start
monitoring the remote process a monitor
is very similar to a link and what you
do is you just start monitoring the
process if something happens to that
process we get a Down message we get
like a unique reference so all of us so
we don't need to make make your f
anymore we just use this unique
reference in our message and expect the
back in the reply and if we don't get a
reply and something happens with the
remote node the message goes that we
receive a Down message telling us that
the process terminated for this
particular reason and we can go back and
say error you know there is no process
error no clock on the remote part side
so hopefully I don't have an intelligent
client that sum up which realizes
something has gone wrong with the server
let me wait a little while random the
amount of time and then retry in your
first check how the transaction went
maybe the transaction did go through and
then the server crash before sending
backwards ponce maybe the transaction
didn't go through at all so you go in
you check and you execute a new payment
and so what happens here is we send back
a message we get a brutal I know
all of a sudden we get a Down message
have you seen what's happened here have
you seen this the sequence this is
another catch which you can get so you
going you send a message no it's not it
again so you go in you send the message
okay
and your process crashes we get a Down
message fine you go and you send a
message so we're monitoring process
being when you're monitoring process be
you get back a response but before
payday is able to retrieve the response
the process crashes it be crashes and
also sends us a down message so this is
before we actually go in and start be
monitoring the process so what we need
to do an hour in a reply here is where
we receive a reply we say we want to D
monitor the process but to make sure
that the down message doesn't isn't kind
of glove with garbage collected isn't
stuck in our mailbox and never read it
it won't ever be ready because we're
pattern-matching a unique reference so
to ensure we don't get any memory leaks
when we go in and be monitored or
meiosis after the call we also need to
go in and flush and the down message you
might have received after after the call
so these are just some of the tricky
things which can happen with concurrency
behind the scenes and OTP will takes
care of all of this for you the other
thing that takes care of includes
bottlenecks it will include certain to
certain extent race conditions and the
dedlock's as well
now
something you which your people who tell
you about our line is to fail safe and
fail early and that usually gives
goosebumps to see programmers saying I
can't make my code crash but what you
want to do is you want to go in and
isolate your error right and you can do
that in elling because you've isolated
your error in a process and once again
sir think of the 925 programmers they'll
go in they'll start they need to go in
and they need to convert today so the
atoms Monday through Sunday to a number
to an integer to the relevant day of the
week now a defensive programmer will go
in and say guess what if you're passing
the anatom I don't want to crash if
you're passing is something other than a
day of the week I'll return error
unknown day and this is what we refer to
as aliens defensive programming you
don't want to do that you actually want
to make your code terminate now in a
case statement if you're passing in
convert you know any other day and it
doesn't match any of these your process
will terminate and that's really what
you want to do you want to isolate error
and make that process terminate not try
to handle it if you're actually going in
and handling it you know for every time
you call convert day you would actually
have to check are we returning error
unknown day and if you are what are we
going to do about it the date in the
system is corrupt and I've actually seen
so many more bugs be inserted in systems
because of defensive programming then
the issues directly trying to resolve it
so what you're doing is you isolate
error you make your process scratch
attritional be using the word crash
because smoke
a few embedded program is tickling
goosebump but make your process
terminate I think is a politically
correct word there is no shared memory
and what you do if your post is critical
is your letter supervisor restart it and
when the supervisor restarted you're
going to create the state so for those
of you who have got a little bit in
there like you'll know that you've got
processes which are all linked together
and if a process terminates an exit
signal will be sent to the poster
strapping exits we denote processes
trapping exits with two rings so this
processor will know that process a has
terminated and it can then go in and
decide what to do with that process soap
it being usually goes in and well we
start deciding if it's an important
server if it's an important behavior it
will restart it if it's an SMS going for
the system or a payment it will not risk
most probably not restart it because
it's probably going to be a bug which
one will be persistent and you end up
getting a cyclic bug so what the done in
a line is in this case what we're
starting in and what we've done in
adding is we've taken a process dropping
exits we've added a bit more logic
behind the scenes we're adding many more
generic kind of error cases which can
handle and we group that we create use
this process called the supervisor to
create what we call the supervision tree
and a supervision tree or supervisor
will go in and monitor processes or
behaviors and other supervisors you're
giving you a complete tree itself what
usually do is you tend to group
logically connected processes under a
particular subset of the supervision
tree and on top of the supervisor we've
got the workers and what we do is we
package all of this into what we call
an application and an application is
your LEGO brick in an Alec system it is
your building block and it's a logical
unit processes and models group together
which will perform a certain task and
you'll start them as a whole you'll stop
them as a whole and usually well it
contain libraries but also supervision
trees and you're adding system is
nothing other than a group of loosely
coupled applications so you know this
example we've got the Anna Grantham
system the colonel the system
architecture support library needs a
database and so on and all of these
together with your open source
applications for logging and for metrics
together with me or whatever it is you
sit you're doing could be or your card
payment systems so you know complete
Alex system is built as a release so
what do you like and not it's very hard
to get away from it so I mean
completions is wrong yes use airline but
don't just use airline use OTP you know
once you've used a like once you've done
these mistakes you'll go in and you
start learning actually the benefits of
what OTP as a whole framework and as a
middleware actually brings to you it's a
slightly steeper learning curve but you
know the documentation for it has begun
much much better compared to when I
first well got told that you know we're
not doing telecom systems there are
books you know a woman recommend OTP in
action
there is a book club a lot of it is
including one you some airline for great
good and I'm actually writing a book now
together with rubber birding and Simon
Thompson also on OTP itself it will be
ready but it will be ready but I'm yep
any questions or any faults
yes what's the difference between
Wayne's morning so a loop is
bi-directional so if you define them to
you if I terminate you select single you
terminate i received axial a monitor if
I monitor you you don't know anything
about me if I terminate and in effect
you know a link is in fact two monitors
and it's I'd say design flow in the
language when you're the inventor to do
believe links were enough but in fact it
should have just had monitors yes
program yes i noticed that i love
defensive forget afterwards for user
facing code because i came up to tell
them what when absolutely absolutely
absolutely absolutely so what I'm saying
when I say don't be defensive trust the
data which is within your system but do
not trust a they're coming from the
outside you need to make sure that you
know any data coming into your system
works and is correct so use your data
absolutely go in your positive check it
you know make sure it's exactly what you
want to provide the best possible
feedback if it is correct and allow it
into your attic system but once it is in
your system trust it yeah
okay lunch I think thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>