<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Origins of Free - Adam Warski (Lambda Days 2017) | Coder Coacher - Coaching Coders</title><meta content="The Origins of Free - Adam Warski (Lambda Days 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Origins of Free - Adam Warski (Lambda Days 2017)</b></h2><h5 class="post__date">2017-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KdqvwM-U1qI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for coming my name is Adam Barsky
and there's a recent trend I think at
least I think so that Ramona's are
getting quite popular at least in the
scholar land is that they have been
popular in Haskell for quite a while
and it wasn't always immediately clear
for me what what this free means when it
when it's applied to mana so I will try
to explain today hopefully a what's the
intuition behind free and how can we
understand free so it's going to be a
bit of an experimental talk for me
because it's going to be mainly math so
we are continuing the theme of the
previous talk there will be a bit of
code so and as always if you have any
questions just let me know if something
is not clear um okay so our overall plan
first I would try to sell you some
motivation on of why should we consider
using free Mona's in the first place
that may not be obvious it's not a
needed one it's not needed to understand
Pomona's to understand the talk but
being motivated is usually good anyway
and then I would like to introduce five
basic concepts from from a universal
algebra from Mass that will get us to
two free moments and there are quite
simple concepts the usually
formalizations of what we do every day
so even if they have big scary sounding
names don't worry and don't don't look
for deeper meaning things are really
simpler than they sound and that just
formalizations so after we get to free
algebra and pramanas we also take a
short look of how few Moniz implemented
in practice in Haskell and and it's
colossal so what I would like to show
overall is that free is a general
construction which can apply to many
different structures not only not only
moments and okay so why why why would we
want to bother with free in the first
place and so that's I try to state the
problem that we're trying to solve
when using for Mona's
maybe there's another approach to it as
well but at least how I understand these
things is that we want to be able to
define programs in a composable way
composable meaning that we wants to
build bigger programs from smaller
programs and we want to use some
business oriented language
so some high-level instructions without
a giving specific machine interpretation
of what these instructions mean so we
want to define a program in a high-level
language and we all want to later
specify of what these high-level
instructions actually do and how they
translate to the specific operations on
the database and so on so once we have
this program defined we want to be able
to run it in context okay so as a very
short example again I don't want to give
this talk to be an introduction to fume
owners because it would be a whole talk
in itself as a very short example of
what every model can look like in the
code snippet below we see a function
which returns a data structure called
free the first type parameter of the
data structure describes the possible
operations that we can use when writing
our program and the second type
parameter credit limit is the type of
the result of the whole program okay and
here we are the our program will be
wrapped we will be represented as data
which will allow us to manipulate it
later and so the instruction set here at
the bank ops and to issue a credit card
to a user we are using its operations
which are looking up user data fetching
the user's credit history calculating
the limit and so on
okay so these are our basic operations
and we are combining them using the
Monad syntax and as a result we are
getting a data structure free so
hopefully will understand why free is
called free after the end after this
talk finishes and so what we get is we
get a description of how our problems
should be solved okay
without any specific interpretation so
there's no interpretation of what
looking up user data actually means okay
it's just an instruction look up user
data it's just a piece of data it
doesn't mean anything yet and then we
can write interpreters for follow
instructions a which will actually run
some real operations of example here we
have a production interpreter which
interprets our operations in terms of
the future right so for example here
looking after the user data would
actually mean going to the database and
fetching something from the database
which is a side-effect knee operation so
we wrap it in a future okay we can also
create another interpreter for example a
test interpreter what we don't we want
to only test the logic we don't want to
test the integration with the database
so here we just interpret each operation
as a strict value without wrapping it in
anything special and once we have an
interpreter and once we have our a data
structure the free the free Monat which
wraps the our program description we can
actually interpret it using an
interpreter and get the result okay so
that's like a very brief introduction to
few moniz there's a lot of learning
material on the net if you have if maybe
this if you want went familiar maybe
this got you interested and how this
actually works though the Monad syntax
and so on so it's a lot of times much we
go a lot of learning material on the
internet which explains it in detail and
so what I would like to focus on here is
what is the meaning of the world free
and where it comes from
okay so before we start doing that and
just a short introduction who I am so
that you know who's talking to you
so I'm a software engineer and the
co-founder of software Mir we are a
small company based in Poland we do
custom software for various types of of
clients startups
banks we do all kinds of messaging
systems and so on
I heard we are a company of nerds I'm
good anybody think that just look at me
and so I domain this column and I do
some open source projects such as quick
lines marquai and so on and and what
actually inspired me to do this talk is
a long time ago in my previous life I
was a student of category theory so
that's that's why I learned these things
and I hope I will be able to to pass
some of these some of this today okay so
let's start with actually defining what
is an algebra okay so if we go to
Wikipedia the ultimate source of all
knowledge you can see that algebra is
the study of mathematical symbols and
the rows of for manipulating these
symbols okay so we have a set of symbols
that we can arbitrarily choose and then
we define some rules of how they can be
manipulated and in fact we have we seen
a lot oh we see a lot of algebra in our
everyday life maybe not every day but
almost everyday life so some simple
examples like the lunar equation right
we have some symbols and YX aim a and B
plus and there are some specific rules
on how this can be manipulated right
it's an algebra and can get any more
complex we can invent our own symbols
and so on and going further we can even
go quite crazy and define some symbols
like this right this is still an algebra
we are quite good and well it's
manipulating these specific kinds of
symbols right we know the rules quite
well if we if we if we forget the rules
the IDE usually corrects us and so these
are all examples of of algebras but now
we will go a level high and we'll try to
abstract from the actual specific
symbols used and that's where universal
algebra comes in and that will be the
first the first thing I would like to
introduce the first concept it would be
often algebra
a signature okay in universal algebra
and what you do is you don't study
specific algebras and specific sets of
symbols you just say that you have some
symbols and you see what you can do with
this notion okay so a universal algebra
studies a more general studies any
algebraic structures rather than
specific ones so to define an algebraic
signature contains of of two things it's
usually denoted as a large letter Sigma
and contain in it consists of a set of
type names okay these are just labels
just names like strings nothing special
a set of labels which are a set of type
names here we will deal with a multi
type and universal algebra because we
all like static typing and then there's
a family of sets of operation names okay
the operation names are indexed by a
series of types names and an one
additional type name okay so the first
the series of type names are the types
of parameters of an operation and the
second one is the return type okay so in
an algebraic signature we have a set of
type names and some operations so as an
example which we will use later on as
well we can have for example two type
names int and string again these are
just labels they don't really mean
anything
you kind of can guess what they might
mean right because in ten string or
something that we use every day but here
they are just labels okay
two labels and then we have some
operations okay we have a one operation
without any parameters and a return type
int which makes it a constant which is 0
again it's just the name no
interpretation okay it's just a name and
then we have an operation which takes an
int and returns something called a
successor and we have another operation
with which takes two ends and returns an
int called plus and so on
okay so let's that's an example of a
signature right we have a set of type
names and a family of sets of operation
names and we can build expressions using
these using this signature okay we can
also define like a signature for Scala
of a Haskell right and good programs as
well
now the second concept would be an
algebra okay we have an algebraic
signature which specifies the symbols
that we can use our language right and
now we want to actually have a specific
interpretation okay
and then algebra is a specific
interpretation of M of a signature so an
algebra consists of two things again
so for each type it assigns a set of
values and for each operation it assigns
a function between the appropriate sets
so again following our example that's
the same signature as before now we can
define an example algebra a okay there's
a lot of possibilities of how we can
define this algebra there's only one of
them so when our algebra a the the
interpretation of type int will be
natural numbers and the interpretation
of type string will be a the set of all
possible strings okay that's one way we
can actually interpret this signature so
we have an interpretation of the types
we also need an interpretation of the
operations okay so here we say that the
successor in algebra in Naija bra a so
it's the successor with the a suffix is
a function which adds one to its
argument okay we can define it like that
why not and similar we define a plus in
algebra and so on okay so that's the the
that was the second out of five concept
that we need introduced to get two free
algebras now we will define a special
algebra called the term algebra so we
will define this algebra for any
signature okay so this algebra we
thought it would be quite boring so it
will consist the interpretation of each
type and will consist of all a well
formed expressions of this type that can
be built okay so the elements in this
algebra we
we would be strength without as
expressions out of out of the operations
that we have okay so to be an algebra
built out of pure syntax again no and no
no special that would be no like special
interpretations we will just built an
algebra out of pure a out of pure syntax
can think of it as an algebra containing
valid code using our signature or well
from strings and so on so as an example
we have our example signature as before
and now we define the term algebra T
Sigma ok Sigma is references the
signature and T is like term algebra
okay so first we have to define the
interpolation of the types okay so the
interpretation of type int is all
expressions that we can build using our
symbols that have type in okay so it's
zero obviously it's also success or
applied to zero right
and successful successor is zero and so
on and similarly with type string right
it's all expressions that that have type
string now we also need to provide an
interpretation of the operations okay so
the operations again at are quite boring
so the interpretation of the successor
operation in the term in our term
algebra we just built a bigger
expression a bigger string okay so on
the Left where you have the success of
the Sigma it's an operator that's a
function and operation interpreted in
the term algebra and on the right you
have a term right so it takes a term and
it returns a bigger term which is the
successor applied to the older
okay so as our interpretation of the
operations we just build out bigger
expressions okay so it's an algebra
built out of all valid expressions built
our using both using our our language
and another way to think about the term
algebra is that it it is defined
inductively okay so as the interaction
base we take all constants that are
available in our signature so here it
will be only only zero
and then on each step we apply any
functions that we actually can apply to
the terms that we currently have so we
start with a with a with a zero so we
can only create four terms out of out of
a single zero in the next step right we
can add two zeros we can create a
successor of zero and we can convert a
zero to a string in the next step we get
more terms and more terms and more terms
and if we sum it all up
we'll get the term algebra okay so
that's the that was the third we have
the algebraic signature algebra and the
term algebra we are halfway there
and so now a homomorphism so now let's
say we have a single fixed signature and
we have two algebras and two different
interpretations of the same signature
okay and we wants to be able to somehow
relate these two these two algebras we
want to create like a function between
the algebras and that that kind of
function is called the homomorphism okay
so again it's nothing special it's just
a name for function between algebras and
the function between algebras it's kind
of what you would expect
so for each type meet the function
between the type interpretations okay
but these functions cannot be arbitrary
they need to be well behaved and I will
show by example what what this means so
again we have the same the same
signature let's say we have two two
algebras two interpretations of our
signature okay now we say that the
function is a homomorphism if there are
two functions so there's a function
between the interpretation of ends and
there's a function between the
interpretation of strings such that the
operations a are preserved so that they
the the functions are well behaved with
respect to to these operations what this
means for example if we take the
successor one right if we map the if we
map the successor of a of any value in
algebra a it must be the same if we take
the successor in algebra B to the
mapping of
of X okay it means that we can pull the
operations outside of our homomorphism
of other function okay it's kind of if
you if you try to sing it a bit
it kind of is what you would really
expect and from such a function but so
that's that's the definition of a
homomorphism okay and now the final
thing that we need to introduce is the
notion of an initial algebra so that's
almost it's almost the definition of her
free Hydra okay so now it will be a
definition it may be a bit hard to
digest but don't worry it's just a
definition so we will say that an
algebra I is initial so it will be a
special algebra a very special algebra
it would be initial and then in fact the
you can hear about initial objects for
example in in when were reading about
Haskell quite a lot so it's the same
initial I'd it's the same initial 'ti so
we will say that our special algebra I
is initial then if we take any other any
other algebra a and that there will be
exactly one homomorphism between i and a
okay but that's quite a strong there's
quite a strong requirement so for any
other algebra a there must exist a
homomorphism between i and they and it
must be unique okay
and now there's a theorem that actually
our term algebra is initial okay so why
why is that of course it's the proof is
an easy exercise to do at home but i
will do a proof by example which i hope
will convince you and so we will take
our example signature and we will take
our example algebra hey if you if you
remember in that algebra we interpreted
in as natural numbers and strings as all
possible strings right so it's like
quite a natural interpretation of this
algebra so now to to prove that T Sigma
is initial we have to convey have to
construct homomorphism between between
the terminal Gibran and our example
algebra a
so we need to construct a homomorphism F
okay so now how can we construct such a
homomorphism so most of the construction
follows from the fact that it needs to
be a homomorphism and so it needs to
preserve operations if it needs to
preserve operations then for example it
needs to preserve the mapping of the
constants right so the zero interpreted
in in the term algebra so the term zero
must be mapped to to the interpretation
of zero in algebra a similarly from the
fact that this is a homomorphism the
mapping of a successor of the term of
the success of any term must map to the
successor of in algebra a of the mapping
of that term okay and so on so because
the term algebra is defined inductively
from only from the symbols that we have
at our disposal you can see that there's
only one way to actually build that
homem orphans between the term algebra
and algebra Hey
okay and that from amorphous in fact is
an evaluation of that expression in
algebra a okay so we take any term so we
take any valid string built out of our
language okay
and we interpret it in algebra hey hey
and that's our homomorphism okay and we
can always do that for any algebra a we
can take any valid expression without
using our signature and interpret it run
it in our algebra a right okay so this
our tournament bra has to two important
properties which carry over to free
algebras later so first of all an
initial algebra term algebra that
contains non junk so it contains only
the elements which in algebra for that
signature can contain okay so it doesn't
contain any extra elements right it only
contains because it contains expression
that can be built from our language it
doesn't contain any extra elements right
so there's no joint and it doesn't
confuse if two terms might in C
we have different values in an
interpretation there will be this
distinct terms okay so it show a counter
example a I will show that our example
algebra a is definitely not initial okay
so if you remember when our algebra a we
interpreted in as natural numbers and
strings as the set of all strings so it
contains the junk because if for example
string a the string a is not reachable
by any expression right it also contains
confusion because in algebra a 0 plus
successor of 0 is the same as success of
0 plus 0 but in general it doesn't have
to be we can build an interpretation of
them of our signature we can build an
algebra such that these two terms have
different values ok so finally we reach
the free algebra and but to do that we
need to add a small twist to our
definition now we will define terms with
variables ok so far we have we had just
terms built out of out of our language
construct out of the signature and now
we will take a set of variables each
variable will have a type okay and we
will build expressions using our
language with these variables added so
for example if we have our example
signature again we define the set of
variables X so we have three variables
of type int ijk we have two variables of
type string s1 and s2 okay as an example
and using using these variables we can
build expressions okay of course well
form type the types must match for
example we can build an expression
successor of I plus J plus successor of
success of 0 or something like that
okay so T Sigma or from T Sigma X will
denote our term algebra built using a
given set of of of variables
okay now that would be a very hard
definition but we will make it simpler
later okay so now we will say that again
especial a sigma-algebra I is free over
X okay when you say this something is
free the parameter of the the X
parameter make is is important and here
it will be the set of variables okay so
we say that I was special algebra I is 3
over X when if we take any other algebra
a again and if we have a mapping of the
variable so if we have an interpretation
of the variables this extends uniquely
to homomorphism between the the algebras
ok so that may may sound complicated we
will see what what it means in practice
in a second ok and and of course you
probably expected it that for any
variables at X our term algebra built
with these variables is actually free
okay and that it's the same free as in
free Monat and we will see the
connection in a in a second so what does
feel what this definition really means
is that an interpreter and if we have if
we have a target algebra in which we
wants to interpret our expression write
an interpretation of the variables
determines the interpretation of the
whole term ok so the interpretation of
the variables is the function f between
our variables and our algebra and the
inter patient of the whole term is our
homomorphism the f sharp okay so as an
example we take this same signal as
before in the same algebra as before and
and we define an interpretation of our
variables so we say that and in the
interpretation of I is then in the
interpretation of js5 and an
interpretation of s2 is days so now we
can interpret any expression built out
of our language using these variables
right so this F sharp is just an
evaluation of of this expression in
algebra
okay and it's quite straightforward
right is more less what you would expect
right so if you take the successor of J
it will be in algebra a it would be six
and then you advance with seven and so
on okay and okay so now what what does
it really mean that this algebra this
term algebra is free okay
so it means two things first of all it's
if we take it first of all it doesn't
provide any interpretation in itself
okay
the elements it contains are free to be
interpreted in any way okay that's
that's one aspect of the freeness okay
there are no constraints you can
interpret the elements in any way okay
it doesn't do any interpretation itself
and secondly it's free of any additional
structure it contains only the structure
that it must contain because the our
signature told it so right so it's free
a few of interpretation and three of
additional structure and that's that's
two aspects of freeness of why it's
actually called free as I said it's a
free em every algebra contains contains
no junk so there are no extra elements
and doesn't confuse any two elements if
it doesn't have to
okay so does to just to know do a short
summing up of what we said so far so we
introduced an algebraic signature which
consisted of a set of type names and the
family of operation names then we said
that an interpretation of a signature is
called an algebra then we have defined a
term algebra which are valid expressions
built out of a but using this signature
right it is kind of what we do every day
right we have a signature our our
language Scala Java whatever and we
build valid expressions using this
language hopefully void expressions
using this language right and then we
interpret so our interpreter is our
machine which actually interprets our
our compiler which actually interprets
our our our terms into something more
meaningful to the computer then then a
text file okay and then we said that the
term algebra is free right it is it is
free if any if an interpretation of the
variables that it contains and the term
is an interpretation of the whole term
okay and it's a sorry it's a general
construction which you can apply to any
algebraic structure to an algebraic
signature okay and you can get a free
algebra and the term Allah is free
meaning that it is free of it doesn't
interpret anything in itself it's free
of additional operation in
interpretation and free of additional
structure okay so now let's get to Manas
why would we why would we look at Mona's
in the first place so let's let's put
three aside for a second so now
following our original motivation of why
we want to look at at the few monad we
said that he wants to model programs as
data okay so in any program so in if we
want any way we approach the task any
way we approach the task of modeling
program as data we will a sequential
program for now
we will we always need to operations an
operation to return a value an operation
to compute what to do next bathing on
the previous value okay
so these two operations would be always
there whatever your other basic
operations are so people decide is know
if if these operations are always there
why don't we extract these common parts
right we all like to do we all like to
extract some on parts and abstract them
right so let's extract these common
parts and give them a name right and
they couldn't think of a better name so
they came up with with Monat and that's
what we are stuck with now so so a Monat
is just read these two operation these
two common operations that are extracted
and so that we can model sequential
programs right and now also some sanity
laws in Moniz right so that they that
they better so that they behave well so
they're like in addition to the to the
basic unit structure okay so now now
that we know we wants to use a monad
more or less to model our program it's
data because you know people decided
that it's a good
abstract way of modeling programs of
modeling sequential programs how would
we approach the free moment so the fimo
not now that's not a direct construction
it gets a bit more complicated but a
very rough sketch would be that in our
signature we have pure and flat map
right we have two operations and the
variables would be our basic operations
our DSL that will be our variables so if
we define the signature and variables in
such way the Fremen art will be more or
less all the terms right legs touch data
structures terms made out of pure flat
map and our variables okay and that's
more or less what the free monad free
more than is of course we have a day we
have to add and we have to add so I said
that in a free algebra there is no
confusion here we need to add some
confusion to satisfy the Monad laws okay
so the free monad still has to be
amounted so it needs
so it it needs to introduce some
confusion but only as much as is needed
right so for example here is one Mon at
law right that flat mapping a pure value
with the function is the same as as
applying in the function to that value
so it will need to actually confuse
these two these two terms okay so you
can actually do this construction
III yes and and in an important thing
that follows from our definition of what
free means is that if we provide an
interpretation if we pick a target moniz
right before we have we picked a target
algebra now we pick a target Mona okay
and if we provide an interpretation of
the variables in that Mona okay that
extends uniquely an interpretation of
the whole program okay that's exactly
the same as with free algebras and to
get a bit more precise of how you would
actually construct the few Mona in such
a direct way okay so we will need to
tweak a bit our construction that we did
before so before we were dealing with
algebra so our world was where all
algebras right here we will have to
switch our world to all Scala or Haskell
or whatever Mona's okay in switching
this world is doing these calculations
in a different category and also we have
to switch the world of variables before
we only used sets and now we have to use
valid scalar terms right so for example
two and define the DSL right that's
that's usually a some data structure so
that's a valid Scala skeleton
okay but otherwise this the construction
of the free monad goes more or less
similarly and now if you look in if you
look at at how free is defined in in in
cats or in Scala Z you will see that it
is a data structure okay so one
important thing about the Primo net is
it is that it's just a data structure
it's nothing special just a data
structure okay
and so there's a datatype free as I said
the first type parameter is the type of
the operations the second type parameter
is the return type of the whole program
and so it contains three constructs okay
so we have pure and flatmap which are a
direct traffic ation of the current
platform mana topper ations right so
that's you can see that if we build a
data structure using three we actually
end up building a big term containing
pure and flat flop right so our our
signature operations say but those
contain suspend so suspend is simply an
embedding of our variable of our DSL
into the free data type okay so in this
definition we have verification of two
operations of the two signature
operations right as terms and we have an
embedding for variables which is a value
from our DSL so that's more or less what
what we have is more as follows the
construction that that we did and now if
we if you go to actually Haskell and
take a look at the Haskell definition it
is a bit different
okay so I've translated it for into
Scala as well so in the Haskell
definition you have an additional
requirement that F must be a functor the
the type the the first time the first
type parameter must be a factor and you
only have to a construct pure and join
okay well pure is quite clear about what
what's what's the join and well it turns
out that these are likely equivalent so
it's the same free monad in Haskell and
in Scala Z and cut and you can translate
between the two forms okay what what is
the difference is that if you look at
this representation because of Menard
laws you can have the same expression
represented by two terms right so an
equivalent expression represented in two
ways
alright for example we have a series of
flood maps you can have a left biased a
series of flat cop so you can
using the Monad laws the equations can
all you can put all the flatworms on the
right right or you can apply the
simplification flood mapping a pure
value and so on so for some expressions
there are two two ways you can build a
term to represent that expression and
this form that you can find in Haskell
is it's kind of normalized so each each
expression has only one one form and
when you actually do the translation if
you have a free expression written and
written in that style if you do the
translation to the to the Haskell style
that same you will see that you actually
normalize the your expression so that it
is a it has only one
one form okay an important note is that
the F over here so the type of the DSL
is different than the F over here okay
the F in the in the in this
representation has to be a functor right
and it doesn't have to be in the other
one so what we do is we can actually
make any any data containing a functor
by creating a per data container plus
mapping function okay that's a quite a
simple operation right and that again
actually is a free functor built out of
the our basic data container which
doesn't have to be a function in the
general it's called the kona da again a
fence name which does means a functor
with the mapping data container with a
mapping function right so in java I
would have probably a container with
mapping or some like that and in Haskell
we have a Coronado it's it's a name as
any other okay so to sum up so what we
did is we did have direct construction
of free ideas using a basing on any an
algebraic signature and we kind of a bit
transpose that to constructing every
monad and the Fremen at the
that we constructed is again why why why
is it free so the expressions that if if
you have a data type which which
represents a program right that program
can it can be interpreted in any way
given given the interpretation of the
variables right so we have you have free
to interpret it in any way and there's
no no no additional structure okay
so that's that small as what what we
went through if you would like to read
some more about it there's a book from
which I learned the universal algebra
and category category theory it's by one
of my advisers I guess it's called so
it's a very nice book if it contains a
lot of exercises if you'd like to to
find out more about category theory for
example and of course the Internet is an
endless source of reading material
YouTube videos and so on ok so that's
all I had thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>