<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Functional programming guerilla in the land of Rust - Tomasz Barański (Lambda Days 2017) | Coder Coacher - Coaching Coders</title><meta content="Functional programming guerilla in the land of Rust - Tomasz Barański (Lambda Days 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Functional programming guerilla in the land of Rust - Tomasz Barański (Lambda Days 2017)</b></h2><h5 class="post__date">2017-03-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/y9ONOUm62_A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">the two things that function have to do
in a functional programming language -
and I love those nasty tricks with being
first class and pure how do I search is
that a first class function is a
function that could be created on demand
summon in code we started in a variable
passed as an argument to function a
return from from a function so can you
read this code is it big enough but in
the back yeah okay I can tie you closer
so this is very very simple function it
just takes it up an argument called X
and that's 5 - it actually close another
function but for the sake of this talk
this will do Andi you can I can sew it
in in a variable called at 5 rust
doesn't makes me type all type
annotations unintended but these are
strong typed closes I cannot take
another closer and I'll pass it to folks
to a function that requires a closure a
function with two arguments the only one
and probably this this code compares to
integer all will good close to a
function or closure that requires an
integer argument naturally I can for it
to be a little bit integer by requiring
it to return it type inference in Russ
is on par with what Haskell predators
can do it can reduce the types and fill
all those two NASA details so that I
don't have to worry about it so yeah I
got a to the function and so little
project or great so I can write a
function that returns a function this
boxing 4 also known as is tells the
compiler basically to allocate is on
heat not on stock which matters in rust
and and this the physical does basically
the same that in lining the culture is
in the previous slide it creates these
other functions create another function
and it turns it on it so can be
referenced somewhere else and actually
last compiler is smart enough to
understand that this is function which
will decode somewhere and I totally told
code it's on on the heap but depending
on the context I use it in it probably
optimized out the the allocation so this
will cost me nothing in terms of
performance and I'm sure there's
yesterday that is very little in it like
very little nice if the syntax in
nightly rest that just don't bother with
box things we will do it for you nicely
Russ Russ tools channels stable which is
well label it's nicely widget for
experiments and things that need to
sometimes to be tested on different
contexts we talked before they become
stable so yeah I got the function that
returns a function socket can have a
function that takes a function as a as
an argument the absolute applied to a
function is basic takes an integer and a
function that requires an integer and
applies one to another and you can take
my other function output of the other
function I'd find previously I would
take ad hoc closer if I defined just
what I needed
so yeah functions that can be created in
demand check starting the viable check
passes arguments check return some
functions check cool how about purity
Haskell is a great example of of
languages few functions and thrusts
cannot compare to that but closes is
said that they have functions are pure
the things they are operating on
immutable data and have no suggests it's
not true in closer but in general they
do not do nasty things to the data don't
change the values when you're not
looking and I can do something that's
simple but it's actually treating you
can define pure function like that in C
as well so late something this something
else a struct is something like an
object in rust so you have a piece of
memory that consists of two integers
integers yes and have something that
operates on it and messages were to
define methods in last and looking at
the type signature of this function it
is pretty much get what it's supposed to
do it takes self and the number another
number and retains another point its
call to move by so you can still do not
guess what will be inside the function
but look at this one it's almost the
same but take save as a mute or multiple
reference that means this function is
supposed to change the object itself the
object it's called on upon so you get
pretty much guess what this should be
doing and of course when the first
function would cannot modify self is to
return something here like this is a new
point with those fields X x and y
increased by respective integers and you
also one mutates things in place and if
you ever make a mistake and forget them
you think the compiler will just say ah
you cannot do this and I just put the
basic and
and this way when you you you have
something some some piece of code and
you're looking type signatures you just
see that things that can change and see
the things that guaranteed not to change
ever this is not true I I thought well
you can of course change things like you
can instantly print statement and change
the code word around your code and you
can do all kind of of things like open
files open connections stop databases
try to whatever modify some some some
memory and this isn't change the values
past the function the compiler will not
not complain so it's not pure pure but
its purest law as long as only talking
about the parameters of the function so
you may be anxious okay if I can open a
connection maybe I can store something
in some global state global variable and
introduce some some kind of change there
and you can certainly do that this is a
way to implement a static global
variable in in rust and you can of
course say it's immutable variable and
you can try to change it but Russell are
you really sure you should do that if
you are if this does not a mistake
market so Russ would require to surround
this piece of code is safe keyword which
means that this is a way to take
compiler to not worry and not what I'm
doing
trust me this will be all right and the
body will enable anybody looking at your
code later how unsafe I should be should
be worried worried about that so
functions in Russ are pure enough for
all practical purposes and because it's
the system ceramic language to do all
nasty stuff with hardware and low-level
things it lets you escape those pure
security and
do what you want basically okay
functions um see his functions and see
pretty much can do most of that you can
store a function you can pass a function
you can create them in runtime but also
that you can do how about something guys
how about data types I've mentioned that
rust is a strongly typed language
there's time influence so we expect that
a modern type system that allows do very
nice things like intimate algebraic data
types so examples in this section will
be taken basically from learning as
Haskell and translate it to rust so this
is the simplest of the predator pipe you
can eat you can have it's an enum just
like in C which has two values and you
can use them in variable but this is
again treating races and the language
can do that most anglers can do that it
is something more complicated let the
shape type which can have two values
sinful and example and circle requires
you to use three floating-point numbers
and rectangles expect you to for you can
again use this syntax in the last line
to create a circle if you have in scope
something else which uses source of the
name circle you will be required to use
the qualifier shaped column column to to
integrate it so yeah this is how you use
it in a real code you it's not as
elegant as in Haskell or Scala
but you can match against the value and
its enemy must because of the match must
exhaust if you forget something compiler
we say that this will not do and you
have all those nasty all those nice
sorry things in II you should expect
from a modern programming language like
destructing like it about parameters
this again this function because it does
take the reference to shade will not
modify shape of course and you can be
pretty sure it won't but this one thing
having things like circles and
rectangles and maybe other shapes can we
have something more generic a type that
can hold any type like that like maybe
in Haskell just hold any any kind of
value and sure enough last have an
option type which is so-called generic
type it can hold nothing or none and
some value of the shape of the T and you
can use it and the type inference and
the compiler will know which types that
you are is it option of strings option
of in anything that can be expressed in
that system can do Butler to even
sometimes we'd like to have some
restriction on the type like this is not
a enemy destruct again which has three
type variables each of the synthesis of
this one type and we can just create it
in line just putting values so the
constructor of the of the object
destruct and have last figure out what
to do with that however if you would
like to have something it just prints
not that nice if you use the default
things
you might want to say okay I know better
how to print this thing clear stranger
to the format it seemed to show it this
is quite easy to use some restrictions
not every but everything can be printed
to a string right you cannot print a
function to a string you cannot the
closure to a string so this is not true
that any value can be substituted for
this TSV type variables and it's any
module programming language Rus allows
you to specify that there are some
restrictions to those types and in this
case all of those need to have a display
trait which will inform the compiler
that those types need to know how to
display themselves to a string the basic
stuff if you explain about it which
brings me to my next topic right case
inverse look a little like type classes
in other languages a trait quoting Wrath
diverse book this is only one at the
moment it's a trade trade is a language
feature that tells the last compiler
about functionality at times must
provide on a type class the sort of
interface that defines some behavior you
can say that it's pretty much the same
thing and let's see how it works in
Haskell of course you have some color
which will take one of three values
create some binding for them and try to
compare those as these are the same if
it works you need to you need to have
the your type implements the EQ type
class which defines two operators equals
and not equals and provides default
implementations for those so when you
implement them you can't write any for
it to work and this parameter is welcome
rust this same coach translate to us
give an enum which had sin half can take
one of three values we've been do you
create variables you come
them and again to have it to be able to
do you to the operation into demanded
trade goes surprisingly enough EQ which
provides two functions which have
default implementation this is not the
real EQ class from Russ it is a little
most complicated but I this works
exactly the same as in rust and it can
be done rust and trace I used to do all
those funny things and like like oh
sorry
you need to evil to might want to
implement this but this is silly nobody
nobody would do that for this simple
thing so you can have it automatically
derived this what's compiled is that for
you you know how to do deal with EQ and
you guys it for you so Restless trades
is very important this part of language
it uses quality which defines two to
three it's partially positive equality
ordering comparing to two values to
produce an order also you've done with
traits clone and copy clone and they do
basically the same but the distinction
between them is coast
copies the rise of them automatically
for you if the type is simply enough and
it's always used inclusively never use
it doesn't write any methods actually
you can call them method from from copy
and for example individual types have
copy implemented so you can just copy
integers everybody consider the cheap
operation clone and enhanced of the same
but is considered expensive so when you
implement clone for your type you need
to explicitly call clone methods and
it's considered expensive
operator overloading is done with
straight add a design sub double sign
and so on couple dozens of them
accelerating cover types is also
implemented in terms of a trade it's a
trade having it an object is collabo as
all trades Jolly three trades because
Russ control control suitability looking
into an object indexing into an object
again a trade default trade which
basically tells compiler how to produce
default value for o types like zero for
integers or or something like that drop
is used to control what happens when
your value goes out to scramble and the
memory gets freed so you can overall
implement this trade just an extra
behavior at this moment sentencing those
two are interesting because they're
using thread sent items although those
items can be transferred between threads
safely so they visited from words rated
the trade the thread cannot reference
them anymore and then appear in the
another thread and you can use them the
sync items the types that value the
types that implement things rate trade
can be shared between threads all the
threads in the program can now use them
this is how this one of the ways that
makes last thread safe reinsert safe and
starting with last 1.15 which was
released two weeks ago I think you can
do custom device usually compilers know
how to derive those common traits like
EQ art and so on you can write some
procedural macros to implement and there
is a trace you desire this little
advance last black box black magic last
and I'm not going to this but this is
very very nice feature that you use in
couple of projects actually that these
are which is ORM in rust or cellulite or
library which brings me to macros hardly
any language has real macros this is
considered the Telegraph disgusting
dangerous people shouldn't use it but
it's turned out to be very useful and
that's like macros that means C will
just shrink manipulation but will
hygienic macros has a couple of them
like all my cousin you need to end with
a it's amazing point is how you mark the
macros into compiler expects back it's
very nice syntax to create lists without
literals
try is meant for family carers panic
about your program principles well
Prince things but also macros allows you
to build pieces of syntax the drugs are
in support out of the box and I use it
as in supposed to build a functional
composition with Argos that doesn't
support compositional fractions out of
the box but you can do it let's say we
have specified that we have a list of
numbers a vector of numbers and we try
to map over it with some modern look or
less trivial example but such more than
a single function and we can use that
but the only thing I care about in those
yellow line line is the ABS function and
in negative function this is the Salomon
is just syntax avenge don't really like
it I would I would like not to use it
anymore ever
so let's lie down as a micro macro this
is a syntax to create macros it looks a
lot like function let's thing on the
Left it defines a pattern that the
compiler will look for and the thing on
the right after the double arrow that it
will be replaced with this
so in this case we've got two
identifiers dollar F ontology supported
gadot and this will this will be
translated into a closure function
closure which takes an argument and
applies those two in order in order this
is how we use it
notice that I didn't use the Commission
point in the definition of macros but I
need to use it when I call the macro
this is how rust works I just use
sanitation absolute and just apply it
and of course worse provides you with a
method to expand the macro to see what
is actually see what does not descend
and sure enough this is what we expected
this macro has problems like there's
only only allows supplying methods not
functions it's only I was applying two
methods not any number of them which is
good limiting like if I want to to apply
the function like that that's right
another macro macro let's call it C by
compose and this is there is basic stuff
you apply those functions in all that is
like mathematical definition of of
composing functions listen like that
and sure enough it expands to something
and we expected the i30 to column : ids
is a so-called Universal function calls
and ducts
this is ways first or is a way to
uniformly call functions and methods all
other things that can be callable so
that we can unify it and use it in
context like this and since we can
rewrite our our previous example with
this new macro
look is that abs is a function from the
type and energy neck is a function from
the trait has the difference in casing
all right so let's try now the final
function that applies three things three
functions you can be tempted to do like
this just try them in order but is it
out to nowhere right
this only works for three functions but
you will immediately have a case of four
functions and five functions etc and
rest provides macros absolute classes
you can try to implement this in the
smarter way to allow na and number of
functions and is it the first line is as
before when we have just two functions
we know what to do we have more and this
weird syntax of H expression which is
repeated with plus of one more times and
the comma before that the separated with
commas and this should return a closure
that takes a result of recursive
application of parameters and tries to
the to its parameters and to the first
function of the of the arguments just
how we use it just use it like you'd
expect that we solve all those functions
and sure enough compile expanded to what
we expect ate the the blue things lost
the most the first function sum from the
list is applied to the result of calling
the green function to the purple
argument and the green function is
application of this macro for two
functions and we can go crazy
now we can go crazy with this macro can
do anything we want this is thinking
these numbers filtering to get the
vertex absolute values of those numbers
then we negate them then we count once
in binary representation then we cast it
to cyan't integer because count one
citizen a sign and sandy digital and
then we apply an even function actually
now if we can see what it expands to end
this is some some horrible code which
has great for closures applies them
create them applies them it's not
something a human of right would write
right it's not something a human would
write so maybe we're losing something
but we should just forget this all and
like any normal human Java programmer
and write it ourselves and forget those
closer composition so I'll create a
benchmark last being language it is
focused on on performance the built-in
benchmarking facilities calculated two
tests to benchmark
health coverage code on the bottom and
the macro on top and they are pretty
much the same in terms of performance
last compiler can see those old creation
of closures and application needs is
only temporary and we will just optimize
it out and pretty much produce the same
code in both cases so yeah you can
implement all those nice features like
functional composition
use it anywhere you go back you can see
that there are methods there are trace
methods there are functions they are is
an even closer defined in on the spot so
can you do anything and you're not when
you're not paying for it this is pretty
much all I had rust easily functions
provide first class functions a direct
language that provides physical
functions which are pure enough for
practical practical applications that
languages provides algebraic data types
we can do all nasty things with that
have trays which work with the much the
same as type classes and you can use
macros to create all those things that
are missing from the language and even
pay for it when you still got a c-level
formal even better than C because well
types can enable very nice optimization
questions
you've shown in your example of macros
how you are making a macro over working
over identifiers but it is possible to
make for example macro which could be
applied for type definitions for example
I have macro that takes type definition
as a parameter so I can for example
iterate over it skills or fun yes there
if you look into the definition of those
macros let me go back you see there as
the the FG and H are to fix this column
export this expression and the first
macro we used items identifier and rust
provides many more of those and types is
one of them is py I think I remember
correctly which would make the compiler
expect type path to to the macro however
it's not the disease as it as it is here
this is so called simple macros and they
just replacing some code with some code
to iterate over like types fields or
enim fields you will need to write so
called procedural macro it can be done
and starting from last one to 15 is in
stable so you can write that it's
working but you basically to write the
function that is called at compile time
which takes naps of syntax 3 as an
argument and then you can do anything
any other questions
okay you don't know more questions than
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>