<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>LFE: A Real Lisp in the Erlang Ecosystem by Robert Virding | Coder Coacher - Coaching Coders</title><meta content="LFE: A Real Lisp in the Erlang Ecosystem by Robert Virding - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>LFE: A Real Lisp in the Erlang Ecosystem by Robert Virding</b></h2><h5 class="post__date">2016-09-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/x2ysisqgd2g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay thank you plugin right so yeah this
is a bit talk about LFE it's been around
a while so parts of it aren't you
some parts are so it's a something in
the ailing ecosystem and I'll talk a bit
about what the a-line ecosystem is what
we mean by that and why you'd want
something there or not right so the
goals for LFE the original goals we've
had the whole time is that it should be
a proper Lisp okay in the sense that
it's not just an experiment I mean to it
it takes you're an afternoon to write a
simple Lisp interpreter that's not much
that's not a problem but a properly
something is actually usable in
production things like this for you want
an inefficient implementation on the
beam okay you want to make it as good as
you can running on the beam as efficient
as possible and the goal was to have it
seamlessly interact with our line go TP
and all the other libraries and stuff
you can have running together with it I
mean you've got this enormous set of
libraries you've got tools and things
like this you want to work together with
all these things otherwise it's not
really that useful so what I'll be
talking a bit about a bit about the
background the history I promise you
will be short because you most of you
not it just has some influence on why
LFE looks like it does Wyatt why it
doesn't look like other things or other
lisps I'll talk a bit about what we call
the Allen ecosystem which LFE is part of
and what that means and then bit about
describing LFE so the fire background
when we're working in at the computer
science lab in Ericsson
so Ericsson had the ax e switch which
was a very successful switch but it
quite quite a lot of effort to develop
and maintain software for it so one of
the things we were looking at in the lab
was how to solve the problem to make
programming these type of applications
easier to do and some reflections we
have on this is that
we were actually not out to implement a
functional language this was not a goal
so the language what then became our
lang became functional because this sort
of fitted into what we were what our
thoughts were we weren't out to
implement the actor model okay we did we
hadn't heard of the actor model when
we're doing this we were told afterwards
aolong implemented the actor model then
you go look in the papers about the
actor model and say yeah we have done
that but this wasn't our goal to do that
we came more from a processes type
operating system type processes for we
were out to solve the problem that was
our goal we had this problem we were
trying to solve the problem and this was
our solution to the problem so what was
the problem this the problem domain here
this is a set of points written from a
thesis by a B on a deco how that's our
boss at the lab then about various
issues around this type of problem what
the problem domain was and of these some
are more interesting well from outside
the the problem outside telecoms and
others for example so we had things like
it had to be able to handle a very large
number of concurrent activities if
you're thinking of telephone switches
you might have had hundreds of thousands
of users maybe tens of thousands of
calls going on at the same time there
are timing constraints things have to
happen in a certain time will take a
certain specific time for it you need
distribution if you want to make a truly
fault-tolerant system you need at least
two computers it's just no way around
that it had had the problem or the issue
or the requirement that you have to do
continuous operation over many years
over a long time the system must just
not go down for anything right so you
need to be able to maintain software
upgrade software and so on wireless
system is running and the last one here
is it has to be fault tolerant again the
system must not crash and the thing
takes you have to realize is that if
you're writing a system you are going to
get errors in the system there's just no
way around that
so how do you design your system in such
a way that when errors occur the system
does not crash paths so it might go down
but the whole system does it
so these were the type this was our
problem line this is that this is the
issue we were trying to solve making a
phone ring is easy right you send the
switch a few signals and the phone
starts ringing you send the switch a few
commands and two phones are talking to
each other that is not the problem these
are the things that are the actual
problem and when you think about it
that's not just telecom they're an awful
lot of applications they have the same
requirements much more than at least I
realized originally so so our line and
the system ran and was designed to solve
this type of problem okay and there is
direct support for all this in our line
go TP for these type of issues that's
what that's what it's all about right
that's that's why that's the inherent
cause of why the language and the system
looks like it does and the language in
this and there are ideas about how to
use a designer system came about at the
same time so things in the language are
there to think for things we thought we
needed to build these type of systems
that's why some things doing some things
in our line is extremely simple like
writing a supervisor something that
manages other processes and restarts
them when they die you can write that in
less than a page of code because some of
the primitives you have in the language
are designed for doing that type of
thing right and that gets us on to what
I what we mean by when we call what we
call the airline ecosystem right and
it's a set of languages built and
running on top of the beam on top of our
Lang and on top of OTP and using all
these features for it so I mean
typically you have a line of course
Alexia's part of this elixir is built on
top of a line and the beam and using the
primitives and their and extending it
with its own set of features word but
uses these things for LFE is there
there's a prologue there's a lure system
running on top of that and there is
there is Joxer which is another Lisp
other things running in these things so
all these languages are part of the
Allen ecosystem and the thing here is
that if they if they follow the rules
prop
they can interact openly with each other
so you can write passes system in the
different languages and they can call
each other and talk with each other
interact with each other and if you
follow the rules is quite seamless to do
that so you're not locked into one
language okay and this is a big benefit
to do this so you can choose which
language you prefer to write in and you
know you can face things written in the
other languages are there hour long of
course because a large portion of the
libraries are written now but other
languages as well - this has other
benefits as well - so if we have the eco
system here we can have another system
in the for example in this case the JVM
and if you want to interface the a line
system with the JVM you can do that
there is support for that for doing that
but once you've done it it also means
that all the languages running in the
ecosystem can now talk to JVM they don't
have to do it themselves separately they
can all use exactly the same thing if
the interface is there they can all use
it right now with the JVM you have a
slight extra extra way over here because
running on the JVM there's something
called air jjang which is an
implementation of our line running on
the JVM and it is a very good
implementation and quite usable and it
also has the benefit that it is very
close to our line amongst other things
you can run distributed our line
together with the distributed edge air
jack so you can run you can run an
outline system on the JVM running as
distributed our line natively into
interfacing with it and have an
interface into everything else running
on the JVM so again this is this is a
benefit of wait there's the thing rate
one came this is another benefit running
on the ecosystem you can use all the
other features and libraries written for
the other languages you can access them
and use them as you need so at the
bottom of all this is the beam which is
the Allen virtual machine so what is the
beam
well yeah it's a virtual machine to run
Allen and that says very little but it
actually says quite a lot so the beam is
specifically designed to run a line it's
specifically designed to support the
features of the language so the language
itself the arming language itself from
the beam are very closely interactive
integrated with each other and you can
the beam can do a lot of things but it
can read runs hourly that's what it does
so if you're want to run things on top
of the airline system you end up being
having at some level something that
looks like a line because that is what
the beam supports it just doesn't
support things outside that now this is
important from the LFE point of view and
from other languages because this very
much decides or determines what becomes
how the language works if you wanted to
interact properly you have to follow
these rules there's just no way around
that if you want to something that
doesn't then you're outside it and then
you get interaction problems with it
so what are the properties of the beam
so it supports the lightweight massive
concurrency it's the one that can give
you millions literally millions of our
line processes running in your
application and there are serious
products that do this it's one who
provides the asynchronous communication
between all the processes we don't call
them actors we call them a line
processes it's provided for example
support for pattern matching well it's a
process isolation that's why we can do
the letter crash thing in our Lanka's
processes you'd like because they're
isolated as the virtual machines the
beam that provides the support for it
it's one that provides all the
primitives for doing error handling for
doing a railer handling system for
building fault-tolerant system all the
primitives are in there inside the beam
the continuous evolution of the system
which in this case means it's the one
that provides that all the Phils
facilities and support you need for
dynamically loading code while the
system is running it's all this and
therefore it's the one that provides a
soft real-time it's actually quite hard
to block the Erlang system you can do it
if you work at it but otherwise the
system could protect itself very well
and there's a lot of this support in it
okay there's something I don't have to
think about for example which makes it
very easy and it provides a very
transparent SMP multi-core support I
don't have to think about how many cores
I'm running on the Erlang system will
quite happily grab them all and use them
all and spread the load between them as
as much as it possibly can and all this
is just built into the system I can
control it if I want to but if I don't
it just works for this is not simple to
do there's a lot of support in the
machine to do that now these types of
things you will sell them directly see
if when you're implementing a language
they're just there right okay
the one you might notice is that if I'm
receiving a message I I have to do some
form of pattern matching because that is
what the basic system that is how the
basic system handles messages so I might
need that in my language it also
provides a lot it has a lot of other
things properties as well which are much
closer to when you're implementing
languages so it has immutable data not
just has it all data in the system is
immutable that's it there is no way of
mutating data at all in the system for I
don't know if we can get around using
this but you might crash this and
probably crash the system if you try
around there's no guarantees what will
happen there is only a predefined set of
data types you cannot create
user-defined data types there's just no
way around there as well there's support
for pattern matching their support for
the functional language as well for as
well these are baked into the thing it
has a cot it has a a view of how modules
and code look and how they work which
you have to adapt to to get things
working for again this is very much
based on on the dynamic code handling of
the system how this works and there is
no global data at all we don't do global
data and we don't share again this this
again comes back to the problems of
the error-handling if you're if you are
going to accept the fact that processes
are going to die and crash then you
can't share data because then one
process crashing could ruin the date for
another process crashing and then you're
in serious problems so although there is
complete isolation in the system for
that's why there is no global data at
all in the system you can implement
something that looks like global data
but when you get round to it it's not
just a problem for this also scales very
well because it's something that is if
there's one thing that makes scaling
systems very difficult its shared
mutable data and we just don't do that
all just avoid the problem completely
and these are things you will see in
your language these are things you will
directly see in your language it's very
difficult if you're in your language you
do things which mutate data then you
have put a lot of work to do that to get
around that problem get around the fact
that the the beam does not support in
immutable data okay you can do it but
it's difficult so the next thing I think
I'd know how many people Lisp is here am
I talking to the converts a few okay
well so why less bright of course and
this is probably the oldest will the
second oldest high level language in the
world so we're talking somewhere around
about them this code example here is
from 1958 okay so this is this is how
all the languages and it doesn't look
very nice there and if you start looking
at you'll see it's actually three func
defining three functions for set
manipulation for set membership for
intersection and union subsets there
that's that's what it's doing right so
why do we really want to do something
like this why do we want to use it the
the language that is this old haven't we
got any further than that well it's not
that bad these days so these are le feel
turn ative z' for those functions and
here we're using things like pattern
matching to do itself or it's slightly
better for so so why Lisp
why is lisp still actually popular and
still actually in use
it's controlling NASA satellites
telescopes satellites things written in
this port why well if you're going to
look at Lisp some properties of it it
has numbers nothing brilliant here we
have numbers for it we have symbols
these are just normal symbols they just
are things Lisp symbols here so we got
symbols like Bert and more of and do an
different size and greater than these
are just Lisp symbols there's nothing
special about these we have lists which
is where the name comes from list
processing we have a list of integers or
lists of numbers and we can have lists
of symbols and we can have lists of
lists which are lists of symbols numbers
and mixing them a list of lists and so
on and we can have a list that looks
like this this is just a list right just
a list with two symbols and a number
just happens to be the greater than
symbol the size symbol and for that's
time to look a bit kodesh and this is
just another list so it's just a list of
three or four elements the first is here
for then income three three two three
more lists here and this looks a lot
like code and it is code that is the
fantastic thing with Lisp is that code
are lists so this is code this is a
function test function with one argument
size which tests if the size is greater
than four in that case it calls the
function bump it otherwise it calls a
function drop it and it's code this is
real code there's nothing strange about
this but it's also just a list structure
so it just shows that Lisp is truly her
my iconic code is just data straight off
word and there very few languages that
that do that the only other language
I've used that he is home iconic is
prologue which doesn't look it but it
actually is it's home iconic but with
operators but has changed a lot and
still has a lot to offer from the same
thing from before they call the
programmable programming language
because the fact that code is just data
structures it's extremely simple to
generate code you do that all the time
so it's an EXOR language exploratory
programming
it's practically syntax lists you can
either call it having a very simple
syntax or no syntax at all and the basic
syntax is it's a list and the first
element of the list tells you what this
list is all about so that if list there
is the if or the one that says that this
is an if test or can be interpreted as
an if test is still just a list and
there's an awful lot of code to do that
so that gets us back to LFE run so what
isn't LFE or what LFE isn't it's not an
implementation of scheme it's not an
implementation of Common Lisp and is not
an implementation of closure and one of
the reasons for this is that the
properties of the beam make it very
difficult to efficiently implement these
things so for example in common Common
Lisp and scheme you have mutable data
and the beam does not support mutable
data so if you're going to implement
something with neutral data you have to
got a lot of effort to implement that
data type there type of data which then
becomes relatively inefficient closure
doesn't have mutable data but has
another it has not another view of
concurrency and how you do things
concurrently from what the aolong
virtual machine provides and if you
wonder that yes you can do it but you
have to implement it yourself and then
you're losing efficiency for and you
have to be very careful otherwise you
might lose your interaction with the
rest of the system so what is it it's a
proper list as one of the goals is based
on the features and limitations of the
Alain VM of the beam so it uses
everything it can in the beam and it
cuts out things that you can't do okay
it runs on the standard Erlangen there's
nothing you special let's do to run it
there no no need for ports for NIF's for
anything like any extra code for of
something like that it just runs
straight straight on and currently runs
for everything from version
fifteen - version 19 not guaranteed you
can run all the code there but the
system doesn't and it coexists happily
and seamlessly with OTP and everything
else running on the machine so if you
want to call our line fine you do that
all the time if you want if you want it
for example our link to call it a fee
fine just do that all the same time
there's no problem for example of
writing your behavior callback file for
a behavior callback module for behavior
writing that in LFA is no problem if you
want to talk to Alex here it's fine just
call it and be good call by it the date
I've just go straight through so that's
what it is so what I plan to do is look
at a few of the features or what goes in
here and try and explain why from the
explanation from the ecosystem and the
being why things look like they do in
LFE and why I've made those choices
right so look a bit about datatypes
modules and functions and the thing
called this one versus list this - a bit
about pattern matching and macros of
course so we only have a fixed set of
data types that's it right there's
nothing we can do about that this is all
that the virtual machine provides so you
have numbers you have atoms which are
close to Lisp symbols they're lists of
course there are tuples we have maps and
binaries and there are a few our peg
types as well there are pins and riffs
and a few others as well - they're part
of the system that's it you don't have
anything else for this is a limitation
but it's one we have to live with so the
atoms and symbols if you're coming from
a lisp world they're not quite quote
they're not quite the same as Lisp
symbols so the elephant's are not quite
the same as Lisp symbols so for example
an atom only has it only has its name
whereas if you're coming from the list
world a symbol has other properties it
has a value it might have a function
definition you might have a Pelias
property list and a few other things as
well - we are now in the a language
system and atoms don't have that you can
fake it however I've got some
a nice hack to fake property list of
symbols if you want to do that you can
do the same thing with values if you
want there is only one namespace again
this is that this is what the the
machine provides so if you're coming
from Common Lisp and scheme you can have
multiple you and from closure for that
matter you can have multiple namespaces
the beam does not provide that you can
try and fake it right so they're
notebooks common list packages or
namespaces for you can try and fake it
by saying yeah we'll call the atom name
with the coal onion and that means will
be part of that package something like
this with the munching of the name that
would sort of work but then would make
the interaction with the rest the Aling
system extremely difficult because it
doesn't follow the same rules ok so if i
if i have this package called bar with
an atom fool you know i could call that
bar colon foo and I could work around
that in the fu system but then I'll pass
that to into an a line function which
I'll be do which I'll be doing all the
time anyway it suddenly breaks down
because it just doesn't just understand
the rules so you just don't do that
right just don't do it and we have
boolean x' there just atoms again this
is basically how the Allan system works
so what we have lists of course we have
we have tuples which if you're coming
from common list they're just vectors
the other way around for it we have
these no more or less the same except
for the fact that they're immutable
we also course provide support for
binaries I mean they'd be total stupid
not to so you can have a binary data
structure here so the first one just a
binary of 3 to 3 bytes 1 2 3 I mean
binary binary is at the low level just
an array of bytes or maybe an array bits
depending how you want to look at that's
all the binary actually is at the low
level the interesting thing about a
binary of course is how you interface
these bytes and the second example of
course we're defining a binary here of
five fields of different of different
sizes these in this case these are all
well the first three are numbers and the
first one T is a little endian 16-bit
number again this is just something this
is just an interface to buy
provide and we can access that interface
and make it the second one the second or
third therefore bit integers the fourth
one F is a float it's a 32-bit float and
the last one B is a bit string
containing all the rest of the bits in
that binary this is just describing the
data structure of a binary and again
this is the the Aling system provides
direct support for this we're just
mapping straight into that right and so
we have properties like the type the
size the Indian scientist is just
straight - straight from the beam and
binaries are fantastic when you start
thinking about them if you're writing
protocols so this is the one of the
classic examples of a binary this binary
describes an IP version 4 packet in one
go write the whole header for that
packet so there's an 4 bit version
there's a four bit header length is a
let's this 8 bit service type a 16 bit
total length there's a 16 bit ID Flags 3
bit either the case I've seen those
flags are 0 so I don't really know
what's in them there's a fragment offset
13 bits there's a time to live 8 bit
there's a protocol there's a header
checksum there's a source IP destination
IP and there's all the rest of the
whites so I can write down the whole IP
packet in one binary in one go like this
as a binary and the thing is I can use
this binary to construct the packet so
if I write this binary down in all the
field names there have values I'll
create a binary containing exactly these
things which is now a legitimate IP
fourth packet so I can't so if you're
doing protocol stuff binaries are
fantastic for doing that and we just
provide straighten export that or just
access to all those things they're the
modules and functions what again now
we're hitting again we're hitting what
the beam provides us with and if we try
to do something more complex here then
we're going to lose the interactive
interaction with the rest of the system
then we end up having LFE is one system
and the rest is something else and maybe
a limited interaction between them which
is something we don't want right so
modules are very basic again this is if
you're coming from the Erlang world
you've seen this I don't know if you
thought about it but you've seen it
anyway a module it has a name and
exported func
that's basically all you see in a module
it has a few attributes but that's
basically it
what you see in a module it only
contains functions modules do not
contain data there is no module data
immutable or otherwise and it's a flat
module space that's it
you might try and create hierarchical
module spaces by messing with the names
so they could have to underscore bar
underscore bars are trying to make
hierarchy for but at the bottom level is
just a flat name space and there is just
things you have to live with and of
course modules are the unit of code
handling you compile modules you load
modules you update modules to delete
modules you cannot do it at a functional
basis again this is what the machine
provides and functions only exist in
modules I cannot have a function outside
a module okay this is nothing strange
here there are no inter dependencies
between modules okay not not at the low
machine level through aren't any so
that's one reason why I can act I can
load and delete modules independently of
each other because there's no
interaction between however we do have a
support in error thief at defining
multiple modules in one file which is
sometimes beautiful I'm a bit ambivalent
if I want it or not that's there and it
works right so allows you to support
write multiple modules in one file and
you can compile those you will give you
a separate module of definition files
which you think can load
sometimes it's practical do that so an
example here is there's a definition of
a module called the Rif with three
functions to adds in a sub and we define
the module mix porting the functions add
to add three and sub two as with our
line when you export something is the
module name and the arity the number of
arguments that's important there so we
define add of two arguments a and B we
just returns plus a B and we've got to
find out we've got add of three
arguments ABC which just plus a B and C
and these again these are just two
separate functions okay we have sub a
and B which just returns did you
between and the function definitions
real resemble common lisp that were that
was sort of my heavily influenced by
common lisp and mattress perlier and
standard lisp and even at lists machine
lists but before that how that did
things that sort of my heritage for
functions can't have variable number of
arguments again this is something
implemented by limited by the beam
that's why i've got two functions ad
here it's not one function which have t
the two or three arguments it's two
separate functions as to what machine
gives you you could implement functions
with variable number of arguments by
making all the argument by having all
the functions having one argument with
just a list of all the arguments that
you could make work and you can make it
invisible but then you wouldn't interact
with the rest of the system which
doesn't do it that way okay thank you
people so yeah the functions are the
same name for so an elephant module it
has to fit this it what consists of well
it consists of attributes so modules
have a set of attributes for various
values of things you can see these if
you do module info we can have metadata
in there as well too and this we can
have metadata information in the source
files which will then go into the beam
files which you can actually access and
read there if you need them for example
you can have type information there you
can a function type information and
that's metadata in the module in the
module we have function definitions yes
we can macro definitions and we can do a
compile time function definition so when
you're defining macros you can you can
define functions that only exist while
you're compiling and you typically do
this for using in macros when you for
macro expansion which is done at compile
time the macros can be defined anywhere
and but they have to be defined before
the use it's nothing strange there if
you're running multiple modules in one
file anything to any macro is defined
before the first module are visible in
all the modules there apart from that
macro is defined within a module only
visible inside that module so there's
quite a clear separation of what you see
and where you see
this one versus Lisp - this is a long
battle inside the Lisp world and what it
all boils down to is where you access
the pop of properties are they symbol
really so you can have it you can have a
symbol in two different places basically
you can have it in the functions in the
function position or as a value okay so
if we look at here example the calling
foo foo 42 bar the foo is the function
so there that's in the function position
the bar is in the value position now if
you come from a list one symbols only
have values so irrespective of whether
in the function position or in the value
position you'll just take their value
for so you both for both foo and bar
you'll take the value of foo and the
value of bar to use those and the value
of foo has to be a function in list two
symbols kept both values and function
cells so if it's in the function
position in as user through here then
you'll take the function value function
position for that it was bar as the
value you'll take the value position of
that so they have two things and this is
very old
this is this list two lives in mac list
from the from the 70s probably earlier
than that as well to this one is deemed
to be cleaner to do that but this Patil
their common list for example is a lisp
- Mac let's pause money on whisper as
well - so we see what we have this thing
economy what we do what what should we
do in LFA so if we went with a lisp one
here
well the Allen system provides us lets
us define say in this example two
functions foo foo of two arguments of
full three arguments and in my function
bar here I can call foo of two arguments
so I can call foo three arguments are
can have multiple functions called foo
but in a lift
Lisp one world I will let bar equal the
lambdas lambda here I can only have one
bar because if I tried to redefine bar
I've been to be new bar a different
y'all wanna go pick one right and that's
inconsistent okay I'm big on consistency
so if we go with Lisp - we can still
have two functions through here but then
I can do a special F let and I can
define two functions bats here a
function bears have one argument and a
function bears of two arguments they're
both local and they both exist at the
same time and I can call flow of two our
two arguments through three arguments I
can call bears of one argument and
Buzzard two arguments and this I feel is
much more consistent because then
because then the function the naming and
handling of functions relative to the
number of arguments is the same whether
they're global functions top-level
functions or local functions so LFE is
gone with being a lisp - which means it
breaks with example scheme which doesn't
do that I think if it's better on the VM
it's more consistent for it and actually
I call this two plus because you can
have lots of functions with the same
name you can have like you can have food
two three four five as many arguments as
you want therefore here lots of so I
call this blue plus four I just think it
fits better in we directly support
pattern matching this is nothing strange
pattern matching is a big win there is
support quite a lot of support for this
in the virtual machines be be stupid not
to use it so we do that and we use
pattern matching everywhere you can have
functions are multiple clauses and use
pattern matching for selecting a clause
you do it there's a lip there's a case
there's receive which are all based on
pattern matching
there are macros as well in macro
definitions you can pet you can use
pattern matching as well so pattern
matching is used everywhere so a lot of
the things that exist in common in
standard lisps for binding variables we
now use patterns instead to bind test
and blind variables so let just doesn't
take variables it takes a pattern with
variables in and uses that for it
we have the case which it's a straight
mapping we have the receive of course do
that when we define functions we have a
function of multiple clauses and we
again use pattern matching to select
clauses there's nothing strange about
this we've even added in the cond
as a macro itself we've added an option
for doing pet for matching so we're not
just evaluate a test and see if it
succeeds or not we can actually do a
pattern match there and you can choose
that clause that the match succeeds and
you can access the variables which can
be quite useful so pattern matching here
well it's just a few D function
definitions using pattern matching we
have the acumen function we have the
member function written in more
traditional type Lisp not using pattern
matching in a cond and we uses pattern
itself if you haven't used pattern
matching you really missed out on
something if you have used pattern
matching you never want to go back to be
honest for of course we have macros I
mean it wouldn't be a list without
macros and a lot of the things you're
using when you're using LFE are macros
the de fun we saw is a macro for example
the F lit is a macro as well too so a
lot of things you see in macros diff
modules a macro there's an awful lot of
macros here they are unhygenic in the
sense that they don't really the
expansion of macro doesn't really have
its own environment for it this is not
too bad it's not good but it's not too
bad in the sense that all variables are
scoped so anything any variable you
define inside of it for example or
inside a case Clause they're just valid
inside that Clause so they won't escape
it but yukl to limit importing things in
there there is no Jenson so what Jen's
ium does or does in this world is it
creates a creates a symbol which is not
interned in any table and going to
guaranteed to be not equal to any other
symbol this you can't do in a line if I
make an atom it's in the atom table and
it's equal to any other item with the
same name and one way of crashing the
Erlang system is keep generating atoms
until the astrum table fills and the
system crashes so we're very careful
using Jenson there is none we could make
a limited form of Jensen Jensen have
some suggestions for that
it's a macros only world and actually
not compile time at the moment
actually they're not you can do compiled
you can do well compile-time and
run-time macros you don't see that much
I also put in a limit so LFE is a set of
course to a core language you cannot
redefine those we're using macros sort
of bit of self-protection right so we've
got macros here for example got an add
them macro which takes two arguments and
just returns a it just returns a form
which will add those two arguments
together just replace it with a plus
it's very simple one here we've got well
the macro the second argument doesn't
have to be a list of arguments in just
be really just be an atom and that will
just be a list of all the arguments that
you get when you call a macro so the
average here will return a plus of all
the arguments and divide that by the
length of the argument list and it's
going to calculate the length of the
argument list at compile time and we
have a list macro the list star macro is
a common one from Common Lisp
it just takes him to builds a list of
elements takes a list elements built a
list of this sets the last one which
puts it as a tail of them your standard
macros macros clear multiple clauses I
don't have well you didn't the list ones
this star you see it's got pattern
matching and this macros can have
multiple number of arguments only means
you have one macro per thing I know I've
got a code example here but we're
running out how much time we got left
okay okay
skip the code example it's it's a very
common case it's a very simple thing we
had in the lab we had a little system we
could we could actually make phones ring
and we had a system called tell us for
doing that for controlling a switch and
this is just examples of running to when
you're making a call
yes you a side is ringing the b-side and
what's happening for two processes one
managing the a side and one managing the
B side and they're all message
controlled here for them and it's
completely non blocking a bit of ongoing
work
so we now have a feature in the language
which allows you to call macros as if
they look like function calls so in the
module mod I can have a macro call macro
and I can call that right right the call
for that mapped by doing mod call on
macro and then do that and that compile
time that will be recognized as a macro
call and will be expanded at compile
time the alternative is that you you
include a list of local definitions of
the macros this allows you to get around
that feature so I don't have to do
include files to include the macros I
just call them with it with their module
names and this works anywhere it doesn't
not just in the right-hand side when
court as in function calls bright their
macro is expanding to patterns and
alright it the this the module name call
a macro name expansions on the on the
left in a pattern as well and they'll
still work it looks a bit strange but it
works for this is compile time well it's
sort of run time as well because if
you're calling a function in a module
and that function does it doesn't exist
we'll try and see if it's actually
actually a macro definition an expander
at runtime it's bit cunning it works
it's not used very often because most of
the time the macro expansion will happen
will happen before you call it anyway
but if it still works we're adding a
type notation now for it I spell it
correctly
yes so you can run alex here for example
together with dialyzer it's a little bit
hacky cuz dialyze has sums and weirdo
restrictions you can get around those
but there's been no way of defining
types and specifying function types
until now so we're working on that too
the way of defining a specifying
function types I've got a list machine
flavors packet that's been migrated from
the list machine flavors this machine
flavor is there a forerunner to the
Common Lisp our object system for it and
they are much cooler they were much more
fun some basically they poured in number
as many options as they could dream up
into them right if you start looking
through them and so I have a port of
that which works you're getting into the
system will not just have as an ad
we have some work being done on a
closure interface and again there's a
structs package from the list machine
which sort of migrated into common list
but it's simplified which I'm working on
now and that's very versatile and when
that works we ought to use that both to
define records like our Lang records and
Alexia structs as well amongst other
things we are very much more control of
what the data structure wants to look
like how you want access and things like
this form so that's what's going on and
of course the final question why well
that's easy I like Lisp see it's my
first higher-level language if you don't
count Pascal and for trainers high level
I like yeah like yes I like to implement
languages yes it's fun implementing
languages a lot of fun so implementing
and they're facing that that's fine and
that's just me accessing me in different
ways and a very very nice ecosystem cube
here think we have time for a few
questions
Oh
it's used in a couple of places I know
of okay yeah but they're still using it
that's the best I can give yes they're
still they're still using it migrating
for so it does work for is it used in
production yeah yes yes so yes it's it's
actually used in production or they
using it to build production systems for
it went to version 1.0 before summer
it's been around for a long time and I
never realized the importance of going
from 0.9 to 1.0 that apparently is very
important the changes were mind you it
was changing 0.9 to 1.0 I shouldn't say
this this just says the original system
was very actually very good it was
production quality I just hadn't
bothered yes so well what happened to
like hear the unhygenic macros one of
the things that that saved me a lot of
time when I when I did it for fun was
was John Sims yeah that's a problem
okay I have a solution for Jen Sims
which so the problem with the Aling
virtual machine the fact that you that
you in turn atoms and you feel the atom
table they never go away I cannot do
anything about so if you want something
that generates atoms you'll have to
reuse the atoms in a certain way and not
hopefully will not be too dangerous
about that so you don't get it-get
overlaps I cannot create for example
create two atoms without the same name
that that are different the system just
does not allow me to do that I cannot
get around that but I have a few ideas
to do that I had one in originally but I
removed it off the wall but I've got
requests to put that agencia meme so
I'll have to put it back again and
unfortunately I cannot if I create an
atom I cannot guarantee no one else will
get the same atom even if I get the most
weirdo long name of 100 characters if
someone comes up with the same set of
100 characters it's the same atom
there's just no way around that
there's something I can't do anything
about
so one reason that people like poly
language systems like this is because
you can take old code and run it in your
system so doesn't really apply to you
because it's not really the same as
other people's lisps a lisp no no so I
guess so then the question would be well
why would somebody want to write in in
LFE when they could use a line because
LSA is so much nicer I mean would you
write all new code in LFE instead of if
I could yeah interesting language I
think it's a better language right I
like this I like I like it my second
best language in the ecosystem selling
for this wedding right yeah and as I
said you can interface everything else
so if someone feels like writing a
module in a line it will just work
there's no problem for so the pattern
matching syntax that you use in in LFE
is that borrowed from some other lists
No so you just you've made it up
yourself well I did exactly I did
exactly the same as an a-line the same
idea is now like an hour long if you
write a data structure on the right hand
side it builds it if you put it in the
left hand side it's a pattern other
lisps other lisps that use pattern
matching extensively I don't know of
other lisps that have it baked into the
low-level but a lot of them have will
have packages that do it for you okay
but not at this no I don't think not at
the same level you do is if you put it
into the system at the base I'm just
wondering why it doesn't seem to be like
a popular feature and lisps in general
my guess is a lot of lisps are older
they they come from environments whether
we don't have pattern matching and
they're not willing to adopt but they
did they adopted by by defining a
package that does it that allows you to
have some form of match
with back with patterns and so on for
the it's not in the language itself you
haven't added into the language I mean
once you've done pattern matching what
how could you live without at night to
be honest I mean there any other serious
functional languages that don't have
patterns any last question I can say one
thing when you go I have some LFE
stickers the other free mug if you
wanted up there if you were the one with
your face on it
no I don't have that's a bit too
megalomaniac but where you go maniac no
forgot the other one the mug DiMarco God
I can give you one of these tomorrow if
you someone actually really wants it but
two features or things that you said
that it would make interacting with LFE
more difficult from the whole ecosystem
those two things which are both done by
only two I think no well they no there
isn't
now well there's a last parameter that
allows you to provide a list which is
virtually and it's something yeah okay
it's gonna be really strict it's
something is bit of syntactic sugar
which allows you to write something at
the end which becomes a list right yeah
so I will debate that with you but yes
okay go on go on go on go on yeah okay
no okay the one Alexia has is is if the
final argument is what is there using
the special syntax for keyword lists
then it works then you can remove the
brackets for and you can write key colon
value key colon value key
value and the pass will say that all
this is a kick this sort of looks like a
keyword list but without the square
brackets to make a list and it's the
last things I'll put it together in list
that's basically how it does it right
okay I think you will have to take that
discussion of lying afterwards so let's
thank the speaker</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>