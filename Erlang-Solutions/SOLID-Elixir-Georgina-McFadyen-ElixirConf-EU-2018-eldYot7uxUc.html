<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>SOLID Elixir - Georgina McFadyen - ElixirConf EU 2018 | Coder Coacher - Coaching Coders</title><meta content="SOLID Elixir - Georgina McFadyen - ElixirConf EU 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>SOLID Elixir - Georgina McFadyen - ElixirConf EU 2018</b></h2><h5 class="post__date">2018-04-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eldYot7uxUc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hi everyone today I'm going to be
talking about the solid principles which
are originally a set of design
principles created for object-oriented
programming
we'll discuss whether these principles
are useful in the functional world and
see if they can be applied to elixir or
whether functional languages need a set
of their own design principles my name
is Georgina and I'm a software developer
I most of my professional backgrounds
actually been in Java but at the moment
I'm working on a project which is a
micro service architecture and some of
the services are written in elixir when
I first started out my career I was
doing C++ and Java so probably the most
object-oriented languages you can find
and there was a lot to learn I had to
understand how to model the world as
objects not something I'd done before I
had to learn the syntax of the language
so I could bring the solutions to life
and at the early stage of my career all
my effort was spent in lashing some code
together and hoping it would work over
time I got to grips with the oo way of
thinking and I soon realized that just
getting some code to work wasn't really
enough and I needed to take my code to
the next level to make a more robust and
a more testable long-lived project so
luckily I made a career move and I
joined a consultancy which was very much
focused on clean coding practices and
the solid principle an integral part of
the developer process after applying
these principles to my Java code
enhanced my code in such a way that I
had a more maintainable and long-lived
product the same company asked me to
learn a functional language so as a
consultant I could go into various
clients and be able to evaluate what
languages and paradigms were best suited
to the problems that they were facing
and I chose to learn elixir before
learning elixir I had years of
experience or problem solving and system
analysis so I had to learn the center
but the syntax is nice it's quite
approachable so I didn't find that too
much of a barrier so I quickly got
something working and then I found I was
in the same position as I had been
earlier in my career I wasn't sure how
to take my elixir code to the next level
in terms of design I wasn't aware of any
functional specific programming design
principles so I decided to do an
experiment and apply the solid
principles to my elixir code the solid
principles are 5 design principles where
each letter is an acronym for a given
principle when applied they're intended
to improve the quality of the design of
your system so you've got better
maintenance reusability more robustness
and you avoid making breaking changes
every time you need to face adding new
functionality so the originally devised
400 languages but I wanted to see if
they could be applied to a functional
code base the use case that I've decided
upon for today's talk is an elixir micro
service which forms part of a holiday
booking system the code we'll be looking
at is concerning customer search
preferences and it's a web plug project
so services communicate using HTTP the
booking site has many forms like so
where customers can select their holiday
accommodation preferences they press
search and they'll be presented with
various accommodation options the first
time you log on to the website
there'd be no options pre-selected but
every time you search for some
accommodation it would save your
preferences to an underlying database so
that the form is pre-populated next time
you log in so in order to fetch the pre
save preferences we have a get endpoint
in our system
a typical workflow is that a customer
logs into the site and navigates to the
search page when the form is loaded it
will call the get end point of our plug
system under the hood the database is
queried using an a customer ID which is
obtained from the log in and we're using
DynamoDB which is a database offered
with an AWS stack a matching record is
found and that record is stored in an
internal map structure we do some
transformation so that we return JSON
back to the calling client having
explained how to fetch the saved
preferences we also have to add new
preferences and for that we have a post
endpoint for the post use case the user
logs in navigates to the form they
choose the selections that they want to
search for and they press the search
button and that invokes the post
endpoint this time we receive Jason we
have to transform it into a map so that
we can then go ahead and save it in our
database so for the purposes of this
talk just think about this service as a
glorified crud system so now that we
have a flavor of the domain we can go
back to our solid principles the first
principle is single responsibility so
this is the official definition of
single responsibility on Wikipedia it
states that every module or class in
your system should be responsible for a
specific part of your system so what
does that mean well using this
definition let's decide on this occasion
that getting user preferences is a
single part of our system it's a single
use case we need to implement so let's
see if we can write a module that
fulfills that single responsibility
so here's our web controller which is
responsible for fetching the user
preferences and as described in the use
case that will go ahead and query the
dynamo database to see if it can find a
record for the given customer ID we have
to decode that database response because
DynamoDB saves some metadata along with
the actual business data and we want to
strip that out by transforming it into
an Alexa struct and then we transform
our database row into some JSON which we
return back to the calling client so in
a nutshell we broadly have three things
going on three different steps happening
in our controller we queried the
database to look for a matching record
we decode the database data to strip out
excess on metadata that we don't need
and then we format that data into JSON
so it's a bit more human readable for
the calling client so is this single
responsibility together those three
steps do make up the single use case for
fetching user preferences but let's asks
us let's ask ourselves a question so one
way to identify if you're violating the
single responsibility principle is to
ask yourself of the steps that are
happening in this module can any of them
change independently for instance if we
decided to update our query to the
database so that rather than just
providing a customer ID we also provided
a geographical region with the other
steps in our controller need to change
possibly not and in this case it
wouldn't because of the data coming back
from the database doesn't change our
transformation of to Jason won't change
either so this could indicate a
violation of the definition that we gave
earlier because we've identified
distinct steps that can evolve
independently
the reference has always lots of
interpretations of these principles and
so I tend to favor this one from Robert
Martin who's a big advocate for clean
code and architecture in the world and
he states that a class should only have
one reason to change now an elixir we
don't have classes rather modules so we
could update this definition to be for
elixir a module or even a function
should only have one reason to change so
at the moment we have three steps inside
one module let's apply this new
definition of single responsibility to
see of the solution suits having a
different module for each step so first
of all let's extract out their database
lookup we can already see at a glance
that this is now a much more concise and
smaller module and it can be tested
independently and tested in a much more
focused manner now if we needed to
change our JSON transformation for
example we wouldn't even need to open up
this module look at it because it's
completely isolated the next step was
decoding our database data into a struct
now it's debatable whether this actually
warrants its own module because if we
look closely at this code is really just
wrapping a library call and there's not
really any business logic going on here
so we should make sure that the modules
we break down do warrant their existence
and this may be better suited merged
with the previous module that's looking
up the data with the database and the
last step was transforming the JSON and
it makes sense to extract this out
because really it is doing a completely
different job it's not interacting with
the database at all our calling code or
controller now becomes much simpler it
just coordinates the calls between the
new modules and so we need less tests at
this level now
so if we think back to when we had
everything inside one module if we
wanted to test the Jason transformation
we'd have to mimic hitting the gate
endpoint we'd have to mimic hitting the
database and a row coming back from the
database
we'd have to decode that data and only
then would we be able to see if the
Jason had been transformed correctly
whereas having separate modules we can
now test those things directly and we
could have much more focused tests and
focused tests tend to lead to much more
focused failures and focus barriers tend
to lead to quicker resolutions because
it pinpoints exactly where the problem
is happening and our higher level test
can become a thinner suite and they're
typically more expensive to set up and
run anyway of course there's always
trade-offs and every module does what
needs to earn its right to live there's
an overhead with every module that
exists in terms of maintenance and
testing so it's a good idea to evaluate
how you've split up your system and if
you end up with a plethora of tiny
modules of which some always change
together it might be a sign that those
modules should actually be merged
together and should live together
the next design principle is called the
open closed principle so this principle
states that you should be able to add
new functionality without changing
functionality and this sounds very much
a contradiction so I like to summarize
it as the ability to add new code
without touching any existing source
code so as a quick reminder we have our
post endpoint to save search preferences
to the database so that we don't save
any incomplete data we want to perform
some validation on the payload that we
receive we want to check is the customer
ID that they provided a valid customer
ID and we want to make sure that there
are certain mandatory fields present in
the payload
with single responsibilities in mind we
could model each validation rule in a
separate module we can go ahead and
execute those rules if they all evaluate
to true we can persist the customers
data to the database and if there's any
errors we want to handle those errors
provide a reason and send that back to
the client so we want to add a new
validation more easy we add a new module
with the business rule inside of it we
can update our with statement and we can
update our error handling so that if
that rule fails we can give a reason and
send it back but wait a minute
the open closed principle says that we
shouldn't be touching any existing code
when we're adding new functionality and
if we do what I just said we would be
modifying existing source code which is
against our room so whilst this is a
trivial example production large systems
are often lots you know have lots more
complexity and as you add more and more
rules your system becomes much more
difficult to test you might have lots of
permutations that you need to test so it
might be better if we have the ability
to plug rules in and out then in our say
unit test environments we can just plug
in one or two rules for unit testing but
in our production environment we can
plug in all five 10100 rules that we
have in our in our system so let's try
and configure plug-in architecture
so looking at the original set of rules
they tend to fall into two categories
there's those that concern the header
properties and there's those that
concern the payload the body of the
request so instead of having them all
listed in this width statement we could
model it slightly differently we could
create a list of their functions for the
header validation and a list of
functions for the payload validation we
could then wrap those lists and another
module and that module could iterate
through those rules and execute them one
by one and then if there's any errors we
can fall out of the loop for example
here we have our header validation
functions configured in a list and we
can recur stru that list and fall out if
there's an error so now if we were to
add a new rule we would just need to add
it to our list and the code surrounding
that list wouldn't actually need to
change this simplifies the calling code
so the with statement would just call
the wrapper modules and it would just
need to check there all the header rules
and all the body rules the details of
the rules that are we actually executing
is now hidden from this level so if we
add another 10 rules this module doesn't
need to change so this module is now
adhering to the open-closed principle so
what would we need to change now if we
were to add some new validation rules
well we would need to configure a new
module with our rule in it and add it to
our list and if we think of this list as
configuration rather than code we could
tell ourselves that we are adhering to
that open-closed principle but there are
trade-offs with this of course testing
hasn't become any easier
if we have a hundred rules they're still
going to be listed in this list and we
still need to unit test all the
permutations
so we've definitely made a step in the
right direction
by isolating our area of change to a
single list but another thing to think
about here is there's no guarantee as to
what these rules are going to return and
we don't really know what parameter we
need to pass in and with elixir being so
flexible you can pass in any function
here but our surrounding code is
expecting the return values to be in a
certain to poor format so we could use
an elixir behavior to try and put a bit
of a contract in place and that will
enforce a contract between the rules
each module that's going to adhere to
this behavior would need to provide
implementation details for the functions
that are defined on the behavior and if
you're familiar with Java you can think
of a behavior as being similar to a Java
interface so we could define a behavior
something like this
which is saying that any module that
uses this behavior will need to provide
an implementation for the is valid
function and this function would need to
return a tuple of either okay or an
error with some reason so now we have to
update all our validation rules actually
adheres to this behavior and to do that
we can just provide the annotation to
use the behavior and then we need to
provide the body of the is valid
function
this way rather than configuring a list
of functions we can actually just
configure a list of modules and then
when were iterating through these
modules we can call the is valid
function directly because that's now
guaranteed that these rules actually
adhere to this contract and the last
step would be to make this list of
modules fully configurable and we could
do that by moving them into the elixir
config and this way we can configure
different rules for different mix
environments and then at runtime we can
look them up using the application get
em and this way we've achieved being
able to configure one or two rules for
our unit testing but we can configure
however many rules we want for
production so now if we add a new rule
we need to add a new module containing
that new rule and we need to add it to
our list of fun of our module names in
our config so we're finally adhering to
the open-closed principle because we can
add new functionality without touching
any existing code again this may seem
overkill for this example but if you're
working with a large complex system and
you need the ability to plug in and out
features or you've got rapidly-changing
requirements being able to have this
plug-in architecture can be quite
beneficial the next principle is called
Lascaux substitution now in
object-oriented programming you have
classes and classes can inherit behavior
of other classes so in this example here
we have a base class called report which
has a format method and we have a sub
class called marketing report which
inherits this format capability and then
has some methods of its own as well
okay so I wouldn't even try and
understand this definition if you've not
seen it before because it's like a
foreign language but what it's trying to
say is that we should be able to
substitute any of the subclass type with
that of the base class type and this is
probably best described using a small
code snippet so this is a snippet of
Java code so avert your eyes if you
don't like looking at Java code this is
just creating a new marketing report and
calling the method form at the Liskov
substitution principle is saying we
should be able to change the type of
marketing report to the base class of
report without any desire undesirable
effects happening in the system so it
should still compile and run and this
works because of our inheritance model
and the former method being available at
the most generic level there is now in
functional programming we don't tend to
use inheritance as much sometimes not at
all but let's see one way that we can
mimic something similar
using elixir so we have some reporting
capabilities in our holiday service user
preferences are sent to various
departments so we send our preferences
to the advertising department
so that targeted marketing adverts can
be sent to you additionally data is sent
to data warehouse so that we can build
up a historical store of all your
preferences and we can look for things
like trends so in a nutshell the data
that's persisted is sliced and diced and
different views of that data are sent to
make the different reports
so to help model this we'll use another
behavior each model each module that
implements this behavior will provide
its own bespoke implementation of how it
wants to format the data for the report
that it's responsible for so we can map
different modules to different parts of
this diagram for example we have our
advertising report and that uses the
formatter and inside the format to ROS
function here it will format the data as
is needed for the advertising report we
have a historical data report for data
warehouse and again that uses the same
behavior and it will format their
different
the data differently as it needs for
this data warehouse report and then we
have a report generator which will
format the data and dispatch it and do
all that coordination so that takes a
little database data and a list of
different formats and it will loop
through and generate the different
formats before dispatching so here we
could actually plug in any formatter any
module that uses the formatter behavior
and we'd be able to successfully format
our report so we could say that this is
adhering to Lascaux substitution
there'll be no undesirable effect if we
put in a new formatter that's great but
a holiday sites really taking off and
there's a new regulatory requirement
that comes in and suddenly we need to
generate a new report for legal legal is
always a bit difficult they're never
happy with something you already have so
although we want to use the same format
as the data warehouse they of course
want some extra information they need a
disclaimer and a header they want some
colors so there's some extra work that
we need to do
so we could write a new legal report
generator this takes the database data
and a formatter it will format the rows
as it has done previously but it also
will go on to add the disclaimer and add
the headers and add the colors before
dispatching now we already have a module
that formats the data as we want so we
already have our format two rows
function there but let's go ahead and
add our new functions so we add a
disclaimer and our header and so on so
now when we pass in our historical data
format to our legal report generator
everything works great it generates it
as we wish because it has a definition
for all of the functions that is
expecting but what happens now if we
pass one of the other four matters into
the legal report generator let's take
the advertising report for example it
implements the formatter behavior but
that only has the format two rows
function defined on it so the first step
would be successful but when it comes to
adding the disclaimer and the header we
haven't got implementation for them
available on this formatter so of course
we would get an exception we'd get an
undesirable effect so we would be
violating the Liskov substitution
principle because according to that we
should be able to plug in any formatter
and everything works as expected so we
need to think a bit more we know we want
to format the data as an existing
formatter but we know we need to do
something extra so rather than updating
the existing historical report we could
try creating a new report which uses the
existing one so that we reuse the
formatting capability and then we can
add the extra details in the new module
so we created a new module and use the
same behavior so we don't break any
contracts in the format two rows
function we can delegate our formatting
behavior to one of our existing reports
so that we reuse that capability and
then we can go on and add the new
presentation layer function
so now we've actually been able to hide
this extra presentation behind the
actual behavior that we have so all of
our reports now adhere to the same
interface essentially and we can just
use the same report generator so by
wrapping an existing report we've been
able to extend its functionality without
exposing that detail to the outside
world and now we can substitute any of
those different formatters safely so
perhaps an elixir we could think about
the Liskov substitution principle as
follows where we have code that expects
the behavior type we should ensure that
we're only using functions that are
defined moistu in generic level so that
works fine but why didn't we just update
the formatter in the first place and
then we could have updated all of the
reports to provide a disclaimer and a
header and the colors well we saw how
this would potentially make sense for
our data warehouse report our historical
data but doesn't really make sense for
our advertising report because it
doesn't need these extra presentation
functions if we had updated the
formatter we would need to provide an
implementation for these new functions
to fulfill the contract so in our
advertising report we would have had to
have provided than a disclaimer function
and add headers function but the detail
would have essentially been empty
there'd be no business logic we need to
do because these functions would be
redundant and this is confusing for
people working on the code base because
if you see a behavior defined with
different functions on it you think that
they're important and you think that you
need to provide good implementation for
them and if you just provide an empty
implementation it's usually a sign that
your design isn't quite right and
similarly if we have lots and lots of
different reports we don't want to have
to update them all just because one or
two of them lead these extra
presentation functions
so if we had done this we would we could
say that we'd bloated the behavior in
order to satisfy a new requirement and
this would actually be violating the
next solid principle which is interface
segregation so the interface segregation
principle states that clients should not
be forced to depend on contracts that
they do not actually use in
object-oriented programming languages
there's various signs that you can look
for to see that this principle has been
violated
typically you see it in very tall class
hierarchies or interfaces or classes
that have lots and lots of methods split
over different responsibilities and
translating this into the world of
elixir we could look for large behaviors
or modules with lots of functions again
spread out over lots of different
responsibilities so we've already
discussed that adding all of these new
functions to the original behavior is
not a very good idea because it's not
relevant to all of the different reports
so let's leave the original formatted
behavior as it was so we don't break
their advertising report and instead
let's create a second behavior that is
around presentation and has those
presentation functions on it so the
historical data report can now be
updated to implement both behaviors
because elixir lets you use as many as
you like as long as you provide the
detail for each of the functions defined
and this way when we generate our report
we can split it up into processing and
the formatting of the data then
presenting the data and our calling code
can decide which reports are needed to
run through which step so this way we've
kept the necessary functionality
restricted to the modules that actually
need them and you'll find that several
of the solid principles start to
intermingle because by making sure your
behaviors are focused
you're usually enforcing the single
responsibility principle as well
so that brings us to our last solid
principle and that's dependency
inversion and unfortunately that isn't
me in the picture by the way now
there's too many words on Wikipedia to
put the whole definition but I've tried
to extract the essence of it here and
dependency inversion is around
separating your high-level layers and
your low-level layers so looking back to
our gate endpoint we have the ability to
fetch data customer data from the
database and the database is an external
dependency if we look at our
implementation we're using a library to
look up and interact with our DynamoDB
using this library we have a couple of
options to configure two different
databases we can configure to point at a
real dynamodb table in a real instance
of AWS or you can run a java process
which will bring up a local DynamoDB and
you can connect your elixir code base to
your local instance but either way you
need to have an external database
running in order to connect to it and
when I'm running my unit tests I don't
want to connect to a real AWS instance
and I don't want the overhead of having
to orchestrate bringing up a local
DynamoDB so I can hit it
and clean it out and all that overhead
so to adhere to a dependency inversion I
want to start splitting this up I don't
want my high level module which is get
customer preferences in this case to
depend or be tightly tied to this
library which is expecting a real
database to exist I want to provide an
abstraction in between such that I'll be
able to provide a fake database so that
when I run my unit tests I don't need to
bring up any real database at all
and then I can configure on different
environments different implementation
details for the database so in my test
environment I can use my fake one and
then in production I can use my real one
and if we look at the code base closely
in the library there's actually only one
line that actually physically connects
to the database so if I can isolate this
one line I have more control as to
whether I use that original line from
the library or whether I substitute in
my fake call an elixir gives you a
couple of ways that you can do this one
method of decoupling that we can
demonstrate the dependency inversion
principle with is to use the elixir
config to substitute different
implementations for your different mix
environments so as per dependency
inversion let's modify our design
slightly we can provide different
implementations of the database so we
can have a real AWS request database and
our fake database they can depend on an
abstraction and in elixir we can use a
behavior for this abstraction then we've
got our high level module get customer
preferences and if we let this depend on
the abstraction as well we've created a
layer between our high level modules and
our low level modules this way we can
change our database implementations
without the high level module knowing so
it's completely separated from the
details
so first of all we create our
abstraction which in our case will be
your behavior and that's the layer
between the high level modules and the
low level modules we can wrap our real
database functionality behind this
abstraction so we again use that
behavior and we have that cool that hits
the real database and then we provide a
fake database this will also use the
same behavior but it will just return
account results and it's a hard-coded
result in the same format as what would
come back from the real database so now
we can configure which one to use in
which mix environment so when I'm
running my unit tests I can just get
that canned result coming back every
time but in my other environments I can
use the real AWS instance so we can
utilize Alex s config again to configure
what implementation we want for the
different mix environments and look up
again at runtime which one we should
substitute in so it seems that we've
achieved what we set out to here we're
not dependent on the details of our
database implementation anymore and we
can configure in and out different ones
depending on our needs but there's
always trade-offs so what happens if I
want to test different scenarios at the
moment my fake module always returns the
same hard-coded results in another test
case I might want to hit the database
and mimic no result being found in
another test I might want to hit the
database and mimic and error being
raised or multiple rows being found and
at the moment we always return the same
value and the only way we could drive
logic in our fake is through the
parameter that's passed into that
function and in our case that's the
customer ID so you might end up with
some logic in your fake database along
the lines of if customer ID is one then
return a canned result if customer ID is
to raise an error if customer ID is
three returned empty
results and so on
and it's difficult to keep that
expressive through the code and when
you're looking at a test case it's not
always easy to know what branch of that
logic would be executed and which
branches are never executed so
maintenance can become a bit of an
overhead and as that complexity builds
do you then need to unit test your fake
database and so it kind of bro can grow
out of control if you're not careful
so in summary using config files
definitely gives you some flexibility
and I've used them quite a lot to plug
in and out fake implementations but if
you have a rich set of testing scenarios
that you want to cover it may be
difficult to keep that maintainable and
expressive through the code base so
another option that I've started using
is to use a mocking library and this way
you can define the behavior of your
fakes right there in the test case which
is where it's most relevant such a
glance that tends to be clearer for the
developer what behavior is going to be
returned from the fakes so to use mocks
you add it as a dependency to your mixed
file and we want to keep our dependency
inversion design so we have our
abstractions still but using mocking
library we don't actually need to
physically create our fake database
ourselves so we can cut out that part
from the picture we still need to wrap
the real database functionality behind
our abstraction we can configure that in
to use in production through the config
and then in our test config we state
that we want to use a mock and that can
be any name that you like because we're
not actually physically going to create
it instead we ask mocks to create it for
us so we say create me unlock request
module that implements this behavior
then in our production code we can look
up at runtime which implementation we
want to use and then in our tests we can
use mocks by importing it defining an
attribute and then giving the
expectation as what we want to be what
we want returned when the database is
actually invoked so here we're saying
when the request function is called on
are fake then execute this function and
it will return an okay tuple with the
canned results so the main advantage
here is that you can define in the place
where as most relevant the behavior that
you want your fake to actually run you
don't need to trip through lots of
different make modules that are
somewhere else in your codebase and
trying to figure out what behavior will
happen now if you forget to provide your
expectation you will get an exception
and I found this quite useful in terms
of when I'm writing higher-level tests
that span through several layers of the
application it really brings at home as
to you how far through the system your
tests are actually going and how many
hits to these external systems you're
actually making because sometimes you
forget that you're doing a read and then
a write or I found that having this
feedback is actually really useful to
keep my tests more concise so although
there's similarities between using a
mocking library or writing your own a
mocking library tends to give you the
convenience of being able to define lots
of different return values as well as
using a rich set of verification to
check that your external systems are hit
a given number of times the only slight
untidy edge is that mix gives you a
warning because you're referencing a
module that you're fake module which
actually physically doesn't exist in
your file tree but I can live with that
so in elixir terms we could suggest that
dependency inversion is useful if we
depend on abstractions rather than the
detail because it certainly helps you
test particularly when external systems
are involved and you don't want to use
them in your test environment so can you
write solid elixir well we just did
we've pretty much applied every one of
the solid principles to our elixir code
base I think the real question is does
it make sense does applying these rules
make for idiomatic elixir or have we
just ended up with an elixir code base
that resembles something like Java are
these the right rules to use in a
functional landscape we need to remember
that the characteristics of a functional
language are quite different to that of
object-oriented languages amongst other
things functional languages tend to be
about passing data around whereas an
object-oriented you're reacting to
messages that are being sent between
objects so I think the solid principles
get you started in elixir or functional
but probably we need to tweak the rules
to be more aligned with the functional
characteristics with maintainability in
mind it seems sensible that we continue
to use the single responsibility
principle do one thing and do it well
having small focus functions is as good
an elixir as it is in any language
functional or object oriented and
functions are the building blocks of our
functional languages so we can think of
the single responsibility principle as
having small focused functions and an
elixir we can compose functionality by
passing functions in returning functions
and composing functions together so
having them small and focused will help
any potential reuse so from my point of
view s is fully implement implementable
in elixir
regarding open/close it seems sensible
and low-risk satin adding new
functionality we don't touch any
existing code this reduces any retesting
effort and it makes the code and the
tests more focused in elixir we have
higher-order functions so we can pass
any functions in and in some ways that
makes the open-closed principle very
easy because we can just pass new
functionality in without touching the
body of the function while passing it
into bearing in mind with great
flexibility can come a great mess so you
may need to think about if you need to
put in any contracts like what we did
with the elixir behaviour so I think
open/close is a good goal to strive for
in functional programming so what about
Lascaux substitution in our this tends
to hinge off inheritance and I haven't
tended to use inheritance very much at
all in functional programming so perhaps
this one we need to redefine and one of
the things that functional programmers
strive for is purity a pure function has
an input and an output given that input
you will always get the same output
there'll be no side-effects and no state
modified so let's imagine this pure
function which simply adds two numbers
together given another function which
uses this which is also pure we can
calculate as output so the output of our
lucky number function would come out at
7 every single time so if we substituted
the number 7 every occurrence where
we're calling lucky number
there should be no undesirable effects
in our program the result of the
evaluating expression is going to have
the same mathematical value as the
starting code and this is known as
referential transparency so I would
propose that we modify the definition of
Lascaux substitution and instead we use
referential transparency thus replacing
the L of solid with RT
in our interface segregation is about
keeping your interfaces small and
focused only forcing contracts were
necessary in our case study we saw how
the elixir behaviour could help with
this and in Neelix a source code
documentation it actually says if you
have to you can think of an elixir
behavior as being similar to a Java
interface so I think this supports my
conclusion that interface segregation
should be applied to the elixir
behaviors and we showed how by creating
an abstraction we can decouple various
modules in our application and that this
resulted in a code base which was more
flexible and easier to test without
depending on external dependencies so we
created an abstraction between our
database and our high-level modules and
we could then substitute in different
implementations so particularly with
testing in mind I think having a
principle such that we can depend on
abstractions rather than concrete
implementations makes a lot of sense now
the existing solid principles were
created 400 languages and we need to
remember that functional languages have
no state they're immutable typically
recursion is used over imperative
looping so I'm leaving you with a
question as to whether at a future date
we need to work some of these traits
into our design principles so coming
back to the title of the talk many of
those who consider themselves a
functional programmer brush aside the
learnings of the i/o community by going
to the extreme and forcing these
principles on my elixir code base at
face value I found a lot of them made
sense I had a lot of code that became
smaller more focused and easier to test
and regardless of what we consider to be
great idiomatic elixir I'm sure we can
all agree that we need to write code
that's maintainable and easy to work
with and easy to extend and we're lucky
that elixir being a kind of newer
language and has learned a lot from
existing languages it already lends
itself to being
nice to use with immutability
pattern-matching being able to compose
functions having behaviors and protocols
all built in so we concluded that s for
single responsibility was applicable for
functional languages I suggested that
open/close was a good goal to strive for
we discussed that Lascaux substitution
should be replaced with referential
transparency to acknowledge the purity
of the language using behaviors we can
adhere to the interface segregation
principle which leaves D for dependency
inversion in which case the baseline for
design principles in elixir could be
sorted thank you very much
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>