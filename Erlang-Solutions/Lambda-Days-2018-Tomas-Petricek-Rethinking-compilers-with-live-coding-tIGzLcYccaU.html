<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2018 - Tomas Petricek - Rethinking compilers with live coding | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2018 - Tomas Petricek - Rethinking compilers with live coding - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2018 - Tomas Petricek - Rethinking compilers with live coding</b></h2><h5 class="post__date">2018-04-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tIGzLcYccaU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I have a bunch of different interests
and one of them is is doing tools for
data science the other is history and
philosophy of programming and what I was
thinking what talk to do here I sort of
decided that maybe this is the safer one
because different bits of history are
not allowed in Poland so I didn't want
to get into history of tyldus banned and
put me in prison so instead I'm going to
be talking about life coding and this is
this is a piece of work that I've been
doing in the Alan Turing Institute which
is a sort of UK Institute that does data
science and sort of lots of people
around you do very fancy machine pink
but couple of people who are sort of
interested in improving the tools that
people use when when when working with
data and the the context for this as it
got a lot easier to explain my research
interests thanks to these people because
there's this sort of name for it called
post facto or sort of fake news where
for example in the UK people sort of
don't really don't really find facts and
and through all that interesting which
if you're interested in data science is
kind of sad because all your all your
work is about sort of how can we make
the data more accessible so how can we
how can we make sort of data more
accessible so that people care about
them and are actually sort of interested
in finding what the data can tell us and
there's it's sort of recent trend that
some newspapers have been have been
looking at so this is an example from
the New York Times where they're sort of
visualizing data and some really sort of
accessible ways to encourage people to
sort of see what what what the data says
so this example is when they were
looking at the history of Olympic
games and they sort of draw the history
of medals so there's sort of over time
you can see which countries get more
medals which had fewer medals and I find
this really nice because with just sort
of this one picture that is based on
some actual facts on some actual data
set it tells quite a lot of things so
right here you can see two Olympic Games
didn't happen because that's the two
world wars there's this peak around here
where in 1980s first the the US didn't
go to the Olympics in the in the Soviet
Union and then sort of next year or next
four years if it reversed you can see
the cold World War and the Cold War in
this and I think it's it's a way of sort
of engaging making data more engaging
getting people interested but even this
so this has a couple of problems one is
that pretty much the only people who can
do it are New York Times because they
have so many developers who know
everything from art to JavaScript d3
they wrote d3 so that helps it's really
hard
and so what I'm sort of interested in is
can we make this easier so that if
you're a not necessarily sort of random
person of the speed but at least sort of
university educated person you should be
able to somehow look at the code try to
sort of understand how it's been done
check that you could recreate it
check that the visualization isn't
misleading and be able to explore
further so with the Olympics for example
if you count football or ice hockey
winning you can count it as one medal
for the team or you can count it as like
15 medals for every single player that
really skews the data
so what I've been working on access is
this project called the gunner and I'll
give you links to everything later where
the idea is and everything in router the
idea is whenever you see a chart you
should be able to see what how it's
being created so this is an example
where I'm looking at carbon emissions
and comparing carbon emissions of China
and the US and you can see that China is
winning pretty clearly and this is
looking at the but that's that's sort of
what does it they tell me well I can
look at the source code here and this
has a little scripting language which
I'll be talking about more later on
where you can access some data and for
example what I'm doing here is that I'm
saying looking at some data from the
World Bank
give me the carbon emissions in kilotons
now this is one of the several things
you can look at and carbon emissions in
kiloton is the sort of total number for
the country and if you compare this for
China and the US while there's obviously
a lot more people living in China so
maybe that's misleading and maybe what
we want to know instead is metric tons
per capita which is basically sort of
how much is it for one person living
there so if I change it here and here
well then if I didn't resize my window
then there would be a nice Update button
here and I could change it so instead of
changing it through through the code I
can also change it here because I'm
sorry I can analyze the code and find
bits where there's some variability and
so I can do the change here
and this is something that you can do
even if you're not a programmer but
behind the scenes it's actually
analyzing and modifying the code and so
now if you look at carbon emissions per
capita you can see that u.s. is actually
much worse polluter relatively per
person than say China so this that's the
kind of transparency that I think is
really really important when we make
data available and the sort of whole the
whole project evolved into how can we
make this easier because currently you
can you can build this sort of data
visualization you probably need PhD in
computer science and PhD in data science
to just be able to do this so how can we
sort of make it easy for a regular
journalist who's maybe technically
skilled but not sort of expert to
produce these kinds of visualizations
and there's a there's a nice talk by
Jonathan Edwards which has in a
different context but he talks about
this gap between spreadsheets on one
side and programming on the other where
spreadsheets you can use them to solve
fairly simple problems but lots of
people can do it programming there's
sort of even the simplest programming
problem is fairly hard but you can solve
arbitrary complicated things but only a
little number of people can actually do
this and I'm basically interested in
what's somewhere in the middle like can
we make something that's easier than
programming but more powerful than
spreadsheets and one idea that's that's
really great about spreadsheet is that
when you're doing something you're
working with your data life you're not
writing some abstract very variables F
and Freeman at one
working with actual numbers so in Excel
if you want to add two things or
multiply you just sort of look and work
with the data directly and then you
extend your computation and so the the
main thing I want to sort of talk about
is behind the scenes of this part of the
project where and I'll do refresh to
make sure my window size is right
alright so what this is doing is that as
I'm typing it will give me live preview
of sort of the the code what's what's
the result of the code that I wrote so
far and that's one thing the other thing
is that this is sort of inspired by a
certain type providers even though it's
not this is not actually absorb the code
here it's my own language that runs in
the browser and I can say things like so
let's look at who's what the largest
number of Olympic medals in real games
is real and all I'm doing is sort of
typing dot and choosing one of the
options here so it's a the talk is an
advertisement for autocomplete and if I
say give me real then I can do some
grouping and here I'm doing this sort of
by writing code and the preview updates
life this is even a bit more fancy
because I can say I can click on things
and it will write the code for me so if
I want to know gold medal per person
paging what do I know I want to sort it
first so it I like spreadsheets rather
than being like a proper programming
language but actually they're still
still code behind everything you're
doing so this is this is how you can get
the number of gold medals and
going to cheat and with a bit more
effort it's not significantly longer I
can I can put it on a chart that you
could end that in article but really the
sort of interesting thing technically is
that as you're going through this code
here this doesn't quite fit but as
you're going through this code it gives
you preview for where exactly you are
end up in the code and if I change
something it pretty quickly reacts and
comes back with the updated updated page
updated result so that's the that's the
interesting problem how do you actually
implement so this editor or a program
where as you're typing you get live
previews and sort of changes are are
evaluated we like so if you if you if
you're start thinking I'll write my own
language and you read a textbook on on
writing programming languages then the
textbook compiler has a couple of
properties that the usual textbook
compiler is batch based so the idea is
you give it a file it will work you go
get some coffee because it's compiling
you come back and you have a result and
the way it works is that it it sort of
builds and transforms trees so it pauses
the code then walks over the structure a
couple of times and then produces a
binary and and a textbook compiler can
also read bad programs so if you make a
like forget a closing bracket it can
tell you haha I can't do anything fix
your brackets and that's things that you
can't you can't really do in life coding
but let's let's start by looking at
textbook compilers and so the the
example that I'll be using for the talk
is not going to be the fancy data
science thing because that's you
complicated
but I've built a very simple version of
it where you can do some image image
manipulations and so as a toy example
we'll try to build the live pro-life
programming environment where you can
write code like this and it will blur
images and compose them and we should be
able to sort of modify the code on the
fly so if you're if you're in a sort of
standard compiler mode then when you see
something like this that you run you
built you build a tree from this where
the first thing I have is that overall
this is a LED binding where I'm deciding
defining a variable P and what I'm
assigning to it is a call to this load
method right and load takes two
arguments one of them is image that's
the instance and the other is Pope PNG
which is a string then what does it do
in the body
it calls blur and blur takes P and then
it takes 5 as another argument so normal
compiler will will build this tree and
that's the result of parsing and then it
will walk over the tree a number of
times so if you like typed programming
languages the first thing it will do is
that it will assign type so this is some
class Pope is a string and then the
result of load is an image and then when
we look at the body P we know that's the
result of load so this is an image as
well this is an int and then if I call
blur I get better another image and the
overall result of this is again an image
so normal compiler will build this tree
and then it will walk over it
to do the type checking in the next
phase it will walk over it again do the
evaluation if you're writing an it or
interpreter so image will be some object
this is still a string then it will load
the image the result of this will be a
picture of a pope then Pope goes back
here that's still Pope s is five and
then we're going to blur Pope so this is
a blurry Pope and then blurry Pope as my
overall result here yeah so that's how
normal compiler works and we'll start by
doing this but we'll see that this is
really tricky because every time you
change your program you have to rebuild
the tree and rerun everything but it's a
good starting point if we want to
understand what we're doing so I have
right here a little live coding
environment for demo where I can do
things like 1 plus 2 and I see 3 or 1
plus 5 is 6 and it trains some
statistics that will be relevant later
and the programming language behind this
is really super simple so I have an
expression which can be basic things
like numbers strings and binary
operations I can access members so it's
dot property I can do dot or invoke with
some arguments I can have variables and
I do let bindings where you say let be
so let some variable equals this
expression and then the body following
it is this expression and so far on I've
written an evaluator for some of those
things so basically an interpreter where
if I get the number and I'll just return
that number as an object if I get a
string s I'll get that as an object if I
get a variable then I'll see
I'm carrying around this context which
is a mapping of all the variables that
I've defined already so for every
variable in scope I have its value and
I'll try to find the variable if I
access some variable then it's as
variable it's not defined so this is
working binary will run the operation
and what I want to show you as two bits
so if I have a member accessed then what
I'm going to do is object node is this
instance that's the expression the sort
of instance on which I'm doing the
member access and I'm inside a function
evaluate expression so I'll just call
myself recursively with the same
variables and this gives me the instance
and the way I'm running this is that I'm
just come interpreting this or running
this as JavaScript so what I'm going to
do here is say get property which is
JavaScript what did I just do get
property which is some JavaScript
binding that will do a dynamic lookup in
this object and I'm going to access this
name so you're basically walking over
the tree recursively and at every node
you do some basic thing if I have a LED
binding so this is more fun because now
I'm defining a new variable
I'm going to evaluate the assignment so
if you say let P equals one plus two
let's first evaluate one plus two let's
evaluate a sign and then the next step
is I want to evaluate the body but I
want to keep this new variable so I'm
going to say evaluate expression and
this was this was read because I'm
wrapping all these expressions in some
new object so I need to do dot note and
here I want to evaluate the body but
with a new set of variables where I'm
going to add this this new variable that
I've just defined so bar is a string
this is my key and I'm going to assign
the thing I evaluate it as the value of
the variable into my variables and
evaluate the body so basically all the
Trant three transformations this is
where functional languages are really
nice because you're just walking over
trees and evaluating things I'm not
going to implement call because this is
a bit too long but calling again you
just say evaluate the instance evaluate
all the arguments and get the property
and invoke the invoke the operation so
with all these changes if I go here one
plus two still works so that's nice
and I have two pictures here in my in my
folder so now I can call image dot load
Pope and it will evaluate the expression
and will see a picture of Pope Francis
and now the numbers are important
because it tells you how long took the
parsing so that's pretty quick binding
is something I'll get to next but then
the evaluation here it took like 600
milliseconds because it was actually
loading the file if I if I if I change
it well now it's just still loading the
file so it takes some some number of
milliseconds but it's not doing the
request again and then I have a couple
of operations like grayscale maybe not
what did I do
oh there's greyscale Pope I'm not
handling new Pines properly I guess
that's the problem so now I've got Pope
with a grayscale you can see it took
five huh five hundred milliseconds and
if I do something like blur blur is fun
you can see my cursor is stuck because
blurring is slow this ticks like three
seconds and now if I start typing then
you see it gets really painful because
every time I type a key it will have to
reparse the code and walk over the whole
tree again so it still hasn't finished
no no so that's that's why we need
something better than a textbook
compiler because the textbook compiler
is working as a batch based thing so
every time I do a change in the code
that will think it will you have to do
it again from scratch and you throw away
everything that you've done before
so how can we do this better the idea
here it's that rather than well what
what do we actually need so if we want
to deal with an environment where you're
modifying the code life as you as you go
then first of all we will definitely
somehow need to cache the results and I
just an if every time you change your
code I can't run it from scratch so I
need some sort of caching and in this
demo I'm doing just an evaluator or an
interpreter but if you're writing a
compiler you need the same things you
need sort of to catch the results of
type checker catch the results of
optimizers and so on and the way we can
do this is that rather than walking over
this tree we'll build some dependency
graph that will reuse things that we've
seen before the other fun things about
life compiler is that it needs to be
able to accept bad programs because if
I'm here so the way I can make this
reasonable
I'm just curious where I where I messed
up with my verities
yeah I'm not allowing spaces before not
apparently so here if I change the code
and break it by sort of doing maybe
backslash
no backslash is still allowed so what
what other characters do I have at maybe
there it is if I end up in a state where
the parser fails then I can happily edit
my code because the parser will just
fail and the compiler can't run it
because it's not valid program but the
problem is when you're when you're
writing code most of the time your code
is not valid like if I open a
parenthesis then I'm in the middle of
writing but if I'm if I'm in a batch
mode well then yes this is not a valid
program but if I'm live coding then the
environment should still be able to
parse this and and work on it and maybe
even give me a preview without the
invalid bit so that's the other tricky
thing here so we need something that
will cache the results and accept bad
programs and work in some more clever
way and the key idea here
is that where am I
so previously what we've been doing is
building all those priests and now so
we've been building all those trees and
then walking over the tree but what we
are going to do next is that we'll still
start with a tree
we'll still run the parser to build the
tree and as you can see in the and the
numbers here the parsing is the is the
fast part that doesn't take very long so
parsing is fast we'll build the tree but
then the key trick is that once we have
the tree we will turn it into some sort
of dependency graph so here for example
I'll create a node for this image and
I'll create a note for my string and
those are just primitive things that I
have already and then furloughed I'll
create a new node that depends on these
so so far it looks pretty similar but
now I'm going to break the the structure
a bit and I'll remember this is a note
this is a note 4p right here and then I
go into the body and I'll create a note
for blur and this will directly depend
on the P and so we still have five
that's a primitive value and I depend on
on that as well and then my main thing
depends on this
so I've third parse the code built a
dependency graph and then I'm going to
do all the same things I've done before
so image is some sort of object Pope is
a string that I'll evaluate load will
give me normal Pope and then this is
five the result of blurring is a blurry
Pope this is tricky and one more blurry
Pope goes here
yeah so this is the sort of when you
come to this first but then what I'm
going to do next is when you modify the
code as I'm building the tree I will
actually look at the previous three I've
built and reuse bits of it
so as I'm building the tree I'll go to
my image and now and I'll say have I
ever seen image before and I will find
out that I have and I have this note
which already has a value for image then
I go next and I say load this again this
is a node I've seen before so it will
already have a value then I go here and
I need a node for a load that depends on
these two nodes and again this is
something I've seen before I'll cash it
in some way and as I'm building the
graph
I'll just pick the note that I've seen
already which already has a value then
I'll go to blur and now so I've changed
the code so that it does blur seven
rather than blur five and that's where
now I don't have now I don't have in my
cache note with the same dependencies so
now I'll be like well now I actually
need to do something new so rather than
rather than reusing previous nodes now I
actually have to build a new node and
this one doesn't have a value yet but it
depends on this node from here which
already has a value it depends on this
which doesn't have a value and then the
overall result is a new node so you can
see that when I change some bit of code
what I can do is that as I'm building
this dependency graph
I'll take bits that I've seen before and
for those I will keep the value size
evaluated before and then when I need a
preview for the new version of the code
I'll just have to evaluate the remaining
bits so I'll grieve re-evaluate this to
seven and I have a boat already but now
I'll create very blurry poop because
seven is more than five and this is
going to be my overall result Oh what
happened what do you see there no that's
not mine that's not my screen
can I get my screen back I'll try to
plug it on and off is it not my fault
don't be surprising
I want my screen back I was just oh did
I touch something on here yeah this is
clever yay
okay I will not touch this that's all
right
no problem there's a hidden control
panel I can launch the missiles if
you're naughty
so this is now newly evaluated blurry
very blurry poke because I said this to
seven so I hope you didn't lose the
screen too far back but the key idea is
that as I'm building this dependency
graph I can now reuse bits that I've
evaluated before and the way I'm going
to do this is that I'll just build a
cache of nodes where the key is going to
be what kind of node is it and what are
some hash
the dependencies and then I'll just
every time I need to build a note in the
graph I'll say have I seen this before
and if yes I'll pick one that I've seen
already and if no then I'll create a new
note which is the purple here and then
those new notes I'll have to evaluate
later on so for to do this here this is
my representation of the code as a
expression as a syntax tree and I'm
adding a new one which will be the nodes
in the dependency graph and this is very
very similar very similar to the
previous one you can see one change here
is that there's no LED binding because
let is really erased in the dependency
graph that just sort of becomes a direct
link and then an entity has a node in
the graph has what kind of Noda days and
also some sort of hash and I'm being
naughty functional programmer here a
mutable state with a value whether I've
which will start as not evaluated it
will be none and then when I evaluate it
the first time I'll set this to sum and
then I don't have to re-evaluate it
again and my evaluator for this is going
to be very similar actually even simpler
than the one we've written before so if
I have a constant well then I just
returned the value if it's an operator
then I'll evaluate the operator but one
important thing here well I'll get back
to that in a second then if I have
member access member call again
this is going to be pretty much the same
things we've done before so we evaluate
recursively the instance we get the
property here we evaluate recursively
the instance we are the arguments call
the application the one interesting
thing is that if I have a sort of node
that represents the variable binding
then I don't have to do anything sort of
clever because the clever thing has
already been done when building the tree
so I just evaluate the body and when I
have a reference to a variable
I'll just evaluate the node that this
represents the one tricky thing that I
didn't show you is in binder so binder
is another sort of is the thing that
walks over the tree and builds the graph
and what I'm doing here is that I'm
defining all these entities and you can
have a look at the code explore further
on but the clever bit is here inside
bind entity where I say given this this
node that I'm creating
get me some code that represents the
node and all all its antecedents what it
what it depends on and then I collect
their hashes and I have this dictionary
where I say let's try to find a node in
this dictionary with these with these
children turns and if it's there then
just return the existing node which
might already have a value and if it
knew well then we'll create a new one
with a new hash and remap rate for later
so we've written the evaluator here and
the last bit is that this is my sort of
entry point for the program and I've got
this is this is written using fable
using the Elm architecture so here I
have a rendering function that generates
all the HTML and here I have an update
function that when you change the code
it will there's lots of performance now
so that I can check how long things take
I try to parse the code then I call the
binder which is the bit that walks over
the tree and builds the dependency graph
by reusing nodes and then previously I
was just doing evaluate expression every
time a fresh old style now we are going
to change it to evaluate entity
and this will now work rather than on
the tree it will work on the graph so
we've done the change here and assuming
everything worked we'll see how that
goes
let me actually open debugging tools
here so you can see a bit what's going
on let's make this bigger so you can see
that the binder refresh it again
couple of log messages so if I say one
it says new binding for number one if I
say two then it says cached binding
number one new binding number two
this means that and new new binding for
the plus operator this means that it
reused some of the notes when building
the grass if I put parentheses around it
then this just reused the cache to cache
nodes so this change didn't didn't
modify the tree at all if I say times
three then it's still reusing the nodes
for one two the plus operator and it's
creating some new nodes for three and
the multiplication so in this change
whereas as it was evaluating it it was
actually just reusing one plus two now I
was I was actually la I think because
there's bit that I haven't finished in
my code as I was writing the evaluator
there's the function evaluate entity
kind which does the pattern matching and
it recursively calls evaluate entity and
evaluate entity is where we do the
clever bit with storing the value what
I'm going to do here is if I want to get
a value for an entity I'll say
well I'm going to do this in the in a
naughty way but if this value is not
evaluated then I'm going to evaluate the
value and store it in my in my entity
and now this is definitely evaluated so
I'll just return the value so this is
where now I've done a change that as I'm
walking over the graph if I evaluate
something I'll actually store it there
and then it will it will get reused so
with with adding numbers you can't quite
see that quite see that but let's try
with images so if I say image load Pope
then it loads Pope that's all right
what I'm going to do so if I have hope
and then I do Pope dawdler 5 this is the
bit that takes long and still blurring
it took three seconds to blur but if I
continue and I add greyscale then the
change took only 600 milliseconds
because it was able to reuse the note I
built previously for the blur operation
which had a value so all I had to do
here was to add tipped to do one more
one more operation and do the greyscale
ink so I've got and I did another change
and this was super fast because all the
notes that are here are already
available I have one more picture shadow
now the variable but used anywhere and
that's why this was fast as well because
I'm not using it if I change it now this
was slow because I'm blurring and gray
scaling another image and then I can do
dot combined
which takes another image and sort of a
percentage of how much of which image
you want to get if we will if we change
this to 50 or 70 then it's producing
creepy image of a pope who is in to
absorb obviously with with with a
shading monster so and you can you can
see that that basis running sort of
significantly faster than before because
if I change this this number here the
update takes like half a Melissa a half
a second because all it needs to do is
to evaluate the last combined call but
the blurring and the and the great
scaling that is something that I've done
before so it's cached including the
value and if you did something more
fancy this would include the type
checking and so on
all right so that was that that was the
demo what's the summary of this well
first of all if you want to see this in
a life sort of big a bigger thing then
have a look at the gamma dot net or
gamma dot during a cuk I'll share the
slides on Twitter so you can you can
find it which is the sort of project
where I'm doing this for real on a
simple data science environment for
aggregating data the other the other two
things that I was thinking on the way
but all the code was written in F sharp
and I think the the the sort of
pragmatic functional first nature of F
sharp made this really easy for two
reasons first I just used mutation when
it was useful so most of the code was
purely functional three transformations
which is great but some of the caching
that's just a hash table or or storing a
value so the style works really nicely
for that and the other thing I was using
is the fable compiler which is absorbed
in JavaScript and you could sort of see
that throughout the demo where as I was
typing the code what I made the change
and saved it it was immediately
refreshed in the browser and this is
this great feature that fable gets by
being integrated with the node.js
ecosystem so all I had here was this
command line thing running in the
background with the fable demon and web
pack and that was making all these
things possible now if you're interested
in building your own life coding
environments to Hintz up build
dependency graphs and work over
dependency graph and use them to cache
the evaluation results
and good luck writing a decent parser
because that's the that's the tricky bit
where as you're typing your code you
want a parser that will recover when
there's like a missing parenthesis and
you basically have to guess what the
programmer intends to write in the next
step that's it so now you know how to
write your own life coding environment
thank you so we have time for one
question and then I guess you can get
tomash after the talk you have a chance
to ask one question or does everybody
just want to go for lunch there's
question here if you want to chat later
on I'll be around until the end of the
day so could you maybe say a few words
about how the cache invalidation is done
since I imagine that if you delete a
reference because your life coding maybe
you don't want to wipe it immediately or
something like that yeah so the question
was how is the cache invalidation done
the way the cache works is that when I'm
when I build a node I never actually
change it so like in this example that I
was trying to explain here with with the
picture in the code I changed the
parameter from five to seven but when I
was building the graph I just created a
new node for seven rather than modifying
an existing one so the nodes are
immutable and if if the code changes
then I'll just have to generate new
nodes and in my in my cache I'll have
sort of nodes for the previous
parameters but as I'm building the tree
I'll just create new ones so I'm never I
never need to like once I evaluate a
value I never it never becomes invalid
it can become irrelevant because I've
changed my code and this node is never
going to be used again
and that's a bit I'm not really doing
well in this demo like normally what
what I will what I was going to
implement with after sort of some number
of iterations where the note wasn't used
you can delete it from the cache but
that's just for memory reasons I never
need to remove notes because they would
they would change so it's sort of
building a nice in the the graph itself
is built as an immutable thing thank you
all right that's it time for lunch
thanks very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>