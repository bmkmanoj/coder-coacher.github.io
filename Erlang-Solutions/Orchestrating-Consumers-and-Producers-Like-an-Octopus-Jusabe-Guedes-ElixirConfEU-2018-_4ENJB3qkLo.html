<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Orchestrating Consumers and Producers Like an Octopus - Jusabe Guedes - ElixirConfEU 2018 | Coder Coacher - Coaching Coders</title><meta content="Orchestrating Consumers and Producers Like an Octopus - Jusabe Guedes - ElixirConfEU 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Orchestrating Consumers and Producers Like an Octopus - Jusabe Guedes - ElixirConfEU 2018</b></h2><h5 class="post__date">2018-05-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_4ENJB3qkLo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello my little friend he said my name
is Abbi I'm from Brazil if you are
wondering why I'm they took 24 hours to
get here so and this is my handle you
can find me pretty much everywhere so
it's not a problem Twitter and Facebook
github so the title of my talk will be
orchestrating producers and consumers
like octopus the title is a little bit
cyclic biting but respective to like the
talk so my goal here is to be simple and
not to be well to build a fencing
solution and just show our way to do it
not not the way up to it so if you have
a simple requirements this solution
probably will meet all your needs and
constraints okay and what's the problem
during that we are facing at our company
the name of my the company I work for is
bitch 2w and we can have a product that
integrates some sort of some sort of
sellers to the marketplace so our
requirements not to be lightened fast so
you just need to be current in parallel
most of the time because our clients are
trying to communicate with different
market places at the same time and you
need to be able to provide this to them
I'm not talking about the the the result
of the sucks because we kind of rewrote
some some components that we have in a
different language I won't say the
language because I think it's not the
case you know much that that language
better or boasted then then other
language so just keep in mind we we we
did implementation in a different
language and they need to rewrite it
near lecture to get a better performance
and before that we were not using SQL a
SS service for procuring masses and
before that we was a background library
that kind of hard structure thing for us
and then we need a persistent way to
keep the message in whatever we need the
message will be there so we didn't want
to build or maintain wrapped in EQ
instance so let's go for our service if
we don't need to care about it and then
as I said the different different apps
while we're pushing message to the ask
us and after the the message displays in
the squares and I'm using this
application called octocamo
it's just that is just a template and
just application that will consume the
or the message that we put in the SQL
service and then we need to interact
with third-party applications that is
the main reason that I'm talking here
because if you just have a queue just
consume it you don't have a problem if
you have the application on your domain
when you have third-party application
you have some kind of constraints that
that's you know you need to put your
solution around that you can't simply
that the other thing will work as you
can you know fix it whenever is possible
so our stats here will be you need a key
to have a cue and each element of the
kid needs to be consumer of course and
then each element must pass through a
pipeline we will have this massive do
some computations on that and then send
it to a bucket and I will explain why we
need to send it to a bucket and each
bucket they must work independently
if one bucket goes down or it's not
available we need to make sure that they
are working separately after the message
is on the bucket I need to flush it I
hope I won't keep the message for Evan
in our service so we need to first
whenever is possible and periodically so
let's go back to the escrow service and
in this you will have different queues
expect we don't we don't have just one
and for each queue I make abstraction to
call it here pour and this is for we
will fetch out the message from the
queue and send it consumer supervisor
this consumer supervisor will be the the
main thing on this abstraction because
after that the message is received a
grant spelling process and send this
message to to another process then each
consumer will do the pipeline that I
have mentioned before and after the
consumption
I'm going to send it to the bucket okay
that is the main abstraction in the
whole scenario that we are dealing here
so which also are we going to use first
of all as I said this is needs to be a
vanilla way well I'm not using any fancy
library that's out there if you use red
tunic you you're better suited with
something like that Bernie or whatever
but here are going to be very simple
very simple and we're just going to
change change engine server so why are
you why am I using
jinsol then then Jen's stage is because
of the black pressure back pressure
because when we are dealing again when I
didn't have to third-party applications
you have constraints in our scenario we
kind of have did it with our unavailable
unavailability of our partners so I
don't want to to keep injecting
ingesting message from the cue that I
don't are not able to process so the
back pressure provided by the change
stage is is wonderful for us you know I
will explain why so just for to note the
audience how many of you have used a
staging introduction here okay nice so
you know what I've been talking about
and then you have to create the flow and
so not the flow label module that you
have in your lecture but you need to
cater for that you you are pulling the
message every time you need it in
whatever whenever you need it
so how things start with a producer dick
Shay's is basic basically and producers
and consumers I have
after I saw the producer I will start a
consumer consumer we're plugging into
the de producer and say hey I'm a
consumer I'm plugging into you and I
want I want you to give me a hundred
events if if you if you do have please
give me then okay my producers will go
to the today ask us and pull the events
and say hey I have just ten you ask me a
hundred but I have just an but no
problem I'll keep pulling you out
satisfy my demand if not madam is not
fulfilled I keep pulling the message and
over and over and send it the the
message for the events here to the
consumer so at the particle time my
consumer may say hey I have processed to
two message already you can send me two
more
so the this thing will keep going until
I have attempted oh my my my cue okay so
it's a simple as that
give me give me advance my I can handle
100 events at the same time I'll keep
pulling and keep had in the the the
demand and try to satisfy the demand
that my consumers are asking so Chuck
shape so let's show the code the stocks
is meant to to have a lot of cold so I
tried to be very very Latin is very very
practical here because we we had done
this production almost the same this
same way our production costs a little
bit different but for the purpose this
talk I think is enough so I think at
this stage zero we have the
configuration so remember this bit to be
simple our team needs to get into this
process if he needs to consume another
cue has has another implementation I
just need to plug another configuration
so I only the name of the cue
name the handler that will take this
message and do something with it and
then say the concludes the conclusive
will be exactly the number of concurrent
process that will be running at the same
time you know to process the message so
let's see the pool yeah the pool as I
said is a Jing stage and when I need my
when I put the pool in the supervisor
three the absent at some point they're
going to call this callback they need
callback and as you remember we have
said the name of the queue and that is
everything that we know everything that
we need for the for the pool and I'm
going to put in my stage the name of the
queue and create a new queue internally
and the pendulum Andy would be zero that
at this time and when the consumer asked
for the message this this kaback could
be common so the hand of the man at the
first call will be okay the main to be
100 and so hey I'm adding up the the
current demand with dependent demand
that I have so everything will keep
going then the sense of prat the central
part about the pool is this dispatch
events so when I call the dispatch event
I'm going to do a pattern matching oh if
I have my pen demand equals zero I don't
need to pull one message from from the
queue why is that because sqs data
chargers for the number of requests with
this approach I'm minimizing the number
of time that I'm going to desk us and
and we are saving money so if the
dependent demand is zero I just do
nothing and if the dependent mean
depending demand is not zero so I keep
on the defense phone from the queue that
is exactly what this little thing here
does so I'll keep asking for the
dispatch events to to get the message
out from my internal queue okay and then
actually dispatch them so when I do a
load reply and dispatch events we are
sending the message to the consumers so
and this is the other thing here is what
we keep the the message flow going so if
I still have them in to satisfy I'm
going to pull more more message okay so
what is going to happen is going to send
a synchronous call to my changes
producer why are synchronous because I
don't want to block the execution just
put a message in my mailbox that might
in several later catch on and put the
message so this adapter here is exactly
what I'm trying to say go to that class
give give me get me some message to send
to the to the consumers so with this
strategy we are saving money because I
just go to the - class when I have them
in to satisfy okay the first step is
gone we kind of create an abstraction to
keep the cube being consumed at all the
time now it must go to a pipeline as I
said and this is the abstraction that I
have mentioned before what this consumer
supervisor is going to do is simply get
the message polymer process and and
spatch it so
it doesn't really have any logic in the
besides getting I'm going to know which
processes are processing its each met a
message so this is against a lot of code
here but everything you need to know
about this is those three boxes that we
remember to have declared a handler so
they will just pass the the Hamlet to
the message to this handler I'm
attaching to a bullet because they are
binding to the name of the cue okay
and the microkernel will be the maximum
pretty much it this was just this little
code we have created an abstraction that
can consume and can dispatch and
orchestrate any kind of consumes okay
then this is one example of handle we
have this little thing here that that
orchestrate for the tax pot dot sapling
and then say every time you receive a
message please call called my module and
this function so I'm not going into
details about the the process in the
pipeline because it's you dependent on
the task we're doing of course if you
have a cure that do one one job and the
queue that has another job
the the pipeline will be fair very very
much so again we just have created I can
imagine that can consume that queue so
each element mass to mass pass to the
well pipeline and pretty much it and
then we need to now inspect it to
another another bucket why is that
because
I have a we have some kind of
constraints about it for example we have
we interact with different partners in
marketplace and some of them have for
example you have you you won't you all
are able to make 30 requests per hour
you didn't hurt me hurt me wrong I can
just have like King on make 30 requests
for power so I need to catch them up and
and then dispatch them but whenever is
possible so with this little line here
we kind of send it to a bucket I have
explained how this bucket works and
after my consumer in and my my producer
has them they work they gonna pass it to
the pocket and the box is here represent
represented as a dispatcher because now
I'm going outside my boundaries outside
my domain and say hey I received in a
message I have done other thing I have
to do it and here's a message for you
and I will keep sending message to my to
my dispatcher so every time I a customer
message I send it to my dispatcher and
keep sailing and after a period of time
I'm going to dispatch this message again
from from my entire queue in the
dispatcher to my third-party
applications so in this flow will keep
going until until I have finished how or
the the messaging in my queue so when
I'm sitting messaging in dispatching it
periodically after some times I'm going
to dispatch zero message if I'm going to
send a message to a bucket
and I have acted that work it will have
done some distant dispatch
I'm just need to say hey I don't need
you you can go and shut down because I'm
not and I don't want to keep any
processes running in my note that
they're not that doing nothing you know
so this is the code that we're going to
add the message is that then I think
that we having dialects licks awarded by
everyone
every time I see no match to the book I
will ask my my clothes if they know that
already exists if not I'm going to try
to dispatch
but if Alexis I'm going to let this
message a synchronic at my bucket as
well if you see we have another queue
here so when you see we have asked to
ask you and we have producer queue and
then we have a consumer queue and then
we have a partner Q so the the message
keeps cascading over the kills because
we we just need to to reduce the number
of cows that we are doing to the extent
of services and the special doesn't
exist what I need to do I need to create
one
so eventually this callback could be
call it because when it started and a
new new process they need callback will
be colored and then what is the the main
thing here which is message has a
context it has an account or has the
name of the queue and I'm going to
create a new queue again and the entry
dispatch count to be 0 as I mentioned
before we need to keep tracking the
the number of times that we had sent the
iron to dispatch so yeah and and after
some time I'm going to say hey you need
to dispatch the message as I said I'm
going to send a message to my PO Box
my internal mailbox saying hey you need
to dispatch and this handle is we just
send the message to my mailbox in the
hand of info call back could be call it
whenever is possible and all I need to
do it is really dispatch the message we
don't have too much attention on that
yeah if my my limit is greater than then
then the enter dispatch they have I just
shut down my my process and nothing has
to do but if not I have done my dispatch
it is not empty and then I'm saying I'm
going to send a message to myself again
so every time it's such a message so
sexually I'm going to send a message to
my mailbox have to amount a period
period of time so we have flushed
whenever is possible so what what this
brings for us if you if you want to see
the thing up and running probably pretty
much like this we have the deep pools
that we keep pulling the message from
the queue
every time and then dispatches to our
consumers that will be our handless
every one hundred we raised it in born a
and die very quickly so depending on
your requirement if your message
consumption is really really fast that
these abstractions is not good for you
why because we have the the consumers
provider right here I didn't point them
but right here we have the consumer
supervisor and every time you link a
process to another process when when it
dies it needs to to keep track so in
your example we kind of dealing with a
third-party application that one price
may may be long for one oh one second
two seconds and when you have a huge
queue this requirement is not the case
because the bottleneck is on the
third-party applications that in your
queue consumption so and then after the
the handless is have done the job they
gonna send it to the inspectors so the
dispatcher the the pretty much would be
the fixed number of of process here they
did not live for how long so too many
long time and yeah
is this solutions working yeah we have
done this in production and we have
applied this solution for two queues and
it has been processing 17 million
messages a day
paulus and each match may generate
different requires more than one and so
they generated almost
in nineteen million cars per day in the
number of buckets concrete buckets that
are living in our classes is about 2.9
thousand thousand buckets I speak really
really fast so if you have any questions
I'm here to take it
any questions yeah maybe a real quick
one
so you said that you that you're a
consumer supervisor actually takes looks
at messages and why they didn't process
and then like just something about them
so since you using estus equation like
why are you not using like dead letter Q
so something like it's kind of automatic
like if a message fails what goes back
to you like a couple of times you can
just get yeah in this example actually
the they we have to acknowledge the the
consumers the consumption of the the
message right
so they step that we are going to
consume the message will be here at the
dispatcher level because we need to make
sure that the hearts patches the
domestic be consumed with well really
nice way that the dabbler is surely
applied here because when we consume a
message in the service is down for
example how weak I don't want to to keep
this message in my queue I just put it
in another cube that the third letter Q
and the the the thing here about the the
consumer not that the consumer was not
customary q is because we had to to
leverage the abstraction made by the the
change change it's just very for us you
just need to use it you don't need to
think you just implement that the
handlers
soon
why did you not make dispatches a
consumer as well the one before that
could be a consuming producer and yeah
we can cascade then connect the
dispatches as another consumer exactly
or producer do know but the thing is
each server is much suitable because we
just want to to create one whenever we
want because having accounts that you
know you know our clients our clients
eyes are on accounts so everybody to be
tighted to one accounts so I don't
really think that is a good approach to
connect the the consumers to the
dispatch is being a customer because
they are not you know part of the
pipeline the just receiving the message
and stardom and in sending the message
over the wild average after some time
you know okay
forgive my final round of applause thank
you
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>