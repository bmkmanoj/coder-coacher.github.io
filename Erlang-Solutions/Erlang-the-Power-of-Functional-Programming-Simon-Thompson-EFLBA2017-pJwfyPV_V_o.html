<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang: the Power of Functional Programming - Simon Thompson - EFLBA2017 | Coder Coacher - Coaching Coders</title><meta content="Erlang: the Power of Functional Programming - Simon Thompson - EFLBA2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang: the Power of Functional Programming - Simon Thompson - EFLBA2017</b></h2><h5 class="post__date">2017-07-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pJwfyPV_V_o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">only after that unless they are empty
Arthur Murray on society in that way I
guess fujita yeah mucho various
knowledge zita mela neutrals young once
indirectly not if Simon's also selective
organization from scenarios and agenda
Fukakusa Akio by Oneiros half people
convene to see Emma this is somewhat of
a mozillian again versus Illuminati is
really the professional or in the owners
in pocket is a considerable ego in
electric inertia Lara and with the
attorneys are certainly in the path of
confirmatory dog suppose a human's
overlooked office at our hand or if it's
allowed in the booth
okay so obrigado D the feather or God I
pronounce it now we should be a novel
faha Portuguese and italiana fo fanna
English it is dispensing okay so I like
either and the reason our language so
move is so popular and is so heavily
used is that it's a concurrent fault
tolerance reversed
distributed programming language one of
the things about talking about
particularly balanced talk at the end of
the day is going to tell us
some of the benefits of those features
of Erlangen whatever is as well is a
functional programming language and what
I'd like to do today is talk a bit about
some of the features of functional
programming that are perhaps a bit
beyond what we do when we first learn
functional programming but are useful
tools in our toolkit and so I want to
talk that's what I'm going to do today
I'm going to talk through a number of
ideas a number of examples the code I'll
put the code I'm going to show is up on
github I've put the link for that later
on so it's showing you some ideas of
what people do with functional
programming once they move beyond the
first stage okay so when we first learn
Erlang we discover key things we learn
we start to write functions using
pattern matching and that's such a such
a benefit when we see it we don't have
to write accesses we don't have to write
discriminators we can just say in this
case do this in this case do this and in
this case when I've got these components
to do that so you start matching them
recursion is the engine of repeated
computation that it's interesting we're
running our online course at the moment
and for people coming into Erlang from
other languages particularly from an
imperative background recursion is still
seen as as a hurdle but once you get it
you get it big time I think here you can
see I'm not using tail recursion but
that's thing as it were-- the gateway
drug into our into what goes on in doing
things in our a business encode for maze
salting which you can find in the in the
repo
but what are they offer to the thing we
learn as well is that we are able to
model inside Erlang all sorts of
different data types now I think there's
a there's a misconception that lying
I like types are not as strong is a
technical sense the answer's strong but
there's a misconception that behind
types are not as expressive or a bank
data is not as expressive as in other
languages because that's not the case
it's just that we build things
explicitly so if we want to build a type
that represents shapes we represent them
explicitly as a tuple tagged with a an
atom but we're able to express express
the things that people can express in
other languages like Haskell one of the
things I come back to at the end of the
talk is to try to make the comparison
between what we do in Erlang and what we
do in Haskell but of course the other
thing is our variables are immutable we
write an assignment there it's not an
assignment it's simply a naming of a
value and that's crucial until 20 years
after Java was launched people in the
Java community are beginning to
understand why immutability is such a
crucial thing is they can then write
much safer multi-threaded code ha 20
years but and I guess another theme of
this is how long it takes for new ideas
to come through in programming we think
computer science moves computing well
this is a very fast pace in fact some
things we've really really rather slowly
and I'll come back to that and the other
things we meet we meet tail recursion as
I said that's the engine of writing
iterative programs and we meet some
standard higher-order functions where we
write things using filter and concat and
then we've got a nice syntax for it
using this comprehensions and we can
write can write our own functions which
I'm doing there
so that in a sense I could stop that and
that is that will be enough of a
functional language to write a lot of
the things that we do but for the rest
of the talk I want to do is show how we
go beyond that and I think the crucial
thing is um if you look at the types
that I'm contains it has standard things
like numbers and atoms and on but
functions are there as a type so the
thing that gives it a huge amount of
power to functional programming in
general is it's the power of thunder now
this is a quote from three big surf
artists Walter Reed I put the slides on
the github as well this is a quote from
Jones runs history of Erlang and it's
interesting he said in here they tried
out David originally brought a lie in a
in a prologue until the prologue but
they say what started as the addition of
concurrency to a logic language ended us
with removing all the prologue features
and adding many well-known features as
functional languages the influence is
clear Sarang is functional but I think
the thing that I want to I'll be
concentrating on now the rest alleged is
this keyword fun it's a nice column in
English we're going to have fun thank
you
so we're going to have fun with
functions and be pleasing to learn that
you thing to appreciate is that
functions and you're not just in the
language to pass into things like this
math and so this filter but there are
pieces of data just like any other piece
of data Christmas strangely who is was
one of the pioneers of understanding
semantics of computing languages and
under language designer as well coined
this phrase functions are first class
citizens you can do with functions what
you can do with any other sort of data
but what's what's special about the
function o is that this is active data
if you like it expresses some sort of
behavior a function does something your
list it a list our a value is a value
our number is a number but a function
will do things it represents computation
in some way so they are special columns
of data because of that and I want to
give an example this the simplest
example I can think of of using
functions to represent our represents a
piece of data is the game
rock-paper-scissors which I guess
everyone understands I can explain it is
like two people play and simultaneously
YouTube's one chooses one of these
things and other chooses one as you then
decide what result is rock wins get
scissors because a rock will blunt and
scissors scissors when against paper
because they can cut paper paper wins
against rock because it can wrap the
paper the rock up
so it's a simple game two-person game
what is a strategy for playing
rock-paper-scissors
you can play randomly you can echo the
echo somebody's last play you can I've
come back to to what these things need a
bit later on there are various things
you can do you can do some statistics on
on what your opponent's has done but
what it is if you look a bit deeper its
we choose what to play depending on your
last moves or in fact we can depend on
the whole of your moves if we're doing
something statistical we think that
we'll okay you've done you've played
Rock more than you play the other two
I'm going to guess you're going to play
rock or in the future or perhaps elastic
you know so what we are here is a
strategy is this choice we are choosing
depending on the history of our
opponents movements now what does that
mean in practice that means that we have
a function from the list of plays that
our opponent is played to what we play
next so in a natural way of representing
that strategy is as function
is with the single Alps our type of
place is just a list of single players
so strategy isn't actually one of these
things but what's nice about that is
that we are we're able to represent very
importantly what these different ideas
lead so a random strategy or we just do
something rather an echo what under here
is I'm building my list so that the last
play of the previous player we observe
the pre display of the other of the last
of the other player is on the top of the
list so I'm building the list like a
stack if I echo on and I have a list of
with who's head of X then I just play
that back so if you play rock last time
I play rock this time I'm sure it's a
terribly good strategy for people who do
it this is the nice one this is a really
good if you want to you want to make
money playing rock-paper-scissors this
is the place to do it
don't go I guess not but somebody else
who's in the room I suppose in general
people think that playing randomly means
you never repeat your last move if you
look if you ask people to look at
pictures of random data they will
normally take looking at random dots of
of black and white pixels they will
choose something which is not quite
random it will be smoother than random a
purely random block of black and white
pixels will have some quite big sub
blocks a white and a black if you're
choosing sequences of plays you'll have
quite a number of repeated plays where
the same the player plays are saying
play more than once but people's
intuition is somebody won't play the
same move twice if that's the case then
you can play not to lose because what
happens
if the last time round the player played
rock you can assume this time they're
going to play paper or scissors so what
do I play I play scissors because that
will be paper and draw with scissors so
I can always avoid losing by betting
that my opponent won't want repeat and
often they want the D sounds not
important but you can tell you can go
further are part of the URL but they
don't talk about it
um but the point is now we have
represented strategies instead of
expressing them as atoms or ever there
at their active behaviour we can now do
perform an interaction with a with the
strategy so here's a little game that
plays you feed in the strategies of
parameter and it's um what sex is here
oh yeah I've got yeah you feel it this
is the the the tail recursion so you
feed in strategy or Washington it will
play it will play against input so your
view into input interactively but it's
nice that we've exactly pulled out that
strategy and we can put any any game
player to notice feed it whatever
strategy then I so functions and
represent active behavior and we could
easily plug in any other strategy we
wish just by writing another functional
description of that strategy but now we
think of functions as strategies as
functions we can begin to do something
else and not to start combining
strategies together and this is what
people call a Combinator were combining
functions together to give us another
function this is really where you're
doing functional programming with
functions of data the functions are data
so you have functions that take the
strategies as input
if your strategy as output here are
three things he might do you could just
build a new strategy you could choose
randomly between the strategies you got
already you could apply them all and in
a particular case and choose the result
that comes up that is most popular from
all your set of strategies or you could
replay each of them on the history that
you've got so far and choose the one
that has best predictive power over the
history so once we start thinking of
wrapping up behavior as a function we
then start thinking of writing functions
that work over that and I think that's
one of the um that that's one of the
insights that I wanted to you to go away
with and you can see here this is this
is floating it's it's simply a function
from a list of strategies to a strategy
so the take-home from this bit of the
talk is okay it's a toy example but what
we get by representing strategies pass
functions rather than just an atom for
random Latin for no repeats or whatever
is that we have complete generality we
allow ourselves to have a potentially
infinite collection of strategies and we
go up this one level which we start
thinking about how could we put these
strategies together just as when we
start writing lists we begin to think we
start writing function just working over
lists but we see the instruction and
build higher-order functions like map
and filter and so on we get these
combinators that combine strategies
together so there are three natural
using functions of data it's a really
nice thing in our armory
but you could say hi it's a toy example
all of these in a way a toy examples
because they fit on the side they fit in
a small file there's something that you
can understand but the ideas do scale up
and for example here awesome just before
I moved up there is a wonderful website
which is the world
rock-paper-scissors society this is not
a spoof website this is a real website
it has also it's got stuff for game
basics is got an advanced section if
you're interested in this stuff it is
fascinating well to an extent there's
really something going on as their
website would visit sort of passive
aggressive stuff about their web they're
webmasters are not being very good it
does look better but obviously took the
Masters a lot of playing together but
it's really into fascinating site but
the the insight is on do please think
about even though even a simple thing
like a strategy as a function and here
is the this is a github repository that
has the the code I'm talking about and
I'll put a couple the slides up there
when we're finished
okay so that was a toy example small
example how does it grow up well in the
phrase one key example that you will see
the I am I would imagine you all the
third on but maybe not it's the idea of
planter combinations what we're doing
here is it's a similar inside what does
the planter do if you think of it as a
an operation like this it takes some
text and it gives you a couple of
outputs it gives you a parse tree of the
amount of text is managed to to pass and
this would being functional here we're
thinking of this we return the remaining
text so as a function no side effects we
take some text and we get back a pair of
a parse tree what we successfully parts
from the beginning of the text plus
there
the text so we can represent a partner
as a as a function so here's some
surveilling code I'm using quite heavily
using type types and specs because it's
really it's a very nice way of
documenting your code right the types
and specs feed those into title and it
will check whether you have type in just
gives you a nicer interface to dialyzer
the dialyzer itself so parsers are
functions that take a string and return
a pair of abstract syntax tree in the
string and then for example applying one
part that then another becomes this
function sequence takes two parters
returns a parcel so this is the this is
the first if the canonical example
people talk about in a score but also in
lots of other languages of writing using
functions as using function to ear anger
to represent so now what we've done here
is represent deterministic classes it
might be that a parser is
non-deterministic it might be it kind of
Tom it could potentially read all from
the beginning of the string for example
suppose you're trying to to part a
number you might read the first digit
turn that into a number you might be the
first two digits and so on so you
potentially have a number of passes each
of which has a corresponding remainder
of the text but with your mother like
just as easily as a function we take a
string and we return a list of all the
results so the way that you represent
functionally something that is is
non-deterministic is the same I don't
care which result I get I'm just going
to take it all so um we're taking string
and we get back all the possible passes
so that will be an abstract syntax tree
with one string
abstract syntax tree with another and so
on and sequencing is still the same type
signature we still in sequence two
palaces together we have to feed that
not the output all the output potential
outputs from the first class as inputs
to the second each of which will produce
multiple outputs and then squish them
all together so this is a bigger and
more substantial example that serves to
show how functions get used in to
represent complex data so it's a real
example there are implementations of
partha Combinator's i guess they started
in a school that the number of libraries
in haskell would use them they also in
Scala
you see them Oh camel Olivia I can find
at least four on the Dom on the web
there seem to be two on github which
have a single contributor it still is
slightly worrying but there are two
which are are tuitions they use that
they fill out to compare each other on
compare themselves with the other
library in order to explain why Lotus is
better so this is something that is used
particularly in the Alexia community for
building classes it's a practical
mechanism for doing that it's a more
constructive way of doing things than
something like yak which does everything
underneath the under the hood it
produces a gate that typically produces
over a efficient parser but it will
everything is in front or isn't this you
explicitly construct through a set of
function applications that mirror what's
going on in your grant you explicitly
construct the depositing you need and it
hints at something more general for the
child I'll come back
later on okay so where we are we've seen
this just taking function seriously
taking fun seriously if it's a new way
of representing data now this is I guess
this is something people in your world
have done don't you know the nonnamous
objects um perhaps it's thinner it's so
much easier here you get you simply have
a different kind of input you process it
and produce this different kind of
output that you're still writing
functions to okay now that the just
going back to the example here all of
the things that that makes this
practical in a language like Haskell is
that um you know what this does is
produce the list of all the answers you
don't have to look at them all what do I
mean by that well put it another way if
all we're looking for is one class we
should perhaps think about they think
differently about how we do evaluation
we should perhaps think of evaluating
that collection of all the passes on
demand so what I want to do in the the
next bit of the talk is explore what
that means and how we can join with them
ah and we can program that how to model
that in our so let's think about
evaluation on demand
as your business I think when I say you
know like I probably be is elixir as
well but I'm not an elixir expert so if
I say something that is untrue about
Alexia please bear with me
function evaluation in analyte works
this way if you have an application of a
function to set a set of arguments you
first evaluate the arguments then you
execute the body so if you want to write
a function like this which takes a
number and said if that number is bigger
than zero return whatever the second
argument is otherwise return the third
argument it sister else if you like this
a function or it's a special case with
an else it's not ideal writing that in
argh because what will happen you will
pass in something for them the first
argument evaluate that to a number you
pass in what to do if that number is
zero if I like that what to do if that
number isn't zero oh if only only us as
well so we have that sort of restriction
we are evaluating arguments before we're
evaluating the body there's something
wrong with this it's simply an
observation it says that we can't as it
stands right a function like that we can
do something with macros and I'll touch
on matters later on to do other things
we can write something like that using
the align macro system but in general
arm macros are limited
I had this bizarre bug in something I've
got so badly show up
and against the wall I realize it was
just a limit Oh eating a Makarov ugh
there's most difficult to debug
so one should use them or share some
sparingly but anyway we evaluate all the
arguments before we evaluate the body
the other thing we do is that we fully
edit value' eight the argument here is a
function don't ask me why but what we're
doing is taking a list all I'm doing is
adding the first two numbers in the list
we'll see something list examples but
later on which are more make more sense
but I have an argument which is a list
I cut a match a and B and the remainder
the way evaluation works is I fully
evaluate that list before I return those
two the sum of the first two values so
not only do I evaluate arguments before
the body I fully evaluate so there is no
gray there is no ambiguity there's no
gray area I do all of the arguments
completely so the question is can we do
something differently and we make a line
do something differently
well what argument is you you could say
well just throw it away and use Haskell
but that has an awful lot of
disadvantages so I think that wouldn't
be a good idea and I think there are
people in the house look I mean there's
a debate in a score community which is
it resolved about whether it's is what
happens in a circle it's lazy
it supports these kind of things by
default but then the compiler has to
work very hard under the hood to work
out where it can be strict where it can
do these things
because it's much more efficient in
terms of time and potentially space to
do this this sort of evaluation to have
to do all sorts of analysis work inside
the compiler which is not necessarily
what we want so
but let's see whether we can make an eye
a bit more lazy a bit more done the key
here is this oh no no you may well have
seen this before but it's it's nice to
see it's another example of having fun
if an argument is a function then it's
passed under valuated so if we want to
pass some stuff to a function we can
wrap it up like this so you call it
equal call it a Suncor a closure so we
got this stuff we turned it into a
function that takes no arguments and
returns stuff and then if we want to use
it we just have to apply it to no
arguments so this wraps it up and this
if you like this suspense computation
and this forces computation it gives us
a way inside our like and you were using
with focusing in here but precisely
because of the way functions are handled
so we're using that to give us some a
different way of handling evaluation
okay so let's look look let's do an
example
let's build streams you know so what do
I mean by stream well it's something
where we've data is flowing in perhaps
getting data it's coming in it's coming
down the wire we're not quite sure when
the next piece is coming in it's
something that never gets you like never
gets fully evaluated so we pull things
off the stream that's we also want to
put things on to a stream so in one way
it's a bit like a list but in another
it's we don't ever want to evaluate it
completely so here is um here in our
code for building
and unpacking the street
here's our construction it takes a first
element and the rest of the string and
it puts them inside a thought it hears
our stuff and we're turning that into a
that into a function
what we do if we want to take the head
of the list because that that this is
going to be a function we apply it and
then we reply if we get back we get
inside there
we take the head when we apply here we
can get in time so what's wrong with
this anyone like to tell me where
there's a mistake in this
what is the fatal flaw in my definition
maybe my new innovative job or letting
the whole thing when I sorry when you
were relating and here when I do not see
Heather unveiled in hitter tail and you
recall thing
well this the distinct remember this
thing itself might be another three so
that's not a problem of evaluating the
whole for you just unpacking that to
whatever is in there can you see do you
see what the other what the problem is
well let's assume we could make an
expert let's let's assume they never end
the promises what happens when I call
the columns and there's a stream there I
fine you ate the arguments which I don't
want to do so we'll have to do is make
it a macro
if I make it a macro this just gets
substituted when I see a cons I just
wrap it up in a function I don't
evaluate that X's so Colonel elderly
micros allow me to write something that
looks like a cons but in fact is just
it's not a functional it's a macro code
but all this does is substitute whatever
is in there inside your code but if I
did this I told calms it would evaluate
that so that would mean when I guess
history I have to I have to evaluate it
all of the three already which defeats
the purpose of me building strings in
the first plane so just one simple of
one simple change allows me to to build
I now build these things with this macro
it just gives me it wraps up whatever X
and X is whatever that stuff is inside
function call and he only gets unwrapped
when I call head or tail isn't that nice
I think there's this okay let's let's
build some examples um here's the street
it's the streamer ones so ones is just
ones one stuck on the front of the same
stream now even much if that was a cons
what would happen I call this equal to
evaluate at oops I go around forever but
that's not
I'll show you I'll show you in a second
you can think of this I'll come back to
this you can think of this as a little
network here is once and it's defined by
taking the output and feeding it back in
but sticking in one in front of it
so once the whole thing is got by
putting one on the front of the whole
thing you can see that that will forever
give me whatever I take from that will
be a one and it will still be more ones
where that came from so that's given as
those oh we tell the world numbers we
could build numbers from n we get by
starting with N and then carrying on
with n plus one we can do the primes now
this is what for the scissors
Eratosthenes ah what does it say just
briefly it says you get the primes by
sitting all the numbers from 2 what it
says - it takes the first number in the
in the stream and removes all the
duplicates of that number in the
remainder of the stream so it says say H
here would be 2 and then what we do is
stick two on the front and then cut off
all the multiples of 2 in the remainder
and sieve the results so what cut do
does is remove all the multiples of 2
and then we do assist versine lb3 to
remove all the multiples of 3 and so on
so this gives us a an infinite stream of
primes and what else this is more fun we
can write to Fibonacci numbers like this
first number of zero the second number
is 1 and then what we do is sit together
what we've got already with the tail of
what we've got
really it'll be doing is we're adding
number tips before and the number one
per floor and that gives us so rigidly
together 0 here the first thing here
will be 0 13 here will be one for the
first thing here is 1 and then the next
thing will be adding 1 and 1 to give us
2 so there we've got and this is all
this looks just like list programming
except that we've got that magical
question mark at the front so we're
building these suspensions rather than
on rather than building real lists and
then when we evaluate we get to see
what's going on and you can see this as
a network if you like here are Fibonacci
numbers B is the tail of the list what
we do is take the fifth and the tailor
fit and add the pairwise and stick them
back in the list so we get 0 and 1 and
then 0 and 1 gives us 1 and then 1 + 1
gives us 2 and so on so we're able to
write these sorts of stream programs and
under the hood what we're using is
suspensions these functions take a the
NTU the empty argument to the stuff
that's inside and then understanding
when we need to let me try and do a demo
this is always a bad idea
I want the screen so you can see here I
have um I have the curve this is the UM
certificate sorry I want if I can get
rid of that Oh show me a bit bigger
again so you can see this is precise of
the code I showed you earlier on
we've got comms defined as as this that
is macro that replaces a cool that calms
with this thing that wraps the stuff
inside assumption cool here's my ear it
is the function which of course doesn't
work properly
but um we're not going to use that and
here is head what hand does remind you
we take this they come the stream which
will be something like this we apply it
to the MT own argument that gives us the
stuff inside we putted matched up and
you take the head and simply to the tail
and here's our ones leg so here are all
our definitions now um what can I do I
have a little dizzy function which just
prints out the first an alliance so
let's just go to L let's confine our
stream should picked apart anyway
so let us do what we do is string what
piece does is it just it prints out the
first and elements of a stream so let's
say stream primes see and say 20 oh yeah
they were getting the first 20 primes
you can see that it's taking it took a
bit of time when it got down there and
something will come to a bit later on
we could do a similar thing with Finn's
and it's taking some time here this is
um this is interesting this is crucial
if you like it is it's not doing this
very quickly what I said we got is
evaluation on demand I should I choose
the wrong concert venue it so we've got
we have a stream library which is not
terribly efficient what are we going to
do let's go back to our presentation and
take those
Oh
whereas I don't want to suppress these
through this much beauty now why was I
sent it let me stop where I stopped okay
so we were looking at look at these
examples and you could see that we were
producing Fibonacci numbers but he was a
bit slow the problem is for example
we've got a call to Fitz here and we got
a call to Fitz en we probably keep the
gating conversation I'm not trying to
optimize this but there are deeper
problems than that let's let's try and
explore those of it we're guessing what
the blind nice circular circular
computations arm and but we are getting
this repeated recomputation how much
longer than I got yeah Timmons okay fun
okay well I can just carry on talking
that's the form of negotiation so I
talked about evaluation of demand so
what we were getting was by building
these arm by building these these
closures by wrapping up our stuff inside
a function call we were getting the
effect of not um not evaluating
something until wanted to so we could
build these infinite lists you could
take a head of an infinite list without
down looking at the tail so we we got
half the way there but what we haven't
got is what's called lazy evaluation and
that's another dimension in lazy
evaluation what we try and do is ensure
that each argument is only evaluated
once or at most once we don't care if
it's never evaluated but we don't want
to reevaluate
so how do we do that well oh let me also
correct this should say memorized it
shouldn't say memorized apologies the
voice bar down anyway I think memorizing
results - ok - can be useful for you've
got exams or whatever but it's not the
same so we must be sure that we keep
erect order results so we have to do
some sorting we have to do something a
bit cleverer but oh for goodness sake
isn't that what the compiler should be
doing are we do we really want to do
this in like are we pushing things too
far
well maybe let's do it anyway we clean
up my period we have to manage how
results are stored once we've evaluated
them so simple enough to reach options
and I'll talk about the first that I'll
leave a second for you to look at they
look at in the repo if you want to we
can use a DTS table good old impure
functional programming to the rescue we
can use that to keep track of results or
we can actually do this purely
functionally though it is we have to
change the way that we represent our
streams and that's it's worked through
in the in the repo by modeling the store
functionally and passing it around
explicitly as a map effectively arrow
through all our calculations but
threading up through when you're doing
things later they is a bit of a
nightmare
but let's let's look at ETS table stuff
so what we do well what we do is we
effectively do what's in this picture we
have an ETS table which soars to sorts
of things it tells us where the next bit
of free storage is and the things that
we store in there are either a thunk one
of these functions she's wrapping up
some stuff or we store the results of
evaluating that
so we have references into this table
and we use this 0 slot as a place to to
store where our next free slot is since
it-it's a simple representation and okay
cons becomes a tiny bit more complicated
what do we do when it's still a macro so
we've got the same code this is nice but
the same code as we have in this for the
streams but the macro is doing a bit
more work under the hood what do we do
well we update what the next references
we are want to it we insert our thunk
our stuff wrapped up inside a function
at the next reference and then we return
what's the result of the cons the
results of the cons is now a symbolic
reference to a place where the result
will be stored rather than the results
itself so I'm building rafts into our
line using ETS table if you like though
I could do it purely functionally see
the subsequent stuff so with that we
pretty much get what we want
well we have to change head slightly as
well what has head to head now has to do
another switch head you look in the
ETF's table if it's a pair then you just
return the head that's fine because it's
already there in the table if not you
better evaluate it stick that value at
the table where it belongs and then
return the head of that value so it's
one of these you take it out and return
replace it with one of these by applying
F to the buy time that's like working on
what the stuff is inside axed
so it's again just going back to the
original topic of this it's about using
functions in a in a creative way and
then with that we can um we've got the
same code or we get efficient started so
let me just briefly I have got another
demo oh yeah here we are
I got yes well I don't have exactly the
same code and this is the last bitters
are not tying when I built this coms I
know that it's going to be put in the
next reference so I make the thing it
refers to an explicit arm an explicit
call to thee so that the the quarter
comes here is actually the same as this
I'm tying that not so okay
I'm getting it's a bit grubby it's a bit
lower level but we get the efficiency we
want and we could do a similar thing
with um with Fibonacci but we transform
that a bit we build the same cons but we
have these its contour to those two reps
so we know this stuff and now we can do
ginormous Fibonacci numbers memorizing
this way so again it's a we get full
late evaluation we used impure features
but we got a smooth transition perhaps
because we don't have time you can play
with it it sits there in the reptile arm
so you whatever leaves clover doing this
with an explicit store will I chose one
color here what we have to do is change
our functions so that instead of taking
input to an output they take two inputs
the real input and the store before you
do the operation and give us two results
the real results and the store after so
is threading that store all the way
through the computation for example if
you're pulling out the first n values
you have to take the store here pass it
in
it's I defected and then you use the new
version they're not so nice and making
it work is a bit more complicated but if
you like to see it's a bit like circuses
used to have dogs or keel man's legs
this is about submit my girl I'm walking
on its on its hind legs getting getting
full declarative lazy evaluation inside
early right
I thought cover got enough site so I got
it early as for me roads are offline I
clearly did I'm in out slides so I don't
need to tell you about a more general
mechanism for memorizing but you can use
ETS tables for memorizing values of
function and I said in the abstract I
was going to say a tiny bit about
dependent types and this just notches at
it this is a sort of this is a way of
doing some memorization in the data if
you like what I'm building here are what
your vectors which are lists which have
carry their their size with them and
then if I want the length of a vector I
simply take the first component so we've
got some examples there if I apply the
join I have a join a vector version of
the join function or about what join
does it takes a list of things in a list
and separates them with separator so we
get at the length of the list is twice
the length of the original minus one and
then what we can do is define a macro
which returns the right result so again
it's playing with function for macro but
I'm running out of time so I like to
conclude I'll I got two minutes to
conclude yeah okay
functions are flexible and powerful I
hope you think that we've seen a lot of
example strategies for the simulation
simulating different sorts of evaluation
that's good pure molecule effects is not
that easy so you see in the world at
school things like mud ads on our
transformers effects and so on they're
still pretty complicated um but they are
some nice design patent and there were
hints of those in here and I'm sure that
we will see what I've ivories and so on
coming into elixir and curling I'm not
going to talk about that a final point
everything I talked about was using data
type data uh people of thirty years ago
and I'll be equally true in Haskell what
has changed is the way that people deal
with times so the old lifetime system is
perhaps around where things were twenty
years ago a school type system has moved
on you can do should still know the same
things the values are exactly the same
functions are very tight and so on all
the data you see is well understood a
long time ago and that point I'm going
to stop thank you
15:42 quick question students what or
they're fine
so my question is how does airline get
along with very large mattresses and its
operations very large matrices is an
operation between masses which deviation
and other I think colleges use which use
a library in a different language
I think you should use the right tool
for the job there's no point in there
people have spent decades of time
efficient for the useful time don't use
the use for travel that's today's
takeaway message Willa yeah thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>