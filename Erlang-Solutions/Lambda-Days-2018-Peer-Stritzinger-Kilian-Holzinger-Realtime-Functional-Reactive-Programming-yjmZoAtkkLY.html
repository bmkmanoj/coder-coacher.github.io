<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2018 - Peer Stritzinger, Kilian Holzinger - Realtime Functional Reactive Programming | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2018 - Peer Stritzinger, Kilian Holzinger - Realtime Functional Reactive Programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2018 - Peer Stritzinger, Kilian Holzinger - Realtime Functional Reactive Programming</b></h2><h5 class="post__date">2018-04-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yjmZoAtkkLY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we're talking today about a very
reactive hard real-time add-on
programming so you probably heard about
function reactive programming and you
know what the along may be and you heard
about hard real-time and you know that
Ellen is soft real-time so there's a
discrepancy here and we are talking
about this today so that's me and that's
Killian who basically built the demo and
did a lot of the code of the talk and
we'll do half of it but I think I'm
gonna stop so why do we want hard
real-time in the add-on so we kind of
build these embedded systems and use
Ellen embedded systems because like
Ellen much and if you use a long an
embedded system that's very useful
because you have a lot of properties in
the airline that are very helpful to
build embedded systems especially
Network admitted systems and so this the
system that you see here that's a little
controller node and basically the actual
board is just in the upper part the
lower part is just cabling so it's
actually smaller that's that's that's
effectual demonstrator for Bosh where
they do transport systems so they do
convey both brought you a little video
let's just run nope
yeah there should be a video so this is
a conveyor belt system it's moving no
only you see it I I don't see it here so
this is a conveyor belt system like a
medium-sized thing so you have these
little pellets running around and you
have RFID tags on the pallets I don't
know when you see the RFID tag now so
basically you identify the product and
then you decide what to do and to move
it to a different direction or to
actually stop and work on it this is
this conveyor belt systems are huge like
spending a whole factory and kind of a
natural way of actually controlling
those things the movement of the of the
of the whole parts and also the RFID
system it's in a distributed system
manner because the best way from the
cabling and from everything else and
also from the price point is to have
lots of little nodes close to the
locations sharing sensors to a
distributed system with this and this
actually what you saw here was
controlled by 15 little n nodes on
running a little board it'll embed
aboard so this is basically how this
started and that's the motivation for
doing hard real-time things because
these these scorable systems there's
certain movements need to be in time I
mean there are some movements that when
you feel late it's only slow but certain
things need to be in time or otherwise
the pilot Falls of the thing so bad
things happen so goes beyond the end of
the conveyor belt because you didn't
stop it or whatever or crashes into
another pallet or whatever several of
bad things happen if you're not in time
and allen software of time kind of is
almost good enough but not for all the
applications so this was just as a start
of the island system running on a hard
real-time operating system which makes
it already more hard real-time than it
is if it's run on Linux
on the raspberrypi because the Linux
basically brings your Allen system and
then you not getting anywhere so the way
of the the kind of real time that we
have here or that's actually I'm behind
with my slides so the kind of hard real
time that we get here is kind of event
based it's not like a closed control
loop which we do periodically very
quickly things to control something we
could do that too but the the
application space we have is a certain
event happens which we detect by a
sensor like something comes by and we
want to stop it in time and not fall off
the conveyor belt and so in order to get
towards hard real time in in the oven
the first thing as I mentioned this you
need a hot real-time operating system
because if the operating system messes
with your hot real feminist and nothing
is gained so what we did like a few
years in the past and we ported Aaron to
autumns operating system which is a hot
item operating system we'll be talking
later about this so this is all running
on this stake so that basically how this
looks in the inside we have the a man
code that basically runs in there long
runtime the VM and the little box below
the blue things and that's the actual
items operating system but it's an
operating system misquotes
we also get to that because it's just
linked it's a very thin between hello
between Alang and and in the hardware so
the hardware is below and we can use
sniffs and port drivers to directly talk
to the hardware so hardware's accessible
like hardware registers are accessible
in an if for poor driver to the to the
Elan code so we can write very thin
layers of C code to actually get to the
hardware a few a little bit like
explanation like what's actually soft
real-time in hard real-time there's lots
of definitions and there's also firm
real-time and all kinds of real-time if
you if you look at like an event based
system that like you get a starting
event and then you need to do some
processing and to be done with your
processing and have your actions
happening
at the certain deadline so every thing
has a certain deadline where you need to
be done if it's a soft real-time system
but both basically have the average
execution time which is lower than the
deadline but a software system can can
occasionally get above the deadline
really and that's not like a bad thing
like the the system value basically
drops like continuously when you go I
mean it drops pretty fast if you say
anything real-time it's not like yeah
okay you can slow down until the user
gets bored and goes away or whatever so
that's not what software means it's a
normal system a non real-time system but
it's very rarely going over the deadline
but the hard real-time system never goes
over the deadline so going over the
deadline is actually a failure how would
you want to achieve this in a functional
dynamic language like I learn with
garbage collection and all these little
obstacles to hard real-time mess so
garbage collection is a problem because
it can happen at like arbitrary times
and actually mess with your timing ellen
is pretty good at that because it's
garbage collection is only per process
or have little heaps that it's garbage
collected per process and actually other
processes can do some processing while
the garbage collection in one process
happens so it's not that the system
standstill but if you are in this one
process which actually wants to react in
time but then you actually want to avoid
an arbitrary long garbage collection so
either you want to have some real time
nests in the garbage collectors or a
different kind of garbage collector they
exist or you want to basically get the
garbage collection out of the way and so
the the way that we actually
conceive this is that if you do a
vampire system the scheduling is
deadline based so and we added an
additional deadline so we have two
deadlines one deadline so the green bar
is basically our processing time so
before the green bar we get we get an
event like a message because they are on
this message base we get an event like a
message and in the green area we need to
do all our processing and all our
actions to the outside world
send all the messages set the hardware
turn the motor on whatever what turn it
off to not fall off and in the blue area
basically this is our recovery time so
this is the time until we are actually
able to process the next message and
usually when both systems have pretty
decent recovery time so their recovery
time is usually much longer than the
actual action times you've got a very
quick reaction to an event but the
events don't happen that often so for
example if yet they have these little
pellets coming by the next pallet will
not be showing up in a millisecond
because it's not physically possible
that it already is there when the ones
left so if you look at the second
deadline what what you define by that is
kind of a maximum message right that the
process can take
because like the second deadline is the
period of the maxim message right and
that's actually a useful design
parameter if you design a system because
you can actually throttle the maximum
message right if you have some inputs or
you actually make sure that you don't
overdo this and the green one is baked
basically the reaction time Direction
deadline and what we do is we put we put
the garbage collection in the in the
blue area so once we're done doing
processing we always do a garbage
collection and we can use the normal
garbage collector then and the garbage
collector needs to be done by by the end
of the last deadline and since basically
the processing in the hard real-time
system is kind of limited and you know
that you use a limited amount of heap
this garbage collection actually is also
bounded because it's always the same
same every round you go around your loop
you produce the same variables and you
do the same kind of garbage collection
so this is not the fastest way to do
things like the best throughput thing
but there's a discrepancy if you do a
hardware time system you never go for a
throughput you go for a real-time this
this there's a cannot have post usually
it's very hard to do both high
throughput and an hard real-time so
that's how it would look like if you
have like two processors like the two
lines or two processes being scheduled
by an earliest deadline first scheduler
which is one of the ways hard real-time
gets scheduled which is very fitting for
this use case so basically it sorts all
the processes to whoever has the next
deadline and runs the process with the
highest priority that has the next
airline so it longer there so the degree
in the green area and the second process
can actually interrupt the blue area in
the first
he'll want to because the deadline is
longer so yeah that's how that's how it
would look like from the scheduling so
what we in addition want to avoid is
actually that along is actually getting
a new heap
like because the memory allocator of the
operating system might have unbounded
time it's not bounded it needs a search
run for a for a right sized memory so
what we planning to do in the in a long
time so this is all things we want to
actually add to their language mmm I
have to say we pre-allocate the heaps
you can do this now you can basically
tell a process in the beginning when it
starts like yes let's start with a heap
this size and to avoid getting any
memory allocation thing we basically
pre-allocate another heap so we have a
dual dual dual hip thing and we do
garbage collection garbage collectors a
copying one so it needs basically two
memory areas where the one it copies
from and one copies two and we basically
always copy from one hip to the other
and then back again and to the other so
we never need a new hip area and we also
probably want to limit their message
mailbox either by a system design that
we actually make sure that there is no
more there's no more than a certain
number of messages in the mailbox
because message mailbox size is also
getting like variable timing in there
and we buy by doing that we can actually
use the normal garbage collector and
then the question is what do we actually
do when something doesn't work because
it's always a probability that some bad
things happen on your systems and you
miss your deadline and since in a hard
real-time system actually this means
probably that your state is kind of
corrupted which makes you kind of take
too long for processing and miss your
deadline so this is an error like the
usual let it crash error or let it fail
era of Alang so we let it crash too and
take care of the supervisor to actually
restart the subsystem so we have a
glitch in the system that it actually is
not working for a short time but then
able to recover by itself so we can get
the failure tolerance together with
actually maybe an area of a useful
research how you can basically combine
in failure tolerance or real time things
there's also an optional trick out to
restart on a crash so since we have we
have pre-allocated all the heaps and
know everything about it we could
actually not go to the supervisor to
restart the process but you can just
clear the heaps and jump to the
beginning and and do a very quick auto
restart which is much faster than your
supervisor would do it and then have a
count on it and if you do it too much
then the supervisor chumps in anyway so
what do we do a message overflow there's
basically four possibilities we can
crash the sender because it sends too
much we can crash the receiver because
it's too slow eating up the messages or
we can actually drop messages and
there's also two things drop the old
message that's already in the mailbox or
drop the new message that's not in the
mailbox that just came in for example if
I have a new temperature reading I mean
I don't care about the last temperature
reading anymore I just drop it I work
with the latest sensor readings so that
would be drop the old one so that's a
little bit on the inside how we are
actually planning to implement this and
how this actually looks because there's
nifty little details how they how the
the i/o systems work how the drivers
work and how the nips work and we also
need some help there in addition because
we have to normally run scheduler and
then we have an additional airline
schedule or group of scheduler in case
of an SMP system which runs on a higher
hard real-time operating system priority
so there Hardware ephemeral and
scheduler always preempts the other one
it's basically it looks like a scheduler
in a second core except it's on the same
core but always interrupts the other one
so it's always getting priority to talk
to the hard which actually write
something to the hardware you can still
use normal nips because you go into the
nephew right to a register and it it
gets maybe even a valuable read
something from register and you get the
value back this is bounded time this is
not not a problem the problem of course
when you will need to wait for something
so if you wait for something like the
traditional way would what to do to like
a synchronous i/o is this basically wait
for i/o to happen or an event to happen
the attrition away was using a poor
tracker for this
which then goes through the operating
system select call which is basically
the way they along the M there's other
calls but this is the basic one and the
one we use in autumns which is a way for
they along the m to wait for multiple
things to happen on multiple file
descriptor so you need a kind of a pipe
or something or you need some file
descriptor I need to wait on the file
descriptor there and then it actually
they along am actually notices that
something happened and actually sends
sends a method to the to the process who
is actually watching the port as of
recently you can also use this with
sniff so they added a functionality to
make this select thing available to NIF
but the problem is that we don't really
know what kind of like operating system
machinery it's behind the Select call
and if it's hard real-time and also we
need to make sure that the routing of
the select file descriptors go to the
right a long process and there's some
kind of shady area here the best way to
go so the select thing is fixable but
that might not be the nicest way to do
it the nicest way to do it basically on
the under the overall time line of
actually improving natural native
implemented function if functionality is
native implemented processes so it's
basically on the roadmap above OTP so
maybe we implemented over or we wait for
them to implement them that's basically
a process that you can write in C for
example which runs on a separate thread
and which can actually send messages
sent at arbitrary times to arbitrary
Alain processes so it basically behaves
like an errand process but it's outside
of the VM and with that we could
actually perfectly react to outside
events to happen I need to speed up a
little bit okay okay I build us a small
scheduler for hard real-time early I
used Berlin only so it's more like a
prototype implementation to see
potential and possible weaknesses of the
whole approach I use shared ets table
for synchronizing the scheduler data
across the real time processes ets has
the advantage that it's very fast and
you have short help us anyway and it's
very optimized so it's the way the best
way to do it I think and the car type of
scheduler I used was a cooperative
earliest deadline first scheduler the
issue is that you don't country and
other processes in Erlang so you would
have to you go to the VM and which does
this usually so I have to rely on some
collaboration between those real-time
processes
actually it's my Martha heck I really go
into deeper in the next slide and there
can be other things going wrong so I
implemented also watchdog which I will
take care to clean up the ETS tables if
something crashed for example or a
process missed the deadline so in yes
you have four fixed priorities it's
normal and low where you usually have
your normal software and processes
running and there's also hi and Max
which you actually shouldn't use but I
did nonetheless and the trick is to have
all real time processes waiting and the
max priority they are in a receive so
they are blocked because they don't get
a message as soon a message arrives the
the process we'll call the scheduling
algorithm and then it will decide if it
can run if it can run if we go to the
high priority and it will start its task
if another process receives the message
it's still in Max and country empty
other one but yeah it's say heck it's
not perfect but it works quite well
okay we are talking about real-time
software mostly so what about the
hardware not about the operating system
and we have a small board available it's
called Tris port if we go into detail it
you can order it already and we'll
present it to you you can also build
some cool stuff with it this is it it's
looked like this it's manufactured in
Germany and it has Wi-Fi on it so you
can build cool internet of things
application with it elding's running
closely to the to the cpu that without
much operating system interference so
you can all have that if you want to
there are many connectors for sensors
and actuators I will show it what we
have later it's a 300 megahertz CPU we
have 64 megabyte of RAM which is enough
to start the VM and to run most
applications we have to buy fire and we
have a microSD card slot for the actual
program this is the CPU it's an arm
cortex-m seven we have a floating-point
unit and a DSP unit which we plan to
make available from the alongside so you
just have been dwelling module and can
do digital signal processing in hardware
and we have internal of two megabytes of
flesh which is used for the bootloader
and 300 kilobytes of RAM
additionally which we don't use yet but
we plan to to make things faster as a
microSD slot to Wi-Fi the GPIO ports
which also support passive modulation
we have two of them we have our two
pilots we have little switches which you
can access from Erlang we have a reset
button to reboot everything if you are
port and to SPI
interfaces you also have some interrupts
and you can have multiple SPI slaves
there's a nice grassy pass also the NOC
next talk of cloud and Adam will go more
into deep with this also an one by a bus
there's also demonstration about that in
the next talk so if you if you're
interested interested just stay if a
micro USB slot micro USB port which is
used for the power supply of the board
and you have a serial console and you
have also a gdb opens Oct de Baca so you
can debug C code on the hardware and you
also can use an external hardware trade
tech debugger so I think the P months
are my own thing so the connectors you
saw before they are actually conforming
to some standard by digital and it's
called P modes and you get lots of
little lots means like over 100
different sensor and actuator boards
actually quite cheaply and you can just
plug them into these P modes there
different kinds of P modes that's a
different spi uart GPIO interfaces which
means and we are actually providing
drivers on the Island of or lots of
these P modes and the most most usual
and this means that basically you can
build all kinds of things with the board
you're not limited by the board you just
plug in the peanuts that you need and
then you can build almost arbitrary
things so let me go through a few mods
to show you what what kind of things are
actually available this is a P mod that
makes it possible to connect four servo
motors like just a standard servo motors
for model planes or something you can
connect four of them to one port the P
mode nerf is a P mode that is pretty
cool it has a 10 degrees of freedom
navigational thing so you get like three
exits
accelerometer you get three axis gyro
you get a three axis magnetometer like a
compass and you get their precious thing
to actually have height measurement so
it's precise to actually know that if
you're a few meters up and they are
pressure sensor and a temperature sensor
for good measure
in addition so it's actually 11 degrees
of freedom even in one Piedmont there's
also like all the peanuts which just
implement a 3-axis gyro or just an
accelerometer but I would recommend just
go for the P mode enough because we have
a very extensive driver for that and it
just has everything you would ever want
to about like inertial measurements and
and in location things there is
basically a lots of different motor
driver things that the HP mods so you
can actually Y up a higher powered motor
to it so we can basically run the motor
forward backward and response modulation
you can actually modulate the speed very
thing you see the motor just it gets a
standard plug into the P mode and you
don't so we actually have a robot but
the robot is actually involved in it
another conference a robot that drives
around there we use these motor drivers
and there's also like a P mode for GPS
so for example if you're outdoors
reserve this drone you all you need is
the P mode enough and the GPS P mode and
you always know where you are very
precisely you just little do a little
bit of filtering and nifty nifty
processing sorry the P Mo's directly
that the interfaces so three modes
actually is simple and it's a it's an
ideal first way to do your first one own
hardware thing and here you see one that
actually build up that's the one that's
actually running the demo so that's just
a breadboard and we just sold it a few
bots on it we will here but later so you
can basically very easily make your own
P modes
as like beginners soldering project
things software's given again okay so we
were talking about hardware now I will
proceed with the software stack which is
running on this board which is actually
very similar to the one you've seen in
the video just a little bit on the
hardware we use SP I already mentioned
FM's Artem's it's a real-time executed
for multiprocessor systems it's open
source and free and it's you don't have
any processes they are it's just threats
so everything is shared you have no
memory protection but you have a full
POSIX compliant API which you can use
and we do use it for a year TS we have
SMP support and the board also
networking stack that comes from FreeBSD
and everything is statically linked so
there's no dynamic code loading
everything is statically linked
the crisp but run time is the thing
about that
it's basically an early application
which has many LinkedIn drivers already
so all for the basic connectors
everything is done you can just write
device drivers purely in Erlang it's
very cool you're very fast it takes not
much effort you don't have to stick with
registers and bit chips episodes you can
just use a link any pattern matching and
stuff like that it's very powerful and
very easy to write new drivers on top of
the existing drivers the hardware
subjected of course by that and yeah we
have drivers for almost the basic stuff
is done the tooling makes it very easy
to deploy your own application we have
created and rebar three plug-in and
there's a template which you can just
use by calling rebar three new crisp app
it will build a directory structure for
you everything you need and you will
place your bÃ¡lint files in in there and
you can then build the application with
rather three crystal build and this will
link this week first compile cross
compile the UTS runnable x2 to the crisp
hardware and also link against the atoms
operating system and then finally you
can deploy it on the SD card
you think it's my turn again while yeah
actually takes care of the demo and said
run so so the in the demo we explained
to them a little bit we have a stepper
motor here and I'll explain what stepper
motors actually are make a little pipe
and we have sensors and we have sport we
I showed you before so let's maybe
explain what's a step motor and what's
the difference to a normal motor so
before we saw this h-bridge we can go
forward and backward and you can kind of
like do some speed control loop but
that's actually a lot of work a stepper
motor actually has a lot of nice
advantages it has very exact positioning
so you basically tell it go to this
angle go to this position angle code
this 30-degree forward or like go ten
turns and stop at this exact position
there so that's why it's used in
printers in 3d printers for example
Philippians is all run on stepper motors
that's basically there's no question if
you have a permit or not they all have
stepper motors to actually for the
positioning of the whole thing you can
also control the speed very well because
it depends on on the actual like
basically tell it like increase the
angle by this right in in this time so
you can actually very precisely control
speed and if you do two stepper motors
that actually you control is the same
way that would actually run
synchronously so how do you actually
achieve this maybe I should explain the
picture a little bit so you have lots of
coils in there and magnets and and the
way you drive it is not like that you'd
basically do a turning field and and
then it goes around but you always
basically apply force to the next magnet
and like you pull it to the next magnet
and push it away from the old magnet and
so it goes to a discreet position and
normal stepper motors have lots of these
discrete positions where they can
actually position them so for example
this one has like 200 positions going
one time around so it's 11.8 degrees one
position and the controller can actually
by actually
driving the current to two coils
basically slowly like a little bit of
this like 10% of this coil and 90% of
this coil you can have substeps which
means you can have 256 sub steps between
this 1.8 degree which is very very small
steps and very precise they are also
very cheap because there's not much in
them there's not much moving parts
there's nothing that actually kind of we
are Spears down because there's just
these coils and magnets and that's it
there is no yet don't have any forth
force any any current into a like a
moving part like with some things that
then wear down and you need to replace
them and there was a pretty high talk
but they also have disadvantages the
disadvantage is that if you go step by
step
basically you dump the same energy for
every step in into the stepper motor and
if it if he actually if it kind of
behaves weirdly because if it's unloaded
if it doesn't have anything to pull then
it actually gets pretty hot because it
gets in it needs to get rid of the
energy which is also a waste of energy
of course it's not energy efficient
there can be noisy because this stepping
kind of like makes a piping noise like
this of all printers that's actually the
stepper motor you hear also if it's
overloaded you can actually skip steps
so it doesn't fail well because it plead
it either can go to the next step where
I can't and then it just skips the step
and then you don't know where you are
anymore
fortunately there are controllers which
are very very smart and control the
current while the step actually happens
so it it measures the current how much
goes into the coils and can never deduce
how much the odors and stops the step
early basically when it's actually
already there so it knows when it when
you took the step successfully so it it
actually can take off the load and that
might reduce you you take away all the
disadvantages so you get all that one
touches and take away all the
disadvantages and then the stepper
motors are actually perfectly usable for
almost everything except going very fast
it also you have motion planning so
these controllers have a high level mode
you basically tell it like accelerate in
this rate or this speed and go on this
speed until this position and right in
time these two start to decelerate to
stay at the point so you can do very
interesting things without a lot of like
closed controlling so you can control
them step by step but you can also do it
in a you know like a higher level way so
that's very suitable for long
so the mo is running already and what we
have in the demo actually I think I
switch over to to you and show the demo
on the only view like early so you
explained in Drive and the demo or I
explained the demo and you didn't type
or whatever make sure it doesn't work we
need to slide nice try
and yes we using an interrupt driver so
pin interrupt is something where you can
configure the CPU to jump to a special
routine you can do a configure so this
is running purely on hardware
and we have this sends us actually
connected to pins we've configured for
an interrupt and get go to camera the
goal is to have this interrupts events
as along messages so I wrote the
interrupts driver in C for the Chris run
time you can use it soon it's soon on
hoes on github it needs to be some trick
because you can't just send a message
out of nowhere and airline you and also
you have to take care what to do in an
interrupt service routine that's how to
take callback for end if an interrupt is
called you have to you have to send a
message to an other FET and then use a
pipe and then you're this person is goes
in a select and the Select will
eventually send a message I think we
would move forward with the demo we're
running out of time mmm so what you see
here is a plastic pipe and a little
metal ball running around the place here
can you see the ball it's visible okay
so it goes around so the pipe is open at
the ends so if we if you basically don't
tilt the pipe in in time we would lose
the ball and to actually know where the
ball is in a little way we have these
these sensors here that's actually
inductive sensors so they actually
detect the presence of metal and that
ball is made of metal so and if you look
at them closely you see when a ball goes
through the little light flashes on on
the sensor and that's actually what
hooks up to the interrupter I've had
Killian was actually explaining now and
then we we need to react in time and
what we want to show in the demo is that
actually along with the little tweaking
we did already it's already fast enough
to actually not lose the ball here so
that's actually pretty close to the
manufacturing application because you
don't want to lose the pellet over the
end of the conveyor belt so the ball is
basically playing pellet here
so you see here that's the picture I
showed before that's the grease port
with the wired stepper controller here
so that's the stepper controller and
that's basically some resistors to show
two ways to get the voltage of the
sensor stone and that's the stepper
motor
and you see it just keeps going
it's very mesmerizing I could look at it
for like hours but let's go on so we
keep it running so you can see that
actually it doesn't lose the ball so
next slide that's the demo so that's you
again we have some interesting updates
we are shipping since November and we
are still shipping so you are free to
buy one and be happy with you buy one we
will do the software release 1.1 this
month and we have now wpa2 running so
you have can have encryption Wi-Fi
encrypted Wi-Fi and we updated our link
to the latest version it's 20.2 all
basic drivers are done so you're ready
to go basically and start your own
projects oh that okay so we also use
inverse port in the light-cone new
product it's about Internet of Things
and edge computing with the Internet of
Things so edge computing means you push
the computation to the edge away from
the data centers because the data
centers can't with Internet of Things
growth rates expect the growth rates of
devices and we use it basically for the
Internet of Things application it's very
convenient there because we can actually
the lots of the researchers are you
Ellen code for their further systems
models and now we have a board where we
can basically run the same code that we
actually run the server also in the
board so you can actually decide where
you want to run the the director code
the road map in the future more drivers
problem and a pre-built cross OTP is
basically will be showing up next week
that means that you don't need to build
the torture anymore makes it even
quicker to get started with the board
and and we also working on fixing a long
distribution in this research project to
make it more scalable like the airing
distribution protocol has scalability
problems so we're kind of running out of
time but I've
have one topic untouched that's the
functional reactive programming thing
from the title so let me rush you
through this so the the general thing is
like usually I learn programmers when
they hear about like has the programmers
doing functional reactive programming or
wherever we basically sound yeah but do
we need that I mean kind of like we have
this message passing and chronicity and
so really in the along like an on topic
there but still you can especially for
this hard real-time systems you can
improve it so that's actually how I alan
gropes now you you have encapsulated
processes which only communicate wire
messages and normally if you have like
if you do it the OTP way you encapsulate
the message passing part which is the
non-functional part because messages are
side effect the classical side effect if
you send a message or a zero message
that's a side effect that's not not pure
functional anymore and you separate
basically the side-effect code in to be
so-called behaviors and and and have
your your functional code in in in pure
functional callback modules where you
then basically write your application
code there so there's a separation of
concern and you have functional and non
functional there's there's especially
for this like controls things a more
higher level way to actually look at
this system is actually you have like
modules that do some processing and
react to invents and they're usually
connected by a flow graph which then
basically is wired up and the messages
flow from one or the event the abstract
event goes from one block to the next so
you have building blocks and you can
actually assemble them to larger systems
and if you look at the system at the
flow graph of a system then you actually
can reason more about the system because
then you for example if you want to know
the deadlines between the two yellow
arrows going in the system and out of
the system that very useful if you
actually know where all the messages go
and traditionally in Yelland you don't
know this because well you have justif
processes and you don't have a
statically accessible way of actually
this graph looks so what we actually
want to build were actually partial
build is a way to actually specify a
flow graph over kind of like real time
modules which will be special behaviors
and doing this and then you can also do
things like for example if you look at
this flow graph and you do all this with
messages and you have like a long flow
graph that might be good for throughput
especially in a multi-core system
because you split up your computational
things over multiple cores but if you
want to reduce latency that's actually
bare because you have lots of messages
and lots of switches of context so
you're actually increasing latency by
using lots of processors by having this
flow graph and encapsulating the
functionality in functional modules we
can actually group them together when
when when we don't need messages so we
can actually call just functions along a
chain and actually when it gets too
messy for us we fall back to messages
and we reduce latency by this and we can
do this automatic system startup for
example so this is a little bit
complicated I just hand with me to
myself to through the slides because no
time the way we actually do this that's
two of those blocks and these blocks
have like like plugs which have names
it's the green things that's plugs where
you can actually plug them together with
these arrows and that's basically a
standard two blocks of a protocol stack
where you have up and down you have
basically a downwards thing and your
mighty for shared state in every level
and going back up and the way we
actually connect these when we don't
want to have a message passing so we can
have if message passing it's trivial but
if you don't want to have message
passing they actually add system startup
when we basically start the subsystem we
be passed around basically we wrapped it
static configuration or the kind of
dynamics that like runtime static
configuration at start time we wrap it
into a closure and we past closures from
one module to the next wrapping all
these things and so basically what what
you at the end in the first process of a
chain you have all these wrapped
closures and can call this functionally
without any process switches and on
without any message passing so that's
the way we are doing this we're actually
using this in the protocol stacks for
this Hydra prop device with
has to implement a lot of automotive
protocol stacks in a flexible way so
that's why we try to get a more higher
level approach to actually plug these
Lego blocks together and so that works
very well and we also want to use the
same technology for hard real-time
things to make it more functional
reactive programming and that gives me
to the lots well yeah the grist port is
available we can ship there is actually
a discount
during lambda is until Sunday if you
enter their code lamda 2018 that's on
the slide it's also on the post outside
you get a 20% discount on all your
orders so get some boards we can need to
get rid of them so we can build new
boards and the the price drops when you
buy in blood sports because the price of
manufacturing is basically about like
the piece count and but that we run and
we have two minutes for question or one
minute I saw Adam Lindbergh's
presentation I didn't EFL : like two
years ago and oh cool I can try it now
with Erlang but then I saw the price so
for just playing around it was quite
high so can you you can I can explain
the price no it's not a party price it
was just my opener so is there a certain
area of things where you would use this
instead of just taking a raspberry and
put Linux in holding on it while you do
very different things with it you can do
things that you can't do with a
Raspberry Pi yes of course and it's much
easier to actually get started on the
island level because we provide all the
drivers then with the Raspberry Pi where
you actually I mean there's like nerfs
project and the constant complaining I
hear about this is the lack of drivers
we basically fix this by building our
own hardware because the problem is the
drivers these are a lot of work and if
you basically you're BeagleBone or
Raspberry Pi and right this drivers for
this board by the time you're done they
make a new board and then you say
alright we have to start again so having
our own hard we actually can control
when there will be a new board and we
actually can pick the new board in a way
that we actually can save effort driving
writing drivers I know the price point
is quite high but if you want to if
you're looking at academic use please
talk to us we will be sponsoring some
academic projects if they look
interesting and it also it's also meant
for professional development we use this
for prototyping our devices and our
products for our customers and if I bet
it's actually not not expensive thank
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>