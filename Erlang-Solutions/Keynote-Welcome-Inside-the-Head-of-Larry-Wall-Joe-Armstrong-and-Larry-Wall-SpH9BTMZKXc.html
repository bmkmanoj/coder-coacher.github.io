<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Keynote: Welcome Inside the Head of Larry Wall - Joe Armstrong and Larry Wall | Coder Coacher - Coaching Coders</title><meta content="Keynote: Welcome Inside the Head of Larry Wall - Joe Armstrong and Larry Wall - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Keynote: Welcome Inside the Head of Larry Wall - Joe Armstrong and Larry Wall</b></h2><h5 class="post__date">2017-03-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SpH9BTMZKXc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay well you know parole has always
come at it from net the language thing
from a natural language point of view
because I was trained more as a linguist
than a computer scientist and some
people would say it shows and but you
know with the natural language you learn
it as you go you're not expected to know
the whole language at once it's okay to
have dialects the gold ESL's if you want
other things you know languages natural
languages evolve over time and they
don't have arbitrary limits and they
naturally cover multiple paradigms there
are external influences on style you
write poetry difference and then you
swear I hope it has fractional
dimensionality to it easy things should
be easy hard things to be possible and
you know if you get really good at it
then you must be Kampai so that's
natural language but Perl has always
been sort of the same kind of idea makes
them easy things easy for most the
people but you don't have to be a
computer scientist to understand it if
it's accessible for mere mortals to
begin with but it hopefully doesn't run
out of steam
later so a little background in the year
2000 we said maybe it's time to break
backward compatibility what just once
and see maybe we can afford to do that
get off of the worse is worse cycle
crank the thing once for a worse is
better cycle so if you could break one
thing what would it be I expected maybe
26 suggestions we got 361 another thing
that happened about that time was Paul
Graham wrote his essay is a hundred-year
language and he speculated on what what
the characteristics of a language that
might last 100 years are and you know it
has to do with whether it can be
extensible whether it can evolve over
time
gracefully and so we put a lot of these
ideas together and thought really hard
and so we came up with a whole bunch of
principles in the last 15 years
there's no most important principle trip
this one we want to torment the
implement on behalf of users if the
error message is less than awesome we
can set it at a bug every glim comes
with corresponding lat
put that in the corner can capsule out
your cleverness and then we use the heck
out of it so all of our pattern matching
what we call smart matching is all in
one one table and every type knows how
to do with smart matching and it's that
way consistently throughout the language
the press knows tables another place
where there's a lot of cleverness
encapsulated in one spot but you just
learned a is a funny kind of a be but
call it a that's a lot and we learned
from Perl 5 I won't go into that give
the user enough rope to shoot themselves
in the foot but hide the rope in the
corner ok every feature should have high
leverage but not too high pick the right
default this time around that pearl size
cut sort of refrained from picking
defaults for object orientation and that
turned out the mistakes so ya better
default and everything should be
strangely consistent so kind of always
things but the thing we really came up
with was you know girl as the culture is
is postmodern but there really is no one
true language not even Perl 6 of it is
the one true language because Perl 6
itself is a braid of sub languages
planks for short convenient and they
interact with each other and you can
modify each each part of the braid so
here is almost getting long enough to
braid now I never grew my hair out
before about to try that but a braid of
languages let me illustrate ok one of
the braids of languages is for each of
the different slots that an operator can
be so we can redefine or define not
redefine a postfix bang operator we
don't happen to have it built-in wonder
of wonders so if I uh if I defined that
municipal should look almost like Erlang
you recursive function obviously but you
notice that over here we're actually
using the new symbol in part of its
definition the the way the flying works
is as soon as it sees that name of a new
function it derives a new parser with
with a mixed in rule for parsing that it
automatically writes a new lecture for
you so you never have to write your own
lecture a righteous on its own longest
Turkic token matching and it's all
already available by then so if I run
this here it actually comes up with them
yeah yeah it we also have obviously long
big integers by default so here we have
same thing now a lot of people are
allergic to schedules we as in protocol
tree culture we like our schedules but
you can write without them so here we
have the sigil list style here where we
just called our parameter n and that
without that works also or we can talk
directly to the dispatcher we've unified
functional programming and
object-oriented programming they're just
all functions with different dispatchers
so here we can actually talk to the
dispatcher and say well call the same
function but with this argument and that
set will also work but that's not how we
usually write we don't usually write
tail recursive things in perl 6 you'd
usually write a reduction operator this
just says multiply everything from 1 to
n and that works too and there's a
little philosophical thing there is that
even though we're building a lot of
functional programming capabilities into
Perl 6 this whole head tail recursive
definition of things
tends to work against concurrency we're
more of the view of guy steel and
fortress where we want to be able to
subdivide things equally list so our
list they're higher abstraction levels
than necessarily the head and tail of
Lisp so going on 15 years later what
have we got well we we got in 2015 we
got our first real release of Perl 6 so
the version number is six dot C
Christmas the next one will be six dot d
Diwali but what what do we what do we
have we have a fun handy scaleable
learning Bowl expressive optimizable
maintainable they just keep getting
longer and longer don't they
multi-paradigm gradually type Unicode
friendly concurrency aware test suite
specified functionally reactive
parametrically goes a Viking safe
linguistically malleable multiple
virtual machine meta object protocol
defined representational e polymorphic
that's important
and every one of those things was worth
the talk but you know pearl sixth we
want it to be the last programming
language you'd ever want to use no
that's not right now we wanted to not
run out of scheme when you when you need
it not to okay so but we've borrowed a
lot of ideas Haskell we we stole
I mean borrowed the you know idea of
laziness and some other ideas from small
talk and and Java Smalltalk we borrowed
the idea of trait we call them roles
instead but we instead of just doing
small talk traits for compile-time
mix-ins we also added in ideas of
interfaces and mix-ins and and generics
so those that one construct serves all
of those kind of things as an immutable
reusable bits of code that are not
classes borrowed some things can go have
promises and channels so if you're
familiar with those older functional
reactive programming from c-sharp and I
guess their line we have borrowed some
ideas from from APL indirectly not the
syntax of course but for instance we
have a lot of operators a lot of list
operators but we can compose the meta
operators and this is kind of an idea
from APL here's just a plain old cross
operator takes two lists if you run it
it produces the Cartesian cross-product
of those well but what if you add a
concatenation operator there it's
crossed with so be like zip with cross
list etc so this this will instead do a
cross concatenation of everything and
that's just one of the meta operators
that we have here's something that's a
kind of fun functional programming I
mean it says I have a sequence and
here's 1 2 3 you figure out the rest of
it
and it does but again Haskell pleasure
with so was it that I'm smarter than you
I'm not going to try to do that or it
doesn't matter if you like it you know
that that's by the way is red one two
three dot whatever the stars is usually
red whatever and what it really needs is
delegate to whatever you're calling to
figure out what the appropriate thing
there's but you can you can have the
explicit infinity you can write it in
Unicode if you want network to do but
what if you what if you actually just
want to have part of it well you can you
can slice the subscript all of these
freaking the same things we use zero up
to but not including so often as a range
that we have a unary operator that does
that so all of these will produce the
same sequence sequences also know how to
iterate on on strings so you can do that
now you guys have smartphones and
they're they're always fixing your
quotes to curly quotes for you and
that's frustrating right well you know
what if you actually type that into it
doesn't care
curly quotes are fine how many you from
Europe how many you have different curly
quotes yeah
well some of some of you had these right
at work and some of you have the closing
curly quotes the other direction that
also works and what if it actually
turned to your dot dot dot into a
Unicode character well laying out that
work too so we're very very up on
Unicode here we process everything in
terms of graphemes
flex lift only better
and we call that normalization form
graphing but basically the idea is you
take any composed character whether or
not it has precomposed
a variant in in unicode will pretend
like they're all free composed so those
are graphing it's the native speaker or
you hear it physicist he wants vector
move and he wants to think think of that
as a single character or she well you
know it is one character in Perl 6 it's
two code points but it's one character
it doesn't matter how many markings you
have on if you in Perl 5 if you say this
it says that's 49 characters oh look I
forgot to tell if it was utf-8 so we say
utf-8 it's still 27 characters
Perl 6 how many is it it's five if you
have to watch the right your your
numbers in Tibetan I work or kumea form
this it all falls out of a Unicode I
mean they just apply this so it's
trivial to hook it up really vulgar
fractions they work you might think well
that's a floating-point number no it's
not it's a rat has a nice mellow one and
what are the rats methods well has lots
of rat including attorney to a fat rat
to be heated enough okay well I said one
of those messes is nude numerator and
denominator but you'll never forget this
method ninja there's got to be a joke
about nude rats in here but I don't know
what it is or you can get the pearl
representation of it you see it's sort
of going back and forth here between
functional and you can treat everything
as an object much like in Ruby and this
is an exact perl representation of self
at values
to run period okay well what happens if
you speaking of wrath what happens we
say this in in pearl high if you try
this new favorite language it probably
is going to say these are not equal but
in in Pearl fixed we see the yes it is
because those are not floating point
numbers in Perl 6 those are rational you
actually have to put the e 0 on it if
you want to want to do things in
floating point okay so since we do
things exactly in rationals does this
exactly match this end point of course
it does try that in your language and it
might not match it might just keep going
on forever okay but you we can say okay
here's one that does go on forever but
give me the first forty values of it so
you see it into a geometric sequence if
and here's another geometric sequence
that just happens to have a multiplier
of minus one so it can do that one two
and yes you can just say two to the 32
if you want alright what we'll do with
this looks like it wants to be a
Fibonacci sequence doesn't it well we're
not that crazy if you really want a
Fibonacci sequence then you can either
name these the built in in fix plus
operator that's its actual name or you
can write lambda in any of those three
ways and those all produce Fibonacci so
you know we had a earlier talk where we
had had Fibonacci a 40 in a cook couple
couple seconds to do it
it takes point zero five seconds in Perl
6 to get the fortieth Fibonacci but of
course we're not seeing it certainly
more fun function composition okay log
of a - number is quartz going to blow up
but if we compose it with absolute then
we can get a safer version fold
operators you can write reductions in
the shorthand that we have but there's
also the longer form if you need to get
fancier so these all add one through
four quick what's the sum of all these
numbers right it's cheating of course
it's optimizing that to a sum method on
a range object which it knows how to
skip over the intermediate value here's
a scan if you in the half terminology so
so that gives you the half scale numbers
triangular because your numbers or your
structures tend to get larger and larger
so there's sort of a metaphorical
triangle there so the fur looks like
typing the wrong thing okay so there's
the first 40 triangular numbers there
roll 5.5 Yahtzee dice here and print
them out
unfortunately Unicode doesn't actually
give the numeric values to little dice
the last and usually original ray but
for those those dice okay the sum is 15
mins 1 the range is all the way from 1
to 6 and the least common multiple is 12
because that's an index operator we can
use it as any reduction see more things
to look at don't have to specify elf
over our fold because if you do with
that from the operator self so it knows
that exponentiation falls from one
direction and multiplication from the
other automatic identity if you if you
like to do a large factorial
that's one thing but what if there's
only one thing we'll go get one
well is nothing in that so still one
because it knows that that's the
identity out if you reduce on a
comparison operators and it
I made these all variants of the end key
and that was a mistake
control and is not the famous okay
okay so I guess I get true and false
there the identity value for that one is
true identity for men and maxes plus and
minus infinity of course GCD I don't
know one whose there are demeaning 40
cedis okay other meta op we saw a text
earlier suppose we define our own our
own data operator here which puts a bow
tie so that puts puts the arguments in
Reverse
this does as if so those in parallel zip
with basically the X we already saw does
the cross you can stack them so the
reverse X and yeah you could you could
have a operator this you know 500
characters long if you want to do no
arbitrary limits there's X reverse which
you know it's actually different if you
do reverse X reverse it comes back up in
the same thing so so just to sum up
quickly we do a lot of stuff with
concurrency now in perl 6 that will look
very familiar to go in Erlang
programming that the structure of the
scheduler threads versus the witch cult
process is quite similar reactive
programming is these new things that
work where you can write things that
look like loops but they do the right
thing and compose with reactive town
responses the things and this does kind
of stop on this one one of the important
things that we do now is called
representational polymorphism and that
means that even even your classes in
perl 6 don't actually care what
representation is so you write your
class the same way your message the same
way for accessors and it doesn't care
whether it's the built in opaque type or
whether it's some DM array of underneath
or a fee structure or C++ or or Python
objects or Ruby objects those can all
look the same so that makes it very easy
to interoperate with any any other
languages that we can talk to that's
probably enough probably too much to 300
years time
all these programmers you have to read
legacy Erlang and segment early and they
go what it's like it'll be like the
ancient hieroglyphics a nobody was dared
change it because it all works people
who do this to us
fortunately I'll be dead right yes and
also if you design language with you in
this course you get no credit for all
the programs at work but your program to
speed written in your language which
failed at your hospital of my course yes
one of the things we started out with
the window when we decided to break
things and come up with Perl 6 was you
know we already know what our old
mistakes are let's let's let's throw
those out and make new mistakes this
time
but kind of related mistakes in the
sense that pearl as a overall philosophy
of how you how you think of programming
as an activity embedded in a culture and
that the culture says a lot to how you
actually structure the style of the
program and you know externalities will
often determine whether you want to be
object-oriented or functional or do
logic programming
or what have you just as in a natural
language you know if you take a class in
in poetry you're going to produce you
know work the literature that hopefully
look and work like poems but if you take
a math class and write a math paper it
is structured more like a math paper and
but in each case in an all sort of
literary work it's this negotiation that
is happening between the writer and the
reader whether that reader is a computer
or the next programmer you know who's
going to read your code and you know as
an actor you know there's this
negotiation of here is I'm starting off
in sort of with a an understanding of my
character lessons here but I I switched
into more and more specifics about
exactly what language I am I am
programming it and the big idea in Perl
6 is that unlike Perl 5 which was always
really confused about what language it
was parsing and so don't ever try
reading its parser you'll go mad Perl 6
in contrast that's one of the most
things we decided we liver make again
Perl 6 always knows exactly what
language is parsing and a strict one
cast parsing like Pascal and at every
point it can drop in when you define a
new operator or you pull in a new slang
or if you say use COBOL it just drops
into that different language and it
might or might not be really related to
the outer language it drops into the
parser for that language as a pure
parker and that knows what to do with
that language and then at the end of
that block or program the sub program it
comes back out and it restores back to
the previous lexical scope the lexical
scopes are very important for
knowing exactly what language you are in
and we never you know cheat by looking
ahead and seeing what classes are
declare don't even know how what the
class declaration will look like at the
end of the program necessarily it might
be we might be in a completely different
program so we don't cheat anywhere in
Perl 6 so it's very clean linguistically
and this buys us a lot of power that we
think will eventually control that that
divergence that happens to all languages
you know either your language is too
brittle and people just invent different
languages let's do the same thing with
different syntax or or your languages is
too mushy
and and it just becomes a mess kind of
like some some Perl 5 is unless you're
disciplined so to avoid either of those
big mistakes is we have this just as as
Erlang is very strict about its process
model we are very strict about our
linguistic model and so we think that
that that will help us over the long
term to be more like what Paul Graham
was talking about when he talks about
100-year language sorry its preparations
are telling us conversation together I
was looking on the internet it's quote
to do or something I think so that oh
wow well now I'm say anything no but and
then I discovered it that you want
you're older than me so so so tell you
I'm not sure that I'm a year wife so
much more with my container and as wiser
than analysts attempt but it meant that
we've been through the same shift in
generation 15 hardware and what what was
always kind of coupling these is where
did we go wrong because
and I shouldn't either in my mind
certain certain dimensions of computer
that are fixed in my memories so one
limits that took a long time to break
with this 1/4 or 1.4 for megabyte limit
of a floppy disk
yeah and for a long time development
increased to the point where you got to
one point four four megabytes and then
you stopped I just melted limit the man
when I was first sending our programs
Usenet articles could only be 30 32 K
characters right so if you wanted to
send out software then you had to have a
little program that would split your
program up into separate files that
could then be me I remember Tom's Tom's
recovery disk you know we had a complete
UNIX kernel and everything on a 1.4 4
megabytes floppy disk and I remember the
first from Airlines we did get essential
they fitted into 1.44 megabytes and then
things started to change and these went
away and suddenly you're not aware of
that anymore and you go into the future
and you look back and suddenly said what
the perception that an operating system
is you know a small operating system
images that you gigabytes or something
like this so where do we go wrong well
we're not we're not wrong we're just
displaced because you know yeah that our
normal machines are getting bigger and
we're powerful but you know this whole
internet of things we're gonna you know
you're not going to put a you know a
huge computers I delightful we can put
it right now I'm good comics I want into
it to run it rather CPU hot enough it's
just being consistently good but it's
going to be a mix pod more powerful in
the clay probably and you know that
that's part of why I should not worry
too much about making a large language
in Perl 6 obviously the larger your
language the harder it is to support
we do have a portability portability
layer of a restricted subset that does
make it easier but you know one one
worries a little bit about making it too
hard to put onto different VMs we
currently run on our own VM what's
called more VM historically used to run
on parrot VM we have been on c-sharp and
on on Haskell those are all prototypes
that has sort of gone away we also run
on the JVM currently so we've got a
story about portability but under what
but I'm mo um I'm more thinking in when
we have megahertz clock yeah you know
why why are why isn't an operating
system booting them and generally
microseconds because yeah because well
things thing he espies well then where
it's Alan Kay cat we should you have to
reinvent Gator you know you know
computers are getting more and more like
people and so the principle is applied
to people are starting to apply to
computers and this principle is every
computer will be promoted to its levels
and compensating okay and you know
artificial intelligence is a starting
going to start looking like natural
stupidity so I'm not sure that you know
even if the singularity comes well I
think it's probably a plurality not a
singularity but you know I think the the
the foibles that we have as as humans
yeah that the computers will just make
the same mistakes faster unethical to
others affected if you go back to the
mid eighties but programmers could talk
to each other because everybody even if
they knew different programming
everybody knew see everybody knew may
kept repeating you bash and the matter
they can't talk to each other know what
builds they all are using goo BR go
beyond grunting you know my grunts my
grunt Guffey's will
yeah I so it'll be yeah a lot of coming
in here I said this OTP still mean what
it used to be but yeah you know we are
we are in the process of becoming
fossils and the new culture will always
be built up on the strata of the old so
it's a healthy process that that the new
generations will will take what they can
from us all teasers and you know take
what they like and leave behind some of
the things that maybe they don't like so
much but I mean now I think when we
started project we didn't say for you
you know you where you're learning
programming you had the choice of
learning assembler COBOL or Fortran I
learned basic oh we had machines with
that advanced it's actually my first the
computer program was on a programmable
calculator but not even I think naysayer
or some some off-brand is you could
program it 120 steps that were like
compresses and I almost got sick Tac Toe
in to 126 I'm sure it was a very stupid
program and if I could do it now I
probably be better but no actually my
first computer language was a basic plus
on a-deck Christus and she the one lemon
table uh my in 1972 it was actually on a
PDP 11 20 which was a forerunner to the
PDP 11:45 okay have you hadn't done any
programming to pull it out it's only on
the only in my last quarter of high
school that when we got the few
calculators and I was I was supposed to
be doing independent study in math and
most of my inside the calculator so I
started with Fortran in 1968 I think and
with a three week turnaround times of
your programs because the first week you
you get it on the coding forms and I
said too often and I did have to do
COBOL in a bad system
we have to take our card decks down and
of course I never got to clean the pile
in but on the other hand you know I
didn't really study all that much
instead the night before the final I
read the entire IBM COBOL manual and
aced the test but yeah there's lots of
people people talk about so well Coco
has has had a good run and I do have to
you know sometimes disabuse people of
the notion that you know if a
programming language is like a
networking like a natural language they
really think of COBOL which sort of
Cargill cultured phrases in without
really doing anything and it was really
just a procedural language that happened
to have English phrases with key words
but it didn't really work like the
natural things on a deep level well I I
knew I knew COBOL was not for me as soon
as I I saw you called you call a
subroutine or you thought you say
compute you say what it is you don't
even call you why don't you do a
subroutine that's two letters you have
to even both I forgot - yeah there's
like a seven-letter word for for calling
a subroutine I said why why are they
using long words for common stuff since
the beginning of this inkling that you
know it's going to use something
frequently it should get rubbed down and
be the short thing the the term we use
nowadays in InDesign is Huffman coding
now Huffman coding is a bit encoding
that we're we're frequent characters get
a small number of bits and less frequent
characters get many bits but the
metaphorical meaning of that is you know
make the common cases short and this
happens in in natural language too if
you look at almost any natural language
the most irregular parts of the language
will be the most common these verbs
amount and that's because that is where
you you use the most you need the most
irregularity there for information
density and clarity and redundancy of
communication so that it's not really
surprising this is the most irregular
parts of natural languages are are the
most frequently used end of the most
rubdown bits of it so similar things can
happen if I'm also under get the at what
point in time did you I mean did you at
some point in contact I know what I'll
do I'll make a new programming language
all the other I never did - I did my
first real language well I did a
language for a compiler class with the
Dragon book yeah yeah I'm mostly ignore
all dragon back I also ignored the
dragon book and then use yes but that's
okay I'll a whole and I are friends now
yeah he's a great guy and but you know I
one toy language event then I had this
problem that I was programming for our
school
our computer center in basic plus doing
real work for the college and and I
needed to be able to sort of link in
various basic routine so I need to kind
of an inside-out language nowadays for
an inside-out long as you think of
something like PHP where you know it's
mostly text but then there's sort of
code interspersed with the tech this was
a different language but you could
interspersed lines that that would
control how the text were used so it
could basically selectively link in
different routines and this was called
Jam which was the jury Pig jury jury rig
all-purpose metal language hi jammers
Jose abstract machine
yeah 32 yeah but that was that was
actually my first compiler that was that
was just a recursive different kind of
kind of thing and but but about stages
could scratch your programming ages
oh yeah yeah oh well that people can use
yeah and but then I went to work in
actual industry after after some grad
school and and had to do a compiler in
Pascal for for a discrete event
simulation and I you know I've worked
some macro systems for the RN program
that I had written and so you know I
sort of had this general feeling that I
could do this sort of thing and I I'd
published things before the RN program
the patch program which does you know
certain amount of parsing so I already
had this kind of inkling that you know I
like writing compilers and what if I
like something other people might like
it so when when I sort of had this
realization that the UNIX had this
gaping hole you could do shell
programming which was you know very you
could whip things up I call it whip up
the tube and you had C programming which
was very intricate and you could do
anything
I call that manipulate city if you if
you grasp if you think of that as you
know either or
then you
you know programming one of the other
but I'd realized there's two different
dimensions and it opened up as kind of a
two-dimensional graph and I realize it's
a big hole out there where we're
something that should be you could whip
stuff up in quickly like shell
but that could do more intricate things
than shell programming to do and and
work more like a actual programming
language even though that kind of thumb
was a violation of UNIX philosophy and
do one thing and do it well it actually
ended up being a toolbox such that
people could then make other tool and
kind of fit back into this little box so
you know I was already on my you know my
rebellious slide into changing the world
at that point and so you know not not
everyone in the UNIX community
appreciated that that you know I think
Henry Spencer famously called the early
parole office skin cancer
IIIi think I was ugly you know I got
coded transmission sun-god well you know
but it's uh it can be written to look
like that yes with this upon even even
even pearl five pin can be made today
I'm and reading your poem book and
thinking yeah I like the gate with pearl
six yield you'll discovery to that you
can actually write some beautiful codes
with it but I was kind of interjected by
the way you started off with a I think
it was a character count or a word
counter or something like that you wrote
it more or less as I would understand
and see or something the while loop and
getting tokens and things always we can
omit these brackets that we can remove
these organisms and the program just got
shorter and shorter children up yeah
well I I did a couple years when the
upper skated C code country I saw that
yes what what did that produce do Oh
one of them was a Dvorak keyboard
emulator so ye you like ran it and and
started typing in and translated all the
characters the other was a Roman numeral
calculator that was all what like was
all written in roman numeral right so
these techniques you use with you into
the source kind of problem when I
started working on on Perl 6 and we as a
community we were starting to decide how
to divvy up all the work the people who
were with it said that we will implement
Perl 6 you stay out of the
implementation you are just the language
designers because we see what the
insides of Perl 5 look like and we don't
want the inside of Perl 6 to look like
which is funny because it sort of ended
up doing the same thing you know you
can't program the sea without writing a
bunch of macros did you keep out of it
will you put I can actually keep out of
it and that's part of the reason that we
we had I suppose you know three or four
prototypes that didn't really work they
say we learned everything even the
failures though we learned a great deal
from each of them the each person who
tried to implement Perl six and had
different ideas about it they they
taught us you know different ways to
think about things the first
implementation was actually in Haskell
that really tightened up a lot of our
thinking about how did you remove a lot
of stuff as well as adding stuff I mean
from the ideas come from Perl well no I
mean from poke successful as a designer
you say ah I think we'll do that and
we'll do that um and it just becomes so
complicated to implement that you remove
it or uh it was kind of careful not to
put in things in the first place that we
didn't think would be quite useful what
we did discover along the way was that
many things that seemed like separate
things on the surface ended up unifying
underneath so it turned out to be you
know really easy to to get most of
functional programming and most of
object-oriented you so if i Nick as we
have said you know every time you add
something to program and you take
something out you build it so - yeah
that remains for you I freely admit that
you are more amenable than I am so I
keep wanting to take eggs a solvent or
not and I need I need the minimalist
running alongside my chariot saying
you're mortal and so I have a great
appreciation for for
the idea that of trying to keep things
simple as simple as possible where I uh
where I think it sometimes goes wrong is
you know the full phrases keep it as
simple as possible but no simpler and
real life is not simple and the problems
that are presented to computer science
to solve some of them are you know
they're math problems they work great in
functional programming some of them are
simulation problems and those tend to
work better with with object orientation
logic whatever whatever your whatever
you you slice up your your paradigm
you know it's quick and dirty scripting
so that there are there are languages
that excel in each of these areas and
one can achieve a certain kind of purity
I suppose even in the PHP where the PHP
realm there's some kind of purity as
they are achieving but when you start
looking at a language that wants to
encompass the whole world like like
English it doesn't have to be perfect at
everything but if you can do 90% of this
paradigm and 90% of that paradigm and
get those talking to each other
underneath in a smooth fashion that's
what we think we would achieve with Perl
6 if you uh if you scratch a method it's
really just a function just has a
different dispatcher that says how about
of how to find it and call it yeah I
think fine chess guys walk in and I
think there are drinks afterwards and ok
and we could actually see her talking
Dresner we could we could
um so we could yeah
let me just have one pile in Soviet
that's the main the main thing that I
think that we've really got in from
functional programming is the idea of a
coherent type system Perl 5 had an
incoherent type system and and so the
complete the computer was often just as
confused as the programmer is the type
of thing with the Perl 6 we don't we
don't really have types for the benefits
benefit of strong typing it's more like
that's that third place second place is
we can optimize that the first place is
actually if therefore multiple dispatch
and pattern matching could use what more
you can and this is pervasive pattern
matching and multiple dispatch whether
it's two methods or functions I mean you
saw it there with there's a perfect
example is built built in at a
fundamental level and that that's why
Perl 6 love types is to drive that and
it actually once once you've uh once
you've done your multiple dispatch and
decided which thing to call you don't
even have to check your function
arguments you've already checked your
function arguments to do this you just
patch so it in a sense
dynamic type checking comes for free as
soon as you've done that so that's that
is another thing that I want to thank
the the functional programming to me for
for letting us feel but in some sense
you know we have our separate
communities but we're all you know one
big community in world was trying to get
similar things done and you know going
back to anthropology there's there's
people who live in one community and you
know they tell the stories of that
community and there's a tribal leaders
there but there's also the merchants
that go back and forth between different
community
and healthy cultures need both of those
things so it actually pleases me to see
you know Erlang and elixir sharing a
conference like that pearl has shared
with the Ruby community over the years
especially in Japan
yeah because of coke we can build
systems with one language yeah and so
you know our slogan there's more than
one way to do it
that's lies outside of pearl as well as
inside so yeah I think it was great and
thank you for inviting me and thank you
any kvetching where's wimp appear well
of people metaprogramming
it means it needs a champion
maybe that will tickle one of you guys
we definitely have tried to you know
make it possible to put put our language
on two different vm and it does run on
JVM and JavaScript is nearly done if you
can put it on JavaScript you call it
anyway</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>