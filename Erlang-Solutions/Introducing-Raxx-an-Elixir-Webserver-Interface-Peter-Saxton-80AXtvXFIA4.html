<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Introducing Raxx, an Elixir Webserver Interface - Peter Saxton | Coder Coacher - Coaching Coders</title><meta content="Introducing Raxx, an Elixir Webserver Interface - Peter Saxton - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Introducing Raxx, an Elixir Webserver Interface - Peter Saxton</b></h2><h5 class="post__date">2016-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/80AXtvXFIA4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is just to talk about a library
I've been working on a bit of an
experiment
it's called racks it's an elixir web
server interface and weight it's based
on rack rack is a Ruby web server
interface for anyone not from Ruby there
are others but I don't know the names
them so sorry there's a couple of key
differences of rack the main one being
it has two exes which is pattern in
elixir libraries so I would just want to
tell you a bit about what I've been
doing with this but first there is
definitely an elephant in the room so
plug em yeah it's basically the same as
plug I was going to come up with more
reasons about why I did this but I think
Johnny's giving me a good excuse though
I was exploring I was really just a
seeing what I could do and trying to
learn some more about and sort of the
web stack to go a bit further in it my
motivation is in fact this line so the
plug con object has an owning pid'
associated with it and it needs this to
do like send chunk responses and a few
other things so I saw this in them it's
not it allows for a lot of sort of
impure functions to be done and I hear
good things about purity and you know
reducing side-effects and functional
languages so I wanted to see if I could
sort of eliminate this this calling out
as the the process that was a running
the TCP I've said this a couple of times
but I quite often a read Haskell and
write elixir this is basically my way to
thrash all the arrow you know history
out of me because I've got a ruby
background so it was a serious job so
the principle being status HTTP
request/response model it fulfills a
valuable role in modern applications and
it will continue to to be the case so I
think plug adds some complexity when
you're just doing a request response
pattern so simple HTTP looks like this
you get a request your application turns
into a response a simple wrapped
application does the same so what we
have here is well you get a request
you've got an environment there's just a
dependencies that you need to pass
configuration and then you return a
response so this looks very similar to
plug the main difference being that
we're not actually we don't have to pass
the request when we make the response so
the response object can be created like
a new every times and the request is
lost the quest object itself is just a
map so there's a lot of information
about the request key ones being
essentially method and path those the
ones you use most and so the reason the
reason that I've sort of been playing
with this library I quite like where it
showed up ISM I don't need a DSL for
routing there's so much power in the
elixir pattern-matching
but I think this is really quite a nice
router but there's nothing but a
function called an elixir here so
because the object no path in is
reasonably expressive and what it has
the one piece of help it does for you is
it splits paths on every slash so you
get a list of segments for every URL you
can have you can have I just I think a
very readable controller and there's no
magic so you know for people who like
minimal things if you want to dig into
this about what's going on there's
there's really nothing to get lost in so
so this is this is how you divide up
your your actions based on the request
the response the response is even
simpler and as the status headers in a
body this is exactly the same as the
Ruby Ruby right thing I think others do
the same
there is actually a fourth field there's
a sneaky errors field which so if you're
if your group throws an error we can
catch that throw a nice 500 and then and
then re-raise the error so the process
dies properly but you should imagine
that's not there otherwise it leads you
to doing all sorts of weird control flow
with errors and throws which is not what
we would I would try to do with a nice
functionally pure app so here's now our
controller where the bunch of responses
sort of try and look at this one so in
the top one we just returned the map
directly so you know the status is 200
and the body is it's the string there's
again absolutely no magic here in the
ones below I just use some of the helper
functions
so you can have exam very readable
things where response not created we
just make some map and it puts in the
the correct 201 field so you don't have
to remember the codes if you're better
at remembering the names but I think
most people actually about it
remembering the codes I quite like this
example so there was a talk about
splitting things into umbrella wraps for
controllers I think this is brilliant
way of doing things so in this case the
my app create user would be a separate
umbrella wrap I think this is exactly
the line that your sort of domain should
be spread upon so your responsibilities
that's one so yeah responsibilities
between handling HTTP and the domain
logic it's gonna see the me on father
one button well you have to ask my
office because I've completely forgotten
so there's a yep so that's five minutes
saying this even though so yeah so just
the final part of this story was um
streaming essentially I decided that I
wanted to request response with the
first class system but that I did manage
a way to do streaming with sort of
separate also pure callbacks which make
it look very much like a gen server and
I can't tell you about that it's all
stop</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>