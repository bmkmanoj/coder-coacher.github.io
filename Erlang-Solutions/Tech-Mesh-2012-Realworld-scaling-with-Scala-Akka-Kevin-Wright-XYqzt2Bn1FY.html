<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tech Mesh 2012 - Real-world scaling with Scala &amp; Akka - Kevin Wright | Coder Coacher - Coaching Coders</title><meta content="Tech Mesh 2012 - Real-world scaling with Scala &amp; Akka - Kevin Wright - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tech Mesh 2012 - Real-world scaling with Scala &amp; Akka - Kevin Wright</b></h2><h5 class="post__date">2013-08-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XYqzt2Bn1FY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you okay so first off one thing
I've found is not a lot of people here
actually know what zbox is some more
familiar with speaking to Scylla
conferences where we tend to be better
known to begin with then zeebox we are
we call ourselves a companion app the
broadcasting industry calls us a second
screen application so we are a piece of
software that you will run on a tablet
or you will run on a smartphone or
indeed in a web browser when you're
watching television we currently are
targeting live television so we really
really go for the whole interactive
angle allow people to maybe vote on the
best singer in some reality program or
to see live statistics about an ongoing
sports game and of course the
broadcaster's absolutely love this
because it gets more people on live TV
watching adverts revenue stream etc etc
and it's had the browser comes up in the
right window
so give a quick live demonstration of
how we actually work
ok
this is your your entry point that the
home page on the application you can
come in instantly you can see we're
telling you programs that are especially
popular we give you a short list there
we're give you an idea of how much
something's being discussed on Twitter
the size of the audience and that's
based entirely on our own numbers people
using the application we can we're not
showing any at the moment but if
somebody's you know mentioned a
particularly noteworthy thing in a tweak
that might appear in a in a window here
and you can drill down into the program
you can start see we showing you the
Twitter stream we can show you if any
particular famous people are talking
about the program we can related
applications for your iphone or same
thing on android device will show you
applications in the Play Store we can
show you what your friends are watching
if your friends have also got zbox
installed so we we pull in a social
graph from facebook or from twitter to
get an idea of who you are and who you
know and perhaps a bit more
interestingly we have what we call Z
Turks and and these are actually
produced life throughout the program we
will sit there we will actually monitor
these subtitles against a program or
closed captions as accordance States and
we can pick up particularly interesting
topics you can click on one of these
they will take you straight through to
the Wikipedia article and again it will
show you applications and news related
to that particular topic we also listen
out for background music so we can
identify a song you're hearing in the
background of a program you can go and
down
that and in addition we have the ability
for broadcasters to add their own
content so there was a program we did
quite close to our launch in it was a
reality TV program one of these scripted
things and we were actually popping up
tags showing venues the people were in
and they were just scheduled to come in
at a particular point of time throughout
the program we also allow customization
like there this whole world works screen
up here and finally we we have an
electronic program guide where again you
can go in and you can sort it by how
many people are watching how many people
are talking on twitter maybe you're only
interested in food &amp;amp; leisure programs so
we can filter that day and it makes it a
lot easier to discover what's on
television so
for back to keynote um so that gives an
idea of what the program is and there's
a lot of bits that have to go together
to make it work we have so we have to
deal with static content which is you
program guide we get that in from a
third party we have to do a certain
amount of data cleanup of course because
nothing is perfect we have the custom
content where people can add their own
artworks stuff around the brand's which
is really quite important to us we want
engagement from the broadcaster's so the
broadcaster's were actually go out and
say hey download zbox now that's where
we get our customers coming in from we
have the Z tags of course which is
completely live on on demand and perhaps
most challenging is the accounts because
we have different scalability issues for
fraud for all these areas the big data
of course just keeps getting bigger and
bigger and bigger most of that is stuff
we're pulling in from google analytics
so we can try and understand what people
are doing in the application that lets
us decide on new product features we can
tell where people are interested and
scholar doesn't especially solve any of
these problems would probably not what
you're expecting me to say so the static
content we just use a content delivery
network everything is hosted in the
Amazon Cloud so we just push that out to
the edge of the network let it be
delivered everything is pretty much done
with Jason at the front end application
is JavaScript or objective c or java on
android and all the communication is
done by Jason it's all restful web
services with the custom content and the
live content again that will go up with
the number of channels but no
with a number of users because everybody
watching the program will see the same Z
tax for that program there's nothing
user specific there the the only really
sensitive area is the individual user
accounts so when you log in you will see
which of your friends are online you
will see what programs they are watching
you will have the ability to start
chatting with them inside the
application that is distinct to each and
every user and that is where we are
really really pushing the boundaries
with Scarlett and with akka and just to
give an idea of sort of volumes we're
dealing with we can get thousands of
people hit the applications
simultaneously and try to sign in and
that usually comes because we've had a
TV ad campaign on or because somebody
specifically mentioned the application
live within a program and the way we're
dealing with that is we're using an Akha
cluster so that we can handle
round-robin and because it's all in
Amazon we can quite quickly scale up at
new nodes we have a cassandra database
underneath that again because it can
scale quite quickly and it's got a lot
of resiliency built in there it's a nice
clustering model plus our ops team knew
it always helps if you know the
technologies you're you're working with
and and we are growing quickly where we
are growing exponentially we have yeah
we definitely have volume volume to deal
with which is why we went with scholar
because we pinched the best bits from
almost every other language going so
Java as an underlying platform for
scholar it gives us the the jar file
packaging it gives us maven for managing
binary dependencies it gives us ability
to put in anything we want from the Java
ecosystem so can use any third-party
libraries we want and I think of all the
languages that currently run on the JVM
scholar is best that's speaking like a
native citizen on the JVM on the
interaction with Java is pretty much
seamless when we have the types there so
we don't have to deal with with that
translation we have the same classes
same objects etc etc on top of that we
we are acha which brings in all the
concurrency primitives and actor is
often described as an actor library
which it isn't occur either it's a
general-purpose concurrency framework I
website so in addition to the actors
which I think of being covered pretty
thoroughly already in Erlang discussions
we have futures the the idea of here's a
block of code that will complete at some
point in the future and when it
completes go and do something with the
result we have a called agents so an
agent is a bit of mutable state but you
will send a message to it just as you
would an actor and you say double
yourself or convert yourself to a string
or Europe you are literally pushing
functions in the gross functions of
course in scholar a first class citizen
and that bit is especially helpful
dealing with future so this this is
something that I think Haskell is the
only other language I've seen provides
disability
the you you can map and you can flat map
futures so you can build these small
bits of functionality and you can
compose them using a comprehension in
just the same way you would map over a
collection or or anything else with
which cuts the boilerplate you would
otherwise have trying to follow that
model or to put it more succinctly
wasn't the only choice either we we did
consider another language that also runs
very well on the Jovian that does have
good interaction and we ruled it out
okay Joe joking aside yet parenthesis
can get messy they don't make for nice
easy domain-specific languages which is
something we do use quite extensively so
we we we have our own models for for
dealing with particular parts of the
system and we do write a domain-specific
language for solving problems and then
use that from that point onwards if you
if you for example look at some of the
testing frameworks available force Carla
there's Scarlett ests their specs too
and they are both I I think some of the
best examples going of what can be
achieved which is pretty much what I
said here and type safety very important
a lot of it was already covered by this
morning's keynote but the issue we found
with dynamic languages and we are using
some Python we are using some closure
within zbox is
unit tests are code code needs to be
maintained in a way that types do not if
I was to write a multiplication method
in a strongly typed language for
integers I can guarantee that that thing
will only ever be called with integers
if I was to write the same method in for
example closure I can have as many unit
tests as I want but it's still possible
somebody's going to come along with some
other data type I've never seen before
push it into that method and cause an
unexpected failure so you can you can
really pin down within type system
certain invariants that it's not
possible to do in a dynamically typed
language this is ultimately what drove
the decision to go with Scarlett because
it wasn't about its technical abilities
it wasn't because of there's some
special feature that makes scholar more
more scalable except perhaps echo which
is pretty awesome I must admit it's
because it allows the people to scale it
allows developers to scale the role of
of a programming language we found is
more allowing developers to communicate
amongst themselves I certainly find that
I read code a lot more often than I
write it and I know everyone else in the
company does that we've we've now
reached the stage we've got about 50
people working in development which is
not doing too badly for an alternative
language and the vast majority of those
are working in Scala and some of them of
course objective c is cetera et cetera
and it we are scaling our systems to be
able to deal with more developers coming
on board to be able to make changes to
the system very very quickly to add new
features to fix bugs we we do have
competitors out there we do need to move
faster than the competition and and
being being able to get more developers
on board get people cooperating get new
features in faster is absolutely
essential it's it's an active business
unfortunately so that's weird is cut off
the top so that this is an idea of the
sort of thing we are doing and and this
is again a domain language that we
implemented and this is for dealing with
Google Analytics so what what I'm
building here is a specification for a
query to be run against Google so the
Google API it uses xml everything is
strings it you know it's a bit hairy to
deal with we wanted a layer on top so
what I'm saying here is first i'm
quoting the specifics on calling
accessions and and this is what we call
a symbol its is an intern string
essentially so I start off I take a
symbol and I've enriched it with with an
implicit conversion so when when the
compiler sees symbol plus in so well
plus is not a method on symbol and it
will go off and it will look for any
defined implicit method that can convert
a symbol to something that does have
that operation available in this
particular case I converted to something
i call act which is short for accumulate
example I'm accumulating the spec here
so we'll find a symbol it will convert
it an intern so that fills an
accumulator I then add this thing which
returns another accumulator so we're not
mutating state here it's it's fully
persistent i'm adding this i'm adding
this i'm adding this i'm adding this i'm
adding this and the difference between
plus and minus e is just down to the way
google analytics works it has these
concepts what it calls dimensions and
metrics our dimension can be absolutely
anything you can filter on it and you
can query it and it can contain strings
etc a metric is purely a a numeric
quantity and it is generally used for
for building our aggregate so if you
have a particular page if you are full
for just the page path and a number of
page views it will give you the total
number of page views for each part for
example and the more things you asked
for the more it breaks down that the
data and gives you fine range stuff
we're using pre-existing notation from
google here so all of these things have
a common super-tight what i'm calling it
boo when i'm calling a fetch column then
fetch column is what makes this all type
safe so if I've got an accumulator the
plus method can only accept a dimension
is an argument back only accepting
metric filter can accept anything so we
were using subtype polymorphism sorry
somebody had to
and again we're just using functions as
a as a first class entity so what this
will do is it will will take a single
field and it will break it up into
multiple fields we pass parameters in
our URLs we want to split out in our
warehouse into into different fields of
time stamps for example is passed in as
a parameter that allows us to break
stuff down without having it you know
enforced aggregation so so it's not
multiplication no so so the storm method
here on in fact any column within the
context of building specification will
say when you actually run this thing
against google and you fetch the data as
part of the fetch in parallel it will
apply this function to this field to
split it out into multiple fields the
type of page URL is an ultimately
they're all fetch console I fetch column
will have a name as used by Google and
that's usually something like GA colon
page URL it will contain a string size
so maximum length that we can expect it
will contain the type as well so we were
using a feature known as manifests that
can represent types as values to be
passed around within system and it has a
few methods like this method so this
method doesn't actually exist on the
fetch column that method is added
through an implicit conversion so in
much of some ways we converted a symbol
to something that has plus at this point
we're converting the page or l2
something that has that method on and
all of that goes and builds up a
yeah that what's that out at the bottom
is an immutable query specification that
thing gets passed through the rest of
the system so this will define a
database schema so we're we're using an
in-memory h2 database to fetch this
stuff and we have all the information we
need in there to actually go and create
a table in that database to hold this it
will also drive the queries that we're
making against Google and we're using
the volume the data were dealing with
and because Google will actually start
sampling data if you ask too much this
actually ends up creating multiple
queries one for each day because if we
try and ask more than a day's data at a
time it will sample it for you and our
analytics become a lot less useful so
and these of course are readable even by
non-programmers I'm people need that bit
explaining to them but otherwise anyone
who's familiar with working with Google
can look at this piece of code five
minutes of explanation know what's going
on and they can start adding new queries
to our system and we can build all the
magic behind the scenes that will or
handle the database that will handle the
connections to google that will handle
the authentication the fetching a single
days at a time etc etc etc we do use
this technique quite extensively
throughout the system we have other
dsl's in in other components so the way
the zbox application is organized on the
backend is we're running on multiple
nodes in the Amazon Cloud we have a set
of nodes that deal with the social
interaction staff and set of nodes that
deal with the Z tag dynamic content we
have another node that deals with the
analytics and the data warehouse in
another one that serves up that the
artwork from the website etc etc all
communicating through Jason we also we
use scholar in fact as a scripting
language as a rather awesome projects
out there that will allow you to use the
build tool SBT to crave scripts so you
can write a script that will specify
dependencies on other Java libraries
that can be resolved through maven and
within a single script and you can just
run to the command line like you would
any other Python or a pearl or reveal or
whatever it's I mean it is really the
most multifaceted language I rough I've
been lucky enough to him to encounter is
it all rainbows and unicorns no sadly
sadly not it's you can hurt yourself
with skull it's because it is really
really heavily multi-paradigm we don't
have this idea that you're getting
Python you know there is only one way to
do it there is never only one way to do
it within Scala you you have a multitude
of styles you have there's a lot of
people in the community who've come from
Haskell for example who are using scala
because they want to be writing Haskell
but the organization's there within
mandated the JVM or whatever else so
that code is written very very heavily
using a lot subside classes almost not
using objects at all other than
containers for functions we we have a
lot of people in the community who
freshly migrated from Java and they're
largely using scholars or Java but with
type inference
we have a bunch of people in fact two
who've come from ruby and and they have
their own style of writing a classic
example would be method names with an
underscore ? on the end of its returning
a boolean or an underscore explanation
is doing something perhaps slightly
risky whereas more idiomatic Scala tends
to frown upon using snake case we're
using underscores in in method names if
the underscore character is already
massively overloaded we really don't
want to add new ways in which it can be
abused so yes it can it can be a scary
language you can get yourself in a
really really really nasty hole if you
don't pay attention to what you're doing
if you mix and match styles too much but
I think the same can be said of any a
truly effective tool you if you're a
chef if you work in the kitchen you will
have sharp knives you can hurt yourself
with those as well we don't start
issuing chefs with plastic scissors
because of this we make sure people and
how to use the tools safely and
effectively and we get great food as a
result I think scholars are saying that
it's a tool can be used it can be abused
if you have a disciplined team if you if
you know what you're doing it can really
trace them some absolutely wonderful
wonderful things and in our experience
is that you don't need to go out and
hire scholar developers in order to do
this it's enough to have maybe one good
person with a year or two experienced
amongst the team of say ten so that when
anybody does hit a point that they're
wondering what's the best way to solve
this particular problem there is someone
there available for that person to ask
them to
to just make the idioms or all mesh
together properly and have everybody
writing a consistent style of code and
it's really really taking off as a
language I I know for a fact that every
single international investment bank in
this country has at least one team
working with scholar which certainly
wasn't the case when I started using the
language maybe five years ago it was it
was unknown it was a very risky thing to
be doing now of course we're seeing some
very very big people working working
with the language but I've I've actually
run through that talk a bit far does
anybody have any questions
so so I I was not fun that's right now
so I'm not saying that we're using no
time I'm saying that these are features
available that are more commonly
associated with with other languages so
if you go to anyone at this conference
say what language would use for writing
actors in the answer is going to be
alone node seems to build up a
reputation as being a language for the
asynchronous callback type programming
model and you your category theory type
work is is clearly the domain of Haskell
but all of these are available in one
place
perhaps
and so the the biggest problem we have
we did start out working with an actor
model and we actually ended up migrating
that to the the more a synchronous
dataflow site model we we have to deal
with slow external systems Facebook
probably being the worst possible
example that anyone could imagine it is
it's a truly hideous API and a slow API
so when somebody signs in I say okay I'm
new zbox user I want to connect my
facebook account so you can see my
friends so I can see what they're
watching and chat with them and invite
people to watch programs with me we will
will make her arrest call and that will
return a future to be completed at some
undetermined point in the future and
that future we can then map over it
because it's minh addict we we can also
for example start flat mapping futures
so if we needed to call three external
services they will all return a future
and you can then perform a comprehension
over them so you can say for a in future
a be in future be seeing for you just
see return a plus B plus C um that will
itself return a future representing the
sum of those three and that future will
complete when the three import elements
have all completed we we've also built
up little bits of infrastructure so that
we can for example linear linearizing a
list of futures so if we have a
collection of multiple futures we can
say wait for the first one to complete
then wait for the second one to complete
then wait for the third one to complete
to force a particular sequence of
execution and as a building block there
much more easily composed than actors
are and compose abilities has turned out
to be the key to allowing us to make
very very rapid changes to innovate
quickly and to maintain the copis a
student buying a piece of work with a
touch version okay we wanted what least
thing you do with other which is you
know the supervision free to rely on the
process yes all right well we better
test this so we should use the standard
testing techniques to make sure that
this works yep a single thing with the
standard testing make sure that this
works is what do you do about testing
your supervision trees we don't use
supervision trees very much we we tend
to use the the I synchronicity in the
futures built-in taraka they're
certainly a lot easier to unit test
compared to two actors
in so you're talking for example if a
user tries to sign in and a process
fails that future will will ultimately
time out and that that future will will
for example time out so futures and an
actor's can interoperate so you can send
a message to a remote actor and await a
reply as a future so if if that remote
actor is on another system and that
system goes down and you've specified a
time out that future will then fail at
which point you can say okay we've now
got a failure we can go back and we can
retry we we have a set of monitoring
system so all of our web services all of
our components have a number of standard
endpoints that we use internally for
monitoring or returning Jason one we've
got one called status and that will
return information like the particular
build number when when it was built
certain configuration variables we have
one called health check that will say if
that system is okay and also if any of
its dependencies are okay so if we had a
component that uses Facebook and it gets
an error back from facebook that health
check will say okay one of my downstream
requirements is it's no longer down
straighten its vanished it's dying it's
returning dodgy data etc and and all of
that we we have a live monitoring system
that goes round and polls everything on
a regular basis we'll start sending out
the usual SMS ease and emails and wake
up whoever's an overnight support for
example
handle
hi laziness and and you've got a number
of sonari for you
to be honest it doesn't actually turn
out to be an issue for for our
particular platform if we end up looking
somebody into Facebook twice it's not a
big issue when you look somebody in you
download their friends list you will
then go to the database and you'll say
oh this users already there and it will
just update that existing information a
little bit extra work will have been
done but we won't end up with any
consistency issues yeah the only state
is held in the Cassandra cluster no no
um we we just didn't need them we we're
not in in the kind of scenario where you
know this isn't a hyper critical
application of if somebody can log in
and we can show them an error message
saying sorry we couldn't log you in it's
it's not a trading platform we don't
have quite the same requirements for you
know the really really tight stability
and lack of repetition and transactional
semantics that maybe other people
absolutely need and I also I must admit
I don't work on the part of the
application that deals we with that
social side the the you know that the
whole presence information and chat and
everything so on I'm not fully aware of
everything that he's going on in that
part of the code base
an organization decided to leverage dsls
like a general problem solving in a few
places yes once once something starts to
look a bit boilerplate see you found
yourself having to repeat the same
structures of a few times it starts to
make sense so you know okay let's build
something specific to represent this
this problem what one of the issues we
have had is how to deal with the fact
that we are hiring we are hiring quite
rapidly and the ability for a new person
joining the company to be productive in
the shortest space of time and we're
doing quite well at this we we hired
somebody last month's their background
was pure C++ and they were writing
production code and their first day in
the office and we've we've found that
the dsl's really help with that and so
that is where we are needing to scale
we're needing to scale the people on
other computers the computers are
getting faster by themselves all the
time thank you very much but a developer
does not automatically get faster unless
you start using the right tools and the
right abstractions to let them work at a
higher level and in the DSL line I show
up so the deer so I showed here e is
readily understood by anybody who you've
got any experience with google analytics
and and a few minutes whereas there
there are parts of scarlet that would
take a bit more time for
people to become familiar with this
oh yeah this is a completely arbitrary
list we've got tens of these things
defines all containing different fields
you can ask for actually you can have a
valley query with no dimensions at all
with just a single metric for example if
you ask for for page views and you
specify a date range it will come back
with a number how many pages were viewed
over all of the day so so so yes
basically this so this make like spec
method expects the accumulator type and
the only way we can create one of those
is by using either a plus or a minus on
a symbol so at some point you will have
had to have given it a name and
specified at least one field to go into
that query otherwise you you don't have
a valid thing to pass into that method
it won't compile the tights are
absolutely acting as a test for us here
and there is a balance dsl's can be hard
to right there there's certainly some of
the trickier aspects of Scarlett code
certainly if you look at the
implementation of Scala test for example
you will see some very very interesting
constructs necessary to to make stuff
read naturally but the trade-off is that
you may be only have to to write this
dsl implementation once but it pays back
every single time you use it and if it's
something you're doing over and over
over again
this nobody else just
experts
the the actual API is to google does
supply a driver library for for doing
this but that API is actually fairly
heavy on the boilerplate and it does
rely quite heavily on beautiful states
which is something we try and avoid so
we we will we will wrap that and we will
hide that from from normal use
yeah with ya with in Java week you could
certainly use a builder yeah life is
just a well-designed likely so it's not
so that you kind of think it's not too
when you decide to go to dsl because i
like you we do like fun event we build
things by building abstractions and
learn some of everything r yes we call
it but by my experiences that moat most
libraries ultimately end up having some
form of dsl because it's just natural
fit for what that is okay they were I've
been told times up so thank you very
much everybody</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>