<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Sam Aaron, Joe Armstrong - Keynote: Distributed Jamming with Sonic Pi and Erlang | Coder Coacher - Coaching Coders</title><meta content="Sam Aaron, Joe Armstrong - Keynote: Distributed Jamming with Sonic Pi and Erlang - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Sam Aaron, Joe Armstrong - Keynote: Distributed Jamming with Sonic Pi and Erlang</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4SUdnOUKGmo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this tall
it's called Sonic by me yes that's right
and it's the first time we've done this
we don't know this morning we connected
our stuff that we've been collaborating
on and off over about a year since we
agreed to do this and about two weeks
ago through this flood of emails like
here we're doing this stuff in two weeks
time and we hadn't met physically no and
until last night last night and we went
off to a tea place and add a cup of tea
and sat there and tried to get our stuff
together but you didn't have your moe
synthesizer with you and stuff so just
kind of chatting what we're gonna do and
then this morning we sat up there and
for the first time we connected all this
stuff together and it worked
so that's the first time it's ever
worked so this is really rather
experimental we we don't know what's
gonna happen
the the plan which I wanted about a year
ago was you were all going to download
the sonic PI on your laptops because
you'd be told to do this prior to that
and I would have a conductors pin and
I'd start waving and they're all start
playing music I think can we promise
that for next to no problem because then
they'll be like this gap of 52 weeks
will 50 weeks and they're oh my god we
could have do this in two weeks time
they'll start writing the code so Sam
reminded me yesterday that we have to
have a road map oh yes it's very
important there with very important mr.
Rowland I was seven and we didn't have a
road map at all so I just quickly made
up a road map of what we some things I
want to achieve and want to do while I
do it I mean I'm interested in I'm
retired now is that stopped being a
programmer sir so I can just do my hobby
projects now and and I've always been
interested in music so I thought well
let's let's do some stuff and I'm
interested in computers and I have a
load of synthesizers at home as I say to
my wife there's no such thing as too few
synthesizers you just want to bother
because once a designer's one
many my wife so what do we want to do
well on the roadmap this this we want to
play the Armageddon Middies and I didn't
know anything about the Armageddon maybe
not MIDI yeah well they said one of the
dark meters and I didn't know anyone
heard of dark ready one person two
people Oh coming inference and now I
didn't know about this stuff until the
small can imagine right a MIDI scroll
coming so painting very very simple yeah
so I just all you can imagine go nuts
let's go so this is
can you hear me as well
at the moment it's not very exciting
this is the boring start warm-up because
and I think about computer-controlled
musical instruments is you can compose
stuff that no human being to play so by
now it's getting difficult to play I
couldn't play I can play Chopin but I
can't play this stuff
Chopin could have come I'm gonna say
could we might have composed this stuff
but he he may well not have done it to
me
so it's not only musically interesting
its artistically nice you can see pretty
patterns that are coming there so that's
on the roadmap isn't it really need to
integrate stuff like that let's stop it
how do you stop it right and then
because I'm classically trained in music
we we need the presentation of scores so
we want to typeset the music of John
Stumpf now how many of you know John's
dumped music oh he was a they don't know
John Stubbs music I didn't know either
so sir he was a music engraver who
engraved music by hand and he didn't use
a computer and he wrote some of the most
amazing music you've ever seen so we'd
like to be able to typeset stuff like
this right
this is typeset by hand this is engraved
by hand now I wrote el guten which is a
type settings program for text but it's
not a typesetting program for music
musics got about 400 glyphs in and it's
got all sorts of conventions normal
English text has only got you know 50s
or something like that so typesetting
this it's actually a bit of a challenge
so we need to do that as well well I
also so for me that I think western
music is quite interesting but I'm also
particularly interested about how we
could take notation like this and add
things that can't do like Tom bruh
they'll have the sound sounds I'm
thinking about how we actually notate
that as well so I think that the code
stuff we're gonna show you later yes
part of the way there but maybe there's
some sort of vegetation we want to play
music that's generated by computer
programs not by people we want to
display that in different graphical
forms and we want to start here which is
something that's simple that you can
teach children generally here heard of
sonic PI few of you good that's good
that's great because you can just type
this the simplest program in Sonic pi is
is play 80 which just means play MIDI
note ATO then you'll see no sixteen and
I also wanted to do this so mike old
when I met sonic PI I'd seen you use it
I want to make it distributed because I
like distributive things so
the Sonic pi as it is today is something
that runs on one computer and it doesn't
interact with other computers but music
orchestras and things are about
communities of people coming together
and interacting so I wanted to see if we
could make this sonic PI terrible idea
distributed thank you earth you know if
it wants to be distributed Jay well what
would we need to what was the starting
position need to be my starting to make
it distributed we would need to Sonic
PI's to talk to each other right okay so
I'd had this idea I've been playing with
Sonic PI and I bumped into some various
talks and I'm very impressed by what
he's doing some great stuff and my goal
is to make this distributed so this is
the 4a of the station hotel in San Luis
where sofa versus I I was giving a
keynote at strange loop and Sam was
there and I said I really like to talk
about how we can make this thing
distributed so we sat down here because
these seats these ones here no we don't
agree on everything and so we had this
conversation the conversation said how
can I control the sonic PI from Erlang
and something well all you have to do is
open UDP port four five five seven and
send it an OSC message message will send
it the message run code stream and I
said well what's OSC and he said it's
open sound control
everybody knows controller since you all
know each angle choice you all know open
sound control is some of them yeah well
that's all what - a few so we sat there
and I thought I don't know what this
open sound control is but we had the
planner of the internet so I googled
airline get herb open sound control
character turn and there was an
implementation of the open sound control
protocol so I downloaded it and
that program that's for my blog actually
and where I described what happened and
I literally typed in this program and
you see that run coder lied in it and
the program says play fifty youths in FM
played 60 and I ran it on on my computer
we were separate - Sam was running it on
his computer so here's my communicates
computer and I ran that program can't
work first time I love to record there
was a I mean there's great possibilities
that's fantastic so that I had this Wow
here yes here has somebody who's written
a program that I can control from the
outside so how many of you have written
programs that run on computers anybody
put your hands up if you've written a
program that runs on a computer keep
your hand up if that program can be
remotely controlled through a
communication interface really with it
with a standard protocol or HTML four
weeks no no no I'm not daughter put your
hand down if but if the answer to that
question is yes running in the browser
and it's HTML and keep your hand or put
your hand keep your hand up if you have
specified the protocol in any kind of
way like with a with a session type or
something so that people would figure
out how to use it and written
documentation and got somebody else to
use it come and see me afterwards
tell me what your program does and I
will integrate it well I don't know
that's amazing
you're you're you are I think if I had
asked her in a big conference of
thousands of yeah JVM people I mean what
is the point of writing a program if you
can't remotely control it
okay so at that stage
my understanding of Sonic PI was that it
was this thing that if you open port
four or five five seven and send it a
UDP message containing a program it's a
ruby program you send it you could
remotely control it this is the most
interesting property of Sonic pi so
where's all the documentation well there
isn't any documentation well well why
isn't it don't want people to do that
well why well because they might send
the program our M minus RF star
something in typically quotes and we've
got no security so so don't really want
anybody just to completely go in and
kill everything so the by default it
does listen on the loopback network
right so you can't send it from no case
in case you're wondering we're not
publishing right and so what's this OSC
it's an open sound control and it's very
inappropriately named it should be
called open anything control because you
can use it to control anything and it's
very nice it consists of a verb which is
like this where was the pointer thing
nobody point no well I've got a pointer
thing but I don't know what to do right
I could be the point oh okay
I didn't I didn't press the pointer
thing me Presta don't do no help what
happened oh gee it's a computer that's
what's gone wrong run to use every
button these pestis not press it again
just just use me as a pointer okay Sam
called you correctly point yeah okay so
so then it consists of a verb that
daddy's got back that's actually a
string you shouldn't think backslashes
don't mean anything that's just a string
and an application can patent match on
that and it's followed by a list of
arguments they can be integers or floats
of strings and it has a type descriptor
so for example the first one which is
note on 1 2 3 3.14159 and string has got
a type descriptor integer float string
and so by handing over this type
descriptor to somebody you you can know
what this is so by documenting those you
have a strongly typed description of
what those things of course you don't
know what the semantics of of note or
not it's not self describing in the
sense a JSON or XML is self describing
you don't tag up all the data items you
just name the message and it's assuming
you'll know what that means and it
assumes you know what the types mean and
that's a much better way of doing it in
my opinion and Jason or something
because just the size of the encoder and
the decoder is at least an order of
magnitude smaller than a jsonparser I
wrote the parser and everything myself
and I've written a jason part an xml
parser and the parser for this and i
tell you you don't want to implement an
XML parser yourself the reason for that
is XML suddenly says you've got to
include XM xml path as well and it's
like when you saw well you've got tools
to do that and you've got to do exocrine
thing and basically if you want to
implement xml you've got to implement
every RFC on the planet and the entire
internet this is very simple slight 100
lines of code of 50 lines of code in and
there you are it's done right so what
happens next
yeah I said that and people do use over
sangwich oh yeah they use all sorts of
things as their robotics people use
robotics you can patent match things you
can say actually I want all the messages
that regulate to my arm move them up and
move them down so there's a lot of user
cases every sandwich I started digging
into its later when I haven't done this
we decided we would try and do something
together and I started digging inside
sonic PI to see how it worked internally
and I found to my great joy it wasn't
this one poison like that thing on the
top if we expand that it actually looked
like this it we've built out of three
components a GUI which you could command
by sending messages deport four five
five seven a server which was doing the
logic of the GUI the GUI it said do this
play this do this stuff and I said and
the music or the tones were being
generated by a program called a super
collider and super collider is a thing
I'd come across and never amazing that
it software and then all goodness well
it turns out the supercollider itself
recursively has this structure where
it's built out of a programming language
and a sound synthesis engine but
actually has a big extremely nice
architecture so I thought yeah this is
really good stuff and I looked up some
documentation about the supercollider
and it said yes the server is an
independent program that we communicated
using global central all you need to
know is it's an IP address such as and
it's port the code that does that is ten
lines of code if you can imagine the
enormous difficulty of interfacing
owling and see your bearing and Java or
Haskell and C and haskell and java
languages which have a different view of
the world languages which represent
their internal data structures in a
different way are very difficult to
interface but interfacing through
messaging is really simple
Helen Kay will be here tomorrow he'll
tell you how messages are wonderful and
this is the way we should interface it
wasn't always this way so the early
versions are supercollider and the
server were this warm big binary blob
and there were some advantages of shared
memory but by separating agent
separating them at to these two parts so
J's McCartney wrote supercollider he
wanted to explore different languages to
communicate with the synthesis engine in
order to try and see if as
would be an interesting language to
writes your end user part in or Ruby or
a small talk or Erlang and so by
separating these things out
he basically opened up so supercollider
for us to start playing with and and you
as well whatever language you want to
work with so we stopped talking about
this and what would you do and and Sam
said well he wanted us more less a
single abstraction there's an additional
thing in you know SC which I haven't
mentioned that's time stamp bundles so
we've got commands that's one set of
things well we can add a time in front
of the command and basically means do
this stuff that's in the command at this
time that's in the bundle head and that
should be done at a precise time so
getting it writing really easy about 10
lines of code and everything so I
thought well let's implement that and
and and Sam will be happy and we'll see
where we go so so I'm gonna implement
this as the first shot here so the first
thing I wanted to do is kind of figure
out when we're talking about time and
the accuracy of time I went into kind of
geek mode and thought yeah house airline
got sufficient timing accuracy to do
music properly because prior to now I've
only done telecom systems and they are
the accuracy of the time is a few
milliseconds so that's pretty easy so
musics I'm thinking is that okay or do
we have to go down to finer times it
depends on whether the the sound is
actually independent sound which sort of
10 milliseconds is probably enough but
if it's the same sound from the same
source and you'll get phasing issues if
it's much less than that as well so I
thought to myself okay let's do a few
experiments I've got a load of MIDI
files now MIDI files are just timed
sequences of events there are delta x in
an event and the events a note on or
note off and then you just wait for this
so this is the most simple-minded
program you could possibly write which
plays a sequence of Delta x fair as well
if the if the Delta time is zero you
just send the MIDI event to the device
and if it's got a delta time it's not
zero you sleep for that amount of time
and then you send the message
that's really simple we just iterate
over there and this sleep that's just
the sort of vanilla sleep in our
language the simplest sleep that you
could possibly do you just wait on a
timer and off you go
so that's a brain dead program you know
that's a really simple program to write
texty five seconds to write it and the
question is isn't good enough what
happens when you write that oh so sorry
about that
this is Chopin's waltz in c-sharp minor'
over 64 number two so that sort of
sounds alright although it sounded
pretty lousy do there because we have
some crackle on the speakers but no but
easy it actually okay well so the next
thing I did was no it's not very good
the reason it's not very good is the
time is drifting slowly and we're not
aware of that fact because every time we
do is sleep our brain is kind of
relating it to the last the last time so
by the time we're at the end we are
literally depends right so you're using
this on Erlang this yes what your design
here is the first thing I did in sonic
PI when I built it for the classroom in
two weeks and on a Raspberry Pi one will
be running on that it's much much much
worse problem perfect you can really
noticeably orderly hear hear the
difference so it depends on how fast the
architecture and how fast for languages
as well so I thought well let's look at
the timing to see what happens and I
thought well okay so instead of doing it
that way let's do it a different way
we'll we'll measure the clock when we
start and then we'll measure the
relative time in in delta x and then
when we got to a particular point I'll
measure I'll look at the clock and we
and resynchronize using the time and
then I was right and it turns out that
Sam had invented exactly the same
technique this kind of musical clock
that we resynchronize all the time and
and I did it again and let me see I've
got to change a choice here why doesn't
it come up there's a thing I have to
press but I can't see it now no where's
it gone
it's probably just be Preston right but
I don't have to do it there like this
then they can't see it very well they
kind okay you can't see the slides but I
can see the buttons I have to press in
order to make it placings right so this
is sloppy this is the bat this is a bad
one
well that's terrible sorry
and this is accurate timing well it's
not you're hearing a difference just
leaving here well we can't we can't fix
that up so that was that was better
timing although not perfect timing and I
wanted to understand why that was so oh
oh it does it when I push the button
yeah it's not amazing okay right that's
good yeah we can we get it um so then I
discovered that the the Mac if you if
you say sleeps of 50 milliseconds or
some like that 40 milliseconds it
actually is a bit late because it's
trying to cause it's trying to help you
by conserving power so it turns
everything off and does thing and it's a
bit it takes it a little wee while to
get started and so it's always late and
there was a long discussion on the
ailing maybe this is why it is so I
bought a new strategy to sleep to about
three or four milliseconds until the
time I really wanted and then go into a
busy wait loop which is totally ashamed
to say this we couldn't find any other
way of doing it when you do that you can
you can get down to hundreds of
nanoseconds in timing precision but not
always because occasionally you're a
whole hundreds of microseconds out and
this is not my fault
it's bloody apples fault because say
they want to save power on the processor
they they do horrible things like
balancing the temperature of the COS and
swapping things out without telling you
so so really it's a horrible thing to
program but but you can you can do it I
thought wait a moment
let's because I'm programming an airline
and I like airline so I thought oh
what's this representation of music I've
represented this the way you would
normally do it and how you would
normally represent music is by a
sequential program that basically sleeps
for the next event and then does it and
I thought whoa hang on why don't I what
did I create a thousands and thousands
of parallel processes where one parallel
process
presents a single note okay and what
I'll do is just to check just to check
the accuracy of the clock I will create
19,000 well I'll take a bit of music
which just happened to have 19,000 821
notes in it and I would create 19,000
821 parallel processes each with a
little timer that plays one note and I
see what would happen what would the
would the scheduling system manage to
play this because now there is no
synchronization at all it's a it's an
orchestra imagine an orchestra with
19,000 821 musicians in it no this is a
piano work right so imagine 19,000 821
pianists all sitting at a grand piano
they've the music they've been given is
really easy to play because all they
have to do is play one note at a
particular time and they're given a
clock and they say you play this one
note at this time and they will sit
there looking at they want to boom at
the right time and I'm gonna let a
computer do that so I was kind of I
didn't expect that to work because
there's no synchronization for I didn't
expect ordering to be preserved and all
sorts of thing I thought was gonna sound
horrible so for the first time ever I'm
now gonna you're gonna hear a program
with 19,000 821 independently scheduled
events and just let the clock do the
synchronization and the first time what
I need to make sure that it goes the
right order and I press the button so
I'll do it this way so this is the first
one because it's about 10 minutes long
this big it's
did you start it yummy you didn't press
appropriate oh this is it can you hear
it that's it that's the word but the
auction is playing now and then the solo
is coming back it's like the dark
minister
that's it Koda
that long yeah I know that's 19,800 21
parallel processes all doing their thing
so at this state I could you know if you
could kind of mentally slow that down in
your heads
for those of you are interested in can
amusing who can identify that any
guesses okay so I thought so what does
it really sound like when we don't slow
it down did it sound okay so I've got
the first bit just slowed down this is
you're now hearing parallel processes
triggering on a clock they are not
synchronized at all it sounds like this
Oh
what sorry about the quality
then the officer come board or who knows
what that is
oh come on no what no guesses have to
tell you no no don't play that again yes
it's a black man oh no it's the
beginning of black man an officer piano
coach ever did that when he was 18 not
bad eh
pretty good so at this point I thinking
yeah we can do timing we can do it down
to hundreds of nanoseconds if we want to
we could represent music as sequences of
parallel events and just sort of share
do them and there are actually going to
be any problem so I'm happy with that
let's see what we've got
so you mentioned the most important
thing right so you can totally imagine
doing this in JVM right so I'm gonna
spawn a bunch of threads sleep for
whatever amount of time hit the notes
told I can do that in Java you do that
in Java right it's not hard or Ruby the
biggest problem though is that the
garbage collector randomly decides to
stop the world at that point your music
just pauses and then continues okay all
right and that's I think the thing with
Erlang right you don't have that problem
so you can play that program time and
time and time again and you'll never
coordinates doing it yeah well garbage
leper process rather than yes for the
whole system right so back to remote
control um another way of looking at
this is that there's a communication
channel between the GUI and the server
and so a natural thought to me at least
is well I'm kind of interested in what's
going on there so I'll put I put a
little spying program in between that is
purely a transparent spy is just
watching everything and I thought to
myself hey that's rather cool because I
can now modify Sam's programs without
him knowing if he writes the word Sam in
a comment in in his code I can insert
her like in the middle and you won't
know anything about it and I thought
that's a really nice way to do things
and this is a sort of a longing way to
do things we we observe the
communication between processes so I did
that and we got all that working
Sam to modify the sonic par little
little place so we could allocate port
numbers to it and it worked more or less
a little bug in pretty soon and I got a
strace like that and I'll send the
tracer to Sam I got this excited mail
back that said I completely understand
what you're saying about the beauty of
being able to see this Indra I've
already had a debug flag it's intensely
and it's been intensely useful but he
started saying um how long have you been
able to do this and then I mailed Mike
Williams and said how long does how long
the ferrets gonna be none of that I
think we first did it in 1974 or
something you know we've always been
able to do this tracing stuff one of the
things people say about about message
based systems apply to any message basis
is it gives you a different level of
abstractions you've got black boxes that
do things and you've got the messages in
between and to me it doesn't matter
which programming language you use
inside the black box provided all the
messages are the same
I don't care about programming languages
people people are going on and on and on
about Ruby we should program in Python
we should program in Haskell we should
program in Erin we should program in
c-sharp we should program in C++ there
are thousands and thousands of
programming languages and I say it
doesn't make a big difference what you
do the most important principle in
computer science is that of
observational equivalence if you've got
two black boxes and you cannot
distinguish them on the basis of the
messages that going in and out they are
the same this is the most important
principle there is and Sam makes this
wonderful system where I could just send
the message in it says play some music
play a note and it does it and I don't
need to care about how it works or how
it's done inside because we are just
looking at the messages we can put other
tools in place to monitor all this stuff
so the debugging you put in your program
is completely unnecessary we can observe
the behavior of your programs by
observing the i/o that goes in and out
of them and that is the correct place to
observe them because if we see that we
send a message into a black box and we
observe
that the message that comes out from the
black box is not as we expected we can
infer that there is something wrong
inside the black box and that's how to
test things we have raised the
abstraction level to something that is
reasonable and we've done it this behave
exactly as we behave we send messages to
each other other people can observe them
we can observe errant behavior by
noticing faults in this communication
this is not the way we routinely build
software but it's a way we should
routine software right so the
architecture of this follows what I
would call the UNIX philosophy the
original UNIX philosophy which we build
systems out of small units each unit
does something rather small and it does
it reasonably well and we glue these
things together the way that uniques
glued things together with through the
shell and through pipes that when you go
into a distributed system becomes
sending messages through sockets or all
or through UDP or TCP messages and you
have a standard way of encoding the
standard way of coding is very important
because it's saying that all people
should speak the same it's like you know
there I don't know how many human
languages there are but if we want to
communicate it's very convenient if
everybody talks English or if everybody
talks French sure I mean when Britain's
left these oh sorry I mean they're how
the brexit negotiations in French
because everybody understands French 28
countries understand French the British
right so this is C over UDP it's
actually it's actually the simplest way
I can conceive of connecting things
together I said what would I do is just
reinvent the digital audio workstation
these programs like Ableton and they are
amazingly powerful amazingly complex and
amazingly difficult to use the problem
with this approach is that programmers
have made system systems for
non-programmers
where they can manipulate every single
musical event there is not by writing in
text not by not by writing a small
program because they've they've made
this conclusion that people don't know
how to program and therefore they
haven't given
the opportunity to write programs what
they have done is given them the
opportunity to manipulate extremely
complicated data structures by clicking
on buttons and dragging dials and
selecting things and that is an
appalling ly bad way to do things no no
sorry Sam come to meet Lee the different
thing
I said let's do this in text and let's
start off with 10 year olds yeah to do
this the alternatives I mean there is a
protocol right we should able to use it
which is middie yeah it's just fabulous
yes for the resolution is 7 bits you
have 127 different values which is
totally useless right so to get a
program to be remotely controlled it has
to respond to messages and do that and
we set this stuff up the future Sam
wanted a bundle scheduler where we can
send various e messages and retesting
and we just tried it this morning what I
want to do there is if you're doing if
you're playing one bit of music on one
instrument the time synchronization
doesn't matter but if we did it
Orchestra here and we blast out I want
you to play the violins and you to play
that and you to play this synth and you
deploy that simple they've all got a
sound at the same time if they're more
than about I don't really know we reckon
10 milliseconds something like that if
we're more than that we're gonna be
screwed yeah so we don't want to do that
and now I put this primitive in and
Sam's been using it and he said he's
written some stuff with it I haven't
actually heard this yet me neither
sorry you you haven't heard it either
okay so Sam hasn't heard it either that
sounds the SAMS sounds basically a new
type of musical instrument where he's
invent he's reinventing music using a
computer so he does this live coding
thing so in the future few hundred years
time they're going to look back and say
well so Sammy was like Mozart or lots of
other like terms I'm not the only one oh
no better no because when Sam can think
something he can think some music and
then he can write a quick algorithm that
does it so he can get you know do you
realize how difficult it is to do lists
you know easy study he studied for years
before he got good at it you can place
you can out you can play the fastest
appearance
were Vladimir Vladimir what Susan
Horowitz was reckoned to be the best
pianist in the world you can play scales
faster means you can - yeah well never
else Oh cheap because we use a computer
exactly now that sounds now going to
show you what we can do with timing and
cheating yeah in chosing programs yeah
sure so we run out of sizes yeah I hear
we have I don't know I've got no idea if
the sounds good actually sound good or
not it's not correctly like it was then
so the goal with sonic PI has always
been to try and teach computer science
to kids right and there's a tough
problem with that which is kids that
really don't have much time to pay
attention they're not really focused on
what's going on
and so you have to make things look at
the resolution that's amazing you have
to make things really really really
really simple so we've seen this as a
play 70 right so we've seen this and we
Joe talked about this and this right and
if this is POSIX leap my desktop to nuts
then obviously gonna get drift right
because you're not just talking about
the time of good obviously one says
think for at least one second not
exactly one second at least they're
waves are scheduled to wake up but also
line one play 70 takes some time a
computer site so you're you're gonna
counter good exponent take two
distributed computers play that program
on both at the same stars yeah and just
see if that works do they keep in sync
or do we need to do more than that
because in the early day the reason why
I really noticed is that in the early
days if this was no problem for kids
right they were just happy doing this
play sync placing please thing but there
soon it was a point where the kids were
saying right this is my melody love it
wicked where melody you love it right
actually that's just speaking a slightly
bit more interesting right
that was a melody and then they also
wanted is this the good stuff yes when I
keep
get rid of that right and they would
have like I know play 50 thanks where's
the bass
oh that you've got a soap right since
news so you can change the synthesizer I
know tb-303 right and so let's do that
I'd know four times
maybe this
right so they would have these two
programs and they would want to pay at
the same time right and so unfortunately
computer science curriculum in the UK
which is fabulous and we have one
doesn't allow you to do that cuz you
need some sort of concurrency thing
right that's typically taught at
university so why I basically out
through concurrency into sonic PI and so
you could do this put these two things
and you could sort of say in thread do
like this on there now it's not working
for some reason
oh yeah yeah that's because you can't
hear it exactly right and so they were
writing programs like this but they just
sounded horribly out of time because the
same thing we're talking about for the
fact that do you this not point five a
different nor point five minutes because
the scheduler this company might take a
bit longer shorter than then that's and
then of course on the Raspberry Pi one
all bets are off in terms of how fast
the machine is so it's really was
drifting quite badly
so that's when I invented the logical
clock thing that Jay was talking about
and made it all work in time so now on
this machine it emits totally fine and
so for a single machine from talking to
Ruby to supercollider it's all fixed but
everyone keeps saying to me Sam I like
this one it PI but the sin it's not like
great say I'm sorry I have invented them
not very good at that and I've got like
loads of hologram people say got loads
of hardware how do i play sonic PI with
my hardware right and the problem is
that if I sent messages MIDI messages
from from this program here at say this
time here it wouldn't actually so the
play 30 the way it works is it schedule
the message ahead of time so you can go
to think of this as a program which was
running concurrently which are sending
asynchronous messages to an external
server which is the music server each of
these play commands essentially a
dispatch of a message the message
contains the timestamp of of when you
want things to happen in the circle
counts and control thing that Joe was
talking about the server receives that
message and then schedules it to happen
and
grams so we're not doing timing in Ruby
because that would be crazy
we're just doing management of logical
clocks with Ruby and that's actually
fine and the concurrency is fine because
they were working at human speed not
machine speed so they could either
spending 8 times a second and be the
good thing about green threads is you
can just randomly new Clem and it's not
a problem I'm going to sort of wait for
a machine to release its of handlers and
things but when we're talking to
external machines like this synthesizer
here we have a problem because if I put
a line of code in here which says play
my my motion synthesizer it would
dispatch that as soon as it ran the code
right and then the message would get to
the synthesizer it would play it before
the supercollider play this because this
is scheduled ahead of time and also the
delay of sending the message to
receiving it it's going to be subject to
jitter and so the timing is not going to
be right at all and then if ruby decides
to GC again you've got more jitter and
randomly all over the place so although
people kept saying are there's loads of
Ruby libraries for doing MIDI you should
just throw it in it was never really a
simple solution because of all these
problems the timing problems and so what
I really wanted in my head was if I were
to write something like this and I know
closure or Ruby or something the way I
would write it would be to derive a
server which listens to messages it
would then spawn a thread wait for a
political amount of time to make sure
that that was the right time and then
forward the message on right that was in
my head but because of the GC problem
this is not really a viable solution on
most languages but the Erlang approach
was exactly idiomatically the same right
and so Joe's like 30 or 40 lines of code
just read exactly like that
and of course spawning a thread
underlined is insanely cheap and there's
no global GC because it is a process as
a completely isolated thing and so it
can really handle this timing in a
rock-solid way whilst a program isn't
some Harry C nightmare we have to write
some horrible scheduler code which I can
imagine like the Linux kernel most put
into the nightmare for this and so this
worked perfectly so what we do now is I
can now instead of play 30 or this kind
of thing I can write mogh 70 and then
we're getting the messages now you're
not going to misuse
oh you got something going there why is
this not working because this is always
seen I mean making lights flash that's
what computing is about isn't it's not
writing web servers and things I'm
making noises sorry what well the
message going through but they're not
going through to the Moga thing this C
library so this is this is Erlang here
printing messages and then this is again
so that talking about the small
processes
I don't using Ruby's MIDI stuff at all
I'm sending open sound control from Ruby
to Erlang Erlang scheduling it to be
folded on to little C library which my
friend Lois larette's written and all
that does is wrap around a MIDI library
so just was essentially receives open
sound control and immediately dispatches
it to MIDI but we seem to be having some
sort of problem with it that's seen your
long bit which works it's good and this
see what is going on its founders ear o
MIDI inputs it was doing this earlier
I'm just super annoying to this little C
library should actually recognize that
yeah there we are it's found it now all
right so now all right right we're good
so that's the mode to the sides are
coming out of these speakers which is
different from these speakers right and
and this is a piece of hardware which is
entirely separate from the software
inside of here but if I if I play this
louder playing the same time
yeah they're actually there is there
very very closely Alliance and we've got
multi beat look it's got flashy lights
right I like tragic night sorry this
this to me is like just the fact that
this works is is a fabulous thing
because now I can control any MIDI
synthesizer or any open sound control
thing with the time again so just mobile
to do how long we got left show each we
make some music
yeah five minutes yeah so we can do it I
can always all right so let's let's just
show you that more if I got a twiddle
well you can just wit all the knobs gel
justice Rizzo so I guess so
and also the cool thing about the thread
thing is that you never really want to
use use that you want to use this thing
called life is much more fun oh all
right and then if I do there
but generally it Tony works right so
what I've got here is two threads
running this they're synchronized with
each other because you can totally do
this
this one's playing the analog
synthesizer and this one's playing the
internal supercollider but you can start
to totally imagine instead of saying my
mode connected here what the MOCA later
on Joe's machine yeah and then starts to
figure out how to show you how to use
Erlang to combine all these things and
the story for me was that I mean I I
didn't invent all these things and
invented nothing of this stuff I just
watched and saw he was architectural
decisions right so supercollider
separating out these two things was a
beautiful thing for me and made a
complete sense and I had imagines if I
could have something that sat in between
like this earlier thing the benefits you
could get were quite profound right so
one would be you could do this so that's
the first thing scheduling these things
have them all and signalization but once
you've got something sitting in the
middle as Joe is saying then all you
need to do is tap the messages and
stream them to disk and you have a
recording right so all the events going
out to both superc line around the mode
I just put the disc and then I can just
play them back do some offsetting of the
timing of the bundles and I can replay
all the things but if I can store two
discs I could also send it on the
network which then means then you could
all be listening to the message of the
things I'm playing so I now have
screencasting for Sonic PI which doesn't
require me to send video
and all do and all that so nonsense I'm
just setting a little simple messages
and you were able to essentially
reproduce the sound on your machines so
then allows me to do distributed
streaming but then this is where we're
hoping to work for very soon is that
wouldn't be really interesting if I
could say mr. Joe you can send a message
to me and we could jam together whilst
you're and sweetly really great from a
discussion like this and a meeting like
this and with people like you in the
audience is if we could i I call these
end I just call these end points an end
point to me is something that receives
OSC messages they're OSC over UDP you
can implement that in any language you
can do it in Haskell you can do it
independent type systems you can do it
in whatever you know people say Sam you
put it is have you got you guys you must
have different expertise I mean I don't
I don't know how to do graphics I don't
know you know I'm crap with graphics and
things like that so somebody here and
sitting in the audience is really good
at graphics who knows C++ or knows you
know Haskell or something has got a
really nice graphic can just make a
simple end point that's got a graphics
canvas so we can just send a few
messages start defining it somebody else
knows how to play mp3 files make a
little a little player a little MIDI
player a little wave file player a
little thing somebody else knows how to
trap keyboard events off MIDI devices
just contribute these things come
together and build it and specify them
so we can build an open architecture for
this kind of application and by doing so
we can show other people how to build
applications because the way we build
applications of including code and
running them in all gluing them together
is appalling ly bad we need to break out
of this we have we have any things for
micro services which go on the net but
they're not they are completely badly
named they're not micro services they
are macros huge big ugly's of micro
services tiny little things have less
than a kilobyte or something just
running locally on your machine they're
not things of selling money and data
centers for IBM
I can services there ways for big
corporations to make a boatload of money
though good being able to speak to some
musical backgrounds like it's wrong yeah
what about our instruments like guitars
sorry our instruments like guitars like
that's ok that's obviously gonna work
but what about like more analog
instruments like guitars bass from what
about them what can you plug them into
that because they're fabulous so we're
not trying to replace you no no no but
you want to play it there and put it
through that so you can whatever at the
weekend yeah yeah everybody once there's
I mean sonic PI itself also supports
ability to get sound in from the sound
card and treat it like a synthesizer and
you can apply effects to all these
things so yes you can already do that so
it's just a it's basically an analogue
inputs yeah so that could be anything
you can recorder the microphone yeah so
I one of my thing one of my duets I jam
the guitarist and we pipe that into
Sonic PI and I'm able to add effects
they're also synchronized with the music
quite easily so flanges and what's up
stuff slices yeah oh yeah so what we
intend to do is strip down a Lang -
because it's like hundreds of megabytes
at the moment it's make it into about
ten megabytes just squirrel it away
inside sonic PI so it all gets
distributed and then we can start
teaching kids distributed programming as
well because as well as as well as just
having like two sonic pies hey why
should we concurrency right but I mean
once you've got two sonic pies and
they've discovered that we can send
messages you could we could introduce a
new notation like you're sort of Sam
bang a message and on the other side you
could day like receive message and it
could print out on their screen so
school kids could start writing
distribute down
yeah and we could sneak in some computer
science into into the audience thinking
in the parentheses around things what to
modify the air they've Ruby syntax you
know that so we'll keep that will keep
the lambdas and things that they can do
that when they're 11 yes
any more questions so it's also our
quite make it a small announcement so
there this is the latest version of
actually this is the we're showing you
beta of 2.12 which I just made a half an
hour ago or an hour ago 2.11 on the Mac
is released now so this is the official
announcement it's there available so if
you have a Mac you're free to download
it now Windows will be around on Monday
if you've got kids ten year olds and you
want to teach me programming I think
this is the best way I've ever seen it
because the shortest program is like
play ten and it's not one of these silly
things of graphic user interfaces which
I hate you know it's a texture of
interfaces we actually are we
communicate by writing and this is a
major way we communicate further
generations we can describe things in
text it's brilliant but there's be this
horrible thing to replace simple textual
interfaces by origami gooey sort of
thing click on nonsense to do stuff Sam
and Joe ladies and gentlemen thank you
no more thing obviously now it's like
social time there's lightning talks
going on all sorts of cool stuff which
I'm sure you're gonna announce in a
second but also I'll be making some
music here a bit later as well so if you
want to have a sensible conversation and
talk about developments then you need to
leave this room ok right Joe don't shout
at me for making much noise but if you
want to see what you can do the system
more than much more than what I've just
showed you now come and come and see a
bit later and see what you can do
thank you so we've got lightning talks
we've got drinks and will soon have Sam
in this room as well right enjoy your
evening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>