<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2015 -  Jan Pustelnik - Performance implications of various programming styles | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2015 -  Jan Pustelnik - Performance implications of various programming styles - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2015 -  Jan Pustelnik - Performance implications of various programming styles</b></h2><h5 class="post__date">2015-05-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/B-_e0aioiQ4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so maybe I'm kind of start okay so
maybe a world of introduction my name is
Yann and I'm running the colors of the
gfd bones company that's doing
consulting services so in that capacity
I'm currently working as a scholar team
and track lead for one of our customers
doing some boring stuff financial stuff
it's totally boring but what's
interesting is in Saqqara so as I looked
through the code base which has some
significant size get hunt different
idioms programming idioms
okay so barring from immediate quotation
to like highly melodic pure functional
style and as they're highly melodic pure
functional sighs either the hype of the
day okay
everyone talks about that I wanted to
evaluate the performance of that this
curve the case of different ways of just
inspires of writing code and still being
in functional gender so doesn't work too
well this is not the right right okay so
I will give you some examples in-house
coast kala and super loss blast okay I
will be benchmarking them I have
benchmark them on a single machine okay
so it doesn't matter what kind of
machine it it was it was running Windows
seven just by accident because I had
situation in handy by basically we are
interested in the baseline so in the
difference of performance between
different programming different
functional programming stars okay
so much marking Scala is really
difficult okay because first of all when
ranking Java is very difficult so
there's this nice libraries called jmh
to do it and someone
actually common Milewski which i'm very
thankful wrote a report adaptor
authority Scala okay
so running Scala 2.10 for fairies and
Java 1.70 something and jmh 1.5 for
Husker benchmarking is even more
difficult because it's a lazy language
okay but there is nice library for that
written by Brian O'Sullivan which is
called criterion nice I'm running has
purchased CSUN 0.813 and I'm combining
with the optimized option because I want
everything optimizing optimal and as
fast as possible because it's slow okay
but it's maybe a but hadith what I want
to show you so I also run some C++
examples new benchmarking harnesses
there just won't block time so really
old sir I mean I'm using
mingw for a21 and GC forces it doesn't
matter I'm burning the windows this
matters because in fact if you run those
examples on Linux you might get a bit
different ratios between C++ and the
rest of the stuff I'm not going to go
into details anyway you don't have to
find it out in the internets okay so if
you want the color to real the real
thing just go to this repository and
you'll get it's some random name okay
I'm kidding okay so I before before I
really begin so directionally for for my
thinking was I looked into the code I
looked into the the source code there
were different programming styles then
like a month ago there was a guy who
really completely ridiculed this whole
big data industry by running some you
know some MapReduce it's called my
rapper juice or some graph algorithm on
his laptop and on one thread he ran
hundred times pasta there were 128 cores
Hadoop cluster or some other some
organized spot library but you know he
cheated he said one important way so he
used an algorithm which is highly
mutating and it's not very easily
distributable okay so it was a trick
okay so I started thinking okay and so
what is really that the relative the
relative performance of such solutions
like imperative solution against
functional solution and the other thing
is well if there's nice languages like
Haskell where you can do only people
functional puncture your functional
programming so if you want to cheat you
have to use something is called I don't
know not or St Mona so if you go to the
LDS shoot out a benchmarking game you'll
see very fast hostile programs which are
in fact imperative programs running in
an ST moment which is a trick ok which
is the treat the problem is ok it's fast
it's pure functional but it's pure
functional in the name because everyone
says that pure functional programming is
cool because you get the correctness of
your programs for free so you gather you
look at the program and you see that the
program is really correct ok so I
started with merge sort so I I took as a
as a examples sorting algorithms three
months old
quicksort quick so to speak supposedly
and I don't have to keep sorry ok so a
solid metals metals is just a portal or
everyone knows it no one knows who
discovered it
Knuth babies that it was from no man
around 1945 but actually we don't know
so everyone knows it everyone could
discover it is obviously correct so
medicine is very simple algorithm you
just defined how to divide in half
divide in half and then merge merge
merge merge right branch any other
sorted sequence has nice functional
implementation ok
is easy to implement functionally
difficult to implement with mutation
works well with least tapes like you
know old-style tape sequential data
lists yeah this is our tapes and it is
very fast in asymptotic time so if you
if you could you know ask to your
intuition like computer science or
addition who runs a totally unreal model
of computation like rum machine okay
he will tell you that a history ends at
merge sort because you cannot go faster
than oh and log N and that's it
okay so we're fine cons may be slower
than quicksort okay but the pixel will
be discovered like 15 years later so
nobody cares about that okay so let's
take a look at the merge sort
okay this is just run resources for
examples I didn't write it myself
I just took curated curated examples
from the Internet's okay the public
domain MIT automatic Creative Commons by
attribution like the slack overflows all
examples ice CC by attribution
okay so haskell c++ january scala I took
programming in Scala example improved by
someone to actually work okay good so
let's on a scale Matt sort is really
nice this is matt salt does just melt
okay so you have this merge medicaid is
just this technicality okay merge salt
analogous to things the list is done
we've split okay this is this is some
clever way of splitting with going only
once with the list so it's supposed to
be very fast and the merge is just a
list merge okay you could just say a
split at and but then you would have to
figure out what n is and in order to
find out what n is you would have to go
through the whole is because Haskell
doesn't store it for you because pure
functional end this is for poppin in
Haskell okay to saw anything okay so
this actually I'm just showing you this
care not to tell you was inside of this
curve because
I don't care I just want you to take a
look at this code it's pretty this is
pretty it's pretty simple okay you could
understand that easy and you can infer
be confident that it works okay
so bottommost assault in Haskell
somebody it might be faster because it
just goes bottom-up so it's just listen
comprehension to split the list and
there's just bottom-up to get all the
work done no double recursion should be
faster might be faster okay let's see
the benchmark okay you can do also in
C++ and this is actually nice one
because in C++ actually we have a
standard library okay to talk off okay
so this standard library makes our lives
easy so I have in place merge I have
standard matching placement what you
what you want of course I'm implementing
this in the okay in terms of time
classes random access the activator is
right class as you see now the
interpreter trades on the max history to
value time so a nice tight class all
those syntax is really not nice because
it's some like evolutionary extension of
something coming from the nice size
color okay merge so this color really
easy now I'm doing this trick I'm just
taking the length of the list here
okay I'm splitting an ad might not be as
fast maybe should not be as fast but
it's fairly comprehensible what we have
here okay and bunch more times okay so
let's see
well C++ is really faster okay maybe
because in-place merge is really fast
and maybe it's you know it's something
optimized because it's in the Sun to
library house call doesn't matter if we
faster than top down but not my March
times in milliseconds so to sort 1
million records you're taking five
seconds on a recent hardware okay pretty
recent hard with five seconds for
sorting million of integers this is
really I mean this is so state of things
was really slow abysmal slow as we will
see
okay and Scott's house quite fast one
second okay
C++ is really fast maybe it does
something behind the scenes which is
mutation okay
and then let's go to quick song okay
quick sound is quick but it sounds quick
in terms of obstruction okay it's really
quick okay so it's something like kind
of taboo in theoretical computer science
just write something that works okay
it's really difficult to publish such
results because no one really actually
wants to see those results published
okay hora did it this guy okay he took a
break from theoretical science did some
real programming around 1960 but
everyone said okay if you've shown us
this quick so that we don't believe you
that this quicksort is actually quick no
they believed him because he had numbers
but he said we don't know if it's not if
it's false so her hard spent like nine
years inventing corner logic to prove
that it actually solves and higher logic
is actually something we which we can
prove programs okay he wrote another
article with logician extending core
logic and then then in a book in which
he's shown how to prove algorithms so
it's really a dumb thing you don't need
a clock or a trace for then but of
course would be nice and more functional
okay that's a wait so it's quick and but
you cannot implement it functionally
okay you cannot it's impossible okay
because it needs mutation to work okay
so it doesn't work well with lists once
a random access demands mutation okay
and nobody knows what it does okay so
these are just code samples it's like
this is something I'm going to talk
about the esteem or matter or Scala it's
just some code from excellent book of
functional programming this Kalibak
ojou-sama and will not be honest on okay
so this is ugly
standard quicksort with a bug taken from
a desk keys Scala by example
okay for a nice 16 this magic here
imperative impure magic being done there
is a balcony hidden in here but this
back was in most of quicksort programs
you know in 20 years it took 20 years
people to discover this back ok but it
is that ok and well good so this is in
Scala you don't trust it ok so let's go
to huh scale ok Huskers your is
functional it's perfect so if I want to
write it in Haskell I go to a steam on
that and I get that
ok
it's functional programming should be
obvious that it's correct that it's
working it does what it does but it's
not this is this is the point it's even
harder to see what task than in standard
in pure language ok so actually to be
sure that it works we have to prove it
we have to go to some logic give some
assertions like in volumes which require
a living person to prove it ok ok
nice then we have the same thing with
Scala we use the scholars library which
is library not a compiler a house care
has a compiler and Alliance is even more
ugly ok so my example even more ugly but
maybe it's fast ok and this is
functional quick sauce there's a very
nice program but it's not quick sauce ok
because quick sauce has to salt in place
ok so it demands mutation but it's
obviously correct in fact I will tell
you this is a kind of kind of math so
let's clever man salt it doesn't your
split in half but it's please the
smaller ones into small ones and bigger
ones and then runs merge ok and let's
see let's see ok this is this is
functional salt in color also taken from
scholar example and this is functional
quick sauce in a C++
ok syntax is ugly but is really
functional is it's in it boy
beautiful returns copying everything
scopic you can be sure that it kind of
works and these are times what is really
interesting so it's like a variety of
salt salts millions of Records like in
112 milliseconds okay so if you do
functional you're going to be 20 times
slower okay st mole nut doesn't work for
Scala because it's part of library so we
have problems real world problems we've
got much collector so it just never
finishes like okay never being 13
seconds so it's slow and well so you can
see yourself as C++ functional it's also
very slow because functional is slave
this is a problem it does a lot of
homesick he was called come sink in that
70s okay but it's a turn from list but
this is why let's be lost
okay this is why functional programming
hasn't become more popular because it
has to do constantly it has to be slower
this is a problem okay so like
functional to functionalism or if you
use a steam or not in fact you're
getting a pure other if so you could do
mutation good imitation skull others
mutations some the library MLS SML or
calm will do mutation okay so how to
make sure okay i'm gonna skip the heap
sort because it just shows some
immutable immutable data structures were
running after the time so i just wanted
to show you that actually heapsort using
immutable data structures like scholars
a heap or haskell PQ or hip disable
immutable data structures is kind of
really really slow scala priority queue
which is mutable data structure is way
faster okay because we continue tation
but what is interesting we have to do we
are doing something mutable here so you
see here you're using mutable data
structure we are using even maybe var no
we're not reading they are mutating
inside the priority queue but it doesn't
get outside of it okay and this is
something I want I'm really I'm really
thinking is the important takeaway from
this because Dom it doesn't matter if
you are doing functional programming if
you are doing functional programming
you're doing it if you're doing it in
such a way that you have a function that
doesn't do side-effects outside of the
world okay you still can check it check
its properties like using quick check in
a Haskell to be sure okay maybe not sure
but there's some probability to see that
it does what it's supposed to do so you
don't you shouldn't be afraid of
mutation and mutation in the language
okay your functional programming
language there's a dunce mutation that
it allows mutation like Scala like
f-sharp okay just mutate okay don't go
outside of the function and test the
function as a whole and you should be
fine the other alternatives were already
non-existent because ST moment is
exactly that and functional approach
like standard functional approach of
doing so I goes nice functions were only
copying is allowed okay is slow it's
longer and end times slower those even a
paper on that in the seventies IV late
seventies early eighties okay this is
the first time where functional
programming lost okay so these are
mainly takeaways imperative constructs
we in terms of performance haskell seems
to be faster than skyline c++ for pure
functional constructs you would not
assert if you would run through those
results in detail because haskell is a
very heavily optimized towards
functional programming okay but is a
problem in functional languages okay
it's really problems cars is a library
so it's voice lower than the husker
which does many things as a compiler
pragmatic functional languages except
that mutation can be a fact of life and
you should too you can design isolate
and tested ok mammoths are not perfect
because imperative code in Moniz is even
less readable and if it has functional
interface test it and you can be certain
to some extent that it really works ok
it is our nice nice books I've also
taken some examples from it's like the
first two already really nice ok I think
that's it some questions yes please
ok ok no actually laziness makes posture
Husker potentially FASTA so Okazaki
writes about that in his exposition of
leftist trees lefty Steve's then in fact
if you have laziness and you don't see
but you're not in look inside of the
data structure you get amortized cost of
o M instead of O n log n ok this might
be the reason why for instance a
function of week's audience color using
the factor which is actually a lock as a
key left is to eat it runs a bit faster
than an array because it can amortize
the cost but the problem is if you would
like to use it in this way in this
capacity then you would lose this
performance because as soon as you like
in there exactly in example of strategy
gets cut okay if you if you take a look
at what's inside you're losing the
performance okay because side the
factory is being run outside of the
moment or the moment think of course the
haskell rather the runtime environment
lazy has got its own artifacts in yeah
okay
no more questions okay so thank you
again thank you much I really appreciate
that you site so lights thank you thank
you for joining us on this research
truck</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>