<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tomas Petricek - Learning to Live with Errors | Coder Coacher - Coaching Coders</title><meta content="Tomas Petricek - Learning to Live with Errors - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tomas Petricek - Learning to Live with Errors</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ytW6dPdTj3g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I think one thing I should add to the
introduction is that the way you get
interested in philosophy and history of
science is that you're doing your PhD
and you sort of start asking the usual
PhD student question which is what is it
that I'm actually doing here and if you
sort of just do it in a pub then it
doesn't turn into a into another
interest but if you do it in a sober
state and you might you might actually
start wondering like how does science
work and why we do things in the ways
that we use and I think this talk is
trying to use the same sort of way of
thinking or some of the the methods that
philosophers of science use when trying
to understand how science works and I'm
trying to I'll try to use some of these
sort of ideas to talk about errors in
programming and I think it's a it's an
amazing sort of fascinating history so
there will be a little bit of historical
aspects to it a little bit of like why
do we think about errors the way we
think about errors and there's a lot of
different takes on errors so you could
you could ask like how important errors
actually are our errors in software is
something that is like threatening the
whole industry and will turn into crisis
and everything will stop working or is
it actually just fine and if you if you
look back Charles Babbage in 1837 wrote
if trials of three or four simple cases
have been made and are found to agree
with the results given by the engine
it's scarcely possible that there can be
any error so you just write your program
for the analytical engine running three
times gives the right results
you're fine it will work that's what
that's what he used to think and even in
the sort of very early days of the ENIAC
machine the the sort of narrative about
errors was that the ENIAC woman would
simply set up the machine to perform
these plans and this is just a trivial
mechanical problem and that this turns
out to be difficult and actually require
a lot of thinking that was something
that the sort of people in the industry
completely didn't expect so they said
well we'll have these programmers who
will write the plan or design the
mathematical plan of the computation and
then we'll hand it to the ENIAC woman
who will just do the clerical coding
work and it turns out that this is
actually the hard part of it
and it took people really long time to
realize that programming is really hard
problem and there's lots of errors and
by the end of 60s people were actually
mostly talking about crisis and ever
since the 60s when people realize that
it's actually hard managers academics
and governments with release warning
about the desperate state of the
software industry so I think that the
the fascinating question here is that we
went from bad base saying this is
trivial to this kind of a newspaper
article that says the Tuesday will
happen on January 1st because of the y2k
error so it's really I think that this
sort of overall part of the history is
really just fascinating how the
perception of how important errors are
changed completely and there's I'll be
citing a couple of books
I'll give you references at the end but
this one makes a really interesting
observation that we
live in this perpetual crisis of
software engineering and yet this is one
of the sort of most profitable and
successful industries of all time so
like how does this fit together and I
think the sort of interesting story is
that programmers in different
programming communities are in different
parts of the industry somehow learns to
deal with errors and we sort of
developed lots of different practical
strategies for dealing with it and I'll
I'll try to just quickly talk about four
of them and they're sort of represented
by these personas and the first part is
that you just see error as a natural
part of the programming progress they
sort of happen you can't really avoid
them and you should try to do something
to avoid as many errors as possible
and it I think this is one of the sort
of earlier attempts that keeps happening
in the and the more sort of software
engineering oriented part of the
industry where in the early days when
when COBOL appeared the amos COBOL will
eliminate the need for skilled
programmers and the bad yeah that didn't
happen the other fun thing about COBOL
is that it was designed by the so called
short term Committee which was trying to
build something that will be good for a
year or two and it ended up being used
for 50 years and when people sort of
sorry I can't count but it will be used
for hundreds more years definitely but
people sort of realized that maybe we or
the the the industry realized maybe this
is just a management problem like really
we just need proper management
and that will solve the problem and
there was an event organised by NATO a
conference on software engineering in
1968 where the main message was that
this black art of programming has to
wake May for the science of software
engineering and that typically mean
meant software engineering as proper
management of these sort of weird
programming people who are difficult to
manage so it was sort of mostly seen as
we just need to turn it into a proper
engineering business and then it will it
will work and that sort of continued
since 68 for a long long time and I
think it's really interesting when you
sort of see the history and link it with
what what people are saying about
software development in more recent
years where with the software
craftsmanship movement we again sort of
emphasize the individuality of the of
the software developers and we say well
you really shouldn't be focusing on
these processes and tools and the sort
of ng the the sort of managerial
software engineering methods but we
should go focus again on the on what in
the nato times they call the black art
of of programming so I think there's a
sort of interesting interesting history
there and I'm going to be talking more
about the sort of the way errors are
dealt with in software craftsmanship or
in test-driven development because I
think this is really an interesting case
where we practically deal with errors
and we use them in some way so I'm sure
many people here are familiar with TDD
and this is just a quote that sort of
defines it where we say we will only
write new code if automated test fails
so that's the first point
and I think this is this is really
interesting because it says it used this
error to build software like we're not
saying errors shouldn't happen we say
well we first need to produce the right
error and we introduce the error find
the error and then we write the code to
eliminate it and the sort of test
becomes a part that sort of traces the
error in the in the software but the
error becomes sort of something that we
we actually used to sort of build the
software and it becomes part of the
specification that explains what is it
that the software is actually doing and
it serves also as a documentation so
we've gone from a world where we sort of
say well we'll just properly manage
people and errors well sort of not
happen to a place where we use the
errors in a very active way as part of
the development process to build correct
software and that was that was one take
on error and there's another take coming
from the sort of more academic or more
logically sort of grounded community and
in the very early in like 60s there was
an article in the ACM which is the sort
of academic programming community saying
well we the ACM members have read many
non ACM or industry articles on data
processing and they all suffer from one
basic fault they fail to report any
fundamental research so I think the
perception was that that the data
processing problem is just trivial and
there's nothing interesting there and
instead the approach that sort of
appeared in the in the academic world
was I think very nicely captured by the
Algol programming language which was
labeled as remarkable computer
science achievement and it was an object
of beauty which was never widely adopted
and many of the things that happen in
sort of academic research still come
from this idea that you should formally
define your languages so this sort of
become a defining an object or something
that influenced the community and
defined what the problems that we can
ask are and algol really sort of started
with this idea that you should have
formal specification of what the
language does which people didn't do
before and Mark Priestley who's doing a
talk in in the next slot I believe has a
nice book called science of operations
and he saw this identifies the the
common idea in the algal research
program where the goal was you utilize
the resources of logic to increase the
core the confidence in the correctness
of the program so you don't do debugging
you just construct a correct program and
that's what you could have seen in the
in the keynote that was a nice example
of construction of a correct program but
of course the difficulty is you have to
sort of know what the correct program is
and this is something that's reduce you
can you can trace it to the modern days
programming languages research so
exactly the same thing that they were
saying about the algal research program
you can you can sort of hear now when
people talk about dependently type
programming where this is a quote from a
from a recent book trying to sort of
explain it in a practical way where the
author says well you would think that
the coastal formal program verification
is too high but we can now
finally fifty years later show you that
program verification can finally work
and I think there's there's another sort
of related thing that I'll mention later
because we're sort of shifting from the
the program code to the properties to
the formal sort of specification but I
think that's just again a nice sort of
trace through the history where you can
see something that appeared very early
in in 50s and 60s and sort of traces
through the academic programming
languages research to the things that we
are doing as cutting-edge research today
and I think it's a again it's a it's a
fascinating story that sort of fifty
years later we're still saying we will
finally figure out how to make the
proofs thing work and when you sort of
see how the idea appears in the
universities this is this is a logically
the thing that that we must be doing
because in the sort of early days of
computer science finding like a formal
mathematical program or agenda that's
what made computer science possible as
an academic discipline and you don't
have like science of Telegraph or
science of trains or science of cars
because there was no sort of formally or
any any like a well-defined program for
what is the problem that we are solving
and I think with with sort of computer
science
having algorithms and trying to prove
things correct gives us really nice sort
of goal that is academically credible
mathematics is a perfect part of the
university environment so I think it's
very
natural to see this this progression and
you can sort of see how it's somehow in
interacts somehow doesn't interact with
the data processing people who are
solving all these trivial problems like
writing all the banking systems and
stuff and in many areas using program
verification actually works really
nicely these days but in some areas it
doesn't seem all that useful and I'll
get back to that topic in the
conclusions and try to sort of figure
out why that might be the case the other
amazing thing so this is I think 1993
Sir Tony Hoare who's one of the founding
fathers of the of the sort of formally
trustworthy programming research wrote
the this paper where he's sort of saying
well all these industry people they're
not doing it right
but why how is it possible that the
software they do sort of works and in
the introduction he sort of quoting how
many people died because of software
errors and it's not much it's like well
depends on if you could say compared to
zero anything is too much but if you say
compared to the car industry I think the
number is something around sort of 10 so
it sort of mostly works but it's not
using the right things so how is it
possible and I think that the sort of
but ant the the first approach that I
was mentioning just doing proper
software engineering and as that might
be changing over time is actually often
good enough and there's that was that
was my first first persona this is my
second persona and I'll have two more
personas that also learned to deal with
with errors in a way that mostly works
for
so the other approach and I think this
might resonate with this conference it's
just saying well errors will inevitably
happen we can't get rid of them but and
that's that's of course what the airline
language uses and how the community
thinks about errors where if you look at
long-running distributed systems that
run on lots of small cheap devices
errors will just happen because even
though even the probability of the
cosmic-ray flipping Abed it's actually
pretty high so the this is this is sort
of a completely different approach where
again you sort of accept that errors
somehow happen but what we do but we
deal with them in a different way and I
did that read Joe Armstrong's thesis
where he says he distinguishes between
these two these two different concepts
one of them is an exception which
happens when the runtime system doesn't
know what to do and the other is an
error which happens when the programmer
doesn't know what to do so errors are
expected because the specification is
not complete and when you receive a
message that has wrong bits in it you
just don't know as a programmer how to
react to it and this is amazingly very
different kinds of errors than the ones
that we for example handle with tests
and what do you do with errors where
well in Erlang if you find and if if you
get into the errors situation you just
let someone else deal with it and what
you have to do is you let the process
crash or I think as the as the as chose
teaser says you just kill yourself and
this is again sort of an amazing amazing
approach because you just say well
errors will happen
and when they happen we'll have to
somehow deal with it and the only thing
we can do is shut down this particular
process but because of the structure of
the runtime you'll have other
supervising processes that will take
care of restarting the system and
recovering from that error and if you
think of it like this is exactly the
opposite
approach the errors then both people
with writing tests like want to do
because if you're if you're writing
tests you're basically using the error
to specify how the program should should
behave you're saying like this is the
specification for what it does and
errors in Airlines are errors that
happen when exactly when you don't know
what it should what it should be doing
when you don't have the specification so
there's sort of two communities here
that both use errors in some way or deal
with errors in some way but the notion
of what the error is is completely
different and there's interesting
question and I don't know the answer but
if you're if you're sort of in a system
where you expect errors should you still
call it an error and I think it makes it
makes sense to call it an error because
that's a good good name for the thing
that happens but if you sort of if you
approach the same problem from the
service maybe from the from the academic
perspective and you try to prove things
about airline well if it's if it's
handled if it's handled in a sort of
expected way then it's not really
contradicting my truth it's just part of
how the system behaves so that's a
that's another take on errors and I
somehow all my all my errors all my
personas are manifested in this
conference which is beautiful
so this this a Lego figure doesn't quite
look like some errand but Sam is son is
playing tonight
and in the life coding or live
programming community errors are dealt
with in yet another really interesting
way so and it sort of historical
historical fun remark is when in the
early days all the businesses tried to
hire lots of programmers and nobody
quite knew what a programmer is they
went to sort of trying to figure out
what are the personality traits that
programmers have and I guess as it often
often happens they sort of didn't really
find anything distinctive but there was
one sort of slaw study reasonably
credible that was saying well
programmers are just like any other
people working in the industry but maybe
they are slightly more musically
talented or like playing chess so there
was this sort of early early days idea
that if you want to hire a programmer
you can hire someone who's good at math
and solving puzzles or you could hire
someone who's good musician or you could
just hire someone who said he's good at
dealing with machines in general but the
the musician sort of trace was partly
there as well and I think one of the
sort of early early systems that took
very different approach to programming
than the other ones that I was
mentioning was in the small talk
language where the the way the language
works and this is something that you
don't really sort of see today because
when when you hear about small talk
they'll tell you while this was the
first object-oriented programming
language and you think about well I
think people here probably don't think
about Java but many people won't think
about Java and you'll imagine all these
classes and lots of code
but the the thing that was really
different about small talk was that you
didn't think about programs as
linguistic entity there's like massive
pages of code but you it was thinking
about programming more as a interaction
so programming is interacting with the
system with the running program and if
you write some small talk you start your
small talk vm and that's your small talk
program running and you modify it and
you sort of interact with the program
life which is something that's very
different from this idea that we have
some program code that we analyze and
look at and when we when we are happy
with that we run it and ship it to
production and so this this focus on
interaction I think is what sort of you
can can again trace to the modern times
with things like live coded music which
you'll see tonight and there's a couple
of people who sort of write interesting
things about this this this way of
thinking about programming and one of
the really interesting points is that if
you related to music in musical genres
where they're not closely or precisely
notated there are really no wrong notes
there are only nodes that are more or
less appropriate for the performance and
with with live coding this is what
you're basically taking into the
programming system so life coders may
may prefer to accept the results of
imperfect execution or an error and when
when you get an error in your life
coding performance so watch Sam tonight
very carefully what the people might do
is that they'll perhaps compensate by
manual intervention by playing something
different that fits well based on the
sound you you
you hurt when when the error happened
and maybe it will actually turn out to
be more interesting so when you
accidentally play an error in a live
coding performance what might happen is
that you'll actually play something
better than what you were planning and
so here the error is really more of an
inspiration or something that you sort
of lets you be more creative and that's
sort of specifically in the in the life
coded music or live coded music area but
I think there are there are very many
interesting lessons that you can learn
from this approach even for sort of
proper software engineering and one of
the really key things here is that what
makes this work in live coding is that
you get to see or hear the error
immediately so you hear that something
is behaving in a different way and you
react to it and so the two really
important things here are you make the
error visible or hear about and you
build the tools so that you can quickly
react and every time I read something
about DevOps or read something about how
people have pagers that will ring them
when something on the website is wrong
and then they have to open their laptop
and fix it immediately I think they're
doing life coding with very crappy tools
so I think there's a lot you can you can
learn here and I've got a couple of so I
went through these four different four
different approaches that I think
different communities in the industry
use I don't think they're quite perfect
categorization so if you if you think
there's some more definitely come and
talk to me later but I think the sort of
thinking about errors gives you really
nice way to struck
or have some sort of structured look at
how the industry works and the other the
other part that's that's interesting
about errors is that often it's actually
really hard to sort of classify what is
an error and what kind of error is it
which is one topic I didn't really talk
about that much but if you look at the
recent famous error so this is a Google
Translate around the time of the
Ukrainian crisis or the Russian invasion
to Ukraine
Google Translate started translating if
he if he took words in Russian and
translated them to Ukrainian it would
translate Russia as Mordor and Lavrov
who is the foreign minister as sad
little horse and of course this happened
because Ukrainians writing on the
internet referred to Russia as Mordor
and Google Translate learned this so
it's operating perfectly according to
the algorithm but it's probably not what
the authors expected so what is an error
I think when you sort of think about it
in the very formal sense this this was
perfectly correct and if you had
approved that Google Translate works it
worked but it did something that we
didn't want to and this was the the less
the the less bed of the two examples I
came across recently the other one was
Google Google photos or Google pictures
I think recognizing or putting black
people in the category with apes which
was really really bad and you can see
how the algorithm sort of leads to this
but it's it's ignoring the the society
society aspect of it where we just even
though like we wrote the algorithm and
it works according to the specification
it doesn't do what we wanted to do so I
have two more errors for you and I think
those are in
so one interesting error and these are
from some from some perspective less
said than the previous one so there was
a there was a trading firm called
Knight Capital and they've lost how much
is this four hundred million dollars
because what they did is that they had
software and had some sort of flag
somewhere and they repurposed the
meaning of the flag to mean different
thing and deployed a new version where
if the flag was on it would do something
clever and then they deployed the
software on all servers except for one
which was running an old version where
the flag meant something completely
different and as a result it started
selling all their whatever they do I
don't know for cheap and I think this is
a really nice case study because you can
look at it through the four different
perspective so if you're a live coder
then you say well it really did took
them 45 minutes just to shut down the
server and it did because they just
didn't know how to sort of they didn't
have the right access to the system to
figure out what's the server that's
misbehaving they didn't see or hear the
error and they couldn't sort of
intervene quickly so maybe if it took
them like minute they would just lose
ten million and that's fine
the the airline answer is well obviously
that server should have killed itself
because it received a message that was
incorrect and that's what you do and
then you can say well this shit like
that this whole thing is a madness you
should prove that your system is correct
and this cannot possibly happen because
your proof will tell you this sort of
this change where you're changing the
flag will violate some constraints that
you have on your on your trading
strategies and it will it will give you
a nice short
error message that's easy to read
telling you this is where your proof
fails and I think the the related
interesting question here is well what
is it that we actually need to test and
what are the the the cases that we
haven't covered or more interestingly if
you're using something like quick check
what's the property and it turns out
that the last two are actually very
similar so whenever you hear people
saying that there's like a massive
opposition between the tests and the
types with proofs they're very often
talking about that if about the same
thing
because you always need to know what's
the property so what is it that we could
have said well we could have said maybe
if you're if you're trading then you're
only allowed to change some price of
something by this much and then either
prove it or write a test using something
like quick check that covers that so
what I think is really really
interesting here is that when you look
at any any software related error in the
industry you can see these different
ways of thinking so I think one that one
thing that I would like you to take away
from the talk is that you can think
about the problem in very different ways
and you'll often end up with different
answers that all make some sense in some
context my my other popular error so
this is the end of the world which was
supposed to happen at the beginning of
the year 2000 and it didn't happen so
there was lots of money spent on
preventing the y2k error and again you
can sort of try to prove or test some
properties and this one is really
interesting because you can because it
partly relied on a on a very low level
representation or error so if you have a
proof on the paper that says I'm doing
my dates correctly you will usually just
say well year is a
and the fact that it ends up being
represented as two digits would very
often be just the technical detail so
you'd have to be very very careful to
actually sort of once you once you
realize that the two-digit
representation is a problem then you
don't have to finish the proof you can
just go and fix your integer
representation I think it does give you
sort of very nice way of thinking about
it and finding the error and the other
other interesting thing about y2k is
that what happened in the end is that
they company spent a lot of money trying
to fix it and then they just had someone
sitting there by the computer around
midnight waiting for the system to crash
and sort of saying well let's see what
happens and if I can then get it back to
run and again this is the the life coder
there sitting with very crappy tools
waiting for the Doomsday and thinking
well do I actually have enough tools to
fix it when it happens so to wrap up
there's the one thing I mentioned in the
beginning which is that software
industry even though it's the most so
the fastest growing of the USA code
fastest-growing sectors of the US
economy we somehow live in a world where
we are in a constant crisis and it's
it's really interesting to sort of think
about this since and try to figure out
as it that we are actually not doing
right or is it that maybe we were just
don't thinking about it in the right way
and I think there's there's lots of
things you can you can learn here one is
that if you have some nice basic
assumptions then well the big picture is
there are very often different ways of
dealing with a problem so if you have
some basic assumptions that you can
prove or test
then that's perfect and you're very
lucky and do that but if you have some
system where you really don't quite know
what the exact sort of specification is
or what is it that it should be doing
then taking some idea from the other
approaches might be very well the thing
that you need to do and I often think
that the problem isn't like is it
ethical to write programs without proofs
or is it not ethical the problem is
what's the sort of easiest way to
describe what the program is doing if
it's easier to write code and read that
read the code and say yes there's thus
what I think it should be doing then you
should write code but if it's easier to
write a formal property that describes
how it should be done using types or
using dependent types or using quick
check then
you should write the property and maybe
in in the bright future of Agra it will
just fill the rest of the code for you
but if you don't know what the property
is then that's not really going to help
you and the last bit I think the live
coding experience is interesting because
it sort of finds different ways of
giving you this this quick response so
if you have to have a human there which
often you do you can learn from what Sam
will be showing tonight and figure out
how do we actually enable the people to
react appropriately and quickly so the
two points are there's lots of different
ways of thinking and often when you sort
of hear people say something about
errors you have to understand what is it
but what is the context in which they're
saying it and the other is I think it's
interesting to think about is it
actually easier to write the code or is
it easier to say what the code should be
doing in some other way and that's the
end of the talk and I'll just wrap up
with these two books that are
interesting and amazing resources that
I've used a lot and enjoyed a lot
Thanks
and I believe we do have some time for
questions
what if there are no errors at all
yeah yeah so the question was what if we
are just not seeing them yeah I think
this is this is the sort of interesting
interesting question about rotational
error if my plane lens that on okay
we're not seeing the error I like the
idea of having lots of errors that you
don't see I guess that's what sorry
partly happens in the in the airline
style there if you have an area you just
recover from it if you're using it more
as a mechanism within the system so
that's one way of having areas that
don't really you don't really see I
guess you might still see them in a sort
of performance monk
when you realize that some process is
running really slowly because it needs
to restart itself after every other
message yeah I think that's a sort of
topic for another for another talk about
voltage is actually an error so in a
world where one man or one woman's era
is is someone else's exception how
should library authors approach the
problem of catering to both audiences if
you if you're writing system in airline
then the error sort of happening within
that will be isolated and if you're if
you're doing live coding Q you won't
suddenly sort of plug in some things
that you like you won't have a middle of
your program but that you'll want to
prove correct or at least that's
something that nobody has quite done yet
and maybe we should I think there's
another sort of interesting
option which is that you could have
multiple different layers of things so
if I if I if I have an airplane I maybe
do want someone like Connor to write the
low-level bits of the airplane and with
with proper proofs that it will not like
flip itself or it will not I don't know
what else airplane si it will not sort
of speed one of the motors to the to the
max and the other to the min but then um
that's a very sort of small layer that
just covers the basic properties or
basic assumptions that are easy to say
and then I'm perfectly happy if the
pilot can do live coding on their
airplane to sort of find the way they
think is the best because that's
something we can't formally describe so
you could have multiple layers where at
some very basic level you can prove some
basic assumptions and that's sort of
eliminating one kind of errors from one
part and then use another layer where
you deal with errors in a different way
but I think sort of crossing the
boundary in all possible ways that's
still a tricky tricky thing
I so I write Erlang and as you say
there's lots of errors that sort of
don't matter and a handled but there's
also some errors that really do matter
and then everything crashes and
everything horrible so I wondered if you
just thought practically about how to
distinguish those two because in my
experience treating all errors and like
letter crash all the time results in
like horrible things
woken up in the middle of the night and
I sort of dead fright there's definitely
two kinds of errors in Airlines where
some of them are the sort of recoverable
errors and some of them if you just
write code that crashes all the time
restarting it won't help so yeah maybe
maybe you sort of need to talk to the
live coding people and make the really
bad errors produce really ugly sound and
I don't really have a have a good answer
to that I think this maybe that's a
place where sort of looking at the
different communities and seeing what we
can steal from them could be a way to go</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>