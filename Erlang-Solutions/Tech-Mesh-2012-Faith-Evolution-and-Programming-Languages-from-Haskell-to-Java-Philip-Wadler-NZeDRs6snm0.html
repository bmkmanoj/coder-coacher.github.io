<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tech Mesh 2012 - Faith, Evolution, and Programming Languages: from Haskell to Java - Philip Wadler | Coder Coacher - Coaching Coders</title><meta content="Tech Mesh 2012 - Faith, Evolution, and Programming Languages: from Haskell to Java - Philip Wadler - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tech Mesh 2012 - Faith, Evolution, and Programming Languages: from Haskell to Java - Philip Wadler</b></h2><h5 class="post__date">2013-08-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NZeDRs6snm0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">ok so I'm an academic your developers I
use five two languages lots of you guys
use object oriented languages yeah ok
I'm going to explain why my faith is
right and yours is wrong except you know
that's that's a sort of awful thing to
do right there's been a loft talk about
evolution in the news recently precisely
because of certain faith based
approaches their faith doesn't include
evolution evolution i think is very
important so one thing I'm going to talk
about here is how programming languages
evolve how they change multi-culturalism
has been a lot in the news and so I'm
going to talk about multiculturalism I
began by saying I'm right you're wrong
that's not very effective so I want to
talk about how we can co-exist side by
side and learn from each other and if
the crews me i should add another slide
I don't have one that says no
culturalism with no symbols on it
precisely because certain people would
like to maintain their belief in
evolution they've people like dawkins
have come to believe if that's
incompatible with a belief in faith so
dawkins goes around and says things like
there is no God therefore you're all
wrong I agree with him there is no god
but I'm Jewish right you can be you can
get a lot out of faith without
necessarily believing in God I will say
nothing else about God except at the end
so I want to talk about the origins of
my faith which of course lie in the
church
my faith is lambda calculus here is the
cover of the magazine about journal of
functional programming which i helped
found along with john use and Simon
Peyton Jones I come from Edinburgh
there's the pavement of Edinburgh a city
well known for its functional
programmers and that's the tie I'm
wearing right now so let me tell you a
little bit about history right these
days everything is very fast funding
agencies want results right away if
you're a developer everybody wants
results right away i'm going to start
relatively recently in the story only in
1935 but in fact the story goes back
much further right the first uses of
symbolic logic for people like bull in
the 1800s you wait a while and it's
codified by Galahad Jensen so Jensen
came up with the formulation of logic
that we use today called natural
deduction how many people have seen a
form of symbolic logic you're familiar
with writing and an or and maybe even
implies right most of you how many have
seen natural deduction most of you
who've seen logic seem natural deduction
so this is one of these standard ways of
formulating logic and so the thing on
the left is if assuming a you can prove
be then you know a implies B so those
brackets around it mean this is an
assumption this says if you note have
proved a and you have proved a implies B
then you know be so this is actually
copied out of Jensen's paper here it is
the full system against this paper i'm
just looking in the fragment here it is
the way we would do it today yes this is
exactly absolutely the same except
what's in Jensen's paper except his
letters are in German and minor in
English that's the only difference
so this again says if assuming a you can
prove be then you know a implies B and
this is if oh I wrote I reverse the
order if you know a implies B and you
know anything you can conclude be
similarly if you can prove ain you can
prove anything you know a and B and what
do you know if you've proved a ND you
know a and you know be now these rules
have a nice form which is what gainst
and discovered he discovered that proof
rules come in pairs so you have an
introduction rule this is a rule with
the symbol that you're introducing
either implies R and below the line and
you have elimination rules these are
ones with the simple of buffing lines
this says how do you know a implies B
how do you know a aunty what you need to
know before you know that and then this
is once you know that what can you work
out this is how do you make one of these
things and this is what can you do with
one of these things very nice way
structuring module only took 50 years to
work that out to get from frege's
formulation of logic to get ins
formulation ladka a mere 50 years to
discover this completely obvious thing I
want to mention that because I'm sure
there are many things that would
simplify computing today just as much
completely obvious and it will take us
50 years to find them but you know there
might be one with computing 50 years old
so there will be ideas like that that
are 50 years old waiting to be found the
purpose of this talk is to inspire you
to find those simple ideas so here's an
example of a proof let's see what have I
done here this is the right I said for
the proof of a and B these things
actually have and B has an order right
so really from a and B I'd better be
able to prove bna right so here is a
proof that assuming bna what have I got
here right here's the proof I wanted
I want to prove that from bna I can
prove a and B that had better be true
right how do I do that well to prove a
and B I have to prove a and I have to
prove be and indeed from bna using the
one that picks the thing on the right I
can prove a and using the one that picks
the thing on the left I can proof be to
know so I've got eone first and then
easy row now I've got a and B and then I
can discharge my assumption that's what
this is called so I've assumed DNA and
now I don't need to assume that anymore
by know that bna implies and B now let's
do the world's most roundabout proof of
a and B from the assumptions b &amp;amp; A so
here's the assumption be here's the
assumption a from those two assumptions
i can prove DNA and then I know bna
implies a and B so I've got a and B well
wait a minute that's a very long about
roundabout way of doing it can you do
that more simply of course we can what
we will do is here I said assume right
be from bna we can do this we do it with
an assumption of DNA but here I've got a
proof of DNA no need to assume it I will
just get rid of this implication and
copy that proof of DNA everywhere I
assumed it so there it is copied in so
here's one copy here's another copy I've
made two copies because the assumption
is used twice but now look I've done the
introduction rule nose here right I
introduced an implication and then I
immediately eliminated it here i'm
introducing in and and then immediately
eliminating it so why bother to do that
this is well from B&amp;amp;A i improve DNA and
from that I can get back an egg let's
just use that a directly right so i can
simplify it now here's the
straightforward proof okay so i took
something completely obvious and made
your head hurt with it what is the point
of doing that well I mentioned Jensen
came up with this formulation of logic
lots of different people were coming up
with formulations of logic there were
many different formulations of logic
some of them
some of them you could prove everything
so it was which is not a very useful
logic you only want to be able to prove
the things that are true so one of the
important things people try to do with
logics is to show that they were
consistent one form consistency is show
you can't prove false if you go back to
again sins original rules this is the
rule that lets you prove false if you
can prove a and you can prove not a then
you can conclude false how did you prove
not that was the non-elimination rule
how could you prove not well from a you
can prove false then you can conclude
not a now notice we've introduced a
procedure for simplifying proofs what
this does is by simplifying proofs in
this way you can always get rid of
things that are not assumptions or
conclusions so in this proof we've got
some assumptions and a conclusion and
nothing in between you might have more
complicated proof like this one that had
some assumptions in the conclusion
nothing in between so this proof alone
is in normal forme but when we combine
it with this proof we now have an
intermediate formula that's not one of
the assumptions right the assumptions of
this thing or B and a it's not the
conclusion which is a and B so we
simplified we simplify and we get
something which only has formulas and
conclusions this one only had formulas
and conclusions bigger ones but we can
get rid of them when we combine them
with other things you can always
simplify proof so you have no
intermediate formulas that meant that
for these rules right if you have this
in the middle of the proof somewhere
unless you had an assumption like not a
the assumption of not a would have had
to come from this and you'd be able to
get rid of it by simplifying you could
simplify down until this intermediate
that no longer appeared and therefore
the only proof that's left of false is
there aren't any once the things in
normal forme there are no proofs of
false right because the proof would have
to involve the sub formulas of false
false has no sub formulas it's like what
of no don't you understand right there
are no sub parts of false so in this way
Jensen showed the consistency of his
logic that was why he was interested in
proof normalization that was one reason
okay by the way he didn't do it directly
he had to prove another thing sequined
calculus also the other main logic that
we use to this day so they both lasted
50 years he did both of these in his PhD
thesis by the way also introduced the
upside down a to mean for all all in one
paper and so he came up with all these
ideas so that's the first part of the
story here's the second part this is the
church i mentioned Alonzo Church he
invented the lambda calculus also
because he was interested in logic there
is where is it back is the very first
lambda as used in lambda calculus so
this is the paper that introduces lambda
calculus and you remember I said some
logics ended up being inconsistent he
entered he introduced lambda is a very
powerful way of writing functions in
logical formulas but it made his logic
inconsistent turned out the way to make
it consistent again was to introduce
these things that Bertrand Russell were
on Russell Square this Russell Square is
not named after Bertrand Russell it's
named after one of his ancestors but
Bertrand Russell introduced he came up
with Russell's paradox which was the
main ways in which a logic can be
inconsistent and he got rid of Russell's
paradox by introducing these things he
called types so types were originally
introduced in order to make logics
consistent and this is how church used
it as well so church was interested in
lambda expressions so here's the lambda
expression X with term you and let's
look at the type
of this so this is a function from A to
B so it means the argument is of type A
and result is Type B we saw this in the
other talk except i wrote this backward
see as an error so this should actually
look familiar just a slightly different
notation and so that top line there says
assuming variable X has type a I can
conclude that term you has type beats
that means X appears as a free variable
somewhere in the term you and then
lambda X you would be a function from A
to B if s is a function from A to B and
T is a term of type a of course s
applied to t will have the functions
result type B so this is just function
application this is function creation
they come in pairs what about pairs
themselves so if T is a term of type A
and use the term of type B then tu is a
pair and will write its type like that a
and B now we see why the order in a and
B is important right because clearly aut
pair is isomorphic to a one of these but
not the same so of course if s is one of
these terms we can extract its left
component or its right component so it's
left component will have type A that's
right component will have type B so
these are just typing rules let's say
we've got some program this is sort of
the simplest program I could think of
it's the one that given a be a pair
returns an a/b pair so what does that do
it will take z which is your be a pair
it will take it right component which is
it an A and it's left component which is
B so that gives you back an a/b pair so
there it is so there's the proof that
this term has this type if I've got free
variables x and y of types a and B I can
form a YX pair which of course would be
bna I can apply the function so how do
you do function application well this is
for n easy you can build up this term
well here's a particular actual term
that I want to use for the formal Zeds
you just
stitute it right so we can copy that up
and when we copy it you notice we get
the proof that doing the substitution
remains well typed so now we've replaced
Z both places by this pair of course we
can simplify that by picking out the
correct components and we get the answer
as you expected so here were two
different things now by two different
logicians for completely different
reasons but they kind of look really
similar don't they right in fact if you
reach underneath your seat you'll find
that place there rose-colored glasses
you can put those on wearing
rose-colored glasses you'll see the red
the blue will disappear and sorry you'll
see the blue the red will disappear and
you'll see that this looks exactly like
the logical proof so completely obvious
right so just as you is expect with
something completely obvious right those
other things we're 1935 1940 it only
takes 40 years and william howard
publishes the paper pointing out this
completely obvious correspondence I've
just shown you it's now called the curry
Howard isomorphism because in a slightly
different form Pascal curry had already
noticed this in 1950 i think it was
actually 1956 the year i was born so
what was proved here by korean howard is
that you should expect that every good
type system has a double-barreled name
so curry howard is a double-barreled
name that predicts the existence of
other double-barrelled names not in the
sense of Payton Jones we've got one
person that has to name stuck onto him
but in the sense of a type system which
has to name stuck onto it because it was
discovered twice once by a computer
scientist and once by a logician and so
you've got the Hindley Milner system
discovered by the logician Roger Hindley
and the computer scientist Robin Milner
this is the basis for the type system in
Haskell and many other
languages when I talked about parametric
polymorphism this is how we do it and in
fact that generalizes to something else
called visual rod Reynolds type system
discovered by the logician Johnny Gerard
and the computer scientist John Reynolds
exactly isomorphic systems both of these
were discovered within a few years of
each other always the logician gets
there first so I want to show you
something coming from this last system
this your our rental system and i want
to show how that relates both to Haskell
and to other languages like though so i
mentioned that jensen introduced for all
so here again is the sorry i mentioned
gets an introduced i mentioned that
guessin introduced the symbol for all
but the idea of quantification was older
again about 50 years older it was first
introduced by purse in the US and by
gottlob frege in europe so here and
frankly i think was the first one to
write it down so here's frege's
introduction of quantification Frankie
used so this weird thing here that we're
diagram is how fraga wrote a implies Phi
of a and if he wanted a quota fire he
put a little dip in the line and wrote
the bound variable in that dip so he had
a graphical notation but it was
basically the idea of quantification as
we know love it today so this is how he
would prove a formula hold for all
little a
now if you wait many years John Reynolds
comes up with little type system
explained here called the polymorphic
lambda calculus and he wrote the types
actually you can't see this right but
there's the type this is what we would
now right for all TW but he wrote it as
a delta the reason he wrote as a delta
is he didn't know his type system
correspondent to a logic yet so now I
want to show you a magic trick so do I
not have okay i don't have the other
paper by jerod but chirag did no
corresponding to a logic and did write
the same thing with a for all but let me
just explain this to you with a magic
trick so here's a function R and it's
type is for all a that should actually
be a for all a in front here given a
list of a return list of a so this is
the way we write it in Haskell although
these days in the Haskell we learned
better and you can also put in the for
all a if you want to so I should have
done that but here's a function R type
list of a to list of a for any a ok so
their various functions on lists that
you can write they don't have this type
for instance consider the function that
takes a list and subtract one from
everything in the list well that would
work for list of integers and list of
floats but it would not work for list of
strings because subtracting one from a
string has no meaning but this works for
all a so it can't be that function so I
want you to think of a function that
takes a list of a to a list of a don't
tell me what it is ok got nothing up my
sleeves ok are you thinking of your
function of this time now that you're
thinking of it I will read your minds
and I have divined a theorem which is
satisfied by your function R here's the
theorem
start yes start with your list of a
apply map f to it for any f whatsoever
to give you there's a typo here damn see
that a that's misspelled it's b/c that
be it's misspelled it's a okay so module
of the typo this is very easy to
understand apply this function f which
takes an a to a be to a list of a and of
course you get a list of B apply are at
type a to a list of Ain you get the
rearranged list of a apply our to your
list of be at type B and you get the
rearranged list of B then if you take
the rearrange things and map f again
over them you get that to the same place
let me show you one example here's a
list of numbers 97 98 99 for our let's
see okay now here's the real magic how
many of you were thinking of the
function reverse quite a few how many of
you were thinking of a different
function wow that never happens what
function were you thinking of sorry
identity right an even simpler function
okay good how many of you thinking of no
function at all only one person admits
to it okay so let's take reverse because
identity is a bit too simple so 97 98 99
you reverse it you get their orders in
numbers in reverse order character is a
function that takes a number to its
corresponding character in the ASCII
character code so we take 97 98 99 and
we get a DC we reverse the first thing
we get a list of numbers reverse the
character to get through verse list of
character indeed if we take these lists
of numbers and reverse it we get this
list of characters so the identity
function satisfies this the reverse
function satisfies this anybody thinking
of a
function that wasn't reverser identity
yes color ooh what does that do Oh tail
cutter right on tail okay let's try it
with tail 97 98 99 take its tail would
be 98 97 take the characters you get ABC
take the tail you get ba I read your
mind you may all know applaud I won't
show you the proof of this but the
basically the way you prove it is you
take let's go way back there's a variant
for impure functions but the way you
prove it is you take one of these proof
trees showing that a given term has a
given type and you can convert that into
a proof tree showing that the given
things satisfies the relevant theorem so
it's actually remarkably straight
forward to prove this magical property
so this is great right it means
polymorphism isn't just incredibly
useful right it lets you write one
function that can sort list of
characters and list of integers and list
of strings and so on but you had type
classes which fit in with this perfectly
so polymorphism is a wonderful thing so
when Java came along we thought damn it
doesn't have generic types what would
Java look like if you add a generic type
so Martin or Darcy and I put
polymorphism into pizza and then we
showed how to translate that to bog
standard Java and basically if you've
got something polymorphic in a type in
this case element LM is what I was
calling a before what you do just you
replace it everywhere by object and that
this is what happens right people before
generic would always write things in
terms of objects so if you want a list
that could be of any type it would be a
list of object and right object is
perfectly named
right if you see something like list of
object you should object people have
used object because they didn't have
polymorphism or generics available so we
showed how you could add polymorphism
but map it back into existing Java and
there was a lot of work that we then did
to turn that into well first of all I
came up working with Benjamin Pierson
not sushi igarashi we came up with a
formal model of java so that we could
prove all this there were at the time
lots of formal models that tried to
capture as much of Java as you could
formally so almost every single feature
of Java was captured formally we did the
opposite we made a formal model of Java
that was as small as we could make it so
here is Java in a little bit you know
fits comfortably on one slide and both
of these things are important to do but
the advantage of making it as simple as
possible then other people can do the
same thing so lots and lots of people
would then design additions to Java and
model it formally starting from this
system which was we made it as simple as
possible so we called it featherweight
Java so I highly recommend two things
one formalized to make your formulas and
absolutely as simple as you can don't
try to capture everything try to capture
the essential bits so it only changes a
little bit when we added generic certain
we could capture generics and we could
formally capture the idea of replacing
generic type variables by object and
showing that that all worked and then we
worked very hard Martin and I
collaborating with the people at Java to
get generics in that design actually
into the Java language and it was about
it so it takes a long time to evolve a
language so it was like 10 years before
we first figured out how to put your
neric sin Java and between them actually
getting in there and this gets us back
to evolution again
right evolution is slow but also in
order to get generics into Java we had
to design the it's called the erasure
mapping this is the thing that replaces
the type for all a by object so that you
can implement it on the existing Java
Virtual Machine and the rule was the
Java Virtual Machine couldn't change and
the rule was old library should work
well with new code new code should work
well with old libraries old libraries
you should be able to replace them by
newer libraries that have better generic
types so setting everything up so that
that worked neatly that was the hard
part so if you want to try to add
something to an existing language you
often have to work extra hard right it's
not just a matter of designing the new
feature but fitting it to what was there
before so I think it was very helpful
that we had Haskell as a model of what
we did with Java because just doing of
Java directly would have been too hard
oh and that's the advertisement
literally the representative from
O'Reilly who's here has copies of the
book and she said put this in your
sought talk and tell them that there's a
signing after the talk so there's a
signing at the o'reilly desk immediately
after the talk please show up because
they said very few books and i want to
embarrass them there are only six copies
so if we can sell six copies the next
time i can say see you should send more
copies okay i want to briefly review
three recent ideas right i mentioned
that you should i mentioned that type
classes go well with parametric city I
didn't tell you how they go right but
what free theorem should you get from
sort so sort takes a list of a to a list
of a but it's not any list of a it's
only a's that belong to the type class
board right the type class or defines
less than which
you need to do sort so it doesn't work
for any type it works for any type that
has less than defined on it so now the
theorem you get should look almost
exactly like the theorem for reverse
right it should say if you take a list
of a and sort it to get a list of a then
mapping and sorting should be
interchangeable and if you think about
from when we that will be true as long
as this function f preserves order and
saying function f instead of saying for
all f we now say for all s that preserve
order preserving order corresponds
exactly to say the type variable a
belongs to the order type class as one
operation less than less than the
meaning of X less than Y had better be
related to the meaning of f of X less
than f of y so if F preserves ordering
then you can apply a function and sort
or sort and apply a function you get
strong theorems from the type classes so
what this says is everything in the type
class as long as all those functions are
preserved your properties are preserved
so that's a strong precondition right
you want as few things to be preserved
as possible so just having less than as
your precondition for or it is good you
don't want have other preconditions like
oh as long as it's a type that you can
come do ordering on and can print
convert to a string because now your
theorem would say it's pretty it's true
for any function that preserves lesson
and preserves print how many functions
preserve print well let's see that says
that X print of X and print of f of X
should be the same um and how many
functions do that well usually two so
two things printers the same only if
they're equal so the only f that works
there is the identity function that's
the only one that preserves print in
general so having print in the set of
things that should be preserved is a bad
idea so what happens in object-oriented
languages when you quantify over things
you don't quantify in general the thing
that corresponds to the type classes as
you say you quantify over everything
that's a subtype of some other type like
terrible so or it is like subtype of
comparable and comparable only has in it
the ordering function and everything
that's an object what's an object oh
just a few things like equality and hash
and print oh so as long as it preserves
everything incomparable which means it
preserves everything in object which
means it preserves print which means it
is the identity function then this
theorem holds okay so by making all
types up types of object you get these
three theorems that are completely
useless so this is the second reason you
should object to object which is it's
got too much stuff in it yeah sometimes
it's nice to have print sometimes it's
nice to have hash but you'd like to be
able to say no I've got nothing at all I
know nothing about this knowing nothing
is very powerful but you'd like to be
able to say I know nothing so we need a
new type in the next generation of
object-oriented languages call top that
has absolutely no methods okay so when
you go off and design your next object
oriented language please make sure that
there's a type that has no methods in it
whatsoever that combined with generic
types buys you a lot you can tell I'm a
types kind of guy right half the people
in the world are types kind of people
and half the people in the world are so
half the people are statically typed
half the people are dynamically typed
languages like Clojure scheme JavaScript
Ruby Python all of those are dynamically
typed they only do the type checking at
runtime not statically at compile time
it'd be nice to make these two guys live
together I'm doing some work on that
it's something called the Blaine
calculus again it's a very tiny calculus
the reason I'm saying this is I keep
thinking that somebody should do the
following well I should be lazy I should
do it except I'm not very good at
javascript I'm not very good at what
developer
is due so I'm hoping to persuade one of
you to do this if you're interested
please come see me using just these few
lines we can do the following you can
take a JavaScript program say here are
its types and then turn it into
something that at runtime confirms that
it has those type so no static type
checking but at least at runtime we're
confirming that things have these type
so now if you import somebody else's
library and you give these type
declarations for it and it turns out you
guessed wrong about what the types were
you will find out at runtime so now you
can combine existing JavaScript programs
in a much more robust way that's a good
thing to do remember this 3 theorem that
I gave you about for all types so
there's a successor paper to this one
that shows the free theorem that you get
from for all types you can take an
untyped JavaScript program free of side
effects give it this type and guarantee
that it satisfies that theorem how cool
is that right so you really do get
theorems for free just by imposing a
type on something so I think this would
be a cool thing to do I'm very excited
about it I will go off and do it but
somebody here is interested in helping
me write a library for JavaScript or
Python that helps you do that sort of
thing I think I'd be a cool project I'll
skip over the third idea so I can spend
a moment telling you about aliens
so I mentioned that my faith is founded
on the lambda calculus and that my faith
is founded on the idea that for every
type system there should be a
corresponding logic this turns out to be
true for everything except concurrency
this third idea that I didn't showed you
is recent work showing hey maybe it
works for concurrency as well so what is
a consequence of this faith well the way
I liked to put it is to say lambda
calculus is God's programming language
but in polite company one shouldn't
mention God so what is a different way
of saying this let's talk about aliens
let's say we want to communicate with
aliens we have actually tried to
communicate with aliens right this is
the plaque that's on the Voyager not the
Voyager from Star Trek but the actual
Voyager satellite which looks like this
thing in the background and then they
put pictures of people in the front and
then this is to communicate where the
earth is these are all different pulsars
the length of the line is their distance
from our solar system there are marks on
these lines which are in binary which is
the frequency of the Pulsar so you can
identify the Pulsar so this is telling
them exactly where the earth is and then
they can now I figure any aliens will be
unable to understand this bit it will
depend on what their visual system is
whether this fit makes any sense to them
at all right if Star Trek turns out to
be right they'll look at that and
they'll say wow they look exactly like
us except they don't have pubic hair
or maybe they'll look at this and not
make sense of it or maybe to look at
this and go boom they look tasty they're
over there let's go not clear what will
happen but this is how you communicate
with aliens now some bits we're sure
aliens will understand lights they
better understand binary notation they
will certainly understand this bit not
clear if they'll understand it or not
okay well now let's look in movies
here's a movie called independence day
the aliens come to earth and conquer it
and of course they are destroyed by a
virus a computer virus what programming
language was that computer virus written
in well here's the screen I'm afraid
it's a bit messy but if you look at it
you can see that it's written in a
dialect of see it's got lots of curly
braces in it it's a strange that I like
to see that only has open braces but not
close races and at the time I just gone
to work that this movie came out I had
just gone to work at Bell Labs I was
working down the hall from kernaghan and
Richie and Ken Thompson and I thought
wow how cool is that something that my
colleagues did got into a popular movie
how did I know this wasn't Java this was
nineteen ninety-six Java had been
invented but if you think back to
nineteen ninety-six that was before Java
had spread through the known universe so
I figured it was see now how likely is
it that you can program alien computers
in C maybe not very likely how likely is
it that aliens would know lambda
calculus well all you need to ask is how
likely is it that they would know
natural deduction and modus ponens right
if they know modus ponens then they must
know lambda calculus which is isomorphic
so you couldn't communicate with them by
sending them to c program i think that'd
be really hard they spent a long time
decoding it but sending them lambda
calculus absolutely so there's just one
thing about this right i said so
anywhere in the universe
right you could go and communicate with
aliens using lambda calculus so I'd like
to say lambda calculus is universal but
I think that's restricting things of it
too much because if you think about you
might have alternate universes even in
alternate universes they will know
natural deduction and the law of modus
ponens I find it really hard to imagine
I can make easy imagine a universe with
say a different gravitational constant
but I cannot easily imagine a universe
without land two cousins so I'd like to
say lambda calculus is universal but
that's too restrictive so I had to
invent a word I'm to calculus is
omniverse ille so I'm done now I would
just like to remind you in conclusion
that right the way to make your
programming language work is to have a
simple theory underneath it write lambda
calculus has a very simple theory it's
very powerful what you should think when
you've got a hard problem what you
should think is this is a job for lambda
calculus
and I've lost my microphone thank you
very much so what's the question a bit
harsh an object could you see I can see
why I was very negative on objects yeah
could you still leave equals in there oh
okay right so what happens if you put
equals into object then go get a theorem
for everything that preserves equality
so let's see what was peering of quality
mean it would mean that x equals y if
and only if FX equals F of Y so that's
only I think one-to-one functions so it
reduces things quite a bit i would say
throw out equality as well the property
that you get is this will now work for
all functions as long as x equals y
implies F of x equals F of 0 no that's
always true
ah but it's all relations I gave it to
you for functions but it works for all
relations there are relations that do
not preserve equality many very useful
ones right anything that's many to that
one too many any relation that's one too
many won't necessarily preserve equality
so no putting a quality inn is also too
much put nothing in nothing is good if
you if you want equality that's great
but if you want equality you use what's
in Haskell the type class eq in Haskell
there's a huge difference between
looking at a function that has no type
classes in it and one that has the
equality type class right this one you
know this works for anything it just
does it this one you know oh this is
testing these things for equality that's
a very useful thing to know and quality
doesn't work on all types it doesn't
work on function types for instance so
it's actually a really good idea to be
explicit about when you're using
equality on the type you're being
generic in thanks good question and by
the way I'd be happy to describe that
more later I know that its technical oh
come on I always feels it's a complete
failure if nobody asked questions please
ask a question well so you helped
introduce generics to Java so how happy
are you about the state of Java with
generics in there so I mentioned that we
had to retrofit them with all the
existing stuff and not surprisingly
trying to do that leads to many
infelicities and things that are more
complicated that you'd like and lots of
people complained about them and they're
completely correct to complain about
them and again if you get the book that
I had up there there's a whole chapter
that just talks about what gets messy
from putting in generics to Java so
there are bits of it that are messy and
my hope is that the next time somebody
designs leg
with generics they will understand about
generics from the start and get it right
I mentioned John Reynolds in thrall he
moved to Carnegie Mellon and started
teaching there just after james gosling
and i graduated james gosling due to job
was actually in the office next to mine
fortunate so I didn't learn about it as
a graduate student I learned about it
later James unfortunately never learned
about it so what he did the design he
got it wrong right you can all learn
polymorphic lambda calculus and when you
design your languages get it right from
the start so we won't have these in
Felicity's see by the way we did it by
erasure so that we had good backwards
compatibility properties c-sharp did it
not using the ratio using something else
called reification that makes some
things work more smoothly but get some
horrible backwards compatibility so you
sort of just have to choose which bid is
going to be awful it's nice that you can
retrofit it but it's even better to get
it right from the start so I'm pleased
the generics are in Java but the reason
I'm most pleased as I hope from them
being there and in c-sharp and in a few
other languages people will learn about
them and then the next language is a
design will get it right from the start
yeah it's so a general question what
what do you think about Scala what do I
think about scholar so of course i
mentioned martineau dowski and that we
worked on pizza together and then Martin
went on and did Scala and guests all has
a huge number of brilliant ideas in it
or if I would criticize Scala I would
criticize it by saying as too many
brilliant ideas in it it's sort of like
throwing in the kitchen sink but I think
Scala is a very interesting language to
look at I think that Simon actually got
it exactly right in his slide where he
was saying you know look you want
laboratories for exploring with type
systems and he said Haskell hoskins way
ahead in doing strange things and just
beneath it he wrote Scala Scala has some
really interesting experimenting with
type systems in it in particular looking
at merging functional type systems with
object-oriented type system
showing you can use that to do things
that are hard to do with either one love
okay I think we are we're kind of out of
time now if we need to get to the next
free compatible me during the day enough
exactly you will also be here tomorrow I
should be here for somewhat 40 as well
okay perfect thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>