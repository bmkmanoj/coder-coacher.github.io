<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF Bay 2015 - Bruce Tate - Tests Can Be Beautiful | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF Bay 2015 - Bruce Tate - Tests Can Be Beautiful - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF Bay 2015 - Bruce Tate - Tests Can Be Beautiful</b></h2><h5 class="post__date">2015-03-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sDMngNP7pOw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you so much it's great to be here
hi Josie glad you made it I almost
wasn't here this is me on Monday from a
hospital bed Maggie said smile smile and
then I said oh no the erlang factory is
coming up on Wednesday so it's good to
be here feeling a lot better now most of
the way better but I really have one
thing to say this is it test all of your
code with beautiful dry fast test that I
get it all and in that little summaries
Jose yeah so this talk is really it's
really about my move as I can make a
better company which is a small start-up
in Austin it's about our desire to write
production elixir code and we thought
that the first thing that we had to
solve the first thing that we had to get
clean and beautiful was the test story
because as a small development shop with
with a very dynamic code base we have to
have a very clean test story to to make
things work so on this talk is about
that story and some of the struggles
that we we had moving in that direction
and really where we'd like to go in the
future so the nice thing about the
elixir community is that most of us come
from pretty strong testing cultures
would you agree how many of you come
from the Ruby culture how many come you
come from erlang culture and how many of
you write tests on a day-to-day basis
for your code bases it's almost an
unfair question to ask these days right
do you write to us oh yeah but my
brother doesn't write tests right
so but anyway we do come from a test
culture the rails community we so Josie
and I are both from rail shops those
that's that's a very strong testing
community you have the you know gosh I
was worried about going up against quick
check talks and I kind of checked the
schedule i said well the main quick
check talks came earlier in the day so
that's good but so the Erlang community
has a strong test culture as well we
think that it's important to test all of
your code another way of saying that is
that if it's worth writing it should be
worth testing say it another way you
don't want to let your customers test
your code right so we use we use archive
in the Ruby world we use X coveralls in
for elixir and we've liked that pretty
well so far this is what the setup looks
like so this is just the simple mix file
we had a couple of a couple of lines to
to walk users through the usage model if
they're just running tests without
coverage to say okay this is how you'll
you'll test with the coverage detail and
then you add your dependencies and and
then we have the sum sum environment
details to add and this is what the
report looks like I want to make a point
here that unless this day's pretty clean
this is a difficult report to read and I
think that that's universally true of
all testing tools so it's easy when
these numbers start to grow a little bit
to let them go a little bit more and a
little bit more so we'd like to read
this line as on or off are all of those
lines zeros or they not and if they're
not all zeros then the boss wants to
know why okay and the lines I told you
you know if you're using if you're
running coverage we try not to make the
user do too much more documentation so
we throw in a couple of extra line
to say okay this is how you get a
detailed coverage to report and so if
you find something that's not a zero
then you can run a detailed report and
the output looks like this green lines
recovered black lines are neutral and
red lines are not covered okay so the
first decision that we had to make was
what do you want to test with and well
with the liq sir we didn't have very
much of a choice we could either write
some of our own and stuff right all of
our own stuff or use what we head out of
the box right so but within the context
of this talk what I want you to think I
want you to think about the testing
philosophy I don't want you to just to
think about primarily the tool box right
we want to talk about what's the right
thing to do and then then at the end of
the talk we'll talk about where is the
right place for a liquor to go and worse
right place for other tools that that
can augment this behavior so these are
the that said this is the tool box we do
use X unit and we want to build on X
unit our goal is to grow that as much as
we can we also built a couple of quick
tools one is called should I and that's
based on has anybody ever used that BOTS
shoulda and that tool primarily is
useful to us in the area of pushing
language and language which drives in 10
I think that's important and we'll talk
about why in a second and we also have a
data generation tool called blacksmith
has anybody ever used any data template
tools I'm data generators yep yeah so
there's a couple out there for erlanger
elixir there's a faker library one that
we actually used on the back end and we
wrap some tools around that to make it
cleaner and simpler so that data is a
set it and forget it much much like the
the templates that you create index unit
but our goal is to push as much as we
can into the original X unit so that we
can grow that tool and they can take
advantage of the same
of the same oh goodness that we get out
of it so about X unit there are some
things that we really like about it it's
very fast and I think that that's one of
the foundational goals of X unit we also
like that the assertions give you more
information than a typical text testing
framework because well you have the AST
sitting there and you can tap the AST
for more information we also like the
idea that you can create templates for
whatever kind of thing that you're
working on you can create a testing
template for an ecto model or for a
controller or for anything any specific
type of business logic that you're
building right there are also some
things that we don't like about us
actually I think that there are some of
the things that many of you don't like
about X unit it's not necessarily dry
and that leads to some chaotic tests and
the syntax and the language can get in
the way and we'll talk a little bit more
about those things but like I say the
way that elixir has worked so far is
that it's very much a community effort
it was great how many of you got to see
the top last night with with josee and
the Phoenix framework so that was a
fantastic talk I think and the
interesting part of that story is that
after after there was some play with the
Dynamo framework we got together and we
talked and we said wait a minute there's
no way the one person can do a full web
framework and language at the same time
what we should be building we're
building a framework and we should be
building a lego builder right so we
started on unplug and then once that
came out we could start to push that
more aggressively into other other
frameworks and and then about the same
time that that that came out Chris
McCord started working on the Phoenix
project so the elixir the whole elixir
ecosystem is based on people working
together on common problems and as
things grow we start to pick up speed as
a community so what we'd like to do
is to push more of what we're doing into
the base X unit so let's talk a little
bit about what it means to be dry so in
this in this particular test suite on
this is an oversimplification but maybe
we have some Universal set up and then
we have a get and then we heat want a
logged-in get and logged in post right
so in this case there's some common code
that we have to write to log in the user
we probably have to create the user we
probably have to do some setup with a
plug connection and then we you probably
have to use do whatever the framework
does to log in the user in the first
place like for example pass in a stub
plug or something like that but this is
repeated code so we're not dry here
right not dry as a bad thing so I also
want to talk a little bit about the
chaotic aspect of a vex unit so thanks
for this example is Jose not everybody
is humble enough to to provide something
like this but but take a look what's
wrong here this is a real test that's in
the elixir project
yeah yeah that's exactly it so so
basically what are some of the rules of
good software design that this violates
what's that do one thing right single
purpose right that's it that's a huge
one and what's funny is that you can
look at the bottom of this and you can
see that the author of the code is
trying to do the right thing right hey
these are the single purposes and I want
to isolate these things but I can't
really do it because my tooling isn't
letting me right I want these to be
individual tests right okay so should I
we want to maintain the advantages of X
unit but we also want to start to patch
some of the disadvantages and hopefully
to push those things eventually back
into X unit so we want to be more of dry
we want we want to be more beautiful
rather than chaotic and we really going
to be mindful of the language and help
the language make us help us make better
decisions along the way and what should
I does for the testing behaviors we want
blacksmith to do with data make sense
okay so let's go back to our initial
statement let's flesh out a little bit
more beautiful so why is beautiful
important with tests does anybody does
anybody agree that tests are beautiful
or should test be like grafted on to
yeah yeah yeah I mean exactly exactly so
there's there's a there's a visual load
that we're very careful to control with
the rest of our code base but we often
don't take the same care to do the
refactoring and control around the test
cases right in fact sometimes we'll make
an effort
not to be dry and this this adds to you
know pretty significant of maintenance
overhead right so to say it another way
test cases are first-class citizens
right and if you think about it a lot of
this is driven by the language if you
think about it language shapes the way
we think and syntax shapes the way the
language hangs together here's an
example how many of you have seen test
names like this test chat test get
method right why do we see that naming
style over and over that word right
there right that word is encouraging
well that word gives us no structure
that it gives us no mental structure it
gives us no language help for what the
rest of the test case should do right
and I can say okay team let's let's make
all of our test cases have a single
purpose maybe it's more useful to say
all of our tests titles should have some
type of a name like this right but if
all of the test names are going to have
a name like this well shouldn't we
rename the name of the test in the first
place right so this is just a little
place where you know it's a lot harder
to have a multi-purpose test with the
title that says should write should
create chat now I know what this thing
is supposed to do so our overarching
philosophy which i think is a beautiful
thing one of the places that Joe's a
challenged me was we had a we had a test
we built the test framework where we
would run some code and then a
measurement then we run the same code
run another measurement
on the same code and run another
measurement he said you know no this
this isn't going to work for me and then
he would tell me the story about the
lung test about some of our clients have
tests run ten minutes and I always
walked away from those conversations mad
because the thing that I wrote didn't
work that way and I knew that he was
right and that I have to rewrite it but
I think that where we'd like to go with
should I and where I think that we are
right now with should I is that we want
one experiment to have multiple
measurements the second piece of that is
we want the multiple experiments to run
as long as they're providing useful
information right so if I'm calling a
get of index and I'm testing the
response code the template that he comes
back with and where you're potentially
redirecting to all three of those things
I'd like to know how all three of those
things failed if they fail so I could
have just one iteration two to actually
fix all the problems at once does that
make sense so one experiment multiple
measurements that's that's I think a
beautiful design concept and that's the
one that we support so this is what a
lot of our test cases look like before
we adopted this approach so that all i
had a i created a bucket and then added
to the bucket and then did the
measurements after that that's multiple
assertions multiple measurements if you
look at that test it doesn't look that
bad i would guess that this test case
would not look the same after a little
while right especially if there's more
than one person because why because i
don't want to write the setup code again
now i'm going to say hey i need i need
some context with one element in i'm
going to stick my thing right down here
right you know I need something with the
chat bucket I'm gonna stick another one
right here and then you wind up with the
nightmare scenario that we saw in the
first place
with with multiple purposes right so
what we'd like to do instead is right a
little bit more code this does say
basically the same thing you know I have
a single experiment here create a bucket
and then I have some assertions but I
can actually take some of this well
let's talk about the the experiment
first one of the things that I like
about this is that the the experiment
lives in set up its kind of setup stuff
sort of right it's kind of test stuff
and that's kind of why I don't like it
as much but it's when we nest setups
which will do layer which will do a
little bit layer the line between the
test and the setups blow us a little bit
so I'm okay with it and then I run a
bunch of measurements about the about
the the chat some of these are very
simple and they have the same structure
right and so I can I can take those
patterns and I can build functions or
macros about those to collapse them like
this right I want to point out there's
another compromise here though what
we've done is since we've made a
compromise up here with since we've said
hey our measurements aren't actually
inside a test block anymore there's a
problem because now these have to be
macros these can't be functions anymore
right so keep that in the back your mind
that's something that we're going to fix
a little bit later okay so in this
philosophy we have a set of mattress and
mattress do a couple of things first
they help Mia collapse our intention
from something that's more complicated
to something that's simpler but in other
places I may want to collapse a heavier
weight policy into something that's more
succinct
right like what a success mean does that
mean it's a 200 no it means it's between
200 and 299 right it means that it's in
the 202 299 zone so this matter actually
encapsulates the policy of what success
means now I can still test whether
whether the context dot connection dot
response is equal to 2 200 or 201 or
something more precise but I can do
something more general if I want to if I
choose to and that's the goal of a metro
right so another thing that we're that
we we try to accomplish here is that we
continue on fail and halt on error right
do you guys like that or not how many
think this is a good idea to continue on
failure and halt on error how many don't
like it take a stand let's try that
again so a failure will continue to run
an error will halt the test case
execution all right how many like that
we continue on failure how many like
wood how many would rather it halted on
failure okay so and why would you like
to see it halt on failure do you mind
saying so you can take action much more
quickly anybody else got a got another
reason
that's the counterpoint is anybody think
that we could land somewhere in between
what's up yeah yeah or maybe after five
failures I think that you're going to
get more so I'm going to stop now right
and so I think that that Josie and I had
a conversation earlier maybe last night
this morning yep where where we could
just where you could specify account
maybe maybe five it might be might be
five might be 10 might be one okay so
let's switch gears a little bit and
let's talk about test data how many of
you would rather see test data created
directly in lik sir how many so a couple
of people how many people would rather
see people would rather see test data
created in fixtures hand or two so still
you're still not taking the stand I'll
let you get away with it this time next
question everybody takes a stand okay so
we think that where possible you should
create your your test data with
undecorated elixir right but there are
some places where that's going to fall
apart and that's what we're going to
talk about here so applications need
test data elixir makes fine test data
right if it works if I can create my
test data beautifully and concisely I
should do that right sometimes when
things get real you need a little bit
more help or the test data will swallow
the test case completely right and so
these are the things that I'm talking
about sometimes I have the same types of
of data formats or the same types of
data the different formats sometimes I
want persistent data or not persistent
data sometimes I want to create things
enlist sometimes I have different
defaults but for four different types of
tests and sometimes a might I might have
way too many accurate attributes to to
specify every single time through the
test right in our solution here is a
framework called blacksmith and it's
it's based on a framework that created
and kind of kept private and Ruby
because I didn't think the world needed
another data framework but these had a
few opinions that that Eric and I like
so so we kind of flesh it out this is
what it looks like so the first thing
that we do is we create a template the
template is just registering what an
individual entity might look like in a
lick sir so there's a macro and a macro
is followed by just a set of name value
pairs and the name of the entity itself
okay but maybe some data might always be
the same and maybe I am working with the
database and I have concurrency issues
or I have concurrent tests running so I
want emails any new email always to be
unique right and maybe I have an admin
so regular user has a role of an empty
list and admin has roles with admin
inside or something like that right so
in this case my prototype is this user
up here right so the first in the first
API for pre register I have two
arguments that's the name of the the
name of the entity and then the map and
then the the key value list and in the
second one I have three arguments the
name of the entity the options and then
the attributes in the fields that
support yep
yeah I guess we could that sounds like a
reasonable thing to do so we would do
something like this right instead of
prototype we would say you know trait
user or something like that that work
the same way I think it'd be it's all we
do is merge we just merge these in these
into this one right and so the
configuration is pretty simple we tell
blacksmith how to save one and how to
save many we provide a would provide an
integration for ecto which is pretty
simple and this is what the usage looks
like i can create a single user i can
create a save user I can specify
attributes that override the defaults
right so this will create a saved user
with the name of will override I can
create an admin which we saw before
inherits from user based on based on
this prototype here prototype based
inheritance and I can create a list of
users so what school here is this allows
me very quickly to separate two separate
the database from the test right because
I can create I could say hey give me a
saved saved admin list not can create my
test like that and run it like that and
then I could separate out the repository
and say this is a this is a simple
repository that that just has five
elements in it right so I could have it
saved or an unsaved list and I could
have singles or doubles and there's
another feature that you don't see here
that allows you to take the map and
translate that to something else right
so i can create a JSON hash or whatever
form
I thought I want to write this is really
cool this has helped us keep our our
test cases much much quicker than they
would be otherwise okay so let's talk
about dry what's the biggest problem
with the lick sir and and dry test what
do you guys think yeah yeah yeah so a
lot of the the so there are some macros
um so be really careful when you say
that because a man next to you would say
we're going for explicit there um yep
yeah I agree so there's you're always
walking on a razor right and and the
razor on one side it's over ceremonial
on the other side it's Oh is too you
know too much ceremony versus too much
magic and you know if we didn't want any
ceremony at all we'd sweet everybody
would be coding Lisp right now right
because that's the that's syntax with no
ceremony at all right so yeah I agree
with you there's anybody missed nested
context that you see in some other
testing frameworks I think that's a huge
deal I think that's probably the biggest
deal for us we think that to have dry
tests you have to have specialized set
ups and with nested context right so a
setup for for group of tests and then
you build up on that set up for another
group of tests so for example maybe you
say we're testing a controller all of
these tests are for logged in user all
these tests are forget of post all these
tests are for Eric a get a post with an
error condition right so all of those
things are just building building on
separate on different plugs tax right so
for example maybe I have a controller
tests that's testing the
geez that's running very simple tests on
on these actions then maybe sa well I
want to run some tests logged in I want
to run some tests logged out which might
have different behaviors and then maybe
I want to run some additional tests with
admin users which might have you know
separate links that show up like or
separate links that are hidden like flag
this user as vlogging this post is
inappropriate or things like that so
let's take a look at some code that
lives down here maybe it's something
like this you know I know it's
oversimplified I kind of coded this
actually right on to the right into
keynote did I say that out loud sorry
but anyway so there are chunks of this
code all the way through they'd have a
lot of replication in them right so like
for both I have to create a part create
a connection and then and then and then
process the get right and that's all
that's all repeated across these two but
with the nested context I might write a
little bit more code but I could do
something like this right I could say
well if I have a part in a connection I
want all this stuff to happen well for
logged in users I want all these things
to happen and with a logged in admin I
want all these things to happen well a
couple of things happen when you write
the code this way the first one is that
the dryness is that you start to get you
start to dry out a lot of this code
right there's more ceremony here maybe
maybe too much ceremony here we'll have
to see if we can bake it down here but
the other thing that happened is happens
is that the intention of each individual
test case gets much cleaner I can do
something that looks like this one
experiment multiple measurements each of
which run to completion each of which
gives you district general information
right
get responsible success winders a
template for configure okay okay so one
of the things that we always struggled
with in ruby was fast tests and elixir
is already going to give us some
improvements like that over that because
well it's a faster language it's ignore
it's a concurrent language and it also
has we also have a clean start and the
clean start enables us to look at things
in a new way right so I want to talk
about a couple of a couple of important
subtests here the first one is that
integration matters I'm going to
embarrass you Josie so we were actually
bouncing some code back and forth over
what skype and email or something like
that maybe both probably both and so I
got this example make the toast spread
the cream be sexy I love that right and
so so anyway this is the this has the
same problem of the integration tests
that we saw earlier right and so we have
multiple tests but really the problem is
that this really isn't intended maybe
these are slow things and maybe this
isn't intended to be an autonomous test
this is probably intended to be
something very different an integration
test where one thing has to happen then
another thing has to happen and then
another thing has happened and we're
testing all the interplay between the
components right so while this is
multi-purpose if we shape the code in
the right way we can define steps that
are that are autonomous right so this is
what we can do today so maybe we return
context that has create breakfast in it
somewhere right and then maybe we spread
the cream that takes a breakfast
argument and we run the test we do a
measurement and then we return breakfast
right and then we can make our test look
like this right this integration test
describes our intent marvelously well
right so we haven't done anything what
are some of the problems with this
approach though yeah so where does yup
we don't we don't get the information
all the information that we'd like to
get out of this right like we don't we
don't understand exactly where these
things broke we'd like to see better
information excellent so what we'd like
to see so after a little bit of time we
came up with an integration test that
looks like this right and this will
basically compile down to this with a
little bit of extra metadata that gets
passed through to to the the ax unit for
matters which is very cool what do you
guys think better yeah thumbs up how
many people say like it don't like it
good so this is the direction that we're
going so the second thing that we that
that we've learned is that concurrency
really matters and we can't do anything
in the test cases to disrupt currency
that's why we really yup
yeah so probably not within the rappers
but it would be very easy to break out a
step right here right so the only thing
that has to happen is these have to take
the same the same argument so to be very
easy to take a function yo you know one
line this and and call a function that
you could reuse yeah yeah great point
more comments questions ok so the
concurrency really matters and one of
the things that we've done is we've
tried to control so first we've tried to
control mocking and joe says been a
strong influence on that but we've also
tried to control the database
concurrency by controlling the data that
goes into it so we have a master
sequence that's an agent that's sitting
out there that can allow us to create
unique IDs that are always unique for
the life of the test case and for the
family of test cases the other thing
that we've done is with with blacksmith
we started with with user and save user
and we thought this isn't enough because
we'd like to be able to create a
repository of users that has nothing to
do with the database and a great way to
do that is to create just a simple
database stub that has very very skinny
functions right that allows us to you
know to add remove and you know just
just very basic crud crud methods on it
that mirrors the API of of ecto right ok
so I've shown you the tool case that we
use today this is where i'd like for
things to go and this is where I think
we'd like to take the X unit tools so
the should I we'd like to push our
experiments out of setup and back into
tests right and once we have a couple of
extra features an X unit that can happen
after this happens we can do this
right now mattress or macros we'd like
matters to be functions right functions
are easier to write they're easier to
understand and their fundamental to the
types of things that we want to be able
to do so into actual unit this is what
we'd like to see we'd like to see nested
context I think we already know how this
can happen we'd like to we'd like the
ability to continue on fail probably
configured by the number of failures
right we'd like to be able to customize
the assertion messages so that maybe if
you're dealing with plug you can see the
HTTP headers things of that nature and
then we'd also like to be able to see
integration tests that look like the
ones that that we showed earlier do you
guys like these things they sound like
the right list anything missing think
about that and get back to this okay in
conclusion test all your code with
beautiful dry fast test okay questions
comments yes
we're using X unit and should I for just
about everything I've never been to Cuba
cucumber person that's I'd love for
somebody to step into that some of the
more behavioral type elements that's
that's just not us yeah
so right now I mean we're kind of
heavy-handed where where our cleanup is
just kind of you know stamp out how all
these processes you know kill the you'll
kill them through OTP system processes
we haven't touched that at all we don't
play in that space at all I'm josee
you know most of the work that we've
done around multi-process is more to
help us with race conditions in the test
so that we can do things like we can do
we could have matters that that have
receive arguments right like it should
receive a message and then match a
message and then and then compare that
against the result yep yep yep I totally
get it so is there a test case that you
can point him to in the ellipse roco
base that would help him
like
so these sound like real battle scars
right so it sounds like you have some
some code that you can grab from yeah so
we have we have a bigger problem right
so we have we're overloading setup and
test right we're overloading set up for
set of purposes and set up for the
experiment purposes and we're kind of
blurring the line between the two more
than it would would normally be and it
took it took what four or five
conversations for you to talk me out of
this bad idea but you finally talked me
out of it
yes because as you had more sugar we
start going to eat one specific place
and they need to relearn everything
right so yeah thank you about calling
functions and about returning maps yeah
trains because if I have to match I know
how to merge match I just need to calm
at work yep be very careful with that
not introduce our own terms because it
is right because already have a very
language right but and neuronal
structures we can break that yep
right yeah in blacksmith I mean we've
we've trimmed that down to I think three
macros just the macro to create the I
like having the save user the usual list
and stuff just because it's it's it's
code that's red so often and I like
having to register because that really
defines the intent if I am building a
template right now but it's basically
you know that's it's basically
delegating a function and so that the
template yeah but i agree with you very
much there yep uh-huh wait a minute
there's a question back here I think
that right now we plan so probably the
initial release will do it sequentially
and then we'll decide where to go from
there I think I think that if you if you
had more complex lodging is this is just
sugar for providing additional metadata
for something that you do a lot right
running one thing after another straight
composition so I be afraid to add too
much to that for the same reason that
shows they just mentioned if I did that
then what I'll probably do is write
functions compose those functions and
then just bite the bullet on on getting
the extra metadata out yep
yep yep yeah I agree I agree I agree
nope any more questions yes I like the
way it reads liked it backed it out and
looked at it several ways but when I
read it this way I it just it screams to
me that I'm creating test data and these
are the arguments for the test data
right so ford says I'm test data this is
the type of destin a test data that I'm
creating and then right after that or
their arguments for creating it it it
makes it so the whole thing that we're
doing is simplifying complex test data
and so it's it it reached me much more
cleanly this way other comments okay
let's go get some coffee thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>