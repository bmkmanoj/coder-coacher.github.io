<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Robert Virding - LFE - a lisp flavour on the Erlang VM (Lambda Days 2016) | Coder Coacher - Coaching Coders</title><meta content="Robert Virding - LFE - a lisp flavour on the Erlang VM (Lambda Days 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Robert Virding - LFE - a lisp flavour on the Erlang VM (Lambda Days 2016)</b></h2><h5 class="post__date">2016-03-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Br2KY12LB2w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yet how many people know this by the way
all right I can skip token skip four
slides
okay so this is about LFE let's play
with our line it's just a a lisp or a
flavor of list running on top of the a
line virtual machine so it will describe
a little bit a little bit about that so
to start off with what it isn't it's not
scheme okay it's not Common Lisp and
it's not closure okay right and the
reason for that is the properties of
these or the properties the a line
virtual machine make implementing those
types those lisps inefficient we'll see
why a little bit later so yes it can be
done but no won't be efficient and there
is no way around that but what is it
well it's a proper list I mean it is
proper in the sense it's not just a
weekend hack it's properly with things
for it but it's based on what you can
and you can't do it on top of the Aling
system and it means that it will coexist
completely seamlessly with anything else
running on the Aling system in this case
our line we're OTP and it runs on a
standard vm there's no special VM
necessary for it so I can skip the
wireless okay the people here so the
question is of course do we really want
to code in something that is so old
we're talking 50 years now right that
actually is all very old this Lisp code
from the early 60s a copy of it it's
three functions doing some set
operations on lists right so as a member
of the Union and intersection the syntax
wasn't that easy to read and they hadn't
really learned about indentation
properly then at that but we can do it
better now so here are some alternatives
written in LFA there's a union function
and intersection function we'll see more
about that the question of why Lisp of
course was if you know it's easy right
you you have this peasant list as
numbers
it's got symbols right so more but more
of do if size and greater than they're
just symbols we have lists of course
which is what it's all about
we could have lists of numbers we can
have lists of symbols and we can have
lists of
lists containing both numbers and
symbols we can have another list here
which is starting to get interesting
here because this is well as the list is
a greater than over size and for right
this is also a list and now it's just
we're starting to see here that we're
actually getting code so this isn't if
this is an if well an if form we test if
something size is greater than four will
do bump it otherwise we'll call dropping
right which means we go even further we
can't define a function like this which
is also a list so the one of the very
interesting things about Lisp of course
is that all code is just lists all codes
are dated just data structure trade-off
data structures it's homo iconic which
means working with code very easy
compared to working with code with other
languages it also means that well
depending how you want to see it Lisp
has a very simple very simple syntax or
it has no syntax at all I write down the
list and I can interpret that as pretty
much whatever I want to interpret ours
right before and of course the white the
wildest pay wealth has been around a lot
has changed in 58 okay
yes but it's it's an external language
excellent language for experimenting
prototyping developing systems writing
things like the idea cells and Lisp they
are actually nothing specific because we
can view a whole of Lisp as a DSL right
so that's a very quick thing most people
have seen it
okay what's the goal of LFE what was the
goal of it it was to be a proper Lisp I
mean something was actually usable to
write serious stuff in entities it
hasn't reached 1.0 but it's but it is
production quality actually there's
always one more feature I want to add
before I get to 1.04 but pretty soon I
will have reached it it's efficient on
the beam meaning in the sense that you
can write your code in LFE and it will
be as fast as writing in his airline or
anything else in the video there's
nothing strange
about that and interact seamlessly with
our line OTP so you can mix you can
write things and how long you can write
things Lisp you can mix it together if
you're using OTP I can write my
behaviors in LFE there's no problems
doing that so how does this work in a
more general sense here yeah this all
due respect to Leonard Cohen here this
is a fantastic Leonard Cohen CD if you
haven't heard it from the early 70s but
it's really well worth worth listening
to
it's as depressing is they always are
but it's very nice depressing right
there's even death in it but it's okay
yes but if the if the idea here it's the
new skin for the old ceremony and get
what do I mean by this is if you start
looking at implementing languages other
languages on top of the a-line virtual
machine you end up you end up with
something like this if you're going to
do it sensibly you've got the Aling
virtual machine the beam at the bottom
okay
you have our lying on top of that then
you have the OTP libraries and then you
put what you're what you're doing in
this case LFE sort of half beside half
on top and half beside it so you you you
you could implement directly on the beam
but that would be a very impractical
choice because you'd be throwing away
most of benefit a lot of the benefits
you get from would you part of the
allying system the OTP the libraries the
way of working with it they just throw
that way so a better way of doing that
is keeping those and putting what you
want to do beside and on top of it so I
can reach all the good stuff for it I
can reach the good stuff that's in our
line in you know TP but I do it through
my interface and this is how you would
implement a language or I would say
native language on top of the a language
or machine a Moose's base is what a Lang
is and if you're looking at their likes
ear they do it exactly the same way
there's nothing strange about this so
the first question is of course what is
the beam because there's this decides
this defines exactly what we can we
do-right and so what is the beam well
it's a virtual machine to run a line
okay sort of a bit of a derp but this
actually this actually means quite a lot
for because when you think about it the
beam is designed to implement a like
nothing else just Aling so there's a
very close connection about the features
of the Erlang language and the beam and
the features of this how systems would
be built on top of our line and how
that's supported inside the beam so
there's a very close connection between
them so the thing here is saying to make
it efficient if you want to make it
efficient you have to work with that and
just accept that and work with that and
use the pen use those features right and
if you look at the properties of the
beam I missed the slide oh great
nevermind yeah okay so there's a slide
missing here talking a bit about about
the more system type features have been
so that with all the things that you get
nailing like the concurrent the
primitives of the concurrency like the
primitives with the fault-tolerant the
communication the process handling the
distribution mechanisms the scalability
stuff all that's part of the beam all
that's based in there so when you're
running hour-long and you're running on
two cores or four cores rate course or
16 cores wherever it might be
it's the beam that makes sure you get
access to all of them is the beam that
will load balanced automatically between
systems will make it efficient to send
things messages between processes
everything like this is all part of the
beam all that's baked in you get all
that for free but there are things you
sell them see directly in your language
you will use them because you know I
have processes I know I can send
messages I know for example a system
will never block etc and all these type
of things I know everything's
asynchronous etc etc but I don't see
that in my language really it's just
there right and I will use it and I'll
use it my building systems I don't see
it but here are some properties that
some of the properties of the beam are
there
related traveling the language and these
what will affect me as implementing a
language on top of the system directly
effect which this is what I see right
and coming from a functional world some
of these are strange at all but if
you're not they can be so it's immutable
data okay again this is very functional
but all data is immutable there is no
way of getting around that it's not that
there's that it's not that the language
itself enforces it's the implementation
of the virtual machine that does it
there is only a predefined set of data
types that's it I cannot create new data
types but we have support for pattern
matching built into the language so
that's that's very nice for it
it's support for a functional language
the way modules and code work are also
baked into the system and another one
which can be slightly strange if you're
coming from the non-functional world is
there is no global data in the Aling
machine at all
we don't do global and we don't do
sharing and that's it right now these
are things that will directly affect you
implementing language and this is while
getting out earlier things like Common
Lisp and scheme you cannot make an
efficient implementation of those
because you don't have mutable data so
if you want to implement mutable data
that meet that entails carrying around a
state with all the data in it and
working on that state when you're
mutating it and yes you can do it I've
done it with fur law but it is not
efficient so you can't get that and
there's no way around that so yeah and
this if this affects the language so
some of the things we're gonna look at
we won't go through everything but all
the features of LFE but some parts of it
it's a bit about the syntax of data
types modules functions this one versus
Lisp to the never-ending war a bit about
pattern matching and macros right so so
the syntax is pretty straightforward
basically syntax you have your
parentheses for the lists some bits were
borrowed from scheme so they it's got
the square bracket versions of list
lists instead symbols quoted symbols
like common lisp you've got vertical bar
quoting those we have all the standard
separators we have the we have this
topple constants we've got binary
constants there's a string syntax which
expands to lists of lists of characters
list of integers and this is the way our
Lang does it so if you look inside the a
line system there Allen doesn't really
have strings it has lists of lists lists
of code point values so the string
expands to that we've got characters
there is also bit of syntax for a binary
string so you can you can make a binary
a binary data binary data structure
which contains a utf-8 encoded character
streams we have a fixed set of data
types again this is what's enforced by
the Erlang virtual machine the a-line
virtual machine does not allow you to
know user-defined data types at all it
has to do with a code loading if
anyone's talked more about the offals I
can explain a bit so we have numbers we
have atoms which are Lisp symbols we
have lists of course we have tuples
which are equivalent and lists vectors
we have maps we have binaries and we
have a number of opaque data types that
you just they're just there for example
you have a process each process has a
process identifier which you need to
identifies that process typically called
a ped and that's its own data type there
are a few others as well to form and
that's what you have that's it
many there are a number of things here
which means we can't do things like it's
done in Common Lisp or in scheme for
example when we're talking about atoms
and symbols in our line an atom only had
it has one property and that's its name
there is no concept of an atom having a
value or a property list or something
like that that just does not exist in
the system at all it has an atom knows
its name that's basically it
and the value of an atom is itself
there's only one namespace we don't have
names basis in the system
we can't implement common list packages
as they are because they are namespaces
we can't do that you could fake it by
munching names so having an exported
visible that symbol in a calm package
you could call that food : Barney
internal one fook fook : : bar or
something like that
but that will just not won't properly
work right you could more more most get
it working but then you won't be able to
interact with the rest the Erlang system
which has other rules as well - that
just doesn't work so we don't have
packages that means we have problem with
all the other language list I was
mentioning you can't do those probably
boolean Radames is just an airline
property so that the atoms true or false
they're the boolean values there's no
special no boolean types so I'm not
going to talk about the other other data
types they're pretty straightforward I
mean numbers numbers tuples of tuples
and things like this the interesting one
of course of binaries which in one's one
sense binary is extremely boring it's an
it's an array date it's an array its
array of bytes okay that's it
the interesting thing is how you can
access it so I have a structure here
binary the top one the first one
constructs a binary or three bytes one
two and three but I could so I construct
the segment's but I can say what I want
these segments to be so the second
binary I'm creating and binding with T
and and it's going to be 16 bits big and
a little endian value little endian
integer put in that right and then i've
got two two segments which are four bits
big each and I've got a floating point
which is 32-bit floating point and I'm
putting a bit string at the end of it
now a bit string can be any number of
bits they don't have to be units of
eight four so this tells me how I want
to put together my binary so it's a very
declarative way of accessing raw raw
byte data I don't say how I don't give
in
structions how to do it I say what do I
want it to look like and if I write this
structure down the system will build
that binary for me recorded those rules
and putting those fields in that's a
very powerful way of working with with
binaries with binary data it means
things like protocols to suddenly become
extremely simple I basically look up in
Wikipedia the description of the
protocol structures or write down the
binary definitions of them and that's it
I can do these things for and as an
example of how far you can get that
binary structure describes an IP version
4 packet in one go right so yeah it's a
it's a four bit version it's a it's a
four bit header length
it's a 8 bit service type it's a 16 bit
total length it's a 16 bit ID there are
three flag bits there which I think
usually zero for the type of these types
I've looked at them there there's a 13
bit fragment offset they've bit time to
live etc etc etc so this is just I write
this down this will create that that
binary packet for me right so it's a
very nice declarative way of working
with with binary data and I'm actually
very surprised that a lot of other
languages don't have this I mean writing
that in C code that's quite a lot of
effort that's quite a lot of errors and
here just straight off right we'll see
some other examples that other things
you can do that later on as well - for
so our line has this concept of records
if you're talking yesterday someone's
asking you about records so we have
records of course in LFE the mainly just
because we want to be able to be able to
interface to our language has the
records so we want a nice structure for
that but again it's not a new data type
okay it's a tuple with a tag at the
front of it this is what this airline
records look internally as well as just
a topple with a tag with the record name
at the front of it and it provides name
fields that's all it does one so for
example down here we would have a person
record here with me in it
and my name age and some interests mr.
Pinterest fourth and this has just
basically has literally house integrity
it's in store in the system is just a
topic I have a long discussion of why
that was good or bad but that's another
issue but we have a pretty lispy way of
defining it so we have a def record
macro here which takes the name of the
record and then all the fields you want
to put in it and it will make what that
field definition can just be the field
name or a field name and a default value
now what that will produce is a sequence
of macros to create an access that
record so if I define a record like this
I'll get a I'll get a make a make macro
which will create a record to record for
me I'll get a test for it I'll get a
match one I can use when pattern
matching so I can test is is this thing
this type of record and extract fields
etc forth
I'll get access records or access macros
for accessing the fields in so I can set
the more rhythm so we hit have hit havoc
we have the case here which one macro
which one what I call that will expand
to a sequence of other macros I can use
for them so records are very easy to use
from LFE okay we have modules and
functions so again we have what the a
Lang system what the beam provides with
modules they are very basic ok a module
it has a name it has a list of exported
functions it can only contain functions
ok there is no concept of modules having
data or anything like this there no
module variables or module data
structures or anything like this
it get at the bottom level it's it's a
name it's a list of exported functions
and it's a lot of defined functions
inside it that's it right and the module
name space is flat there is no
hierarchical module name space in the
language in the system at all you can
try and put something on top of it but
at the low level is just flat right and
the thing here with modules is the
the unit of code handling so when you
compile something you compile a whole
module when you load something you load
a whole module when you get rid of
something you you delete the whole
module
you cannot compile bits you cannot have
bits and pieces of functions I compiled
a few functions here in one module and
have a code function over here which
I'll compile and put into that module
that does not work when you compile the
module you have to compile the whole
module in one go that makes some things
you'll find another list but
difficulties they're not equivalent to a
namespace I can't create a name for the
namespace I can create the namespace
then I can add things to it later I
cannot do that with a module when I make
the module everything has to be there
that makes other things difficult to do
and also just where functions only exist
in modules so now we're seeing from them
from the list point of view now getting
a brief overview of the internals of our
Lang as well - - for the price of one
presentation so yeah functions only
exist in modules the LFE repple you can
define functions locally within that as
well - another interesting thing here
with modules there are no inter
dependencies between modules so anything
any interdependent is there they're all
run down at runtime I cannot add compile
time check if a module exists or not
safely check if a module exists or it
has a function if not this so I do not
know what it'll actually be like when
I'm running the reason for this is that
it from the a line point of view modules
can come and go while the system is
running if you have things like inter
dependencies of stuff that will make
that seriously impede on that that's why
you cannot have user-defined data types
because because because modules can come
and go so yeah this is just some very
basic pop and these just things you have
to live with yes I very much like to be
able have more name space II type module
I could plug in and remove functions as
I go later on but the system does not
allow that okay you could do it perhaps
by keeping all the abstract code of all
the functions in the module and
recompiling things as you go all the
time when you're adding and removing
but that will affect how the code
handling of the system runs and affect
other things while the system is going
so you can't do that
so it is hard to find a module is a def
module so this defines the modular RIF
and we're saying we're exporting two
functions we're exporting three
functions here actually add to add three
and sub two so what are the two threes
here so when in Erlang a function has a
name and it has a number of arguments
the arity of the function so when arms
what I'm saying here is I'm exporting
add with two arguments that I'm
exporting add with three arguments and
I'm exporting sub with two arguments
again this this this is this is the
underlying yelling machine there's
nothing I can do about this so every
first so that it means two things that I
can have a function two functions with
the same name with different number of
arguments and they're different
functions so if you look in this code
here there are two add functions there's
an add a B which does plus a being is
add a b c which does plus a b c and they
are different functions that the same
name but they're different functions and
what i want to export them as i do here
i have to be explicit and say which ones
i want to export and we have sub here
with two arguments for them it also
means you cannot have functions with
variable number of arguments you can try
you can try and fake it but that you
can't do that internally that's just a
property of the system that's baked into
that and again this is something we just
have to accept this is how it works
right so yeah so having functions with
the same name and multiple arguments is
quite practical it's quite nice to do
that not having functions with variable
number of arguments well if you used to
it can be quite stifling but you get
around that there are ways around that
so an ls3 module it is the declarations
it's the thing at the top def def module
there are other declarations you can put
in there as well but it said
declarations
it has function definitions these were
the functions of defining before the app
the two ads and the sub for example
where I can define macros inside a
module and I can access those and
there's a way of doing this way of doing
compile time function definitions so for
example the death the death record macro
that expands to a number of macros plus
two internal local functions which are
used when you do it doing the macro
expansions and there compile-time
functions they only exist during the
compile time that they're not not seen
afterwards but they used when for the
macro expansion and there other things
you can do there now you can actually do
quite a lot there now in the compare at
the compile time level of defining
things defining macros defining
functions which are used by macro
expansions and stuff like this and
defining variables that only compile
time will start at this point but once
they once think modules compiled it's
all gone macros can be defined anywhere
just as long as they're defined before
they use there's nothing strange about
that I'll be working on extending this
I'll talk a bit more about this at the
end they've got the right slide here as
well - okay the list one versus Lisp -
this is the discussion that's been going
on what 50 years about these type of
things for and this is how symbols if
they're in the function position or in
the value position how you get the value
from them for this way so if if you look
at that if you look at the food the food
42 bar list there that's that's a that's
calling the function foo with value 42
and the value of the ED of the of the
symbol bar okay that's what that's
that's what that structure does now if
you know Lisp 1 Lisp then in both
positions both the foo in the function
position there and by
the value position you will use the
value cell for that symbol to get get
the thing so you'll get to take the
value cell or food for the function and
take the value cell of bar as the
argument so that's what this one means
it's just one thing there's a value so
now if we're in list two then a symbol
will have a value cell and it will have
a function soul okay so that's where the
two comes from and therefore the foo
here which is in which is the function
name that will use the value of the
function cell for the function whereas
Bar will use the value the value cell is
the value does that make sense yeah and
so typical Lisp ones schemes on this one
I think closures are Lisp one and
typical list two Common Lisp is a lisp -
okay an old Mac Lisp and this machine
lists they were also listed - actually
there there look it should be it's not
released one list - should be listed for
at least five or something like this was
a symbol other properties as well but
that's what this Wars been so that's the
list one versus the Lisp - generally is
in list one is said to be cleaner it's
nicer for you just have one thing and
you use that irrespective what you're
going to do with it
but we have listed two I think I read
reading some of they actually wanted to
make a list one out of common list but
they couldn't because of the hereditary
format behind it so yeah how does this
work now how we're going to fit this
into into LFE so I can I can define two
functions foo here one of one argument
and one or two arguments are in one of
three arguments so good I can I think so
global level I can have two foods now if
if I was in a list one here I would in Y
bar here I'll do let here and I'd say
bat bears now ism as is a lisp is a
function of one argument but I could
call with bad see here not gonna call
foo with two arguments and food with
three arguments there I could not read
it I cannot have two Bowser's in this
case one of one argument one of two
arguments was it they're just they're
just the value of that symbol okay
whereas in through here like
multiple foods because that's what the
system gives me and this is inconsistent
okay what why Karen had allowed to have
one bears at but two foods because
they're in different places now one
solution would be to say okay we'll cut
out this thing about having multiple
have having functions of different
number of arguments we'll just just
forbid that we could do that quite
easily but that's very restrictive and
it also affect your interaction with the
rest of our Lang and OTP which moreless
assumes you have these you have
functions the same name and multiple
arguments and I don't like the
inconsistency
so those heard me SSA yesterday safe
consistent consistent consistent so the
alternative is that you go for Lisp to
instead interpretation of it so I can
still have my two functions through
there but I can I can now I can now
define functions bars depending on like
a multiple definitions of bears
depending on how many arguments they
have so I can't do a normal left here
after an F left a function let here
saying okay now I'm defining bears the
functions bars here with two two of them
one a one argument one of two Agnes and
I can use these locally so I can call
back through with two arguments through
with three arguments bears with one
argument bears with two arguments so so
I'm being consistent I can also actually
give bears a value inside a letter and
use that as well too if I want to so it
is consistent here and that's why I went
with Lisp two because the consistency
for it I've just found easy to work with
so yeah so I think it fits better into
the system I think just makes the whole
thing more consistent I actually call
this two plus because you cannot just
have multiple for two functions you have
multiple functions of them so I could
basically swore I have multiple foods my
mouth multiple bases as well too okay so
that's that that's why we ended up there
there are a few other lisps on top of
the allen machine one called Joxer they
went with Lisp one instead that they are
more closure inspired yeah as you might
have seen if you've seen
commonly this is this is more common
list inspired and many of the names of
the other things you're doing therefore
we have pattern matching okay I don't
have to solve pattern matching here yes
it's a fantastic big win once you've
used it you're sort of realized you
wonder how you could not have it I was
seeing saw some discussion on Twitter
that C++ is considering getting patterns
or something like that equivalent to it
I don't know if it's true or not there's
just some questions someone asked what
what people feel thought about that idea
I have absolutely no idea if it works
online if you can fit it in but it'd be
fantastic if you could do it it's anyone
know another environment yeah
so we have pattern matching of course we
put a pet pattern matching every
everywhere so I go to father yeah so we
so we use pattern matching this is a
change from from LFE compared to most
other list we have pet and matching
built into the system everywhere right
so it's in the function clauses let's
case receives macros macro-econ's LC and
bc and list list comprehensions and
binary comprehensions so the left now is
not a just a value it's a pattern so I
give a pattern in expression I evaluate
that expression I do the bindings and
the other variables I think export out
for we have a case we have a case in
expression with separate clauses
depending on which pattern matches so we
use pattern matching everywhere the only
one would actually have to have is the
receive because this is the structure
that's used the Aling system to extract
the get messages that have been sent to
a process and you do that by using
patterns and which message do I want
I'll give a pattern to a message I want
to receive and I'll find that message so
here would actually have to have
patterns will have the trivial case of
receiving everything which is something
you don't want so we do pattern matching
for when you define a function you can
define a function with separate clauses
and use patterns on the arguments to say
to select clauses
okay so as I thought I can a function
with multiple clauses depending on the
arguments the patterns the arguments I
can select clauses I guess they're
closed which one I want to do here
we've even added a patent case to the
cond so con just doesn't do tests one of
the tests can actually be a pattern
matching that pattern match succeeds
then you choose that choose that case
and then the variables that come out of
the pattern match you can use in the
body there so I've tried to put pattern
matching as deeply as possible into the
system there are lists list
comprehensions and binary comprehensions
macros as well which you also use
patterns for selecting as well
we have macros of course I mean you
could not have a list without macros
there unhygenic for there is basically
no Jenson well you can write a Jenson
but then you run into a problem in our
line that whenever you create an Adam it
never goes away and you'll eventually
fill the Adam table if you do that in
uncontrolled fashion so we don't do that
and there at the moment they're only
compile-time though within the ripple
you can define local macros there and
use them as well too so the rap of the
ripple is very dynamic right and there
are a bunch of core forms in LFE you
cannot redefine those as macros I mean
there's a cons corn for core form for
building a Khan structure yes you can
define a macro called cons but it'll
never be caught
so is there's a bit of self-protection
anyway you can't you you can shoot
yourself but not too much anyway right
so yes but the system quite happily
defines the macro for you but just won't
it won't reason there's a death match so
they're deaf my crow here so I'm
defining a macro add then which takes
two and just returns it just returns an
expression that which does the plus we
have a macro at the average which
returns a division by the sum of all the
arguments divided by the length of the
arguments here the arguments as a list
here and what will happen here is the
length of we calculated compile time but
we're
the average will just become a call to
the plus function to sum them all
together which will be done at runtime
and we could have multiple clauses in in
in macros as well depending on the
structure here so we can find a list
this star macro here this is the common
list of lists our macro yeah and macros
can take any number of arguments okay so
there's one there's only one macro foo
they can take as many arguments if you
want to call with it and at macro
expansion time you can decide how many
how you want to handle a different
number of arguments you can multiple
clauses and we have the backquote macro
which is fantastic because it allows us
to write down what the structure one
problem with Lisp is often you have to
you have to it's you have to you don't
write down the structure you write down
a set of instructions for building forms
for building the instructions with a
back quote macro you can write down the
structure and it will generate the forms
here so for example the the plus the
back quote plus a B here will generate
will generate set of instructions that
builds that list when you run it but I
can write down what I want the list to
look like which is great we don't have
time for the code example on friend talk
afterwards we do that so some ongoing
work here so now if you define a macro
you have to define a macro local to the
module you're compiling it in which
means if you want to share macros you
put them in an include file you include
that file in multi and all the modules
you want so what I'm working now on
which you actually have working is a way
you can define macros in one module and
export them from that module and then
you can call them from another module in
the same ways you call a function call
here so I can call if I forgot the mod
here with a macro can do mod call on
macro that will call that macro compile
time and expand it so I don't I don't
have to do I don't have to include the
macro definitions locally I can still do
if I want of course but I don't have to
so that works that works well now for
compile time I even have a version
working for runtime expansions of the
permit really certain I want to include
that it's it's quite limited but it
works but we'll see where we end up I
have an implementation of risk machine
flavors
that was a precursor to the common lisp
object system and I think this were a
lot more fun than the close one for it
so I haven't I have an implementation of
that I can't you can't even find all of
it because a lot of its a lot of us
various machine specific so you can't do
those bits but I have the basic stuff
there it works they have a lot of cool
properties they've got demons and things
like this you can call various stages
you can mix you can merge the all the
stuff together it's it's quite a lot of
fun actually it's yeah work is being
done on a closure interface I'm not
doing it myself and other guys too
Duncan McGregor's been doing that so we
had to talk between between now and
system running lfv and and a JVM running
closure in a relatively nice way between
them for them as well too
another thing I'm going to start working
on is well destructs that came from the
list machine they they will subsume
records and what they do what they have
is their they have a very versatile
formatting and access way of specifying
formatting and accessing so they won't
just be locked to tuples or tagged
tuples and things like this I can say I
want I want the access functions where
access macros in a module and stuff like
this for them and a lot of control over
that and it will subsume records records
just be a special case of this and also
actually be able to define the alexia
structs from that I think they're quite
easy to find that they're using maps but
the same same idea for it so be able to
find that interface that so this is
stuff that's coming now one feature we
haven't mentioned here we have multi
module file so can define define many
modules in one file if you wanted so the
final question is for you keep me up is
why well I like Lisp that's easy this
was the first high-level language I
learned it's still fantastic I like I
like a line of course I like the ways
how Allen works for the systems I
actually like the language I like to
implement languages I think that's fun
so doing other fields natural
I've got other language implementations
I can were you with later someone if
someone asks and that's about it
that's me yeah this is this is not
nothing really to do with our Lang
solutions so they're not I sort of had
tested support for doing it but it's not
part of the Allen solutions work so
that's sort of my private programming
email address now wordings the tag LFE
iOS is the webpage for it before this
and they github once if we can find the
source code and there's there's a google
group for mailing lists and there's a
tag twitter tag out on this for talking
about that's do we have time for
questions one or two short questions yep
any questions
mr. different well I can do that in a
normal function definition I can say yes
I got the function foo here and if and
if the argument is an is number do this
if it's a structure do that if so let's
do that I can do that that's no that's
that's a problem of the module handling
once I've compiler made the module I
cannot extend or change things that's a
limitation yes I saw that you can do
more than two arguments with a plus does
I mean plus was implemented as a macro
yeah plus as a macro it's very lispy
internally there's a quite a small
number of core forms and a lot of things
in macros everything basically
everything I've shown here is a macro
yeah the thing that makes your
successful I think it's great interrupts
with both JavaScript and JVM so are you
can you call like functions by name yeah
if the LAN codes right but no no any
glue code or no you call the a line
function straight off the a line
functions can call you straight off so
if I want to use OTP behaviors I can
write my behavior modules in LFE and I
just call the functions the same name
the only slightly no it's messy but is
that being a list but you want to use a
hyphen two separate words being in our
language that you have to use underscore
and which doesn't feel that they've been
number of solutions for every other will
work at a good one don't like for that
is that a more interactive way of
exploring Erlangen trying new things is
a more interactive than the standard I
learned the shell is more interactive in
the fact that you can define you can
define functions you can define
functions and macros in the shell and
experimental work within their right
that is as I said you can't get past the
basic properties the Aling system those
who you start compiling things anyway
yeah no worries
actually don't need a tooling in the
sense that they're what I'm calling I'm
calling one from the other when I'm
calling a module from our long I don't
have to know what is written in I just
call it in the same thing going back the
other way there is support in rebar to
for compiling our LFE modules and rebar
3 we'll just need to plug in 4 to do
that so you can run them together do
okay thank you for the questions but we
don't have time for any more of them and
let's thank our speaker ok</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>