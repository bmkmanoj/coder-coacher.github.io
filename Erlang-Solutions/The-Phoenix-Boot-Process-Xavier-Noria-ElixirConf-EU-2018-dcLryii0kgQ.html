<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Phoenix Boot Process - Xavier Noria - ElixirConf EU 2018 | Coder Coacher - Coaching Coders</title><meta content="The Phoenix Boot Process - Xavier Noria - ElixirConf EU 2018 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>The Phoenix Boot Process - Xavier Noria - ElixirConf EU 2018</b></h2><h5 class="post__date">2018-05-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dcLryii0kgQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I was talking with a with a friend of
mine and he asked it what are you going
to talk about in the intercom
France and they said I want to talk
about the Phoenix boot process and she
said and he said that's a classic and he
was right my first talk about about Ruby
on Rails was in 2006 and I explained how
rails boot at the time and as a younger
me right and later I have another talk
about the rail whole rails boots this
one is from 2016 in railsconf the way
race boot changed it in in rails in
rails 3 precisely
josée had a lot of work done there so we
changed it alright so yeah this is
something that I encourage you to to do
just you know do a walk-through and and
you know you're going to learn a lot
from that experience is like a journey
you're right you start opening some
initial file and from there you know go
on and you will go down to how airline
Wharton is it's a journey so you you
when you when you boot Phoenix or when
you boot an airline note you're going to
have more context about what's what just
happened alright and you are also
exposed to idiomatic code
it's a I recommend it is a very nice
experience let me let me explain you
which is the talk the role of the talk
okay let's say we create a new Phoenix
application we create the database
whatever and we run we we launch the
server what happens here that's the wall
of the talk what what's happening here
all right
it's going to to be we're going to see
like a conceptual understanding of what
happens here so the code is not a
walkthrough yeah I'm not going to show
listing after listing you know files
it's not a walkthrough I've read most of
the involve code to prepare the
presentation but the ideas to digest
what I have learned and presented it in
a way that as a finished developer you
like
- - you know to be aware of and there's
going to be some trade-offs because
otherwise the talk could be like very
long for instance we are going to see
that the happy path so you can have
errors in a lot of places and there's
you know logic what happens if this goes
wrong we are not going to cover that
okay so which is the happy path okay
also there are millions of flags that
change how things how things work okay
you can say to mix to be silent for
instance and then there's code that says
if we've been told to be silent then we
have to do the you know this branch of
code you know so we are going to
simplify some of those things all right
okay so let's go with OTP applications
so when you learn alex ero airline you
start learning the the programming
language and then soon you realize that
there's there's like a layer on top of
that call it OTP okay the the normal
path - OTP is through Jen server and
supervisor do you know some modules
right but OTP is much more than that
module collection there's also a set of
design principles that tell you how to
organize like you know an underlined
note how to organize you know a set of
components that are building your
application in the in the traditional
you know big sense of the word so
application in Aaron and Alex ear is a
technical word okay in the rest of the
you know in general in programming
languages we have the concept of an
application which is an you know an
informal concept but in Erlang and in
alexia whenever you read application in
documentation or books whatever normally
that's a technical word for doing that
short for OTP application is very a very
specific meaning of the word application
and to to learn how these design
principles are set up there's the this
section of the of the airline manual and
also I find this book to be excellent it
covers a lot of ground about about
working with with with airline in this
case it's not for Alex here but you can
translate easily to Alex here
the majority of the things it covers a
lot of how to work you know without to
be with a lot of perspective and you
know production knowledge and everything
excellent book alright so what's an OTP
application and the concept of OTP
application is is central to understand
how things boot so we are going to go a
little bit into what is an all TP
application to you know to have that
very very very very clear alright so if
if you do not know what's an OTP
application the first thing you have to
know is is that it is what in other
programming languages we have as library
okay is it like the concept of library
but it has more meaning added to the
concept of library in in other primary
languages the concept of library is kind
of lightweight right for instance in
Ruby you have something packets as a
library and normally the contract the
entry point for that library is requires
something and that's the end of the
contract
all right and then it's one of those
libraries when you require the library
they do the own thing
okay this is much more standardized it
in in in Erlang and Alex you so it
standards standardized sorry the file as
a certain file structure the
standardized configuration also how they
boot how the processes are structured
and how they shoot down okay we are
going to see this now except maybe for
shoot down because we are concentrating
on on starting up alright
file structure in air long project
has a you know a certain conventional
directories and etc but we are not going
to see it because in Alex's we normally
work with mix mix has its own you know
thing do you know it so for for DB
Lomond the structure for development
let's say we we are using mix and that's
it for Alex here the the file structure
that you deploy is common to Erlang and
Alexia so in Aaron and Alex here you
will have this even directory with which
has you know the compiled files trip
with some assets and stuff and then
consolidated is a specific to Alex ear
it stores consolidated protocols so
console eight except for consolidated
which is an elixir thing even impress
that the directories then you normally
deploy alright applications are
described it in in something called the
application resource file the
application resource file is is a text
file that contains an airline term so
this is airline notation because that
that's how the file looks it's an
airline term
alright so there's a couple the first
thing is application engaged in case you
do not know airline that's an atom okay
in Erlang in l exceed atoms start with :
at least you know the conventional
syntax in in airline they do not have a
column if the word starts with lowercase
that's an atom okay so application
description ID those are atoms right and
the words in in uppercase there are
variables and in this in this case they
mean so this key has some value and the
value is just a placeholder right this
is the application resource file and
describes it has metadata about the OTP
application so you have here application
that's the the first of the uppercase
application has the name of the
application you can have a description
and in the version modules is a list of
the modules include in the application
which is normally filled by Bill tools
max T is a is a is a threshold in
milliseconds you can say I want this
application to run at most for this
number of milliseconds register it is
for four named processes include
applications is it's a collection of
applications that you need to coordinate
how to start something that's the idea
is not related to umbrellas applications
basically means dependencies M is a very
important key M means environment and
that's another overload word in Erlang
and Alex it so applications have the
concept of environment variable or the
environment and that's not the operating
system in vitamin A vitamin variable
okay it means one so the applications
have their own environment which means
some key values that you can you can put
here and in other places and if you rate
environment variable do not think about
the operating system normally normally
you are talking about this environment
all right not is a module that is
optional and it's called the application
Kovach module we are going to see it now
the starfishes has to do with include
applications and runtime dependencies I
believe is not used in Alexia all right
this is this is the application resource
file of actor or a set of it right so
actor as any library that you ship or
conventional or idiomatic ships as an
OTP application has a resource file this
is a subset of it
okay this is the all of those keys are
optional
all of them have default values so this
is the minimal resource file that you
can have all right this is a ballot
resource file and it is very handy if
you want to tinker about the behavior of
how this is processed so it's very easy
to drive to write this file by hand and
then you are I don't know modules and
tweak modules if they exist if they do
not exist how this behaves you know very
busy to tinker so this is all of the
keys have optional so they have default
values and this is the minimal resource
file that you can have all right
applications are managed by two modules
while its application lower case is the
airlin module for managing applications
and application with upper case is the
corresponding one in Aleks ear through
thought the application module in Aleks
ear delegates the majority of the world
of the work through the application
module written in Erlang that's where
the things happen actually so it's a
thin layer at a little some things but
the main work is done by the application
module in Erlang when Erlang boots
creates a process call it the
application controller his name in that
way and there's a module collet
application controller that has
implementation of application controller
so the application the application
module most most of the of the api of
this module is just a wrapper to the
application controller alright so this
is like the public the public API but
the actual word is that clockwork is
implemented in application controller
which is kind of a gen server
technically it does not declare it does
not implement the behavior but the you
read it is is practically just a surgeon
server alright so we have applications
resource file they are managed by the
module and application module delegates
most of the world to this this is a this
is a single tone this is just a process
that is launched when air long boots all
right so no we are going to define what
means to load an application there is
some jargon here right we have the
resource file applications can be load
applications can be started and can be
stopped all right we are going to
introduce this what does it mean to load
an application easy all right
loading an application means loading the
application resource file which is the
file that we that we saw before and this
is done by the application controller so
if you say load do you see the cursor
yeah so just if you say load this
application the application control is
going to look for the application
resource file in the code path
conventionally the application resource
file is in the even directory but
technically it can be anywhere in the
code path indeed if you want to tinker
as as I said before you can just throw
in your current directory two or three
up you know resource files and unload
them and do whatever you want because
that's the technically just condition
that is in the Copan then this is
important we have to remember this key M
with the environment you load the
environment from the resource file but
then you are able to overwrite some of
these keys and in particular you can
pass to the airline shell an option
which is config that allows you to put
you know to pass a configuration file
where you can overwrite the keys that
are present in the resource file and
this is relevant for releases releases
delete do this we are not going to see
releases but that's important for
religious in particular
and after that you still can overwrite
even this thing with passing passing
environment variables in the sense of
OTP in the in the in the common line you
know as when when you call the airline
shell and this is known for include
application so these precursors and
loads everything
this is synchronous alright so when you
want to load an application you do the
call when the call returns everything is
load you will see I've seen this at
least in a couple of books this is a
myth loading an application loads its
modules so remember this there's a list
of modules in the resource file ok well
this is not true
it they are not low that I I've read the
the source code is not done and and you
can test it in the console you can load
X unit you ask if the X unit is low that
is not loaded
ok so in case you see it you know out
there
loading application does not load the
modules all right so we have the
resource file we have the concept of
loading an application and now we are
going to see what is starting an
application which we are we are getting
closer and closer to the boot process
the start in an application means the
following you load the application which
which is what we just saw you know that
if needed ok if it was loaded already
fine otherwise we are going to load it
and we check the dependencies so there's
that applications key that lists the
dependencies of this application if one
of them has not been started already
this returns an error done there's
nothing it's an error condition right
one of the one of the the fields that we
are going to see in the in the
presentation all right then if if you
are able to load and the dependencies
are all fine they are all started
what happens next depends on whether you
have a callback module or not which is
the mod key the mod key can be missing
in that case there's no mod module if
the mode key is present do you have a
mod model II the application callback
module okay and in Phoenix you have an
application code module but this is not
required so if there is no application
callback module we just return okay and
done all right
the application code module M is is a
implements technically is not needed but
normally you implement the application
behavior and you have two required
callbacks and two other optional
callbacks the most important for for
what we are seeing here is the star
colvett okay so when the application is
so this is this is a module that has a
star callback and the star callback can
do whatever you want is going to be
called can do whatever you want but it
has to start and link a supervisor and
it has to return the pit of the
supervisor to the caller
alright that's that's the key contract
that has to be satisfied by this
callback he can do other things but
that's required it has to start the
supervisor and return the pit of the
supervisor all right so what happens we
said if there is no callback module done
but if there is a Kovach module we have
more work to do so now the application
controller starts a process called the
application master this application
master does these things traps exits
becomes the group leader the globe
leader is something related to IO but in
this case the globe leader is just a way
to easily identify all the processes
that belong to an application because
there's API to say
which is my group leader and the group
leader is going to return the
application master so it's just
technical thing a io is actually
forwarded to whatever was the group
leader before the application master was
was spawned then once we do this we
invoke that callback that we saw before
the star callback then the application
master stores the Fraternal Pete which
is the it has to be the pit of the
supervisor and enters the main loop done
it's listening for for exit messages and
that kind of thing so that's done okay
we have the application master
everything is a spawn okay when you
launch the observer the application
master of an application is that is that
process there to the left okay so that
process is managing this application
with is the chat application is that the
chat application is the one that we are
using to study this all right
and if you if you click on the different
applications in the sidebar you will see
that all of them have this process
anonymous to the left but they are all
going to be different because the
plication master is different for it
it's one dedicated for its application
all right so that's that's application
master as a curiosity this second guy
here is is is internally quality process
X and it's it it's an implementation
detail but it but it leaks into the
observer you see it okay so conceptually
you have duplication master link it to
the supervisor that the top supervisors
application ok conceptually you have the
link but due to technical reasons that
are explained it in comments in the
source code there has to be an
indirection through these processes but
its implementation ok so this process is
also synchronous ok so starting when
when you get the prompt back if you are
in the shell everything is done okay in
particularly if you start the supervisor
well you have to if you are using on
Kovach module and then that cause
sterling that maybe call so another
sterling that has an init function to
call you know all all that three of
calls happens synchronously all right
another miss starting application lotus
module it's not the case all right you
can see this also in documentation or
books is not the case the the mode the
modules are not loaded when the
application is has started loading
modules is something totally orthogonal
to this basically you have two ways to
load modules in in Ireland and in
Aleksey you can you can you can run the
bin in two modes interactive or embedded
mode they are called ok if you are
interactive mode which is normally the
mode you run in development modules are
loaded on demand so there's an auto
loading mechanism that when you first
want to call a function in a module and
that module is not is not loaded then
there's code that catches that goals
load the module and everything is fine
loads into the beam calls the function
and it's transparent for you in embed
mode this is disabled and everything is
load when when when the node boots in
something called the boot script it's
like everything is eager load before the
applications are start and you know the
modules are just the binaries and in the
beam right so it has nothing to do with
loading or starting applications and you
can also test this you can here we are
starting again X unit and a unique case
is loaded it's not loaded alright ok if
you want more information about this
this source code
I find it relatively easy to read all
right this is the application which is
the interface the application controller
which is the one that knows what to do
it has all this logic and then the
application master which is the one that
spawns the application you know all
right
an intermission here
we have seen that there are applications
that have a callback module like Phoenix
applications do and other applications
that do not have a callback module the
callback module is optional so the OTP
application you know has a way to
package things has this concept of
loading starting and in the case if you
have a callback module some things
happen if you don't have it some other
things happen all right but there's no
official terminology for distinguishing
which is which so in some books you will
see that they called the ones with the
callback module normal applications or
regular applications and the ones that
do not have a callback module library
applications but as far as I know
this is not like well-established right
and for instance in documentation you
normally don't see it used but I have
the personal perception that there's a
missing name here there's a missing name
you do not have words to clearly refer
to applications that have a callback
module and plications that do not have a
callback module and this leaks in my
experience this leaks for instance this
is from the elected official
documentation they're starting an
application is done via the application
module callback mmm not true if it is if
it if it has a module Kovach but if it
if it doesn't have then as a user you
you are left wondering well if I know
that it does not require so what does it
mean to start an application without a
callback module this is this is saying
that does not mean that applications
without a kobold module are not started
you gonna know all right the answer is
that they are started okay so the answer
is the starting of application means
what we have seen it means if it has a
callback module we do this
but if it doesn't us us still have
define it what means to start an
application this is from the
documentation of a well-known airline
library like all OTP applications the
name of the library has a top supervisor
again this is an abuse of language not
all OTP applications have as a top level
supervisor so it is like we we are
missing a word to be able to express
ourselves with with precisely you know
and this that's very important in
documentation especially but also in
everyday life you know true to
communicate and you know be precise
about it another another one we have
here in the observer the application tab
right application stub and we have the
applications in the sidebar
but again abuse abusive language because
there are a ton of applications that are
missing here so if if you were thinking
that those are the applications that
were started with your finis
applications wrong there's a ton of them
that are not there why because that
application stopped in really in
realities
thus provides three twists or
applications that have a callback module
you know we are missing a name here that
isn't that doesn't fit in a tab name
right so just be aware of that often
times you read assertions about about
applications that involve these kind of
things and in reality what the writer
had in mind is applications with our
witness supervisor all right all right
so how is how is this related to Phoenix
I know we have we have explored the
concept of OTP application it's kind of
formal all right
look at the resource file we have the
notion of loading we have the notion of
starting but how is this related to
Phoenix I don't know I do a Phoenix new
it will Phoenix test that what what what
is the relationship with Phoenix so this
is very key mix projects manage OTP
applications so you can be you can be
very productive in Alex here I believe
using mix and and and do not fully
realize that in the end everything is an
OTP application behind the scenes
because mix gives you a very convenient
interface to manage your project and
many of these things are just automated
for you ok but in order to understand
how things start we have to to make this
very clear
mix projects manage OTP applications
either one of its an umbrella it can be
several alright so in a mixed project
you have this project function you have
this application function so let's do a
link here application here means
technically OTP application alright
and this disc is a PP version mode
alright this kiss map to the resource
file these are the keys of the resource
file alright some of them are in
projects some of them are in application
and some of the keys that are allowed do
not end up here but basically the keys
that you have there map to this thing
alright the description the version is
called BSN here ok so there's a
tradition of the key but there's a
mapping alright and you may say I have
never written this but what what's going
on well it's it's generated by mix for
you so for a chat application you will
see a chat dot a PP file in your evening
directory all right and an application
call it foo is going to have food dot a
PP somewhere in the code path
conventionally in the even directory of
that application so it's there right and
it's generated by this task mix compile
dot a PP that is include in the series
of compilers that mix runs alright so
this is the this is also the application
callback module of Phoenix application
you will recognize this right is where
you you declare the repo you declare the
endpoint this file is the application
callback module of your OTP application
note that but at the end you will start
supervisor which is the contract of this
callback all right so we have that mix
projects manage all T publications and
Phoenix projects are mixed projects so
if we apply modus ponens to these two
premises we get that Phoenix projects
manage all TP applications all right so
that's super key to understand this
presentation we are a Phoenix a Phoenix
project is managing and managing an OTP
application and that's wonderful I mean
the Phoenix is not a special in that
sense finish is just you know as regular
citizen of the airline ecosystem
everything is idiomatic everything is
packaged and and you know and manage the
the way you are supposed to behave in an
OTP context all right Ruby on Rails in
this in this sense is very different
because Ruby does not have OTP Ruby does
not have these conventions if you if you
have a library that that spawns threads
or whatever you are on your own
there's no conventions okay the only
conventions is you require so
Raley's has had to invent his own boot
process and that's not a standard
because there's no standard disease or
the decision of that in in Ruby but in
airline you have this define at all
awesome just do this alright okay
no we are going to see mix run so the
objective is to is to understand what
Phoenix server does but before that
we're going to see mix room mix runny
belief is bronze okay Iran is the
default mix talks by default so this is
the default task but you can override
the default in the project okay
but normally that's that's run and you
are used to use this code to to launch
this comment for instance the
Alekseevich L minus s mix that's since
run is the default what that is running
normally is the run task okay so this we
are running this constantly okay the run
task is very important because the run
task is is the one that properly starts
your OTP application so we mix we are
managing managing OTP applications run
is the one that starts the application
alright so we are connecting the dots we
have the concept of starting an
application mix manages ot publication
mix run is the one that starts your
application it does more things but
that's the the main the main feature of
this task all right well we let's
analyze this since we we want to
understand what what's happening first
we put mix because mix is an executive
executable and when that executable is
is in bakit so
thing happens right then we have in
addition to that the run task itself the
mix executable is just analytic see the
script alright so the first thing that
that we do is to launch the to launch
the beam okay we know that that you know
everything runs on the beam so that the
path from mix to the beam is exactly
that mix is run by Alex ear and Alex
here is a is a Neverland program all
right so you launch the airline shell to
run Alex seed which is going to run mix
okay this is super interesting and it's
very relevant in in releases but in the
case of of using mix which is going to
be the content of the presentation
there's there's not too much to say
about it so we are going to to jump over
it just just realize that we are
launching the beam at this point all
right then so we have launched the the
beam and then we are going to to invoke
mix a start mixer start is a regular
function function it's not a callback
okay and the only thing that it does is
use this API to be able to start your
application but remember to start the
application you need to have all the
dependencies started before you okay so
this is an API that basically says
please start whatever you have to start
and start anistar me all right so this
is this is a starting the mixed
application itself so mix is an all T
publication everything is all TP
applications all right and the the
dependencies here are just Colonel
standard leap and Alec seed itself so
this is this is unrelated to the
feelings application is just the mix
application you see the argument there
mix it means a starter mix which is very
small
Alex here makes a start the next call is
mix CLI main and know things start
happening alright as I said we are going
to see a subset of the things that I
believe were the most important things
or the things that I would like to know
as a Phoenix primer that are happening
right
so if present we are loading this this
config file you know in the in the mix
home normally is not present then we
load the mix file itself then we set the
mix environment that is going to check
the vitamin variable whatever in in this
case the operating system environment
variable we load the configuration in
conflict slash config dot exs at this
point we know which is the environment
so in the configuration you normally
have at the bottom load in addition to
this to what is in this file load the
one that corresponds the environment
okay so the Byram is already set the
configuration is is loaded early and
this is important and we are going to
see later how it does this plays a role
all right so this is mix CLI main and
the last the last bullet is running the
task itself alright so mix tasks run is
a generic this run is not the same run
of the task this run is is a function
that runs tasks so in this case the run
is going to be the name that you pass a
first our woman alright and know what
mix run does it adjusts the code path do
you know to have the coke path according
to the project checks the project
dependencies you know if you have
declarative dependency and you didn't
run the task to fetch it or whatever is
going to complain all right you can you
disable these and I believe all of them
have flags and everything but just to
keep it simple
that's what normally happens then you
run the compilers so if there's anything
that has to be compiled it's going to be
compiled protocols are consolidated and
then starts the application and all the
dependencies so if you are running if
you are in a mixed project you don't
need to worry about starting the
dependencies in order of that kind of
thing so mix takes care of it you just
launch the application is going to
launch the dependencies as needed done
if if we one is going to preload modules
that's false by default and if no halt
is passed is going to sleep and just be
there all right
as I said you can disable checking the
dependencies you can disable
compiling and those are flux that you
run but by default that happens all
right
there's this flag in the Erlang shell
that allows you to see process well not
not the steps that I like not config
loading the config that kind of thing
but with this flag you're going to see a
report showing all the applications that
have been started all the supervisors
that have been started
all the workers the child specs all
right so that's a you can you can see
there what's happening sweetie flip on
this is another flag in Aleks see the
the outcome is a little bit different
and these are the application that I
started with a Phoenix application we
are not going to see them just as a
reference and if we share the slides we
will have them right Coco is the web
server
you know act Oh pool boy is the is a is
a is a pool manager that actor uses
well Phoenix is broken in a number of
multiplications Phoenix pops up Phoenix
HTML etc the written in Erlang is
written in Alex year Alex series in both
them because Alex is written in both
languages library applications these
applications do not have supervision
tree node for instance that we have here
pool boy for instance it doesn't have a
supervision tree regular applications
I used the word regular here these ones
have a supervision tree okay we start
this the supervision the provider starts
and the supervisor has to start the
children the children the repo and the
endpoint so quickly these when you when
you refer those those two these two okay
these things are started from left to
right all right so the repo is declared
this way when you the the using macro
for actual repo those a number of things
relevant for this talk there's a
tireless Peck generated that says I am a
supervisor and this init callback so
when when you start link this module
there's going to be a number of jams and
eventually this Kovac is going to be
called and you have an opportunity to
change a little bit the configuration in
this case and this is generated you can
the URL for the database used operating
system environment variable right so
this this you know start the the port
and this is the part of the tree of your
of your chat application that that
represents the repo okay
oh so process is there on the right is
those are the connection connection pool
those are connections established to the
database from the repo to the repo pool
there's just one line
you see their Alexeev chat Alexeev chat
repo you could think that this is close
this is far away in the source code so
I've counted like 15 15 jumps you know
in four different libraries from the
point that you start the repo to where
the pool is is in the end created and
the name you know assign it who is then
if if we are so deep how do we have the
name related to the chat application
because the name is or whatever has to
be used to build the name is passed in
in this in this series of calls right so
you know the diagram does not reflect
and it doesn't need to reflect the
implementation in that sense all right
then the end point I am finishing yes
okay so just to hear that you see if
code reloading declare some plugs this
is at the module level so this is
happening at compile time and this is
where having the correction law that
before we compile like roll because the
compiler remember the compiler exit or
so the compiler is doing the same thing
as the as the Alexia Commandos the
difference is that one emits beam files
and the other one doesn't
okay but Alex sees see a Baloo is the
code so why that's why you can put a
conditional in the body of module so
since the configuration is already
loaded at compile time and this applies
to this this file and applies to your
own files a compile time you can check
configuration if you need to right if
you have the files compiled and you
change the configuration Alex it knows
that it has to recompile right okay this
is the pub so layer in the in the tree
but we have no connections to the you
know what no no no web connections here
and the application does not have it
ranch is the is
allocation that Kobo uses to receive
connections it's mostly empty cowboy
itself is morally antique where are the
connections okay to have the connections
you have to launch a server so you have
the DB connections you have them but
there's nothing there's no one listening
for HTTP requests and that's beautiful
because we have seen what run does well
launch in the server is is use is
running the run task the one that we
have seen with the only difference that
before launch it the tasks there's a
configuration key set that's the only
difference is beautiful right so used
you change this configuration and this
serve endpoints and if certain endpoints
is is a set the run task the scope if we
are if we have this set then we have to
launch the server and is this part of
the of the tree that you see here III
said this is the there's a pool also to
to handle the connections not the
incoming it's call it the acceptor pool
in the jargon of of range which is the
library and I set it to 10 just for the
slide but the default is 100 so you are
going to to to see a huge column here if
the some you know the most move and
things to know happening Oh ton of other
things that happen but most most
important things to highlight them we
load them the mix file set the
environment and all the configuration at
that point early before compiling then
start all the applications that in
proportion this should be like a huge
bullet right but this is fixed with
phone I can do that
and the connection pull the pops on
layer and launch kowai kowai this is
done in this order just because in the
in the application
Kovach module we have defined the
children in that order you can you can
also insert your own things there and if
you change the order that's going to be
reflected in the way these boots because
it goes left to right all right okay
that's it thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>