<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>My Little Pony - Darach Ennis, Sylvan Clebsch | Coder Coacher - Coaching Coders</title><meta content="My Little Pony - Darach Ennis, Sylvan Clebsch - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>My Little Pony - Darach Ennis, Sylvan Clebsch</b></h2><h5 class="post__date">2015-11-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/0UkTnsXlZsc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone thanks very much for coming
especially since Roland is giving a NACA
talk right now over there so I'm really
happy that anyone showed up at all this
is a new experience for me in the Donna
is a pony user and he's giving the talk
and this is the first time someone who
isn't part of the pony development team
that I know of has given a talk on pony
which is pretty exciting on the other
hand he made the slides and showed him
to me and then I was like great these
are wonderful and now he's changed them
all and refuses to show them to me so
what's gonna happen next I have
absolutely no idea
basically dars gonna run the show and if
you have questions I'm happy to answer
them or if Dyer wants to answer them
that's great too I don't know if he's
gonna make me talk about specific stuff
and have you got tone hello and welcome
to his show that I'm giving so apart
from pony being an actor language skip
that ponies all about wombats so as
you're gonna get to know this talk
before this becomes natural to you
ponies all about denial as a capability
so we need to get used to contrary and
logic it becomes normal after a couple
of months of using Pony and three
one-hour sessions were Sylvan that
lasted about eight hours and we both got
in trouble for getting home late we just
had this talk basically I got
constructed so I'm the I'm the Padawan
Pony so I'm the learner I'm just a geek
Phillips Pony and this is this is Sylvan
he is the pony master the uber wombat so
the the brains behind this wonderful
language and for those of you that don't
know this is research as a head of
Imperial College in London so this is a
London or West London based technology
so that's pretty awesome to have at a
London conference so let's let's have a
look a fairly interesting agenda for
this because Pony is such a an
interesting collection of things that
there's just like 10 different talks we
can have a little language but we only
have time for one
so we're gonna fit in three so when we
do the basics of the language do you get
comfortable with the syntax it's it's
exactly like Erlang it's a really nice
syntax based on Fortran then we're gonna
do some benchmarking we're gonna do some
benchmarking because everyone knows
benchmarking right especially micro
benchmarking we've got many experts in
the audience when people say to some
people they don't then we're going to
cruise the actor model which is why
we're here so this is the the newest
actor model in the pantheon of actor
models that have been done we've got the
most successful actor model we got Joe
here and we've got the newest actor
model from Sylvan here so that's that's
rather prescient
ponys a bit weird in that it's a
compiler oriented letter crush
technology only it lets it crash a
compile-time thereby proving it can't
crash at runtime this had the strange
effect that at runtime we do actually
have errors but it's okay they're not
like errors in Java they're cheap
because cheap is good and cheap runs
fast there are no runtime exceptions and
poney but now I'm jumping ahead of the
slides now to confuse him because it
makes me happy but I'm Pony still just
the language your legs actually a system
it's not just a language so Pony OTP is
like the kind of pony that Joe might
want to use because we don't was already
fiddling he's like user number what 0.8
and then I go through pony promises
who's the owner of futures are bad so
we're gonna tell you what's around the
corner and Pony based on some of the
activity that's passed or happened over
the past couple of weeks some of which
may be our fault your a fault or we
don't know what kind of happened
together and then we'd have a QA okay so
let's get to the basics
how many folk here are Erlang
programmers or reasonably familiar with
their allowing there are other languages
like the imperative ones
we have three honest people in the
audience this is great
so pony has variables it has two types
of variables variables that Jo's like to
have single assignments and so they're
very easy to manage and think about we
have kind of variables that are like the
imperative variables that you can mutate
and don't understand
honi allows you to have a choice so it
gives you both and we use the same
syntax and fields w's in in classes I
just got that wrong so if you want to
make a variable private you add an
underscore that's very very nice
reasonable syntax they're typed so you
can define a type int your variable so
this is the billion this is a 64-bit
signed integer very simple let's move on
and we have expressions so say given
given three variables a B and C values
one two and three so if you have a plus
B times C and anyone tell me what they
we can't actually see the hints in here
just terrible but I'll remember is this
going to give me seven or nine a plus B
times C come on so simple who's there
who are the mathematicians in the
audience hands up okay we have four
fearless mathematicians what's the
answer to this question
don't tell them computer scientists
who thinks it's seven who thinks it's
nine who isn't sure at least two people
are correct so it can't be seven and a
can be nine depending what's the problem
here what can't we see in this code what
is the syntax missing precedence in most
languages precedent says done for you in
other words you don't know which one
they picked in Poli you have to provide
the precedence it's always correct by
the way in small talk that's nine
because reasons so we've barely glanced
at the surface of pony and already
realized this is something just a little
bit different so what about widening
conversions who loves them heart full
audience yes there's none of that Pony
either you have to explicitly explicitly
cast none of this will guess for you
because we'll guess wrong so Pony is
safe you have to make a choice it's
really very simple and we don't like
statements statements are evil in Pony
statements or expressions so all
statements return the value it's very
simple other statements know their
expressions the statements return a
value it's very simple so for example if
we wanted to assign a value to X here
which is a single assignment then we can
you know totally do that conditionally
if that was something we needed to do
which is very handy so if we could have
a fur loop yes it also returns an answer
whose one answer does this one return
and I know Tommy it's a going through a
range of numbers between 1 and 10 it's
10x it's kind of Mac's exclusive so what
are the value returned by this fur loop
I don't want to stop a guess at 7 or 9
yeah it's that's hard to read sorry bad
thing well that's going from one to ten
max exclusive seven is irrelevant right
returns nine okay very simple very
consistent okay errors must be handled
okay it's let it crash but the compiler
does that which means when it and if it
does crash we have knowledge of where
we'll crash so you can actually handle
it safely that's kind of a bit weird if
you used to writing Erlang where
anything can happen we just ignore it
because we let it crash right you can
you can you can actually handle it
reasonably in Pony and because there's
no wrong time exceptions and it's in
that did crash you don't have access to
so you can only act on an error based on
what happened before that didn't crash
so even your exceptions are safe and
fast that's kind of Awesome a number a
way you can handle exceptions so
anything in in Pony that where you can't
wrap an error is kind of an else loop so
we can we can we can compensate by
printing some statement or sending a
message somewhere we can actually
propagate the error if you propagate the
error the function syntax or an actor
behavior you have to say I actually
return an error I may not complete I'm
partial so we use a question mark to
signify that it's it's not here so this
actually won't compile remember the
compiler says no so even if you think
the code is reasonable it knows you're
unreasonable it won't compile for you
but will force you to go through again
okay or we can swallow the exception I
don't care in that case it's its handle
because we didn't care it's gone
yeah sorry about this the screen doesn't
agree with you you know there's no
editor I'm not gonna try a quick
accurate because there's no that'll work
how do I do that thank you rob ugly is
better than non readable so the man
invert colors sweet way hey readable and
the first post part talk and the first
post talk point goes to rob thank you
very much I'm glad I met you the other
night Swain or your name so we could
just swallow the exception yeah let's
back up back to here so here you can see
all right that's two hey but you know
the answer is now it's not as funny okay
so we go very well you have let which
are single assignment just like a skip
okay Joe gets annoyed skip yeah okay
widening awesome state with their
expressions we're all good okay
errors must be handled okay there's four
different types of this we can handle it
consume it now propagate the air because
we're happy we can handle it and
propagate the air because we're
definitely not happy we don't know why
we're not happy because when the error
occurred whatever calls the error means
it's unsafe so why would you want to
propagate that space on something that
we don't know what we don't know about
we know was erroneous we don't know why
and so we just yeah there was an error
deal with it we don't have to deal with
it we're sort of passing it on it's very
simple that's that's that's that's the
complexity of error handling in Tony
it's pretty simple and then we have the
third case is if something does happen I
still don't care so if something going
on happens we know that we don't care so
just ignore it it's very simple now when
we propagate you can see we've added a
question mark so this means I'm partial
I may or may not fail you deal with it
no I don't care you may care but I
certainly don't so it's very very simple
oh we have Erlang style pattern matching
design we know what this is he's not a
functional programmer now there were
three admitted imperative programmers
here can you help us out here this is is
imperative syntax like if then else
if then else it's horrible it's
illegible it can't possibly understand
what this stuff does it's also extremely
verbose I mean I don't know what this
does anyone understand this
yeah the pre imperative programmers not
everyone else they've already figured it
out this was pretty obvious this is
pretty cool so we have pattern matching
syntax so you can see were doing a match
we're creating a topple of a and B as we
have topples where a is greater than B
so we have guard expressions and then
we can return the value because it's a
statement which is an expression a
statement
I met expression if something else
happens I wouldn't cover our clauses we
have a default get-out-of-jail-free card
and we can do something else
so however matching is a it's extremely
simple we also have wild cards so if you
don't care what this value happens to be
we can also handle that case it's
exactly the same as in the airline case
underscore means I don't care where it
gets interesting is we also have atoms
but atoms in a pony are a little bit
different so we call them primitives so
we have primitive red green and blue if
you're an airline programmer you can
think of this as an atom the difference
really is the algebraic type system that
allows us to get a little bit more
structured so we can say red green pure
atoms but color is the set of red green
or blue atoms you can pick one which is
pretty nuts so we can create couples of
these or we can union them and we can
you know have an optional use as well
where we can go it may be a string or it
might be not a straight so pick either
this is pretty cool so for example in
this case we have the map from the
standard library and the key for example
is hashable or it's comparable okay so
that should be fairly obvious so that's
that's okay and then this this map is a
hash map so it's hashing on equality
based on on the key fairly simple right
so we can D structure at opal just like
an airline so in this case we've got a
couple which is a type string color and
we can construct it in the usual way
using parentheses we can have member
access and we can of course see
structure and pull out the individual
values make sense that's pretty simple
it's like totally alright it was the
same funky syntax it's awesome
well framer is a little bit different we
can also for example package functions
inside of primitives so if you don't
have money anywhere good for a utility
function to go we can actually stick
inside a primitive so further you three
imperative programmers that means you
can have things like mono States or
utility or helper classes
it doesn't actually create anything or
it doesn't require any staging of itself
it's just a useful place a sickle only
function so I can stay with a slowly
functions that are yeah related to the
same kind of thing you want to do are
utilities and stuff like that we're also
used to represent the built-in types
okay we have traits so there's a nominal
typing so if you want to describe things
in the usual way and again this
imperative language people this is for
you so you can do all of that good stuff
so this is traits and make sense as in
these Scala sense we have interfaces and
unlike interfaces for the imperative
folk these are structural subtypes so
for example in the standard library we
have a definition of a real number and
we have this function add so if we have
an add function that conforms to the
same basic structure then we can use
this too for example in a pair we
overload add and we can use plus to add
pairs so that's all built-ins so we've
got operator overloading and we've got
structural subtyping which is using
operator overloading so if it conforms
to the shape you're good to go
this is fairly useful if you want to be
flexible if you want to be inflexible
you can use traits if you want to
enforce some discipline over how the
categories are composed in your system
which is which is very very flexible and
powerful to have both and use which one
as you need it we have classes too
slight difference here there is no
multiple inheritance from the extension
perspective so there's only one line of
inheritance which is from something
that's either an interface or a trait or
some algebraic type composition of those
things which again leads to a very fine
drain of control very simple sign so
nothing you haven't seen before
ok so here we have a class wombat
wombat has a name the name can be
initialized once and only once in the
constructor or by default for example in
hunger level were defaulting hunger
level to zero okay so we have
constructors so you can have as many
constructors as you want you use the new
keyword to create a new constructor
that's basically it they don't have to
have any specific name if you call it
create you don't actually have to use
the dart create syntax to call it a
constructor you just invoke a new type
by using the type name so we'll have an
example of that in a second okay so for
example we have a wombat which is a
class that's using a nominal type called
named and its name is seventh by default
that make sense no it's name is so we
have a function so you use the phone
keywords say I'm a function so this is
something just old okay so we have a
function and functions returning a
hunger level it's a type on sign 64 and
we can set a hunger again defaulting the
argument coming in now where it gets
interesting is this assignment it's not
really an assignment at all
so in most languages when you assign
something you assign the value on the
right to the value on the left and we're
all good in Pony when you assign the
value on the right to the value on the
left and you chain it to the value
further to the left it gets the value
that was in the value in the middle
before you put the value in the right
into it so the value on the left now has
the old type or the old value so we've
done swap without a temporary variable
bigger than that kind of change along
it's a destructor free what you return
is the old value make sense
ah are there any precedence issues here
we even optimized that the brackets
where they're not needed no because it
makes sense so native integration who's
ever done native integration with J&amp;amp;I or
Neffs or bifs and Erlang it's it's
awesome isn't it it just works so native
integration no it's just as easy and
Pony and Pony we use and twitter-like
syntax so if you put an ass in front of
a function what you mean is can you call
in this case s printf and it goes oh
yeah that's in standard i/o here how
about on that it's kind of pretty cool
your integrated that's it so I might
have an actor able to go hey I want to
go to the other direction can I send
this over to seal and yeah sure just you
know tweet it over from the other side
of the language battery sounds like
Twitter Twitter integration yeah but
finally we found something useful to do
with Twitter
so yes pony actually uses a capi
underneath so a valid pony programs also
a valid C program so just works it's
awesome and this generates a really
large library to integrate against it's
very complicated to penetrate so this
very simple one line of code has mainly
boilerplate on one or two lines of
useful code and this massive 97 line
header file it of course will be very
difficult to integrate into your native
programs that's pretty cool okay there's
so much more we can covert about the
basic language but we're here to talk
about actors not the awesome expression
language the statements that are
expression and everything like that so
we could have covered generics and we
have object literals and lambdas which
means we have higher-order functions a
lot of the sugar for example don't
create and I want you both the things
that Achatz but we're gonna start there
and move to something a little bit more
interesting we're gonna go straight to
micro benchmark you can see how much
sylvan has been lying to us about the
awesomeness of this fast safe and cheap
language like a web we're all scientists
or mathematicians or engineers here so
we all start from a point of distrust so
he's lying so what better place to start
than Fibonacci which starts with a lie
right Wow make sense well what else you
gonna choose we kind of use a Golden
Spiral it's just not as funny so here's
imperative that there's only three
people in the audience that understand
this
so let's skip it it's not pretty very
interesting it could be fast but that's
that's part let's write some tests and
find out here's a non tail recursive
version that's more Erlang style terms
of pattern matching so we reuse that
yeah I automatically understand what
this means I don't have to decrypt it
anymore it's just perfectly makes sense
right so if I have Pibbs ero well 5000
so there you go return get out of here
we're done if I have fit one well yeah
get out of here we're done otherwise
let's fit awesome it's so simple and
then we have the tail recursive style so
you see an underscore for a variable
makes a private well if you have
underscore in front of a function name
it's now private too so so Feb it will
be called if f is nonzero
there you go that's the tail recursive
form the same function so can anyone
guess as to relative to each other of
which one is faster which one's slower
so who thinks your parrot of style
because you know JVM is awesome C is
awesome
will that be faster or slower than the
non tail recursive rows detailed
recursive form anyone has her to take a
guess animal the Java version be faster
than the C version or
I'm not expecting you to write the code
I've already done that we have slides so
we just move forward okay cool it's your
conference so here we go
so I implemented these Street functions
in Pony and seeing in Java and Erlang so
we notice that for nom table for the non
tail-recursive forum we were skipping
imperative by the way you'll see why in
a minute and we call that no is one EXO
ponies the fastest and see it's only 34%
slower that's pretty cool see isn't that
bad it's not faster pony Java on the
other hand is 7.8 times slower that's
you know that's that's reasonably bad
and Erlang is different so this is more
apples than our induced you know have
you ever gone to a talk and our Lang
person says well comparing as apple and
oranges so these are using 64-bit
integers right it's fixed whereas Erlang
you can have any depth you want you know
any precision it's infinitely more
flexible clearly you have to pay for
this that makes sense so it's it's a
stupid story so let us compare Pony to
pony because relatively speaking we can
see that if you're a good functional
programmer you want no matter what
language you choose that's true relative
that's whatever functional programming
wins about functional programming
doesn't win as much oh that's let's just
focus on Pony again and see if n 37 so
fib 37 10,000 iterations happens to be a
benchmark unit of 1 right so and that
doesn't matter what machine you run it
on then the non tail recursive form
compared to tail recursive is 66,000
times slower ish I've rounded up but the
imperative form is 15 percent worse than
that again which is why you really
shouldn't use imperative programming
it's bad for you this is much better if
you use functional programming and a few
we want to sub optimize again
just use pony because it's faster at
least at the moment now everyone has to
catch up that's pretty cool and like
it's totally new so they're not working
around all the bugs and all the older
languages that's why it's faster
that's what's pasture isn't it he said
yes so anyway enough flies are two
actors so here knows no the bad actors
no one okay so this is a new subject for
everyone except except open so they're
basically just like castles they can
have behaviors right that's pretty
simple it's Joe's been saying for years
are object-oriented like here's proof
yeah it took a few years hello actor
behavior so behavior is basically just
an asynchronous function I want a
behaviorist call it's not executed now
remember it's asynchronous might happen
at some point in the future and you'll
see why later why we don't care we do
cater happens recently in the future but
not right now is okay because it's
asynchronous we'll see we'll see later
why that doesn't matter well with pony
it says with the other actor
implementations but yeah that's that's
like an advanced object which is a
couple of slides on so it doesn't need a
receiver capability again this is where
polling is different so we have you know
functional programming so we have types
but types have there's something else
and pony that wasn't different enough
for Sylvan so he came up with
capabilities so you need a type and a
capability to do something useful in
Pony and the real genius has this extra
capability which is entirely predicated
on denial which is why it's weird and
awesome means that we don't have to we
don't have to manually kill our actors
the runtime can do it first so just like
the JVM gave us memory management Pony
took it away so you don't have to the
manager actors you don't have to kill
them Tony knows when they're not doing
useful anymore
they'll be on serviceability and it puts
them down first which is extremely
powerful so if you have problems
managering and binary heaps and all this
kind of stuff another actor muggles well
pony doesn't suffer from that's it just
now your dad I'm just kill them send
them away
it's pretty awesome so in this case we
have a little ping-pong actor which
takes a reference to itself and then
starts pinging and pawning itself which
if you roll and scale it across multiple
cores that's pretty interesting how you
see it's got exactly the same kind of
deterministic scheduling that Erlang
does it's pretty good that's like that's
totally the entire program and you can
play with it with some of the tunable
options and Pony and have some fun and
see how to see how it scales on your
laptop how do you recommend that
so concurrency how the behavior is
asynchronous money can be run at the
same time each thread can be executed an
actor behavior and any given time and we
don't care because we're using natural
concurrency so who again our trio
imperative programmer is hiding in the
back the great thing about a parent of
programming and you know JVM and C and
C++ is you know we have blocks you know
we have threads and they don't compose
I've been harbor changes we have to
rewrite all of our code we don't have
any of these benefits with the actor
model we use natural natural concurrency
when you first use it it's actually very
very difficult to to use you have to
suspend disbelief for a moment and write
code that seems natural and regular and
uncomplicated and simple and it's it's
crazy it kind of just works which is
pretty awesome
we think and we think the imperative
people would like that play with it so
actor is what I'm thinking in the box we
can think sequentially and that's pretty
awesome but you know we have these
massive multi-core machines we want to
get some advantage so just spin up more
actors and that sylvans compiler and
runtime worry about scheduling all of
that stuff so that's what we do and
that's what Erlang does and that's what
the actor model gives us that's why the
actor model is so awesome and again
really the unique key difference is the
actors get GCD for you and they're
finished their useful lives they just
now they get killed off basically it's
yeah it's brutal but you know your your
memory your machine and your runtimes
will love you for this
so this is great DevOps that's pretty
cool so far safe and cheap so how cheap
are they well 240 bytes cheap which i
think is you know pretty cheap right who
thinks that's not cheap right answer
it's pretty cheap there's no locks and
no context switches so all mutation is
local and we'll see how that was
achieved later so an idol actor consumes
no resources except for the memory and
when it's not running it's literally not
running so it's not costing you anything
and you can have as many as you want or
as many as you can afford memory so if
you're using a new but at the xeon x3
martin I'm talking about with hundreds
of cores 2 terabytes of memory they can
have like gazillions of actors that'll
be pretty awesome so the compiler that
says no how does all this magic work now
this there's two parts of this there's a
compiler that says know when why it says
no denying you everything but once it's
denied you everything could improve your
deadlock free data raise free so you can
write whatever you want it's pretty cool
that's a proof than everything it's
encrypted in some mathematical language
I don't understand
it's our cell phone and a few other folk
in the audience can help you read it I'm
happy just writing tests and using the
runtime so it's memory safe there's no
dangling pointers and no hurry no
there's no concept of Nolan Pony we call
it none it's an atom you you you can't
seek Sagan atom I'd like they're
entirely safe its nominal it's okay I'm
nothing
can't dereference it it doesn't exist in
the real world it's a figment of pony
it's pretty awesome
and the type system ensures the compile
time that your program really never data
races
there's no deadlock because it doesn't
have any locks so can't deadlock won't
deadlock so it's pretty easy to write
code that just works that you're scaled
and you can make sense out of it without
requiring you know a quick phone call to
Martin Thompson which is really very
handy further three imperative
programmers oh sorry - Martin's here
sorry
well there's a problem that's nothing is
perfect right nothing is for free
what if Sylvan hates the slide
I love the slide he doesn't know why he
hates the slide we'll just find out a
few slides it's asynchronous we have a
behavior what if in this asynchronous
behavior we run a forever loop there's
this other awesome thing and pony called
causal messaging so if I spin this
behavior and I send another message to
the actor and it's running the loop
forever how will that other message ever
get in it won't you rock band code
so although Pony can prevent you from
most things you can still write bad code
it makes it really hard to write unsafe
bad terrible cold but it's still
possible we don't recommend you write
bad code and this is probably the only
bad example I could think of and believe
me I've tried I try I tried to get I
tried to get the Machine addresses and
through a fluke called through FFI
sending it out as a print death and the
compiler said no so I I tried wrapping
it in a variable ephemeral izing if
sending it somewhere else and using it
as a local parameter and the compiler
said no I've said no you can wrap it and
change it you can Swizz it no matter you
want you're not getting the hardware
address i'll give you its identity which
is you know the same but you're not
getting the hardware address you don't
need it I still disagree on that but we
can talk about that later it's fine so
there's two ways we could possibly run
there so it makes any reasonable sense
we can try and kill the actor beforehand
and pony will notice that you know it
can't receive any more messages because
nothing impossible will be sent it will
never get processed so it'll kill it for
you or we can run the loop first which
means we'll never be able to kill it
either way that's not a very useful
program so these are the two stars in
which you shouldn't write Pony
there it's only a list of two it's
pretty small compared to most other
programming languages which is pretty
cool so Pony active support calls on
massive messaging that every is there
the real serious point behind this
so I actually can't say in or express it
that well so I'm gonna use Sebastian
blessings quote from a string of ponies
so when we get this distributed
multi-node Pony I highly suggest you
read this paper and he says each message
is an effect
previously previously sent to received
messages are a cause of that effect
because the cause can't happen in the
future so causal message have every
guarantees that the cause of the message
is always in queued in an actor's
mailbox before its effect who disagrees
with this no philosophers I can't find a
way that you can disagree with this so
if you want to find out how the garbage
collector can leverage this why this is
the killer feature and why everything
inside ponies so awesome and worth
learning yes how the garbage collection
can actually work with this using deny
capabilities which are just about to
step into it's the easiest part to learn
about Pony it scares the hell out of me
to know how to recommend reading this
paper to sew ponies basically formal
proofs and it's the representation of
this formal proofs and the protocols
inside the language in one time
basically make a safe for us to write
code that he prefers to write and we
wouldn't first you know we we've got
started it so capabilities in a nutshell
so a capability for example an object
capability in JavaScript or anything
else it's pretty simple the imperative
people understand this because they have
objects and functions we don't we know
I'm taking as a function I guess but if
you have a reference to an object you
can do stuff with it fair
you don't what object can't do anything
it's pretty cool but if you have a
reference to a thing or capability it
gets slightly harder so to describe
access right on an object and whether I
can invoke a function that mutates field
for example so
I have isolation guarantees or I can
share a thing is much more difficult to
express it's also harder to prove glad I
didn't do the proof so what do we want
basically a tow system or why do we
attend conferences like this shared
mutable data is hard
agreed mutable data is safe safely
shared great but sometimes you know
mutable data that we can share is you
know more performance you know it's a
bit dangerous isolated David is
certainly safe it may be complex but
when every actor is single threaded
there's a path to solving this problem
if we're strict about the way we
interact with fields and mutable
variables inside our programs or inside
the actors running in our programs and
this is really what capabilities are all
about and the most important capability
is isolation so this is readwrite unique
so if you imagine you've got a number of
actors and you all have a reference to a
thing can I don't think of why this
might be bad that's not isolated
multiple actors have a reference to a
thing so we're going to have a look at
this in a second with a few examples
could be immutable that's you know the
other extreme so if the immutable you
can't change it so it's safe to share
yeah saf3 you can't change it it's
immutable so it can be a reference so a
reference is kind of like regular
imperative code where you don't have the
benefits of single assignment where you
can change things it's exactly the same
thing so you can change it whenever you
want all threads can change at at the
same time and everything just works
right no deadlocks data is free no it's
it's it's the exact opposite
then Pony kind of gets weird so these
are the things we expect then we have a
boxed type so it's readable to you well
may be readable or writable by others
that doesn't really roll off the tongue
and it doesn't roll into the head very
easily either you have to spend a couple
of weeks digesting this one a transition
type it just got the most awesome name
in pony
I think only Sylvan understands this one
that's right only so the variable
references data we wish to share is
read-only to others and it's as well we
can't read it ourselves it's rate unique
I said well it's the only
reference to something that may be
readable by others it can be made into
an immutable later yeah so like we turn
into a value still don't know why or it
can be a tag which means it has an
identity okay so it doesn't really deny
you anything so you can't really send it
anywhere because you can do anything to
it and it's not safe to read or write
make sense it's pretty simple so what
can be safely sent on a message by
reference you know by preserving all of
these nice guarantees so isolation or
mutability or identity and that's really
the secret sauce inside Pony that
enables everything else to just work and
that's what we're going to dig into so
what permissions do we need to be
expressed well there's write ability and
readability there's this new thing the
pony introduces called aliasing so if I
pass a reference to something
potentially readable or writable and the
compiler knows who that's being sent to
the compiler can check and do an
exhaustive search to see what the scope
of this mutability is across the
mutations and the data flow and the code
paths so if you try to do something bad
was something we said should have been
isolated to compiler can say no you said
you wanted an isolated reference and if
I give you a reference while I maintain
a reference for myself I've violated
that guarantee so think of a relay race
this is like the Olympics for
programming people you have one token to
the isolated object and you pass a
reference along to your different
objects and if you have the reference
you can do things with it otherwise you
can't because you have to sacrifice the
reference ponies are called ephemeral
types so let's say we have Alice and Bob
and Alice and Bob are accessed since we
shared data so Alice has isolated
permissions and Bob has no permissions
on the data so this is okay so Alice
could pretty much do whatever she wants
contexts of isolation so she can send a
message or she can do very stuff but you
know Bob can't really do anything or
didn't have a reference to him so if
Fred whoever or Wilma have an isolated
reference
or a writable reference some other
reference type they can read or write
into that same shared piece of data then
we violated the isolation guarantee so
the compiler says no and the compiler
will see is lovely graphs of code for
you compile time and selects out the
ones that are true and gives you a
compiler error for the ones that you
accidentally try to program that it
doesn't think you're mature enough to
use and the compiler is always right
except when it's wrong so that's the
isolation capability so here I'm not
sure it's easy to read the diagrams at
the back but basically if you try to
write and read at the same time for
something that was supposed to be
isolated for more than one reference
you've clearly violated a guarantee so
poni ensures that all of these
guarantees essentially are preserved
despite providing a very flexible
environment to write programs so this
prevents any data race or deadlock or
any of the other conditions that become
possible if these guarantees weren't
provided if that makes sense
Silvan can also explain this but it
takes four hours and then we realize
we're late to get home and we're gonna
get in trouble by our wives but it's it
does take a couple of weeks to get used
to all these six different capabilities
and how they merge together so for
example tag a reference to an object
doesn't have to make any guarantees
about aliases that's great so it's
basically not very useful except for for
actors where it's which is where it's
primarily used so because our
asynchronous mutation as local tag
identity to the actor is enough to be
able to invoke a message against to send
a message to it or receive a message
from it so that it personally should
make sense so how does all this crazy
capability stuff work it turns out a
Silvan spent a couple of months years
days maybe an hour that was years
thinking about how these compose did
some formal proofs to see how to make
this simple for the rest of us so people
like me those part of our learners and
it turns out if you look at the local
guarantee so I am the actor and I have
local access to these fields versus
global guarantees I am something
referencing the actor which may or may
not have a capability to read write or
identify then how does that construct so
for isolation locally the read write
that I capability it should be exactly
the same as globally it's isolated so
only one actor at a time should be able
to read or write its read or write
unique for a value or an immutable type
then we deny write capability locally
and globally in exactly the same way
it's immutable you can't write to it
locally you can't write to it globally
it kind of intuitively makes sense this
is the opposite way of thinking that
we're normally used to
and finally if it's a tag we don't deny
anything make sense so these three
together are the three sandable er types
within pony so so isolated if it's a
vowel or an immutable type or it's a tag
you can send it from one actor to
another everything else was bad
so all mutation is local which pretty
much makes it safe does that make sense
it's a complex mechanism with a very
simple result I'm working through the
rest of the matrix you need to
transition if you don't understand box
which I slightly understand and
reference which is obvious that's the
imperative style of doing things but it
only allows you to do it in a good way
in pony so if a function is a reference
function you can mutate fields in that
class or in that or in that actor it was
not a reference you can't except in a
behavior because it's always cool you
can always access mutate or read the
variables within the actor but with a
reference to another piece of the system
and the ladies went to play to deter
there's a very simple relationship for
this in terms of deny capability so you
can see on the right hand side we deny
nothing on the left hand side we pretty
much deny everything except the ability
to send a reference from one place to
another in a read/write and unique
fashion and we've run out of time
I can't do that fast your turn let's
meet our talk does anyone know this guy
is about half the audience right so
apparently I'm covering the runtime in
one minute here we go so right I don't
know what the hell dar is doing with
this there we go no no I think did you
go down the garbage collection stuff
thank you
they're actors right so actors they're
actors that's good is there anything you
want to say about this stuff no let's
keep going we don't have enough time no
you know what I'm just gonna wing it on
some of the plots and stuff because you
didn't put it in there and this is good
enough so you it is fun stuff excellent
um all these deny capabilities are fun
and we want to make these guarantees of
course we already make them as
programmers when you write code we don't
have a compiler that enforces them but
it's obviously it's how we think already
about ownership of data and sharing of
data but having all this stuff that
where we can prove it to the compiler is
awesome because now we have a garbage
collector that is aware of this stuff so
now we have a garbage collector that's a
no stop the world garbage clock there's
no thread coordination ever during
garbage collection of any kind that's
pretty fun we also have no read or write
barriers during garbage collection
that's pretty fun we also never touch
anything but the working set right so we
only trace the working set there's no
sweep phase on the garbage collector
that's really cool for cache reasons
there's no card marking there's none of
this overhead that you you have in
languages that don't have a strict
semantics like this right not that those
are garbage collectors aren't good
they're awesome they can garbage collect
for semantics this could never garbage
collect for but because we don't have to
be a lot faster that's pretty
interesting it's also that protocol gets
extended to collect the actors
themselves that we determine when an
actor that message queue is empty and
when it can will stay empty for the
remainder of the execution of the
program and that means at that point we
can garbage clothe the actor itself is
pretty fun scheduler layout pretty much
what you'd expect
SP mcq schedulers let's go write zero
Tomic operations put an actor and a
scheduler queue kaz loop to pop it out
but there that's only during
work-stealing
so that's pretty good one atomic
operation with no cast to put a mess
in a mailbox that's good right that's
just an exchange in the underlying code
and nothing to get it back out again so
that's pretty good on the other hand V
right these are unbounded Q's so we're
not making a back pressure guarantee so
that's wait a minute is that good or bad
yes hopefully you all think it is both
good and bad all right let's keep going
here right FFI with LT oh I think you
covered that a little bit we literally
can do L Co level compilation with
native code which is nice in both
directions with funny as the library or
pony using C C++ libraries right I
already talked about this because he was
right in the slide was there I don't
know this was Pony for Joe's so the pony
is a language we have all the bits but
we're missing OTP so we're adding it
that essentially monitors and links are
missing so all the systemic features in
our line that we know and love are
missing and Pony so they need to be
retrofitted a state machine model gen
server and Jen Jen and B server for
non-blocking or asynchronous that's
basically a pony actor that should be
obvious that that's built-in but monitor
Lincoln supervisor there are already the
core missing components that are going
to be added so Jennifer Sam I'm actually
failing with so that's to be there soon
and in the standard library all the
things will come along as well Jen event
was so easy to implement we implemented
it that's in the slides but we just
skipped over it so your eyes are faster
than a traitor's you've probably called
it and implemented it well we got here
so that's awesome just to touch on
distributed pony
it's vaporware we have a prototype
Sebastian blessings thesis has all these
proofs that we can do it it's not ready
for primetime so don't jump in and think
we can do it we will be able to do it
I'm gonna go through these a
specialization okay so these are some
things that are gonna be added I think
we got to get off the slides I think
we're gonna get murdered you that's fair
enough so there's all sorts of things
that are coming more type system madness
being able to write proper function
signatures yes that'll be in soon
right ah please please please have a
look I'm desperate come on have a look
it's lonely being an only pony</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>