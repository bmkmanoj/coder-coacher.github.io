<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>That's My Monkey (...) - Rob Martin (Lambda Days 2017) | Coder Coacher - Coaching Coders</title><meta content="That's My Monkey (...) - Rob Martin (Lambda Days 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>That's My Monkey (...) - Rob Martin (Lambda Days 2017)</b></h2><h5 class="post__date">2017-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pr6P02oYx5I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so isn't it clever of me to come to
Poland and may my my talk after a Polish
proverb right not my circus not my
monkeys I still think it's I love it I
mean like I love this too saying it's a
great way a brilliant way to identify
where to spend our energy and why we're
spending it there letting go of the
things that we're not responsible for
and I picture chaos monkeys running amok
cos the circus tent falls down but I'm
pretty sure that whoever coined this
phrase was speaking metaphorically I
don't think he or she was actually
talking about monkeys I think they were
sitting around the playground watching
their children or watching other
people's children play and and you know
that when other people's kids start
getting in trouble
and you just you want to do something
and then you say not my monkeys and then
you wonder where your monkeys wet so I'm
Rob Martin I'm VP engineering first
startup in Utah we do some machine
learning stuff just like everyone else
quality correctness is pretty important
for us we've got a nearly entirely pure
functional stack
I have interns and juniors who I have
interns and I have juniors who have
never worked in an object-oriented
language
I've seniors who come to work for us
even though I have to pay them peanuts
because they get to come to work with us
and that's really cool I like that my
talk is kind of a kitchen sink manifesto
so I'm just gonna start in the middle I
you know I I wonder how do we tell what
a senior is and and I think the you know
you can't if it's something you have to
count you can't use it it's not the
number of hours a number of years number
of languages number of projects I really
think that it's about someone who
delivers simple demonstrably correct
code and with that delivers value to the
user so let's go ten times further or
something like that how do you tell what
a what a 10x developer is you know this
was really popular a couple of years ago
they're a bunch of talk saying you know
they don't exist whatever so I wanted to
just said they do exist and and the
maybe we've got a little bit of it wrong
you know it's originally based on some
research in 1968 by Sackman
Ericsson and grant Fred Brooks put it in
the mythical man-month in 1975 we
typically refer to it as like 10 times
better than the average developer and
it's not what the research side or the
research that's you know like
demonstrated that the original research
which was flawed still basically came to
the right conclusion what they said is
that the actual studies demonstrate that
there's a an order of magnitude
difference between our most productive
and our least productive developers
but what metrics do you use for that and
and and what use are they I mean if
you're working on some large government
contract I can imagine the you know
Kokomo the constructive cost modeling is
as useful probably is or function points
or or the cyclomatic complexity of the
project as a whole rather than measuring
it after we're done with it measuring it
before these all could be useful but for
for me in smaller mid-sized companies
and startups what I want is value so I
focus on 10x developer being somebody
who can deliver an order of magnitude
more value but what is value we're
developers it's it's a it's a pragmatic
art it's not some it's not an aesthetic
art right we make tools we make the
tools that other people use to build
rich lives we aren't the sculptors we
are
Michelangelo's blacksmiths that's what
we do the degree to which our tools meet
their needs and building the lives that
they want is like how I define value
that's how I want to look at value and
as programmers we deliver this value
depending on where we are in the product
cycle based on the kind of judgment that
we bring to our projects more
importantly what kind of judgment we
brought to our projects along the way so
let's say that we do have a 10x
developer and to become a 10x developer
we need to deliver 10 times as much
value value comes from judgment so how
much judgment does it take to deliver
ten times as much value this is just a
thought experiment I'm sure like lots of
people can demonstrate this wrong from
experience some of us will demonstrate
it right from experience but let's say
developer egg consistently makes
decisions on a project that it delivered
25% more
value per unit of effort developer B is
an average developer and gets 1.0 times
as much value per decision and valper C
is one of our least productive
developers and gets 25% less value
produces our for decision along the way
and I'm gonna accept it as a given that
these decisions affect the future
decisions so if we make a bad decision
or a good decision upfront it compounds
so if with 10 compounding decisions then
the difference between developer and
developer B is an order of magnitude
9.31 scarily the difference between
developers being and developer c is also
an order of magnitude 0.056 so thought
experiment 2 orders have magnitude
different and of course you know that
requires looking at developers see who
is our least productive and we all know
that our least productive developers can
deliver negative value I work on you
know not just creating 10x developers
but creating teams of product developers
by improving their judgment there's a
bunch of things they do for that I guess
first off I'll tell you about some of my
goals over the past few years building
teams of functional programmers that
productively include juniors that's
really important to me the juniors
migrating teams of imperative
programmers and their legacy code into
functional program
teaching functional programming to new
developers especially been learning how
to do that now for about two and a half
years and and now like my biggest goal
is I'd really like to learn how to take
somebody from an intern to a senior
measured by judgment and the value they
deliver in four years I understand and
pulling this considered slow in the US
yeah it's a little on the fast side I
think the value is great but we offset
it with anti values and I want to get
rid of these this is part of where our
judgment comes in because it's as if
it's almost as if in the product life
cycle the decisions we make now are the
ones that we have to the ones that
create the problems that we have to
solve in the next stage and I think he
could actually see this in a lot of
different places right well the feed of
our discontent or we cause our own
difficulties monolithic code is rigid
tightly coupled from one front end to
one back end it's often fragile it tends
towards complexity our code is often
especially early in the life cycle
especially with startups our code is
often untested it's harder to work with
because of that it tends to ship with
more bugs our agile methodologies
prioritize features and they do it in an
iterative and explorative way right this
is wonderful this is perfect this is our
best practices and it ships technical
debt every single time because we don't
know what we're doing until we have a
customer say yeah that's it perfect I
love it and then product says good let's
move on to the next feature because
that's a higher priority than fixing the
technical debt that we just shipped and
resolving that technical debt yeah
has a lower priority so we don't we
don't do it and I'm nearly often enough
you talk to agile leaders about this and
they'll say well yeah this is a
discipline we have to follow we have to
set time aside for it
somehow we don't have the all that many
agile leaders on our product teams maybe
we said so if we go to the typical route
excuse me we deliver quickly we prove
our value and we succeed yay we get
widespread adoption and our servers
start to fall over and we upset
frustrate our users and we start to
refactor our code rewrite our code often
in more functional programming languages
you know we may have started in Django
or Ruby on Rails if we work harder at
managing our anti values upfront we
deliver quickly we prove value and and
we succeed yay we get widespread
adoption and we don't fall over nearly
as often I am absolutely convinced that
I can deliver startup code using elixir
and elm that will scale at least ten
times further than compro comparable
code that startups have been using for
the past you know 12 years so and so we
don't have to rewrite we don't have to
refactor our code significantly and
there's this thing that we'll get into
in a little while the architecture that
we end up with allows us to innovate
around our core competencies we can not
have just one front end and one back end
we have a back-end that's decoupled from
the front end which means that we can
reuse that back-end in new and
interesting ways that people like
passport
I found my monkeys their names are
simple and demonstrably correct and you
might have heard of them because I talk
about them all the time
okay so simple let's describe simple by
looking at the other side of the coin
which is complexity sandy Matz she's
she's big in the Ruby community some of
you may have heard of her she has rules
for developers of one of her rules for
developers is that no method maybe more
than five lines she includes the method
declaration and that my interns and
juniors have a role that between the do
and the end in their elixir code they're
allowed to have five lines of code
that's about as decomposed I mean if if
you can't get it down to their I I
wonder whether are you trying to do too
much with it the interrelationships and
our dependencies the degree to which you
know one piece of software is dependent
on another complexity is the enemy of
reliability that's like a famous quote I
forget the central enemy of reliability
is complexity that's damn gear security
is simplicity as prerequisite for
reliability Dijkstra the price of
reliability is the pursuit of utmost
simplicity that's Tony Hoare complexity
is a part of our code that's not
beautiful I like this it's like beauty
is the ultimate defense against
complexity and I'm sorry I don't know
how to say his last name damage alert
nner anybody want to like shake their
head vigorously and say I got it all
wrong okay and then I want I want to say
that complexity is also code just you
know code Brooks in in no silver bullet
says you got no essential complexity and
you got accident no complexity like when
it comes down to it you're still saying
I'll come all Coda's complexity and if
we could solve our problems as
effectively without writing code
we would probably do that and it would
probably be simpler than the way we do
it now
so um complexity is bad we probably know
this it's difficult to reason about
either formally or informally it's
difficult to test it's difficult to tell
whether or not we're testing the right
stuff it's um it's difficult to trust
complex code if we can't reason about it
we can't prove it
oh why should we trust it Tony Hoare
again and I met him in London and sat
down with him for a little while it's
just it's really amazing to have these
opportunities that we do and me coming
from the states to mean like so many of
my heroes here John is in the front row
and I have an essay that you know it's
come why be functional and of course the
first thing I do is quote why functional
programming matters right
so Tony Hoare says I conclude there two
ways of constructing a software design
one of them is to make it so simple that
there are obviously no deficiencies and
the other way is to make it so
complicated that there are no obvious
deficiencies I contend that the first
one is the harder I think all of these
quotes that are like you know twenty and
forty years old are still relevant I
don't know if you agreed but I think
they're relevant
so what simplicity it's pretty simple to
say it's just code that's not
complicated right and that's a pretty
good answer I have a test called the
simplicity test I use it for evaluating
code that I wrote on my team wrote I use
it for looking at library code and
deciding whether or not I want to use it
or framework code I use it for looking
at a programming language or even like
an intoxicant on why be functional
looking at entire programming paradigms
like object-oriented versus functional
you know it's object-oriented
programming easy to reason about
as functional programming easily the
reason about can I reason about this
code can I demonstrate that the code is
correct can we trust the code right and
if I can answer yes to all three of
these questions my code won't just be
simple it'll be less fragile to be more
maintainable it'll be less expensive to
maintain and if it's simple it's less
likely to rot I think that's why
functional code doesn't rot the way that
object-oriented code does and wait what
I like and what I'm excited to get into
here is the impact that the same
approach can have on architecture the
designs that we're following but first
we'll get we'll get to architecture
anyway so we have code reviews on my
team's our code reviews are are really
kind of based on the simplicity test as
well we look at the tests first see
whether or not they cover the the
business objective that we have for the
feature that the button that we were
working on right then we look at the
code under the test and see whether or
not it's easy to reason about and then
we look at that code in the context of
the big picture and decide whether or
not we can trust it with the system that
we've got so in simplicity test is
useful for evaluating code but it's
definitely useful for evaluating the
tools we used to create code so for
instance for functional programming I
can ask can I reason about this code the
answer I think is yes we've got
referential transparency that promises
us that we can trust the result of our
functions based on the arguments that
are right in front of us right we've got
composition that gives us different
levels of abstraction we can look at our
code we've got a mutable state so we
always know the value of things
when we transform state we get a new
state back our side effects are isolated
they're obviously supported in most
functional programming languages but
it's much much easier to isolate them
can we demonstrate the functional code
is correct yes of course we can it makes
unit testing very easy integration
testing easier and proving correctness
possible like most imperative code is
very difficult to prove that it's
correct
again you know referential transparency
pure functions composition side effects
the fact that functional programming is
based on math makes a huge difference
and like testing it right Dijkstra again
programming is one of the most difficult
branches of applied mathematics the poor
mathematicians had better remain pure
mathematicians okay functional
programming can I test this code if I
can reason about it if I can demonstrate
that it's correct I'm much more likely
to test it so I want simple into monster
play correct code I'm gonna base it on
pure functions we already know a lot
about pure functions we just talked
about them and evaluating like
functional programming right we've got
referential transparency I like this is
how I describe these concepts to new
developers so some of you will want to
throw things at me and some of you might
say oh I wish I knew that earlier right
referential transparency returns the
same value regardless of the arguments
that we get it right which another way
of saying that is any given function can
be replaced by the result of that
function call in place without changing
the meaning of the program and another
way of saying that is that nothing about
the state of a program or the world
can impact the result of a function call
a pure function call we have
immutability right I think it's
absolutely ridiculous what makes me want
to grab that we have in variable
variables and it's always fun to explain
to juniors so I try not to use variables
I try to know buse words like state but
then I explain to them that maybe it's
easiest if you don't think about them as
variables at all maybe we should think
about the misc functions if we have
referential transparency on our
functions you know and for any given
argument we're gonna get the same value
if a variable is a function call that
doesn't take any arguments it's always
going to give us the same value we have
function composition so the output of
one function can serve as the input to
another higher level functions can be
composed of lower-level functions we can
move up and down through levels of
abstraction we have laziness
distribution I'm worried about running
out of time so I'm gonna it we're
functional programmers right just this
make sense
okay I see one hand go up is that a yes
good it made sense right there so okay
so the lowest hanging fruit that we get
from pure functions and functional
programming we can apply both the most
programming languages right and many
many many of us don't get to work in the
programming languages that we want to
and one of my goals is to help people
move from imperative and object-oriented
programming languages to functional
programming languages so I want to apply
the lowest hanging fruit from functional
programming to the work that they're
doing and it gives them an opportunity
to become comfortable with the concepts
in the language that they're comfortable
with to begin with and I'm gonna start
by saying you know like the first rule
is to isolate side-effects from your
logic
Simon Paton Jones in the end all
programs must manipulate state a program
that has no side effects what whatsoever
is a kind of black box all you can tell
us that the Box gets hotter he is a
venerable and wise person but heat is a
side effect as far as I'm concerned so I
disagree with him side effects examples
of you probably know the use it's you
know telling the time telling the time
it's a side effect getting API requests
reading from a database writing to a
database replying to a client on an API
rendering something on the screen
adjusting the airline's on that
intercontinental ballistic missile that
you programmed these are all side
effects side effects are kind of like
you know the opposite of our french hole
transparency right a pure functions
gonna give you the same result for the
same request but a side effect is
probably going to give you a different
result but not definitely makes it
interesting to reason about right so the
plan for functional first programming is
very very simple first code everything
you can without side effects right all
of your your business logic and pure
functions and then code your side
effects right preferably put them in two
different files
you know if I'm using Sinatra or flask
or Reuben rails or Django or whatever
I'm going to use as little of as little
of it as possible I want everything I
can to have no side effect so I'm not
going to be accessing the object
relational mapper and hitting the
database in the middle of my business
project right so I'm gonna use the
router my controller is gonna call my
class full of pure functions
so in elixir in Phoenix you know I
always just ride makes Phoenix new the
name of the app know HTML no brunch no
act oh and no there's one more
no that's it no II just come on no
brunch no right though so then you know
like my Phoenix installs run music
boilerplate code 125 lines and my code
maybe another 40 so when we move our
business logic in any programming
language into pure or as pure as we can
get functions try to remember you know
for instance and Python that you can't
work on a raised without mutating them
you have to copy them first so I mean
like it's not always easy to get pure
functions but we we get some advantage
as one of them is that we can work in
pure language right we don't need much
by way of dependencies there might be
some libraries for instance for doing
date math or or whatever that we'll want
to use but we're not talking about big
heavy libraries into a lot of i/o we
don't need those at all our code base is
smaller I think that as soon as you get
rid of those dependencies and you're
only dealing with pure functions our
code is a whole lot easier to reason
about it's certainly easier to test unit
tests or breeze and they run like
instantaneously our our functions are
stateless they're easy to scale
horizontally it gets us in a good place
for architecture and when we isolate the
side-effects one of the really cool
things is almost all of our side effects
is IO right and we don't write our own
IO of libraries not usually I mean if
you write your own io libraries that's
cool because you know there's some fun
programming in there but most of us
don't need to do that so when we're
working on our IO layer on our side of
Kleier we don't need to do any side
effect or we don't need to do any unit
testing because just the libraries come
with unit tests all we're going to do is
integration tests and our side effects
layer is as thin as possible
it's just side effects so it gives us
the opportunity to change it out you
know we're doing the least amount of
work necessary to say you know I want
this instead of that
or I want this in addition to that so
maybe we start on HTTP and we want to
add WebSockets or HTTP 2 or or a message
bus interface super super easy and with
functional first programming again
developers working in object-oriented
programming languages pick up a lot of
functional concepts so I ensure working
on a new project in a functional
programming language is an ideal
situation a very very few of us are
lucky enough to have that my last job
had a legacy code base of 3 million
lines of Java 6 with JBoss so a
monolithic application we work harvin it
up into micro services but of course we
were still stuck with monolith you know
whatever was still being supported by
that code we needed the whole of the
code and we couldn't break even the
stuff that we weren't using in most
cases right the longest class I saw in
that code was 15,000 lines the longest
method I saw in that code was 5,000
lines there's these two two women who
sat behind me they refactored the 5,000
line method it took them a month which
actually I think is pretty good
performance
they removed like 3600 lines of code in
a month and and they were so good at
pairing that I wanted to like put them
on a stage and make everybody watch them
for at least an hour a day
it's imagine refactoring 5,000 lines and
one method and and like doing it with
another person and enjoying it's it's
good
so I reported to a VP of engineering and
I ran an internship program and my VP
engineering Scott he said hey Rob why
don't you do a refactoring internship
okay I laughed at him I told him that it
was the worst possible code for interns
to learn from and it's the worst
possible code for new brand new
developers to work on the practices and
there were horrifying and that the
interns are gonna you know you're gonna
hate the code they're gonna hate the
work they're gonna hate their job
they're gonna hate getting up in the
morning they're gonna hate themselves
more importantly they're gonna hate me
and if they're lucky they're gonna
become hairdressers rather than computer
programmers and I only say that not
because I work with women who are in my
internship programs my buddy Joe and I
owned a business together for a few
years like 15 years ago
and at that time the the field that had
the highest job satisfaction was
hairdressers so we used to always joke
you know on bad days that it was time to
go become hairdressers as if we could
learn that you know quickly or something
just like computer programming right not
something we learn quickly so um I
laughed
it's got lasts and then he said do it
anyway
that was fun fortunately he quit before
I had to do it but and thinking about
that he's right juniors need to know how
to refactor code so it's good jobs it's
easier jobs for a junior to get it's
important work so how could I turn that
in to something that actually
move them in a direction of writing
simple demonstrably correct code that
relied on functional the lowest hanging
fruit from from functional programming
right so this was the basic process you
looking at it you can see that I pretty
much stole it from Michael feathers but
I wasn't smart enough to ask him first
so I had to create it myself and it's
basically it's you you find the program
area you leave your side effects behind
in the method but you move your business
logic and in the problem area into its
own function right and now you can just
call that function except we're relying
on class variables we're relying on
global variables and we don't want to do
that so we're gonna purify that function
we're gonna take whatever its relying on
in its code and we're usually only
talking about like six or eight lines of
code that we're moving into its own
function right so we're gonna pass in
anything that it's relying on once we've
got that then we haven't changed our
business logic at that point we
shouldn't have to worry about having
broken anything so now we write a
failing passed a regression test for the
issue that we're working on right and
because we're there when we're writing
tests we're gonna write some
characterization tests as well that
demonstrate how it actually works even
if we don't understand why it works that
way we still want to make sure that it
works the same way when we're done then
we fix the code pass the regression test
and go back and refactor to make it
simpler easier to reason about easier to
maintain and still passing all of the
tests
okay so I got this from from Phil
wobbler and I thanked him for it and he
said I never said that it feels to me
like some of our programming languages
were built in a garage and there's a
reason for that it's because they were
built in garage
some of the garages were really really
big but Java would still meet in a some
garage right these languages have a lot
more abstractions but they feel more
concrete you know we've got many choices
in how we're gonna do it and some
languages have even like you know some
of themselves on there's more than one
way to do it right
we've got languages that are
object-oriented and procedural we've got
languages that are functional and
object-oriented we've got frameworks and
libraries that add new abstractions on
top of the abstractions that the
language is already providing us and
we've gone at the end the illusion of
choice with tons of hidden complexity
loosely wrapped in abstractions that are
you know held together kind of tenuously
depending on the language worse some
much worse than others I've used these
languages have loved these languages I
probably written more than two million
lines of code in a lot of these
languages what I find is these languages
require mastery in order to have
judgment good judgment and if you don't
have that mastery yet it's difficult to
have good judgment if you don't have a
good judgment it's difficult to deliver
value so I want to avoid these languages
right or well somebody gave a talk on
Orwell right freedom is slavery choice
power I think that it hurts us more than
it helps us but some languages feel like
they're based on the laws of the
universe and that's because they're
based on the laws of the universe
it's not a bunch of Miss mismatched or
abstraction so it's a few solid
abstractions that go a lot further
because they're based on math logic
philosophy we start with lambda calculus
for most of them right a few functional
programming languages are primarily
based on combinatorial logic and we tend
to add in take their inside variant
category theory and you know and you can
look at this family of languages and and
you can trace you know like which
abstractions they're based on and and
get a lot further with them we all know
this I hope because I hope most of us
have the pleasure of working with these
languages compared to the languages
built in garages these languages are
very constrained we we don't have as
much choice we're not gonna get in and
you know deal with the metal level
things at least not not very easily we
we don't have the power of a systems
language we don't have the power of Java
or C++ or C or whatever right and that's
what I want my teams to have I want them
to have a constrained language I want
them to be able to learn fewer
abstractions I'd like them to have fewer
options I want them to be able to focus
on problems that we're solving rather
than understanding all of the options we
have and how to solve them functional
programming languages again this this
slide looks just like other slides we've
got characteristics of functional
programming languages these are the
languages that very often feel like they
are based on laws of the universe and if
we apply the simplicity test to them I'm
sure that you can probably do that in
your head but I'm gonna rush forward it
is code that we can reason about it's
code that we can demonstrate that's
correct and it's code very often that we
can
or that we can trust again with juniors
I like to have a simple way to explain
immutability and I tend to do that using
identity right we use state in our
program very often to represent things
that are in the real world right in
object-oriented languages the properties
of one object distinguish that object
from other objects identity is the
current state of an object the the
current properties of that object are
the identity of that object the object
oriented abstraction gives us only one
identity it's a current snapshot of that
object we could of course maintain a
journal but we don't get this for free
from object-oriented programming in
functional programming you know state is
immutable right so we transform state
from one version to another version
which means we always have at least two
versions of our state we have the
current and the next row or the previous
and the current you know however you
want to look at it by extension that
means we actually have every version of
state because we were the ones who chose
what to throw away and because of that
we can we can actually say that you know
identity is basically an immutable
collection of states over time
and it's very different between
functional programming and
object-oriented programming code
identity and functional programming is a
collection of states over time and we
get this for free
when we're using functional programming
and it's an extremely rich source of
data for answering questions even though
things that we don't actually know to
ask yet um once we have identity we very
often need persistence right so we have
classes of databases relational
databases tend to treat data like
object-oriented programming treats
identity write a query returns the
current state of an entity updates are
destructive in the standard abstraction
the database is mutating its data the
concepts behind relational databases are
kind of brilliant especially for the
late 70s and.and they don't match well
with our current needs on on this
internet and model and complex data and
relational database this is painful I
don't like that and we'd like to avoid
it when possible because it's complexity
then we have most no sequel databases
there is no such thing as no sequel
everybody should remember that this is
sloppy convenience it gets us eventual
consistency gee normalization and speed
web-scale
also a meaningless term that
we often have trouble doing with
relational databases they still treat
our data alike object-oriented
programming treats identity right
updates are destructive data is mutable
or at least it's presented to us that
way like couchdb doesn't actually mutate
the data right and it keeps previous
versions right up until you tell it to
clean up and then they're no longer
available to you and you can't query
them we're still getting that point in
time snapshot of our state and changes
to our data are incremental and shared
across multiple devices so we mean to
manage conflict which is again
complexity so then we have immutable
databases which do not destructively
update our data in fact there are no
updates with immutable databases if we
look at crud
we don't have to see our UD we just have
seen our create read an update is just a
create that says hey you know this is
now that we have the same benefits of
with a mutable state in our programs and
immutable databases and our persistence
layer we can reason about our data
changes to our data item potent we've
got an audit trail showing us when and
where and why things changed we can ask
questions about our data over time our
clears may even be pure functions
against a bunch of events there is a
question about you know like a cap
theorem cap theorem was influential very
influential in the creation of our know
sequel databases and I don't know about
you but I first learned that cap theorem
was about databases no it's about
distributed computing and that's gotten
me fit to ask you know what's the
difference between what is a database
what's the difference between a database
and something else you know if I have
row oriented data I probably have a
database if I have column-oriented data
I probably have a database a key value
store and events to our document store
we call these databases right but what
about a web server
you know why is a web server not a
document store
what's a microt service what's the
search engine and maybe the distinctions
that we have between databases and
services is not actually all that
relevant we still have to deal with all
of the same things
reactive manifesto i'm guessing who's
who's heard of it who's read it who uses
it
yeah expectations from past
architectures are inadequate of meeting
the needs of today's Internet they say
our previous expectations are too slow
too fat and too unavailable so they
define a coherent system architecture
that expects 100% uptime millisecond
range response response times
cloud-based infrastructures and and
petabytes of data and maybe this is not
what I need for my startup but the ideas
are wonderful and applicable they're
based on four characteristics that our
services are responsive that we have
rapid and consistent response times that
build confidence and the usability of
our system that response time also can
be useful to indicate whether or not
things are working properly if we
monitor our response time and we see you
know things go awry well that probably
indicates that there's a problem
reactive systems are resilient they stay
responsive even during a failure the
components are redundant replicated
isolated and we can delegate
responsibility you know if something
goes down we've got someone else who can
pick it up our reactive systems are
elastic responsive even under varying
workloads are designed to avoid
bottlenecks and contention points we're
constantly monitoring and automatically
scaling and reactive systems are
event-driven
which gets us back to our immutable data
right asynchronous message passing
we're decoupling our systems and and and
using that message passing to to connect
them back together we avoid blocking
communication isolate our services and
we make the location of different
services transparent you know we we
don't care where things are at funny how
much this sounds like Erlang
so creating reactive systems helps us
design and build scalable anti fragile
systems reduces the complexity of our
systems it aligns really nicely with
those functional functional first
concepts that we talked about and it
aligns really nicely with domain driven
design
what's domain driven design again I'm
guessing that some people have been
trained in okay so core concepts for
domain driven design are well domain
driven design it's it's just an approach
to developing software that's based on a
collaboration between us and then
programmers and the people who actually
work in the problem two means that we're
solving and our code actually ends up
being organized the way around the way
that they think and talk about the
problem so core concepts a domain is an
area of activity a subject area or
sphere of knowledge model is how the
people who work in the domain think
about the problem the ubiquitous
language is the way that people who work
in the domain talk about the problem and
entity is something that has identity as
we've already talked about in the
context of a domain a domain event is
something that happens that's important
to the domain experts it's within the
context of the domain model and it
affects entities in that domain bounded
context is a collection of related
domains that share a model or models
share the language they have many of the
same entities and they tend to still to
have their own domain events if we do
domain driven design skillfully we'll
end up with code that's limited to a
particular domain while organized that
way depending on data structures
describing entities on the models in
that domain and because we're using the
same language as our business partners
well we often end up with code and data
structures that they can read and
understand and that's really interesting
like we write for our future selves we
write for the people who maintain our
code in domain driven design we're
writing for the people who benefit from
our code too compared to you a context
where you know we used to build these
unified models of the business and
monolithic applications domain driven
design as as dramatically simpler faster
and cheaper cheaper to maintain and
batter at correctly solving business
problems the front-end is its own domain
reactive systems and domain turbine
design lets us derive that it may be the
consumer side in the backend just the
producer side for instance like any
commerce or banking it might be the
other way around
and in data entry or Internet of Things
or logistics or an ERP system where the
front-end is the the producer the back
I'm just a consumer the purpose of the
front-end is strictly to manage the
experience of the user the domain logic
on the front-end can be performed on the
front-end this is something that we
don't necessarily always do because it's
within a different domain and the
front-end and various backends relate to
each other as defined by the bounded
context and their domain models and the
entities and events within that context
front end is a different domain if the
front end is a different to me in the
back end is a different domain or the
back ends are different domains the back
happened is responsible for maintaining
the integrity of our data by applying
our business logic that's its job we
don't just have one of them we create
one for each domain we group them within
the bout and bounded context based on
functional first programming we're gonna
isolate our side effects keep all of our
business logic together so I forget what
I was gonna say there it's fun
this gives architecture you know the
same benefits that we get from
functional programming but at a
application scale the business logic is
purely functional its referentially
transparent it's composable with purely
functional business logic and immutable
data it's easy to horizontally scale our
business logic is really easy to test
and the test run fast our side effects
layers only side effects we cover those
again with integration tests that
isolation makes it really easy to add
multiple interfaces to our domain logic
so so we get this bonus then that we can
easily have multiple front ends and
multiple backends right if we're mashing
up the back ends to form the front end
then we can identify different domains
for the front end maybe we have you know
like one application that's more for
staff and one that's more for management
or we want you know mobile native mobile
app or a public API these are all things
that are easier to do when we have that
back-end so if we take this into a
simple overly simplified architecture
with various clients
various client applications representing
different domains they generate domain
events write reactive programming they
generate these events within the bounded
contacts domain driven design the events
are persisted to an event store which is
an immutable database the events store
is queried for for events filtered by
the domain or domain served by the
domestic but filtered by domain for the
domain services domain services generate
domain events within the boundary
context and hand those back to the event
store which then you know other domain
services picked them up and update their
models client applications also
subscribe to events that pertain to them
and client applications and domain
services can query other domain services
to answer questions about the domain
model that they're responsible for from
here of course this is this is minimal
we can still use rabbit or Kafka for
distributing events we can shard domain
models we can access services from under
bonded bounded contexts and
cross-cutting services like messaging or
authentication we can move the whole
thing to AWS with s3 API manager Lando's
dynamo Kinesis NEC - this is this is how
we do our our event store and because of
the timing I'm just gonna say that it's
it's based on on demand driven design
you can see we've got a realm a domain
an entity and an event type that we're
storing the data for the realm is really
organized around authentication our
domain services are
organize of course by domain subdivided
by the model each service requires or
receives its it's events that we map to
a function that we use to transform our
domain model this is this is really
useful sometimes we'll receive those
functions and process them immediately
well update our domain model that's
that's typically what we're gonna do and
we need to ask questions about the
domain model a lot more frequently than
we update it so if I'm building a
shopping cart service I want to know
what's in a shopping cart about 50 times
more frequently than I want to change it
but if I'm running a shopping cart
service and I want to know hey which
products got left in shopping carts and
then taken out right before they checked
out well that's not a question I'm going
to ask very frequently so I might do
that one on demand and projections and
reductions are two different ways of
looking at that domain model I'm gonna
skip that sorry
distributed computing all I'm gonna say
is that's not invented here as much as
possible in this architecture we're
pushing the hard problems of distributed
computing off on to software that does
distributed computing we don't we don't
work in that domain you know I don't
work for a research institution I don't
have a research team or a budget and
these are well studied problems that are
peer reviewed and demonstrated to be
correct in summary then using the lowest
hanging fruits from functional
programming that functional first
approach using reactive programming and
domain driven design we end up with a
system that we can reason about
we've got event sources and command
query responsibility segregation that
pattern is simple it's well understood
we've got domain based design that's
well organized our domain models and our
events are immutable
our events map to pure functions and our
domain models are just state
transformations we can demonstrate that
our system is correct or demand logic is
purely functional right referentially
transparent easy to test our domain
services are isolated our system of
record is immutable and has a full audit
trail reactive system design gives us a
monitoring for operational errors and
distributed computing portions that were
based on the hard stuff we didn't build
people who know who are putting that
effort into it are taking care of that
can we trust our system yes it's easy to
reason about we can demonstrate
correctness before and during production
we deliver value quickly and frequently
we can trust even our less experienced
developers to produce value in these
systems we can avoid the anti values
that we discuss we leverage our
functional programming concepts which I
think helps us trust it and we get the
benefits from reactive programming and
domain driven design and I'm sure
there's not time for questions thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>