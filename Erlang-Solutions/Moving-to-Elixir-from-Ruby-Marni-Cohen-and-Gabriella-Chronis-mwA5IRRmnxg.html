<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Moving to Elixir from Ruby - Marni Cohen and Gabriella Chronis | Coder Coacher - Coaching Coders</title><meta content="Moving to Elixir from Ruby - Marni Cohen and Gabriella Chronis - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Moving to Elixir from Ruby - Marni Cohen and Gabriella Chronis</b></h2><h5 class="post__date">2016-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mwA5IRRmnxg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Marni I put my note cards
over here and forgot about them cool
business system developer at puppet
formerly known as puppet labs it's a
server automation company we work on a
smaller team of four folks by I started
as an intern learning ruby moved into
elixir full-time about a year ago in
August by day time I do functional
programming and elixir at nighttime i
switch to c sharp and make video games
we work on the same same team together
if we switch off a lot is this going to
be bad for a microphone avoid eating
I've been programming professionally for
about two years I guess if ta enfora
students cats for a bit of that and I
spent a portion of that time learning
ruby and and unlearning the functional
paradigm that I've been taught in school
and then the rest of the time since then
unlearning Ruby and relearning
functional programming with a lick sir
and that's our team that's totally what
we look like in the real world so you
can tell there's me and Gabriella
there's also jeff weiss who was as
Robert would say our profit he made a
strength elixir and then man you who's
newer to the team who has a Java
background and what our team does is we
build internal tools for the business so
if someone needs something automated if
they need data pulled from JIRA or
something we figure out how to make that
happen so we have a lot of freedom and
what tools we use and the twirl we ended
up going with is elixir and this book
was basically all of our introductions
to elixir at different times I think
that Jeff and Manny both read this book
when it was still in beta and then we
signed on a little later on I remember I
was reading this and the book is called
programming elixir also i should say
things out loud I remember I was in a
coffee shop working from home one day
and I was reading this book and it was
my first introduction to
functional programming at all and I was
so surprised I was just like pattern
matching pipe man like what is going on
and my friend who is not technical was
in the same coffee shop and he was just
like what why are you gasping out loud
at this programming book what's going on
I was like oh you know it's just like
this is all so different and new and he
was like oh can you explain it to me I
was like well first I have to explain an
object-oriented programming and then
tell you to forget everything and turn
it upside down and that what you've been
reading has been backwards this whole
time and he I lost him right about there
and this talk is going to be a survey of
some of the lessons that we've learned
while moving our team from Ruby to
elixir over the last year and so we're
going to sort of dive into that using
two rewrites as our main focus so one is
a rewrite of a company directory system
and moving from Ruby to Phoenix and
another second one which i'll take is a
data warehouse that we're currently
working on so i'll start with the
internal directory this is Robbie
Robbie's main focus is to be a internal
website where you can see a map of the
office and see Oh HR sits on the fifth
floor over here or oh there's a new hire
what's their name like Sarah what does
Sarah look like type her name in see a
photo have an idea really important
especially for a fast-growing company to
know who these people around you
actually are it was my first memory
project and I was really excited and i
had very little supervision so it turned
into a mess really fast it was a single
page app purely because single page web
sites were really hip at the time and I
didn't know how to make good decisions
so I was like oh this is a cool thing
I'll just try and do a cool thing and it
was a single file that were like the
main app was a single file of 937 lines
of code and it was disgusting I mean it
would fail like we had a little our
operations team had a file that would
kick it or
tool that would kick it every hour to
restart it because it failed so often
and it was just messy from the ground up
and it reflected how you know I didn't
know what was going on other people who
touch the code would mess with things
and I wouldn't know what they did I
didn't know how to read Ruby very well
partly because I was a new programmer
and partly because I was writing messy
code in the first place good here's some
beautiful examples I went back and
looked and my comments are just like I
don't know what this does I spell I'm
not really sure and I mean I was two
years ago too so that doesn't help um
not sure if I could take that out of
nothing would break or the whole thing
would go down tried to look it up
recently and I still am Not sure and me
trying to figure out how to make
something secure but I didn't understand
how salt worked and i'm adding salt on
top of a password that are a hassle on
it and chomping is just it's gross you
can see how gross it is but i was proud
of it cuz it was my first app and you
know it worked some times um and not
enough clearly was it sure he had always
led a joke it didn't work ever
apparently new hires would be told Oh
welcome to this tool Robbie here's a way
to meet your co-workers here just update
your picture and they wouldn't be able
to update their picture would break they
would sometimes when be able to log in
and I don't think you can I was hired I
could put my info yeah it's like welcome
to puppet here's a broken tool to meet
everyone with
but the logos Barry yeah but the logo
look great it was cute whore loves a
friendly robot um ano single page app
huh so I was proud but I got pushed to
other projects over time other teams
picked up Robbie added a bunch of
JavaScript on top to make up for what
Ruby couldn't handle and what I couldn't
handle the put in and it got harder and
harder for me to go back and edit the
code or participate in this thing that I
had built so we decided eventually to
rewrite Robbie and elixir just like burn
the whole thing to the ground still have
the old repo somewhere it's good for a
couple of laughs and so we started with
Phoenix and Phoenix was awesome I mean
we use it in half day projects we use it
for rapid prototyping it's been really
amazing and nice and it sets everything
up sort of in a pretty structured way so
I can't put everything in one file like
I could with the first Robbie and the
original Ruby Robbie just as background
was basically talked to a database ldap
lightweight directory access protocol
pull downs just a ruby push that to
Sinatra and then wrapped it all in
JavaScript but like with like too much
duct tape basically it wasn't like a
neat little package it was gross and so
without all that JavaScript on top with
Phoenix and elixir it was just so much
faster because we can make the requests
on the client side I didn't have to use
Ajax with Ruby which if you're new to
programming trying to learn Ajax is like
throwing someone in the deep end it was
a lot scarier than this I'm started here
but then I wouldn't know how good I had
it I guess um a couple things that made
it better was umbrella apps so making it
easy to go in and out so we had Robbie
web where you could edit the templates
the views all of that SMS code
so if someone forgot their password we
could go here and be like okay this is
how of texting the information goes if
we wanted to text all the users in
Robbie to troll them or something this
is the code that we would look at if we
want to write or read to ldap there were
different directories for that and then
we had a ldap wrapper so that if we
change our back in if we don't use ldap
anymore to store our employee
information we could sub out ldap read
and write and the rapper would still
function as an in-between it with little
editing to make it work so this makes it
so much less intimidating to go in and
fix and change things and add to it
rather than going through this nearly
thousand line file with all those
discussing comments and code that I
couldn't read let's just simplify
everything significantly for me and then
we even got to have some fun we added a
guessing game where it pulls pictures of
employees I censored everyone's last
name because that seemed like what I was
supposed to do even though I don't think
you can read that from here anyways and
it's an easy way for new people and
folks who have been there for a while or
remote employees especially to guess who
like you see a picture you have a bunch
of names there's some bonus rounds where
if there's a really common name such as
like Nick or something you can see all
of the Knicks and you have to guess
which nick is this one picture just as
an extra hard mode and we have a little
high score and the scores are all kept
with ecto as individual game place so
you can pull the stats really easily
about it and it just handles the user
the choice and the right option with a
couple of other features such as request
a better picture like my picture and
Robbie is a cat so I get emailed
constantly from this little button that
we implemented saying hey I don't know
who you are can you have a better photo
but since i made the tool and I break my
own rules so it's for everyone else it's
not for me and it also handles no choice
so if you try and just hit the next
button without picking someone you know
what it knows what's up it's not as dumb
as most
we also had some fun so we have we use
hipchat a lot and sometimes HipChat goes
down so as an exercise and how to use
channels we've built a little chat room
inside Robbie so sometimes when hip chat
is down you can go in and at first we
didn't have like we didn't scrub out
HTML and stuff so people went a little
crazy with that wish I had screenshots
up there just like shadows yeah putting
more keys in it and then it got a little
more hazardous oversized so we had to
update that pretty quickly just as a
testament to how easy these things are
to spin up though like this happened in
an hour and a half I think one day when
the whole company was just grumbling
about how impossible it was to
communicate so it quick and easy yeah no
it's it's been really awesome and it's a
tool that everyone knows and for april
fools I changed everyone's picture to
the CEOs face because it was just so
easy to edit and it's a great site for
pranking and our company is pretty probe
pranking like moderately luckily the CEO
has a good sense of humor so I still
work at puppet I don't know how I'm
going to top this one though I mean is
so good but I had the confidence to go
in and edit Robbie without thinking that
I was going to break everything because
it's kind of scary to be like oh I'm
going to change everyone the company's
photo to this and hope that at the end
of the day I can change it back and it
was fine if everyone doesn't look like
this anymore except for the CEO he still
feels like that and overall we packaged
it with Jenkins we deploy it with puppet
good ol puppet behind a VPN because we
have to keep the data sent you know
sensitive data is private so we can't
use Heroku or something
and it's been really successful we don't
have to restart it hourly it's easy to
update I can touch the code again like I
can use my own project and update it it
isn't abandon it isn't run away like
it's it's ours it's real and it's still
in use and new employees aren't set up
to fail anymore they're like oh here's a
tool and it actually works which in
technology like maybe half of the tools
work ever I feel like so if it's a
relief to be on this side of it and I
mean using a lick sir especially from
coming from Ruby it prevented me from
falling for programming mistakes that I
fell when learning ruby because the
architecture and philosophy of the code
encourages good programming habits and
that reflected on our team and how the
team approach problems too like we broke
it down easily is easy for us all to
have interchangeable parts it was easy
for us to own different parts while
understanding what each other's sections
all did and be able to completely edit
those as well okay so after our first
big Phoenix project now our main main
application that we're working on any
team is a data warehouse so this data
warehouse is an application that
collects sorts integrates and stores I
can go to the yes integrates and stores
data from all sorts of different tools
and services we use across the company
so sales data customer service data
somewhat little telemetry data we have
and it's a platform for analysts and
business intelligence tools to use so
this is another rewrite and I wanted to
talk a little bit about the former
application just to give you a little
stark contrast and for our elixir
project so this is our current data
warehouse it was written in the space of
five weeks after somebody split-second
decision not to renew
a contract with an external data service
so very small time crunch to get this
whole application off the ground and
because of that a full data load of all
our different sources takes would take
eight hours from start to finish which
is ridiculous so we couldn't do this
more than once a day we can do this more
than once a week and and so we had to do
incremental refreshes all the time to
make it made our architecture even more
complicated so the reason that it took
so long is because the main task logic
was in one giant Ruby script that was
three hundred lines long and we have
cron jobs managed by puppet which by the
way is not a good puppet practice to
kick off this script every once in a
while and there was a little bit of
concurrency we use JRuby which also
cause other problems right so if you
want if you want to use JRuby you can't
use a lot of gems that just won't aren't
compatible at all right so the in this
script we would load one data source
after another this caused all sorts of
problems with dependencies that were
completely unnecessary so if we have a
problem say a change in the data
contract of the sales data API that
doesn't without notifying us and that
bit crashes then the rest of the data
doesn't even load we don't even get to
the customer service data and for a
business data application this is silly
right this is a problem we don't want
the success of one data load to be
dependent on the success of one that's
completely independent from it so
basically this application is full of
terrible anti-pattern spaghetti code
unneeded dependencies but it's also
understandable right because in our time
constraints the mental and emotional
energy required to implement concurrency
and Ruby five weeks is just not enough
so needless to say whenever we wanted to
change something at a future add a
couple fields the whole thing would oh
yeah and running on a single server
forgot that the whole thing would go up
in flames so we were very pleased
relieved to let go of this horrible
application that we've been depending on
limping along on for the last two years
to call this a rewrite this is our
elixir gap right to call this ovary
right would really be an understatement
of the the incredible improvements that
were enabled by elixir in terms of
segmenting failure and sort of
increasing the reliability of our system
so in the same amount of time less even
this is for weeks same amount of
developers two people working on it we
were able to prototype a system covering
all the same basis as our last
application and we decreased our load
time to 45 minutes and this is the time
it takes to load the largest object that
we have in sales force which is sixty
percent of our data in Salesforce how
did we do this we used it we did it with
a lift sir an OTP of course so utilizing
the supervisor structure and making Jen
server processes to for the sort of
smallest independent chunks of work that
we could manage so we end up now with
four I think four or five data sources
we're eventually going to have around 50
we have 1300 processes instead which I
guess according to Robert is not very
interested
but it did just things to me right I'm
used to single threaded code so in this
way we're able to to staunch the flow of
failure at the the lowest level so if
one data source fails for any reason or
even one object in that data source
fails we can try that a couple times or
kill it all together and let the rest of
the data load happen unaffected and also
added side a side effect bonus is that
because of the way we've structured our
application using a message queue
architecture we can now throw our
application up on many servers as we
want four or five and in that way
horizontally scale without any extra
work at all because we have that the
instances on each server just listening
to the same central message server
sounds a lot okay so this has been a
really fun project and I've learned a
lot about the sort of nitty-gritty of
elixir and oh no TP and I wanted to
share a couple lessons that I've learned
and problems that we've run into and
solutions that our team has generated oh
yeah five that's the number of servers
that's up on the screen currently we
forgot to warn also in the beginning
about a motion sickness there's a lot of
zooming in this presentation so if you
get woozy at all just like put your head
between your legs and take a couple
breaths so Oh Robert touched on this a
bit the first lesson that I wanted to
share is that elixir processes are not
Ruby objects and should not be treated
as such and so you might take pause at
this because you hear a lot that
processes and jen server is elixirs
answer to state right this is how we can
do non trivial things with our programs
otherwise we just be sitting around and
doing a bunch of math problems but well
it's a it's a well warranted analogy
it's it's dangerous and that's because
the environment that we're working
is different so if you take an object or
something you can treat like an object
and put it in a concurrent environment
all of a sudden you've opened yourself
up to all sorts of of dangers and
pitfalls so what does it mean to treat a
process like an object to you look at
one so this is a process taken from the
data warehouse application it's the
extract worker so it's responsible for
pulling data from some external service
and when our application starts the
process is just there sitting on the
beam until it receives a message that
says hey it's time for you to do some
work so then what our extract worker
does is it calls out to the external API
gets the data and stores it in a state
now this is what I'm doing as a Ruby
programmer we're going to change this
process in a second so extract or Gert
has the data in a state and some other
process somewhere else in our
application is alerted to this fact this
is the insert worker that's responsible
for doing some stuff to the data and
putting it away so it makes a it's also
a process that gin server makes a gents
or a call to the extract worker extract
workers like oh yeah I have that data
here here you go you take it and then
the insert worker does some stuff with
it right transforms it and then sends it
off to the database ah ok so this was my
first instinct as a Ruby programmer
right then my extract worker is sort of
analogous to what I had in our original
Ruby application where I have an
extractor class that i initialize with
the data and then later on in my program
can access edit few whatever too but in
this environment we run into some
problems and we open ourselves up to
on one in side effects so right now the
problem here is that we have functions
inside our insert worker that are impure
because they're making a gin server call
out and using shared state basically
treating extract worker like shared
global state we have functions that
depend not only on their input but also
the state of an external process and
this is bad news very functional
programming is bad for testing at least
all sorts of complex complex structures
that we just don't want to reason about
so if you see this in your code kind of
need to take a step back and try to
instead implement something more like a
data flow so this would be a more
optimal way of implementing that where
instead our extract worker just receives
a message when it does its work it sends
the entire chunk of data to the insert
worker which does its work and trade-off
here is that the extract worker needs to
know about all of the recipients of its
data it needs to to know who to send it
to so everything's great good not quite
there's another problem with this
picture and that is what if our extract
worker just goes up in flames in the
middle of doing its work before it's
able to send an 80 on so say the server
requests times out well as robert was
saying we don't have to we don't really
have to worry about failures right this
is literate Erlang's OTP our worker is a
part of the supervision tree right so
when it is kicked it'll just get
restarted by server in fact I have a
little quote taken from the elixir Lang
front page website to cope with failures
elixir provides supervisors which
describe how to restart parts of
system when things go awry going back to
a known initial state that is guaranteed
to work and this is where we run into
our second problem see the the insert
worker is not going to be useful to us
if we restart it in its initial state so
what we want is not only our gen server
to be restarted we want it to be
restarted with the work that it's
supposed to do because if we kick it and
it gets booted up again by the
supervisor is just sitting there it's
lost that message that it received and
we don't want to lose that data load
right we don't want to lose that run so
turns out that supervisors are not a
cure-all and sometimes we need to extend
or thinking about failure a bit beyond
beyond then who okay lost track I've
gone ahead of my notecards 18 water yeah
do I sound us in the solution that she's
about to talk about does get solved in
the future as we learned at Orlando
elixir huh but yeah so what we need in
this case is a pub sup right we need
some sort of message queue where we can
send and receive messages between our
processes in a durable manner right so
if a message doesn't get delivered it's
not lost and with Phoenix pub/sub and
potentially some some assurances in gen
stage with flow as we heard about in
Chris McCord's keynote and also Josie's
keynote in orlando might happen in the
future or will happen in the future but
until then yeah we have an interim
solution using rabbitmq and a message
message cute architecture so I'll
explain this a little bit so this is a
similar picture to what I had before but
expand it a little bit that triangle
that first triangle is
and exchange so we'll have an exchange
for each of our data sources and then
each object within that data source is
going to subscribe to its own cue that's
bound to that exchange so when a message
comes in and says hey it's time to do
that work then it fans out to all of
those cues and then consumed by the or
extract workers which are now
subscribers to this message queue when
they have finished doing their
extractions they will send the data in
packets of in this case to another
exchange because for each object we have
we want to do several different things
with that object so we'll have a a
different workers subscribed to the
exchange for each object within the data
source so a little more complex and it
has to be but right now this picture
looks a lot like what we had before but
just more complicated right what benefit
does this give us and the key here is
that we want durable cues so it's this
last line in here that is what is really
important amqp is the library that we're
using to interact with RabbitMQ so
there's no ack set to false which is
really the same as accent2 true requires
us to explicitly acknowledged that we
have received the message to rabbitmq so
at the end of of all the work that the
insert worker is doing after its
senate's data back onto a different
queue then we acknowledged that we've
received a message and the message gets
deleted from the cube if on the other
hand the insert worker dies then it's
connection to the message queue dies and
that message gets sent back on to the
cute and is received again when the
worker is restarted
so this is if you're interested at all
in RabbitMQ there are great tutorials on
their website and they're actually code
examples up in elixir for amqp provided
by jeff weiss from us on our team yeah
Oh last two quick and so I have one more
thing that I wanted to talk to you about
that sort of touches on the multi
lingual section of Roberts talk and so
we are building a data integration
platform right it's sort of its main
function is to go and talk to the rest
of the world and get a lot of data from
it the problem is that the rest of the
world speaks Ruby oh not elixir so there
is a huge ecosystem of gems for
interacting with and accessing a
thousands and thousands of rest VPS and
I'm wondering now that where we've
decided we've made this decision we have
our prototype up and running
everything's great we have four data
sources going I'm wondering if we've
just condemned ourselves to writing
client libraries for every data source
that we want to access using elixir and
the answer is we gets the answer here
not necessarily so of course like there
we do want to contribute to the elixir
ecosystem so sometimes you just bite the
bullet and write the library and when
you do you realize it's not as bad as
you thought it might be so these are
just a few of them that we've written on
our team force x is for interacting with
salesforce greenhouse is a recruiting
software ecto ldap is an ecto adapter
for ldap if anyone else and
world means to use that you can find it
talk to us and I've stacked is for
intact which is an accounting finance
and accounting software and so it's not
so bad i heard i was talking to Jeff
wise who wrote Force X and he sat down
and in about two hours of coding he had
said he had got about ninety percent of
the functionality that he used of the
ruby gem database com which is not too
bad right so but we don't have time to
do it for everything right like we have
clients we have customers we have
deadlines and we need to get our
adhesive our job done and like yet fifty
more data sources to do this for so we
can't spend all day writing elixir
libraries so in order to use elixir in
production and still get our jobs done
we've exported some of that work into
Ruby so oh no my code is not there it
again yeah sure oh there it is okay well
i had that so it doesn't distract you
now remember right so this is sort of
interim like very naive solution that we
have that allows some of our sub
components to shell out to the host
system and execute ruby or you could use
python whatever other code you have in
through our OTP supervision tree so we
already the reasons for doing this we
already have decent Ruby code that does
this from our last application right
it's not it wasn't the code for talking
to the customer service portal itself
that was the issue was how all of those
components were strung together so now
that we have a sort of task skeleton in
a lick sir which is the strong point we
can sort of recycle that code which
wasn't so bad in the first place and we
also have other people who want to
contribute to our code base to our
project who aren't a lizard
is their main languages Ruby and we want
them to be able to add to our system and
right sub components in their language
of choice that can just hook in as they
wish so we have devised a shell worker
we call it that is really fairly naive
you could use messaging for this as well
but we decided to just trust that those
other programmers know what they're
doing I'm good idea so my worker now is
going to look like all of the rest of
them it's still going to subscribe to a
message queue and then when it's done
send a finished message off to another
message queue but when it's time to do
the work in it this is quickly becoming
my favorite favorite elixir function it
calls system CMD with a command that the
chance server was started with and you
can pass it environment to in this case
it's the database that we're connecting
to and we just assume that if the
command exits with the zero codes and
everything was planned and we can
acknowledge that we've received our
message that a QP act and otherwise we
either try to redeliver the message or
rejected completely if we fail too many
times and so yeah in this case our
command is do some stuff in Ruby but it
doesn't always have to be the case you
can do whatever and this is just a sort
of a simple example to show that it's
possible and not sort of out of reach to
hook languages into one another this is
sort of the simplest solution that we
could we could imagine okay that was I
think that's just about does it those
are the three lessons respect your roots
what were the other day elixir has
helped us streamlined a lot of what
we've done in the past without having to
abandon ever
thing that we were doing before elixir
learning it all on a team has been
really great because we've all been kind
of on the same page even if someone is
more advanced like peer program and is
still really helped all of us with
learning elixir with building each other
up our applications crash way less which
is a good thing yeah an overall elixir
and Phoenix have been like really
awesome to work with excited for the
future yeah also I know this conference
is about elixir and production so if you
want to hear a little more about that
pipeline that we have for rolling out
our own elixir releases you can talk to
either one of us or aura also there's a
few medium articles also by Jeff whites
that sort of explain in a nice how to
that system don't get you on your feet
so if you want to get your application
like out there in the world so that
people can use it okay I'm not sure we
have time for questions or if you just
want to find us afterwards
okay yeah please do we should have our
contact info up here i'm gabriela at
puppet calm if anyone wants to reach out
about anything Marnie
yeah yeah thanks for that what what are
some challenges that you found in terms
of getting these things into production
deploying these things because I think
that's an area that's still quite
challenging in many ways so i mean just
see what you sort of did I mean one of
the good things is that everything that
we deploy is internal so I think that's
made of a lot easier for us and we have
an elixir fanatic on our operations team
so we have sense of 50 there and if you
want to talk Yeah right now we're using
a combination of e XR m and conform
which are I don't have to say is that
Paul schoenfelder someone help me out
there no okay those are his libraries
that I think are going to be replaced
fairly soon with a new one that he is
working on so conform it helps with
production configuration so allowing you
to change change and set that separately
from packaging your release together and
and ii xrm makes ODP releases so that
has Erlang and everything you need to
run the beam all packaged up into your
release and then a head start sort of
like going through our pipeline it's a
sure use a lot of trial and error to get
there but right now I just have the end
cut in mind and we're hosting on debian
machines so we used fpm which is a ruby
gem actually it stands for
package manager because it just gets the
thing done oh and it makes Debian
packages which we then hand off to our
ops team and big deal with making that
repo available to our puppet code which
we have on our production machines and
not just make sure that we have the
current version of our software running
on that machine does that sort of I mean
that was just an overview it didn't
exactly I'm else do I thank you okay
thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>