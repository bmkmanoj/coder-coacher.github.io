<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Completely Unbiased Showcase of Elixir by Andrea Leopardi | Coder Coacher - Coaching Coders</title><meta content="A Completely Unbiased Showcase of Elixir by Andrea Leopardi - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Completely Unbiased Showcase of Elixir by Andrea Leopardi</b></h2><h5 class="post__date">2016-09-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EPXZ6VLiZuo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello so just I need to the usual show
events so just to calibrate I think
we're all here but if you're not here
can you raise your hand okay everyone's
here if you didn't get it no worries
so who knows elixir more than Erlang
here it's a few people who knows Erlang
more than elixir who doesn't know what's
going on don't do this if you don't know
what's going on
all right so nice less like few people
that's good so first of all I was back
home in Italy until a few days ago
and my mom just got this guy girl home
so it was so so hard to like took the
cars to stop cuddling that and come to
the conference so I really appreciate
the opportunity but it was really hard
really hard I didn't hear all for this
can you oh that's that's better thanks
so let's talk about elixir or as it was
called originally LFE which standard for
loveable fun or long we settled for a
less controversial name which is air
long for eaters of course we wanted to
go with Erlang 2.0 actually but yeah
elixir was kind of the good middle point
so what is elixir I think in the I like
to have these like kind of languages
that are related to other languages
scale so from JavaScript CoffeeScript to
JavaScript Elm
I think elixir is kind of in the middle
is it like same relationship as Java in
closure have so closure compiler to Java
bytecode
runs on the JVM and elixir is basically
kind of the same for long so it compares
to Erlang bytecode and you can run it on
the beam it's not just a transpiler like
CoffeeScript it just combines two
JavaScript source code it's not
completely different paradigm I like
early Elm that just changes everything
and compiles to JavaScript so it's kind
of in the middle
and then just it's just this is just the
language the runs on the beam and deep
down it just complies to beam files and
it just Ireland basically once compiled
and it's a pretty young but quite stable
language the 1.0 was released in
September 2014
so roughly two years ago right now we
are at 1.3 which means we didn't have
any backwards incompatible changes for
two years right now and we have we had
like bug fixes and improvements but
everything is still stable two years to
now so it's pretty good I think and what
I'm going to talk about is the good
stuff that I think elixir has the neat
stuff that there's in elixir the stuff
that I think we can improve in elixir a
bit and then I'm going to talk about the
relationship between elixir and ere long
so my name is Andrea that is my handle
on github and Twitter everything I work
as liner say that football addicts in
Gothenburg which is a company that makes
a live score football up I'm not a
football addict but I work there and
we'll be using elixir in production for
a while now I think it's interesting
that I work with another core team
member of elixir so we're proud to be
the company with the highest number of
core team members in the world of elixir
and that's it so let's let's dive in
let's start good stuff I'm going to lean
a lot on the good stuff in this off it's
going to be like 95% good stuff
0% improbable stuff 5% elixir in Erlang
because I just think that's like a lot
of good stuff so and not that much
improvable stuff so let's start with
this and so tying into what we Fred said
yesterday in the keynote I like put a
lot of attention into making tools that
shine making developers happy writing
Erlang
and I think you will like see this theme
of developer happiness recurring into
the features that I will show of elixir
there there's a lot of stuff like made
for just for the happiness of the people
that program in elixir the first thing
is a standard library I think elixir is
a really great standard library it's
it's really really consistent especially
compared to Airlines ever long one
for example in Erlang you have this you
don't have a lot of like builds setting
stone conventions so you have some
modules that occur like plural like
lists maps then some are like singular
like string binary so in elixir we fix
that you have placement of argument in
Erlang that is not very consistent so
some modules like binary the subject of
the functions look which is really
usually the binary goes as the first
argument in lists it goes as the last
argument and it just weird conventions
and in lakes where we fix that as well
but this is I mean just smaller stuff
but make makes me happy at least and
then we have binaries all over the place
rather than char lists which i think is
a good design choice and i see this
happening in l on libraries as well
moving away from Charlie's and going
over to binaries so it it has to mean
something we have awesome Unicode
support that's just awesome Unicode
support and streams I think it's a real
nice thing that we have built into the
standard library so let's talk about
that a little more so what are streams
it's a they're basically composable and
lazy enumerable so instead of executing
computation on an enumerable so on the
OL enumerable we can just basically when
we compose streams we just store the
computation in the stream and delay it
for later until we want to actually
execute it and when we execute it it's
executed one element at a time in the
stream the whole chain of computations
that we store it in the stream so
it is easier to see with an example I
think in this example we're taking a
file food txt we're just streaming lines
out of it so creating a numerous
innumerable innumerable of lines a
stream of lines out of this file we can
map some something some function over
these lines we can do other stream
operations we can filter we can do
whatever we want on this stream on the
elements of the stream we can call map
multiple times them up different
functions on the elements of the stream
and then but until we call a Newman to
list which actually turns the result of
this stream into a list
nothing happens basically we just store
this computation in the stream and not
not not execute them at all and when we
execute them in an m2 list they will be
executed one element at a time so
basically what stream will file that
stream will do here it will yield kind
of yield one line at a time and then
when that's when we're executing this
when the line comes out of the file then
we map the function over the line
then we can do the other stuff that we
do in the stream like we can filter it
out or we can mop other functions over
it and then put it as like store it as
the first element of the list the denim
to list is going to return and then the
next line is going to be fetched so it's
going to be done in a streaming way if
you do this if we did this in a kind of
eager way we would read all the file
split it into lines and that's another
list map over this and that's another
list do other stream stuff and that's
maybe other lists and then we just like
end up with a final list but this time
we just build one list with all the
lines of the final operations that we do
on them and this turns turns out to be
really useful in a lot of cases this is
really really good use case when you
don't want to load that huge file into
memory make a huge list of lines from
this file and just over it create copies
of this list while you're operating it
and I think this is really really neat
next feature this is a mattre
programming I think this is probably the
feature that sets its
apart the most from Alex from our long
story and I think from quite a few
languages as well but this is something
that very long really like struggles to
do and it's so basically it's a lot of
folders a lot of focusing mixer on the
compile time features and what you can
do a compile time so you have to know
that when elixir code is compiled is
actually exit like parts of the parts of
the source code that you write is
executed in elixir so the content of the
content of the functions is not executed
but the like module definitions and
function definitions they're just
selects your code being executed so you
can do stuff at compile time to kind of
inject your stuff into that process and
a classic example is what you can do is
you can at compile time generate
function clauses from dynamic data for
example from external data so one
classic example is I have a file of
stuff and during compilation time I can
read that file and turn that file
somehow into a bunch of clauses function
clauses so that the contents of the file
are basically bundled into the beam file
that I'm going to have at the end and a
concrete example of this is actually in
a lecture itself so x0 comes with a
Unicode database thing which is a text
file and at compile time when you
compile a leak sir elixir will just read
this file and generate a bunch of
function clauses for for example for
finding the next code Unicode code
points in a string so will generate this
so that the this will be done through
pattern matching in the function at just
by reading this file and an ardent super
useful thing that this compile time
feeders allow is the use of macros so
macros are just basically functions
that's instead of taking values they
take the abstract syntax tree so the
shape kind of shape of the code of the
argument and they say SC in lick series
just code so it's just a elixir data
structure
we can manipulate it and this these
macros they take the ast and the return
ast so quoting quote is what returns
turns some code into ast unquote this
kind of interpolation to inject the code
that we had originally into the code
that we're going to return this is not I
don't mean to explain this like to two
very in-depth but just to get an idea
this is a classic example is to write
unless as a macro having hip if so if
you read it as function since we have we
will evaluate both arguments first
before invoking the function you would
evaluate both the condition and the
expression even if the condition is true
for unless but if it waits as a macro
you will literally just basically
replace the call - unless - with this
call to F which is just what you would
write if you were didn't have unless and
this means this is a this is what
happens so at compile time if the
compiler encounters are less it will
just call unless with the ASC of their
arguments that it sees and replace the
unless call with a code that unless is
going to return so you can basically
build code and this since the code is a
data structure elixir data structure you
can manipulate it how are you however
you want and this turns out to be really
useful for a bunch of stuff and this is
so these macros are not to be confused
with Erlang markers so they're not
preprocessor markers they're actually
actively run in the completions process
they return data structures they don't
this code is not pasted like where the
macro call is there's a it just injected
as as in the ast as a data structure for
the further code and they're hygienic so
they don't leak macros they don't you
don't have to worry about parents
because then it's going to be syntax
errors or this kind of stuff like in C
or or Iran and next feature so it's a
struct basically structs are same as
very similar to Erlang records so long
record you know are these data
structures with
with named fields they're based on
samples Strax are very similar they're
based on maps though and you just define
them attached to a module so in this
example we define a user module and we
define instructing this module with the
name and age fields this makes makes us
able to call the user use the user data
structure underlying is under the hood
is just a map with a special fields like
records are just double with the first
field as the name and they're really
basically comparable to records they
have I think if few advantages but the
probably the big one is that they're not
copied when updated so tuples are copied
when they are up when you update one
field of at Apple but maps are not
they're not copied the whole map just a
just a field and this means that if you
have like they need to update records
very soon these very often and they're
huge records is going to be problematic
for memory especially if it's not like
say it called optimal or something and
this is quite a common case because
usually records I use this state for 10
servers or is take machines and in a
lick Siri I think it's more common to
use tracks and this is one advantage
definitely and then this kind of they're
kind of the official data type for
elixir like kind of records are for
airline and this allows us to do other
stuff that we'll see later and then we
will see with protocols so this is
another feature and so protocols are a
way to extend for like a way for to
extend stuff and so in Erlang the basic
extensibility mechanism is behaviour
right so if I want the user to be able
to extend something that I'm doing I
will give I will say them give me a
module that implements this behavior and
I will call it and know that it will
implement this interface and I will be
happy that I have this but and be able
to extend my mind code so the only
polymer phase is in
a versus just modules the module name
actually because the only thing that I
can accept this the module name and then
then module will implement a given
interface and we'll know what to do with
this data
but with that interface but it's just a
module but protocols are they switch the
polymorphism on data types instead of
modules so basically I can say I have a
set of I have an interface that operates
on a data type you can implement this
module this protocol for this data type
and for all the types built in and that
you creates and this probably easier to
understand with an example so classic
example is a JSON link if you want to do
JSON encoding so in Erlang what if you
wanna include custom kind of cus
whenever a becomes custom encoding rules
for your data the only way you can do
this is to like have a convention in
your library that says I will encode
every since tabble is not a black
meaningful data structure to encoding
JSON you can say okay tuples are what I
think are special data structures that
you can encode as where you want and the
way you tell me how to encode tuples is
by telling like having the first element
be a module and that element and then
modulus to implement a given behavior
and then I will encode I will call some
function in this module from the
behavior some callback and then that
that callback will know how to encode
encode your structure so this is not
very strong I would say because it's or
stable because it's it has to be kind of
convention from the library side writes
there's no there's no universal thing
that works like this but with protocols
this becomes super super easy because
you just define a JSON protocol which is
same as a behavior it's just a set of
callbacks that interface that data
structures have to implement basically
and then you implement this module for
this protocol for data structures and
then you can just call JSON dollar
encodes on anything and it will call the
right
cementation of encode for that given
thing it can be done with criticals work
in the example i say def input json for
user so i'm defining the implementation
of the JSON protocol for the user struct
which as I said is kind of the data type
in elixir this is how we distinguish on
like create custom data types so that we
can implement protocols for but I can do
this for built-in data types I can I
could use like list and define this
protocol for lists by a binaries I don't
know whatever and this means that it's
really easy to either create a protocol
and let other people extend it or create
a data type and extend a protocol that
other other people implemented so it's
very makes things very pluggable another
really nice feature is the testing
framework that we have an elixir which
is called xunit and it's kind of on the
same wavelength as EE units I think it
has a bunch of more oops
hello I only have one HDMI in here
nope summer long people are sabotaging
this talk I'm sure oh there it is
alright xunit I will talk about this
anyways this is a testing framework it's
kind of the same wavelength as a unit in
Erlang I think there's a bunch more
features is more like a fusion between
units and common tests but anyways it's
a nice DSL for writing tests you have
like this test blocks you have this
assertion Makris that are macros like we
talked about earlier so they have the
their macros in Erlang as well but since
they get the they can like do more
inspection on the code that they get and
they mean and they are really helpful
when the assertion fails because having
they SAS see of the code they usually
can show you the code that failed for
example or I mean just have nice reports
when something fails and have more
insight on the code that you're trying
to assert so if your assert between for
example an equality between or something
on a binary operator you can detect that
this is a binary operator and just say
this was not equal to these if they
operated was equals equals if it was
different you can say this was equal to
this so it didn't match the different
operator or stuff like that I mean it
makes for really nice a certain failure
messages and we have a bunch of other
nice features in Ex unity of tagging
tagging is just you can talk tests with
some properties and then you can like
run run tests just for a given tag just
for subsets of tags you can skip tests
for a given tag I use this all the time
for like integration tests I talk them
as integration and then I don't run them
when I want like fast tests or I just
say exclude integration when running and
just really straightforward
we have diff when there's an assertion
fail failure with like
for example the Equality operator so
this is this is what happens when you're
when it test fails you get the actual
diff on the where it failed it doesn't
work on strings only it works on old
data types so if you have a huge list to
huge lists and they differ somewhere the
diff we lie I highlight the elements
that differ in the two lists as well and
it's useful in a bunch of cases it works
on maps you work on works on table
doubles but it works everywhere and then
we have this nice features called
feature called sale in mix which
basically lets you avoid running stale
tests so what happens is you run mix
tests - they're stale the first time it
builds a manifest of modules that are
referenced by tests basically and then
when you rerun mix tests - they're stale
it will only run the tests the
referenced modules that changed things
the last time you ran so you basically
just change something something run mix
tests - they're stale and you will only
run the tests that are connected to the
something that you changed so it makes
for really a quick feedback loop yeah
another great thing I think about elixir
is the inter updated as with Erlang so
you can actually do real stuff not just
play around with ep languages and
basically this since I said that elixir
is just along at the end of the day air
long is just elixir as well in some
sense so basically if you have any
Erlang expression like this this is a
mapping over a list with a function you
can read this in the lick sphere as well
the exact same semantics with a slightly
different syntax but the semantics are
exactly the same you have the same data
structures you have the same I mean
modules same functions a way to call
functions it's exactly the same and this
is actually it's not something it's not
like shelling out or going out twirling
it's just integrated is integral part of
every elixir project I've been working
on at least
because it is the recommended way to do
stuff for example there are it's not
usually it's not recommended to just
ripe right elixir wrappers for airline
modules to just wrap the modules so
there are so elixir sign the library
when it adds the module to the center
library it does because it announces
something related to elixir from the
airline alternative and for example our
modules that just are not wrapped in a
lecture and one like good example I
think is Gen TCP for example so gentes
or jente sippy is not wrapped in elixir
so if you want to use gen TCP sockets in
Aleks we just call the Gentilly module
from Erlang and it's just you use their
API you you you go through their
documentation and you just use a link
with a slightly different syntax and
this is actually kind of true in the
other way around as well so theoretical
it's it's really easy to call elixir
from Erlang as well right now that just
it's just the tooling problem I think
but once you load the elixir code in in
Erlang and you have access to this
compiled elixir code you can actually
just call elixir from Erlang with a
slightly different syntax so you can see
that in um the module name in elixir is
actually the item elixir dot in arm but
once you have that figured out you just
use your lungs in texting you can call
the same functions defined in by elixir
you can call a liquor code and just get
same results and as I said I think this
is mostly a tooling problem but it's
this is definitely possible it's done
somewhere in like the insides of elixir
so next great tool is a mix so this is a
this is a kind of the build tool
compilers dependency management custom
tasks generators everything comma line
tool for elixir and it is basically what
it does what rebar 3 does right now but
is I think it's better integrated than
rebar 3 so Reba 3 is catching up right
now but makes it still more more
polished I think than rebar 3i
is more integrated into elixir and it's
I mean it's the right I think it's the
right way for rebirth 3 to be in the
future but yeah documentation we have
great support for we have great
documentation first but we have also
great support for writing documentation
so we we can we have a to collects dock
and the generates orientation and we
store documentation in the code so you
can write documentation in your code and
will be attached to the code in the you
can retrieve this later programmatically
so it's just code and attach to the code
that's just a string and then we have
this tool called hex doc which reads
this documentation formats it to nice
HTML and you have like pages of
documentation and this we have this
website Eric mentioned X Docs where you
can publish this documentation as well
for packages and this works for our long
as well can publish stuff too long as
well and it makes for really nice it's
really nice support for documentation
you can use this for documenting modules
functions types and whatever you want
one great thing about elixir that is not
strictly a feature I think it's it's the
onboarding at 10:00 this is this is what
I meant when I said that this ties into
what Fred said yesterday we have that we
need to kind of care about users more I
care about users happiness more and
onboarding is a really huge part of that
I think and like onboarding elixir is
kind of I think straightforward and I
hope it's a pleasant experience but and
we have like this really great getting
static guide which is like a pages of
guides just gets it up with a leak
theory becomes yeah it has like super
simple part of the beginning then more
complicated parts as long as you grow we
have a lot of resources like books
tutorials blog posts we have like a huge
list of books just about elixir we have
like good error messages this I think
just random thing that's I think it's
helpful for like new users
and we we kind of have the model that's
if it's a bad error message it's a bug
right which is not really I mean Erlang
just settled for bad argh like whenever
you can and and it just kind of says
okay but this like we try to like be
more informative when error happens and
how to find a solution and just have
good error messages in general and
another thing that I don't I know it's
not a feature but it's good for elixir
set like we know libraries we have the
best libraries we have this was a quote
we have a Phoenix which is a like a
really nice web framework it's for doing
used a lot for real-time web
applications and it's driving a lot of
people to the beam I think it is
probably one of the most like the thing
that drive drove people the most lately
into the beam a lot of a lot of rails
developers but still good that we have
people and then we have nerves which is
a really interesting kind of younger
project there is a framework for
creating and running elixir application
on embedded devices so there's a lot of
like excitement on that area as well we
have a lot of great libraries like actor
which is like the database abstraction
library blog which is for HTTP stuff
just stage for kind of reactive
programming stuff and it's we have a lot
of good good libraries already even if
the language is quite young and then the
last thing I think it's a community we
were I think a really really great
community this is why I like went into
elixir in the first place because it was
like friendlier than other places and
just just went there we have a very open
and helpful community and everyone will
try to I think be helpful if you're if
you're a beginner this i've never kind
of never experienced any any kind of bad
stuff happening so this is good now to
the improvable stuff so what i think can
be improved in elixir not not a lot not
not a not a lot but definitely one thing
that can be improved is dialyzer
so dialyzer kind of works with the
elixir so is not good with tracked
structs it kind of gives a lot of false
positives with Strax it kind of shows
it's kind of weak weaknesses with macros
because they they just mess with the ASD
and there's weird stuff often so it's
kind of it could be improved a lot for
elixir and right now honestly I just use
it for recommendation because I want
people to know the like type specs on my
functions but I've never basically never
run mix dialyzer and to actually check
type check the code so this can
definitely be improved in respect to
Erlang
I think property based testing can be
improved as well because we have a few
young property based testing libraries
we don't have as many as we're long as
many established ones zero line but
mostly we have I don't think we have a
culture of writing property based tests
right now so people don't even look for
these libraries it's just there's none
is not in the bloods of elixir
programmers yet and then I think the
biggest point that we should improve is
the way we use elixir from aerilon
because we're so happy to be able to use
Erlang from elixir and we do this all
the time and we so our long it gets
better elixir gets better real long gets
a good library elixir gets that good
library as well for free and this was so
this has been really unidirectional from
from Erlang to Alixe you right now so we
can super easily use a leaks airline
from elixir benefit from all the good
stuff but if some someone from Erlang
wants to benefit from good elixir stuff
that's going to be a problem right now
and mostly as I said a tooling problem
because like theoretically it's this
super straight is the same thing they
just compile to beam so it should
interact based basically it's the same
thing but right now this is not the case
and of course there are cases where it
doesn't make sense to call elixir from
Maryland one example is micros of course
so you can call Mike rose from elixir in
Erlang because they're a LAN compiler
one know how to expand the macros but
still allowing to really easily you
elixir from Erlang this way I think this
will be the breaking point where we
actually can bring the communities just
become the beam community and not the
Erlang community and elixir community
because we have a like we have a lot of
great libraries we have a lot of we have
X so we have everything is already in
one shared place so it would be really
awesome if you could just make this make
possible to use elixir from ur long as
much as we use Earlham from elixir yeah
and then this is the last point of the
salt which is the relationship that that
we have right now from elixir between
elixir and airline so one thing is so
there's the thing about the syntax a lot
of people say that alex fears better
syntax in airline I think syntax is just
syntax so it takes it takes a little
time to learn both under the hood
there's still the same language so it's
not important and since you in elixir
you call air long a lot you basically
and you like surf to surf through Earl
and documentation you use the same data
types you know or long modules because
you have to use them so basically
learning a leak series you can learn air
along at the same time you will learn
air long at the same time it's just a
matter of writing your line in your lung
syntax and instead of elixir syntax at
some point so I don't think syntax is a
huge problem but someone does but so
elixir is is actually just an
application so it's not it's really
nothing special at this point and once
compiled it's just you can see here it
is a screenshot from observer running
just elixir and you can see kernel
application from Maryland the can see
logger you can see elixir just regular
apps so the question I really like to
ask myself is which one do I use when I
have to write a library mostly which one
we do a user longer use elixir so this
is a completely unbiased tool so I think
you can use whatever you want but my
feeling is just please appreciate both
because they're they're the same thing
I mean some communities don't even get
one good job one good language so we
have to write and
so it's still like we were very lucky
like you place a possible rule of thumb
that I use when choosing which language
to use is just write your libraries in
Erlang if they don't benefit from elixir
features so if you don't have to use
heavily use macros that will use
protocols or this stuff just write the
library in Erlang because right now it
gets it has a wider reach if you ready
to no longer will you will ready book
for elite your people and Erland people
I hope this will change in the future as
I said that way you can write in
whatever you prefer and will be
available available to everyone but
right now I think this like has a wider
reach if you write something in our line
and then read just write your apps in
elixir because it's because of the I
think the developer happiness I've been
talking about so working with the leaks
here I think it's a bit more right now
it's a bit more pleasant experience like
a better error messages maybe better
tooling better plug tests support all
this stuff so it makes it easier to
write like your apps more pleasant
experience write your apps in elixir
still running your libraries in Ireland
and then I think the last points told I
just want to mention the Eric talked
about this earlier but I think hex is a
really important like a joint between in
the Erlang elixir community in the beam
because this is actually the first point
of contact where Arirang is coming this
way instead of just us going there so X
was just a kind of first thing that's
really connected the in communities in
both both sides and I'm really happy to
hear that
like LTP is considering using it as the
official package manager and I think
this will this will be really good for
the community and makes it will make
sharing really easy for just everyone so
we talked about the just recap we talked
about the good stuff which is a lot of
stuff like protocol standard library X
units the community that go system
documentation all this my stuff we talk
about the stuff that we can improve I
think dizer improve property based
testing testing and we can definitely
improve the situation of using the
elixir from Ireland
and then when I talked about just what
to do be nice
use both if you want to just use a
liqueur otherwise don't use just er like
that's crazy and then share whatever you
want on hex and that was pretty much it
yes we have time for questions we have
we do so I'm sure there are
yeah question regarding protocol
implementations what happens if there
are more than one implementation for the
Chile for standard data types for the
same for the same data type there can be
more than one implementation it's just
like defining two modules the I think
the last one will win but just
redefining them when you define any
protocol implementation under the hood
you just defining a module basically and
then and then when you dispatch the when
you call the protocol it will dispatch
to the right module for the given data
type so if you redefined an
implementation twice you're just
defining a model twice basically it
happens the same thing when you define a
module twice same module twice but
imagine I use two libraries which define
protocol implementation so be careful
not to treat it as a conflict
so basically basically if you I think
this is like approach problem because if
you're right either
elixir provides a approachable yeah and
you implement this but if Alex reprise
the protocol it will implement it for
all standard data types right and
basically anytime you define a protocol
you usually want to implement it for all
stat like built-in data types and you
want just want to make it extensible for
data types that other people create
right so if two libraries this would be
a problem of to libraries creating the
same that data type in the case just
hell happens and everything burns I see
thank you comforting words and what else
personally have a problem using the air
max mode for Alex see you yes
Emacs mode human yeah I use that as well
I don't think it's perfect I think
that's a lot to be improved year long
one is fantastic
it just works every time it gets
indentation right every time maybe it's
because I don't really know like I don't
really have opinions under long
indentation so I just do what the editor
tells me yeah I don't know I I'm saying
that like the Erlang one it's a good one
it leaks you want kind of flaky right
now it has a lot of lacking mostly I
find them mostly highlighting and
indentation bugs but yes people are
working on that like definitely it's
just like I think it's a more probably
complex syntax than syntax tree than air
long so it's kind of harder to get
things right indentation right
highlighting right but we have great
tooling anyways which is this Alchemist
thing for Emacs which is like a
integration for elixir in the into the
editor and you can run tests from the
editor of a shell in the editor all this
kind of stuff we have in Emacs as well
it's called alchemist
you say that Colin paramedics here for
being proved there correlate how calling
Erlang from elixir or the other way
around we are calling along from elixir
is not is really straightforward it's
just I showed this in the is the other
way around
alright so as I said this is this is
just a matter of improving the tooling
around it because this is are you this
is actual would would be working code if
everything is loaded and set up right so
you have this this is an elixir call to
the module in human shuffle with the
list this is the same call to the same
model to the same function with our long
syntax so it's just a matter of syntax
and as I said like a gnome it's just the
module name in elixir this is just
converted like under the hood it's just
this elixir down a new module so it's
like if you define a module with this
name in Erlang and then called color
function from the module so the only
thing that so like syntax wise and
working wise it's just you just call it
the same way Isaac with you if it was a
long it is a long code at some point so
you call it as your long code the
problem I think I see is with the
tooling right now so we don't have
really great tools to in right elixir
and use it in our liking rebar projects
for example all this kind of stuff this
is more like it less easy in mix we have
you can write Erlang in your electric
project and it will compile it
same as elixir and just load it same as
elixir we kind of have to work more on
the other way around the thing to
integrate them more on the other the
other side indeed it's really a
dependency problem of I was pulling
pulling a lick Sri and as the dependence
into your lab project yeah that's kind
of thing yeah so so said that the
streams are lazy yep could they be used
to implement like glaze nests into the
language or the application or so
there's still everything that we can do
anything that Erlang can't do so you can
bundle like you can do an a skill thing
where you just F business everywhere but
you definitely like this this streams
are just the laziness happening streams
is laziness for real this is just if you
want to do like you if you want to do
anything that you do in a skill with
laziness you probably can find a way to
do that with strings as well so you can
have for example infinite streams that
that's one like thing that comes up
usually you can have infinite streams
because you don't really stir the whole
stream you just or what's needed to
generate a stream for example so and you
just basically define the way to get the
next element of the stream so as long as
you have a way to get the next element
you can generate an infinite streams and
then you can still do the stream
operations on the infinite stream and
map over it as long as some point you
just take a part of it the same as a
skill does for like you if you map over
infinite list then you have to take
something to have a concrete list right
you take few elements you have like if
you can use a new take on the stream and
you will run the stream and get as many
elements as it needs and just return
that
last question okay then well being 100%
unbiased I can say that there was a
fantastic whirlwind tour of elixir
thank you very much Andrea thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>