<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>DevOps' Swiss Army knife for the BEAM by Csaba Hoch, Viktória Fördős | Coder Coacher - Coaching Coders</title><meta content="DevOps' Swiss Army knife for the BEAM by Csaba Hoch, Viktória Fördős - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>DevOps' Swiss Army knife for the BEAM by Csaba Hoch, Viktória Fördős</b></h2><h5 class="post__date">2016-09-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/4FK83LxEvjY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so hi everyone I'm Chava ho and this is
Victoria further film from along
solutions and we are going to talk about
tools in a log for production systems
and how many of you use air long here
yeah how many of you have put a bug into
an air long system that went into
production
some of ya
so that will fight a few hand so I think
that it's useful if we have tools with
which we can go into production systems
and see what's going on inside a system
and in general air long is very good at
this so in the first part of my talk I
will or our talk I will give a brief
overview of what kinds of tools we have
and then I will show you that we did an
integrated let's say framework and so
that you can write your own tools that
fit into this framework and do the same
thing as other okay trouble but why do I
need tools so I mean by it this is just
an airline code so yeah so the first
approach is actually that you just get
into the production Ella node and start
typing code right so if I'm interested
in let's say information about the
process but I can say that I want to see
what the init process is doing so I'm
writing it is at least converting it to
a bid and ask a long processing for to
tell me some information about the
process I can even pass some additional
parameters I couldn't stacktrace so that
I can get even more information about
these processes
I even have shortcuts in the shell
documented in the module code 3 so that
I just need to say I 0 0 0 and I get a
bunch of information about the init
process so this is very flexible and
convenient in some sense because you can
do whatever you want but it was also
very dangerous
let's see an example so let's say that I
have processed and that plus that
process has a large message queue and I
want to see what's inside that message
queue so let's say that one message is
ten kilo byte long here I'm creating
such a message and let's say that the
message queue has five thousand elements
so this is the position and what I do is
that I get this message queue and I ask
I Oh bleep format to convert this into a
string
it shouldn't be too large here it's not
a nice thing to do but it should be like
15 megabytes or something like that and
I have many gigabytes in my machine but
if I do this then this will happen so
this is the graph that shows the total
memory usage of this node the red arrow
is when I release this command and in 30
seconds the memory usage of the node
went up to five gigabytes and this is
because the pretty printer ones do a
good job but it takes quite a few
resources notably memory to bring this
message in a pretty way so writing code
is like a chef's knife it's very
flexible you don't need anything special
but it's tedious to use it all the time
like you have to write a code or
copy/paste it from somewhere you need
expertise to use it there are many along
systems that are operated by people who
are not along developers so this whole
along syntax and shell and typing those
commodities alien to them and it's also
very dangerous yeah and actually I want
to be the year of the day and not the
one who cared managed not so what I can
do whichever I will tell you in a second
okay
so there are other tools that you can
use in that case so on the other end of
the scale there are tools which are good
at doing one thing and do that one thing
safely so for example etalk if you get
into an alum node you can ask it up to
list you the top along processes by some
criterion for example message queue
length and you will get this information
in a safe way and the other example is
the add I function which will tell you
what add tables you have on your node
and what are the attributes of these
tables you can even pass the name of a
table to this function and then you will
get the content of the table and you
will get it in tracked so that the
system is not overloaded so these tools
are like this kitchen appliances you
don't need anything extra again you can
do one thing and you can do it safely
but it also means that the capabilities
of these tools are quite limited well
actually I'm looking for something more
Universal so but I can use in most cases
and it maybe looks fancier yeah I have
something more fancy for you and this
called observer so all the variants the
graphical - it's like this glass bowl
it's fancy nice and versatile but it's
also very fragile
so this is how it looks like and you get
some basic system information with it
you get resource utilization
you get process is drawn into nice trees
you can click on them to get more
information you get eat up like process
this thing you can get the information
about the net addonizio tables and even
some tracing information so it's
intuitive to use like most graphical
tools that's its main advantage and it's
very convenient you just start it and
click around you don't even have to read
the manual to find out how it works but
the biggest problem with it is that it
requires the WX graphical library and
often when you have like a Linux server
running
along code you don't have any graphical
libraries installed so you can just go
in and start observer sometimes what you
can do is you have your own a long load
on your laptop let's say and if you can
connect from that node to the production
node via long distribution then you can
start observable locally and ask it to
get the information from the title node
but usually that's not a good solution
either because we have firewall rules
and security rules that protect the
production node from being connected to
just from a developer laptop and and
actually if there is an ongoing outage
that I'm under stress so I want
something that will definitely work and
I don't want to bother myself with
firewall rules and anything okay so
let's look at tools then that are
outside of airlock so so far we have
explored but included in their long
history bution let's see what else is
out there there is an top which is
similar to eat op but you don't have to
actually connect to the other node you
just it's not a female separate our node
tell it the node ID of your along node
and you can get nice information you can
get keyboard shortcuts to decide where
you want to sort things like that
another very useful tool is a red bug
it's different from the ones that I have
been talking about previously so let me
tell you the logic so red bug is like a
blender it takes something like a long
tracing which is very dangerous and
tries to make it as safe as possible
so Alan tracing is dangerous because the
function can be called many times and if
it's called very often with huge
arguments then you can overload the
system very easily by tracing so what
red bug has is that you can specify like
in this example I say that I'm
interested in course towards the least
number function but if I have ten
messages that I have collected or one
minute elapsed from
the time when I started to the
collection then I want to stop the
collection and stop the tracing
whichever happens first and then you can
see an example of a printout so at this
time yeah you don't see the pointer so
at this time this process which was
started this way had the least number
function called with this this is the
parameter list so load Buc is very very
useful but you have to be careful with
this as well
double-bag is also dangerous so let's
say that I have Jan server which has a
handle call function which of course get
a state as a parameter and I'm
interested in call Stovall his hand
across function so what I say to red bug
is that I'm interested in this function
100 messages are enough for me
that low enough number to sound safe and
again the one minute interval and I want
to print the output into the file so
that I don't get like this much
information in the terminal and I create
again a 10 kilo byte binary which will
be my example and create a state or a
simulated state with 500 of these
binaries and what I call this handle
call function a hundred times then I get
something quite similar to what I have
shown before in twenty seconds the
memory usage of my node will go up to
five gigabytes and that's because red
bug is quite fast in collecting all that
function calls and passing this huge
state towards the fast server all the
time but then the file server is not
quick enough to write out all this
information in a pretty printed form
there are two other tools that I would
like to mention briefly one is recon
which also does tracing in a safe way
and it gives you some other tools to get
information safe
about processes and it has also some
completely different things
like dealing with be more locators and
memory fragmentation and finally I'd
like to mention early burley which is
also best in tracing it has a nice
graphical interface actually and there
will be a talk in the next slot about le
burly and the reason that it is a not a
blender but an immersion blender is that
it's not as safe as recon as well back
because it doesn't have overload
protection so it's actually not
recommended to use it for production
nodes only in development so this is
what I have been talking about so far
there is a developer there is an Allen
node and the developer is talking to the
island node via these tools yeah but
what if we think that maybe there is
another approach to to tackle this
problem so I mean there will be outages
you will need to be investigated but it
would be nice if you do not need to to
run tools on manage node it would be
nice if you would be able to to use your
existing cooperation maintenance
infrastructure to to retrieve this
information or to to execute nodes and
actually I I would say that we have such
a world this is called vomitorium this
is an operational maintenance tool for
along and elixir nodes and for what were
exiting implementations that are running
on the beam virtual machine so
vomitorium was primarily designed for
preemptive support that means that
agents that are started on the manage
node are collecting matrix notifications
and alarms but what if we could ask
these agents to help us in tooling it
would be much more comfortable
and hopefully more safer tools that
sounds like a really good idea so I'd
like you to add all of these tools
actually this one but well but yes as
you thought these have different
dependencies and the aims are different
the requirements and the but they
produce so I mean the results these are
totally different
yeah I'm sure you can solve all these
problems and yeah I've entire all of
these tools really and I want even these
tools and this tool and this tool is
very useful by the way I want one of
these and this is my favorite tool that
I want you to add to home but ok Chava
so your favorite tool is so custom that
that I think you should implement it
yourself so I mean what if I give you an
opened API and you will implement this
functionality I think I can be a bit
better that's ok so then I think if I
want to add all these tools then I will
return result in a chaos right and how
can I avoid chaos well with with very
smart easily extendable and extremely
general architecture that has an open
API that allows Java to implement his
favorite tool so now the question is or
the challenge is how to design such
general architecture right and and I
maybe start with finding the common
points so to get very broad picture
let's analyze problem dumb the first
question can be that when we want to
start these tools so actually these
tools are running only for a short
period of time then the reason an outage
or when we want to analyze them
investigate our system
and where we start these tools well on
the management that behaves crazy and
what we really want but to retrieve
information or to execute some comments
on management and how can we do this
well actually that's a good question but
wait a minute so what we really want to
do is to retrieve information or to to
introduce some changes and and why right
why why we are doing this stuff and and
the question and the answer is to
recover from outages or to further
analyze our system and to find
bottlenecks and eliminate the weakest
points and how can we really do this so
what we are we really do on the manage
node and and and these are nest details
right so if I want to change a
configuration parameter on a node then
then how I will change it it's
definitely depend on the configuration
tool that I use so if I using along OTP
standards then I will change the
configuration parameter in the
configuration file I mean in the SIS
config file but if I'm using cuttlefish
config then then I will need to change
the cuttlefish configuration and then
generate the SIS config file and how do
you want to implement all this yeah so
we are living in the wrong world so I
think I trust Joe and I want to make
every single synchro's I want to prepare
for failures and and I've won - hello -
terminates requests so now we know the
model we know what our goals
so now let's further analyze the problem
so go into details maybe it's a good
idea to
limited set of tools and try to still
find the common points but yeah so what
eat of returns it will return a list of
process informations but soft urges do
is is to get rid of all the old version
of the modules this is used for its side
effect viola retrieving a processed rate
state or tracing a process is it's a
thing that we can only do when we know
which process to be traced or which
process to be inspected so here we need
to know the process identifier so we
need to have a context and not
mentioning changing config so I need to
know the the name of the application the
name of the key and and what changed
configure returns this action returns
very very meaningful okay at home
thank you yeah so the thing is that I
have to admit that this whole thing
sounds very scary implementing a tool
that can respect all these different
requirements for all these smaller tools
maybe but if we step back and and
observe that actually all of these
features or services are just just
something that we execute and and and
yeah they need input to to to puff to do
their job and they will use the simple
to produce the output that's true so all
of them have input and produce some
output but the very important point here
is that the execution framework do not
need to understand it right it's it's
just need to know the implementation of
the service to specify its interface
so then the users or someone else can
request for this service and and the
framework should have the ability to to
collect the output of the service and
then forward it to the user and not say
that's it so now I'm able to to tell you
chopper but you need to implement to to
realize your favorite tools so the only
thing you need to implement is three
callbacks
the first one is the init request so but
when you are initializing a request you
you should check the input you should
validate the input you should ask
yourself do I know I'm seeing to perform
this request or can I do this am i up
for this job right this is very
important and and if you have received
incorrect data then you should deny the
execution but if you believe that this
is out of scope of your duty so I mean
you are you implementing a service that
is able only to change mongooseim
configurations and you were asked to
change let's say media configuration
then you will say that this is not your
job so you will return out of scope but
if you think everything is correct and
given you will accept this request when
you accept this request you should
return information that that we are
tired the execution framework how would
you like to execute really district pass
but you do nothing here just just fast
just give some further information about
the execution young and then there will
be the time
when you really need to do your job so
you need to execute the request sorry
and you should only do one unit of the
task and and the execution can result in
in in termination so you can say that
you you you dumb right you'll finish
what you have to do or or or you can die
that you will continue
you can return data if there is
meaningful data or or you tell us that
you don't want return data and and if
you fail then you should admit your
failure and give some explanation yeah
afterward when the request terminated
then you can you can clean up the mess
after yourself so this is the clean up
request Duty and there you can so for
instance if in the unit request you
allocated resources then you should
release these resources in the cleanup
request okay so this is what you need in
front right I think this is a this is a
reasonable task so it's not a big for
and and so now let's see what what we do
at one website so let's see there a
retoucher so here you can see the user
and one met node so as I said plugins
can can change their mind so they can
think that they are no longer able to
provide the service and and you can add
your plugin or anyone can add the new
plugins those are considering that you
are allowed to override our default
implementations so all of them implies
that the list of available services will
write among
the long notes that means that we need
service catalog this service catalog
will be maintained by the service
locator process and you should imagine
this service catalog as as a database
that you can browse and based on the
information retrieved from the Service
Catalog you can initiate request
initiating request is handled primarily
by the request manager process so this
process accept requests and and
maintains its not on database which is
the so called request catalog users are
able to browse the request catalog and
so they can see which requests are
running at the moment oh there is a user
there is a wombat but the heart there is
no manage note so it's it's a bit of
boring so let's at the long road or an
elixir note or an 11:00 note or yeah so
in this along note there are two
implementations that both of them
implements the configure the
configuration services but the first one
implements a specific configuration so
it's only able to work with Mongoose
i''m configurations and the second one
is the general configure configurator
problem okay so when these plugins have
been started on the manage node Naevia
announced their services to the service
locator process this process will be
process the unknowns services and it
will register it's in the service
catalog so from now users can see these
services and they are able to request it
yeah so let's request for it the Rick
that said arrives to the records manager
process that will start a new request
stream because as you know we are we are
longer so we love conferencing so each
request is handled by separate process
which is the so called request stream
process and it's it it's world is
definitely restricted to two to only
more requests yeah after this process
has been started its will be registered
in the request control so now you can
see that there is a running request but
this request stream start we do as a
first step is to ask service locator
process to resolve the users request now
the service locator process will return
early a list of possible executors that
may be able to execute the request right
and recur stream is a bit of lazy
process so it won't do any real job
instead it will try to outsource the
request so it first will ask the first
implementation whether it want to accept
the request and it will it will said
that oh sorry this is out of scope of my
interest it it won't accept it for
instance imagine that the request was to
change new configuration parameter and
the first implementation is is only
dealing with Zion configurations so my
dream process don't give up instant it
turns second implementation and asked to
perform the request the second
implementation accept the request and
made a promise to execute this so after
the
is the request stream turns to be a real
stream this will be a direct channel
between the user and between the
implementation and using this channel
the users and the implementation can
communicate with each other they can
send the commands information data using
this stream so assume that the
implementation managed to to do some job
and it now returns some some datum and
this is this arrives to the request
stream which will forward the data to
the user
now imagine that one of your teammate
Rives and and he is interested in the
same request that it's running at the
moment I have good news your team may do
not need to see it next to you because
users are allowed to attach to a running
request in after attaching to a running
request what will happen that any
further data that was pushed by the
implementation will arrive to the will
be forwarded to both of the users and
how this story ends well either the
users or the or the implementation
saying that ok this is the end of the
story I want to terminate and this this
end in this case the request through in
process will die because it's performed
its task
so it's ready and of course with the
termination of the request stream the
stream the direct stream between the
users and implementation via Terminator
so this was the architecture in a
nutshell and now I
I asked Java to show what we what we did
yeah let's actually see how this looks
like in combat
I have a video about that she's the
blonde my screen I can try to make it
fullscreen you know it's full screen on
my screen great - first I'll show you
how our atop integration works so this
is one BOTS web dashboard here we have
one of the reacts node selected which
are managed by phone but and there you
can see some of the services that you
can execute so first we select the atop
service and we select that we want to
order the processes that are listed by
that message queue like so when I start
request I will get this table which
contains the top process please order by
message queue length so you can see that
the first process has more than 200
messages and if I'd like to get more
information about this process that I
can click on the ID and get info
messages dictionary state and stack
trace so for example the process
messages will show you order not all the
mess is in the message queue only the
first ten messages because we want to we
don't want to overload the node and if
you are wondering about what the process
is doing right now then you can have a
look at the stack trace so you can see
that the process is doing do put and
actually it's doing asleep because we
think we did a little bit so that it'll
actually have that long view the second
example is visualizing at stables so
it's quite similar to eat oak
you say that you want to have a look at
that table and we will get a table with
the tables so each row here is an edge
table and by clicking on it you can view
what's inside the table you can evaluate
any longer Alex expressions here so
again you select what you want to do you
type an expression which will say what
are the connected what are the nodes
that are connected and like visible and
what are the nodes that are connected
but hidden to this tree or node and home
but you simply execute it and printer is
that and you will be able to see that we
are connected of course with the other
react nodes in the cluster and robot
itself yeah but here we need to mention
that this is a bit of dangerous because
yes you need you you know what you want
to execute yes so we integrated the chef
knife as well the dangerous part and the
good thing is that one bot has like user
management so you can say that yeah this
user knows what you doing so he is
allowed to execute stuff like this but
the others are allowed only to executive
a top and the other safe things
yeah and the last thing that I like to
mention is configuration so that was
Vicky's example in the slide so but in a
long usually used configuration
parameters to customize our nodes so
here if I select the react node and
inside that I select the application
that I'm interested in which is really
in this case then I do get a list of all
the configuration parameters and their
values and that's it yeah and and here
is a shameless plug that to be think
yeah within the next two weeks I will
give a talk about configuration
management in in run workshops or come
join and enjoy it in Japan yeah so now
we do you have any questions
I hope you have including so we are also
waiting for suggestions about your
favorite tools that you like that like
could be part of what matter yeah so
yeah I can look at him the microphone
services okay so my question is do you
have kind of access management that some
users cannot run certain services as I
mentioned but I can elaborate on that so
then you create the use in one but you
can decide whether he should have like a
gasp access meaning that he like just
controls data and cannot do anything
dangerous he can be an admin which means
that you can even add nodes or he can be
in the middle and there you can choose
whether he is right access meaning he
can do little changes or even exactly
what access meaning that he can run this
executor like change configuration and
the body weight on it a long expression
on the node or very worrying about the
overhead that may might be might put on
the manage node maybe this is another
question okay good so actually there are
some services that that are bit of
resource consuming so this is for
instance atop and such such services are
controlled by voom but by the bomb but
not so there is an exclusivity
constraint that we check so if there is
a
running atop request then you are not
allowed to start a new one right
can we see like what's in the alarms
like what kind of alarms you receive and
and also the matrix if we can okay so
can we see you or not maybe I will
whether I have one was running actually
because it's not the video okay but yeah
I do have a Walmart run English how
lucky do ya so these are a bunch of
columns so for example this alarm tells
me that my system you know it has a
bunch of beam files and there are beam
files with the same name in different
directories and that might mean that you
are having a problem yeah so we are more
than certificate in arms and more than
100 bit in matrix matrix are can you
show some matrix so matrix are organized
into three groups so we have let's say
operation level metrics that measure the
demotions attributes we have a long VM
level matrix so for instance the showing
yeah a total number in metric process
memory metric yeah so you can put up
different kinds of memory metrics to see
but the memory is used for yeah and we
have a fine-grained matrix so for
instance you can check the the number of
processes that are running at the moment
and and we have we have corrected matrix
which have a history and we also know
users so online the park system and this
is done by line metrics that are
refreshed in each second yeah thank you
but if you like to write your own plugin
then then your you can push matrix
notification and
and of course you can implement your
services and all will be presented by
this web dashboard any more question
yeah please okay so in here I can see
some metrics but let's say that you
already have like some sort of
monitoring solution in place let's say
graphite for instance and I already like
that one so I don't want to replace that
by this tool wombat but I still wanna
wanna be able to get these metrics that
you can get or that we get with one map
is it possible to forward them to
graphite or to get raphae to consume
this data yeah absolutely so we have
many integration possibilities sumtin
sumtin yeah so we support pushing data -
did the dog refine looks - gray log
maybe was pager duty yeah thanks so yeah
right that sounds really useful thank
you thank you
more questions it's not that thank you
very much thank you thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>