<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>What's New and Exciting in Julia - Stefan Karpinski | Coder Coacher - Coaching Coders</title><meta content="What's New and Exciting in Julia - Stefan Karpinski - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>What's New and Exciting in Julia - Stefan Karpinski</b></h2><h5 class="post__date">2015-11-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YMwm9xCW4bU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yeah the the fortress thing on the
Wikipedia page is actually not not true
we were not particularly influenced by
fortress since none of us have ever
programmed in fortress but it does bear
a lot of similarities but i think it's
convergent evolution so i'm gonna talk
about what's new and exciting and julia
two years ago i came here and gave a
talk about a multiple dispatch and the
sort of the the benefits but also the
that's that the responsibilities that
came with multiple dispatch Julia's main
paradigm is multiple dispatch so you
write a generic functions which you can
write many signatures to and the
particular implementation of a function
that's chosen dynamically depends on the
types of all of its arguments that has a
really nice property that it sort of it
reifies the concept that is like just a
method name in object-oriented
programming it also takes a method for
the function generic functions outside
of types which is really nice it allows
you to share types between different
between different bodies of code much
more smoothly than you can an
object-oriented programming where
everybody basically has to agree on the
functions that a type hierarchy is going
to is going to implement whereas this
way you don't have to do that but I'm
not going to talk so much about that
today and most people really want me to
I'm going to talk about some of the new
and exciting features that we've got in
the the recently released Julia 0.4 and
some of the stuff that we've got cooking
for the next release of Julia so that's
my one and only slide the rest of it's
actually going to be all live code with
all the all the potential for failure
and excitement that that can bring all
right so I'm going to use the the the
Jupiter notebook which is this wonderful
didactic tool that was originally
created for python by Fernando Perez he
wanted something that was like
Mathematica notebooks but not
Mathematica and you know open source but
it's sort of you know it it spiraled
beyond that and now it is this multi
language
web frontend that lets you mix text and
code and evaluate code and do nice
typesetting and then you can publish
those on the web because the nice thing
about it is that it's self-contained and
you can include graphics and the output
of the code that you evaluated in it as
well so this is a Jupiter notebook
running with a Julia Colonel backend and
so the first thing I'm going to do just
to give you a flavor of the language
because I feel like you really got to
get a sense of it so if it has anybody
in here you know who's programmed in
Julie a little bit ok that's a
respectable number ok so this is you
know this is going to compute this has
nothing to do with the name of the
programming language but this is going
to compute a the Julia set and so the
Julia set is this famous fractal and
what you do is you do this this complex
number iteration where you take you know
two complex numbers Z and see and you do
this iteration thing for a while you
know Z equals Z squared plus C and and
as soon as the absolute value of z is
greater than 2 or the squared of the
absolute value of z is greater than 4
it's a more efficient way to compute it
then you return and that's the number of
iterations it took to escape and then
you can plot them the the time it took
to escape and you get these pretty
pictures and we're going to see some of
those so julia is dynamic it's an
interactive language you can you know
just type your code in and evaluate it
we can see here that the you know we
could rear valuating it one pair of
complex points but you know you can do
different points so you can see that as
we as we take the imaginary part of this
higher we get significantly higher
numbers and then you know at some point
we get even bigger I think I know
there's there's you know it goes up to
like a hundred because a hundred is the
max that we allowed and so we can
actually see this evaluated a bunch of
points using an array comprehension this
is probably familiar notation to people
from you know from Python other
languages have similar constructs you
know that let me see
yeah okay the formatting is little it
needs to be a little bit smaller so you
can see that the upper left hand and
lower right hand side parts of this this
array are uninteresting they're all twos
and then there's some interesting stuff
going on in the other corners but this
is a terrible way to visualize this this
is not what we want to see but one thing
we can see that's kind of interesting is
we can see how this is getting computed
and this is one of the things that makes
Julie interesting for numerical
computing is that we we just in time
compile it and we generate pretty
efficient code so even though you didn't
mention any types in there we look at
the types you actually call the function
on and we generate code specifically for
that and generally we can infer concrete
types for things and generate the same
code that like a see compiler would so
you can see here these are x86 vector
instructions and it's a pretty small
tight loop and this is the entire thing
this is going to be pretty fast so I'm
going to reload a couple of packages
colors image and images and image magic
and then I'm going to define a color map
and the color map is going to be this
you can see it one of the nice features
of this I julia interfaces that you can
define display methods for different
types of objects and they can display
themselves in nice convenient ways like
this is actually just an array of RGB
values but it knows that you should
display an array of RGB values as this
like nice color swatch and then you know
using that color swatch what we can do
is we can basically just you know
compute that same thing that we compute
it up here that array but use each value
and index into the color map and then
we're going to have an array of color
values instead so we can actually see
that without the image part so actually
so let's do it without that bit oops ok
so this is the what did i do here ok so
this is actually a bigger square and
look at the corners are even more
uninteresting but we can index into that
with see map so we can use use each
value to index into the sea map and the
cmap has got a hundred values from
digital form
10 200 and we'll get a big array of
these color values oh no this is I
should not have done this there we go
it's going to display it as a really big
image you actually want to wrap it in
the image thing because the image
displays much much more nicely so we'll
see that now hopefully I regain control
of the browser there we go okay so
that's so much nicer sighs so one of the
interesting things about the about the
Julia set is that if you change these
prints so what I did here is I evaluated
it for a change the first parameter
across a like grid of different complex
points and I kept the second parameter
fixed and this is the pattern we get for
the escape values but you know if you
change this value just a little bit you
get rather different patterns and
they're all quite beautiful and they're
they're sort of you know they're they're
really interesting to explore
interestingly also you know people if
people are familiar with the Mandelbrot
set the Mandelbrot set is actually the
diagonal of this space so if you change
those so that they're both the same then
you get you get the classic Mandelbrot
set anyway this is you know it's nice to
look at the pretty pictures and sort of
tweak the numbers but we can do much
better than that so we can use this
thing called interact which is actually
a functional reactive programming
package written in Julia that gives you
these widgets so it turns you know your
computation into something with signals
and inputs and then it gives you slider
widgets and you can do stuff like this
and you can see how the how the fractal
changes is you slide these things one
changes it the imaginary part changes it
quite radically a real part changes a
little bit more slowly we can sort of
you know we can see all sorts of
interesting things happening here it's a
little laggy tho and so what I did this
is this is going to allocate a new array
and construct a new array every single
time and we know that you know
allocation is not that fast to be much
better to use the same array and then
right into it so this is one of the
things
Julie excels at you can write this like
nice sort of functional high-level
approach but without too much more fuss
you can actually write the version that
you know is equivalent to what C is
doing where you pre-allocate something
and then update the data in it so what
I'm going to do here is I'm just going
to have let use let to get a couple of
local variables so that I can ask for
their length and stuff just sort of
makes the code a little nicer so what I
do here is I pre-allocated data array
which is an array of RGB UN eight values
of the appropriate size and then I
construct an image object of that data
then i have this manipulate instruction
that's going to go through and go you
know look at all the pairs and do the
sea map thing and assign that right into
the data array mutate that and then just
at the end return the image I don't have
to do anything more with the image
because i'm actually just changing the
data in place so if i just redisplay the
same image it'll be fine and this does
no allocation and so what you can see is
that it is you know it's it's some it's
less laggy basically so it's a little
bit faster I have a pretty pretty a week
laptop so on a beefier machine this
would actually be this would fly okay so
I think that gives a little bit of a
sense of the language does anybody any
questions about this okay all right so
you know Julia set feel like that's a
good good starting point so that's
enough intro material now I'm going to
talk about some of the features that
we've added actually a lot of the stuff
that I'm demoing here like the the
manipulate stuff it's while it's not
features of the language it's like
libraries that were developed relatively
recently so there although manipulates
been around for like at least six months
it was a product of a google Summer of
Code project last summer that was very
successful so this is probably the least
exciting new feature but it actually is
like makes a huge difference for
people's experience docstrings so
docstrings if you're familiar with doc
strings from like you know python or
closure basically they look like this
you put a string in python you put it
inside of the function but because we
have multiple methods so you might do
something like frob fubar
equals I don't know I don't know food of
the bar I don't doesn't make any sense
but whatever now you can ask about frob
and you can see that it gets that string
so because we have these one-liner
definitions it makes sense to put the
doc string ahead and also because you
tend to have lots of metals little
method definitions it just seemed better
that way so just in in evaluating this
code I now immediately got help for frob
that's really nice because now as soon
as you load a package like the colors
packaged you can ask about colors and
you immediately get to read me and you
can look at it and be like okay well
there's something called RGB in this
colors packaged so maybe I want to know
more about that and you can see that RGB
is the standard red green blue srgb
colour space yada yada yada so this
makes it you know learning about the
thing that you're trying to use a lot
more convenient I don't know why I put
this up top but I like this particular
bit of help because it has in line lay
Tech which is kind of cool and it
renders correctly in the in the in the
Jupiter notebook so you know you can
read about FFTs in style so that's
docstrings it's a it's not it's not that
exciting but I think it actually makes a
huge difference in terms of people's
people's day-to-day life so function
call overloading in Julia's 0.3 there
were certain types that were callable so
the way you would construct an object is
you would do something like this so you
have this ad n functor type it's an
immutable type which means that once
you've constructed one of these guys you
can't change the field and it has a type
parameter T which is a number the reason
to do that is actually so that you get
it you actually get a different type for
every type of argument you might pass it
and that allows you to do better code
generation a little bit more you know
it's a little bit subtle otherwise you
could just insist that this be like an
int or a float or something like that
but then you wouldn't you wouldn't get
you wouldn't get good type
information about it so by default you
could previously right ad n functor of
two that would have worked so for this
type you could have you could have done
call you could have called the type on
something oh whoops well maybe restart
this kernel just there we go takes a
second start the colonel ok so I've
defined this new type and I can
immediately create this is this is a
type where it you know you give it some
n and it's supposed to behave like a
function that adds that end to whatever
thing you call it on obviously you could
just use a closure for this but you know
we're gonna we're going to make a type
that does the same thing instead and so
you can construct one of these and this
is what we would like to have work but
by default it does not work because the
thing is not actually a function it's
just an object and here's what you can
do now as a new feature you can write
call and then so call is now a generic
function which is the generic function
that the the call syntax f of X boils
down to it actually boils down to doing
this so you can overload it and you can
say well if if the thing you're calling
if f is an ad n functor object and
you're calling it on some x then you
know actually what i would like you to
do is say X plus f of n the field inside
so we would define that and now this
thing actually works it does the thing
that it's supposed to do and of course
in classic Julia style you can see the
native code and it's efficient it does
you know the abstraction has zero cost
you still can't do for example things
like you know f of 3 comma 4 whoops that
was just the bound name add 2 of 3 comma
4 because we didn't define a method for
multiple arguments we only did it for
one argument okay so why do we want this
I mean this is kind of cute it's cute
that you can call things that aren't
functions but wouldn't it be better to
just only call things that are functions
as functions that's actually what we
thought at first Jeff was very against
having anything but functions be
callable but then he came
around so one of the nice things is that
you know we so we were already doing
this type constructor thing so this this
worked previously in in zero point three
but then you end up in this sort of
sticky situation where you're trying to
explain to people why some types are
callable and some types aren't and it
just you know it was it was an ugly
situation so now if you want to
construct something of some type or
convert to that type all you do is you
use the same the same syntax you say
okay I got one two three and I want to
turn it into a float64 I just say
float64 of that previously we had to do
this we had to do float64 of 123 which
is kind of ugly same thing for in you
know it works for all sorts of things
another thing that's really handy so you
know we have a very good Python
integration so this package called pie
call lets you totally transparently call
back and forth between Python and Julia
you can even pass you know function
objects and callbacks back and forth
which is pretty sweet so here for
example I f is going to be a Python
lambda object so you can see it's a pie
object that is a function that is a
lambda and it's got the some address in
there and the pie call library can now
overload that object to allow it to call
stuff so we can actually just write f of
2 comma 3 and it acts like a function
even though the type of this thing is PI
object so obviously this is a much nicer
experience than having to like do some
other thing that's like you know not
actually a function call now here's
where it gets into the interesting mathy
stuff so one thing that we've observed
is that people in functional programming
are very into function types and people
in numerical programming are weirdly not
into function types and the reason is
because almost all of our functions are
just float like float to float so it's
like totally uninteresting I'm like all
right yeah I got another function that's
float to float but there are really
other really interesting things about
your functions so this week we have
instead of just you know worrying about
the lake the literal like what are the
types
maps between because they're usually
just not that interesting to us we can
do nominal typing of functions and so
this is this is an example of that so
essentially what you do is instead of
you know you you you have objects which
represent your function and implement it
by overloading call but which have
additional type information which you
can then dispatch on and do cool things
with and this allows you to do things
that the sort of map onto your problem
domain rather than mapping on to like
you know the types that you happen to be
mapping between on the computer so this
is an example where you're you know
working with boundary element methods
and you have these you know kernel
functions some of which are more or less
complicated so for example you know but
the most general thing is just some
abstract colonel you don't really know
anything about it it has no real
structure but you know a power law has
you know decays as X to the p4 you know
X way left much less than s and as X to
the q4x greater than s and so the things
that are interesting about that are not
the thing the fact that it Maps floats
to floats the fact that this P Q and s
are what describe it so we have this
type now that captures that information
and then you can have you know a
concrete power a lot of type that
actually implements that and actually
has no fields and just define that and
so you know here's an example where we
define this kernel that is defined by
this integral and you can see that
there's got this you know you got nice
nice straightforward notation for this
oops I can't redefine it but i can
define an instance of it and then i can
actually call that instance and of
course you know the llvm code is just
two instructions the native code is
going to be you know comparably easy
okay I am going to come back to this
example someone please remind me if I
forget after I explain stage functions
which I'm about to do that's the next
topic
ok alright so
actually we ended up calling them
generated functions because they're just
a form of code generation okay is that
visible to everybody yeah it seems
pretty good okay so there's different
forms of staged code generation right so
jit is one example you know you're
instead of doing your compilation all up
at once you wait until the very last
minute to generate code other examples
are macros right so you do you take an
input expression and you run code on
that input expression and turn it into a
different expression and then that is
actually what exit what execute in place
of the macro that you know invocation
those are interesting we found this
other one that kind of fits nicely in
between and like fits very well with the
way Giulio does stuff which we're
calling generated functions and
essentially what it is is that we're
hooking in right after type inference
and right before code generation so
you've you've sent you if you've got a
function and you've inferred the type so
you know what the argument types are but
then normally what you would do is you
would say ok but I figured out the
argument types and I have this AST thats
thats hype annotated and i'm going to
turn that into machine code which i'm
not going to run what we do instead is
we say ok well we're going to run code
which is going to generate the code that
you actually run sounds crazy i'm going
to give you an example and hopefully
it'll become clearer so
maybe I should have made this smaller
when your function doesn't fit in the
screen it's not good all right there we
go okay now it fits okay so the only
difference between this syntactically
and a normal function is the at
generated macro at the beginning which
is just a sort of it it tells the system
like to do the generated thing for this
so now what it does what it with the way
it works differently is that when this
body of code runs instead of a being an
array an actual array object a is
actually the type of the array and what
this code is supposed to do is it's
supposed to generate an AST that is the
body that of the code that's actually
going to execute and then that is
compiled and run and that is what
actually happens and so the reason you
want to do this I'll run it and you can
see what happens so n loops ran too well
so n loops ran two will go through and
print the two random numbers in this
very small array ran 2 3 is a 2 by 3
matrix and it'll print all the
coordinates and their values ran 2 3 4
will do the same thing ok so now you
might ask yourself why would you need
this generated code thing here well what
is the most efficient way to go through
and print all of the things in a
multi-dimensional array anybody like how
would you do it you have a three
dimensional array how do you iterate
through all of the things and print
their indices and print their values
yeah three nested loops right and for
two dimensional array it's two nested
loops for one dimensional array it's one
nested loop so the thing is the number
of loop nests that you want to refer the
optimal code depends on the type of the
argument and so that's what this is
useful for and actually we can see if we
just look at this definition and we
change it to a normal function and
change the name
and change this to a singleton kind we
can actually call it on the types of
these guys and you can see that this
thing the code that this generates is
this it's an AST this is just a Julia
expression that we've generated at
runtime with one for loop which does the
completely natural thing it goes i equal
i 1 equals 1 through size of a and then
it prints you know a comma I and then
the actual a value there but if we do
two dimensions it's two nested for loops
and if we do three dimensions it's three
nested for loops and if we do six
dimensions at six nested for loops so
this is like I this is a real pain to do
this simplified a ton of our
multi-dimensional array code and also a
bunch of other cool stuff that like God
got really simplified I don't know if
any like this exact feature in any other
language but but we've been enjoying
this the only thing is it plays very
badly with pre compilation so we're also
simultaneously working on static free
compilation of programs and this is like
you can't like how do you how do you pre
compile this you have to run code and
you don't you know you have to have the
runtime system in order to execute this
code when you encounter it the thing
that's nice about this too is that
unlike macros which have these totally
different evaluations and semantics you
know you can do map and loops over you
know ran two three ran two
oh my god I can't type right you can you
can map it over stuff that's totally
reasonable to do it's just it behaves
exactly like a normal function and from
the users perspective it is just a
normal function it's just that the
compile you get to like run code when
you when when deciding what the actual
body is you get to run code so that
that's pretty cool so back to that
example at the end here so this is an
example where you're using generated
functions with these these paths this
power law example and this is a real
example like this is actually something
that people need to do and it's a
nightmare to do in other systems the
call so you overload the call method for
this power law type this integral thing
and what you do is when you're
generating the code to run you saw you
you you you solve an integral you
compute the chebyshev coefficients with
this fairly expensive integral and then
you actually generate code that has
those constants in line so the code that
you generate is efficient this works and
it's like it's blazingly fast and much
faster than anything else and like you
can't I mean I don't know how you would
do this with like C++ libraries or
something it's just like not really
feasible and that's actually one of the
reasons why these boundary element
methods there there aren't good
libraries for them because this is the
kind of crazy thing you need to do
there's this like weird staging of
programming that needs to happening so
anyway this is just kind of a fun
example also note the like Unicode
variable names that's always fun okay so
that is I think that is what I'm talking
about four yep that was all the new
features so now we're going to get into
the experimental stuff where it gets
weird it's not that weird actually but
it's experimental so this is where
things might get crashy I spent a long
time compiling special versions of llvm
to make these parts of the demo work
okay okay so the first thing I'm going
to demo is a this system called CX x
which is c XX is actually a really slick
c++ binding library so so you just say
using c XX and then you wait for an
eternity because it's compiling all of
clanging basically no it does use clang
and it does generate a lot of code that
it has to compile and it does this but
it's not all of clang although it is
using olive clang it's like loading lib
clang and memory because as it turns out
to interoperate with C++ you basically
need a c++ compiler there's not really
anything else you can do it's not like
see where there's a nice API and what
this lets you do is it lets you write in
line C++ code and then pass functions
and values back and forth between Julia
and C++ so for example you can do
something like this cxx double f
I keep wanting to type function at the
beginning and then tight like end is the
key word I'm like I've done way too much
non curly brace programming for a long
time now so I don't know we can do
something pretty simple with this return
2 times X times y plus X minus y
something like that I don't know okay so
that didn't give us anything it just
evaluated some C++ code but what we can
do is we can use this cxx macro to call
it and now jit is happening again and
you see you get the value 11 you know
3.5 you get different values for
different things and other thing you can
do is so let's say you know you wanted
to wrap this so let's say I'd like to
have you know currently I don't have
anything called F in Julia space I just
have something at called F in C++ space
so I'd like to do that and now I can do
that and it's calling the C++ code and
you can see that what's happening is
that it doesn't you know so for this
particular invocation we know the
signature of the C++ code we know that
it takes two doubles so it has to do a
signed integer to a floating point
conversion of one of the first argument
first because that one was an integer
and the other one was already a double
so that's fine and then you just call
this thing and it's you know got some
mangled name in there as C++ functions
or want to be and then it returns that
that result and you can see that you
know if I pass it to two doubles then
all I got to do is just like you know
straight up call the call the call the
C++ function here I have to convert both
of them so it knows how to do all of
these things
let's let's see some other examples so
that was basically C code so let's see
something that's actually got a class in
it I yeah here we go here's an example i
typed in earlier I couldn't I couldn't
really remember all of this syntax so
you'll have to forgive me when I just
recall it from the history so I kind of
I kind of messed up the indentation here
but I think it doesn't really it doesn't
really matter it's not Python so yeah
anyway so this defines a hello class
which you know says hello world and
tells you the time and we just define it
and then we can get a reference in
Giulio land to the hello class or you
know an instantiation of the hello class
and what did I do
there's something
somewhere up here they're in my history
there is the way to call this there it
is timestamp ok so i generate a
timestamp as a julia date object or
actually it sort of turned it into a
string and then it passes it to the
hello world the whole hello class object
and then it prints its thing so this is
pretty seamless integration between
Julia and C++ which I kind of like never
thought I would see but Kenna was a mad
genius and he made this all happen I
think he's a little too in love with C++
it worries me sometimes but I can't
complain about having great C++ interop
so it's it's all for the best ok so any
questions about this oh oh there is
there is one other thing which is a
little bit crazy I don't know if I
should even demo it I'm a little worried
that I'm not going to get it right but
we'll see let's see how this goes all
right let's let's see what we can do
here alright so I'm going to do a
different function just to keep it
simple I'm not going to try to change
that one void
ok so I'm going to do I probably should
have prepared this beforehand but i'm
just going to do it by the seat of my
pants so what this is going to do is
it's going to splice a Julia not a value
but an expression because these are both
compiled by llvm so we can generate llvm
expressions for Julia code and then
splice it into the llvm code for the c++
code and then generate code for that
whole thing together this is like so
dastardly I don't know if this is going
to work oh yeah I gotta tell it that
it's a nothing
the
oh no no I need to tell it that I'm not
going to get this right anyway you can
do this I can actually there's a there's
an example from the from the from the
web page for this I have it up here
where does he do this here's the example
that's it okay so test Julia print
should do it yeah we change the name I
know okay so see xax exx test just Julia
print and so that that's what this is
doing its actually calling the Julia
print line inside of the c++ function
body which is madness by injecting a
lithium I know it's ridiculous so the
use the use case for doing this which i
think is actually like a questionable
motivation in my opinion was to write
the next thing that I'm about to demo
which is a debugger which uses ll DB
which is a you know LOV ms debugger
library which is in C++ so Kenna wanted
to be able to call lld be very easily
and so you know in the most epic yaks
rave of all time he wrote this c-plus
put these c++ bindings in order to be
able to call LD be yeah so you know
there you have it so I'm going to demo
the debugger next five minutes okay all
right okay so should i do the debugger
afraid to threading if i only have five
minutes i'm going to do threading and
then i'll come back the debugger if if
need
okay so I got to go back to this one
because this is the this is the version
of Julia with the threading ok so we're
going to
okay so I'm gonna
I'm going to define this Julia set thing
which computes the same exact Julia set
that we did in the beginning except it
does it it does it by pre allocating an
array because we don't support the our
threadings and like stuff is pretty
preliminary so the threading works but
the API is very much not what it's going
to be so the only thing one of the only
things that supports is parallel for
loops for the moment so this Julia set
function is going to compute the Julia
set as before but instead of using the
nice comprehension syntax that makes it
a one liner I'm going to pre allocate an
array and then actually like do the for
loops and go through and fill it in but
it's doing the exact same thing and so
you can call this Julia set thing man
might
my command line food today is kind of
crappy actually is
all right there we go ok so I'm going to
call this guy here that seems like a
good one will do that oh I'm in the
wrong window
oh god I've confused myself terribly now
all right okay oh I have to define the
actual Julia function sorry that was in
a different session okay Mac sitter
equals 100 all right okay we can see
that that actually works now and i'm
going to call this guy computes the
Julia set sorry that took a little
longer than expected well let's time it
and see how long it takes okay 4.6
seconds time it again I don't know it
takes it's around point five seconds
okay can we do any better well threading
would seem to be some a good way to do
this better so all you need to do to
make this threaded is will change the
name but that actually isn't necessary
right threads all and it does you know
parallel parallel OpenMP style threading
across all of the outer for loop and
that should be good enough to get us a
little bit more of a speed up this is a
Wimpy machine so we can't expect much I
only have two cores go sorry i have to
do using threads yeah it's it's not not
available by default you still have to
do using ok so now yeah it's about twice
as fast which is as good as it's going
to get on a two core machine I could
demo it on a machine with more cores but
you know that's a little bit iffy should
I try it should we go ahead and not
enough time ok cool we also have a
debugger but I don't have time for that
either but anyway thank
okay they have time for a question or
all right sure
yes I mean that's the whole point is to
call C++ libraries yeah yeah it's not
just to write C++ code in line but it
does it does have that effect you can
also do that
alright cool thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>