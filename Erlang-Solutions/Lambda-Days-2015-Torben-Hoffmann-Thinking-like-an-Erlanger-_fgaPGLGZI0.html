<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2015 - Torben Hoffmann - Thinking like an Erlanger | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2015 - Torben Hoffmann - Thinking like an Erlanger - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2015 - Torben Hoffmann - Thinking like an Erlanger</b></h2><h5 class="post__date">2015-03-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_fgaPGLGZI0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you thanks for coming so last year
fingers poke down here as well and there
I did one of my normal Erlang priesthood
things of propaganda how wonderful
learning is how it turns into money and
all those things that you need to
convince people about doing business and
all those things there and that's also
normally how I get contacted to talk at
conferences people we want to spread he
had the gospel of Earl and you get the
Church of Ireland going and all that and
I got invited last year to do a talk at
NBC in London and by a good guy called
Brian hunter then we agreed yes we'll do
this baby and then he comes up but I'd
like to know how you think
think I think I don't think when I
program I feel like Herod said I feel
and I feel good because I do it in our
line so if you're really good they are
but then okay fine I'll put together 750
McEnroe right now and this it has
evolved over time
there so I'll try to take you through
the mind at least my head as an airline
but I think this that things I'm talking
about applies to how a lot of people
think and also some ideas about how you
can approach airline programming because
one of the things but Gyarados has done
some story started on me if you saw the
keynote that burnings have to learn and
one of the reasons
Berlin is hard to learn is because it's
different it's not like all the other
languages out there it's different it's
special yeah and you like to do it but
the thing is and then any few if you
want to see for yourself
go tick take one of those maps with the
show the lineage of time of programming
languages and then there will be is
you're going running it's not on the
list
what are you doing so you have see you
can see that see transcends to C++ and
then you get and then you get other
things that are worse so there you go
and Berlin's on
the lists so there are reasons for that
but there's also one good thing from
that earning is not on the list is your
number one reason why you want to learn
programming is because it teaches you to
think in a different way and that is
very important so but this in mind
little question for you if you want to
see the Erlang code yeah you can
and that's important here if you behave
nice I might show a bit of code but the
thing is this is very very important
when we talk about these phase syntax is
utterly irrelevant when I was one was
it's the first time I saw alright I
forged syntax was horrible capital
letters and extra RS and everything
horrible that was when I was 28 or
something like that
so I've aged a bit since then and I've
actually come to realise that syntax
doesn't matter except that you're doing
Java then it's a different thing but
there we go but what does matter
thinking is everything so if you leave
here with anything today is forget about
syntax doesn't matter thinking is
everything this is what you need to take
into whatever language you're forced to
write in because if you're not forced of
course to interact so there we go so now
we're coming to thinking and then we
have this thing so we all know that
Ireland came out with Telecom so when
you look at these things and you can
then also abstract it away but basically
it domain like Telecom has a number of
things you need to do in that domain in
order to solve the problems if you're
not solving the problems you're not
being paid and yeah then it goes bad so
you can take the standard approach and
you can pick something like C++ or Java
or something equally when structures
there and you can try to solve the
problem meaning that you need to fill
out a huge gap this is good if you're a
manager now why is it that good it's
good because that means you need to have
an army of people reporting to you
having an army of people reporting to
you means you're important so there you
go so then that's a good reason for
languages to exist it's big
organisations because you can't solve
small problems with this you can only
make big problems and behave
you can get degrees in project
management I get tired okay but then
then comes a longer line is it
domain-specific language it was created
to solve the needs of telecom which
means that it fills out a lot more of
the space in telecom meaning that that's
a lot less you need to prime it okay now
you can always already see that the
managers are going scary it's scary that
means that we'll have less people
reporting to me on maybe there won't be
a need for manager scary stuff but
that's actually important because this
is all where this smaller gap means
there are benefits one of the good
benefits is that you can express your
thoughts more directly so the feedback
loop will be shorter and they you know
what to say the breakfast of champions
is feedback the more feedback and get
that faster you can learn so this is
about again in continuity fail fast
learn from mistake mistakes and improve
faster it's just the way things work
another way of saying this is those
benefits equals into money but we will
not dwell into that it's more the
feedback loop and actually the fact that
it's this small gap makes it fun to
program I had a colleague at Motorola
but more than one because it was a big
company that did things in C and C++ so
you see what that's going but we were -
we've got onto this Erland bandwagon and
then we convinced management that we
should grow our team by 50% we get one
guy extra that's our percentages work so
go round was twice shopping for a person
willing to learn this fingering and work
with us I don't know what which part of
those that he was most afraid of but
anyway he came to the conclusion said
guys you're interesting I'd like to work
with you but I'm not sure about this or
anything okay six months later Villa we
are asked to downsize our team by 33% he
had to go so basically and then he's
just sitting there went to his boss I
know I can't be on the team anymore but
can I sit next to these two
so I can smell the early this is how
much fun Erlang is you don't want to go
he was clinging on to his table yeah so
one of the things out of the silicon
domain that's very important for us for
solving problems is protocols and that
is actually something that too few
people are taught there's a feeling that
protocols is about flipping small bits
there and it's all about silico
protocols is the sugar of the world this
is how you make things work and they
here are to book to recommend of course
you all have a copy of a horse
communicating sequential processes
please yes that's one there good then
don't be a stupid that's me don't go on
a summer school for Tony Hoare and not
bring your copy to have it signed stupid
it stupid so I think I'll fix this this
year but that's another story and then
another thing here and this is a
springer book unfortunately so it cost a
whopping 120 dollars there actually I
have hung on to that but normally when
you take that class at university you
sold on the book because it was just too
expensive to have around but this one
was so good that I am with my limited
funds hung on to that one it is very
good it talks about how you design
protocols
it's funnily enough uses CSP to describe
these protocols and it's brilliant
yeah it's worth the money so the thing
is you use protocols for a lot of things
and you should be using them a lot more
so here we have one taxes consensus
protocol of course they decided to write
it up in s key so that it becomes really
illegible and things like that but
protocols are all around us and that is
what we should do and think about when
we design programs even if you are so
unfortunate that you have to write a
Java program you should be thinking
about protocols anybody can be a single
page programmer and write a Java object
anybody can do that
making Java objects work together is
about protocols that's what I need to
focus and then of course you don't think
about protocols using the one true
language on the
like Oh from Trinity abberline and
that's of course all right so this this
is what makes Erlang specially the
golden Trinity is something I came up
with while taking a walk I took a walk
because people saying you shouldn't be
using her like okay I'll take a walk and
deal with this problem and then you have
to think about these things so I thought
about if I had to strip something from
her language
what would I strip and still code in it
but which things would I take out and
make it go then I can code in something
else and these are the things that are
left in the language when you take that
exercise at least when I do it so you
have share nothing
so you're not sharing anything between
the processes you have in your system
sharing memory is bad
I mean sharing nothing means of course
that you also have to send messages
between these processes so that's one
pillock another thing is you fail fast
because trying to resolve everything but
throwing exceptions around and catching
them it relieves you to one thing one
thing only you will lose your hair
period
find a Java programmer that has worked
with this for 10 years has gone period
it's exceptions that does that so okay
you can't run around and have programs
just fail all over all the time
okay time for the career advice if you
work in a company like Motorola that
works on safety critical systems that
have to work all the time don't run
around let's say we just let it crash
people think you are insane for me of
course it's for the wrong reasons but
never mind
don't say that so in order to fix that
you add failure handling to the language
and then you can match these things out
so you have shared nothing one pillar
with message pass and that everything is
nice this is where the protocols live
you know these protocols to processes to
fail fast and then you supervise and
make sure deal with the failures in a
nice way so that comes with the person
to processes there so did dirt cheap you
just use lots of them if you try to
program say in the Python style and keep
everything in one process inside all
right
you're doing it wrong it'll feel like
programming in Python and that comes
with varying degrees of fun mostly pain
so don't do that and you should use tons
of it
you can spawn off on a Raspberry Pi the
old version you can spawn off something
like 10,000 threats in Java you can take
hundred and thirty-five thousand earning
processes they have that lightweight
don't be afraid of using them if you
program Java objects are cheap yes fine
inner and processes that sheep don't be
afraid
use them a lot and then coming back to
protocols you focus on how they interact
just having another processes as well
nice but you need to focus on how they
interact because that's how we solve
problems setting so I'm going to do
something and I warn you now don't do
this at home it's very important because
some people take it very literal when it
takes the next example and show you how
to use and I'm thinking on this problem
of course you shouldn't be using the run
on this or maybe you should but we come
to this so don't take it too serious
just take it that's a good example to
show the thinking here good game of life
Conway's game i right how many are
familiar with that exactly why do you
think one uses that example ok yeah
never mind take the critics play sir
so let's automaton very simple it is
about evolution of self in discrete time
and the way it works is you have one
cell you can see the wandering in the
middle there the next evolution of that
cell depends on the neighbors around it
so that's those eight one around it
there if there are two or three
neighbors around it it stays alive and
survives if it's empty it has exactly
three neighbors a new cell is born into
that square there a space there and all
all of they become empty and if you've
seen these game things run and then to
make wonderful patterns on your screen
let's just show so yeah I've written up
one yeah and a word of warning here the
world wraps around so the top of the
button can see one another on the left
side can also see
each other that's a common finger yes at
time one and then it starts evolving and
you can see did I jump over time one
yeah well trust me it is this correct
one you see how they evolved and over
time and they have to see what the
neighbors are like figure out what the
next layer should be and then you just
move on like this and I will not bore
you totally to death for this one this
one is a configuration I think it lasts
18 or 19 generations and then it dies it
looks so good here it survives six time
steps and doing great but eventually it
dies out there and people actually
spending an enormous amount of time
figuring out which concrete concrete
configurations survive and which don't
but it's a separate area versus so the
traditional approach to this so now
we're thinking like that you have a
program trust me after this talk that's
the fanfic is out of your body so don't
worry and otherwise if not I will get
you some learning patches you can put on
and it'll make it go away so what we'll
just for two seconds here so the normal
approach to this this is how you see any
textbook and programmers saying you take
a 2d array and then you take a new 2d
array and then you compute from the one
before the next one and you do a four
loop across the board and do all of that
yes that's nice if you don't appear to
program we're going to do so that's what
issues with this and this is where
people say you can't say this but I can
and I will
there it does not scale well because if
you do this unless you start doing nasty
parallel programming things you need to
actually run this quench early for all
things there and if you want to do it
right
because I Pro probably anything further
yeah
these empirical data structures are
really ugly so now I want to solve this
problem in our line so so this comes
down to the basic Erlang idea and that
is
one process per seller some people find
that utterly whoa can you that yes you
can
there i've been running on my machine a
grid of 300 by 300 processes so that's
90 thousand processes having fun doing
game of life there it works it scales
there and then that we let the processes
talk to the neighboring cells because
that's what you doin oh now you have
process is talking to one another by
sending messages around and where does
this leave us on the mark so that means
we're down in the left hand corner we're
down in the share nothing
message-passing area of the golden
Trinity of our life so this is where
we're going to stay for a little while
and deal with these phases so when I'm a
cell and I need to progress to the next
time step I need to know the values of
what my neighbors are at this time step
unless you do with a little bit of
protocol so we collect the cell content
of all your neighbors up just so figure
it touch between the one day they're
there and then you update your own
content and you say now I'm at time t
plus 1 so this is what you do normally
in the 2d version there and I look here
just a process it goes out talks to all
its neighbor and say ok good
give me what your value is and then I'll
update myself when I've collected for
all my neighbors very simple protocol
there so so then the question fix is
speaking it is this Erlang me enough but
what's one of the things I said about
Erlang and processes use lots of them
have I used lots of them here oh yeah
one per cell could I do a little more I
could try and do a little more so so and
we'll see if it's a good idea sometimes
you have to experiment there so actually
every time I need to collect for a new
time step I create a connect approach to
start a collective process that is
responsible for contacting all the
neighbors collecting the results and
once it's done it'll report back to the
mother cell you know what this is what I
figured out figure out what
want to do and how we want to crest to
the next time step Ken those is very
nice it's a protocol thing nicely
described described with these MSC's
that says message is going back and
forth and this that's a learning thing
this is how you design Ireland programs
you've write up these phase and start
focusing on sending messages around you
do not spend your entire life life
writing object inheritance trees this is
not important the static structure is
not important it is sending a messages
between entities that's important this
is what we do and then the collector
loop itself you can see here the top one
here is that as soon as it has nothing
it's waiting on okay
it has a number of neighbors counted up
and then it sends a message back to the
mother cell next content should be this
go ahead and know all the times that it
receives can receive like this is the
receive statement here if you receive
from one on your nature it's in cell
content message or do some updating and
everything and then you continue until
the way and you completed that entire
list this is nice and easy in the naive
way of doing this so the question is
will this work no it will not work so
we're going to see if it actually we can
sort of put a little bit of a provides
home that it works if basically if and
also there's another thing if you ever
start to become a project manager and
even eating other people and you have
your developers is it works if then it
means that our blocks in the program so
you need to so but this works if you
only take one step at a time
so you only ask myself to do cells to do
this to one time step in this simulation
and then we stop again and we see where
we are didn't work as long as you do
that
and if you let the cells run freely that
essentially doesn't work but there
because then the cells get out of sync
how can the cells can out of sync here
the
yes you can request something from a
neighbor where the neighbor has moved on
to the next time step so the neighbor is
at time t2 and you ask me what's your
banner at t1 and you just say well it's
in my past I don't know so that's one
more and you can also be ahead of the
rail at the game you could be asking for
sale value in the future for their
neighboring cell you've done moved on to
the time - and you ask your neighbor
what's your value at 10 - and he's know
I'm a time one I don't know my value
will be at time two we don't have
wormholes in Erlang so we can't
transport things full time and space and
things like that so we have to respect
these things but this can be fixed
luckily so if you have a quest for all
time something in your history you just
keep a history that's straightforward
and if you have a future time request
somebody asks you for value you will
compute in the future you just cue the
response and this though it sounds like
okay this is an artificial way of
solving game of life and what are you
doing these things what the point here
is in lots of places where you have what
they say here
asynchronous protocols you will run into
these kind of issues which meaning you
need to deal with these kind of things
and these two tricks keep in history and
also queueing responses until you're
ready to retire typical patterns we come
across a lot when you're doing more than
programming and it all comes down to
using agent Funes message passing good
now we move on to the next thing because
again as I told you went walking come
and came up with these face failure
Handley you also need to look at failure
handle in this because the code will not
be correct all things bad things will
happen that you couldn't foresee so how
do I do
failure hanging this you start
supervising the cells in your system
there and then if your cell dies then
the Erlang supervisor just put in the
standard Erlang supervisor there and
then it restarts to sell
the original arguments so if her cell
started we're saying I'm cell number 7.5
and this grid and I start with the value
of one meaning I have something in me
good it has been started there but the
problem is if you progressed and you've
done a simulation down to ten hundred
all of the time you just computed went
away when you die it's just going the
closest and the memory of the old
process it's gone so you start from
scratch and that means all state
whatever you have is lost and this
happens every time you have a process
restarting in Erlang April the new one
that repeat we started we started with
the same arguments it will look like the
same one but it has lost all state all
history which is something to remember
many new things but again there's a fix
for this you just monitor all the cells
so you can see if somebody's dying I can
do a fix to this and what you do is we
monitoring and when they die you wait
for the new cell to come alive and then
you say please catch up with the rest of
them so if you have a simulation that
have mine on to time hundred and it cell
dies when it comes back online they want
you to replace your one you just tell it
you know what run to time hundred this
is where the rest of us are please catch
up that's a way of fixing it there and
then if you draw that up in in the
diagram to show what you have you have
your main top level supervisor and then
over here you have a supervisor to
supervise all of the individual cells
you have the cells yeah and then over
here you have the cell manager that's
responsible for monitoring cells when
they go down and when they re started
telling the new cell the one that is
replacing the old one this is what you
need to do to catch up with the rest of
the world and this of course can be
written as a protocol and it looks like
this yeah that's a bit in it so here
we've seen that when the cell goes down
it dies for whatever reason in our line
it means that it's sending out a down
message because the
the processes monitoring so the cell
manager gets a town message for this
particular process and that means that
it says okay the old cell here I'm
removing that for my registry the
managers keeping track of who's around
so we know which processes relates to a
certain cell in our simulation then the
supervisor the supervisor in Erlang
they're dead simple
they just restart stuff nothing else
just restarted it starts a new cell to
represent the one that went away and
then it deaths and register self with
the cell manager and then the cell names
here okay now I know cell I J I know the
process identified you
I will monitor you now and if you die
I'm gonna fix things and what it does is
then takes track of there's a time
module in this as well it ask it what is
the maximum time that the rest of the
cells have reached and then it turns it
back to the cell please run up until
next time and then the cell that died
before has now been replaced by a new
one and the new one is taken the control
of the old one and it has speeded up to
where the rest of them work and again
this pattern also applies outside game
of life you have this situation
something goes down and then you're
looking at it okay I restart the process
how do I get it into the way so it works
the rest of my system sometimes you do
need to do things like this where you're
forwarding it forward by saying do
certain things all the cases you can
just restart it but that's for the
simple stuff the code I'll actually show
some more quote here so here this is
what it looks like the blue stuff here
is the down message coming into the cell
manager and you can forget about the
rest here but this is actually I'm
getting a down message then there do
some cooking yes
we need the time model well the thing is
the different notes of operandi I didn't
go into the details of that but I have
different ways of running the simulation
I could just say do a step step to step
I can also say run until you've reached
a certain generation number or I can
tell them to run freely and when I run
into this situation I can't avoid having
the time in there to make sure that we
sync up on something because then you
would have a new cell you could just say
just run and it'll catch up but the
problem is you wouldn't know what that
is when it's done doing that and if
you're running in a different mode of
our modus operandi there you wouldn't be
able to say now we go back to doing
stepwise things so that's the reason why
the time module is there if you were
just running them freely all the time
you wouldn't need it you'll just say run
and catch up with the rest of them there
does that make good yeah good question
good question yeah okay you get the down
message you do we're gonna bookkeeping
and then you continue then the next step
from the protocol is you wait for the
supervisor to restart it there and then
that cell registers itself again with a
cell manager and then you go down here
and then you monitor the cell so that
you've got it control again the cell
manager it's at all times monitoring all
the cell's in the system so you can take
appropriate actions were there and then
there's the thing that makes things come
back life is you have a kickoff cell
here and that is a function that tells
it to do the right thing depending on
what kind of simulation mode you're in
and that looks like this if it's a step
thing you just get the end time from the
time module right there and then run on
till that point in time and then it
switches over to doing the stepwise pain
if it's run run until simulation you
just sell it directly to do that and if
it's running you just tell it to run so
I could simplify all of this we're
saying we don't have anything but
running cells and they'll just run
forever there but then again you will
have a very hot CPU after a while
because one of the things
this out and there's a link to the code
later and the slice if you try this on
out and you do things like I do running
ten thousands of processes together they
will be utilizing all your course
because that's how it just works in
women by matching to their now at this
point there's actually a problem that's
a deadlock and this happens when you ask
the neighbor for his for value and it's
a future value for him and he cues the
response he says I can't answer right
now so he cues the response for you and
he waits until he's updated himself to
go to the next step and then he'll send
a reply back unfortunately somebody
comes along and kills him or he dies for
his only since there and then that
queuing yeah
it's part of the state of the process
and as we remember processes that die
even if they restarted by a supervisor
all the state is lost so that he has to
remember he had forgotten about that he
has to queue back and he hasn't response
due to us when he gets to a certain time
and if you try and do these things then
I've actually built into the program so
you can just take and kill a random
process just to see what happens there
you will see this and then everything
will stop because it's a deadlock so we
won't get any further there so how do
you fix this one because one thing is
you can realize what this problem is you
go fix the code but when you're dealing
with real-life stuff the stuff that
people pay some money to do asynchronous
protocols they're nasty so don't try and
us to fix it you do something elaborate
on the testing side and that's where you
use quick check how many of you are
familiar with quick check quite a few
happy people happy people the rest of
you can be even more happy by dwelling
in two quick check so word of advice so
use protect and do it operations by
operation there and that operation by
operation then ties back to looking at
the MSC you created for the protocol
you're looking at that gives you all the
clues
we need on how to write the different
steps of the quick check test so some
tricks are in order to do this you can't
just snap your fingers and do this quick
check or equally your link we check is
built on the notion of doing synchronous
function calls meaning that it does
something it checks the return value and
then everything is good so if you want
to do a simple stuff like protocol T you
need to do something and that is called
mocking and EQC so it has that has one
thing that solves that problem then it
has another problem you cannot call your
own module so you saw before we have
cells talking to other cells so you're
calling out and calling another cell
inside a little model you cannot do that
so you had a protocol module I'll show
you how that looks and then because
pre-check synchronous sometimes you need
to soak with your process that's living
is Asian prunes life so you need to add
functions help a function that will
allow it to sink at certain times in the
life of the process this is what you
need to do to test it and trust me the
alternative to this is to run a randomly
big grid of processes and then try to
guess if they've been running for a
while that they are in the correct State
and that all sorts of interleaving of
things are working that is not doable
that's why some companies hire test the
pathless with hundreds of engineers to
do this we do not want to do this we buy
one quick check license we have one good
guy working on it auger and then you fix
the problem yeah of course you don't get
10 managers out of that that's a
different thing so the protocol module
basically is if I query for the content
it's in a separate module crave for the
content of a cell you just caught back
to this cell so you have in this think
of calling out and then calling back
edge because that allows you to do the
mocking and that is typical with these
asynchronous things there so that's a
trick to keep in the book and then the
circuit so it's all really a spawned off
this collector process so when I think
with that then it has a little received
Clause part of the receipt for the
collector loop has is if you can get a
stateless out and that's it's a typical
way of doing this
don't just do a sync function to a
status function you can use for
debugging that is often a good thing to
have anyway so don't just okay I'll just
do this for testing but do something
that also has a a meaningfulness in
terms of debugging for game of life that
people working is not so relevant but
for real-life problem that kind of
debugging aids perfectly good to have
it's safe sure yeah among other things
yeah now doing a step in this this and
this is the quick check model for this
and this is where you have to do with a
little bit of trickery here so here
you're waiting until the collecting
status changes from what there's no
collecting status to something and that
is when you know that the collector
process have been kicked off and this is
the only ugly thing in the quick check
model now they're only really ugly
things there are a few other things that
are not so nice but this is the only
place for you to and this is how you
always have to do it with quick check if
there's Asian kind of stuff and you need
to wait for something to happen to make
sure that things has happened you need
to do these phase to ensure that you are
at the right place and then you can
evaluate things because otherwise quick
check does that's the function called
and the looks of the world and says has
everything happened and in this case
we're spawning a process and that takes
a bit of time for that to actually
materialize so that's as you have to
wait for that there and then when you're
doing this step here then one of the
things you're expecting and this is you
need to ask all your neighbors here and
that in quickcheck
terminology and mocking language there
is call-outs so you're expected to see
these processes sitting in the process
sending out messages for other processes
and that's called call-outs in this case
and here you can see that the call-out
expected to go to our protocol module
and that's why these calls have to be
marked and put in a separate module to
do it and now I don't have a run of it
but that actually painfully highlights
the deadlock thing and you can probably
check it out on github and check out at
the right point okay this is it shows
the deadlock and then you need to fix it
now
we fix it is that you let the collector
loop monitor the neighboring cells it's
asked for value and is expecting
response back and it knows given to the
design in the protocol if that process
that it's waiting for goes down it will
not remember to send the response back
this is tough luck so here you have the
fix for it up here is that if your
neighbor is going down because you're
monitoring them then you go down here
and you spawn a new little function to
wait for the neighbor to come back and
then when it comes back to get a new
message in here the neighbor is back
it's a new one and you can then monitor
it again and then you stay in control at
all times and then again this pattern is
not just for game of life every time you
have known these situations if somebody
you're depending on goes down you take
the down message you wait for the
replacement to come back online new
monitor it again this is how you build a
robust system I double dare you to find
do this in C++ whatever with fritz this
is where you will lose your teeth as
well good so the recap here is a process
per cell in this situation shortly
processes for small tasks this will also
work in other situations there focus on
the protocols between the processes this
is the thing that one should burn those
computer science professors on the
states for that they're not teaching
enough of this protocol go ask for it if
you're still in university go ask for
having classes and both protocols it's
the only thing that matters when you get
out there and the thing is if you do a
little bit of protocol
this is career wise again there if you
know protocols in your how to deal with
this you will be like among the blind
the one-eyed escape you will look
insanely intelligent by even being
average
just because you picked the
tor to solve a complex problem you
taking the hint here and I will not take
50% of all your bonus is going forward
so good
use the supervisors to restart things
basic running stuff and then you have
this monitoring manager process on the
side to get things that are restarted up
to speed
they're good and then thinking you know
like trying to sum it up their focus on
the protocol CMSes have said that a
number of times I'll say it again folks
on the protocols so anything that
matters if you have to do Java focus on
the protocols you have to do C++ thank
you good yeah and then and this is where
you can you can do this in Java as well
ask what could go wrong yeah and then
within days you will be seeing a
psychiatrist because in Java everything
can go wrong but this is what you have
to do in your life you just asked what
could go wrong here because that's a
natural way of thinking about things
because we have this supervisor thing to
have the fail fast there there so please
go ahead and do that
and then tools and doing lots of
processes Sporty's smooth that
short-lived processes for small things
please please do that use supervisors to
keep things in order
they're linked and monitor where needed
that's also important and then yes and
as another trick which didn't work out
for for ego but in in many cases if you
need to have processes and you need to
have a name for them and look them up
it's a library called G proc that can be
very very good but so on these things
the problem is G proc dies in a very
hard way when you're putting 90,000 game
of live cells into it it just dies on
the depression because it's not supposed
to handle that so I don't use it
incorrectly they use some timeout they
can also be used for but that's I
haven't shown anything and then you can
also have things like transaction logs
Ledger's but you can see some of our
presentation to see more the description
of those but these are different
techniques to solve this problem and do
it well and then the testing remember
this ace
protocols are nasty this is why people
do not like to do them but Asians who
knows protocol is what you need if you
want to build a scalable system that's
robust so it's like a chicken and egg
problem
it's accept it but they are nasty I
couldn't generate blood running down
from the nasty here I need to look at
that but they are really nasty but you
embrace them because that's where the
money is their use my paycheck for it
probably stick robots on one process and
mock the calls to the others
good and then if you want to see more of
the code you can go to this github
repository think most of the stuff is on
the testable branch but I'll merge it
into master soonish there so you can see
everything there if you have questions
on that code don't worry write me me do
a P i if you have a way of fixing my
horrible code okay but and then we on
croco so I have to say something about
Alexia because otherwise we had a
webinar recently and people asked but
why aren't we just do everything in
Elysium now you could sort of but later
but it's build on top with your own VM
which is a good thing
don't be I mean it's a wonderful piece
of machinery if you're in any sort into
Erlang its Robert here no Robert wording
is around here he's one of the creators
that he just called shaking hands say
thank you for the VM it's you have to do
that it has more Ruby like syntax for
those again student X is irrelevant but
for some people it's it's a big thing so
you can also do some hygienic macros so
that means you can do domain-specific
languages quite easily if you're into
that sort of thing
there it has better support for data
handling and I think that is probably
one of the key selling points of using
alicia is that earning is a ping-pong
language it's created by Ericsson they
pay ping-pong a lot in Sweden so they'll
get a message you send it back in the
next year it's like playing
drop your something because you get past
something and then you allow to run with
the ball and then somebody could come
and kill you and then you pass the ball
on again so you can do a little bit more
so addiction is like rocky or something
compared to other languages pinko but
the underlying thing is you can't do
good Alexia without understanding the
Erlang programming model so we need to
embrace the golden Trinity Veronica in
order to to work on either these things
or the other million share nothing mrs.
classic pay fast link monitor and Asian
consisting buildi Cassie thank you
question yeah yeah you can keep one you
can only keep the last one around them
and you can just prepare yeah in real
life you wouldn't probably keep the
entire history around in the process if
you have history you want to keep in a
real life life program you will start
putting some of it away to disk you
restore it if you need it for later but
you you will also go in and say make a
trade I would say that's part of my
history that's important for snappy
things and you keep that in the process
and there are things that I don't really
have a lot of chances where this it will
be necessary so I'll just put this away
so that's the normal thing you will do
within a real system you could do a
snapshot thing for that there so so that
different you wouldn't normally it's a
very good observation you normally
wouldn't keep the entire history in a
normal system around that that's also
why I talk about ledges because ledges
are like a way of saying now we will
create a synchronous point we agree on
something
we put it down and then when we start
again we'll ask the data how far are we
and then we use fast-forward to that
point in time so that's why it's again
an example to show things and then of
things where you need when you go it
more serious more questions
the supervisor going down you're asking
yeah that's a very good question because
that comes down to how do you deal with
the fact that you can't protect and
protect and protect and protect and get
things to work so what you do is this is
where the key thing a lot of people said
I can't use the Erlang supervisor I'll
write my own don't do that
it supervises simple it's very simple
and supposed to just restart so the
problem is a supervisor then if it
restarts its children too much it will
die itself and then you need to have
something above it to say what do I want
to do here do I want to restart here or
what and then the thing is then you kept
this like you saw here with the cell
manager you might have another process
on the side that is doing some business
specific logic to if the supervisors are
going down because the supervisor
publish supervisor will just restarted
until it runs out of tries and the thing
the key thing is that you only try to
see I only protected the cells with this
extra process on the side because they
are the important part of my system and
if things are going so badly that you've
run out of restarts you probably are
better off that Apple Pro or program
dies it is rare that it happens but it
can happen
so that's you don't stop all supervisors
from dying you need to take a trade off
here and the beauty in Erlang compared
to to Java there is that you're not dead
from one exception killing you
you can decide which things to fix and
how the rules are for restarting but you
should not try and cover everything it's
not like that but then the other thing
is it's separated from the rest of the
code all the supervisor stuff happens
outside the wonderful Jara's coding
you're doing that makes you feel good
it's outside the Golden Path so but it's
still it's a trade off you need to make
even in your life it's not like the
Silver Bullet to solve all problems
so so this is about currencies of mess
which is delivering their inner lioness
there are no guarantees of message
delivery none whatsoever
because that's the only same decision to
take operating in a system that is
potentially distributed across machines
you cannot know and the guarantees if
you want to guarantees the amount of
stuff you have to build in its enormous
and it won't work so the its Asian
cruise message-passing but what you will
know is if you've sent a message to a
process and it hits the mailbox of that
process it stays in that mailbox until
the process takes it out or the process
dies and takes the mail down box into
the grave with it and therefore it will
be delivered only once there but you
cannot be guaranteed of it ever reaching
if a process you have the closest
identifier and say send it a message and
that process is already dead you don't
you're not alarmed you don't get any
message whatsoever yes that's why you
use timeouts and that's why you use
monitoring for things so you can get a
control over this but the thing is most
of the monitoring and will happen
outside the regular code and it will be
some extra error handling code you could
think about at a later stage but you're
right absolutely right sorry okay so
scaling time off well that is dependent
on the system you're doing because if
you're sending some you have distributed
over number of machines you need to sit
and look at what is the latency of my
network what's the reasonable time out
here so
no little bit of calculation but you can
use rules of thumbs for these things and
you say okay if I'm not getting a
response back in five seconds I've said
this is a long time then something is
probably wrong and I need to start doing
something like kill myself and and say
that there's a problem higher yeah it's
what you do in our line right if things
are not working you kill yourself except
ace programming in general my take on
that is it's it's amazing because one of
the things that's good about AXA based
programming is that it separates it AXA
in most languages will have its own
threat of execution
meaning that you're hiding all the oak
leaf reading any programming languages
and you get a focus on sending a message
to that AXA if it's not message passing
as it is you know it's it's something
very similar similar to it conceptually
so actor pays is awesome very good just
don't think you'll be as happy in those
languages as you will be in early no you
can do if you forced to it just take the
ideas from Erlang and apply it to
something else but remember it's not the
real McCoy there are certain benefits
and then and the thing you will see is
all this I'm talking about fail fast at
supervision this is what you're not
getting as easily in other languages
there's a reason why a company like
whatsapp have bettered their entire
infrastructure on early because these
kind of problems will occur errors will
happen when you start doing a system
with five hundred machines there's a
reason why I paint gambling company like
bet365 that are moving millions of
pounds around every second there's a
reason why they're betting their
infrastructure on early because
will happen and you need to be able to
deal with it when it does because the
worst thing that can happen for gambling
company is that the flow of money
through
system stops if you take out a little
bit of that flow because one closest is
dying everything is good you're still
making a ton of money if you have a job
exception taking down the entire website
entire flow of money just gone and if
you're moving millions of pounds through
the system every minute I don't want the
system to go down so
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>