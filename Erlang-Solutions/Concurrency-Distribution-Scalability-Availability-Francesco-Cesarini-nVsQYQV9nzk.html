<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Concurrency + Distribution = Scalability + Availability(...) - Francesco Cesarini | Coder Coacher - Coaching Coders</title><meta content="Concurrency + Distribution = Scalability + Availability(...) - Francesco Cesarini - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Concurrency + Distribution = Scalability + Availability(...) - Francesco Cesarini</b></h2><h5 class="post__date">2015-12-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nVsQYQV9nzk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yeah very kindly to put me as the last
talk of the day I'm here standing
between you and your beers if you don't
have any disability just stand up a
minute just stand up stand up come on
i'm going to start so yeah i'm going to
talk today about some of the design
patterns which i was forced to document
when writing a book right here so i
started writing you're designing for
scalability many many years ago probably
met say three years ago the first how
many of you have written a book here ok
robert as well yeah so the first piece
of advice I can give you is if you're
writing a book and your girlfriend comes
up one morning says I'm pregnant yeah
you start jumping up and down with joy
saying great but then you've got eight
months to finish that book this book was
supposed to finish yeah now little Peter
is 18 months old is running around and
we're almost getting there now so that's
the first piece of advice so when I
first wrote the first time I book it was
fairly easy and even you're the first
part of this book here as well I mean I
teach a lot i developed a lot of the
training material at the resolution so
what I did is I took all of those
examples which are short compact you
they have to fit on a PowerPoint slide
and a rope to look around that so I just
don't go in and start writing so when I
survive in my lecture on a dudes lecture
they'll go the tour's many kind then was
a written in the chapter I go back and I
start thinking okay where did students
struggle and go get a refill all of that
and you might make sure that the part
the struggle is really clear there's no
doubt about what I'm writing and when
I'm done I go back and think okay or the
really really smart students what
questions did they ask which are doing
covering the course and your dad's way
to start getting your side notes and
then once all that's done you going to
look at the documentation to make sure
you've noticed it and that was really
easy for this book when it came to
generic servers finite state machines
event handlers you know the first 10
chapters about you know i was pumping
them out at about a chapter every other
month and that work really well then i
got the chapter 11 your assistant
principals and release handling it yes i
think we've heard it from Torben today
not it not that easy and mainly because
here there's no standardized way of
doing things also I was just joining
together to part in the training
material and yeah and even young chapter
12 on software upgrade that was fairly
tough as well because you're in both
cases what you were trying to do is show
how easy it is you don't want to scare
people often you know 40 pages later
took 40 pages to compress your boats or
upgrade and release hand it in to maybe
five easy steps to follow and yeah I
thought it was done grading I've got one
chapter left 13 13 is never a good
number and we'd call that chapter node
architecture and and then that's really
where I got stuck you know what I was
trying to do you talk about is you
describe how you learn a new
architecture learning system how you
know how you'd expose your oldest secret
source of airline scalability and
reliability you know there used to be a
popular belief imagine if you use
airline and guess what your systems
going to scale and yet it will never go
down so when doing so now I realize how
you have been architecting Araxes so I
started working with airline back in
1994 with Robert at the computer science
lab did my thesis there and it took the
one on before he allowed me to target
systems but i'm already thank you quite
a few and all of a sudden that was
documenting something which for which
there was no training material and so i
started writing chapter 14 doing the
brain dump you know trying to describe
all of the patterns all of the vultures
everything you need to think about
everything which you had to reapply
between projects and you're designing a
distributed scalable full tolerant
system and you quickly came to realize
there was no one-size-fits-all I was
trying to figure out you know when then
I start writing this chapter and I was
actually dealing for my emails on the
plane this morning her this morning and
found an email to my editor saying oh
I'm almost done it was dated March
fervor march forth and I'm almost done i
will be sending me what i have and
probably a two months later sent
everything off to my editor who came
back and says help stop this is not a
chapter this is four chapters you threw
it back to me and working away you'll be
ended up sorry we're working away we end
up breaking that one chapter into four
separate chapters which we finally
submitted on some day soon be available
is already released and it came to the
conclusion you know that you need to
break down the problems no
one-size-fits-all because there are a
lot of small different components and
design choice need to make along the way
and what it ended up this yoke the
result of these beautiful chapters are
here what are the ten easy steps to
architect designing an architect in a
distributed system so this doesn't just
apply to airline it doesn't just apply
to EDX here it will move from your try
to any distributed system you can have
and these are the design fact need to be
where fold along the way now using Aaron
and airline based language makes it much
much easier because of the semantics and
because of their line
the properties but you know what i can
say here is going to be abstracted very
much and finding of the conclusion after
having written these four chapters or
you know that concurrence and
distribution is equal to availability
and scalability and when all you're
doing when you're you're designing your
system is making choices and trade-offs
along the way and somewhat i'm going to
talk through today now or some of these
choices you need to make up and some of
the things you need to think about now
the first step you need to do is when
we're dealing with it is start looking
to distributed architecture and
distribution here in this case is
important and it's going to become even
more important as you start getting more
and more cores on our architectures on
those law it will state that get your
shoe ireland vm will scale own to a
certain number of course you want to
start using utilizable your course
that's where distribution starts coming
in and you know when we look at
distribution ODB has done a great job at
putting in place all of the terminology
for one single note if you have a port
of it and then for everything else
everyone used different terms in
different terminologies you pretty much
described the same thing causing a
massive amount of confusion and that's
when your turban about two years ago
starts that we need to standardize this
and it's part of the release project he
picked everyone's brains and we put
together a document for ginkgo which is
a distributed Erin component ontology
document and what we came up with was
that if you look at nodes you need to
split up nodes into specific node types
and you usually in our line at least
you've got three different types of
nodes you have what we call the front
end nodes and these are usually
client-facing notes usually have a lot
of TCP IP based connections are often
located in your just within your
perimeter networking often within a DMZ
for security reasons you then have your
logic comes so those you know 70
which one you want to business object so
everything which is well has to do with
your application your writing and
finally you've got what we call service
notes and the service nodes will provide
some form of service it could be a
database it could be an API towards a
third party system it could be an
authentication server so it's yeah micro
service is at its best even before the
term was invented now when you're
arguing the first thing you need to do
when your architect in your system is
try to break down what you're trying to
do in to know times where each node type
has a specific responsibility so you
pretend that this was an e-commerce
store yeah your front-end handle your
your mouth baby is or would run web
servers your business logic would handle
all of your transactions your shopping
carts your session and then your service
nodes could handle payments it could
handle you know send a catch towards the
warehouse to send everything they've got
the database is storing user information
using either storing anything else so
what you do is when you start dividing
on your nose into the front-end logical
urns and service nodes you try to reduce
the functionality in demand as this
allows you then to go in and optimize
the hardware optimize fine tune fine
tune the OS fine tune the vm because you
know the less they do the more likely
they are to become it just i/o bound or
just memory bound or just CPU bound and
if a system is Justin to you but it's
real easy to optimize if its memory
bound it's real easy to optimize you
start putting too much function and into
a single node you start hitting your
head against the wall because you've
gotta love to optimize and there's also
much more which can go wrong if you
think of it so once you've split up the
ball architecture into node type you
need to start thinking about your
distributed patterns you need to use and
distribute architectural patterns
come in any shapes and sizes and it very
much depends on how you want your foot
problems of the system to be now we
wanted to scale now the most common
distributed pattern is distributed
learning just the fully you know where
nodes are both fully connected to each
other and yeah that's really easy it
will just go in and work out of the box
but as we know it's got its limitations
you know every node will connect to all
the other nodes and then it'll start
sending you know if you sniff the
network can see the tick dr. quest so
sort of sending keep their lives and
health checks towards all the other
nodes and the moral notes you have the
more problematically it gets and as soon
as you start since hitting somewhere
between 70 200 notes depending on your
configuration network and so on that's
where you start seeing state degradation
in fruit boat so you know distributed
online however probably ninety percent
of all of the projects it's good enough
now for those where you need two
completely different level scalability
this is where I had to steal the bath
show ring and your turban was lying
actually if torbin if he said no but his
bonus is based on how many country shows
the ring go if the bash engineer is
showing your presentation it doesn't
have to ring he's actually not being
paid it's what he's doing in his own
spare time if it doesn't have the rain
here so the next step is your real core
and rip or basically allows you to you
know you have to keep your Truman
expanded pretty well but what you do is
you've got a key space it could be your
session ID or it could be a unique value
unique key and you basically go in and
hash it in between zero and a very large
number and then you partition each key
space into your 32 or 64 partitions and
you then use these partitions you know
these petitioners incall denotes virtual
nodes you then go in and place virtual
nodes on to physical nodes so when you
do it and you assuming you have a
session you
in your hash on it you got passed on to
the virtual node which then you know
passes you want to the physical go so it
becomes in effect a Rooter it becomes a
job scheduler and it becomes just a
genetic switch and now react or still
uses a distributed airline that means
you're still limited to about 70 to 100
notes and you're depending on your
pattern but what you start doing is now
you start using your reoccurring with
islands of services so you start putting
order the service nodes and all of your
front end nodes connected to this
massive ring right here and you can then
dynamically scale up and scale down your
ring as you want and we were in you know
a fully connected ring you know I can
guarantee you you know you can run your
what's up sighs or even well less you
can run criticize a messaging and that's
enough to reroute one unit last handle
all your task on jobs and then you know
pass them on to the service notes and
then you have the real scalability then
ends up being on the service knows
themselves you following me here yeah so
I will get to that in a second no they
don't have to use distributed re oh you
switch on something else you stood from
yes so this would be react or this is
all using distributive airline but here
you can use TCP IP ssl amqp you name it
and I'm going to get to that in a second
actually um and so yeah you basically
get your time most out scalability will
be a core and another very common
distributed architecture which you know
you might want to pick a service
orchestration very enterprising my son
but it's being used out there you have
your service bus and then connected to
that service bus you've got your service
knows you
front their nose and you can also create
and again smaller clusters of knows
where it is just one of the nodes
connected to search through service cuts
and this is a very common architecture
as well where the limits of your
scalability is how much your service is
able to scale and one of the things you
need to think about when you're deciding
which distributed pattern to work on is
what scalability you want your system to
achieve and what levels of reliability
and availability because these are all
things which you can put together go
head to head to each other and your
whole architecture will basically
consists of a set of trade-offs between
all of these and you know there's no
one-size-fits-all as I mentioned so you
you really need distributed framework so
most of the time going to get called in
to look at such an architecture where
they've got in and they started using
rabbitmq or they started you're using
lots of different nodes and you wouldn't
even asking what throughput are you are
you seeing oh you know we've gone you
know 500 requests per second it's great
yeah you don't need service buses for us
oh we can answer so you can do it anyhow
yeah just simple cluster even you're
going up to your twenty thirty thousand
requests per second you know a simple
mesh cluster it is usually more than
enough and another really interesting
architecture is well obviously the most
distributed scaling the distributed
system of the world is near care to hear
where each client also acts as a server
yeah I mean think of khazana your finger
bit foreign and I've never actually seen
an Ireland system your scale using a a
peer-to-peer system but it would be a
really really interesting one if you
know if you need to scale infinitely and
obviously you're just like all the other
places you can have your Islands you
know alongside so you're
network here becomes also also a giant
switch you want to start applying your
Software Defined Networking principal
student radium principles to it now a
really interesting year question came
earlier and so you know once you decided
what distributed fatter you want to
choose you need to think what network
protocols you want your nose to
communicate with and even there and
there's no one-size-fits-all you might
have clusters which use distributed
airline but there might be cases where
security won't allow me to use
distributive error is just a typical
example of a a two tier architecture
where we've got our web servers running
in a DM set now are the clients are
running the perimeter network and then
you move up firewalls and then between
the firewalls we've got their nose
running the business last thing you want
to do is start running distributed
airline between the web server and these
knows you access your web servers yeah I
think the days when we used to work of
security by obscurity but no one knows
airline or are upon you know you get in
Oh distributed airline you then get
access to everything you have to do
everything happening here in the
business project so usually you know you
need to decide you know what network you
want what network connectivity do you
want for network protos do you want
between the nose so in this particular
case for example maybe SSL or sockets
just pure sockets where you've got
layers here controlling you know the
functions coming into request coming in
and ensuring that only authenticated
users you can come through but this on
your distributed airline mvi 0n to UDP
ssl sockets rest and UPS mmv XMPP MQTT
or you can pick anything you want as
long as it's not
I have another reason in another reason
to not always use distributive airline
is beaucoup max you'll often were not
often thanks you're rarely that it will
happen come across bottlenecks we have a
system you run in distributed airline
all of a sudden and it was handling
instant messages and it was managing
your tens of thousands of requests per
second we moved over from instant
messaging to email and distributor and I
became the bottleneck and we sold that
running you're having open tcp IP
connections Splunk had similar problems
they do a lot of a lot of airliners days
and they've actually implemented a
library i think it's called general pc
which uses twin spools of sockets in
between those and they're able to manage
they were able to scale it up to about
60,000 or PC requests for a second in
between two notes and their Derby this
problem in the trans your soul is you're
pushing lots of logs from one point to
another from one node to another so once
you've picked your network the next
thing you need to do is go in and define
your note interfaces so you need to
define a high level API which each node
so you've spin up on denote the
functionality of the school knows you
need to going to figure out what api's
will these nodes its port so don't worry
about the internals architecture in
terms of you know yet you want to know
if this node calls this note what API do
we wanted to call and how how would that
communicate and you know when doing so
you know basically but they did it your
choice of the node functionality have we
put functionality in the right notes you
want to try to reduce communication
between nodes so you know when you're
you're deciding waveguide you're also
trying to figure out how you're
distributing your data and your state
across these notes and you want to try
to reduce the amount of data redundancy
and reduce the
munication between the nose and once you
have your eight guys go back and stand
it up is them so trying to have coherent
api's across all your systems and these
are the first four steps so I think
you're defining note interfaces is not
the easiest thing what I've always found
useful is to work for stories and you
know book for stories you go okay we're
going from this note to this note from
this note to that though and in doing so
you try to figure out what functions
they'll jump it from one node to another
will call and that's how you start
getting a high-level overview or what
you do and then you look at the function
calls you start figuring out what they
need to have duplicated or the various
nodes in order to to handle those calls
you follow me here yeah good so once
you've done that you need to start
thinking about availability so
availability basically defines the
uptime of your system over a certain
period of time and US airline years you
often hear us talk about high
availability and that's basically system
which never stops a system which has to
both have very very small down times and
that will include software upgrades and
maintains and the whole point of high
availability is the result of your
system having no single point of failure
has to be full tolerant it has to be
resilient and it has to be reliable and
all of these have you have different
meanings which I'm going to go into but
now so let's look at fault tolerance so
both tolerance approach to the village
of a system to act predictably under
failure and that means that if your
system returns an error if something's
going on your system returns an error it
has acted in a predictable way as long
as you define that so you know it client
sends a request to the front end server
the front lines over you know parses it
in turns in turn around turn sends it
over to the logic node and somewhere
along the way the logic know
so it could either return an error for a
timeout and the front that note that
sends back an heir to the client this is
a full tolerant system because it acts
predictably the client knows that there
is question need to succeed or fail and
so in decline softer we then go in and
handle that crazy a failure and it can
make it your retry or be an error shown
to the user or what not and no hear how
I just you know refer to this as a
simple error the simple error could be
what what what would a simple error be
at no reply and so no reply can be
because the request to the logic note
never got them we've got networks in
between and no don't believe what they
say the networks are reliable you know
there's only one thing alongside taxes
thefts and software bugs we shouldn't be
sure that your neck will not be reliable
so it could be that your only request or
lost it could be that the response got
lost it could be that the node crashed
it could be that the note had already
crashed it could be that the note is
incredibly slow and it's incredibly slow
and it's it's cued your request but it's
given with so many other things that you
canÃ­t on about it could be that a
process in you know this crash oh oh oh
yeah exactly so it can be a million
different things which can happen the
beauty with airline is I don't hear you
handle all of these all of these items
in exactly the same way but something's
gone wrong and if it's a processors
crash to supervise it with you it's a no
trash horrible deal forbidden restarted
so you're really yeah you're not you're
handling if you're simplifying
everything instead of dealing okay what
happens if there's a network error what
happens if this there's a process
crasher just deal with them in exactly
the same way and yeah that's will reduce
your co sighs dramatically on top of
full-color to go resilience and
resilience is the ability for a system
to recover from failure and recover
quickly so a client sends a request the
front end node terminates or the back
and determine if you sent back an error
or you're the client notices it by
timeout we quickly restart this from the
note and in doing so we resend the
request they're selling comics it in
Virginia we sent back an answer and
assuming their clients aware that you
could receive a narrative received
Americans to retry you whoever press the
refresh button understand button or
whatever isn't even aware of drama
happening behind the scenes so no
resilience is the ability of system to
recover from failure and then on top of
that we've got reliability and regard I
ability means your divinity of a system
to function under particular predefined
conditions and this includes errors and
inconsistent States we have we had a
customer who was saying oh you know our
system is enough a hundred seventeen up
and we've had one hundred percent of
times since we went live when people I
hope 10-15 years ago wow that's
impressive and then you start scratching
behind the scenes and you realize that
the front ends had never gone down as
soon as their logic notes failed all
they did was log the request and then
someone back office went in and you
think their lesson done with it manually
so yes the system had one hundred
percent availability but the reliability
was kak it was zero and so it's the judo
go hand in hand and what you also need
to keep in mind when you're dealing with
right minute is the whole
single point of failure where you need
at least two of everything is if
something goes wrong something else goes
in and you'll flip it and buy something
going wrong but it's not just software
it's not very hard work it could be
network it could be a power supply it
could be your system administrator
tripping over your network cable so tons
of things which can go wrong and in this
example you know when it comes to
reliability the client sends a request
their offense gets forwarded to back
their node so the logic node terminates
or me or something goes wrong so the
front end the server itself realizes
something is going wrong so without
telling the quad I forwards it to
another node and having done so
everybody sent back to the kind and once
again the client has no idea something's
going wrong behind the scenes we've
managed to isolate the failure and hide
it from from the car and you know
basically is having two of everything
ensures that if something goes wrong you
have an attorney to you you've got a
backup and now so these are the retry
strategies that there in total of three
different retry strategies so you can in
this case you we've sent a request we
forward your request to the logic node
but we're not sure if this request has
succeeded or not we get some form or
error timeout here so we go in and retry
it here and this will be cool at least
better than at least once attempt so
we've got in and we've tried something
at least once if it fails we continue
trying it again so picture an SMS you're
sending an SMS you hit SMS see you don't
get a response you hit another server
see that means the final result is that
you as a receipt
receive two copies of the same SMS is it
ever happened yeah this is probably what
what what you've seen here and it
doesn't really matter if that's the case
now what happens if you're sending a few
billion euros from Brussels to Greece
twice Greece is happy the bureaucrats in
Brussels aren't so you know that's the
typical case when you're dealing with
money or stocks or even premium rate SMS
is is that is the exactly what's
principle where you send the request
exactly once now exactly once is not
that easy because once you've sent it
and it's you know you cannot guarantee
it across distributed systems as soon as
you put a network in between no matter
how much you promise your neck was
unreliable something can and will go
wrong so what happens in with exactly
once is you send a request and if that
request fails you don't retry you send
back an error and when sending back an
error you then usually trigger some
script which start tracing which start
tracing the goal so over moving money
from Brussels to from Brussels degrees
okay when from Brussels to Italy right
yeah is did it reach the bank account in
it and yes it did I'm it has its own up
to this oh great and from Italy got
forwarded on to to Greece that every
crease no okay and you start narrowing
it down if you try to basically clean up
after yourselves and that's what happens
in banking there was a banking system we
used to work on where and as soon as the
exactly once request failed we had a
system called Hagrid which came along
you know Hagrid used to always save the
kids from trouble at Hogwarts and in
this case it basically saved us from
trouble whenever some
software my prom with that work in
between and then finally if you've got a
third one which is at the most ones at
the most once is when you fire off your
request but you never asked for an
acknowledgement back okay and that means
you've sent it off you couldn't lose it
but you don't really care and that's
also commonly used for SMS so those
times where you never receive that
semester that's the strategy to depict
for some of the software in between the
system where you send it off you don't
say stay you don't worry you just get on
with your life and that's the cheapest
of them all because you don't need to
wait there for a response so those are
the three things on top of that so those
are those are the three retry strategies
on top of that you need to start
thinking how do you share your data and
how do you share data across or across
one or more machines if you need full
tolerance you need at least two copies
of the data you need scalability you
need at least two copies of your data so
for all your data and stay what you need
to do is fit your sharing strategy
across nodes across clusters and you
need to take included into consideration
as well the needs of your retry strategy
so here's a here's an example we going
we send you login request and we start
you know client one is logged in and his
session is stored here this is a share
nothing approach client to those in logs
in and sections to stored here we lose a
backhand note so we lose a logic note
and a service though we go in we we
start with client one tries to coonoor
game and he's forwarded now to this
database which only has session to not
session one so we sent back an error on
one session so the client you're being
told that your your sessions or bad it
goes in and locks open again any Google
gone and now this node which is two up
we have both sessions and this is the
share nothing architecture which is
obviously also the most scalable it's
equivalent to Charlotte we've got to
share something where we might go in and
stairs share session but not share
specific data within that session so
assume you've got an econ
the site you've got a user who logs on
so it starts a session and we store the
session on two separate machines then he
goes in and start buying a book but the
shopping cart is not saved across to
machine so we only store the book in one
of the machines we lose that note and he
goes and buys a train set that trains
have now gets stored on another machine
market and that's to share something you
share some of your state but not
everything a lot of things can happen
there's no good restart you couldn't
then merge these your shopping baskets
together that's what Amazon does it
could be a network petition if there are
lots of things you need to think about
you're not subscribed sure and finally
you've got to share everything this is
an example we call primary primary
replication we go in we buy a book we
store it on both nodes we go in we buy a
train set and then we remove a book and
when we remove a book when this the
state well the snow comes back up again
it will copy all of the data will have
consistency and also your movie will
show everything if we need to think of
there might be cases where we use
eventual consistency crd DS casual
consistencies so lots of strategies
depending on your business logic and
when taking these choices here you've
done a lot of trade-offs here this is a
system which is not available or rope
and as you go along the axis the more
available it becomes and consistency
you've got casual consistence will be
consistency and as you go up you start
moving up towards strong consistency
where you're guaranteed the response and
the exactly once approach is strong
that's also the least available because
if you lose a note you might have to
take your system offline to guarantee
consistency and you've got the least
once at least in the middle and at most
once is obviously you know the most
available because you just fire and
forget but it's also the least
consistent because you might lose
request along the way and so your date
that doesn't become that consistence and
the same applies to reliability you
share everything is obviously the most
reliable you lose a copy of the data
you've got
another copy store somewhere but the
network traffic becomes really expensive
as soon as you get a network partition
you lose your availability once again
you might have to take a system of I'm
sure something is somewhere between and
then share nothing obviously it's the
least reliable because if you lose the
machine you do that all the data on it
but obviously it's the most most
available one so these are the five
fifth and sixth step you know every
interface function you need to pick a
redress strategy and you're all your
date and state your picture sharing
strategy across no families no family is
a group of those of the same type and a
group of no families together will give
you a cluster and then your cluster
together will give you your own system
so once you've done these design choices
you might not have realized it but
you've also made already make trade-offs
which come and are directly associated
with your scalability and when you're
skating out you have to be very you know
careful and integrated with
orchestration and also with your
consistency models in your system and
you know when you're skating out most of
the time you're skating out means
capacity planning so it's going in and
actually proving that your system can
handle the load it was designed to
handle and and then we've time here you
can also schedule to increase demand
without failing or full analysis know
back in the good old days we used to
scale vertically the defeating of
opening that box and having the fastest
Chinese computers but skating vertically
by playing manual powerful hardware is
pretty expensive it is not
environmentally friendly because the
bigger your computer get me more
poisonous to stuff in it and it's yeah
it's not the way we do things today
today we scaled using commodity servers
commodity hardware if we scale
horizontally and just by throwing more
service at the problem and then you're
sharing data across them and so as I
mentioned earlier when you reach this
point you already have made all your
trade-offs in the previous section and
you know when you look at the
consistency that the most one says
there's also released scalable of
resolutions and only once is the most
scalable and little bit you share
everything once again it's at least
scalable share nothing is the most cool
and so this is the point where I mean
your capacity County who start stress
test in your system you stop stress as
you system for two reasons what is you
know to make sure it's stable to make
sure it can handle the road to optimize
bottlenecks and get rid of vocal mix and
during your capacity planning you will
most probably go back and revisit many
of the architectural assumptions you
took in the first round and luckily if
you've broken everything up into small
nodes no types having a few more node
types or you're changing your sharding
or your the way you partition to share
your native won't be that difficult as
long as you capsulated your database in
the right way and so you'll have a few
iterations and you know show that you
can handle the load but also very
important is know when to apply back
pressure and road regulation so you're
back pressure when you start rejecting
calls because your system's overloaded
and load regulation is usually using
queuing to scale out your peaks and
troughs so you've got a third-party API
your third-party I can only handle 150
second you get 200 FS coming in your
queue and I'm going to take them on a
first-come first-serve basis yeah and
you know you've got jobs and safety
valve here jobs if it's a beaker of bio
figure and safety valve by I'm just
previous Anderson and you know there are
two great you know they hate it for
different types of solutions i think
jobs is fairly complicated but will
actually do you coffee in the morning as
well safety about this much seed simpler
much easier and much easier to get going
women both work right and so once you
put your background in your drug
regulation you need to start thinking
about monitoring and preemptive support
but you know we'll take this another day
as i realized
they're probably beers outside waiting
for us but just to review you know these
are the ten steps you know speaker
systems functionality into manageable
standard on those you will be optimizing
notes you will be configuring your whole
stack you know os-level vm level and
your code is well fine tuning it a
network level is well that matter decide
will distribute architectural packages
on to use and it's often a mixture of it
architectural patterns and this time
what network protocols you want to use
to have your notes communicate once
again there's no one-size-fits-all it
will be can be a mixture of them they
find your node interfaces states and
data model and for every interface
function you need to repeat a recruiter
strategy so you need to know if calling
this function fails what we dress
strategy joining you and this is
something a very rarely see done and
this is exactly what leaves your system
is an inconsistent state and some point
or another and then finally you know for
your native state you know pick your
sharing strategies across notes no
families in your clusters and systems
and write rehydrate through all of the
steps until you have one of the
trade-offs which suits what you're
trying to do look at your cluster bloopy
look at how your systems going to scale
up and down through time and identify
where goodbye back pressure and last but
not least come back next year don't talk
about your OEM approach and your folks
are no we have approached has to be your
creative support you want five nines
uptime that's a few minutes per here you
need to automate a lot of your support
you notice something's going wrong you
need to trigger scripts which the over
it and also your divinity to do
post-mortem debugging under full
visibility and you know I'll leave you
with one last word of advice and it's do
not over engineered systems every want
to build the next whatsapp the next
Facebook or whatnot but before you start
reaching that scale you need users and
you need to go now if so start taking a
step
if you've split up your note into small
standalone units start simple and then
add complexity when you see it you know
so think Lee your solve problems when
and where yeah it's an issue ok any
questions think we're running away we
were way behind anyways yeah man you
before those of you don't know me Robert
a yard or we're using the last place to
always get on a plane yes yes yeah
exactly yeah anyway I could just say
what one comment yet one is to better
engineering if you think about it
whatsapp is actually quite a simple
fantasia one of the reasons it work
because they decided not to over engine
area and keep it simple and yet so good
look what you should do like that yes I
mean you want to get something out up
and running and you don't get you don't
want to make sure that we have is work
so yeah all of this is the result of
your trying to formalize you know what's
it's been going from ahead in last 15
years whenever I've designed a lot of
these systems and I think we just put
the chapters to arrival available as
early release so you'll probably find
them on BitTorrent and in a week or two
and I've got no problems with it at all
you know try before you buy and if you
like it no one should pay a full price
for a variety book so use the distemper
we don't set the prices and yeah they've
got ya look but yeah it's no point you
know they're fantastic publisher I can
recommend they've got an amazing team to
really support from beginning to end but
use this time code alpha T for fifty
percent dr. Davies defintely talking for
if there's forty percent of printed
copies and what I should not be telling
is that this discount code works on all
the other variety well okay thank you
very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>