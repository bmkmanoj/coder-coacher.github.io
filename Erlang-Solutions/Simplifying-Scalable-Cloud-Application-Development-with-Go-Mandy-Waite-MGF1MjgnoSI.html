<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Simplifying Scalable Cloud Application Development with Go - Mandy Waite | Coder Coacher - Coaching Coders</title><meta content="Simplifying Scalable Cloud Application Development with Go - Mandy Waite - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Simplifying Scalable Cloud Application Development with Go - Mandy Waite</b></h2><h5 class="post__date">2015-11-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/MGF1MjgnoSI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">logica application development
particular in the cloud and that
includes some of the things that I work
on from day to day which is cube natives
docker things like Etsy d and other
things as well so if you have any
questions if they're really boning
questions sick hand up nom du my
basement if not we're saving for the end
I may not be actual answer all of your
questions but I do know a product team
that might be able to answer them so if
I kind of them I'll get your answer for
you you can tweet me on at tek gwil and
it's at the end there's normally on all
my slides i'm using this special for my
today so let's talk about golang and go
is eventually an open source programming
language but one of the key aspects of
it is that is very easy to build
reliable software with it and that's
really why we made it because the goal
is internally at least and now generally
to make it much easier to build things
with applications that can scale to
large lines are cut large amounts of
large lines of code and also too many
users and to scale across our entire
enterprise such as Google's one of the
non goals there's really two not
basically do more research into
programming language development it's
that's not what it's for it's not really
there to say hey look we build a bigger
better language and you have I think
some languages are probably a little bit
guilty at their go Lang is here purely
and simply because we need is something
different and so we decided to build it
not necessarily from scratches has many
see fundamentals but we did want to
design it to meet our own requirements
and some of those have removed from here
the kind of things I'm don't like
talking about because they're kind of
hubris things like how many millions of
machines we have or how many millions of
lines of code we have we have lots of
code we have lots of machines and we
have lots of things we need to run we
need to run in an efficient and very
very reliable way because how many of
you have actually been to google search
and found it in work it doesn't happen
some of Latin way ask that questions on
bananas if I use Bing which is kind of
funny so we need reliable systems people
depend on these systems and we wouldn't
be successful if we didn't haven't
things that people who go 200 batteries
my voice is going on really this
apologize I find it really hard to give
talks from my voice is Gomes I'm
focusing on my voice and not on my talks
my content oh I'm doof come on emergency
repairs you stop working at moment you
guys can hear me tomorrow okay call
anyone doing a million SEK Bochy that
Wow yeah it was in secretary people
talked about it it wasn't actually built
and ready in two thousand seven minutes
when we first started talking about it
lots of interest in famous people who
were involved and more since and also
it's been open source since 2009 very
actually community its language wise on
github it has more stars except for two
other languages I'm not quite sure they
are if you can guess let me know the
language is pretty much stable go 1.0
1.0 was released in 2012 and we've had
six iterations now of product ready code
so at Google we use it quite extensively
but we still use other languages we
still use things like Java we still use
things like pythons we still use
JavaScript and closer and all of those
kind of things that we've developed in
the past we still use all of that stuff
but we do have many many projects that
have written lingo purely millions of
lines of code and some of the examples
of public facing efforts are things like
Cuba Native communities is a cluster
manager container cluster manager which
we will talk about shortly well don't
talk about it in detail that's my other
talk
also download servers for downloading
stuff from the chrome for Chrome OS and
for Android manage one of those
dependencies and also a thing called a
YouTube for tests which is a MySQL
balancer I'm not sure why he's got
balance on that but it basically allows
us to run shouted mysql in containers
everybody wants to run everything good
things nowadays and this is a really
great pattern for deploying sharded
versions of MySQL highly scalable in
containers and the docker containers on
cue blazes effectively so basically the
original target was to build network
systems with it large-scale systems a
bit but it has become a more general
purpose and I think we have to kind of
like pivot a little bit on the way we
design it and develop it because that
general purpose use wasn't really
probably there on the outset we didn't
probably aim for that initially but it's
getting more more general now so who
uses it besides google so many many
people and many big names on there
including people at Twitter have written
extensively about some of the things
that they've done with it same with past
calm for facebook people like SoundCloud
and also interesting the uber use it as
well so many many different people use
it and we'll look at how we can actually
run go later as well so concurrency
let's talk about concurrency so this
talk really was explaining to
concurrency is not parallelism and
concurrency and parallelism comparing
them I don't wanna get into that
arguments I know it's kind of religious
how many people think and currency is
parallel ISM here because that's the
argument that's been going around for
quite a while and I didn't want to get
into it because it seems to be fairly
devices so let's just define concurrence
on its own without worrying too much
about what parallel ism is the ability
to actually run things parallel in
parallel concurrent program becomes kind
of like a software model a development
model because i think when i first
started doing concurrent development
just with the standard Fred library in
Java like 10 years ago 12 years ago it
was kind of very hard to reason about
things he was very hard to actually
think about what you would
doing and I think what go is kind of
pushing towards is having us making this
an actual model for software development
so that's what we need it yeah the
Maritimes I've actually thought of how
an IDE would look that would allow and
support concurrent application
development being able to highlight
where your code path was based on
certain operations because Code Red
sequentially and functionally doesn't
always scan very well because you never
always quite sure what it's doing at any
given time particularly in parallel so
being as a model concurrency is very
very important it's becoming much more
important as well and there's simply
simpler we can make that the better so
effectively concurrency becomes a way to
structure a software the way to modular
software and ultimately in a way that
supports the development of clean code
that interacts very well with the real
well with things that we care about and
concurrent programs can of course one on
a single processor we have the schedule
to thank for that we don't have to kind
of block on Fred running on a cpu we can
run concurrent tasks or task and
currently on the same single processor
and of course a well-written this is
kind of sketchy as well a well-written
concurrent programming might run
efficiently on in parallel on a
multiprocessor machine that is not a
given because we all know the
complexities of doing this kind of stuff
and I read an eight article by somebody
who works at Dhaka currently today on
concurrency and he had to apologize busy
got it quite wrong his code was very
very wrong and he was corrected by
somebody else so it's quite one thing to
actually run concurrent applications and
single process so it's a different thing
entirely to run them on a multiprocessor
where race conditions are much more
likely to be prevalent so being at a
model concurrency is extremely important
and that's quite important for the go
language and this has had this right
from the start this hasn't been added on
afterwards this is a core part of the
language itself so ultimately as a model
for software construction concurrency
has to be easy to understand
has to be easy to use and ultimately it
has to be easy to reason about it has to
be that you can look at your code or
look at somebody else's code and
actually understand what it does and I
don't think that's always going to be
the case we have code that actually is
written on a single screen goes from top
to bottom without actually having some
kind of directors it show that kind of
thing being broken off but I think go
take one step forward to making it a
little bit more readable little but a
little bit more easy to reason I
understand so concurrency in go
concurrency in go is really supported by
two main concepts there are other things
as well or supporting libraries that
help us prologo really go into much
detail with them today the verse is a go
routine and the going scene is a like a
thread of control it's not an actual OS
Fred but it has its own local variables
in habits and stack and we're getting
some more details about some of the
features a go and see shortly these
things we are very easy to create and
they're very cheap to create as well
unlike friends which are generally much
more expensive they have stacks they
come at a cost to actually create which
is why we do a lot of fred pointing in
operating systems and ultimately we have
this thing called a channel that carries
direct messages everything is tight and
go it's a statically typed language and
we use the channel to actually pass
messages between go routines ok so this
is a boring example and it's not that
boring then hopefully it's not boring
talk but just an example in some of
these examples of course they're gonna
be a little bit contrived so the way we
present code in this present thing we
actually edit this code we can add
additional impossibly want to know quite
like that it makes life easy to use but
the one thing I miss from my
presentations in Google Docs is that I
cannot collaborate easy on these slides
I can't share them in my colleagues and
have them comment on them it's a lot
more well a lot less collaborating that
way but it does have some important
features and the ability to edit code
live and to run code is extremely
important so this is a go program some
of you we were already familiar ago will
know
do what this does most of you will be
out to enfold it does anyway because
it's fairly straightforward the syntax
is very see like we have semicolons then
there's no semicolons but they are there
ultimately they get added by the lexer
at some point I kind of like dislike
that because it's like we're hiding
these things but no real reason at all
and it's anything about goal and I don't
really like but we do have curly braces
we have functions we have imports we
have packages everything can go is in a
package and we can import other packages
using the import statements so it's very
easy to do dependency management within
go and you will find that once you use
it it is quite easy to manage those
dependencies there's some really good
documentation about the nightmares you
have to go through with see I think if
anybody's at Dundee C or C++ development
you know what it's like to have lots of
different include and lots of different
files so go ultimately symptom eyes that
and there are some rules I'm not going
to talk about today's only get into
concurrency but ultimately here we have
a main package if you want to have a
executed all command line executable we
need to have a main package and we also
had to have a main function this is the
entry point that the underlying
operating system so in this case we have
a function called main and we have a
function called boring and the main
function calls boring so it's one that
code see what happens you can see what
you know what it's going to do right can
you see that you guys are the back seat
yeah okay so we know but it's going to
do it's going to iterate it's going to
keep on printing boring boring boring
boring it is pretty boring right so
that's an example what we can do is make
it slightly less boring in this case we
just add a variable sleep in there so we
now have a very roll between zero and
one second sleep time and that looks a
little bit different because this is
pretty straightforward right so how
duration for our sleep is random now
and we can close that and go into the
next one we can do that in the
background so it's generally fairly
simple to do this kind of thing in most
languages and I'd not familiar with all
languages I am not familiar with the
likes of Skylar I don't develop in
schuyler but I know that there are very
very good support / concurrency many
many different languages nowadays I'm
still back in the old days of Java when
you use their to do Fred that ran and
suchlike and concurrent libraries that
Jarrah introduced of made life a lot
easier for other people Python I've
written a lot of code in Python this not
so easy to concurrency in Python but we
think go is pretty easy and for this
really to run that method that function
in a background all we have to do is add
this keyword go and that's effectively
creating a goatee this will go off and
do this on a nova Fred or Lisa will
execute him another Fred it will create
the girl we sing for us and something
within go itself will actually scheduled
out on your printing system and again
the operating system will schedule out
Fred for execution at some point so
we're doing this in the background and
you can guess what's going to happen
with this one way it's going to fall off
the end and nothing is actually going to
happen because we entered the main
function we called the the boring
function on end of a Fred we didn't
block we fell off the end of the program
the program exited and say that they'll
go rooting ok so what we could do is
maybe do something crazy like this which
is stick of sleep in there so we can
actually see something happen so this is
the same code I'm not showing it all we
have the ability to actually hide some
code within the code file that were
included in the presentation and I've
done that here so basically we can just
see the main method and main method
again it starts up to go routine we
print I miss then we sleep for a little
while two seconds in this case and then
we print your boring i'm leaving and we
can run that
that's what it does interesting thing
about this and 1p I can't actually
understand currently and I need to get
to the bottom of it is it you always
does five iterations and there is no
account is indefinite we could loop
forever i change this for seven to free
it will always do seven and i had no
explanation for that currently so
anybody can think of one let me know but
i will investigate this is quite strange
right so basically we were shooting a
little bit here we are off doing
something on a different thread of
execution we're printing to the screen
and we're instantly even what's coming
out from the other routinely go routine
itself to the screen at the same time we
can do this a little bit differently and
we could use weight groups and i'm not
really going to talk about weight groups
i did this slide earlier just to kind of
show how it could be done in a better
way in this case we use a weight group
and the sink library moving go has a
couple of options one is the ability to
run things only once only once you may
try to run it many times but you'll only
be able to do at once or we have a
weight group and now in this case we can
say a lack of condition variable like
we're waiting on a condition variable we
effectively want to count down until all
the threads that are on this way group
actually completed and to do this we
basically create our go routine we
create a weight group as a global
variable we do WG to add to effectively
say we're starting the girl routine at
this point and we allow to go route seem
to remove itself from the weight group
and it does that using a diff the
first statement basically that means do
this at the end when we finished and
they were saying defer WG lot done so
remove ourselves once we finished
executing so done will effectively
remove us from the weight group and down
here we block on w0 weights which means
we're waiting for all of the threads the
registered awake group to finish I want
to go with things that are registered
with different weight group to finish
sorry so ultimately what happens with
this one something like this in this
case I'm just printing 10 times so the
actual go routine in this case would do
10 iterations of the print boring and we
would wait for all tend to complete we
could do that on 10 separate go routines
we wanted to in which case we were just
kind of increment that and in one or a
time to the weight group and then wait
for Easter routine to finish them take
that offered away group okay so go
routines effectively very similar to
lightweight Fred's they are not Fred's
much more lightweight they start off
with very small snacks and they can be
resized as needed going programs can
potentially have hundreds of thousands
of them and you can get away with that
you can't really get away without their
threads which may have half a k 1 k even
bigger stacks and that grows very
quickly and also to grow everything very
simple you decide to go go keyword and
you pass in a function or maybe a
closure and we look at some closures
shortly it's ultimately the go runtime
that schedules these go routines on to
iOS threads and ultimately the scheduler
on the operating system that schedule
those on the processor any block go
routines don't use a OS Fred so again
they're very lightweight ok so going
back to our original go cheating
application which one that one no one no
we seated here we actually waited we
weren't actually doing these things
together they weren't both cooperating
right into the screen they were doing
them doing this independently so the
main thread will be writing I'm
listening and you're boring i'm leaving
and the day routine would be writing
boring 0 4 in 1 et cetera so they
weren't really collaborating with each
other they weren't communicating the
beach or in any way so in order to
real-time communications actual real
communications between go over things we
need
to have some construct and that contract
is the channel so a channel and go
effectively provides some kind of
connectivity between two running doe
things and that includes the main go
routine as well that's funny news I'm
afraid so this effectively allows them
to communicate and declaring and
initializing is fairly straightforward
we have two ways to declare variables or
initialize variables as well we can go
we can either do VAR c CH an int that
means we're creating a channel of inks
and channels are typed we can't use the
channel event with strings for example
and then we create the channel itself
using this make command they don't worry
about the details behind the make
command it's a kind of idiomatic so just
make Chan int will create the channel or
we can do it with the shorter form which
is just C colon equals not an assignment
operators such as a short variable
declaration operator and we can assign
that straight to see using inference in
order to send a message alert channel
and again one here is literal we're just
sending that to the channel using this
send operator let's call it a send
operator it's like a cruiser so
effectively we're saying is the channel
send one on to this channel and you'll
also receive from the channel we have
value equals and then receive from the
sea from see from the channel so this is
the receive operator and in this case
we're using slightly different forms we
have white space on the first one that's
not absolutely necessary you can do it
any way you like it just makes it more
readable and effectively here we have a
much more much more useful way of
actually present in that as we're saying
this thing will be assigned to this
value as opposed to making it another
part of the operator Lackey course it
doesn't read some very war if you
separate them with white space but it is
possible so ultimately we will receive a
value from the channel write it to the
value variable
so in order to use channels and we have
some more example code in this case
we're going actually tie the go routine
to functional boring with the main
thread and in order to do this we create
a channel a strike a channel for Strings
in this case and then we call our day
routine without function and in this
case we pass in the channel so we had to
hide the channel available to both go
routines the sender and a receiver so we
pass it into the guarantee and then we
effectively iterate and we receive from
the channel so in the printf statement
format is a package that we use for
printing to determine water some kind of
output device so we're receiving from a
channel and in the boring function we
take the channel and now we continuously
send messages to the channel so again
we're using this operator and that's
sending messages to the channel we had
to send here we have to receive up there
and really nothing can happen until both
of them already okay so if the receiver
is ready to receive but there's nothing
there it will block if the sender is
ready to send but there's nothing to
receive it will block so either of them
can blog and our point things only will
start happening once both of them
already so once we have something to
send and when we have sown to receive
that's when things will start so this
point point the main function will drop
into the loop it will stop while it's
receiving and so something comes along
on the channel from the boring goin seen
and we'll move forward and that will
look something like this and we use in
again around and duration so we'll see
something similar to what we saw before
but we now actually are okay so we only
got a counter five in the loop here I
don't know why I did that didn't need to
so basically we just counted to five we
sent five messages to the channel and
then we exited the program all right
okay cool I felt more I want to say
about that no so this saga right
synchronization just go back over that
again so when the main function executes
the receive operator with the channel it
will effectively wait for availing to be
sent and similarly when the go insane
the boring function executes see receive
value it will receive receipt or same
value movement when a boy and potentates
accuse yeah okay if you wasted a
receiver to be ready so the sender and
receiver must both be ready they must
both be able to play their part in the
communication of wise they're going to
stick there and obviously that's
difficult week inclusion also by other
means or even on either go over things
so ultimately the channels will
communicate and synchronize okay so the
next one is a select statement the
Select statement isn't like a standard
type of select statement but some
languages that have these in this case
it has a special purpose very special
purpose that is for channels only in
this case what we're going to do is
going to have two channels we care about
and whichever one sees some some data
initially will be the one that we care
about as one it will be selected then we
will exit the Select so this case we
have a very trivial example we're saying
we receive men or we sent from be so and
what we're going to do is show a better
example here because it actually
clarifies how they work better than that
example I'm interchange it but basically
we're going to blocking that select
statement until one of those channels
becomes active and then that will be the
channel we've selected that's the one
we're going to use we can continuously
go back into that select statement over
and over again so receive new stuff and
we'll see that shortly so we're going to
use a very trivial example as well but
it's like based on Google search so how
does Google search work and as good with
those of a good question we are setting
interview questions
and it's quite complicated because it's
really really fast and most people don't
really not really able to articulate how
it does it and the reason is because
it's so simple which is like we're going
to show you now we're going to build it
in a few lines of code this is google
search well it's not it's fake search so
what does google search actually do
given some kind of query it will return
a set of search engine result pages
serps and some ads as well probably and
maybe some other things you don't want
all right how do we get these search
results so ultimately we send a query to
a bunch of different backends so it's
not as Baumbach india we talking some
many different backends and when you
look at google search you have images
videos you have lots of different things
there and books you can say which one
you want to search specifically but
otherwise will aggregate across always
the backends that we have and so
basically we send the same query to the
web search to in research to youtube
Maps news etc and then we get all the
results the government mix it up and
send them back to the user obviously
page ranks in bold as well and that's
actually important but how can we
implement that in a trivial way so
here's our fake framework and the code
here is fairly straightforward interest
in its introducing some new concepts the
first one is the idea of a type we're
creating a type called search which is
effectively a function and the function
will take a query string and return a
result interestingly haven't gone over
this we've been going but we had the
name first and we have the type and we
had the return value at the end and a
return value can be a name value as well
which we see shortly so here we'll worry
about the variable definitions at the
top well not yet we first look at the
lower part of the code here we have a
function called fake search which takes
a kind and the kind would be evil web in
means your video in this case that's the
kind of back in we're going to be
creating this effectively is the
implementation of our back-end fake
search and it will return a search
object most search functions very a
search function which is the one we've
defined here in the bold so the function
will take a query string and it will
return a result inside that we will
sleep for some
random at a time up to 100 milliseconds
and we will return the result which
effectively string in this case and
you'll say the kind result for query
okay so we'll say something like web
resort for golang and that's all it does
so we're basically stubbing out the back
end very very simple Google back end so
at a stop deal we create some variables
and each one of those will be a fake
search so we're going to call fake
search and we're going to get the
function back which is effectively a
closure and that will be assigned to the
value so we have web image and video
they'll all be one of these functions
that we've returned here okay so very
simple test we haven't implemented a
Google function we do that shortly but
that's the representation of the Google
back end and the query parameter is
going in this case so that's equation
we're going to pass on to all of our
back ends in this case in the main
function we just start we get the time
we get the results then we calculate the
elapsed time print the results and print
elapsed and it should look something
like this and so now 100 milliseconds
maximum each will Rumble that's what a
random random time interval was so we're
going to get back web result for goal an
image result the goal and video result
the golan so we're searching all three
of our back ends with the string going
and every time you run that we will get
back a different value for the time
elapsed and that will go up to 300
milliseconds obviously it will freedom
took the maximum amount of time and down
to some very small value they will
remember airy quickly okay so this is
the implementations that Google function
we saw on the previous slide this is a
serial version of it so very simply we
were all just in a serial way we will
execute each of the back ends and append
the results we get back to a slice of
results it's effectively again in this
case is a slice of strings because a
result in this code is a string your
notes here that the riesling parameter
which is here
is named so it has a name which means
effectively it's like very similar to
actually declaring it at the top of the
function so we're basically saying I
want a result size called results which
we're going to use one of our results
and then we're going to return it later
so in this case what we do is we
effectively append to that slice the
results from each of the back ends okay
one after the other and then we return
and again this is a naked return and
that's possible because we named the
returns up the return value at the top
down so this will ultimately return
results and we run this we will see
exactly the same as what we saw before
this is the same implementation the same
grid and we'll see High Times and low
times what we need to be added udo is do
that in parallel so we have the same
function definition here takes a query
string which sounds a slice of results
this case we use a channel which will be
run in everything in the go routine so
we need to get to click the results back
from those go routines and there's one
and go with things and we do that with a
channel of results and in this case we
do a query will run each of our fake
search backends web query image query
video query the query in this case going
to be doling and we send the results
back to the channel which we pass in
which we hadn't passing because we do
needs as closures we can actually access
see from within the actual main function
here not a Google function now so each
one of those global teams will run right
is results to the channel and down here
we know we're going to get free results
back we can iterate three times read
from the channel three times and append
that to the results array and in return
that way we send that array so now
hopefully it would be quicker and with
all these things are probably the graph
to be able to compare the results from
one test to another but I don't have
that ability at the moment usually it
but in this case we should see
everything starts ask you a little bit
lower we saw some quite large times
earlier
200 milliseconds okay and such a now
begin to run a few more time to see if
it does skew a little bit lower and so
it's looking like everything's running a
bit more a bit quicker now right all
these things are run in the background
effectively we have 300 milliseconds
running together we should never see
anything above 100 milliseconds okay so
next thing to do is to limit that a
little bit so let's do a timeout after
80 milliseconds so in this case we have
the same code but we've added a select
statement and we've also added this here
so time after 80 milliseconds so
basically once we hit this we will wait
18 million seconds before creating a
channel called timeout that's not
exactly right sorry we will create a
channel called time act and we will
write to that channel once 80
milliseconds of actually elapsed so
we'll be right into that channel at some
point at the moment the this actual
statement here will create the channel
will right through it once the timer has
finished and down here we had the Select
statement and we're going to do this
three times because we have three pieces
of data going to the channel we're going
to wait for one or two things to happen
even a case that something will write to
see or we can hit the timeout okay so
there are two options erodes can happen
so let's run that and see what does
happen I say you see the first one time
now so that one was over 80 milliseconds
and we can run maximum 400 milliseconds
that one was over 80 milliseconds that
was the web one the image and video ones
returned within time and it did it in 82
milliseconds so because we hit the
timeout it's always going to take it 80
milliseconds whenever we do hit a
timeout but sometimes we won't hit the
timeout at all so in that case we can
hit the time out when we still to 80
seconds 80 milliseconds there's an
example we did web image and video all
in 49 milliseconds we run it again we
get a timeout say in this case to be
running for long enough we'll probably
get one where all of them timeout it did
work for me earlier but it's nothing
work me now but anyway you can see now
we're saying don't wait longer than 80
milliseconds and if web slow we won't
send backward results if images slow we
weren't back send back imagery levels
okay so that's one thing so in order to
avoid a timeout we can go back to doing
what Jeff Dean talked about longtail
agency and having what they call hedged
requests we're basically we're hedging
our bets on a number of backends that
can ultimately serve our content for us
or do whatever we need them to do for us
and by having multiple back ends that
are identical we can say do this for me
and I'll take the quickest one that
comes back okay so we send it's a free
one of them comes back in so in the
milliseconds one compact the under-
seconds one comes back and fifty we only
care about the first one to come back in
50 milliseconds we can discard the
others that's called hedge requests so
effectively what we're going to do here
is the same thing with multiple replicas
of our backends so for this we're going
to create a new function this is one we
can ultimately replace our closure with
that we had earlier and this will take a
query string and a variable number of
replicas it could be two could be free
again it's a variac declaration of very
variable we create the channel this time
we've probably seen this before in other
slides we actually we actually buffer
the channel so we know we have an X
number of replicas we care about results
from them we don't want to lose them we
don't really care about and going back
to our friends in but we don't want to
lose them so we're going to buffer and
we're going to buffer by length replicas
so that's the limp for the actual
replicas slice and then we're going to
create another function and have a
closure which is we write into the
channel we've created the general
results and then we're going to iterate
across the number of replicas using this
range function that eventually allows us
to arrange across an entire array or a
channel and I'm not going to get into
there today but it's quite interesting
and ultimately we're going to run search
replica at function we created earlier
in a girl routine and passing the
d it's rated value the value of I and
then we're going to write one result
back where are you going to return one
result we're not going to its own all of
them which is why we had this here ray
what are doing this because you only
really care about one result so we're
returning that one first result that we
get back on the channel and we can do
this here this is the first iteration of
it where we're just using the replicas
here and we'll have a more extended
version which I think I'll get you
straight away which is this version here
where we replace the goal thing that we
had earlier with our first function in
this case we say this is the query we
have two webs we have two images and two
videos and we also have a timeout as
well so we're going to try to make
everything happen within 80 milliseconds
because now we have multiple backends we
increase in our chances of that
happening so now the rest of the code is
the same we run this now what we see is
the timing doesn't always look much
better but one thing you will notice is
we never get any timeouts now um that
one we get many many less time outs now
it's still possible for us to get
timeouts but it's much less likely and
so we know we're skewing to lower values
here if we have more more backends we
dramatically reduce the chance of ever
having that timeout and that's the way
we deal with a long tail latency and
still we have no locks though condition
variables no callback something just
think about how much work it would take
again I know you guys have amazing
languages so you can probably do so soon
as it is in your language but in some of
the more standard languages like C and
C++ and Java it's probably it going to
be a lot more complicated or build yes
then it would be everything go so in
summary we've taken something that was
slow sequential and failure sensitive to
something as fast concurrent replicated
and robust let's talk quickly about
tools we finish the concurrency section
go had some great tools go format and go
imports some of these things are already
integrated into my IDE of choice which
I'm not going to go to
which is Aten so I use that info oh my
go development and again we google it
doesn't matter so much which ones we use
we we had support from many different
options now having Google there's also
the goats always well the command line
tool and also go doc for creating
documentation good IDE needed support
which were probably able year ago it
would have been not so easy to say that
things like eclipse IntelliJ Emacs
fillmore Willam had a major support for
it we have code completion code
navigation all these there is no
official go IDE but many different
plugins also it's supported by most the
major collaborators including Heroku
google app engine sure elastic beanstalk
so you can run app engine on those
indeed I have my slides actually running
on or what it happen I don't have a
connectivity either connectivity
currently so anyway I have my slides
deployed here i will share them with you
later and ultimately app engine has a
couple of options they has a rapid
massively scalable sandbox runtime which
has some restrictions and what you can
do in terms of the language but it's
also massively scalable this is what
snapchat we're on and also we had the vm
base one time which runs your stuff in
docker containers this is much more
flexible it supports pretty much any
language constructs you choose you can
really be completely flexible about what
you run on this but it offers standard
auto scaling it doesn't have our
complicated sandbox auto scaling
functionality but ultimately is going to
get better and we feel we're going to
run p up so the point where it's going
to be as good as App Engine the original
app engine also we have idiomatic client
libraries so we have these in
development currently they support many
of the Google Cloud functions currently
but these are basically handcrafted we
normally also jet automatically generate
all of our libraries so what we're doing
with these is we take the automatically
generated ones and add stuff on top of
them and this is all handcrafted all
written by
and but it is idiomatic gen
auto-generated libraries are generally
not idiomatic at all in a very very low
level so these libraries are an acts of
love basically and large-scale projects
they use go we have Cuban 80s docker I
guess you guys are all familiar with dr.
probably to blazes if you check out a CD
which is used by communities it's a
distributed configuration management
tool saying like zookeeper give you a
more familiar with that also something
called the test fisherman mentioned
earlier four-sided MySQL servers in
containers if you want to find out more
you can go to tour golang org there's
also a playground which you can run with
your code online you can do the
presentation stuff you want to I can
show you how to do that it's not in my
slides you can go to golang org wiki to
learn lots of tutorials there and the
projects itself is on go alone but all
test project you can also contribute to
get go as well on github that's it thank
you so much thanks listen how many of
you developer advocates anyone who went
okay please speak to more developer
advocates these were some questions
they'll ask me at sea EKG double RL on
Twitter so you can get me if you have
any questions and I'll be happy to
answer them thank
just a question regarding communicating
over channels is data being copied or
shared between the sender and the
receiver copy of shared now so how do
you mean sigh like you have a copy of it
you have a copy of it within everything
so and you have ultimately write it to
some variable within the receiver that's
what you can do so it's effectively
copying it yeah but it's got me right
where it's sending it and receiving it
so like if you are sending a message to
somebody that a person received it they
can store a copy of it you don't
actually have to make a copy of it you
can actually use that as a gating
function so you basically waiting on a
channel for something that happen so it
rise to that channel and all you do is
block on that call so soon as it happens
you carry on so it doesn't actually have
to receive anything from it so not
effectively copying it but it can copy
of it that data will be available on the
other end of the channel like it Michael
any other questions I can you monitor or
can supervise processes I go routines as
in OT Peters for Erling you can power to
know about it OTP basically monitor or
supervisor process wonders of your go
routine crashes will died you can
profile it using a profiler you have a
way of actually recovering from a crash
Fred or crashed a lightweight process of
emailing we can link and you can walk
you can monitor and you can supervise
your processes you know that's not that
I'm aware of but I'm maybe I don't know
all of the complicated language
structures there may be something there
that's available and certainly is an
open source tools so people would have
probably come across those kind of
things enriching something similar but
you may be available from somebody else
or this is an open source package on
project tool now get out I can find out
why you'd be interested I don't think
exactly
you know your questions we hope our your
Charles what are your channels multiplex
between go routines are they multiplied
between girl things you can know not
gonna be read by many yes you can find
in you can do both fan in and found out
and poke them I don't have any examples
of it all down for the concurrency
talked I actually took some of my first
sides from which is by Rob Pike it's on
YouTube and he does go into fan in and
found out on channels but up in that
talk I just have time I really wanted to
show you example to end yeah no no thank
you facing questions alright guys if you
have any questions in the meantime just
tweet me te kg double RL I wish I'd
never use that because nobody ever
remembers it it should be remembered
memorable right it's not te KGW RL and
so just tweet me I'll do my best to
answer your questions if not I'll find
somebody new products protecting we can
thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>