<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tech Mesh 2012 - Post Functional - David Nolen | Coder Coacher - Coaching Coders</title><meta content="Tech Mesh 2012 - Post Functional - David Nolen - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tech Mesh 2012 - Post Functional - David Nolen</b></h2><h5 class="post__date">2013-09-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LXVLrfgQgiQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my talk is called post functional
it's a purposefully controversial
sounding it's not as bad as it sounds so
I want this talk to sort of explore I
think there's been a lot of enthusiasm
and excitement here about functional
programming of all sorts both dynamic
type dynamically typed functional
programming languages like closure and
Haskell as well as typed ones like
Pascal and Scala so this talk is what
I'm inspired by 33 talks I became
familiar with the past year once called
extracting energy from the Turing tar
pit sorry for the typo and Alan gave at
the touring centenary and there's an
amazing slide in this talk where he
actually says has talks about what
languages and how languages and he says
it's it's now time to fairly seriously
think about how we might design generic
what languages I mean functional
programming is declarative but I think
we could do better and he says we know
that we now know about many ways to do
very sophisticated types of constraint
solving and search and all this stuff
and it would be really great if we had a
generic what languages that were powered
by these how languages that can do a lot
more work for us so that we can write
simpler programs so what's not house
another talk that is totally in this
this vein is a really great talk that
Gerald Sussman gave at strange loop 2011
Collier we really don't know how to
compute and it's a great talk because
the talk points out that not that much
has happened since the 70s I mean we
have more features or languages are more
expressive our type systems are better
but in the end we're still kind of doing
the same thing and software is still
complex I think that's true so Allen
case talk is is is nice but maybe it
sounds a bit hand wavy Gerald Sussman's
talk is nice but maybe it's a bit hand
wavy but here's a really concrete
example from guy Steele
talk organizing functional code for
parallel execution and the subtitle is
what's important which is full Dell and
fold are considered slightly a harmful
and this talk rich chick he actually
pointed a great insight about the stock
is this actually sort of a critique of
the functional programming completely
because functional programming comes
from recursion theory and this notion of
conduction right and proof right and
that's sort of a sequential thing and so
so as functional programs we often work
with sequences but we often talk about
what we want to go from the sequence on
the left or we want to go from the right
and that actually removes a lot of
opportunity opportunity for things like
parallelism and concurrency that could
happen automatically if we were less
specific if we said more things about
what we want to do and less things about
how we want to do it so I think the
language that I think peop programmers
that have haven't I think a little bit
better notion of what if you learn about
prologue there's a lot of how involved
in Prolog but in general prologue tries
to strive for what and specifically
there is a pure fragment of prologue
which is really amazing when you read
pure prologue it's really great because
you you really feel like you're reading
something completely declarative it
actually shouldn't matter at all what
order the clauses get evaluated and so
there's something deeply concurrent
about prologue and in fact that inspired
a critical amount of research in and
parallel ism or pail ilysm and I don't
think it's I don't think it's a
coincidence that one of the great
concurrent programming languages sort of
came out of prologue hopefully you got
to see the great keynote this morning by
the inventors of prologue Robert Verdi
and joram strong it was really great for
them to talk about how they how they
kept moving but I really think that
there was just a lot of ideas in Prolog
that influenced the design of ruling
something you also see is that smart
programmers like smart things like
prologue so every the people keep trying
to like you know Haskell's cool but
would it be cool if we had some of the
semantics of prologue inside of Haskell
this is a great paper and is actually
laid the foundation for what I work on
this
probably called core logic which is
implementation of of mini Cameron
foreclosure so this is a really great
book by Dan Friedman who worked on this
excellent book on little schemer William
Byrd and oh like kiss oh yeah who is a
very familiar name if you like Haskell
so many Cameron is a 200 lines of scheme
which is pretty incredible because if
you actually go to this book and you've
never done any prologue it really sort
of messes with your hand and at the end
you like reading limitation it's on two
pages and you're like that kept really
be the case if you got to see Phil
wobblers excellent talk on a little bit
where he talked about proofs and Korean
church he really at the end he talks
about how important it is to have
extremely simple models and that's the
beauty of mini camera right it follows
the same principle write it so I almost
fell like Phil what fell while I'm
trying to say you know if you can't put
the model on half a page to no good and
Dan Friedman is famous for saying there
was never an interesting piece of code I
took up more than half a page so mini
camera is nice it's a purely functional
magnetic design and what's cool about
that and I'm not going to talk about
Monette so don't get scared but if you
have a purely functional design you you
basically get back tracking for for free
and this is kind of neat in the way that
this works something else that was nice
that with nice timing is that dumb will
and Dan both are at Indiana University
where Kent dib dib big went who is a
sort of compiler hacker master and he
works in the same cost sheet chase
scheme and what was interesting was when
they compiled mini cameron as well as
can rent a prior version as they saw
that they were able to get basically
sweet sweet prologue level performance
and sweet prologue is written scenes
been working on for 20 years granted
sweet prologue is not the fastest
prologue you can find but still it's
very exciting that sweet prologue is
used to do very serious work and they
were able to embed a good fragment of
prologue and scheme and get decent
performance the other thing about if it
was just prologue I wouldn't be that
exciting but Minnie Cameron is a
lightweight embedding within scheme so I
mean hopefully you're going to see this
we can sort of not get rid of our
functional programming
fun and do some relational stuff at the
same time so corelogic takes mini
cameron it emphasizes efficiency there
are many designs his decisions that I
change the mini condiments to make it
faster the but the big thing that that
correlated does is it really emphasizes
polymorphism which is a big idea and
enclosure so all critical parts of the
system should be it should allow for
open extension and you'll see this
includes unification constraints what
solvers you might want to use what
search strategies you might want to use
so this should all be configurable and
tweakable at the same time we don't want
this the surface a part of the language
that the nice beautiful core that is
mini cameron to be any more complex than
the original design so can we have the
same nice surface syntax but then kim
can somebody modify a couple protocols
and get a slightly different system so
the core language so this was like my
schpeel so i'm not it now it's going to
be a bunch of live coding if something
is confusing raise your hand ask me
questions what have you so I would have
a bunch of examples i'll show the
prologue at the top and then i'll show
the equivalent CoreLogic code so
corelogic code again you'll see if you
know monadic stuff you'll see syntax
looks very monadic but basically when
you write a relational program in core
logic you start with run star you sort
of provide the output logic variable in
brackets and then you have a series of
goals which you want to satisfy sorry I
say tell me the value of Q such that
it's equal is true and this is trivial
right and I get a list of results
because like like a sequel car you might
have multiple possibilities so it says
the only value for Q that satisfies this
statement Q is equal to true is if Q is
true itself it doesn't matter what order
right what order you pass your your what
I'll call terms to this double equals
operator which is not the closure w
equals operator this is it stands for
unification so it's the operator which
says we want to make these two terms
equal so here's one where I say tell me
for what values of Q would
q equal false q has to be false so in
Prolog if you want to do what's called a
logical conjunction conjunction where
you want to satisfy multiple goals you
want to say and basically you use the
comma in core logic and mini Cameron the
body of a run star it's implicitly
conjunctive so here I say for what
values of q is q equal to true and Q
equal to false of course that's a
contradiction right there are no there
are no answers for that and no there are
no values for Q that can satisfy that if
you know about logic variables are quite
interesting because you can also think
about it as we can assign to them one
time we can give it a value once and if
we will ever use the unification
operator again that value better be the
same so if I do this that's okay right
so I'm going to introduce another
operator which is in order to do
interesting work you want to be able to
do often create what across called fresh
logic fires so fresh is analogous to
schemes let or let in haskell or camel
or standard ml it creates a lexical
scope it creates a logic variable so you
can do more work so here I say you know
unify q with X and then unify X with 1
so Hugh has to be one there right so
this one's interesting I create two
fresh logic variables I make a closure
vector which is like an array type and I
unify that with Q and I get this weird
underscore zero underscore one character
so this just tells me that I have a
result in which those fresh FAR's were
never ground they were never assigned
values we can see this in action here
well actually something I'll show you in
a second but this one says now
unification is only is not that fun on
simple values like true and numbers it
gets more interesting when you have
complex terms but and when I say terms
again I just mean closure data
structures so here I have a vector with
x x + 2 in it and a vector with one and
why so what values for x and y can make
those two complex terms equal well one
and two write the vector 1 and 2 is
equal to the vector 1 and 2 and you can
sort of start seeing like oh this is
kind of crazy it's figuring out all this
stuff for you can actually solve some
interesting problems once you have this
ability but if this was all we were
getting it wouldn't be that exciting so
here I'm showing you that we can combine
functional programming and logic
programming in the same program so this
is this is let this is let inside of the
body of a run I make a local binding
where added two numbers together unable
to unify that with with Q it just works
right so if it was just prologue it'd be
like that you just did prologue who
cares but this isn't this is not just
prologue right we have full access to
functional programming while we're doing
relational programming yes
so it's just creating as just creating a
scope you have to remember that the body
of a let won't work the right because
you need to have at least have you need
to use one of the primitive forms for
things to work correctly so fresh is
sorry I didn't say that fresh is like
run star you can have multiple goals in
the body of a fresh and they're also
conjunctive this is this is just because
brent star doesn't know anything about
let's so i use the let to create a scope
to do some functional work and then i
have to have another scope that
understands the magical world of run
star so this is something that i don't
show very much and it's hard to get out
of the books both the william birds
dissertation on mini cameron or the
reason schemer so if you know about
monads this will make perfect sense or
if you're ever analyst interpreter this
will make some sense so here i have run
star and i've made an anonymous function
which takes some strange magic parameter
called a i print it and then I returned
it so you see that oh there's this value
this if there's value being threaded and
in fact this whole notion of goals are
dysfunction closures they're just
functions when I say unify a logic far
plus something else that's actually
going to close over those arguments and
return a function which takes this map
and does something to it well what does
it do to it so this we're going to unify
X with Y and Y way to unify q with a
vector that has x and y in it will print
it out and we're going to return that
and so BAM right the substitution map is
a hashmap which maps logic bars to
whatever you said the unification was
going to be right so q is bound to a
vector with two logic bars why is bound
to affect event bound to to a nexus two
one so all that happens in in core logic
and minion Cameron is you have a bunch
of closures and we thread the
substitution map through the system so
that you can do these sort of cool logic
programming things which will show some
aura so it's not fun if you can just do
conjunction in Prolog you have the
semicolon operators to represent logical
disjunction or so here I have some code
which says Q is either equal to tea or
coffee and so this is the first time
we've seen multiple possibilities
multiple answers so this says yes the
first possibility is T the next
possibility is coffee sometimes it's
important to only get as many answers as
you really care about so you can change
to run start or run n so i can say run
one and get just one thing out of it so
if you know prologue you know prologue
has a very specific strategy called
depth-first so i'm going to show that
mini karen has a neat little trick so
this is a goal right goals again are
just functions so I've made a regular
closure function here but the body is
something that that that the system is
understand which is a fresh and then
notice I recursively called the thing
itself so this is a goal that clearly
never terminates we're never going to
get anything out of this out of this
goal so here I have I have I had this
and you should be worried right so we
know that that con DS sort of try every
possible they're going to try each
Clause kind of their like fresh is
caught sorry like schemes conned or
closures conned only one Clause is going
to succeed but we know and logged the
logic programming world this is or it's
going to try everyone so there's a bad
one there on the first one on that first
line right there's something that we
know will produce no answers and then my
computer has locked up kill that so that
kind of stinks what's cool about about
many cameras mini Cameron does this
diagonal diagonalization thing it
doesn't actually do prologues
depth-first it kind of does this really
cool trampoline thing where it flips
between branches so your i can say run
one and still get an answer and this is
pretty neat you can't do this in Prolog
right so if there is a possibility of
other branch the infinite branch can't
steal time this is so this is fair
called fair disjunction so we have that
that's it those are all the operators
that's the entire language run you've
got unification you've got condi you've
got fresh there that's it if you read
the reason schemer
you won't encounter anything else
besides that and you can do a lot with
that but let's see okay if you know
functional programming you know what
this means cons right you want to add
something to a list okay cool we know
about this so what would it mean would
it mean if if we had a relational
version of sort of a more logical
version of cons and so we have so core
logic and mini care provides this thing
called cons oh so instead of a function
which takes inputs and outputs we've got
something where the the whole notion of
inputs and outputs are quite different
and this should make sense because we
saw that goals what do goals do goals
only take substitution maps and return
substitution maps so the whole notion of
parameters doesn't even really make
sense so here I have cons I want to the
relation of the relational version of
cons what does the value of Q that
satisfies the cons relationship right if
I konsi on to bc right sure that's not
that interesting this is this is this is
running interesting because we're saying
what is the value of Q such that if we
had bc and we know we're going to get
ABC what value of Q could satisfy that
so he would have to have be the symbol a
same here for what value of Q could be
cons a on to Q such that we would get
ABC well the only possibility is if Q is
bc now this one this is this is a
contradiction there is no possible value
for Q so still you could cons be on to Q
and get ABC it's not possible no answers
this one is even more interesting right
so here I've said a fresh far I've cons
it onto this thing and now I actually
have a representation for all lists
right that that are that have three
elements that end in BC so i can do this
right so unify q to ABC oops what
happened
sorry
that works this works right but this
should not work right now only only list
with the right structure will work cool
so if you do a lot of mini Cameron
you're eventually get annoyed because
prologue is pretty pretty awesome
because pro-lok was designed to do this
stuff whereas mini Cameron is sort of
like a scheming awful it's very steamy
and eventually I realized that you
really want prologue level of
expressiveness and so I went ahead and
added enough sugar such that we could do
much more prologue style programming a
particular prologue is very powerful I
mean it's more general than pattern
matching so it's very powerful to do
things like that line says basically
pull apart the first argument and then
just unify the values of the head and
the tail of the thing in the first
argument into a list in the second
argument and that's very succinctly can
do the same thing because I went ahead
and added pattern met this sort of like
pattern matching prologue like sugar to
closure because this is Lisp and we can
do that so right so that's the sugar
we're able to pull apart those things
and get a new value for Q which is
exactly what that pattern match sort of
thing looked like ok so if you saw my
talk yesterday I'm sorry I'm going to
repeat something all this stuff we're
not all of this the first half of this
talk actually works in JavaScript now
because of clojurescript that ported
corelogic to clojurescript the first
portion of this talk anyway so there's a
famous puzzle called the zebra puzzle
rhinestones puzzle and appeared December
1790 62 in this edition of Time magazine
and it goes something like this who owns
a zebra the series of statements there
are five houses Englishman lives in the
red house Spanier owns a dog coffee is
drunk in the greenhouse and so on it
ends with who
oh who drinks water and who owns a zebra
and basically there are five houses they
have five properties nationality the
person what type of drink do they like
what are they smoke what type of animal
do they own and what color is their
house so in this really fantastic book
called the paradigms of artificial
intelligence programming in common lisp
Peter Norvig shows you how to build an
interpretive prologue he started to a
compiled prologue and he points out that
this problem has if you did the naive
brute-force it a sort of enumeration of
all possibilities 24 billion candidate
solutions there's actually a famous
person called James I is it James
Robinson jay jay jay robinson who in the
60s pointed out the resolution principle
and said oh we can make searches much
faster because of this idea of
unification so so by building the
prologue like unification can basically
eliminate all those parts of the search
tree that don't satisfy the solution so
in 1983 when he wrote this version in
common lisp he could solve this puzzle
in 17 seconds and we'll see how fast we
can solve it so before we do this um I
want to break down some of the goals so
this point this is expressing can we
find if Y is to the right of L so the Y
is the right of X and L and the pattern
matching sugar is kind of fun because
what are we looking at in the first
possibility well we found x and y at the
Hat in the beginning of L the second
possibility is that we didn't find it we
have to keep going so is the cat to the
right of the dog it does not is the dogs
right of the cat it is is the dog to the
Isaac is the dog saris the cats are is
the cat right right of the dog in this
case the cats on to the left but he's
not to the right or she so we can do
this by making a new gun call next Oh
which is awesome right this is this is
very declarative I have the right one so
I can just simply flip the things I can
say is y to the right of X or is X to
the right of Y and now I have a relation
that can look for things being next to
each other and that previous goal works
now because this one will check for both
cases so now we have this really nice
way of literally translating the
sentences right this first line says
there are five houses because each
underscore represents a house and then
in this middle one somebody drinks milk
in the first house is the Norwegian next
little Norwegians the blue house to the
right I every house is the greenhouse
the English middle of the red house and
so on okay so what's the answer now the
Norwegian drinks water because the water
is the middle property and the Japanese
man owns zebra that seem to be pretty
fast so how is it how fast is it so
we're doing it 1,000 times so we can
solve that pub that that puzzle in 2.5
milliseconds verses 17 seconds in 1993
so that's pretty cool that you have
started thinking maybe maybe there are
lots of problems that we could solve now
that we have ridiculously fast super
computers you know as a machined I think
people gave this stuff up too early
because we hadn't really reached that
point where something like this actually
runs in a reasonable amount of time so i
would like to talk about that more but
i've got a bunch of other stuff that i
want to show so one thing is that many
cameron only does unification on lists
and that is not that fun because
enclosure we have lot much cooler data
structures enlists so here I've added
unification for maps so that's pretty
cool
I can unify these to date closure data
structures and run queries on them just
like I would and this is completely open
and I'll demonstrate that so if you have
some data structure whether you write in
Java or closure you can make unification
work for your data structure so that
will fail because the map on the right
has too many keys so say you have some
type foo and you want it you want to
make corelogic understand your type your
new term so you come up with a promo
going to say protocol and say I want to
be able to unify foods oops we define
that and then you define your type foo
and you have to have to implement a
couple things first of all we say you
have to pull meant unified terms because
this will happen when the first time we
try to unify your thing and then you say
well I know I'm a foo and tell the other
term to unify with me in the case that
we have a foo and we're unifying with
foo what do we do we say well there's
nothing to do that worked we're just
going to return the substitution map
unchanged if unification fails you
return nil and we've got to handle some
other cases we never need if I with nil
and we don't unify with objects which
are not foods so does foo unify with one
no because object is actually not you're
not it's just saying the default case
when we say object we don't unify with
java objects that are not foods sadly
who doesn't even met does not unify with
tech mesh rocks which it does but it
does unify with foods right that works
and this might seem like a toy but some
things that somebody recently added
that's really useful I did not work on
this somebody else submitted this and
they didn't have to change CoreLogic at
all these have to just add this
functionality very cleanly via the
unification protocols so they realize
that Oh sometimes I don't care whether
the full map unifies I just want to test
for the presence of certain key value
pairs so this is going to succeed even
though the maps are not equal because we
only care whether foo the pair of fubar
exists the key value pair exists
that works but this one does not because
the other map doesn't have the the foo
bar keyvaluepair and that's pretty nice
and so this was requested because people
want to do some pretty interesting stuff
with configuring with configuration so
moving into the last part of the talk
where we'll really see functional
programming and a sort of constraints
and Logic Pro going to come together so
prologue is another problem right so
this doesn't work this is not valid
prologue right you can't say x unify X
with one unified y with 2 z equal x plus
y it just doesn't work because x and y
aren't actually numbers right there
logic fires you actually can't add them
this will blow up in Prolog this blog
I'm not going to run this as blows up in
in core logic in Prolog you have to say
is you have to say Z is X plus y and
this kind of sucks because everything
that I've shown so far seems like oh oh
I can put clause I can do these goals
first and these goals later and it's
really great this seems really awesome
you don't have to think about order but
with is you have a nut what's called a
non-relational operation and suddenly
ordered or the order that you declare
your clauses becomes extremely important
so we have a similar functionality to do
this in core illogical project where it
creates a local scope where they're
those x and y are bound to their actual
values so you can do what you want
however right what if you project too
early right if we project too early
before we unify them with values it's
still going to blow up and suddenly
you're like oh prologue sucks you can't
you can't actually do anything with it I
mean the stuff in the beginning seemed
like there was a promise of something
cool but it seems sort of dashed on the
rocks now that's we've learned things
constraints so the prologue community
figured this out in the late 80s mid
late 80s and they realized they needed a
richer of language for constraints and
so prologue 3 actually had quite a few
you had considered what's called
constraint logic programming
straight logic pro never reels and
integers and so on and that and they
were able to do it and it was very slow
and so it took many many many more years
of research before people figured out
how to do it efficiently and even when
they knew how to efficiently there was
still more problems to solve this is an
incredible book I thoroughly recommend
it concepts and techniques and models of
computer programming it's about this
language called Mozart Oz and there's
it's a great primer into constraint
logic programming and why that's useful
so we're going to show some of the
things you can do before I show the next
slide actually well we're going to talk
about Sudoku but i'm going to show this
first ok so what does this do so this is
fun so we're now able to get back to
where we want to be this was implements
in the past it took me about a year to
get this right but but i finally did so
here we can now work with numbers in a
sensible way and we don't need
projection so we can say x and y belong
to the domain of integers between 0 and
9 and we're able to write our equations
in list syntax and here we say discovery
we want to know the value for x and y
such that if we add x and y together we
get 9 if we multiply X by 2 and we add
it to y times for that we get 24 right
that's that's pretty cool and somebody
figured out that I have this and it
added it and they're already doing on
virtual machine configuration using
inequalities with this stuff ok so let's
do the best part of this example so
we're going to do Sudoku so here's our
data and this for the everything i'm
going to show you is just functional
programming that we not going to be
logic programming here so here we want
to be able to take our Sudoku hints and
initial values and extract the road so
it's 81 possible values for the sunoco
game we want to be able to convert it
into the rose we also want to convert
into the columns
there's our columns we need some way to
get the squares right so this is just
functional programming there is no logic
programming going on here this is a list
comprehension like you would have a list
comprehension in haskell so this one can
extract a square so like acid 0 cos
square we want to calculate all the
squares so there is all the squares so
now we can get the Rose you can get the
columns you can get the squares and
that's because we want to apply
constraints because that's what I'll
sudoku is so don't glue it has to be
unique Bros unique columns unique
squares so this is where it gets a
little bit nuts right this is the
function to take 81 logic bars which
represent the board and to initialize
them to the hits so what do we do this
is we're going to use Richert we're
going to you construct the goal that can
initialize them so if the VARs are empty
we're done we passed a successful goal
if not we get the first hint and we say
if the first hit 20 go ahead and unify
it is not 0 unify it with that initial
value otherwise keep going so this is
pretty pretty cool we're actually using
closures functional programming to
construct the relation which can
initialize the logic Mars Pam and this
is where it gets where it all pays off
right so we construct 81 logic fires we
calculate the Rose the columns the
squares and then here we say all the
VARs are in the domain of you know one
two three four five six seven eight nine
we initialize the hints with that really
cool functional programming plus
relational programming thing we say all
the rows are distinct all the columns
are distinct all the squares are
distinct that's exactly that's sodoku
there's nothing else to it
some pretty printing so that seems to be
right you can sort of glanced over the
result and it looks right how do we
really know what's right so I made a
very simple function to verify it and
what does this do all it does is you've
used some of the functions and what we
do is we collect the Rose the columns
and the squares and we put the values
into a set and every set better have
nine elements in it right that's how we
verify how we verify this okay so did we
actually solve it we did that's pretty
nice then you better then we wonder well
that's cool but I've seen lots of
pseudocode solvers and most of them are
some of them are fast some of them are
slow how fast is this one well that's
not bad 18 milliseconds right that's
pretty good this is an extremely generic
way to solve sudoku right I didn't do
any special casing here right this is a
generic language for in which in using
the generic language I solved a very
specific problem I think it'd actually
be twice as fast I have in the past I
had versions that could solve this in
six milliseconds but I there's more work
to do to get back to that so I've got a
little bit more time so one thing I want
to show is that the entire system is
extensible you can actually provide new
constraint solvers you want to see
you'll be set go ahead you want to see
LPR go ahead I might not implement it
but the infrastructure is therefore
implemented to implement it if you want
to so here I have a little thing called
def see which can take any arbitrary
closure predicate or sort of boolean
statement in regular closure and it will
construct a proper constraint for you so
here I say run star number C and this is
pretty cool right it says any value as
long as it satisfies the number C
constraint and that just works with this
right that should work because yes we
say X is the number and when we unify it
with that other lit
vector that's the number that works out
but if we do this right that fails and
people have been asking for this for a
long time and we have that now okay so
what's this good for people ask me out a
lot so complex configuration is
something that's taken off in the
closure community I know low no cloud I
think uses for this palette uses it for
this I think now there's a guy called
Kevin lino who works on this thing
called c2 which is a sort of our like
statistical graphics visualization
library and it sort of competes with
ggplot but the problem with ggplot is
that you often have to specify too much
even though there's lots of things that
could be inferred so he's actually wants
to use corelogic to do inference on so
that you don't have to do the entire
configuration for this accessible
graphic it can infer properties from a
very simple data description it's used
for static analysis there's a group I
want to see in the Netherlands they used
to work on this project called soul
which was taking a prologue and small
talk and doing some pretty cool static
analysis they've taken CoreLogic they've
created a plug-in for eclipse that can
use queries that are written in core
logic to query the AST the the java AST
there's a pretty nice tiny project
called kabit which is a linter which
really only uses the unification Part to
do pattern matching but people really
like it mini camera work is continuing
to go on Indiana University worked on
some pretty cool declarative GPU
programming with mini cameramen which
could probably report it to corelogic
and then the this is something I really
would like to see I think this requires
me to do CLP set which actually is
pretty easy compared to the finite
domain stuff that I showed we have typed
closure or you know it's a work in
progress but it's pretty far along but
one thing type closure doesn't do that's
pretty nice from languages that have
static types like Haskell or standard of
L is that you have really good inference
so type closure because it's based on
type bracket which doesn't have
inference each haven't tackled that
problem but I believe that we might be
able to support that with some
like the constraint stuff that i show so
just ending comments 0 culture so opf be
an LP it's all old stuff this is not new
stuff for whatever reason we have a
mainstream culture about LOL p it's
pretty exciting to be here and also
places like strangely where you see that
functional programming is gaining more
and more traction and i hope that you
know we're hoping that from functional
programming writing simpler programs LP
is i think still at the fringes people
often surprised when I bring it up
people's think oh isn't prologue dad or
is just prologue and I hope I've shown
that like logic reprogramming is kept
going it's not it's not going to stop
people are going to do more and more
interesting things with it and it's a
pretty wide field and I'm very
interested in two things one is that I
think functional programming is a pretty
awesome how language like it's okay
functional programming is great at half
but perhaps functional programming is a
really good way to build some of this
what right though maybe you can
construct higher-level languages off a
functional programming that's it
questions so time for questions yes
cool other questions no questions Oh
paralyzes so I have not tried it but
somebody else has traded so there's a
really the reason they start on this is
there's a man in the closure community
called Jim Dewey I remember agreeing his
blog post and I saw the zebra puzzle I
was like I have to understand how that
works that makes no sense how could that
work and he actually had implemented in
tonight and Bri implemented it and made
it a little bit more efficient and I
generalized it but he came back and
worked on my thing again and he saw that
if you if you switch to what's called
the continuation monad right the inside
the engine if you switch the sort of
monadic structure to use the
continuation monad you can actually use
a jdk 7 fork joint and your you can run
these in parallel there is the open
problem of of granularity right it's
like at which point should we should the
search fork and we need to work on that
but it was promising because the version
that he did doesn't run any slower
that's pretty big and it that's that's
actually a concern like usually when you
do this it just runs slower right that's
a problem with with trying to parallel
lies these things
I mean not not really so it's just the
Wayfarer disjunction works is that it's
just a trampoline that's really how mini
camera works because it's not an eager
system it's actually lazy so it sort of
computes the stream as you pull things
off of it and so what happens is that
you have all these thunks that are
unrealized and if you have branches you
sort of thunks and what we do is we just
we just jump back and forth between
thunks as we force them it's a really
cool trick I could explain it more in
detail later
oh yeah so um that's a good question so
there's a bunch of stuff that I mean
it's gotten to the point where it so
corelogic so many Cameron is small it's
different lines of code corelogic is
actually now quite big it's four
thousand lines of code and it's probably
going to get bigger a lot of that's
because solvers doing efficient solvers
is quite hard and the solver that we
have is pretty good as you as you saw
but it could be considerably faster
there's a lot of literature and how to
make it faster so one would be making
finite domains faster it would be nice
if we were pretty good it would also be
an interesting comparison with there are
a lot of constraint solvers out there
and people put a lot of work into
backtracking right because they're
mutating state so they have to be have
to trail all the changes and it kind of
sucks whereas here I don't have to do
anything this is all persistent data
structures if something fails BAM it's
gone we go back to the old the old
values and I don't have to don't do
anything there so would be a niche very
interesting to compare once we have
something that we think is as fast as we
can get how does this compare to solvers
I use mutation so that's that's one
thing I'm interested in there are other
things cabling is big if you are know
anything about logic programming if you
have really good tabling there's a lot
of power then I think I mean there's a
bunch of other stuff i mean we could
look at negation and definitely i'm
excited about doing something in
parallel now that would be big
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>