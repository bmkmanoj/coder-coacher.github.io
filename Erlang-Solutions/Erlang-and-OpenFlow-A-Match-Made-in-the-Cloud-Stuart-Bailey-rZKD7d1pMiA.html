<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang and OpenFlow: A Match Made in the Cloud! - Stuart Bailey | Coder Coacher - Coaching Coders</title><meta content="Erlang and OpenFlow: A Match Made in the Cloud! - Stuart Bailey - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang and OpenFlow: A Match Made in the Cloud! - Stuart Bailey</b></h2><h5 class="post__date">2013-05-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rZKD7d1pMiA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hey let's see um great to see everybody
if you're here for a very deep technical
talk you might want to just leave we're
not I won't go into too many deep bits
and bytes I was curious to know how many
people have heard of open flow great how
many people actually know what open flow
is great good I'll talk a little bit
about that so I'll get into some bites
on that um in general is there anybody
who's uh you know thinking of early
anybody think of Erlang in the context
of software-defined networking oh great
that's excellent so I gave this talk to
at Tech mesh did anybody see that talk
ok which was in Europe in November it's
slightly modified um well I'll try to
hit the we end at eleven twenty five so
i'll try to stop it about a let you know
in about a half hour i won't go in depth
into all the slides my main goal is to
just start a conversation find other
people who are interested let you know
what we're doing with respect to
messaging and networking and open flow
in Erlang and so i'll try to leave some
time at the end so i'll jump right in
okay so who's heard of Infoblox anybody
heard of infoblox well that's cool all
right so we we are deep in the bowels of
enterprise and service provider
infrastructure we do network automation
and dns and dhcp and all this stuff that
is not at all particularly cool or sexy
we have a large-scale distributed data
platform which we call the grid which is
not based on Erlang today but just to
give a little bit of motivation of why
we're interested in these kinds of
things is that we have to think about
how to scale
a large data information processing
platform we happen to deal with kind of
network centric data but you can extend
that to Hadoop another big data
processes so that's something that I
know a lot of us are thinking deeply
about you know the sizes that we have
today 250 members / grid we're really
one low level technical person can
manage that whether it's you know two
hundred a thousand or ten thousand
members in this distributed grid you
know our customers require no technical
expertise so if you have a PhD in
computer science from Stanford you're
not going to go work in the IT
departments that are deploying these
products so we have a requirement to be
able to just deploy that kind of
scalability and have it be completely
embedded in a sense in terms of a
solution so we started thinking deeply
about that and really when we thought
about how do we scale that you know the
kinds of numbers that are of interest to
us are things like the Internet of
Things now I put the slide together in
November that's before Cisco started
talk pushing the Internet of Things if
you're watching that conversation but
what that means is really a scale that
several orders of magnitude larger than
what is really practical today so we
don't think of that as a strange
research project because of the
exponential increase in power that we're
getting per dollar so these aren't crazy
numbers and I know for you they're not
crazy at all for a lot of you how do we
scale to a million cores in terms of
processing power and as everybody here
knows pretty well um you know that's
that's not at all science fiction Google
and Amazon have been doing that for a
long time so the question is how do we
bring that into a more industrialized
framework the other thing that's really
disruptive from a kind of industrial use
case perspective is this model that has
been very well understood in the cloud
companies but isn't well understood in
many other venues which is what kind of
jell-o and you know again it's great
talking erling folks get right away
which is the hardware
failing all the time that's the model we
want to have right we just come and so
I've I was thinking well Java of us said
run write once run anywhere I'm you know
I suggest Erlang or something similar
should be write once run forever right
and it doesn't mean I won't modify the
code or change it but if I don't want to
modify the code I shouldn't have to
change the code just to upgrade a new
hardware whatever so there you go right
once one forever run forever so of
course sir laying is closer to kind of
providing the the properties that we're
looking for from an industrial from
industrial solutions perspective I would
say nothing has all the properties and
you know but erling is certainly as
close if not closer than anything else
but what about the network so you know I
think Joe's tuck was coincidentally i
think well dovetailed with a lot of
things we're concerned about you know
when we're talking about you know
scaling to a million cores and a data
intensive system the network really
becomes a source of complexity that is
absolutely fundamental to thinking about
scale um and you know I don't know I'm
sure several of you have tried to run
clusters of relational databases with
full acid transactions you kind of hit
that 30 node barrier and then you say
okay we go to a no sequel store which
really allows us to think about scale in
a different way but we're throwing out
consistency and transaction mechanisms
which may be which are completely okay
if we're doing social networking and
other things and it's all right if I
don't know whether you know I added a
hundred friends if it takes like another
day for my hundred friends of show up
who cares but when we're talking about
coordinating systems in an interest in
an industrial application some kind of
transaction on consistency is generally
required so you know we look at the
world as having a spectrum of that this
really just brings up a
lot of issues and timing and
connectivity and complexity in the
network so how do we deal with that and
that's been a puzzle for us for a long
time of course my backgrounds in
high-performance computing and you know
how many people are very well versed in
InfiniBand okay so infinite bands a
great technology that solves a lot of
problems it's it really brings a lot of
network control close to the application
you can think about you know providing
properties into the network from an
application centric point of view but
it's really quite expensive and Ethernet
one you know this is 2013 and other than
a niche kind of application it's
unlikely that infiniband is going to
take over the world in the way that
would be required to drive the prices
low enough to really be important for
wide scale industrial applications so
again we turn back to the few who've
really have hands-on experience a
tremendous scale and see where we're
what have they done that they're willing
to talk about and where they headed with
networking how many people are familiar
with the open networking foundation ok
how many buddy members or it there any
members ok so not very many so this I'll
just say a few words about the open
networking foundation this is a
standards organization on the board of
which is Google and Facebook and Yahoo
and verizon so if you're in the
networking industry this is kind of mind
blowing there's a networking standard
that's really being driven by consumers
not vendors so have in theory anyway
this has more kind of consumer advocacy
consumer advocacy properties than other
standards organizations so that's
interesting and then they own open flow
which I would say is the kind of
well I'll talk about where OpenFlow sits
in this kind of market clutter of
software-defined networking so the
googles and Yahoo's of the world have
been focused on software-defined
networking there's the standards
organization there's this thing called
open flow there's also quantum and all
this other stuff so a real bit and there
seems to be a lot of market you know
it's becoming it's like cloud was right
what's cloud what suffer to find
networking there's a whole lot of
definitions I don't think it's an
important question I think the important
question for you know what we're
interested in is really exploring this
question which is what is hardware to
find networking and and my session it's
a much better way to approach the
question of what's software-defined
networking hardware to define networking
is not a technical issue it's an entire
industry that's organized along box
function lines so when we think about
building a network today generally we
think about going in buying boxes that
are dedicated to some set of the 2,000
protocols defined in the IETF and other
functions so whether it's a load
balancer a win optimizer firewall a
traditional router and switch and a huge
economic system is built up around this
so everything from how the media
classifies companies the way Wall Street
classifies companies the way venture
capitalist invest in companies the way
the products are marketed and rolled out
to the way the consumers are trained and
deployed and so you have a cluster of
manual activity around each one of these
types of boxes I have my firewall team I
my Road load bouncing team I my router
and switch team now in smaller teams
there's a lot of overlap but the
knowledge tends to be bucketed into
these hardwa into these box function
lines that's striking in reality today
in 2013 the technology and each of these
boxes is virtually the same ether
one and there's a lot of fast processing
available so the main differentiator
today is software in reality but the
consumers for the most part except for a
few who built it all themselves the most
consumers are not gaining the same
economics of fast cheap hardware at the
networking level that's generally
programmable right i can buy a box and
buh and i don't know whether I want it
to be a firewall or a load balancer or a
win optimizer or anything else before i
buy it i buy it just like i buy a server
and I by like a thousand of them and
they're priced just like servers because
I can buy a thousand servers for a very
reasonable price and then I put them in
my infrastructure wherever I want to put
them into and then at real time I can
think about what functions I want them
to have and now actually my space of
possible networking functions just
really opened up because I don't have to
think about it being a firewall or a
load balancer I can think of the
properties i want which is probably some
combination of those and many more like
contract checkers or something right so
there's so finally we have we could
potentially have a programming substrate
which then unlocks this value right so
it just changes the the model that kind
of you imagine that then we get back to
the question of what is software-defined
networking it's a market correction
right this is a way to get better
economics into the consumers of
networking economics that are much more
similar to servers and PCs and tablets
and that's a cheap hardware software
which is great when we then think about
a software you know write once run
forever that's what we want in
networking so the last time we saw this
kind of big shift in value from software
to from hardware to software as the
center of value doesn't mean that
there's no hardware it means the
hardware is generally programmable and
cheese
on the last time we saw that is in the
end of the mainframe and in the end of
the many in the emergence of pc so so
software-defined networking is not kind
of like a phenomenon happening around
networking in the cloud or data centers
those things are tremendously important
first use cases for dynamic networking
but you can see that the implications of
changing the economic model mean that
really we may be faced with many more
choices about how we think about
communications going forward and I think
that will impact how we think about
distributed computing and the potentials
have so it's a very exciting time and
you know you're not too late it takes a
it takes you know not necessarily a long
time once it starts going but you know
it's a significant event to have a whole
economy change from a hardware center to
a software center so there's lots of
opportunities to to get in on that
action okay so that's kind of the very
big broad picture of how how fundamental
this is to what's going on I want to
talk a little bit about the actual bits
and bytes for those of you aren't
familiar with open flow so this is like
a really probably poor OpenFlow 101
tutorial there's lots of resources and
we can delve into that later so here's
legacy networking there's really two
centers where you buy products and
legacy networking I know you know all
this just to say it out loud you have
what we call data plane products those
are the hardware boxes I was talking
about firewall load balancer router it
has something generally it called the
control plane that's baked in right so
that would be like bgp or ospf something
that's kind of making decisions about
the state of things and then you have a
management plane so in general you're
buying boxes that have a specific
function in the data plane and the
forwarding layer and then you're buying
overlay software which is really only in
its just historical and batch if the
management plane goes down there's no
problem right i mean there's a problem
in like a day right like oh I'm not
getting the statistics I need I can't
figure things I can't deploy new boxes
but nobody's business is actually
disrupted in real time if there's a
failure in the management plane it's all
about this boxes so this is kind of the
hardware to find networking picture that
we had there's absolutely no application
awareness it's completely
labor-intensive to deploy a managed and
there's really one kind of set of stacks
on which it's all built on today which
is tcp/ip which is great right but
there's a whole kind of spectrum of
messaging or of communications
technologies that could happen okay so
now let's look at a contrasting view of
the world which is the kind of
software-defined networking view from
this programmable hardware perspective
so this is not to say that northbound
interfaces and you know cloud interfaces
and quantum aren't important I'm just
having a very specific focus on this big
implication of a change in the economic
layer so now instead of the embedded
control plane and the management plane
we have a cheap general programmable
forwarding plane these are general
they're not they don't specifically do
tcp/ip they don't specifically do
firewalls they don't specifically do
load balancing they're all general these
red lines here that cut across them are
flows that cut across those and that's
just what's a flow it's a whole stream
of Ethernet packet so one way you can
think of this is it's a big layer to
mesh of Ethernet things where I can now
do things to those Ethernet packets in
real time and I have a controller which
is logically centralized good example of
a logically centralized but completely
distributed system is DNS so we know
that doesn't mean it's actually
centralised but it's logically
centralized at some level and we have a
standard interface to actually program
the behavior that the reaction of any
particular forwarding element to a flow
to a packet in real time and
this there is a standard that exists
today like that and that's called open
flow right so instead of thinking box
function box function box function we
think here's a flow let's call it one
this is flow five this is flow 10 and
guess what this box should tunnel flow
one this box should meter flow one this
black should switch flow one this box
should nat float in this box should
switch flow 10 this watch the box should
tag flow 10 right and if in the next
minute we want these boxes to do
different things with those flows will
do different things with those flaws so
now we have a flow centric programming
model on an inexpensive forwarding plane
that's a radical shift in thinking about
networking that's a very very different
ship so we think that's exciting because
if you think about large-scale
distributed systems having this kind of
control over flows in real time suggest
some possibilities to fix some
scalability and performance problems
that have been plaguing us doing
large-scale distributed systems for a
while so that that's a kind of very
basic primer um I won't go into this too
much I mean this is just the same thing
again a little bit more in depth example
so i have open flow switches and you can
imagine in other protocols opens full
switches the controller is just some
software sitting on a pc or a cloud or a
cluster whatever you want some
programmable element and i actually have
an application developer who now in some
way can say okay I have an idea because
I'm not just a client-server developer I
already am thinking about like 20,000
things right so I have some ideas about
how those 20,000 things should share
messages I want to put code at the
controller level that actually does
things with the messages between those
20,000 things and I think that the thing
that makes it kind of timely today
is what Joe alluded to Newstalk which is
really from a industrial perspective
that you know what's been the most
valuable thing there's nothing wrong
with it it's just been the most valuable
thing over the last 20 years is
client-server computing and in
client-server computing the network from
a programmers perspective is trivial
right you really don't have to think
about it right I just have a client in
the server and if my client if my server
is like 20 million servers conceptually
it's still a client in the server right
so I'm not really thinking deeply about
a complicated network but if I'm really
doing okay I want to program a swarm of
robots right like 20,000 robots maybe
there's something fundamental about or
processes or virtual machines or
whatever there's something fundamental
about communication which as a
programmer I kind of want to have the
abstraction and ability to control so
open flow points us in that direction in
the same way I think Erlang points us in
that direction so then yeah oh I pack it
does something an open flow just you
know it's very simple right it's like I
have rules I can match right so pattern
matching I can take actions I can
collect some statistics so it's very
very straightforward and no you know not
surprisingly well aligned with Erlang
because Erlang came from a communication
centric problem so you know those things
work well so so we've been doing this
for kind of very interested in these
intersections for I don't know 18 months
or something like that we started a site
it's just very early called flow 14 org
which is completely open source
investigation really of open flow in
general so I'll talk about but also
specifically or interested in the
intersection of that and Erlang so you
can go there currently we have two main
projects there one is link which stands
for link is not closed in the great
tradition of recursive acronyms and it
is a
it's a OpenFlow softswitch that's
written in Erlang and me Hall actually
is one of the primary architects so if
you have very deep technical questions
that's the guy you want to talk to we
actually contracted Erlang solutions to
do that and we're contributing that back
to the community we're not interested in
monetizing that at all we'd love for
that to be expanded and worked on so
that is investigating using Erlang to do
openflow switching it was written from
the ground up the kind of I'll talk
about the other switches and marketing
the difference so we have that and then
we're trying to kind of prove out some
of the ideas by some work doing
acceleration of Hadoop using open flow
and Link there's very early days these
are very so if you're interested in
these you can talk to us there's some
folks mainly networking who are
contributing to this we're always
looking for industrial contributors
collaborators at whatever you want so
are just in the interest of time I don't
want to go too much into this but
there's lots if you're getting
interested in open flow there there are
kind of all different types of open flow
switches you can start playing with I've
listed here without going into all the
details kind of the four big switch and
well primary switches the Khmers the
most commercially viable open flow
switch is open V switch which is
actually just a virtual switch which
supports open flow has very good support
in the linux kernel um and so if you're
kind of wanting to it's written in c if
you want to you know kind of play with
open flow from a commercial perspective
that's probably place to go and then
there's three i would say more kind of
either prototype oriented or
forward-looking switches indigo Loxy
which comes out of becoming called big
switch being supported their soft switch
which is also an ericsson project but a
see implementation around prototyping
and then link and so for link
we're interested in a couple things one
is multi-core bringing multi-core to the
switching platforms so what if a switch
for instance if this generally cheap
programmable switch we're really just a
big multi-core box with like 32 ports of
fast you know gigabit ethernet on it you
know what kind of architectures make
sense for making that and maybe it's
Erlang and so if you're kind of
interested in Erlang and the
abstractions for our link to doing that
link is a good choice there um
interestingly airline the link is that
because here's a here's a unneeded for
you this audience plug for Erlang but
just so we can feel good about Erlang
because of Erlang you know link supports
all the OpenFlow open networking
foundation standards today so it's the
only switch that supports of' config
which is a configuration management and
I OpenFlow 131 which is the latest
version of open flow with a lot less
resources because you know the all the
great productivity properties of ur
laying it being a functional programming
etc so that's kind of exciting it's
still really slow so talk about that so
we need to make it faster anybody who's
interested in helping it that's great
maybe I'll just spend a couple minutes
on this this is the links which
architecture this comes right out of the
oh f config standard which is a
configuration standard which is a
companion to open flow and this is a the
thing I want to highlight here is this
blue box is called an open flow a
capable switch and inside our what's
called open flow logical switches and so
you can kind of think of the blue boxes
being one of these very generally
programmable hardware pieces right could
be a server could be virtual and then
there's actually lots of open flow
switches that can get instantiated
inside that right doing this kind of
abstract
turned out to be really straightforward
well I'll let me I'll say yes or no but
it's from looking at other
implementations I have this one of the
we've looked at it's so much more
straightforward in Erlang because of the
again the conciseness and abstraction so
that's been nice um we've also
architected it so we can hopefully make
it fast right so we have a few different
options for putting a fast path
underneath if anybody is worried about
performance I poured coffee for my wife
this morning I collect mugs of computer
companies that are now defunct right so
i have like sun and digital right and I
I poured coffee for my wife in a cup
that was a digital equipment corporation
cup and had this cool has it has a
little computer on it and it has a
screen that's black right until the cup
gets hot and in the screen because show
something and it says alpha XP the most
powerful PC in the world I said that
that's a that's right who means the most
powerful PC in the world no 1 right
that's why the alpha BC what we need is
the least expensive bc that does our job
we needed to do right so that's the era
for networking that we're just coming
into right this is not about man we're
not going to be able get wine rates it's
like if the hardware is inexpensive
enough we'll have enough of that and it
will be well there'll be too many but we
know how to program lots of things as
what software is all about right so
we're just entering this era where we
think about networking a completely
different way which is it's everywhere
and it's fully commoditized and we
completely can program at any time and
if you talked about having a home pc or
a server in 1975 people said as you guys
know who would ever want that right what
would you do with that so we're in that
same kind of place in networking wow
what could we do if we had all of these
cheap inexpensive fully programmable
boxes everywhere that's pretty
mind-blowing so we
don't worry too much about performance
today right and but we think that it
needs to be just fast enough for the
class of applications that make economic
sense in terms of deploying these things
and Erlang is a great kind of multi
court because we know there's going to
be more course right let's take
advantage of the multi course I'm not
going to say why erling OTP but I will
say this one thing is great about the
communication roots of Erlang as opposed
to the cloud computing is that the bits
in text is awesome because if I think
about wiping away because because what
am I saying am I really saying that we
don't need well-defined protocols yes
I'm actually saying that in networking
right which is very her aticle and
networking but has been commonplace in
the web for a long time right Jason's
like what de facto right so in
networking the reason that we have 2,000
RFC's it that you know really carefully
detail every state machine and
everything like that and all the bits
and everything is because the
fundamental assumption is to make
communications go fast enough we have to
spin customs asics application-specific
integrated circuits so we have to have
custom hardware if that's not true then
we really can think a lot more liberally
about protocols and so the networking
protocol stack may look a lot more like
the cloud communication stack which is a
lot fuzzier than anything coming out of
the ITF but the but we still want to
operate at the level of bits and again
this bit syntax is absolutely you know
coming screaming out of the late 80s is
suddenly extremely relevant you know
which is very very exciting so I again
for an interest of time I won't go in
too much but we have basically for our
Hadoop acceleration um you know what we
did is we said okay for really really
for big data problems today for most
people you know the problem is still in
the
storage io channel right that's where
the bottleneck is today disk is slow
still that's changing with SSD and
everything else so we see networking as
a frontier problem in large-scale
distributed data intensive problems and
so if you assume like you know lots of
very very fast memory which is not
unreasonable to assume at all the
network really starts to choke up when
you go to a thousand or two thousand
cores to try to compute one good
MapReduce number so again coming back to
InfiniBand the idea is you know what
there's plenty of people who put
InfiniBand in and it works and so the
idea here is does open flow on top of
Ethernet give you like sixty percent
maybe whatever it is of infinite man at
a tenth of the cost because if that's
true it's a win so we're interested in
that so we actually deployed Hadoop and
put the link open flow switch in there
and start measuring things these are
published at supercomputing 2012 and
we're continuing this research if you're
interested in these kinds of things love
to talk with you and collaborate um we
have a graph that like is a little bit
better than the red line I don't know
what that means but it's good okay ah
now you can look at the paper we're in
early days it means that it's trending
in the right way but it's just not fast
enough for production today so here's a
possible roadmap items for link so fast
forwarding modules you know we really
want to thank lots of course lots of
course lots of course it's a big
ambition bars hopefully this year to get
a do-it-yourself kit how many people
have a raspberry pi yeah it's if you
don't go get one it is like 1980 all
over again you know if there's this
do-it-yourself option now networking
that was never there before we'd love to
have a kit that you can buy build your
own open flow switch for less than 5,000
bucks right and let it and have it do
something that's like relatively useful
right like the pc and 19 you're
relatively useful we're not saying that
this will replace every single big
router switch or firewall
in the world just like there's still
mainframes today to do but there's
something fundamental happening and this
last thing is really you know my dream
too i hope i can excite at least one
person in this room or in this
conference to do which is can we get
this kind of propyne grain
programmability embedded into the OTP
itself right and we'll work hard at
understanding trying to understand what
are the right abstractions but then i
have all the pieces right because i have
a distributed system and now i can think
about laying down network properties in
some nice abstract way which relates to
whatever job i'm trying to actually do
in real time so that's a big big dream
maybe you'd be interested so i won't i
won't go too much into this there are
three kind of approaches we took in
trying to make this is just for anyone
who's really interested networking and
pointers in the right direction for if
you if you download link and start
thinking about it here's what we've been
thinking about there's kind of three
directions for making link fast one is
to use something like DDI oh from intel
we're so this is a picture that says
core one core two core three core four
core five or six core seven core eight
and it's got a couple of ethernet ports
here that have the ability to bind to
specific cores so can we put the fast
path bind them to some specific cores
and spread the rest of the link
functionality across many cores so
that's just one option I'm will share
the slides you could just have a
straight SMP colonel so now the links
which the Erlang switch goes across all
the cores and we don't do anything
special this is particularly good in
hypervisor type options I think we're
going to explore this very aggressively
and then possibly with a programmable
hardware Fast Pass so there are some of
the hardware companies that are coming
up with very large t cams and other
kinds of very exciting things and you
know the danger here is they have to be
as de facto standard as the x86 so we're
not very interested in like okay we have
this one special card that's really fast
and it's eight thousand dollars a port
you know that's not helpful if it's like
ten dollars you know a port for a
hundred gig and you know it's really
cool that's great
so we're really interested in how does
the hardware commoditize okay so just
leave with a couple things um I
mentioned this before you know that I
think these are wide open problems so
we've worked with you know we're
collaborating a little bit with the
princeton university on frenetic which
is a programming abstraction that uses
reactive functional programming which is
kind of like how do you get rid of all
the callbacks to think about how to
program the network um you know the i
think the contract checkers is an
interesting idea so we're trying to
understand what are the right
abstractions on that we want to expose
to a programmer there's a lots of
opportunities to contribute there and
you know i was at tech mesh and the
haskell guys were like iOS a side effect
right I'm like how is that possible
right it's a pretty big side effect you
know it's everywhere right because
they're like every time I Oh happens it
may cause dizziness and headaches right
so we're going to shunt it over here you
know and I think that's a really really
limiting that is a computation is king
viewpoint and I think that that is
absolutely appropriate for you know
ninety percent of the industrial
applications that have kind of been
important or 975 applications up till
now client-server again the network's
trivial and client server so it's
reasonable to think that way but you
know what about communication is being
completely fundamental what about having
things like Joe's contract checkers you
know this is a picture of a swarm of
flying roboti things right they're going
to have to communicate in a fundamental
way the computation is not king here
community the the overall network
communication is just as important as
the computation so it doesn't seem
reasonable to think of i/o as a side
effect but something absolutely
fundamental as a storm of fish under
there right that's the kind of
properties that we want to see in term
and the right abstractions to be able to
program them very simply right there's
no mainframe operator I have to go talk
to to get my
eight core you know machine to do
awesome things I shouldn't have to go
talk to a team of security specialists
and CC IES to get my you know collection
of things to talk to each other
fundamentally so that's that's what
we're doing with Erlang and open flow
here's some pointers you can send email
to info @ flow 14 org you can go to the
website you can download the code it's
on github and take it from there and I
think that ends my talk with five
minutes any any questions Joe yeah yeah
yeah yeah I am yeah and messaging
architectures to people have been doing
messaging large-scale messaging they go
they look at OpenFlow they go we've been
doing this go like exactly right but
what's changing is the economics the
ability to do that at scale at the most
fundamental level
yeah it it it really opens up the
possibilities and it really and so then
that's also challenging too because it
means that you know the way that we've
been thinking and rationally planning
and engineering as getting disrupted so
one question is all those things are
possible what are the right abstractions
and most importantly what are the killer
kind of use cases that are really
driving those requirements and we're
starting to see that with cloud and big
data and internet of things but it's not
clear what you know if the internet was
important but the web made it really
critical it's not clear today what is
the killer use case that really drives
this model and drives economics any
other questions yeah I'll invite you
over my house you can check it out I
think it'll be challenging for you know
it's very disruptive it's very
disruptive across the board but the
reality is that just like anything it's
disruptive in its disruptive across the
board right so who's going to think this
way who's going to program how are they
going to deploy it so you know it were
not too pretty early days
well yeah I'm not sure a lot of people
have it to be honest with you I think
that if you build cloud systems right
you know that your network has to have
different profile it's not clear though
about the economics right so i think
that the initial use cases for very
dynamic networking makes sense in the
cloud context i think when you start to
see and what n is happening when you
start to see these generally
programmable inexpensive hardware
platforms you know that's my suggestion
everybody just watch for that watch for
these kinds of software stacks get them
and start playing around with them this
is very we haven't had this opportunity
where there's really a new hardware
abstraction a new platform for computing
since the 80s I mean we really haven't
so as so the possibilities are both you
know very broad and also not understood
because we don't have haven't have
enough hands on experience so you know
this is exactly the kind of community
that can start to as these products
appear on the market and you already
have you know ninety percent of what you
need by being an erlang programmer in
understanding how to think about
distributed systems you know you know
there's a lot of opportunity just
waiting to happen but I don't think
you're alone and not getting it great
question yeah this is a great question
so let me just so the question is you
know how big this isn't this just for
the big guys right that's a question and
I think if you go talk to Alex canaras
from concur X he'll tell you why you
know what they did the kind of capacity
they had in a facebook data center you
know in whatever 2005 we can get into
like 17 blades today right so the
subtending this whole thing is a true
you know you guys are mostly engineers
it's an exponential growth in hardware
power per dollar on a you know 18 month
basis that's continuing to happen
exponential growth is a big deal so we
really when we talk about scale that
scale from a computing power in a
multi-core like 64 course is here today
I think the question is not how big do
you have to be but what problems require
you to have this tight coordination so a
very concrete example I think about
Hadoop again and let's not worry about
Hadoop but big data processing general
like a MapReduce framework right so for
those of you familiar MapReduce you know
there's these different phases where
you're going to do computation in a
distributed way and then you're going to
aggregate results and the problem with
the aggregating results is you have n
machines say a thousand machines that
are coordinating to compute one number
right so if one of the machines has a a
Grigori salt which is not a very big
packet or anything but it's really
delayed it's like somebody it's like
having a fleet of buses and you know one
guy missed the bus and he's got to wait
a half hour for the next bus but you
need all the people at the end point to
get to the next phase you have this kind
of blocking delay problem so we want the
network to go whatever you do right now
just for the next ten seconds make sure
that every one of these packets gets to
where they need to go at about the same
time so those are ordering problems
have nothing to with bandwidth right and
this is I think in that the applications
where complexity is really this barrier
scaling the wall clock time because we
still want to get that wall clock time
should weigh the complexity is the berry
to scale those the applications that
require these properties that's that's
where this would be most useful earliest
that's a no-no that's why I want to be
clear well ordered applications it's
where coordination yeah we're we're your
it's more like let me say it may try
this way when you have a highly
distributed application where so here's
a high bandwidth the application I have
a trillion users and I and I want them
all to go to one website so i have I
want to have a million web servers I
don't need sdn for that right because I
just throw bandwidth the problem right
because the internal state of a million
web servers are not really related to
each other right I can one do I can end
the one peer a trillion users to a
million web servers and just scale
horizontally right but when I have a
thousand machines trying to compute one
number in a coordinated fashion ordering
in the network becomes a huge factor in
terms of if nothing else is in the way
like disk i/o and other things ordering
in the network can be can be a very big
factor in the wall clock time and
scheduling so I think that's those are
the properties you know it's like
wherever circuit switching probably made
sense Sdn is going to be more helpful
well I think you know your your
questions generally points to a really
probably all the most fundamental
questions in terms of you know real
world appointments which is how do we
deal with this transition to this where
is it most important how do we do with
legacy protocols what's you know and
there are I would just direct you to all
the stuff going on in stn today because
they're the people who are focused on
software-defined networking our attack
like the open networking foundation
they're asking those questions
fundamentally at the standards level and
in the deployment level
yeah yeah yeah okay great questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>