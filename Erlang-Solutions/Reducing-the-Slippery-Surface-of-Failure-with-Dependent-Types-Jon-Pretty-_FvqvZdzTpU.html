<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Reducing the Slippery Surface of Failure with Dependent Types - Jon Pretty | Coder Coacher - Coaching Coders</title><meta content="Reducing the Slippery Surface of Failure with Dependent Types - Jon Pretty - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Reducing the Slippery Surface of Failure with Dependent Types - Jon Pretty</b></h2><h5 class="post__date">2015-11-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_FvqvZdzTpU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you thank you and so as Ben said
I'm going to talk about quite an
advanced feature of scholar but I'm
hopefully those in a way that is very
accessible to to ordinary users of
Scully you don't need a huge amount of
experience to be able to use some of the
ideas i'll talk about today can I can I
just get a show of hands how many people
here use Scala I think almost everyone
who doesn't those those two numbers
don't add up to the total number of
people in the room I'm sure I mean only
it's less but it's high at that time ok
nevermind will so so the ideas could
potentially transfer to other languages
I think I think Haskell you can do some
similar things and other other typed
languages dependent types are something
which could potentially become become
quite a big thing in the future i hope
i've got this sir is this slide here
which is meant to be a bit of a metaphor
for well this is a metaphor for
programming in a in a dynamically typed
language you're you're trans drive along
this road but it's it's covered in snow
and you're probably going to crash into
the trees what I what I want to do is it
is make that road into a into a sort of
a railway line with rails or at least I
would accept rails has already been
stolen by the dynamic community so I
can't use that but I'll get started what
I want to do is talk you through an
example this is something you might type
into a command line a bash shell for
example so we call in the LS command
we've got three flags there we've got
we're sorting by time and we're setting
the width to 120 now replying these
these parameters in different ways
and what would actually want to get if
you type this into your command line in
in our well types program is it
something a bit more like this we know
that we got the L flag a flag the eighth
flag we've got sort which is the string
time we've got width which is the
integer 120 these I've given the value
unit unit means I mean it especially
saying they are present they're not
they're not true or false they're there
they're merely there this is the sort of
data structure we would like to work
with in a typed language like Scala so
what we want to do and the example I'm
going to talk through is translating
from something like this to something
like this in a way that is as type safe
as possible at the same time without
compromising on how intuitive the API is
an intuitive the library is to use so
let's let's just have a first attempt so
we can create a value called command
line and we're just going to pass the
arguments arguments is an array of
strings it's what what you what you get
in any any java or scarlet program or
almost any other language and we're
going to try an get the sort parameter
now what we might try and do is call a
get method on that which we specify as
the the sort parameter now that's that's
a reasonable first attempt I think
nothing too exciting we'll we'll get a
string back here but with new better if
we're getting the size for example we
maybe want to specify that it's an
integer and we can we can add this
parameter here in Scala which will cause
a particular type class to be resolved
and using that type class we can convert
this hopefully from from the stream that
gets passed into a valid integer
obviously this might fail if it's if you
say size equals hello that that would
that would fail but we're at least
getting an integer out here afterwards
so making progress now sighs can also be
specified with the lowercase character s
with a single dash &amp;amp; S or double dash
and the worst sighs so we need to we
need to accept both options once we've
got the the value everything everything
works the same way as it did before but
we do need to specify both of these but
maybe we're getting getting the size in
several places so it's kind of
cumbersome to have to write both the the
s and size every single time and also
the integer for that matter so one thing
we can do is create a value that
represents the parameter we're
extracting so sighs Bram and we specify
all those details there integer s and
size and when we call command line or
get we just give it that that parameter
value if you put something else in there
the the compiler will check that thing
exists check it's a parameter check
everything everything makes sense and
you'll note compile time if you've made
a mistake so that is that all ok so far
all reasonable yeah so there's nothing
complicated yet I'm going to take a
slight deviation now talk about a
library I've worked on earlier this year
for dealing with internationalized
strings so the the rapture project is is
a collection of modules I've been
working on for a few years now one of
those modules deals with handling
internationalized strings so often in in
your in your programming in your code
you want to be able to present messages
to the user in different languages so
what people normally do is they have an
external file that has those same
messages in a number of different
languages and often you'll you'll pass
that that file check all the values are
there and then you will try and access
those values toss it around several
places in your in your program that's
that's typically how it happens I think
we can do better than that
what I'm going to do is I'm going to put
those messages into the code so I'm
going to create a string my string and
in Scala we can we can write something
like this and this is this is what
rapture i 18 n allows you to write you
can circle a string which is in English
it's hello in French it's module and in
Spanish it's Allah and that's a single
value representing all of those I don't
know from the scholar Skyler users here
have seen this this syntax you can
actually prefix the prefix of string
literal with with a number of characters
and that will that will cause it to to
invoke a certain method and the type of
this thing isn't isn't necessary a
string it can be but it can resolve to
whatever type that method return so here
I've taken advantage of that I've got
methods called en fr and es and all all
the other languages in the world and
these will return different types
depending on which one which one you use
when you combine them using this
Combinator you get a result type which
is this I string of English with French
with Spanish now this this type is kind
of critical to thee to the rest of the
talk i'm using well you can see that
it's got the English there the French
there and the Spanish which have come
from from these here if I were to add a
or d guten tag for example we'd get at
with be there as well and the reason we
get that type there is because the the
definite of the Combinator for any any
instance of a nice string will take
another language so the if you combine
an English I string with the French I
string this starts offers as English
this is a French one to l2 is is French
else who's French there and the result
type is going to
English with French and this this is
this is how we compose the types so our
our ice cream types are are composable
which i think is a good thing does that
does that vaguely make sense I even to
the nonce Carly users yeah ok now the
with type I didn't really explain that
that that is an intersection type and
we're representing what does it century
several strings as a single value which
and I know it's early but you may notice
that it's actually just a map as a map
from a language to a string and each
each type is representing one language
and we find the intersection of those
those those different languages the with
the combination of widths of all of
those languages and we put them into the
type parameter of I string so I string
is parameterized on the intersection
type so we're sort of storing those
types in that intersection where we're
building them up and we can we can track
that type throughout our program so what
this is saying is if we have en with es
and that that is English it is both an
en and it is an AS so if you have you
have something which is if you have an
instance of this thing that instance
inherits from en it also inherits from
from es in object-oriented terms now in
in Scarlet you can always create an
intersection type any two types you can
name in Scala you can with them together
well like this one this should make you
feel uncomfortable what is an int with a
string I mean obviously such a thing
can't exist but nevertheless Skyler will
let you talk about it you can you
you can you can you can write this type
down so what's what's the point in doing
this why why would we ever need int with
string or or string with symbol well you
don't have to have instances of
something you don't have to have
instances of a type for that type to be
useful you can well first of all we call
these these sorts of types that we never
have instances of and in fact it's
impossible to have instances of we call
them phantom types we never instantiate
them and in fact they only really exist
at compile time so the compiler is able
to track them throughout its its various
phases but when it comes to write the
bytecode the VP phantom types actually
get a raised they they don't exist
beyond compilation they don't exist in
the bytecode they certainly don't exist
at runtime so we have to we have to make
use of them during compilation that is
the point at which they become useful
and they're probably other things they
can do but but to particular things are
enforcing type constraints so we can use
these types not so much as a as a the
type of a value but as a constraint on
something constraint on method call or
we can use them to drive implicit
resolution so implicit resolution is is
horrendously complicated in Scala I
think even i think the Scarlets will
have first-hand experience of this I
think anyone else who has heard anything
about scarlet probably also knows that
implicit resolution is complicated one
of the reasons it's complicated this you
can you can like coerce it into doing
various different things that some are
more obvious than others using using
various complicated types and this is
this is sort of embracing that with with
with types that never exist at runtime
and we can we can we can actually
channel implicit resolution to work in
in interesting ways but it's the it's
this this first way here enforcing type
constraints that I'm going to
demonstrate here so let's let's show you
how this works we've got our got a value
here called say hi and it's going to be
the English French and Spanish of that
if we call say hi with with the English
type parameter that's fine that compiles
if we say hi with Spanish that's also
fine we've got that there if we try and
say hi with German this will not compile
it won't fail at runtime it will it will
fail at compile time this is the best
time for it to fail failing at runtime
you have to debug fine at compile time
you get a you get a compile error you're
told which line it's on and you go and
fix it so we prefer Weaver being told as
early as possible now here's it is a
substandard section type here so that
might be English with French with
Spanish and the apply method this this
is the one that's been called when we
try and access a string within that
insect within that I string and it has
you passed it a type V and we have a
constraint on that type this thing in
yellow here is the important bit the V
must be a super type of tea so here for
example say hi English must be a super
tight of English with Spanish now I said
English and Spanish that that that is
the thing that is the type that inherits
from both English and Spanish so yes
english is a super type of that german
is not a supertype so this will fail at
compile time this is exactly what we
want so this this simple reasonably
simple constraint here gives us this in
combination with the intersection type
this gives us better better compile-time
safety on or on on these these I strings
so we know that if it's if if something
exists if we've managed to create a nice
dream that has english french and
spanish as its intersection type it
definitely has an english string it
definitely has a friend string and it
definitely as a Spanish string we know
that if we've if you constructed it then
that's that's guaranteed this is all
this is all checked to compile time we
we saw that on the previous slide and
the operations of accessing knows those
strings are are safe the apply method
the one which you use to get the values
out is a total function you can't pass
it a value and it doesn't even it
doesn't even take a value level value it
takes type parameter but you can't you
can't pass that a value that will cause
it to fail or throw an exception it will
it will always succeed it is the total
function this is this is a very
desirable thing but I haven't told you
the whole story there there's a problem
here how do we have to get a type from a
language that we enter into our program
at runtime I mean we like if someone
enters that the two characters en for
English how do we get a type from that
all we know is that they've entered a
string we have we have no idea
compile-time what type is coming into
our system so we need so we need to find
a way to take advantage of this we know
it's a string and I mean what what
happens if the user enters language
which just doesn't exist these these are
all possibilities and you can't you
can't deal with them except at runtime
well this is the solution this is the
solution in the rapture i 18 n library
so we get a language here and we just
read it from come from from the console
so this this could be anything this is a
string and we get a locale from that the
type of the locale is parametrized on en
with es
and what we do is we build a little
parser we build a tiny parser which I'm
saying is either either English or
Spanish and we use that which we've been
started in in like there's only seven
characters there we use that to parse
the string now this this can fail this
can certainly fail this is not a total
function this is a partial function the
ways we can handle that failure and
there's the serb there's a i can do a
different talk about that but but for
now we accept that this is potentially
going to fail was real questions there
no but the results like we get assuming
this has succeeded will be a locale of
english with spanish and then we can
we've got our are two versions of hello
there in english and spanish and we can
happily pass pass that locale value in
to say hi because it has the same type
constraints as long as this as long as
the type of this which is locale english
with spanish is a super type of the the
type parameter of this then this is this
is acceptable at compile time so this
will succeed because english with
spanish is the super type of english
with spanish in fact the identical types
but that is a sufficient condition for
for this to compile if we had a parser
English with Spanish with German that
would not compile because English
Spanish with German is not a super type
of English and Spanish if we had just
English just past that it'd be pointless
because there's no there's no no choice
there but we could still do it this
would also compile because English
itself is a it is a super type of
English to Spanish so it's that it's
that type constraint of the the Phantom
type that's that's that's providing us
with the type safety that we're
benefiting from so i think is one will
slide on in section types we do still
have failures
failures in the pars method but if we've
got that valid locale if we've if we've
if we if you've got past past the pars
method then after that everything is
safe everything is fine we have no risk
of an exception being thrown and we have
we've eliminated all the failures all
all all the Pradesh potential points of
failure apart from this this one point
in the past method so this is this is
this is good i think in the context of
the title of the talk we've narrowed the
surface of failure we focused it on this
one path method which which makes things
easier for us so I'm going to do a quick
demo of this which let me I've lost my
lost my notes now okay let's first of
all import rapture Ison I'm going to
need a volunteer in a second by the way
we can we can create a message which is
a nice string of English with French and
we're going to set that to English of
hello world or French of module monde
and this will work and we can then say
message English and we get the English
version we can say French we get the
French version we can say German and we
get a compile error yeah question
so if I if I change English with French
to French with English yeah so so that's
a good point the question was what
happens if we we swap English and French
round in Scala at least at the the type
system level English with French is is
an identical type or it's always
substitutable for French with English so
this is quite a useful property it means
we don't have we don't have no ordering
on our I've intersection type another
thing is it deduplicate so French with
French is the same as French which is
another useful thing our map can only
have one particular value for French so
deduplication is the natural property
that fits between map keys and
intersection types at the type level in
Scala there are some complications with
linearization of types if you're if
you're composing things thats of
object-oriented way it does get more
complicated to whether these types are
the same they do behave differently at
runtime or they can they can do
potentially but they're turistas the
same type there are more complicated
answers to this but I think for now at
least at least in this library we can
happily consider them to be French of
the English to be identical to English
with French
yeah let's yeah so so let's let's create
a site Lang's which is English with
French with what's what was symbol for
hebrew a tree okay so we'd find Lang's
their Hebrew will not work well of my
demo later because i'm using a terminal
that the certainly doesn't do right left
but no no but that's that's fine we can
we can live with that it's more that the
well you'll still see what happens in
fact let's do let's do Hebrew with
German so we've got we've got be
published I blanks now we can say Val
message I string of Lange's now let's
just provide the the English as you can
someone think of something some some
message we could we could which include
including we've used that one different
than I do really my whole my hover craft
is it my hovercraft is full of eels yes
my hovercraft is full of eels okay well
I only provider the English there so
this is this is a type error so a
compile-time this has told me you can't
construct this thing because you've only
provided one version here now it wants
and it we get a nice message here saying
we need French Hebrew and and German
which is exactly what we want we've got
to be told what we need to provide is
there anyone French and or German well
or German here no one okay and so we
don't know how to translate this and we
can't type the Hebrew
okay okay well let's okay let's just
import rapture doctrines late and then
just try this again and hopefully if you
have an internet connection it will it
will actually work out that what money
of glitter it clin donkey a load of
squares for hebrew and our dear my list
kissing fat soy is to follow Ella so the
Scarlet compiler is translating for you
with with some help from the internet
but it's doing this at compile time I
can see you getting your laptop out da
we're going to get a translation of this
into Hebrew in it in a little bit so you
could you could write a whole program
you can embed all your all your strings
in the inland program you could you
could compile it and if you've
accidentally missed out one or two the
compiler could actually just tell you
what you need to copy paste in there and
and it is just a matter of copying that
in there and that then compiles and we
can say message French and we get we get
the right answer okay we're not going at
the Hebrew oh yes a question at the back
yes
yeah so that the type aliases compose as
well and that they do all the
deduplication and so on yeah yeah
another question yes it does that's
right oh I'm being yes of the question
is how do i get my custom error message
and this is this is very cunning
actually even though even I say so
myself I'm pleased with how this worked
I have an implicit conversion from a
valid type a valid I string type to an
invalid one so if of an invalid to a
valid one which calls a macro and the
macro is able to inspect the expected
type and the provider type do a
difference on the the intersections work
out which languages are missing and then
just always fail the macro always fails
but it fails by returning a useful
message we can do anything at compile
time it's yeah I guess so so that that
works writing while you you can you can
use that trick in other in other context
as well there's a few little things you
have to be careful or but but macros can
do anything and in fact this is this is
what gave me the idea to actually just
instead of just returning the message I
call off to google translate it does the
translation and and we get the
translations back so that that that is
the demo and we still have a
command-line API to to invent and
lighting for time I'm I've got 15 mins
okay that's not enough time but let's
let's see how we go so let's let's
pretend we have a command called resize
here there are two ways of calling this
resize we can either gives an area which
is I'm thing as a thousand or we give it
both width and a height
we can't just give the width that's not
valid you can't just give the height we
can't give it an area and a width these
these are the two two different ways of
invoking this this command line call now
with with the API we built up before we
looked at the internationalisation
library this is the kind of code you
might have to write to to to get those
values out it's quite a lot of code we
still have to attempt it here and then
if we don't get that one then we look
for both the width and the height and
then I mean this this get methods can
throw an exception I'm not particular
with this as as code that that's doing a
reasonably simple task of checking that
these that this and the babies these are
two valid valid calls so can we can we
do better I mean this I mean one problem
with this is that there are failures in
three different places every every
access of all of the parameter from from
from the the past parameters could fail
every time we try and access it and we
have we have to sort of fall back on
alternative alternative attempts to get
those those values out if we do the hit
of failure so can we can we do better
than that can we actually reduce those
those failures into a single single
point as we did with the
internationalisation library I mean what
we'd like to write is something like
this either we have an area pram or we
have both width and a height that's
that's basically a very simple
specification for how you can call that
resize program and in fact remember we
saw the the little English or Spanish
parser I built before we did the same
thing here we can we can have we can use
this combination in this Combinator and
we create a parser which we can use to
pass the arguments the arguments again
is just an array of strings that gets
passed passed into the program this is
this is very concise this is much more
concise than the previous version you
saw
we could be potentially have something
that's we haven't we have like a very
complex set of these these parameters I
mean if you think of something like get
which has like over a hundred oh it's
over 200 different different commands
each of which has different different
parameters which are valid at different
times could we could we actually encode
that in a in a similar in a similar way
well I think we could it just becomes a
hugely complex structure of disjunctions
and conjunctions unions and
intersections or products and co
products depending on which angle you're
looking at it from now what we're going
to do is represent the in section type
as what I'm calling a product and
representing the disjunction as a as a
co-product each of which is
parameterised with an intersection type
and what we need to do is define define
these Combinator's pipe &amp;amp; ampersand and
what's really more difficult and and and
when I'm when I'm coding I often do type
driven development I I work out the
types first and then then fill in the
the actual implementations later the
types constrain me in very useful ways
so if I can get the types working then
it's almost as if the the
implementations right themselves so
let's let's trying to find the types
this isn't valid skyla code but it sort
of represents what you might like to
write so if we're working out the the
type of combining and x and y we want to
get a product out at the end it's always
going to be product in all all four
cases but if we have if we're combining
two things that are already products we
only want one product at the end we
don't want to have nested products
likewise throughout these two cases here
with the product on the Left product on
the right which we will combine like so
and in the most general case if neither
them our products we want to still
create a product so this is this is
basically a this is pseudocode for a
match on on types you can't write this
but you can do this by the way this is
the equivalent for for copra lights but
you can write this in Scala so the
encoding is ugly and I haven't even I've
put a lips asst for all of
implementations so the implementations
are impotent probably simpler actually
but but we have used there's a lot more
code here I've included this slide not
not to talk you through it because
that'll be quite dull but if you want to
go and check the check the slides later
you can you can read through it and try
and understand what's what's happening
but from the users point of view you
just write this use urban area pram or a
width and a height and we can pass that
you don't see any of that complexity the
type you get back from that is a
co-product of an intersection of the
area parameter and which is which is one
one possibility or we should represent
by with a product of the width with the
height so this is this is how the the
tight end up composing in the example
here so the type is actually longer than
the than the the code you need to type
to get it and this is this is probably
the most complex slide so I will try and
talk you through this a bit having
having done the parsing having having
passed our arguments with this parson we
just constructed here we now have a
value PS and we can handle that so
handle is a method I've defined that
works on on something that's all on a
command line that's been passed and we
have to handle two possibilities we
handle the area because that's that
branch and we handle the right-hand
branch which is width for a man hype ram
with brown and hype run and the
the code you write is basically if it's
an area then we try and get the area
this is a this is a lambda here if its
width ramen hyper and then given given
the parameters we get the width and the
height and we multiply them so this this
is quite it does it does take maybe a
little while to see what's going on here
but we're dealing with all the
possibilities left on the right branch
and within each we are returning I mean
this returns an integer area is too fine
to be an integer parameter likewise
height and width we multiply these
together so this is this is itself an
integer so with both of these lambdas
returning integers the type system then
knows that this area is going to return
an integer which is exactly what we
wanted that's good handle is actually
actually takes far Aleksic it can take
any number of parameters it takes to
hear this is one parameter this is
another one but it has a type constraint
there is a type constraint which ensures
that you actually handle every single
possibility you have to handle area for
a me you have to handle with for my pram
it does that using very standard type
system very very standard actually quite
complicated type system features it uses
the same thing that varargs always use
which is to find the love of these two
parameter types that the least upper
bound and we can actually use this this
least upper bound we can use this
calculation the compiler does that it
does all the time we can use in week we
can as long as we define our types with
with the right variants and and as long
as we get a lot of things right and then
there's a lot of trial and error
involved here we can actually have the
type system enforce the constraint that
if any of these were missed out it would
it would not compile so what we have is
a total function handle is a total
function it will never fail if it
compiles
so this is this is what we want our
failure is all happening up front here
if this succeeds then we're good for the
rest of the program so this is this is
this is great the failure can happen
here and we have the there are ways we
can we can fix that there are things we
maybe need to do to make sure it gets
against handle successfully but we're
just dealing with it in a single place
we're not dealing with it here or here
or here so here or here or here these
are guaranteed to succeed I told you the
typing was quite complex this is what
the same thing looks like with all the
missing stuff shown so the skull I think
is a very good language for hiding
hiding details a lot of stuff goes on
that that you a lot of gets inferred
that you don't need to see you don't
need to see the return type they're the
type parameter to the handle method
which is this this long thing here
flowing onto two lines this this gets
inferred automatically the the type of
this parameter here is inferred I
haven't even shown the type Ram to bear
but that one is inferred all of this all
of this happens without you needing to
without you needing to to enter it
yourself it's it's complex but you can
you can use it without needing to
understand it which i think is a is it's
a great feature of scholar for as long
as it works when it starts to when when
when it starts to fray at the edges
things become a bit harder and and maybe
that's one of the challenges Scarlett
faces at the moment and in the future so
I'm actually I think reasonably on time
we and I'm still quickly summarize we
have programs which have multiple
failure points are I have multiple
burdens on that on the on the programmer
there is more work to do in there are
more things to think about to be to be
certain that your program will will work
and its its its burden
so what we do in stairs we handle all
all the possible faders up front as
early as we possibly can and then encode
in the type system those those those
facts we've established from having
successfully parsed it and the type
which then I think it's passed
throughout the program is it is often
offering you guarantees is offering you
confidence that you can you can then
call total total functions on on these
these typed values and they'll be safe
you don't have to worry about you don't
have to worry about runtime failures
everything everything that's going to
fail will will happen as early as
possible at compile time and we've
reduced the surface of failure so where
is this where it's going to go in the
future I think I've got really big hopes
for dependent typing but at the same
time I think it might take a while
before it becomes it becomes widespread
scholars had dependent types in its in
its own slightly complex encoding for
three or four years now shapeless is is
it's a well-known library that uses
dependent types which is quite quite
widely used but there aren't many there
aren't many libraries that use use
dependent types as much as they
potentially could so there's this work
to do certainly for Scala in in in
making these things more accessible
language is like Idris are better at
giving you giving you first class
dependent types in Scala we have to we
have to improve the way that we we we
encode these things because it just
becomes a bit too to complicate it in
particular with error messages error
messages I think I think of one
particular like a type mismatch is one
particular place where the
the message still the the fix can be
completely impenetrable you have like
types which fill the screen and that
that is that is complex but we we can
end up with with code that has larger
and larger blocks or a lot larger and
larger areas that we can be confident
about that confident they will work at
runtime without without failure and one
last point we with this information we
get from dependent types we can actually
get better performance we can take
advantage of the knowledge that that
additional more specific typing gives us
to make our code faster we can we can
for example replace hash lookups hash
lookups in a hashmap with simple array
access and that's that's the end I can
see bodil getting closer and closer I'm
done thank you any questions if you just
connect your computer fast we can do one
question yeah if you promise for
everything good point yes oats but like
like this okay oh I see sorry question
so independently by the next version of
scholar if oh 3 if I didn't repeat the
question so the question was do i do i
see my implementation become easy with
the next version of scholar skull of 3
or Dottie or whatever however that comes
into being yes that will be a little bit
easier scholar as it currently exists
that the two point x version I think
will be will remain the encoding will
remain reasonably complicated but I
think I think we need a bit of a step
change and I think Dottie may provide
that the type level Scarlett project has
done some experiments with representing
singleton types more more more easily
that that is one one area that it that
it could improve and that may in fact
actually make it into into Scarlett but
I think there's gonna be more of a
change in in Dottie at the moment Dottie
is experimental it's it's only just in
the last month been able to bootstrap
itself so it is still several years way
and that loves I only had time for one
question didn't I or other any more
questions yeah at the back
yes
so yeah so the question is when you have
many complex types being composed in
complex ways you have nested products
and copra lights in the same type and
the type gets longer and longer and
longer how do i how do I manage it I I
design it in a way that's that's meant
to be composable and I I rely on the the
compiler to to do the right thing but
it's it relates quite closer to the
point i mentioned at the end that the
error messages are very complex if you
have if you have a type mismatch in a
really complicated type like that and
for example that that might look like
several handle methods nested within
each other you at you you end up with a
type mismatch it might be half a page
for each for the correct type and
incorrect type and you need to work out
what the differences and that that's
quite difficult that that's that's an
area where I think the compiler needs to
improve and and probably provide ways
for people like me who are rising
libraries use independent types to to
better present those types to thee to
the users I think I think that this this
is the area where a lot of work needs to
be done yeah thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>