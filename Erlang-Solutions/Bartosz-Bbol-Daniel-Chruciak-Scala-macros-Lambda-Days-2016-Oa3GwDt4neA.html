<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bartosz Bąbol, Daniel Chruściak - Scala macros (...) (Lambda Days 2016) | Coder Coacher - Coaching Coders</title><meta content="Bartosz Bąbol, Daniel Chruściak - Scala macros (...) (Lambda Days 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Bartosz Bąbol, Daniel Chruściak - Scala macros (...) (Lambda Days 2016)</b></h2><h5 class="post__date">2016-05-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Oa3GwDt4neA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so welcome everybody to my presentation
about Skylar
I wanted to make title of this present
although I'm aware that there is no
silver bullet in software engineering
but Skyler macros or maybe speaking more
generally a meta programming has very
wide range of use cases very off very
often even in this conference you will
hear don't use macros don't use macros
it's some kind of magic and and this is
true it's some kind of magic but I want
to give you some use cases where they
are useful so for me personally it was
very enjoyable to learn them and to use
them to solve everyday problems so let's
start and few words few words about me
I'm bartosz bumble I work in company
called Java Java was located in war so
we do applications mostly in Java and
Scala using you might call it reactive
technology stack and by the way i have
included here my twitter twitter
nickname and link to my blog and on my
blog i have written free blog posts
about this topic of macros so if you
will find this topic interesting i
encourage you to preview them what else
so to sum up this about me page I'm just
a regular developer who tried to use
this language experimental feature and
today I want to share with you from with
my experiences from this experiment so
let's get started so what about some
traditional survey and let me ask some
questions how many of you have heard
about scala macros yes that's almost
everybody and how many of you have used
color macros or in project okay so a few
people so that was expecting otherwise
you would not be here and but to the
point this is the screenshot from the
documentation which by the way is very
good and extensive with a lot of theory
and use cases but you will find this
sign experimental yeah so it means that
it is still an experimental feature of
the language but it is also widely used
by developers feature so we'll see some
examples couple of slides later how you
could use
macross and today we will try to grasp
the essence of macros I want to present
them in kind of natural yeah so let's
start with some simple theory so
according to the fantastic presentations
by one of Scylla macros creators Eugene
blue Marco macros are good for good for
three things yeah code generation static
checks and domain-specific languages and
by the way i encourage you to preview
this presentation after my talk mmm i
have included link to it at final slide
of my presentation so now we've got some
idea general idea what they are good for
let's go a little bit deeper so i have
included here some bullet points some
key features of macros and just to
preview them right now and macros allow
metaprogramming in sky so meta program
is generating you're modifying existing
code and for me metaprogramming
generating or modifying existing code is
because you want to drive this car it's
kind of cool it's nice looking good
looking and it's what is more important
it is easy to drive here but you want to
drive this car which has feature
features of this machine it's very
complex is very powerful it can do a lot
of stuff but it's hard to drive here so
mmm and what else you want to have this
transformation at compile time of course
so this is very important feature of
scale matters they are expanded at
compile time and macros manipulate AST
whatever this asd is you've got some api
to build this aest and so on so
microsite great Marcus or greater
building libraries and maybe this is why
they are so widely used there and they
are written in Scala so you can use your
favorite language to write them or my
favorite language to write them so now
we'll focus on the first point and we'll
try to understand what metaprogramming
case and this is how I imagined macros
you've got some simple useful thing
which some are under the hood at compile
time changes to some powerful gigantic
robot here so so macros can transform
your code from this beetle to do some
kind of machine
so and you might like to think of meta
programming has some kind of magic
because what it does is a short of
magical little short of magic and what
do I mean by that but being almost
serious maybe you've watched the
leonardo dicaprio movie inception yes
yeah so the movie is about dreaming
inside some other dream this is kind of
story where people could get inside
somebody's others dream and do something
inside it modified it a little bit I
know it's kind of abstract for those who
didn't watch it but this idea of
dreaming inside some other dream is kind
of similar to meta programming which is
programming inside some other program
yeah so meta program is a program which
takes as an input other program modifies
it a little bit changes its behavior and
returns it so it's metaprogramming
specific to scala is it a new concept
and of course not metaprogramming exists
in many known languages I have two
outlined here you know the very popular
languages which has meta programming and
it is considered as very controversial
feature and because you know with a lot
of power comes great responsibility and
macros or metaprogramming gives
developer a lot of power and what do I
mean by that so let's focus on macro
example it is see these are very simple
examples and what C preprocessor does in
this case it replaces code snippet with
our macro body at before compilation so
the compiled code will look quite
different than this written by developer
I have also included here conditional
compilation so proper code will be
combined only if some kind of condition
will succeed yeah so it could be useful
when you are writing some kind of mobile
library for mobile devices and iOS
Android has have different code review
requirements so we might choose which
code might compile depending on platform
yes so it looks kinda cool but there are
there are some downsides and look at
this beast and if you haven't sit downs
this example before what it does it
replaces true to false in your code yeah
so if you are funny developer in mud it
might be very tempting to write some
like this yeah but the consequences
might not be so good for you and but
this is valid and possible to do and
this isn't possible answer the question
why metaprogramming so controversial
because you can do a lot of stuff there
and but I wanted to highlight the
weakness of C macro hero so we are back
to scala yeah so which libraries use
macros so i have outlined here son
skyler superstars which were somewhere
under the hood use macros to accomplish
their goals and we'll focus a little bit
more on Play Framework just to show you
a real example power of macros so the
first example is parsing JSON yeah
you've got case class and you want to
parse it to the Jason because you are
building some rest api it's very common
situation right so you've got a lot of
dis transformations in your code and how
to do this in play framework and this is
how you can achieve it in play framework
you've got this method right you specify
which fields this suggestion should have
and and it's possible way and it's
possible to do it in this way but I want
to highlight here a typical first world
problem boilerplate code via so let's
think about code on the left so this
case class car as a set of words a bag
of tokens whatever else a set of bag of
tokens set of wars if we could take
those words if you could take owners
drink in the air this world rearrange
them a little bit modify modify them add
some new syntax then we could achieve
coat on the right and this is the main
idea and of course this is not my idea
somebody else had exactly the same this
idea before and try to implement this
and this is the result so this is how in
play framework you can achieve seem the
same goal the same thing so this is how
you can convert object to Jason and it
is more concise the redundant code code
lines are removed so it's easier to read
and so on it's more compact
so let's check how this method is
implemented and let's look at file Jason
scholar at this rights method definition
and there is a comment above it which
says exactly what this method does and
we see that this comment is saying that
the line highlighted on red is
transformed to the to these lines and
enormous amount of boilerplate
highlighted on blue and which we want
avoid writing here so now let's focus on
implementation and implementation also
looks very concise if we only knew what
this macro key word means yeah so first
starts start with some simple examples
okay so look at the simple method
invocation it will not do anything
magical just print lies some text but
look closely at this do you see
something suspicious here you see
something I don't know weird so
okay never my developer from outside
cannot specify if method is implemented
using scholar mattress or not so this
method is valid it's nothing suspicious
here but but let's look at the
implementation of this color method so
this is object welcome and what is
important it should be specified in
different compilation face so different
SBT project which your projection
depends on but this is some kind of
configurational detail you can check it
on my blog post how to do this it's not
the case for now so signature of deaf
hello looks pretty standard except this
macro keyword and this macro keyword is
the way how you select implementation of
your macro so now let's see how the
implementation looks like and hello
implementation takes two sets of
arguments first one is context yeah its
type of context and second one is three
return returning type is also this
mysterious tree so let's look at
imported packages for example so look at
simple package and you can see that
there is a black box world and the black
box package and macros in skala come in
two flavors black box and white box if
macro faithfully follow the type
definition the type signature then it
might be considered considered as black
box so it is black books and if type
signature of macro is only some kinds of
abbreviation then macro is white box
yeah and it's more confident to use
macro black box when you're writing def
macro so this examples of documentation
says that so now let's look at
implementation and I have set a couple
of slides before that meta program is a
program which takes an input other
program transforms it a little bit and
returns a new program and this method in
this hello implementation method you
might think about this name parameter as
piece of your code piece of your code so
this is the meta program which takes an
input other program and returns other
program it's not specifically programmed
but we'll go further with the definition
so
let's start with some theory yeah let's
repeat what macros are so macros are
functions that are called by the
compiler during copulation and within
these functions the programmer has
access to the compiler API so he can
type the code he can generate called
analyze it and so on and to do this we
need some API and context wraps a
compiler universe and provides you an
API for meta programming and this
universe package is refinement over
universe known from reflections color
reflection package so you might think
about it as meta press API for meta
programming and the second parameter is
3 and this is the type of sure
represents abstract syntax tree so in
macros implementation will operate will
produce kinda low level structure like
abstract syntax tree we can arbitrarily
modifies those trees and then compiler
will check a result of our modifications
so we'll see later advantages of it and
the last thing of our macro is returning
type yeah so as you see the types also
tree so let's look at the body and this
is body of our implementation and as you
suppose current here is a value which
holds current here as an integer and but
what is this Q interpolator it's more
interesting so it's called quasi quote
and this is how you can build a SD
abstract syntax tree in Scala this is an
API for building asd so we can build
your coat with ease using kind of human
readable code and you're using this
construction called quasi code so like
let's look closer to the last line of
this macro and this line is pretty
important you can use Pugh interpolator
to build a st it looks similar to
building a string so the syntax of thing
of this interpolator is commonly used in
other scala interpolators but what is
this AST what is abstract syntax tree so
asd is core data structure using in
compilers so let's say that we have
following piece of code 1 + 2 + 3 yeah
so early stage of compilation is like
Cal analysis and what it does is
checking the sequence of code elements
and it assigns them two tokens so this
is an example how this code might look
like after lexical analysis and each
sign is assigned to some token but there
are also redundant sighs like
parentheses for example and compiler
needs simpler data structure for example
without parentheses and this is an
example of a st so we've got tokens and
operations right so for compiler this
tree is an information how code is
structured and how to evaluate it i have
included two versions of graphical asd
representation just to give you bigger
perspective what it is so let's say that
you have created some language with an
API for building a SD and plus is just
some representation of code token so AST
written in your language could be
created in similar way so and it will
result result with following structure
it might look like this so why have I
why I have written this is the example
in this way so let's go back to our
example and this code also builds i
esteem to interpolate allows you to
build a hdez as i said before so if they
allow you to build a SD easier there
there should be also some kind of harder
way and what does this expression
produce and this is generated tree you
can generate it you using cheuvreux
method in in scala so it looks a bit
more complicated than the previous
previous example each of these objects
are subtypes of type 3 and this is why i
have written this is the example 1 + 2 +
3 in this way just to show you the
different notations you might use so
let's compare those two ways of creating
kst and this light is pretty important
because i want to highlight what Kwazii
code gives you so without without
classical's you might build your tree in
this way and this is absolutely valid it
is you might put the Equality sign
between code on the left that condo the
right
so I want to show you how they simplify
creating kst you can write human
readable code and somewhere under the
hood in replaces 222 this tree built
from tokens ya hear no no no no it's
only building kst then it is past
further to the compiler and compiler we
say ok you mess you did some syntax
error for example here so your question
is macros different project yeah it is
it's you know it is only for building
kst then if you are using it in your
project then your compiler from your
project will check the syntax from build
a tasty so what else so Kwazii codes
also come in many flavors you've got
different interpolators for building
different structures and if you would
like to build for example body of the
case closed then you will use CQ
interpolator if you want to build for
loop enumerator then use f queuing fq if
you want to build some type then take TQ
and you will find more examples on block
and on documentation i just want to say
that they are existing yeah so now let's
look at little bit more practical
example that was some introduction to
the topic and so let's consider
following situation we want to have
possibility to easily benchmark methods
so we would like to know how much time
the method takes to execute how to do
this this is how we can achieve it and
it just wraps your code in time stamps
between time stamps and print line their
result of difference between those times
x so nothing fancy and actually nothing
important yeah but let's look closer at
this wrapper so this is boilerplate and
we would like to avoid writing this come
on so we are wrapping body of our method
with some time stamp
and but this is not important to
understand the behavior of our method
yeah and it would be tedious to write
this each time you want to check the
time right the time difference so this
also the best option would be to not
touch the method body at all so how to
do this and this is the example how you
can achieve similar behavioral qs e
behavior using Skylar macro and
notations and this is different type of
macro which allows you to write
annotations which can change annotating
definition at compile time it's
important so personally it's my favorite
type of macro what is cool in my opinion
here we don't have to touch existing
code we are just outside the method we
are just uh not a ting it and we don't
have to modify method body at all I mean
developer don't have to modify it so so
this benchmark and notation in some some
magical way transfers our method to
achieve our goal yeah so let's look what
we want to achieve so on the left you've
got desirable syntax and on the right
we've got what this syntax should be
equivalent so we want to produce this
code but we want to write this code we
want to drive this cool mini cooper and
we want to expand it to this gigantic
amount of boilerplate so how to achieve
this using scale omicron notations this
is definition of our macro and what is
important class benchmark so definition
of our annotation is extending static
and notation trade which specifies how
implementation of macro notation should
look like and Method macro transform
take parameters which are called and
notice and so there are elements which
we are annotating so methods of classes
or values whatever whatever we are
annotating and net next we've got macro
keywords and following implementation of
macro so let's focus on end and this is
how our macro implementation looks like
and let's focus on specific parts of it
so there are differences between death
macros and macro notations when looking
at their implementations one difference
is we need to implement
Pro transform method so from the
previous slide and next difference is
our implementation takes two sets of
arguments first one is context we know
what context is an API for meta
programming and what this under these
are these are expression of N and what
how you can think about this expression
it is just some kind of wrapper around
AST so now let's look at this body of
this implementation so what is going on
here so I'm not this is sequence of
annotated definitions as we said earlier
and we want to have them in form of AST
so we are mapping this collection and
transforming each element 2 3 and next
outstanding in my opinion feature of
quasi codes is this extractor pattern so
you see this case we see pattern
matching when on the case closed you've
got this pattern and this pattern is
copied from the documentation you will
have different patterns for different
unnoticed so if you want to uh not the
annotate class you will have quite a
little bit different pattern but what is
important you can extract what is
important what what is important from
your annotation yeah so we can extract
method name types arguments returning
time and so on let's focus a little bit
more on this case clause and look at
this weird two dots and three dot sign
yeah for me that was quite weird when I
saw the so then first time so what do
they mean and these are patterns of
course two dots means that in this place
you expect list of three and three dots
mean that you are expecting lists of
lists of three and why is that so the
reason is the reason is because method
can take one set of arguments one set of
type parameters so list of three yeah
and Method context can take many sets of
arguments so list of lists of three and
this is the pattern so now maybe the
good moment to imagine how you would
butter much code if you have to generate
it from string for example
so so I hope you see what this API gives
you so back to our implementation this
is core of our implementation this is
the real body and we are here generating
new IST so in this example we return the
same method with the same signature
we've changed a little bit body so we
are assigning body to some value result
we are returning this value and we are
wrapping the code with start and to end
values yes and we are print lining the
difference between aunt and start so
actually we are doing what we want yes
so at compile time somewhere under the
hood we are building we are modifying
our code to accomplish this benchmark
think so look at this first line and we
are building here method with the same
signature but there is a good place to
mess up a little bit and we can change
it so for example your question was
about changing checking for correctness
yeah so let's say that you will change
return type for example this is the same
return type your metal fest but let's
change it to I don't know string so what
will happen our method is returning
integer because it's powering some
number RIA whatever and you will have to
statically right here string so of
course you will have compile time error
that your method is you know returning
something wrong this result will be that
it will be integer and return type will
be string so more examples in code to
them you can find in my blog in
mentioned a real post so these were some
kind of small examples just to fit you
in the context of this meta programming
thing and what you should be aware now
is Skylar macros are about building code
from three types and using this kind of
cool API and replacing all the st with
new modified one and everything is at
compile time what is important so now
let's look at use case we had in our
region 14 recent projects so
we have read a small library which we
called Gridley yeah the grid and grizzly
dangerous bear because macros are so
dangerous and powerful but why grid what
was our main problem so on this slide
you can see typical front end table so
you've got a lot of columns we've got a
lot of data you want to have option to
filter those columns you've got you get
here dynamic pagination right you've got
option to sort those columns and so on
and we want to do this pagination
filtering consulting on the back end
because we've got a lot of data so
project was written in play framework
which is actually not so important and
slick which is more important and
angularjs which is absolutely not
important in this case so working
example from this slide from this give
you will find on Javas github so i
encourage you to preview it so let's dig
deeper into this problem and slick is
functional relation or relational
mapping for scala and what it does in
towards it just replaces scholar syntax
to sequel and this is the example so
this is a small example what slick does
it just replaces scholar syntax to
sequin and of course slick has its own
API for sorting for filtering paw
generating so let's look at example how
we could implement this whole sorting
filtering in slick for our purposes so
let's say that we've got users table
this is representation of users table in
slick don't get into syntax too much
it's not important what is important
you've got some columns here first name
last name gender nodes and this is
sequel table yeah so let's preview
necessary methods I said earlier that
you in slick you've gotta API forbidding
salting filtering pagination so these
are methods which allows us to build
desired behavior and of course when you
filter the table it transforms to select
with we're close without
surprises you can also paginate paginate
your data using drop and take methods
and of course you can sort by selected
column ascending descending at it will
translate to select select query with
order by ascending descending yeah so
this is what we need to build sorting
insulting filtering imaginating so now
let's use those methods to create full
pagination needed for our for our
example so there is a lot of code but
there is nothing special here don't
focus too much on the syntax what we are
doing here so for different parameters
from front end table we are building
slightly different sort by so for first
name ascending will build sort by first
name ascending and so on so what is
repeated here so what tokens from this
code exists in each line and it would be
great if they would be generated so what
I want to highlight right now is this
boilerplate call so look at this code in
terms of tokens as we look at this code
from json example so for each column of
our users table we have to write almost
the same code what differs is case
parameter this couple of strings with
column name and sort direction and of
course sort by function body differs a
little bit so actually what we can treat
as boilerplate is also this ascending
descending words yeah because we always
want to have sorting in two directions
we always want to have sorting in
ascending way and descending so it is
tedious to write this x developer and so
if remove ascending and descending from
our code then we have got each column
name talk and repeat that so we can get
rid of the repetitions and our code is a
little bit simplified so do we find
finish now can we do better and leo says
that it is still too much boilerplate
and by the way this photo ma'am is from
movie Inception which I have mentioned a
beginning of our philosophical
discussion about meta programming and
actually from this perspective what is
important to build this whole sort by
is column names so this is the one
element which differs in each line so
you remember the example of parsing JSON
and this similar case if you have only
those tokens with column nice it is
possible to generate rest of the code or
to be more specific to be more specific
build bigger AST with something okay so
now we have to filter our data by
columns and don't get into the slick
syntax too much what is important here
that still we've got a lot of
boilerplate code what tokens are needed
to build this code and more or less does
one and similarly to sorting we would
have columnist we could generate rest of
the boilerplate code so now is the fun
part requiring your imagination how to
design your library or how to design
your macro to grab all the required
tokens do some kind of magic inside your
micro and achieve your goal so my idea
is who is this so this is how you can
achieve all required tokens from user to
generate the sort by filtering pas
generating thing and this is how I try
to reduce boilerplate so for comparison
I wanted to compare this syntax of map
law we've generated code what it
generates and generated code looks like
this I wanted to fit it on the side but
actually it couldn't fit so imagine that
it and some were here probably yeah so
it's what I want to highlight on the
left is less on the right is more and so
full generated code you can preview on
Chavez github and let's look at the
syntax again some what developer has to
specify a set of columns and optional
filter like so for example if you want
to filter by comparing equality then you
will write write equals if you want to
filter by like then your then you can
write like or leave it blank so
it's the library internals or syntax is
not important in this example but I
wanted to highlight some language
feature which helps us reducing
bug-ridden redundant code so you might
argue that this syntax is fully free
from boilerplate because couple of
slides before I have said that all you
need is column names and here you've got
some types here you've got some strings
here you've got some math functions and
why is that and one reason is visibility
and ide support I thought that it would
be easier to parameterize this grid
column object with some types and it
would be hint for developer which this
how this method the second parameter
should look like and I don't want to say
about the syntax you can find details in
Java it up but what you can remember
from this example is this class users
grid is only some bag some container for
tokens yeah so developer wants to use
this library has to provide me proper
words proper tokens then grizzly will
take them rearrange them a little bit
add some syntax modify those tokens and
build bigger HD with desired syntax so
but what I wanted to highlight here is
other problem with macros and this is
problem this problem is ide support so
let's stay with grizzly example so this
is called from our project and it looks
quite suspicious everything is
highlighted in red but it compiles and
it works properly so let's look at the
search result and you are invoking
method grid method run on this object
and maybe as you remember there is no
method run it is class so it should be
it probably it is generated by macro and
it is magical and kind of fun to ride
but it would be a pain to use this kind
of library without investigate
documentation or without some ID support
and as you presume there is a solution
for this problem and personally I'm
using IntelliJ IDEA at my everyday work
and when I have started to play with
macros I was a little bit disappointed
because for example if macro notation
adds new method to the
annotated definition so as it is in our
example of grid then IntelliJ IDEA
cannot see it because its coding
consistence is based on static code
analysis and it is not aware of AST
changes so it's a kind of problem but in
October last year IntelliJ IDEA publish
this post and there it was explained
that IntelliJ is providing small API for
building plugins to support support
macros so actually writing your idea
plugin is not that hard and in third
posts about macros on my blog you will
find small example how to do this so it
requires a little more effort to make
your macro fully how to say full
complete yeah but still I think that in
some cases it might be worth it if you
have a couple of weekends free and what
about debugging i want to say i hope
that i will run of time right now i
wanted to skip this slide so debugging
of macros is quite complicated because
what you are actually doing is two
things first of all you are generating
the tree which should accomplish some
logic and second of all it should
perform some perform this logic here so
you have to first build this tree and
check ok so I abilities and it works but
but then you have to check if it works
correctly so testing and debugging
should be how to save to face process
yeah so you should be back on real body
this your macro so I think that it would
be the best if you would preview the
examples and play with them just to show
you just to see how it is to write and
debug your macro so we are going to the
end and what I wanted to give you today
is give you the taster of scala macros i
use them to hide complex logic inside
simpler syntax and the reason to do this
is to reduce places where you can make
mistakes so the let's go developer has
to write
the fewer errors he will make and also
the solution simplifies debugging and 45
minutes is not enough to present you all
the features of markers and Kwazii
quotes API but as I said earlier you
will find examples in in my blog in my
block and also in skala Madras page
there is some kind of bookmark with dogs
where you will find all the papers and
interesting dogs and I have also
included here the link to the
presentation from company called
underscore I oh I think this very good
presentation so i encourage you to
preview it and what else I hope that I
convinced you a little bit that macros
are not so scary and they could be
useful to avoid writing boilerplate code
and so the code of Brisbane is on Travis
github mmm i hope that using macros in
your projects will result with fallon
faster development more concise code and
more than a little fun as you master
scholar macros as it was in Michaels so
thank you very much for listening any
questions we have where'd the bug encode
and using our ID now let's let it be
idea and is it this code because you
know macro generates i AST and during
the bugging i would like to see some
source code is it readable in any way
yes I mean you want to see their
generated code and not the ASD right yes
because generating code from a st is not
one-to-one function you can almost want
one the sugaring for example of for
compression and other things and yes yes
and also names inside macros I don't
know maybe that's under my control but
I was just curious if it is not too much
paint the back this code generated by me
i would say that it's a little more pain
than the normal code to debug because
what i was doing in my example of this
grisly i was generating their code with
this shortcode method yeah i was
generating it then I was copy copying it
to my project replacing the macro
invocation and then I was checking the
resulting behavior yeah so I was kind of
reverse engineering then I repair what I
have to repair yeah and they're there i
move it to my macro i change what i have
to change and this is how i debugged it
so it's kinda I don't know how to call
it reverse engineering I don't know so
maybe it's kind of primitive maybe there
are better ways so but it worked for me
can you do self typing in macros yes and
there is about about your question there
is in this scanner macros first link
there is a repository from Eugene Bull
Marco where he shows examples how to do
this on github on examples so if you
want to preview the details i encourage
you there is a scholar macros 101 I
think something the repositories
conflate like this
can you come and place on why sleek
seized using macros even though they are
so awesome like they used to have
experimental support for defining the
tables which is pretty much boilerplate
code and then they depreciated in three
point 0 and then eventually system
completely in 3.1 why I don't know
exactly why I read the documentation the
explanation why they did this and they
said that it was too error prone to
define a table and also the migrations I
think also there was you could write
migrations also in Scala so they said
that it is too error-prone and it was
too buggy to use it but we have been
using this generating sequel for example
this user's definition in slick to
version two but now we are not using it
because you know they said that it is
too buggy and can we nest markers can we
nest macros like we have some code apply
a macro to you to transform ya now the
contender is another market of course my
pros just you know project which you can
nest and in this example this macro is
your project is dependent on this macro
project but you can you know build
bigger chain okay and we are we already
run out out of time so please hang our
speaker once again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>