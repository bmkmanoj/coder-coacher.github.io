<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erik Stenman - BEAM: What Makes Erlang BEAM - Code Mesh 2017 | Coder Coacher - Coaching Coders</title><meta content="Erik Stenman - BEAM: What Makes Erlang BEAM - Code Mesh 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erik Stenman - BEAM: What Makes Erlang BEAM - Code Mesh 2017</b></h2><h5 class="post__date">2017-12-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FonRzASOkZE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my name is Eric Steadman but most
people call me happy
perhaps because my general positive
attitude or it might be because I come
from
haparanda which is sort of as far north
that you can get if it hadn't been for
the Gulf Stream it would have been
permanent ice over haparanda but luckily
right now at least we have the Gulf
Stream so you can live there it's sort
of dark and snowy most of the time and
far away from everything so in the 70s
and 80s when I grew up there was of
course no internet and haparanda has
only about 9,000 people and I think we
were three that were interested in
computers so there were not that many
meetups at that time so I was interested
in programming or actually I was
interested in games of course this is
the type of really nice games we had at
that time and this intrigued me so I
wanted to get into games and I realized
that there there were three parts you
could do the sound and music and I
sucked at that you could do the graphics
and well I was ok with graphics but I
decided that I better go for programming
so in 1980 I started to learn how to
program in order to become a game
programmer it took a little bit longer
than I thought so last year after 36
years I released my first game
commercial gain it was of course a
fantastic commercial failure and has
left no trace whatsoever on the history
of gaming but the site is terrible calm
you can go and play chess for free
congratulations but I can now say that
I'm a game programmer so 36 years and
I'm a game programmer
but that's not why I'm here today today
I'm going to talk a little bit about
what I learned during those 36 years
from starting to learn to program and to
actually become a game programmer and
most of that time I spent doing airlines
so I'm going to talk about airline and
the beam that's why I'm here
question is why you are here probably
you read in the abstract that I was
going to talk about the beam and the
components in the beam but I'm not
really going to do that so there's
another presentation and I have it here
and you can go and look at it online
also that shows everything there's also
a book that is actually now online on
github the beam book that has been more
popular than I thought because it's just
a manual but there you can read about
all the details about how the beam works
I'm going to talk a little bit more
about why the beam works as it does
today and talk on a little bit higher
level about the beam and then make a few
deep dives into some details so
what was the problem the problem that
team tries to solve is to build software
system that runs forever
so as Ricard said I used to work for
this small start-up that became a large
start-up providing a payment solution
that had to be up 24-7 and the first
five years we just kept on adding stuff
to the system and the system was just
keeping up with the traffic but we had
one problem growth so the traffic was
doubling every 10 to 11 months so there
was a exponential growth we got more
customers and there were more more
people starting to buy things online and
we got more and more sales people in and
we got more and more customers well when
I say it's a problem with growth of
course that's for the tech department
the rest of the company didn't see the
growth has a problem they thought it was
great
but for the tech department it was a
little bit of a problem but since for
the rest of the company just was the
good thing meant that we got more and
more money so we could just scale
horizontally so we just bought larger
and larger computers finally running on
a 2 terabyte machine with 40 cores 80
with hyper-threading so that's old the
problems for another couple of years but
there were some bumps in the road so at
one time for example we had this XML
parser that trashed and in Erlang when
you have a term that is shared within
the process
it keeps everything shared on the heap
so if you parse and build up a tree with
lots of sub trees of the thing you're
parsing all these sub trees will just be
kept in in one place so it worked fine
for for some time and then for some
reason there were some bug in the parser
and it crashed and then it through its
state to its supervisor said oh I'm
dying
here take care of my data and then of
course this state expanded because at
that time a line copied all the state
when it crashed and expanded all the
terms and then suddenly one process at
more than 32 gigabyte of data and this
was obviously the first time in a long
history that this happened because the
garbage collector crashed and the whole
system and town took some time to figure
that event loop out but finally we did
nowadays I think there's even a the
Hyperloop has provided a way that you
can choose to compile your along system
so that you even keep sharing when you
send messages between processes we also
had a domain-specific language in the
system that decides whether we should
accept credit for a customer or not so
in this system you could write rules
like well you have to be over 18 and
it's nice if you have an income and
things like this and it was backtracking
like Prolog system a little bit so it
did backtracking by having tried
CAPTCHAs and compiled to airline code
and then had tried caches and at that
time you couldn't have more than 4096
try captures in the system at the same
time this was a statically static array
they kept all the try caches with a
little comment oh this should probably
be dynamic smiley face
exit smiley face
and the exit code was not zero but minus
one and disappeared somehow so it took
some time to figure out that when we
load a new code and a system crashed it
was because we had too many try CAPTCHAs
fortunately the new version of our lang
at that time had already solved this we
had just not upgraded yet so that was
easily sold a third little bump in the
road was that since we had this really
really powerful machine it meant that
sometimes especially during night and
the system could see that all right but
I don't seem to have that much work to
do and the Erlang scheduler works that
way that if if a one of the schedulers
don't any have any work to do it goes to
sleep to save power and all the
schedulers but one went to sleep and
then this last scheduler got a bunch of
big terms that it wanted to write into
database don't ask me why but at this
point it got these hundreds and thousand
of them and they were like gigabytes
large and there was one instruction in
the team where he could do term to
binary which didn't really count as
worked by the scheduler so normally you
can do something called reduction 4000
reductions and then that process is put
to sleep and the next process get around
so you get to do 4,000 function calls
and then someone else get to run but
term to binary counted as one function
call so you could do 4,000 turn to
binary that could take one gigabyte of
data and turn it into a binary and this
of course took a lot of time so outside
our system we had this other process
called heart that was pinging
the system are you live are you lie are
you lied and the system was now I'm
doing term to binary I'm doing terribly
binary and the heart went hmm you're not
really responding and kill the system so
it had too little work to do and then it
was killed in the middle of the night
fun stuff but that was not really any
problem with airline per se or the
system it was just strange things that
happens yeah but as you know with
exponential growth what eventually will
happen is that is slow trickling that
you hardly notice suddenly just goes
boom and of course we had just had fun
adding new features to the system and
not really trying to scale it so when
this happened we started to get some
more serious problem with the actual
code and we had to go in and make the
system scale vertically instead and find
all the bottlenecks and rewrite it
fortunately then for us this was written
in a line and we could quite easily do
this so what makes our line so great
Alan was designed from the ground up to
build and maintain telephony systems so
in 1970 Ericsson that made telephone
switches and thiele market which was
Swedish national telephony exchange
started a company together to build the
next generation of telephone switches
and this is a official picture from
Erickson's history site when they build
a X system so
building this system included designing
their own microprocessor and their own
programming language flex and in 1976
the first switch was delivered and by
1992 Ericsson had 40 percent of the
global mobile telephone switching market
with this new switch so that went very
well this company that was started the
LM tel also started a lab in early 80s
and it was this lab that decided that we
should actually find a way to program
these switches a better way than Plex so
this was when yo robot reading and mike
williams set out to make something like
plex only better and to run on ordinary
hardware so no micro processor designed
only for doing this so they had to make
a programming language that could handle
all the hard parts of getting a system
that runs forever so it had to be always
up and running and for that you had to
be able to also upgrade the code on the
fly this you could do already with Plex
but you had people flying around all the
world and updating the system by hand
and it should be able to run forever not
only running every day of every week and
so on but it should run for decades so
it has to be able to grow it should be
distributed handing large data set
highly concurrent and soft real-time
so this of course led to airline and
this is probably the most important
slide in the presentation if you want to
build a system that you can run for
decades that can run forever you have to
be able to understand and upgrade that
system and other people's and or
regional writers has to understand an
upgraded system so having a language
where you can express the design of the
system in a natural way it's needed and
this is very related to how you think so
I first realized the impact of language
on thinking when I as a young Swede
17-year old been to the state as an
exchange student so when I was a kid we
started learning English in school in
third grade so I could speak and
understand English quite well didn't
have the full of vocabulary and I still
haven't really learn the pronunciation
as you can hear but I could at least
understand the language and I could
quickly enough translate in my head back
and forth between English and Swedish
but after about two BAM I stopped
translating and started thinking in
English instead and after about a week I
realized I become stupid
suddenly there was a lot of thoughts I
couldn't think anymore I just didn't
have the words so that was a scary
experience so I started thinking in
English and I could interact with people
much more easily but I couldn't express
myself and couldn't even think their
thoughts I wanted to think so that was
mostly because of my lack of
understanding and vocabulary in the
language but there's also subtle
differences between Swedish and
in how you express yourself for example
computer in Swedish is dot or which
gives you a more static view of the
thing it's more like data storage than
actually computing things anyway
that was how I realized that languages
were important also for programming and
Alain had to be fault-tolerant
maintainable and scalable which led to
the right concurrency model and a good
way to handle exceptions exceptional
exception handling I would say and also
good libraries for the hard stuff and
you get an interactive shell that you
can work with the system to maintain it
and I'll talk a little bit about some of
these things but thinking in Erlang so
the most obvious thing is of course the
processes with no shared state this
makes it very natural to model many
things and especially things that
interact with things like networks users
and so on so that's the obvious thing
but there are some other aspects that
airline helps you do so one is to be
explicit there's quite a few ways as in
not so many to do every one thing in
airline it's not like C C++ where you
can add one to a variable in all kinds
of ways there is no destructive update
so things do not happen in the
background and there's no undefined
behavior like this C thing I I
plus plus plus one you don't really know
what that will do that depends on the
compiler well actually our line has no
formal language specification at all so
everything is undefined but apart from
that everything is defined by the
implementation because there's really
only one implementation and of course
the order of evaluating arguments is
defined to be undefined and that
sometimes trip people up because there
are a few cases when they are not
evaluated in the order you think and
there's the best part is there is no
easy way to redefine the language well
there's parse transform but you just
don't use them there's other languages
where you can define plus equal to mean
insert into a database for example and
that's of course very handy or you can
do this thing that finds something in
the graph who knows what but apparently
that operator in there find things in a
graph
very nice graph library for C I think or
C++ that you can use if you really want
to have hard code to read so some things
a line is very explicit about but you
can also be implicit about the things
that you don't care about like garbage
correct in collection and error States
and you can take this hole that it
crashed philosophy so if you're reading
a file that's a configuration file
that's supposed to be there
you wouldn't check for if it's there or
not if it's not there you crash and
someone else has to handle this because
it's supposed to be there or you can
have a supervisor that restarts you if
it's a file that's on a
disputed network and it might be gone
for a short time but probably come back
when things have healed up but when you
want to read this file you don't really
care in the code whether it's there or
not it should be there if it's a file
that might be there or not then of
course you would check the return values
of your read functions and handle the
case where the file isn't there and do
something else so you can choose to be
implicit and don't bother your code with
error handling all over the place or you
can be explicit about it so that's very
nice so the beam is a garbage collecting
reduction counting non-preemptive
directly threaded register virtual
machine and I'm not going to tell you
what that is sorry but it is trying to
be fault tolerant so to be fault
tolerant you have to be able to actually
have more than one machine that in your
system which leads to concurrency so
processes can spawn functions some
messages receive messages and wait for
messages and then there's a scheduler
that choose which process that will Rob
Allen processes are like operating
system processes really separated and
isolated but a very lightweight and in
the implementation it's basically just
four memory areas and a pointer so
there's a stack for function calls the
heap for storing data a mailbox for
incoming messages and a process control
block with information about the process
and how it should behave and then
there's a pointer to it a process
identifier
it this is not really true so you can go
to the bean book if you want to know
exactly how it works
message passing is implemented by the
process trying to send a message to
another process trying to get a look on
that process mailbox copying over the
message you want to send to the other
process heap and then inserting the
pointer to that new copy to the other
process mailbox so that's a sort of
simple case and that's not really how it
works either so you have to read the
book the scheduler works by having a
number of queues a ready queue where it
picks the next process that's ready to
run and then it will call the beam
emulator to run that process for a
number of reductions that is function
calls and when it has used up its number
of reductions it's put back at the end
of the ready queue if it comes to
receive it will ask and there's no
message for it to pick out in the
receive it will just wait for go to a
waiting State and end up in another
queue in the scheduler and there's
usually one scheduler per process core
or process processor piped friend an i
thing with Erlang exceptions also and
the whole memory handling thing is that
when you spawn a new process there is an
explicit try-catch that you start with
so if that process died and you haven't
provided any try/catch it will be caught
by that implicit try catch and then a
signal will be sent to its supervisor or
anyone that's money returned the process
so that way you can detect that a
process dies and the supervisor is
provided by the
libraries that come with airline and
supervisors are just processes that
start other processes and can decide
what happens when those processes dies
so if process die it can choose to
restart it or it can kill all its
siblings and restart them or it can kill
itself and so on
there's also generic servers which an
easy way to write servers that interact
with other processes something that
makes our line maintainable is the
interactive shells you can always log in
to airline and see exactly what's
happening and since it's telling is
symbolic and also everything is tagged
you can actually look at anything in the
memory and just understand what that
thing in the memory is and it supports
code upgrade so you can load new code
into the system and that code will be
called the next time you do a qualified
call and it has very powerful tracing
and debugging built into the virtual
machine so it's quite easy to trace in
the bag even on live running systems you
can go in and do very cheap tracing and
debugging some things that make a long
scalable or of course very like
processes and the distribution that's of
course necessary that you can run your
airline system on several machines but I
would also say that the weird strings
are very good in airline so the string
in a Lang is just a list as you heard in
a previous talk here like in the keynote
having us strings as lists so this is
very nice for the programmer but of
course you say that this is terrible
because if you look at the space that
you use so this is on a 32-bit machine
so for that
five letter word hello you would
actually use eleven words and this is on
a 32-bit machine on a 64-bit machine
those eleven words would of course be
64-bit so you use quite a few bits for
just a short string but those are not
really the strings of airline the
strings of airline are the i/o lists and
I lists are not lists
they are trees and the leaves in these
trees there are actually just consoles
and in the leaves you can either have an
integer or a binary so if you choose to
have binaries you can choose to use just
plain 8-bit ASCII encoding and then your
strings will be just a space efficient
as in C more or less there's a little
bit of overhead of course but almost as
space-efficient but you can do
concatenation in order one time so you
just create a new console with one whole
string and another whole string and and
suddenly you have a new string with both
of them you don't have to traverse any
of the strings so even if they are like
two books you can concatenate them in
order one time and without taking up any
more memory than just two more words on
the heap of course you can also have
Unicode support without having an
encoding like utf-8 or 16 you can just
put the plain Unicode there because the
leaves are integers so they you have 64
bits basically for your integers so you
can have quite a few different
characters in your character set so most
people take your time before they
understand that this these are the a
line strings not just the list of bytes
that you're used to
another cool feature of airline is the
bit same text so if you for some reason
work with 256 bit words you can easily
pick out the start of the word and the
end of the word and then you don't care
about it it's in the middle from a 256
bit word and then you put them together
again the start the end and your new
bite somewhere in the middle and this
way you can build a new 256 bit word
with one of the bytes updated or you can
actually write a parser for the beam
format with by using the bit syntax and
you can just match on the four
characters that make up the header of a
beam module file that that recognize
that and then you get the size of the
whole file and then it should say beam
and then you have some shanks at the end
and then you can parse these chunks
figuring out the size of the next chunk
and picking out that chunk and then
recursing over the rest of the thing so
with a bit syntax it's really easy to
write parsers for binary five formats or
for network protocols like TCP or
anything like that
so the beam is well-suited as a target
for languages so there are many
languages implemented on the beam and
the beam is constantly evolving and it's
being documented right now so there's
actually a number of languages
implemented on the beam Alex here is
probably the most now nowadays and lf-ii
is also quite popular
we had happy hacking are actually right
now implementing the etherium virtual
machine and going to design a new
language for writing smart contracts in
the future running on the beam pipe has
been around - compiled to native code
for a long time but OTP is now actually
tracing implementation it's supposed to
say they're coming from the OTP team and
if you want to help with the beam book
not money it's free but writing
something there's still a couple of
chapters to be written so please go to
the beam book so what I wanted to say
was that the language affects how you
think and when you think right you write
right and well written code is readable
code has to be readable to be
maintainable and code has to be
maintainable if you want to run a system
forever
so that was my talk if you have any
questions on the beam I have another
presentation here that I can help answer
any questions on the details of the beam
questions okay thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>