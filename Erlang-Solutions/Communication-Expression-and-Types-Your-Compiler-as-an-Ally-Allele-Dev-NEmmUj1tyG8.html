<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Communication, Expression, and Types: Your Compiler as an Ally - Allele Dev | Coder Coacher - Coaching Coders</title><meta content="Communication, Expression, and Types: Your Compiler as an Ally - Allele Dev - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Communication, Expression, and Types: Your Compiler as an Ally - Allele Dev</b></h2><h5 class="post__date">2015-11-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NEmmUj1tyG8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright thank you all for coming on long
today to listen to me talk about things
and possibly interesting and amusing and
entertaining things what I want to talk
about today is the intersection of
communication expression and types and
how you go about making friends with
your compiler because that isn't always
obvious so some links these slides will
be distributed later you can get to my
patreon with which you can get to the
book and then if you're interested help
me make it happen so kind of rough
overview and we're going to touch on a
little bit of communication theory we're
going to get into the basics of type
systems and there's going to be lots of
live coding with all of its spectacular
risks and I'm going to open up right
away with the key takeaways and things
to kind of keep in mind while I go
through this communication is very
important let's learn how to wield it to
its maximum potential types our means to
communicate and express concepts the
compiler is our friend but how do we
befriended and finally abstraction
removes noise but only if we overcome
the jargon so here comes the
communication theory a few definitions
several a message is a packet of
information you exchange there's a
sender and a receiver there's a good
encoding which is how the message is
expressed the decoding which becomes the
interpretation of that message the
signal which is how well-preserved the
meaning of the messages as it makes it
across noise anything that interferes
with that message feedback what the
receiver tells the sender and then of
course context which is a set of
experiences the environment and so forth
all of these kind of concepts come in
handy when we start talking about let's
say you as the developer are the sender
of messages to a compiler who is
receiving it and then giving you
feedback on what your program is all
doing and also the communication that
happens between the code that you've
written and other people that you
collaborate with so let's talk about
types
a type is a property a sort of assertion
on a value and there are means to give
meaning to a program so that a that both
humans and compilers can understand a
type system in turn is a program that
understands types and is able to solve
the constraints and figure out whether
the whole program is consistent or not
with itself if you're communicating with
humans the types of themselves give
meanings the program you're trying to
communicate that something is a person
or this piece of texts represents an
email and so forth they're checked
reminders that help keep us on track and
help us agree on the meaning of the
thing that we're writing and it takes
practice to use effectively it's just
like any other form of communication you
can't expect the first time that you
start using a type system to really put
together all the ideas and be able to
elegantly express the structures of your
program that's just like with writing a
novel it's national novel writing month
right now it takes a lot of practice to
do it well oh yes and express it type
systems there's different types of type
systems even on that contain types all
up and these more expressive type system
lets you encode nicer ideas more with
less noise essentially you get straight
to the point of what you're trying to
say let's talk about compilers this was
roughly my first experience working with
a strongly typed language there were
errors everywhere there was warnings
everywhere I did not know what to do but
that got better I mean it was kind of
like a compiler you know hey does this
make sense no how about now um few
changes now still now you know maybe a
little bit of unsafe perform I oh and
defined be nice please give me some
slack here thanks matt is like sure
let's go with that one on so yeah it
does take a little bit of finishing and
tweaking and experimenting and there's a
certain art to it but eventually you can
get along with compilers and you can
become friendly I'll get into that soon
modern compilers are nice they can
figure out what types we need without us
telling them all that much they can
types themselves can determine data
storage as well as how the data fits
together conceptually or how it
shouldn't fit together that's a very
interesting point okay so with that
let's start doing some actual coding
crystal crease my font size everything
is dark I can fix that
so how many of you all have used Haskell
before I've heard of it fantastic then
you all have seen some of this before so
this is G HCI it's the Haskell grapple
and we can type in some expressions one
plus one is two we can ask for the type
maybe I should go in on full screen a
little bit of manual tweaking here
no scoot a little bit yay we got it okay
so we can ask for the type of
expressions and this tells us it's some
type of number vista this is a type
signature here we get constraints to the
left of the equals greater than which
means that this particular interface
called num is implicated implemented for
some type a and a itself is a number
kind of thing and that's what we've got
here we can take a look at the type for
operators like + + + itself takes three
things or takes two things that are a
number and eventually returns a number
show some pretty cool stuff we can put
together strings with concatenation just
a little bit different than the +
operator here but what happens if we try
to add a string and a number that's
that's one of the first type errors i
ran into and it's telling us a whole lot
so it takes a bit to parse this the
first go-around but it's telling us that
there's no instance for the num
interface it's telling us that this
string doesn't implements the number
interface which is required by the +
operator and then you get a whole bunch
of provenance like where did the error
originated from and so forth and we get
a line number in a column number which
isn't so exciting for a rebel session
but it's fantastic when you've got
several thousand line files language
writers please provide columns and line
numbers for your errors for all your
errors it makes life so much easier okay
so then let's talk a little bit more
about types and now we're going to go
back to a dark font
okay so we've got something called a
some type here datacolor let's say I
could take the form red green or blue
and with a little annotation down here
we can print it out so some types of
fantastic they let you very clearly say
that this is these are all the possible
shapes that this data can take we can
add more shapes over time great for
refactoring let's define a simple
function going from color to color
and we can say red goes to Green Green
goes to blue and we'll leave off the
other two branches and see what happens
so very interesting thing about modern
compilers is they can tell you exactly
what you forgot to match and this is
great like if you're let's say the set
function was defined some in some other
module and we hadn't thought about in a
long time because it's been working but
we had business season said hey we
really want to support the color purple
now and the color blue we didn't support
those before the compiler will tell you
you forgot to match these cases
elsewhere this is called exhaustive ed
analysis and it's very very nice
property of languages to support some
types let's talk about product types so
we might say a person is such that they
have a string a string and an int that's
not all that great not that terribly
descriptive you might say that uh then
you can like make a person by passing
along a string a string and an int and
then you get back a person give some
names to these things like person's name
person's email person's age
and that all type checks this is a
product type it's called as such because
the possibilities are multiplied and
string is inhabited by some infinite
number of possibilities and so is
strengthened in integer as well may as
be but if we had something like switch
and say it's a switch with to bully ins
then this switch can take exactly four
possibilities that's why they're called
some product types here for color the
possibilities add up we have one red to
green three blue for purple sums and
products now we can talk about
polymorphism
so this map type signature is saying we
have a function that goes from A to B
takes a list of bays and out we come
with a list of bees it's polymorphic
over all A's and B's it places no
requirements on the type so you could
pass in a function that converts
integers into doubles strings in two
colors and what have you and this map
function would be able to process it and
I can just be terribly lazy and say the
implementation is the standard library
map so that's kind of the core of some
basic type theory and it's about the
extent that I'll be using for the rest
of this talk so now let's create a new
file and call it person and we're going
to take this person type what we had
earlier and we're going to play with it
a little bit so we already saw that this
kind of string string int isn't very
useful it's not very descriptive it
doesn't express a lot there's a lot of
noise here there's a lot of ambiguity we
could do much better in terms of what
we're communicating so I'm going to go
ahead and define some new types so we
can say that a person takes a knee a
name and a name is self is a string we
can say that we also have emails and
their strings and finally we have age
and age itself is a string now what this
does for us aside from giving names to
concepts that were more familiar with
we're encoding our domain the compiler
will protect us we can no longer mix up
integers with ages we can no longer
accidentally pass in the name where the
email is expected in vice versa so it's
a very powerful little technique so
let's actually give that a try we've got
our person come available now and we can
say that
they take a name cats they have an email
Cat Cat com we love cats at an age of
two thousand or 20,000 look at that and
that type checks okay now what happens
if we swap the order of email and name
everything turned red errors what's the
compiler telling us we couldn't match
the expected type name with the actual
type email so there the compiler is
already helping us out and if we did a
thing where we didn't even try to lift
these things into our fancy custom types
we just tried to pass along the strings
let's say we kind of fell into the habit
of the old API that is also flagged
expected name type with actual type list
of char our string so this is kind of
the heart of our being able to use types
to lift our discussions into a higher
level of abstraction and also protect us
let's add a little bit more to this
person meanwhile restoring things to
their rightful place now we want because
of a customer request this person has to
have a favorite color and they said it's
okay if we just have green red and blue
as kind of a starting point and we can
just add that in and now we can save
what happens
so f here is a car now becomes a
function that expects a color because we
didn't provide it so it kind of ends up
being a cute thing I would have expected
a typeerror to be honest lights there I
bound it and now we've got a fully
constructed person f has no type
signature but it's just a constant
person so it's kind of the process of
refactoring the more you encode the more
the compiler can help you out that's
kind of our one-way path with the
compiler and something I haven't touched
on yet is notice that I've created a
very interactive flow that's one of the
most crucial parts for befriending a
compiler you should be taking advantage
of editor support for connecting with
your type functional language and having
it kind of indicate where the errors are
there will be colors colors create that
contrast that you see where things have
gone wrong and it happens very very very
quickly these type check cycles are
often in the order of 100 milliseconds
or less and that's even for larger
programs so now let's try another
example
so let's say now we're building on an
application that needs to take customer
payments and our very first pass is we
take credit cards that themselves have
two strings attached let's see
immediately do the refactoring to
address as string and then CC number is
also string so a credit card has an
address and CC number associated with it
and we might have some process function
that takes that accounts and because I
don't want to deal with the effects
right now it generates a string
and we'll just say that the credit cards
been processed if yay money comes along
is the output for this so the business
grows a little bit and we find out that
there's some customers that don't have
credit cards and they need to mail in a
check so that comes from some address
and we'll say that's the only field now
we come back to our process function we
get our exhaust Abidi analysis warning
we come along fill it in and say that's
going to take a while
and then we have pay vendor who now has
some particular or CC number and let's
say some ID that's an integer
and we filled in our process and
everything is fine in the world and
after a while of working with the mail
check kind of we find that this isn't
really working for us it's too expensive
to support for whatever reason we come
back to our type our data model we
delete it and we let the compiler tell
us you're trying to process something
somewhere else that no longer exists so
we come back and it's just as easy as
removing a line so there's a lot of
opportunity for refactoring things by
pushing your assumptions on to the
compiler and now we're going to go to
one last live coding example now we're
going to call it abstraction very
general idea and I'm about to throw a
lot of abstract words at you I apologize
in advance but I will explain myself
there's notions of things like functors
applicative monads and alternatives and
these are abstractions that work too
they are jargon they are barrier
especially for newcomers into these into
the realms of programming in a
functional style and that does create a
barrier for kind of figuring out what
these programs are doing and how to work
with these abstractions and they
themselves have a mathematical
background with certain laws and
conventions are associated with them as
to how they're used in programming
something that I found very interesting
for talking about these concepts from a
practical point of view is to think of
them as computational context they
themselves encode what kind of rules
happen when you start applying arguments
and that's really all that they're doing
and I'm going to demonstrate this now by
implementing a an analog to optionality
that maybe type ensuring how each of the
pieces fits together so we might have
some control type called mabes a and
there's def a value are there's not it's
not there
the functor and instant instance from
Abe's has a single function you have to
implement called F map it takes a
function takes a value and then does the
thing let's expand it up so if we have a
thing it's ok to apply the function we
unwrap it and then we have def f of X
we've applied that function and
transform the underlying argument and
then when there's nothing there there's
nothing to apply to and that's all that
amounts to we're not going to see it in
action just yet a little bit more
machinery applicative is a little bit
stronger than functor where functor lets
us take lift something into this
computational context applicative lets
us carry out computations and applying
actual arguments towards success so if
we have some regular old pure value X
and integer string a boolean and we want
to lift it into a maybs computational
context then we just say def of X
there's definitely something there
that's our rule and now here's our fancy
apply type and it has exactly four cases
to consider expand a few things out
and I'm going to line things up a little
bit to make it somewhat more readable
and get that pesky type error out of the
way
okay so if our last computation
succeeded we definitely have an F a
function f and our current value is
definitely there then we can just say
the next step is definitely f of X if
the right-hand side failed we have
nothing if the left-hand side failed we
have nothing and if both of them fail we
still have nothing so applicative talks
about how you only have success if every
single one of your computational path
succeeds it's a very nifty way to avoid
having entire streams of if-else or
conditional guards in your program and
then we have our monad monad has a
return which we can just say is pure
it's the same concept you're lifting it
into the computational context and then
you have some value X and a function f
and there's two possibilities here the
function itself takes a pure value in
output say something in our
computational context so then all we
have to do here is f of X and if we have
nothing then we get nothing and the last
one I'm going to show which I'm actually
going to need to import a module for
that control duplicative is something
called alternative and this is
absolutely beautiful when you're writing
parsers so this has two methods one is
called empty and we say what's our
failure looked like it looks like
nothing and now this is the alternating
operator which I like to pronounce
applied alternative or kind of thing and
let's see here there's four cases to
consider expanding them out again
so if we have two successes we want to
take the first one if the first half
succeeds we take the first path if the
second pass succeeds we take that and
the only time we end up with a failure
is when everything fails alternative is
all about finding the path to success
come try us that to applicative which is
given all the computations you only
succeed if everything succeeds
so with that I have kind of covered one
at one layer of abstraction there's a
lot of common abstractions out there
lots of interesting ways that you can
put together your programs and they help
you raise the level of discourse from
the bear primitives that a language like
that a language gives you into something
that follows certain laws at properties
that make it much easier to write
elegant succinct programs we do need to
get past the jargon and that's a
difficult part and that takes a lot of
human to human communication tutoring
mentoring kind of showing how these
things work in practice and pulling it
away from this abstract realm of oh
these are symbols and there's a symbol
soup and maybe it does a thing showing
things in practice is very helpful in
this regard so with that that wraps up
my live coding and let's talk about
compilers so this is sort of advice that
I applied to myself and also give to
others who are working on languages but
you need to include context with your
error messages and I don't want to say
more is better it's carefully selected
content is the context is very important
like line column numbers files a
succinct description of the error the
too much context can be intimidating I
have run into compiler errors while
working on programs that were easily
hundreds or thousands of lines I once
worked in C++ that was scary so the
provenance of an error is similarly
useful where did it come from but too
much of that without some kind of
coloring or contrast can make it very
difficult to parse the ordering of the
provenance is important as well as the
color contrast they're wonderful aids
like for example you can provide the
most relevant part of the error first
you shouldn't be putting together your
numbers with strings that's a bad idea
and it happened here and it happened
here and so forth and as you saw in my
kind of editing experience when I did
something wrong like put an email where
name was
affected the fields turned red I
immediately had some kind of visual aid
to tell me where to look inside of my
app editing buffer that's very important
for your interactivity so with that that
kind of brings my talk to a close key
takeaways again communication is
important types themselves our means to
communicate the compiler is our friend
and it takes work to befriended and
finally abstraction removes noise but we
have to overcome the jargon that's kind
of presence there it becomes an in
language of sorts okay so thank you all
very much you're all great go write some
amazing programs
yes let's take some questions I just
thought that was a great talk I'm
wondering is it is it possible to
promote those warnings to be errors you
know if you've got a some type and you
haven't covered everything you might
actually want to just stop compilation
at that point rather than being a bit of
an ambiguous state there so yes there is
a way to promote warnings to errors
there's a flag in the compiler you can
just say like W error which turns the
warnings into errors I imagine several
languages adapt a similar approach
thank you for your talk was that emacs
that was Emacs that was Emacs combined
with GHC mod it has to be the latest
release along with latest release of a
sub library to get everything working
right now and it works both for
individual files as well as projects it
can kind of infer it pulls in module
information for anything that's a part
of that project it's very nifty system
as long as it continues to work I was
fortunate its interactive Haskell or it
was yeah ghz mod with has with emacs and
that was it I'd love to see your setup
thanks in terms of letting the type
system help you out how do you then fit
in things like covariance and
contravariance especially if you're sort
of trying to build new types from
existing primitives so the question is
about contravariance and covariance and
how to deal with that and to be honest
I'm not entirely sure I haven't run into
too much of that but i have seen
abstractions that do kind of work and
work with that some things like pro
functor and by functor which are
elevated a little bit beyond these and
those capture notions of covariance and
contravariance in their particular
methods
so you talked about um building up this
conceptual model of our world and and
how Haskell can help us and code that
and and we can talk to the compiler and
it can help us out could you speak to
the aspect of then sharing that model
with non-technical people maybe it's the
client that we're doing stuff for or
some client services team in our company
the communication that get that goes
that way or other than just down to the
computer yes I can speak to that and
it's honestly it's something that I
haven't done too much of yet but the
basic premises you listen to your
clients you listen to your customers and
you start figuring out what's the domain
what things continue to occur some of
those things will be singleton fields
like emails or IDs and you get them from
the customer and then you start as you
start seeing those come up repeatedly
you raise them into a new type you no
longer start referring it to it in its
data representation on level but you
lift it to the domain of the customers
explanation and then when you start
talking about your program and where it
went wrong you can tell your customer Oh
email fields weren't parsed correctly
and you can point them even to the
program if that's the nature of your
customer interaction relationship some
types you capture all the possibilities
those shapes that things can take so you
start having a customer numerate these
are the cases I want to support right
now and you can show them here it is so
if there's some interesting
possibilities for expressivity but it
does still you still have to be aware of
the potential technical barriers and
watch for jargon because those will be
barriers to communication
so in object-oriented code often one
code smell is to have like this gigantic
here are keys of whatnot that includes
that is a subclass of what not just to
add one one one item at a time have you
seen things go wrong as well using JC
and haskell could you repeat the last
part of your question of you seen have
you experienced cases where you run into
a type system it is where you try to
have too many granular types just to add
let's say an address just to add an edge
and so on because you could compose
everything piecewise I'm not sure I've
run into something too terrible and I
guess part of it is you start figuring
out what things can be enumerated like
you don't want to have a subtype branch
for every one of the integers that
wouldn't work out and then you start you
kind of start breaking maybe some of
your inputs into equivalence classes
like you say these first 5000 values
they map into this one branch of this
some type and that you you take
strategies to reduce the problem so you
I guess try to work with only what's
relevant to your domain does that work
just answer okay
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>