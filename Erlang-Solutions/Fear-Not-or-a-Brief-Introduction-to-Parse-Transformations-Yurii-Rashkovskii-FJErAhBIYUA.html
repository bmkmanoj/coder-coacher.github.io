<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Fear Not, or a Brief Introduction to Parse Transformations: Yurii Rashkovskii | Coder Coacher - Coaching Coders</title><meta content="Fear Not, or a Brief Introduction to Parse Transformations: Yurii Rashkovskii - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Fear Not, or a Brief Introduction to Parse Transformations: Yurii Rashkovskii</b></h2><h5 class="post__date">2012-06-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FJErAhBIYUA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">already up can you hear me ok so this is
going to be fairly short as soon so
you'll get a little bit of extra time
for coffee and stuff or maybe right in
any of powers transformation I don't
know anyway let's start with it so the
idea behind parts transformations is
that the goal of parts transformations
is completely opposite two goals of
plastic surgery so it makes nice code
look ugly or just leave it uglier than
it was initially why would you eat that
so the idea is that you don't want to
write that code you don't want to see
that code and yet you need it how do we
do that what is the example why do we
actually need to care about some parts
of our code in that way let me show you
something probably a lot of you have
seen situations like this so for example
we're dealing sequentially with some
sort of list let's say that specific
list and we ran some up map function on
it and we've got a one and then we need
to do something else on it so we take a
one and get 02 great looks great when
you have 20 of those operations you'll
get l 20 out of 21 and when you'll you
try changing them it's getting really
really really funny the other example is
actually fairly common in Cowboys API
every function call that works with a
request weather is a a mutating or non
mutating function it always returns a
possibly updated request object and
certainly can deal with it the very same
weight wreck you wanna break you too and
when you have 50 lines of code well you
have a lot of requests objects to handle
that's not right
so instead of that how about we write
our code this way we say that we have
kind of special variables we will just
have an ad sign as a subject for that
variable and see what we have we have
the very same variable following through
the code so it's out everywhere just out
and everywhere just rip so it looks like
we are actually breaking the single
assignment role in this example how do
we do that in your line good question
well we have a parts transformation that
actually changes it from this to this as
we can see it has 0 1 to 1 102 so it
actually number eights it for you so
something that you do yourself usually
it just does it for you well if you
think about it computers are better at
in the meridian stuff than we are and
they're fascinated as well all right so
how do we actually do this so the
example is clear what we get but how do
we get there there is an answer
basically is some sort of made a program
in a parse transformation on its own is
basically just a rolling module that
takes another module and we write it so
the the module that are gets into your
parts transformation is represented in
abstract format and what abstract form
it is is just a list of two tuples as
you can see on the right side hopefully
you can see where every topple
represents some part of the parse tree
so it takes that and the quota and
process it a process according to a
specification and produces something let
me show you something so here is a
function just an arbitrary function that
actually is completely pointless but the
point here is to show how it looks like
when it's parsed so let's just member
it's called my fon it has a narrative to
some weird arguments and it just prints
them out essentially so this is how look
like a little bit verbose right but
actually for the train I it's not too
bad if you look further here's the
definition of your function so it's my
phone with a narrative to let's go
further well here's our tuple of an 8am
command and the variable X here is a
variable art so just like in the example
we had command X args we have them right
here what do we the next we do a call to
io format with that string that we saw
there and this our list basically uh the
cons so you can see as ours and an empty
list which effectively is just X and
arcs and it's fully reconstruct abell
with one of the early modules that chips
with with airline called lpp so you can
actually get the very same source code
with minor differences such as spaces
and and obviously you won't get your
comments back but you can actually get
your coat back from that parse tree just
like I did with this example so in a
bigger picture the general workflow how
parts transformation works is is it gets
the whole parts transformation trade oh
I'm sure the whole part stream and then
it's basically traverses the whole tree
going down through every element and
seeing well does it match to what we
actually are looking for if it does
rewrite it so let me show your another
completely pointless example the example
here is that we want to rewrite all the
occurrences to some magic function to
calls to some module not so Magic
function so this is how you do it the
normal way so you find
a function you proceed on processing the
first Clause you get down to the body of
the function which is the actual code in
the function and then you go through
every expression and see whether that
expression is an actual call to that
magic function and let's assume we
didn't find it there or date doesn't
matter then we appreciate with the
second Clause go down again and again
and again again we're just traversing
the whole thing and we're repeating that
again for another close so it looks a
little bit unimpressive it really makes
it hard and nobody really really really
really wants to write that well there
are actually some solutions they do help
all figure actually wrote a tool called
par strands and you can find it on
github under ES cells account and I
believe old sitcom as well so what it
essentially does it does that maintain
traversing for you so that means you can
get to pretty much any level of your
code really really fast it also allows
you to inject new forms either before or
after elements that you're replacing or
just keep it as is and it comes with few
interesting examples and extensions on
its own so you don't need any of that
any of those things for our simple
pointless example you just do that so
here you're just matching on an
application and an application
considered a call basically so you see a
four of a call happening on the line l0
and the the atomic name of that function
is magic function and we have some
arguments we don't even care about their
arity we're just looking for any call to
magic function and what we do here we
effectively say well the settlement has
to be replaced with a call to some
module and not so Magic function and
we're saying well continue on here is
it's a recursion continue on go deeper
investigate what what is there
and it will do the job so effectively
your whole code for doing that specific
transformation that we have been
discussing is just those three lines of
code pretty impressive and other things
that that shapes as a very very good
example of using partial transformations
is experts so what experts say is how
many of you deal with records here good
how many of you know how frustrating the
fact of having record info working only
compile time you can't really do
anything ranter good because experts
actually what it does it goes through
your module understands all your
definitions for your records and
basically generate some code for you so
that it can retrieve the name of the
list of the record of field names you
can also use some helper functions do to
create new records so you don't need to
know compile time what exactly you're
creating there and change some of their
values so it's actually pretty impressed
and you don't do anything on top of it
you just include that part's
transformation so all the magic is
actually behind the curtains I love it
actually for some use cases it's
fantastic tool let's go further on here
is an interesting realization so
apparently the source code that you
write and they then pass to your parts
transformation doesn't actually have to
be compatible as is all it has to be it
has to be possible if it parses
correctly then it will go to your parts
transformation what would that give to
us you might ask all right let me show
you so this is a typical example of a
very simple erling module right and we
all know how frustrating could it be
sometimes to jump up and down to the
signatures of your functions or remove
some functions add some functions
their names especially if your module is
say two thousand lines of code you just
have to jump up and down or keep two
buffers open next to each other that's
not really efficient so how about we do
something like this we can actually do
things that are completely unknown in
our line so we say well here's a
function that has an argument of a
function head and then there is an
implementation and even a guard so what
this does with of the parts
transformation called exporting it
converts it exactly to this code and
obviously if you'll try to talk about
that you will never have anything
compiled so how does that work luckily
the the tool is really really simple so
I can actually show you in detail pretty
much step-by-step how is that
accomplished so let's start with the
state that it uses during the departs
transformation so besides the options
feel which is not important in our
situation what it has the most important
things are these exports filled which
collects the functions that you want to
export and it also has an export keyword
that you want to use the reason for that
is this so here we have it if you
actually want to change it for any kind
of aesthetic reason for example you want
to rename it to export this and don't
type in it in your characters like at so
you can actually do that and you'll see
how they're beautifully so this is the
entry point of the parts transformation
so what it gets it gets all those forms
of this is the first argument and some
compiler options as the second argument
so what we do here we actually use parts
chance to go through our transformation
call back I'll do transport and that's
the most interesting part of what
going to happen there so let's start
with the redefinition of that export at
syntax so all you have to do you have to
define an attribute called x 40 and put
any ATM you want and use it are from
phone from their own and the whole
implementation of days is just these two
lines of code so what it does it detects
that the reason a trip the tribute told
exporting and it has a certain value
that we call custom and basically it
keeps this form as is and all it does is
just changes its own state so we just
know what what what exporting do we want
to use in our module this is a more
interesting thing so here what do we do
whenever we detect any kind of function
any kind of function we go into a deeper
transformation lower layer will call it
export transform and it's a the very
same kind of function as to transform we
just go deeper into the recursion with
this function and the whole
implementation of this function is just
these three closes let me explain you
what they do so for every function
obviously as we have discussed this
before we see the closets for those
functions and every clothes has a head
which is H here ballistic guards G and
the body d but what we actually do we
just go and transform only the head with
our own explored transform rule what
this means is that when the erling
source file gets part with with the
example like this export this my fon it
actually doesn't know exactly that it's
a head of a function so it thinks is
just an application of another function
over there and that's what we match on
we say well if there's an application
of a function called any name basically
with any number of arguments but within
this scope then we return the
functioning and the area of that
function in our state and there is a
default case that does nothing so after
this there is a default case in to
transform that again does nothing it
just keeps dakotas is so what this means
is that when we have this function the
export this my fon it reports the fact
that my font is an exportable function
and if you look into into the result
that these claws returns it returns only
RX why is that this the arse is our
function in vacation or something that
early parts are believed to be a
function invocation so it leaves an
actual function definition over there
and that's kind of great what are other
uses for parts transformations so one of
the users is compiled time analysis and
extractions so for example when you
can't really analyze your module runtime
for example for some performance reasons
or you don't ship your coat with debug
info included so that you don't really
have any parts to treat available at all
you can just do your analysis and
abstraction of some important
information just compile time and forget
about it code instrumentation there is
an interesting tool called annotations I
person haven't deals it but it looks
interesting for some users when you want
to do some level of indirection your
code and obviously for building
domain-specific languages on top of
Ireland with early-ish syntax but with a
little bit of different semantics that
turns out to be an earl encode later on
and last thing do not abuse this
technique ever ever ever ever you will
certainly regret this thank you any
questions
what limitations are there in terms of
doing the syntactic parsing before it
reaches the parts transformation stage
like you can't just put arbitrary
punctuation and symbols anywhere you
want no no it still kind of asking the
sort of valid but there are just some
flexibilities in what you get so that
you can do tricks like that so it well
in my experience oh well obviously there
are there is a source code for the
parser but Magnus it was just try an
error what can I do with it so can I do
that ok that's kind of cool if not well
proceed with something else I guess my
rule of thumb like I can't really give a
good example of top of my head but the
the rule of thumb would be is if you use
parse transformations deliberately in
your own code so you write your own
parts transformations for more than
super sense of your cold or something
like that then you have to be just
careful it doesn't necessarily mean
you're already in the red zone but it
really has to be and basically you have
to have a really really good
justification so if you if you're
thinking is well it would be kind of
cool that probably shouldn't use that
guess it will lead to a code that
actually is something different later on
so you you effectively obscure the
connection with their between the actual
code and your source code so you must
have a good reason for that if you don't
well you're on your own I guess
any other questions I guess not that</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>