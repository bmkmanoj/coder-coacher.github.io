<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory 2014 -- Erlang + CZMQ: Scalable, Secure, Cross Language Messaging | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory 2014 -- Erlang + CZMQ: Scalable, Secure, Cross Language Messaging - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory 2014 -- Erlang + CZMQ: Scalable, Secure, Cross Language Messaging</b></h2><h5 class="post__date">2014-04-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/35I2McU-LVk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's nice legal a code so coding is fun
it's less people talk about code so this
is exciting I also know that this is the
last session before drinking so I'm
sensitive to that and I know that
everyone is kind of thinking about that
so if you're responsive and friendly to
me I'll just go right through very
quickly and it'll be great but if you're
sad and remorseful and and you're
irritating in any way I'm just going to
go slow and just so just it's an
incentive it's a fair incentive we all
want to drink so I'm gonna leverage that
okay so I'm going to be talking about
about this this binding but actually I'm
going to use it as a vehicle to talk
about some other things because it's
talk about a binding is kind of boring
so I'll get some big picture things in
here as well a really really impassioned
about zeromq in the same way that I'm
really passionate about airline cuz I
think that these things dovetail really
nicely so I'm going to kind of use this
as a vehicle to to talk about some
non-binding topics okay so what we're
talking about is an erlang binding for
czm q CZ mq is hard to say but what it
means is it the sea binding for 0 mq so
it's a binding of a binding zeromq is a
library will get into what that is but
it's written in C++ and peter hitchens
not a big fan of C++ fan of see a fan of
C API is wrote a really really clean and
elegant wrapper for 0 mq and i really
really like this wrapper so I wrapped it
with her leg so it's a wrapping of a
wrapping ok what is a 0 mq how many
people here have at least heard of 0 mq
this is good this is this has not always
been the case how many people have some
direct experience using it this is more
typically the case so much much fewer
hands went up there will change that
that's gay that's going to change over
time because this is really one of those
things that deserves to be used
hopefully we can inspire some people
today ok so let's talk a little bit
about what zeromq it started out as the
goal the goal of 0 mq started out to be
fast so we want to create something
that's super super fast and that's what
motivates most software programs today
right the faster the better anything
that slow is terrible things that are
faster great so the vision behind zeromq
originally wishes to go
as possible but over time it turned into
sort of realization that we've created
something that we've they have created
something that's really sort of a very
elegant messaging API very socket like
interface to messaging and sort of light
bulbs went on it so this is really
useful and started to take off and it
evolved today into a sort of an
ecosystem of language support that
exceeds 40 languages like 40 45 or so
it's probably quite a bit more than that
but if you just look at the support
languages that are documented there are
many that aren't it's a quite an
impressive list if there's any language
that you're using it isn't on this list
I'd love to know what it would be I've
highlighted some of the more common ones
that you would you would face but right
off the bat you look at this and what I
hope goes off in your head is that this
is a really embracing vision this is
this is a vision of messaging that
extends to everybody it's not just to
airline we enjoy a lot of amazing
advantages in Erlang but zeromq extends
this to basically everybody so everybody
can start to think and act and use
messaging according to this very simple
API I'm going to get into sort of the
implicate some of the implications of
that but this is a really really
important vision I think all right so
why is this thing matter just like in
Erlang using zeromq shifts your focus
from building applications that tend to
be monolithic sort of traditional main
functions Java C sharp C etc into
building systems of services and and
processes that relate that work together
and if you've written erling programs
you've written systems you actually
don't write traditional programs you
right processes that are wrapped up into
application facilities that are started
as a part of this VM initialization
scheme it's a system and a lot of people
don't appreciate that but that's
actually what you're doing when you
write airline programs we mentioned
language diversity this matters hugely
if you're limited in your audience you
tend to be niche airline is niche it's
very niche that if you paid any
attention to the the the
erlang list the mailing list you see
there's then this sort of split almost
within the community of people who think
that like it's important to be adopted
and used and people who don't care about
that well I'm one who cares about that I
want people to use things that are good
and language diversity is part of sort
of an embracing and extension of things
that are good that's why you know which
exists in the zeromq community so it
turns out messages are very very
valuable as recently demonstrated that's
the extra three billion and options at
the end there but we all know about the
the value of messages over the last week
or so but in seriousness apart from the
monetary rewards we know that message
passing and message passing
architectures are hugely valuable for
solving complex problems and it can be
very simple sort of non distributed to
distributor problems again if you've
used Erlang you know what this means in
the 0 m qs the same sort of dynamic
exists and we'll see what that looks
like alright so those are some very
high-level theoretical why it matters
points I just wanted like invert this
and talk about code because that
actually will hopefully solidify at
least some of some of the points that
will be that'll be talking about here
all right so here here's a problem it's
a very generic problem I need to build
something all right we've all been there
before we need to do something okay what
do we do I'm going to I'm going to
propose two options this is the most
common option modify an existing
application how many people here worked
with other programmers as a part of the
sort of their daily work almost
everybody okay so when you do that
you're in that type of environment when
you have to solve a problem you almost
always have to deal with some existing
code right what am I going to do it's
going to be this web app it's going to
be this web app or that web app
everything is a web app right so in your
environment it's probably a web app if
your traditional software environments
but it could be something else it's
going to exist though option number two
though as a contrast would be to add a
service I'm going to talk about that
this might not be an obvious dichotomy
the example will hopefully clarify this
so I want to talk about both of these
things so option number one modifying
existing application I having been
increasingly tending toward
leaving stuff alone like I don't like to
look at other people's code I don't like
to look at other existing applications I
like to just leave it there if it's
broken it stays broken if it's working
it stays working I just don't want to go
do something else modifying in this
existing application forces me to become
proficient with that application the
language the libraries the tools the
patterns the crazy thinking that went
into this and that and I just don't have
the tolerance over the years I've become
increasingly intolerant of existing
applications I don't like to change
things because I found that when you
change things it tends to make things
worse it's maybe at extreme statement
but certainly it introduces that risk so
I like to avoid it and this is the this
is this is probably my biggest beef with
sort of modifying existing code when you
take a good existing code base and you
continue to modify it over time and add
features you are contributing to an
ever-growing monolith that is
intractable interdependencies of code if
you program in Erlang early encourage
you not to do this if you program in
other languages they almost always
encourage you to do this it's anyone to
use Java or seen Java and seeing what
can happen Java is a language and an
ecosystem of tooling that really really
encourages it just big balls of twine to
evolve and become these huge monolithic
structures so I personally like like
services so what's a service so the
service is the define it quickly
something that is discreet and
standalone and provides some
well-defined functionality I will talk
about what discrete means in a little
bit but when you add a service you are
adding something new and you can just
create it in whatever language are
proficient in whatever tooling whatever
patterns whatever is in your brain you
say this is the problem I'm going to
solve it using blah and you can think
very clearly about it you don't have to
be influenced by some other existing
application code language framework you
can approach something cleanly using
your well-defined problem that you have
to solve you avoid changes to other
applications it's served in contrast to
the other option service is allowing you
to focus your solution when you have
something that's standalone you can be
standalone you can be
focused so I like services services are
great and a great services architecture
I don't like SOA I don't like that term
but we'll use it because it's very
common when you create well-defined
isolated standalone services you
contribute to an ecosystem optional one
an option to very high level but we're
going to use some code right now as as
an example so the problem that we're
going to solve here is this very
specific is a JSON formatting problem i
want to convert raw JSON into format a
JSON very simple it's an example right
but it's a service it's some sort of
functionality that we want to implement
now in my brain I look at this and I use
this I use is Python to do this all the
time you can do this in the command line
and I use it all the time you pipe some
some text into Python dash mne JSON tool
and it's like a little main it's like
treats from standard in and out put
stuff it's the easiest way to get
formatted ace on that I know of there
might be better ways but I don't care
what you think I just know it works so
in my brain it's not Ruby or Java or
some you know thing that navin spits out
or you're a docker image or whatever it
just puts Python it simple I'm gonna
ship this thing as a service I'm gonna
get an estimate all code here oh my
goodness so is this big inversion right
high-level strategy to code so just bear
with me here we're going to tie this all
together okay so i'm going to i'm
actually going to sort of methodical e
blow through code here now we're going
to shift from sort of why it's important
different strategies for solving
problems is it going to be changing
existing applications versus service
orientation and i'm going to dive into
some actual 0 and Q code we're going to
pop out of this and hopefully see see
what how the sort of relates serum
queues very code centric it's very low
level so this is what we're going to use
code as an example and this will give
you an idea of what zeromq is all about
in conjunction with this high-level
strategy all right let's take a look at
this blow for blow this is Python it's
easy to read this is a part of a module
I've taken some of that some pieces out
so we can look at the big picture this
is the big picture i'm going to start
with the bottom of all things in python
this is how you get a script or a module
to be executable you put a little hook
in here and it's kind of cruft a
boilerplate but
if this is run as a script it will call
the start function this is the
interesting part start function zeromq
is a low-level message oriented library
so it's used for sending and receiving
messages it's in contrast to a large
framework like RabbitMQ or other
brokering services the mq lineage
typically there are large applications
and their brokers of some type so you
install some large application and you
connect clients to the clients you know
participate in some protocol messages
are routed and distributed etc zeromq is
not this it's often confused for
something like that but it isn't it's
much more like a socket API but it's for
messages and in this API we always start
with a context and this is part of the
zeromq library itself so we create a
context and you can read that in the
docs what that context entails but this
is sort of like the environment for the
things that we create we will then
create a socket in this case we're going
to in its socket I'll show you what that
is in a second but just read it as a
high level oh that's dangerous this goes
fast sorry I did that in practice I'm
like never do that and here it happened
all right it's like a trick that
logitech plays on you okay here we go
don't do that all right initialize the
socket will read that in a second so
that's a function of the context I've
got a socket alright so I'm going to
trade the create the context initialize
the socket loop forever here receiving
and handling message it's basically as
primitive and basic service as you can
get I'm going to create i'm going to
start listening for something and
receive something off of that socket i'm
going to handle that straightforward
right hopefully okay this is some detail
here initializing the socket in this
case is a function of a context we
passed the context in and this is the
API itself then this is the python
bindings so it's kind of object-oriented
great so we zoo contacts dot socket that
creates a new socket and this is a
socket type we'll get into socket types
in a little bit this simply means it's a
particular flavor of a socket a message
socket and we'll talk about that later
this is a bound socket so it's going to
actually be sort of a like a listener
it's going to bind to this all in
faces that's the star on port 5555 right
so we're now listening on a local port
so if you go netstat dash na you'll see
that port 5555 is occupied by this
particular socket print a message and
return the socket very simple that's the
initialization so we create it and we
create a bind this is effectively the
server size the listener will look at
the client side in a second handling a
message this is something that we've
received off of this off the socket this
is not a stream it's not a byte array
it's a message it's an opaque binary and
that's really the difference between 0
mq and traditional socket socket
interfaces and 0 mq you deal with
messages there binaries just binary
blobs very simple they're not streams
zeromq provides certain guarantees that
you get the entire binary so you don't
have to worry about all the plumbing
associated with sending and receiving
opaque blobs of data that's what zeromq
does for you so I got this thing I'm
going to handle sa got message now this
is where the the work is done here i'm
going to call format jason we'll see
what that looks like in a second that's
the raw data that's being passed and i'm
going to send i'm going to send a
response back on the same socket so the
socket is used as the receive and the
send if i have an exception it's going
to send an error and i'm using a little
prefix here to suggest just to imply
good that's a plus so this is a good
good response and the negative is a bad
response it's very ad hoc api that i
created simple direct there's no crazy
thrift or or other complex and coatings
it's just a string and this is this is
the sample alright so that's the basic
flows at all makes sense very this this
library is very very simple it
encourages you to think simply it's
remarkable that when you think simply
amazing things can happen this has been
my sort of Dow experience with with this
library and then very quickly the format
JSON this is taking the existing
functionality in the Python JSON so I
went in and I read the code that does
the the pipeline this reads from
standard out and I just basically put it
in here and so that was a quick hack
very simple I'm going to load this thing
this is an odd name for
taking the raw unformatted JSON and we
converted into an object that's an
internal representation within Python
some formatting options whatever and
this is now converting this using the
formatting options into a formatted
string simple super simple right that's
why I picked this example because it's
super simple that's the service that's
it this is done this is code I'm going
to show this code running in a second
can you believe it that's a service
that's like so simple all right here's
here's here's our line where is like
thank you Oh Python is so it's so hard
to deal with that return statement
bothers me so much and it should indeed
bother you this is much better I feel
you just feel safer doesn't it you're in
a safe place now we can all relax and
breathe oh my coat is going to work I
don't have to worry about this stuff now
pythons great come on pythons great okay
so this is going to be written in a
script this is written a script so this
is the story here I liked I like to
think about code as stories and I can
really tell great stories with with with
functional languages and especially or
length it's so simple I'm going to
initialize a state don't worry about
what that is it's some state will look
at in a second I'm going to make a
request the raw input is being passed on
the command line as an option right
there it is raw meters of the service
that's the raw JSON and there's some
state right we're all used to state we
don't look like to look in the state
because it's messy that's right that's
the way you want to look at it and then
after I've made the request i do a
cleanup so this is a command and i'm
going to execute it's going to run its
going to quit simple so here's the
request I've got the raw now this is the
state that's getting passed in it's a
little leaky but whatever it's simple
there's a context here we'll see that in
a second but this is the socket that's
that was initialized in its state here's
the code this is the library that we're
talking about this is why we're here
today because we're allegedly interested
in these four letters here Z cmq this is
it in action finally it's in Erlang it's
happening zc sorry CZ mq i do thi tip i
type that incorrectly about every every
every other time this is a function that
is going to send a simple string to
string it's not simple it's just a
string on the socket so here's here's
the socket and here's the raw
that's it and we're asserting that it's
going to succeed we're going to then
receive back on the same socket and with
a time out of a second and we're going
to handle the result again very simple
send and receive so in the service we
did a receive send and not surprising on
the client we did a send receive so this
is a basic request-response
implementation all right everyone with
me right good excellent no case
expressions by the way so you don't need
them don't need them okay where are we
in its state again we're looking at the
API we're learning how to use the API
here so in this case the context is a
startling this is idiomatic in Erlang if
you don't know this by now you should
know this quickly this is very very
common i'm starting a process and it's
linked to the existing process that's
what that means that gives me my context
of certain a success here i'm using this
context to create a socket and i'm using
this API CZ mqz socket oh this is a
little bit strange here but i'll show
you later the goal of this library is to
mirror the capi so it might not look
looks a little like a capi that's by
design there's a there's a reason for
that and i'll explain just go with it z
socket new this is going to create a new
socket with the context and this is the
socket type it's a request type the
other one was a reply type just go with
it flow here I'll explain all it later
I'm going to connect the other one was a
bind i'm going to connect here this is
the same ideas listening on a socket and
you have a connector that's connecting
this is this is essentially a client
function of the socket and here is the
address the other one was bound to all
devices that was the star this one is
connecting a local host on the same port
so I'm expecting a connection to succeed
here and then I return the tupple here
as the state because I'm interested in
both of these for cleanup that's the
state there it is we've revealed it ok
then we say well yeah request I've
duplicated this so I don't need to do
that all right so forget this bro we've
already seen this this is the handle oh
I did for context handle receive so
we're going to send this out and receive
immediately and we're
expect one of three results here I got a
success with a plus I got a success with
a minus and i get an error of some type
and we have different handlers for each
of these so if it's good i'm going to
print the reply if it's bad i'm going to
print an error yeah straightforward ok
so we've seen a simple service we've
seen a client and we've seen the API in
action it doesn't actually get any more
complicated than this you just add more
of these things in other interesting
patterns but the code that you write in
this paradigm is should be indeed very
very simple you can extend this into
production systems this is not an
oversimplification it's just simple
right ok so who wants to see the demo a
demo we want a demo right of course we
want to see a whore let's see this
working of course ok so let me show you
the actual code ok so this is the this
is the Python service here it is it's
all of that it's what I actually added
some stuff so it's what are we're in
thirty thirty eight lines with white
space ok here's the East ripped the
airline alright and that's it super
simple ok so I'm going to start the
service so it's going to look like this
alright listening on port 5555 ok so
that's an actual bound port there this
isn't magic it's actually listening on a
TCP socket so at the end of the day
we're talking about network traffic so
don't don't freak out here alright so
let's run our client so let's pass in a
number alright that's valid JSON ok so
here we say sorry about that if you can
just see over here got one two three
sorry that's possibly my fault yeah
there we go ok got one two three and
this is this is the format of JSON not
terribly exciting but let's pass in
something
like this all right okay I got the raw
string unformatted I got back formatted
that's what this thing does one more
just because it's so much fun alright
foo one two three okay convinced anyone
doubt at this point you all convinced
your believers that this works okay so I
passed in some invalid JSON there and I
got no JSON object could be decoded
right simple you could you could I could
charge for it I could monetize that good
like have advertising for this and
retire within as long as I as long as I
had 450 million users I think I could
monetize this with Facebook successfully
very successfully okay so look all right
so what do we just see here let's just
summarize this in pictorial form this is
a Python process it's listing user using
a particular flavor of a socket called a
reply re P stands for reply and it's
bound to this port we started up an
erlang process it has a corresponding
request socket type which is then
communicating the over tcp/ip sending
raw JSON up to the service and
converting it back it isn't honestly
getting any more complicated you are
truly understanding everything you need
to understand right now all right so let
me let me throw a counterpoint up here
because I know some of you are like why
are we building services here for JSON
conversion right so all of this just to
format some JSON why don't we just use a
library right why don't we just used
python why do we have to run a service
to do this like you're talking about
deploying these programs and having
networks and having operations and
making sure that these things are
running and available are you kidding me
for JSON formatting you're insane right
libraries you can just distribute them
anywhere you don't have to like run them
on a particular server these are all
valid points so here are my responses
first of all it's just an example it
could be much more complex than this
this could be interred doing all sorts
of interesting things this is the
essence of the service-oriented
architecture you can have simple
services you can have complex services
but let's just for argument's sake
assume that I just want a format JSON in
all actuality it's not an example it is
something that I want for my business
it's a service that I want operations is
something that you have to deal with or
you have to deal with it at some level
and if you have to deal with that at
some level you should be able to deal
with it at another level if you have to
deploy a web application you need some
strategy around DevOps and operational
management and maybe we aren't as good
as we should be at getting services
deployed and maintained and monitored
but this is a function of time over time
we will become more and more efficient
as doubt you've heard DevOps right
DevOps is so big it's huge it's like you
should just have it on your t-shirt and
stamp it on your DevOps is the
conferences and DevOps are not 300
they're like 3,000 and and they're like
companies and eCos is like markets are
being driven onto it's going to get
better so yes it is complicated a deploy
service but it will become less
complicated over time here is my point
though libraries actually don't scale
when it comes to programming expertise
so remember that option of having to go
and modify existing code we have to
modify existing code what do you need
language expertise you need a nova the
libraries in this case I didn't know
didn't need I didn't need to know
anything that I didn't already know I
got to pick and who cares what what's
under the covers that service is
deployed and it's available and it's
useful and I wrote it and I don't care
if somebody doesn't like it if you don't
like it throw it away and write it in
Perl it's like this much code in this
particular example so small and focused
you can almost just think of it as throw
away write it freeze everybody to sort
of solve problems t whether you're an
individual or a team to solve problems
as you see fit I think that scales you
know as opposed to shipping libraries
for performance reasons or because you
don't like operations I think there's a
lot of Merit to throwing services up
there because you can solve them quickly
you can you can address the problem in
any sort of diverse heterogeneous
environment all right and more important
anything in the world is this idea of
discrete what i mean by discrete is you
have a service that's running out there
what is that service it's bound to a
port
it's really really specific in this case
it's an operating system process you can
go kill 9 in it it has a boundary it has
an API right as an interface you send
something up and you get something back
it's all very well defined you can move
it around it's independent you cannot
say that about a library you cannot say
that about some block of code blocks of
code tend to get entangled you cannot
just pull them out you can't just shut
them down you cannot just move them
around but service as you can it's a
very important step to moving away from
monolith into ecosystem and zeromq is a
library 40-plus languages folks that can
enable this just like it doesn't just
like Erling enables it okay so I'm going
to quickly summarize here the zeromq
approach to software if you haven't
guessed it's sort of micro
service-oriented focus discreet
processes that you can run service
orientation there's a online document
written by Peter Hinton's called the
guide zeromq follows this as a bunch of
patterns of messaging patterns in them
and at the animated courage is going to
call to action to go read that thing but
there's a bunch of patterns in there
that illustrate ways to solve problem
using messaging patterns in the guide
are based on socket types let's quickly
run through some socket types zeromq
works as we've seen with sockets so you
create some sockets and you send
messages the sockets have flavors they
have different characteristics the
mother and father socket types like the
top of the pyramid here are the router
dealer and this is getting into zeromq
jargon or nomenclature and when you read
the guide and when you read the
documentation these will become very
familiar but very quickly a router is
effectively acts as a server in a dealer
effectively acts as a client in zeromq
there is really no distinction between
client and server it's a very freeing
idea we think a client-server primarily
because it's a very common request
response protocol we deal with the web
there's a serve it as a client and
zeromq anything can be a server and
anything can be a client but it's
helpful to think about
this at times is something that handles
a request from some sort of central
thing that handles requests from dealers
these these names if you read the guide
you'll see what Peter how Peter views
them I tend to view them as
client-server that maybe a little
diluted but it works for me you start up
a router you start up a dealer the
dealer has an ID the dealer sends a
message in and the router can send back
specifically to the dealer is that that
is the most complicated facility of
these types every other socket type is a
derivative of this request response is
simply I'm going to I'm going to create
a reply socket here and a request socket
over here and it means that request says
I want to send a request and I want to
reply immediately the reply expects to
receive something and sends it back so
it's a request response type interchange
here you'll see that these types tend
that they pair up with one another they
typically pair up so you'll have one
type and another type and they'll pair
up and you use these these pairings to
create different patterns in your
topology in your messaging topology and
you use that to solve problems another
common one is push pull this is
basically you just want messages to go
into a single direction right that's a
very common pattern you're just sending
messages back this might be a logging
service where you're collecting things
and you're just sending things it's kind
of UDP ish ok that's it really I mean
that's there's a there's a few others
but that's pretty much it and the guide
will show you how to use these things
it's kind of like the zeromq Bible ok so
that's a whirlwind tour of 0 and Q and
the ideas behind 0 mq and some of the
practicals of 0 mq contacts sockets
sending messages i can stop right there
that's basically all you can start to
use this today like like like don't
drink beer just like go create services
is so much fun so let's talk about the
binding here so now we're going to move
into Erlang world and in this particular
binding is library okay it's an external
seaport it's very strange to see a
binding written this
way I often don't know Mitch ered knows
others know here if there are other
traditional language or driver bindings
that use external ports typically I've
seen obviously nifs and and and built-in
drivers the reason I did this was I used
to you see the other compete there's
some other libraries that interface the
zeromq written as as nifs or other other
linked drivers and the problem with any
of these is if there's a slightest
problem with them they'll bring your
entire erling vm down now I don't know
why you use Erlang but if it's not to
stay up and running I'd like to know
what the use case is maybe you just like
the syntax I don't know i mean the
syntax is good I like I actually do like
the syntax I'm not sure we've got my
first choice but I certainly user line
because I want my software to run that's
it that's the primary reason the reason
it runs is it is predicated on unfold
isolation are you have process isolation
and if there's a fault within one of
these it's isolated and it doesn't
affect the other processes why on earth
would you subject that beautiful
architecture to some library that is
peppered with assertions zeromq if you
look at if you just go and grep
assertion or assert you'll see they're
everywhere it's basically just the way
they've handle errors asserted boom
crash so if you use these nifs if you
use zeromq in Erlang you have to
supervise your own process you should
anyway but your process your rolling
process will go down all the time it
just will one mean all the time if
you're running it continuously depending
on your situation it might go down and
have to be restarted you know other
multiple times a day multiple times a
month but it will definitely go down so
I don't like this it's bizarre to me
that that so we'll see that I'm really
opting for for safety over performance
you'll see that the performance on this
thing it's it's it's fun to see okay
highlights of this all functions are
available through a single module so
it's very simple to use it mirrors as
much as we possibly can the upstream
sees d mq api and this is very much by
design so those weird function names SI
saket underscore blah blah blah that
comes right out of
documentation I want folks to be able to
read the upstream documentation become
familiar with that API and be able to
use it here so there's a synergy I don't
want to reinvent something just because
it's more idiomatic erlang in this
particular case I think the capi is
perfectly fine it's very elegant it's
well done and I think it reads cleanly
certainly reads a lot more cleanly than
a lot of other airline code so you might
get a little bit bothered by some of the
verbosity and some of the sea api
ishness of it but that is by design and
you should be happy I think you should
actually be happy about that okay so
this thing is steady but it is it is
what they can slow as a dog it is
relative to some other things but the
initial folk focus on this should be
true I think of any of any software that
you're right should be on it should work
right should work first and foremost and
then and then maybe it goes faster if
you needed to go faster so that's the
approach there's been no optimization on
this but it's not that bad it's not that
slow okay the way an external port is
implemented is you have your airline vm
and you start literally start an
external OS process it's not an internal
airline process it's like another like
PS dashi if you can find the process
running you can kill it it's a separate
OS process and it communicates over
standard i/o so it's a request response
protocol you typically send in this case
with this this implementation you send a
command over and you reply over state
over standard in input and that's the
way an external port works the advantage
of this is that as these are separate
processes if there's a problem over here
who cares you lose the state big deal
it's a message it's a message portal who
care does all there's no state here
anyway hardly any state all of your
precious processes all the code that you
want to work is still working here in
beautiful isolation land and it doesn't
matter and you can supervise this if it
crashes you restart it it's really
really nice the problem that a lot of
people have is they just think oh this
is so terrible how slow this pipe is
just so bad and slow i want an if i want
a
I want to this thing to go as fast as
possible and I really don't care if my
code crashes I did I don't get I don't
understand that maybe speed is important
at times we're gonna see that there's a
big difference though there's a
trade-off to be made okay cesium cube
very quickly is a very clean Peter
Hitchens iiiiii want to be like him when
it comes to program he is a really
mature and understands the the the the
beauty of simplicity driving something
and making it as simple as possible this
is one of the most clean and elegant
api's that I've run across so I wanted
to reflect it I wanted to use that it
wraps a 0 mq library which is a lot more
than a wire protocol we've been in a
list we've been talking about zeromq and
there's a pure lying implementation
that's great if you just want the wire
protocol and want to duplicate all of
the work of the core libraries that's
that's that's fine but to me that's a
lot of work why would you do that if you
could just leverage what what is
existing there are some advantages you
know pure pure pure you know you have to
deal with this weird port interface
thing but there's a lot of work to be
done to maintain synchronization across
the and keep up to date you see you
always see that these pure is pure
bindings are lagging in features
functionality performance etc mainly i'm
lazy here i don't i don't want to write
that so i just want to wrap this thing
cesium cubes closely attended to and it
has some security features so looking at
all the different options i think cesium
q is a very is the right one to work
with it's just this nice clean interface
and its first class Peter's working on
it directly so that's that's what you
get with this binding okay or are we out
here timewise okay it was a 50-minute
talk sort of ten minutes left no all
right I'll skip this stuff then i
thought i had an hour these people they
don't tell me anything come on out now I
I should know okay so look very quickly
here you can see this if you go into the
into the documentation and the samples
but these are these are examples of the
sends here's some of the receives right
there fairly straightforward each has a
slightly different variation
because we're talking about an external
port we cannot block on any operations
any blocking operation freezes up
everything so because zeromq is has all
non blah has has non-blocking operations
we use those and we simulate blocking
using Costas ease with inner Lane right
so you have a polling facility which
will pull right so we can't get push
notifications from an external port we
have to make a request and we get a
response so the only way to get that is
through polling but there's an efficient
polling mechanism so it's not terrible
there's some future blocking simulations
using polling ok observations yeah it
certainly done it you you get all of
that but you get it through an erlang
interface which is doing pulling in the
back back end if you look at most code
examples in in zeromq their polling all
I mean it's the most common approach you
pull you go into a loop and you either
block or your block on a receive or you
you don't block and you do a weight and
you can you can dep that polling
increment i think is when when messages
arrive in 0 and Q they will collect the
messages so it's not like the messages
are being blocked and when you do a poll
it collects all the messages that are
currently have landed so if you get a
thousand you'll get a thousand back
right away and then so your increment in
polling so you get some latency in there
but that latency is generally not
generally not an influence of your
application if you want performant
message handling you don't I don't even
think you want to use airline I think
you want to if that if things are that
important from a performance a latency
standpoint writing something and see is
not that hard and and then you can use
you can write a sea program that is all
the efficiencies that you want then you
interface back to Erlang through a
higher level interface / / an external
port that's the way I would approach
that okay this is a very small library
if anyone who wants to like add things
to this plea
just go do it give me a puller because
it's super easy to do this is a very
light touch around cesium Q and that's
intentional I found that these libraries
that are complex are hard to maintain
their hard to get right so this is
straightforward I think there's a lot of
pay off with a relatively small amount
of code it's slow relatively speaking
but it's solid and we currently have a
pretty stable ap I mentioned the
maintenance issues here okay there are a
couple other sort of prominent zeromq
libraries there's the NIF that's Earl's
Adam q2 and then there's easy and cute
just purely to give you a feel for the
performance here now remember I told you
that this thing is slow as a dog this is
a explain this graph here we have a send
this is using a sender and a receiver in
the respective languages so this is a
receiver the first one is a receiver the
second one is a sender and basically the
receiver sits there and the center just
pounds it with messages and then you
count to see how many messages are
landing per second if you use pure seed
like this is just as fast as you can go
in this particular scenario you're up
over 1.2 million so it's quite good if
you use C as a receiver with Earl Earl
gmq this is the NIF it's about half that
that's incredible that's very fast so if
you want speed in air lang this library
is the one to use you will sacrifice
stability of your system though it
absolutely will I've used this for years
and it just is the case this thing had a
problem with sin so it didn't show up
it's very very low I probably configured
something wrong here do I need to
probably check that it may actually be
that slow i don't know something weird
was going on there so here's this
library this is one we're talking about
it's like it's pretty bad but if you
come back here oh sorry the next slide
will show the numbers here and this is
this flips it so where c is the sender
and then with the libraries the receiver
so you can basically see the takeaway
here is that urls NM q sim q is quite
fast behalf a C in Erlang is pretty good
its course is an if so you pay a penalty
on stability the library we're talking
about here is relatively very very very
slow so if performance is an issue I
would first ask you to look at the
actual numbers so this is still serving
tens of thousands of messages per second
no it's not 1.3 million in C but if you
need that sort of performance late and
see throughput you know characteristic
go right in and see it's not that hard
so we're even right TV today I can use
this in production these numbers are
more than sufficient for the throughput
and if I need more I can I can spin up
more more external processes more more
ports and run these things things in
parallel so distribute distribute okay
what's going on in the future the API is
not complete it is it is usable though
and if you need to add things it's a
very straightforward process so if you
need to put something in its mechanical
and if you need functionality I'd be
happy to do it or I think if you look at
it it's easy to do so that's the first
priority though complete the the API we
want to make sure it's stable get the
type specs written and document
documented community use feedback
improvements and then finally
performance and there are some ways we
can improve the performance and that's
on the ritz on the road map but until
somebody says this is a problem i'd like
to see a problem and then somebody solve
it specifically and no it goes faster
for a reason rather than just making
something fast for the sake of
benchmarks like some companies like to
do okay I've got six minutes left so I
can wrap up very quickly here and get
some time for some questions if you want
to get started it's very simple get this
library from github I have a reference
here that will point you in the right
direction number to run make check it
will compile and run tests i use tests
to document functionality the tests that
i have in here are readable it's fun to
read it's like a tutorial do this then
this then this then this ah okay so it's
not like a bunch of blind assertions
where it looks like a matrix that some
computer sort of assembly its assembly
generated it's actually legible and it's
fun fourth and final because this this
will take this will take all of 10
minutes get go online and read the guide
i have the reference here to it it is
fantastic it will open your eyes up to a
world of this messaging stuff and show
you different patterns for solving
problems and peter peter writes with a
very entertaining styles it's a great
read it will
I believe it will change things for you
okay and then you can start to use this
thing noman olas evolution or a service
Orient oriented adding things to add new
functionality that guide will point you
down that road and you can use Erlang
with this library here are some
references we'll skip that quick summary
I think this is important stuff I think
that the only community needs to embrace
more languages I think we need to be
able to communicate more effectively
with other language groups in zeromq is
a really easy way to do that I think we
need to think more in terms of service
orientation and systems of software
rather than monolithic applications lots
of rolling developers come from
different language camps and they try to
apply those points to Erlang it's a
mistake we need to unlearn these things
and start to think in terms of very
small pointed service-oriented or
process oriented solutions that are all
orchestrated in a system and erling is
beautiful at that zeromq enables the
same picture the same story in other
languages so folks that you work with
that these companies who don't like to
you know to think about new things 0 and
Q will enable new things for them you
will get to work with them you will be
happy to work with them you might even
be able to use Erlang professionally
because you can just write a service and
talk to it with all these other
languages you can just write it in
Erlang and you can write us a service
and early and just as easily this is
really I think very important enabler
for a brave new world of sanity this is
my point of view I i I'm willing to
debate you over beer like in two minutes
ok we have a reasonable amount of time
for questions yeah
there's a yes so the question is are
there any helpers to to to define
protocols the only portico so there is a
wire protocol for zeromq and then
there's the payload issue so what kind
of binary formats are you going to ship
over and the schools of thought are you
know write a very efficient binary
format on your own a wireless of you for
your payload or use JSON or XML I'll use
XML ever or there's things like thrift
or proto buffs or other Imbert things
that you can encode binaries it depends
on the application but JSON is a really
really smart starting point because it's
as ubiquitous as anything gets yeah yeah
so the question is about security czm q
comes with some support for lib salt or
lib sodium which is an encryption a very
fast encryption library and if you read
this easy mq documentation you'll see
what that you'll you'll see what's in
there this library does wrap out there
are tests to show that basically you
cleave certificates that use that
encrypt message the pay encrypt the
payload and decrypt so that's all
documented in the cesium Q stuff it's
reflected here so if you want security
out of the box this is a nice fast way
to get it otherwise you have to do your
own encryption you roll your own
security which is fine too it just
happens to be out of the box here
so the question is he's emphatically
agreeing with me and stating how awesome
I am I agree with that I think that you
make an excellent point there now I mean
the point actually is is that there's
there's a split between erlangen see its
design early it's not designed to go
fast it's designed to be stable and run
it has excellent interfaces to programs
that go fast in C and the external port
is one of those and it's a really good
mental model to carry stop talking about
erling being slow don't don't say that
anymore don't think that way it's
designed to be stable it happens to be
slower than a lot of things but if you
need speed right in in see it works fine
this external port interface is a
beautiful way to write performant code
and Trant and communicate at whatever
level you want to whatever level is
important over standard i/o don't get
hung up over that if you want to write
stock it's fine you can use zeromq but
the standard i/o external port interface
is a very very nice approach to solving
stability vs speed and I your
observation about my awesomeness was
right on the money next question
so the question is about flow control
and and buffering and the library indeed
buffers and there are different ways of
managing the ways of discarding messages
after a certain amount and there's
tuning there's a bunch of options that
you can use for tuning zeromq which are
all available there's some babies two
options that are not exposed in this
binding but they're easy to add but yes
absolutely this is a very nice buffer or
interface to the outside world and
what's also nice is that if there
happens to be a problem you can you can
actually spin off different contexts and
say this one is going to be isolated for
this particular message type this type
of traffic type and if it blows up it
blows up and you can restart it and if
other ones are you know in other other
interfaces remains isolated and separate
for that so it also gives you a degree
of control over the type of flow is the
type of message that you're you're
working with all within Erlang
yeah so if I can summarize the question
it's about distributed airline versus
the use of some other networking
protocol in this case 0 mq is an all
possible alternative i look at the
distributor leg is a convenient way to
distribute Erlang but it's it comes with
a very specific network working topology
that is toxic in some environments if
you get up to 60 nodes or so you know
you have a you a fully connected mesh
and this is the problem with that it's
very it's straightforward and easy
within relatively low note counts and
you can partition those but you get what
it is and it is what it is and so you
look at that and use it for what you
need it need to I don't think that
there's one I wouldn't say always use
zeromq for distribution I don't like
distributor lane because I think it's
easy to communicate over sockets anyway
I like the partition I like the fact
that you know something is outside of
yourself this sort of you know I don't
care no where's a process is running
kind of bothers me but that's me lots of
really great software is written using
distributor lang so I think you need to
look at your application and understand
your requirements and then understand
the specific technical advantages and
disadvantages of the of both of those
options so there's no religion there
other than science you do what's right
for your particular you you understand
your problem and then you solve your
problem using the most appropriate you
guess and yeah
I have no idea that's a good question
and you're please help me on that ya
know we could work together then always
been been point has actually been using
this or looking at it and sending me
issues and so I appreciate that and we
have their all resolved by the way now
that that thing that you were running
into was actually not a problem but but
the question was was about using threads
within the context and there's a lot of
performance tuning that you can do
within within the zeromq context within
that external process I haven't looked
at any of that the first goals have been
just to get the API I get things working
correctly so you can use this safely
environment but I think when it comes to
performance there's a lot of things that
we can improve on but I like to do that
as we understand why we're doing it and
that we actually need to do it and do it
intelligently ex parte ly I don't like
performance for the sake of metrics of
statistics of graphs if you maybe maybe
not realized that but I don't like that
okay so we are over and I appreciate
everyone staying a full four and a half
minutes into your drinking time so thank
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>