<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Implementing Event-Driven Microservices Architecture (...) - Nikhil Barthwal (Lambda Days 2017) | Coder Coacher - Coaching Coders</title><meta content="Implementing Event-Driven Microservices Architecture (...) - Nikhil Barthwal (Lambda Days 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Implementing Event-Driven Microservices Architecture (...) - Nikhil Barthwal (Lambda Days 2017)</b></h2><h5 class="post__date">2017-03-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/I7vdlpuRw5c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yeah hi everyone my name is Nikhil Burt
well I work for gedcom - the way I've
structured this talk of I'm going to
give a very brief background of what
Chet is why we decided not to use an
object-oriented programming language a
little bit about our implementation in F
sharp and the benefits that we had by
using F sharp okay so let's start with a
background we were launched in July 2015
which is like we actually the company
started in 2014 but it was launched to
the public these are some statistics we
have 26 with which does per month
twenty-five thousand orders daily eight
million customers and we have about 15
million items in our inventory and last
September we actually got acquired by
Walmart three billion cash 300 million
stocks from something so we were in news
you know every respect in New York City
everybody was like oh you work for that
company the Walmart one anyway
oh okay sure
thank you better awesome so let's talk
with architecture we have microservices
based architecture about 700 plus
running in production the reason why we
used micro services and our whatever
implementation obviously we had a lot of
scalability micro services lets you you
know it gives you the speed it gives you
independent reusability you can scale
down and scale up certain micro services
depending on which ones are more heavily
use the ones like Tier one that the
customers generally interact with first
they can be scaled you know higher and
tier two tier three you can just tone it
down a little bit
fundamentally it's an event given
architecture so when I say II went to an
architecture I mean it's kind of a
reactive architecture with user
generated event right you go to a
website you order an item they generated
it event or item to customer X right and
and obviously then the backend takes
that event and it processes and goes
through a series okay checks inventory
each X pricing issues you know that's
all kind of background checks events or
things so rather than using the state we
chose to use event sourcing because it
can reliably give you a hundred percent
way of auditing and very good logs in it
so events or things basically for those
who don't know what event sourcing is is
rather than having a six state that
represent the system basically what you
have is all those events that you can
replay to get the current state so for
example if a system is not in sync right
you've got disconnected at a certain
point you know over the last event so
you can just you know replay the events
and then get the current state by just
summing up all the events that happens
instance okay so now comes the
interesting part right we have the
technology stack so we were based on
Microsoft Azure they were business
reasons they don't want to have a
computer to em as and running on Amazon
platform for
reasons we know there was a business
reason right it doesn't make sense do
you have a computer built on Amazon so
we use this dotnet framework this whole
bunch of technologies we have events so
we have Splunk Redis Kafka we we are
going to actually we have now an
in-house implementation of Kafka and F
shop called custom so if you go to Jett
github site you actually can download it
earlier we are using what was called as
an RD Kafka which is actually a c-sharp
point for Kafka but we are heavy users
of f shop over our back-end is pretty
much implemented in a shop as a front
end we have some typescript and angular
and a little bit of c-sharp also but
back-end is all ever okay
now let's let's actually go and look at
how what a micro service is or in
general I'd say this is probably true
for a web service also that when you
look at when you look at web it's
basically as I said a function that
takes an input event in response you can
mathematically represent it as Y is
equal to F X standard wash majority of
services appear and pure means you won't
have any side-effects here when we talk
about side effect we are mostly
referring to writing to a DB or
something like charging your credit card
that's a side effect right a logging is
not really I mean work in Haskell world
logging is a sound effect but we
wouldn't call logging a side effect here
because it's just you know mostly for
debugging purposes and then you have
some of them minority of their services
where you actually use some kind of
inner external effect like a writing to
a database for example you know you want
to check the inventory and you have
ordered an item so you want to go to
your inventory DB and just reduce the
count for that item or you're charging
the customers you know so the customers
credit card gets billed that's inside of
it as far as the service is concerned
so before I go into why we implement
used f-sharp for an implementation also
start the why we think use a standard
C++ Java or the mainstream
object-oriented programming language so
if you look at the history of
object-oriented programming language
right it comes from imperative it was
basically in around 80s that there was
an extension made and primarily
object-oriented programming language
brings two things to imperative world
polymorphism and encapsulation and going
back the imperative world models the
system as states right the Van Neumann
machine and you're basically
manipulating the states of a van human
machine thing is micro-services don't
really have states like vast majority of
them are very pure so it it doesn't seem
right to use a language that's primarily
you know architected around manipulating
states for implementing something that
doesn't have States in it in the first
place so now one may wonder why why then
vast majority of people then use Java or
C sharp to implement and my answer is
it's mostly historic it's like you know
they're just mainstream and people think
hey I mean this is this is the way to do
it this is the way you do programming
function languages are not very popular
and then of course there is a large
amount of ecosystem right your
third-party libraries and so on
built in Java and c-sharp that you can
readily use turns out that most modern
languages like F sharp and Scala right
they can interoperate with c-sharp or
Java seamlessly because you're running
on the same virtual machine so we we
decided that object-oriented language
are not the best way that we could do an
implementation and we had a lot of
benefits that I'm actually going to
cover in the later slides and we chose
to use F sharp on Azure okay so turns
out that a web service can be modeled as
using functional paradigm in a very
natural
for example like I said a service is
basically a function right
that takes an event and algebric data
types of any app shop can actually be
used to model the event very well
we'll we'll go through an example of how
we do that each service can be viewed as
a function that takes this event and
generates an output and of course you
know functions in to work with each
other because especially in a micro
service architecture you have several
services cooperating with each other the
function may call another function it
may call another function so these are
like nested calls and event when
generated don't change over time so if
you've ordered an item X at point T you
ordered an item X 1 T there's no chance
that you know that's going to change now
you might order another item on a
different time yes but that's not still
it it's not the same event right because
the T is different done so event by
itself are immutable and that that's how
it plays into functional paradigm
because functional paradigm has
immutability built in and this is
actually a very important thing is you
should be underestimated because it
gives you an enhanced ability to
paralyze the code we'll talk about it
later okay so as I said a service takes
an input event processes and generates
an output so you can model any kind of
input event like you know let's say that
we have you wanna query an item right of
so you wanna query I have this item name
or I have it from the catalog sq number
right which is basically an ID assigned
to each item that's your input then you
have an output saying you know is the
item in inventory so you take because
your SKU number is basically an integer
so you say well yes it is an inventory
it is not in inventory and when you have
it in your inventory you also want to
know the count how many items are there
in inventory right it's not in inventory
I can give you an estimated date when it
would be so that's the second case or
the third simple cases we we don't carry
it sorry
and then you have a function that can
take this input and you know do all the
processing and do the output so here
what I want to illustrate is how easy it
is to define these events and write a
function so if you're if you're
implementing your service how you
basically take it as the way I would
implement it is I would define what are
my inputs to the service what are my
outputs model them and ATC's and then
just write the code that transforms
because one way of looking at functional
paradigm basically is it's a series of
transformations series of functions that
you apply to input to get an output okay
there are several advantages to
implement it in function languages
particularly if you try to stay with the
immutable and purity part as much turns
out that the behave is very easy to
predict the behavior of the code if you
stay in the purity limits and you can
test it exhaustively because there are
no side effects right so there is
nothing that stops you from testing it
exhaustively generate millions and
millions of cases I know John Hughes
talked in the morning that they have
this big checking tools that can
generate millions of cases with impaired
services there is a certain kind of
because there's an external state now
when you test it exhaustively you have
to be mindful that use of your state's I
do states have to be same because you
can get different results at different
point of time because your state was
different it's not easily visible to the
user of the test I was testing it and of
course certain functions can't be tested
exhaustively because if I am testing I'm
not going to bill your credit card
hundred times so what were the benefits
of using f sharp the first thing is
scalability and this comes from
immutability the thing is that because f
sharp is fuel there are no side effects
writing scalable code is so easy you can
go from like you know thousands of
customers to millions of customers and
not even feel a blip about it
that's the scalability by far and for
website like jet or Walmart you know
scalability is is a very very very
important
we talk about productivity typically
f-sharp code we find that it's about 20
to 30% more concise than an equivalent
c-sharp now I know William Blum talked
about tie providers and if you were to
implement tie provider in c-sharp you
are talking about 900 lines of code and
f-sharp is one line of code because
everything is done like automatically
for you right you you have a tie
provider for JSON so it parses the JSON
engine automatically detects the
structure defines the type for you you
really don't have to do it anything
manually right of course there is a pros
and cons that you know if you use your
the tie provider when you use the JSON
that you're giving has to be
representative of what you expect right
if you have a field that was not present
in the original type sample that you use
now you are in a little bit of problem
but the good thing is being statically
compiled you would detect a large number
of such cases if you use your code
because you're going to try to access a
field that already doesn't exist so your
compile code would not compile and this
actually leads me to my third point code
correctness there's the same in F sharp
community and I think it's probably true
for most of functional languages if it
compiles it's probably correct and what
it tells you is that most of your bugs
that typically like the null pointer
exceptions and so on assuming you don't
use nonlinear sure you actually can use
null inertia you just have to explicitly
market but most of your bugs at runtime
through a very strong type system
actually is checked at the compile time
so you eliminate a large class of bugs
that you would otherwise encounter at
runtime by using a very strong type
system that f sharp would provide you
and that's where the port correctness
comes in our give you some numbers that
we like I don't know about Amazon's code
base right but our code base is
incredibly small incredibly small we are
talking about
maybe 50 200 MB and I can bet you the
Amazon it Reaper probably goes into
several several cakes right now mostly
because they are using Java on I know
Java is the worst language because it's
very verbose but essentially it only
highlights my point that it takes a huge
deal of time for you to write that code
and it's a pain for you to maintain that
code right when you have a when have
really concise code it's so easy to
write so you have a lot of that
productivity right one guy can do like
four people's job and assuming that you
use good enough compiler right
maintaining that code is easy so
conclusion very smooth startups have
scaled a jet size at the same time I
mean we are talking about from zero to
three billion dollars in like almost a
year here and a half and I kind of
turned down the statement very few
because to my knowledge I do not know of
anyone to like that right but somebody
can audiences here I know they so just
to give myself the room you know to step
back I just change the line and said
very few so people don't yell at me that
you're wrong and at the time when we use
F sharp it was like a I don't know if
I'll call it a revolutionary we are we
are again I'm going to give myself that
room to step back but to my knowledge we
are the biggest commercial users of F
sharp I do not know of any other big
company I am not talking about a
two-person start-up here right but I'm
not aware of any big company that has
practically all its back and implemented
inertia and obviously because we are
very much involved in the open-source
community for F shop if there was a
company we would have known about it but
since we don't know so I am probably
going to say safe to say that there
isn't exist one and obviously we have
the scalability in parallelism and
productivity and all
came because of f-sharp I'm open for
questions I'm a developer of a start-up
right now and then we're thinking about
implementing even sourcing and and well
it would not say might Micro Micro
Service is not yet because well you
don't have micro services with one what
right but then how would you how would
you start developing ground up the even
sourcing and and how would you how would
you as a start-up how would you do it
the second make up and that's
particularly if you're a startup right
so if if you know Google wants to invest
billions of dollars to have their own
invent source in short but I don't think
I don't know about your startup but I
would doubt that you could do that so
because of the interoperability of
f-sharp and g-sharp in a case like this
and a case of several such instances
where you would face okay how do I do it
in a cup if you can't do it in air shop
but you can find somebody you did in
c-sharp that's good enough for you right
and particularly when sourcing I do know
that there is an event store we actually
use an event source which is actually a
I don't know if it's a commercial or
open source so the use events or store
if you just google you will get that in
our application I there were some issues
with the reliability with the event
store and we are trying to replace it
now that we are big and we have money
from Walmart we actually are now
thinking about implementing our own the
view probably still won't implement from
scratch right we will still use some
existing and customize it to a need but
to start you can just start using event
store or any c-sharp library and that's
that should do so but I definitely don't
think you should start from ground up
okay you said that you have hundreds of
microservices and most of those services
are pure functions right that's right
and it seems to me that there's a trade
of there so if there are pure functions
they don't have any state they could
also be a library that you including the
services that actually have state and
and the trade of is your but the
Microsoft services that are pure
functions are called over the network so
there's there are different you know
distributed system problems that can
happen there like this service can be
down and so on network problems yeah
right stuff like that can you talk about
the trade off and why you chose the
micro service way over
you know libraries that are included
well micro services actually has to do
with time to market things right with
micro services you can market fast and
again now we are we are no longer the
start above when we started our goal was
to just you know have a product the
customers can use and generate revenue
as fast as possible and you would laugh
at this but we really didn't even had
the testing infrastructure properly
ready when it was open to public it was
really like we just believed in if it
compiles it probably works and we went
with that assumption most of the time it
works sometimes it ain't also and now we
are thinking of adding the unit test
cases and all those things in fact we
have open source another library for
unit testing but yeah it comes from the
fact that you you need you need a faster
time-to-market now in terms of your
original question on you would have
problems with networks and so on but
that's more of a problem that your
clouds provide that is supposed to solve
for you then you are supposed to solve
for yourself right so if you use a good
enough I mean if you use your own
private data center then it's your
headache but for us I was Microsoft's
headache not ours so we would use stay
in the same region which stay in the
same data center we stay in the V net
and a it kind of worked yes you have
production outages but here everybody
has the production outages right and
often
were a premier partner of Microsoft so
we have issues that were beyond our
control we would call them hey fix that
but again a short answer to your
question it's something that your cloud
provider is supposed to give to you and
not you're supposed to solve for
yourself I am a similar kind of question
I guess you mentioned you have this huge
number of motor services I think you
mentioned more than seven hundred one
hundred seven hundred when I prepared
the presentation I probably 720 but joke
yes I guess my question is when you have
such a huge number of components how do
you make sure that they actually work
together I mean you know if there were
components inside single service you
could rely on your the compiler and the
type system to tell you when you've made
a mistake but how do I should make sure
when that the components work together
when there's data cost bunch of services
yeah that's a good question and actually
that's a criticism of micro service in
the sense that when you have a
monolithic service right something
happens you get a nice call stack now
with micro service you have a problem
that I put an event it's going in either
right I got a response I didn't got a
response I didn't got a correct reason
but I have no idea what happened in
between so yes that is a problem
now you can mitigate that problem
substantially with how you write your
code how you test it I mean you have a
whole bunch of integration testing right
staging environment where you deploy
your code in so they're supposed to
actually mitigate the problem obviously
there is no way to guarantee an hundred
percent success rate there or like
hundred percent way of you can get rid
of all problem but depending on how good
your test environment is you would be
able to mitigate that problem
substantially also when you write your
code see the way it happens is that you
have seven different micro services
written by ten teams let's say so let's
say hypothetically you have 70 services
by one team there would be some
similarity so behind the coordinate
implementation you actually are using
the same common libraries so that also
reduces the chance that it won't work
because the code is what might be
deployed separately but in terms of your
codebase you're still using the same
life
across 70 right so don't think of it as
700 different components you can just
boil down and say they're actually ten
different components right split each
component itself is 70 different sub
components here yeah yeah because you
obviously I mean in a small startup
right think about it can you really have
700 different individual component you
don't even have 700 developers we
probably have like 150 when they wrote
that right the question is how do you
monitor your entire system do you rely
on Microsoft to monitor this or do you
monitor the micro services individually
by yourself how does it work we have to
do it ourselves so we have a logging
library how it works is that because we
chose to go with f-sharp we did not had
a lot of standard libraries that we can
use that you could you know get in Java
I know in Python you have logging
infrastructure in Java also you have so
we implemented a whole bunch of stuff
ourselves and this is an internal
library that hopefully we would open
source it for the community sometime in
future but we have a large
infrastructure you know common libraries
for logging and telemetry and all those
that we have implemented and they will
obviously output and then the dev ops
team has log rotations and all those
things and then we actually use plunk
for log management so what data is
actually sent to spunk and there we can
just you know query and see if something
is wrong if that answers your question
okay thank you final question okay oh I
have one question which I probably
didn't understand and you were speaking
about about the services which are purer
and services we have side effects so
it's like a reading from database and
not modifying it a pure service like
when I put the product name and I read
the details about the product it is a
pure or impure in your sense um if
you're suggesting it depends on what
you're reading if it's an information
that can change over time then it's not
pure
it depends on the state of your database
now for example if you're going to give
me how many counts of item do I have in
my inventory
that's impure because as people purchase
your count would go down over the time
right so it depends on the state of the
DP that you're reading right there but
if it's something like do I carry the do
I carry the product or not yes or no I
mean here so it's fine it's also
somewhat impure in the sense that you
can add new products in your inventory
but it's not something you do frequently
right so for practical consideration you
can call it here yes if I upgrade my
system and add 200 more items sure that
can be called as impure but it's not
something I'm going to do frequently but
something like count of inventory that's
frequent because people are parallel
abaya stuff right so essentially when I
say pure and impure service the way I
look at it is is there a state involved
that depends my output depends on that's
what it is and is that state changing
over time if it's yes it's an impure if
it's no I'll call it a pure right thank
you very much shackle
fascinating talk congratulations so
there will now be a 20 minute break</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>