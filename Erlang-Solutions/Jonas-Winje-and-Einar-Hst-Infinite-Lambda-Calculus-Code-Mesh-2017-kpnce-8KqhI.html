<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Jonas Winje and Einar Høst - Infinite Lambda Calculus - Code Mesh 2017 | Coder Coacher - Coaching Coders</title><meta content="Jonas Winje and Einar Høst - Infinite Lambda Calculus - Code Mesh 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Jonas Winje and Einar Høst - Infinite Lambda Calculus - Code Mesh 2017</b></h2><h5 class="post__date">2017-12-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kpnce-8KqhI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yes this is our talk infinite lambda
calculus and some more elaborate title
things going on the way this is going to
work is that we'll be having sort of a
conversation on stage I will be talking
and asking questions and Eunice will be
also talking and answering questions and
coding yeah so we have this Emacs with
some racket running underneath when we
run this line it won't be poop which
means or something which means I can run
like my slides and things like that so
opening slide and some notes to you and
for myself but I think we went through
those so hello yeah so the topic will
obviously be a lambda calculus yeah and
lambda calculus is basically just this
yeah so this is the syntax an expression
is a variable lambda abstraction or an
application we have like one computation
rule that does beta reduction which says
that if you have a lambda and apply it
to something you substitute its
parameter for something in the body and
it gets resolved so we can do stuff like
this right so now you just substituted
the fool yeah and we've made like this
drawing stuff so we can think so it's
gonna be very hard to meet you sort of
point up to point that stuff yeah yep
that's fine there's one application the
function is the lambda X not X thing and
the argument is cool yeah so that's the
reference to the right hand on the right
hand side yeah
and then you pass that into the to your
function which is the lambda keep that
after that and replace all the XS within
that expression in such a very simple
thing about it for years tiny formal
system and then you can do that multiple
times and we can ask it's multiple
lambda abstractions that you yeah it
will print one dyno results for each
kind of have no bar here which is
because oh you don't yeah so yeah all
the beasts in the expression very pasted
bar and you have no B so yeah so yeah
that's kind of how it works and then we
know we can do all this stuff like
compute basically anything yeah but we
don't have lots of stuff built in
so typically we we have to start very
basically what and finding them so
normally we like to do this thing where
we define numbers to be functions to
take arguments that are functions that
take arguments that are so so even your
numbers would be these functions yeah so
serious kind of the function that takes
two arguments and applies the first
argument zero x to the second argument
as you have sort of zero FS
yeah and then there's a bunch of
trickery involved in order to do like
it's a function that adds something yeah
you're trying to do some actual
programming with this yes and like I
said that's what we normally do right
but we would like to sort of proceed and
do more like proper programming and in a
sense and we have like one teachers
proper programming yeah and in little
schemer they use like they have numbers
that look like the numbers to Lucy and
they have functions like add one and sub
one and zero boolean if conditions are
calm state context prescience and
of elephants yeah so I don't think we're
gonna have elephants in this talk
problem is we don't to kind of extend
our language with some of these things
right yeah in addition now to the to the
lambda calculus itself II have remedies
we only have some if thing and we have
numbers and we have some built-in
functions and maybe some other stuff we
could have built all of this stuff with
with just the lambdas but then that
would have been the talk so so this
gives us some big blocks can I get this
off the ground we want to write so the
regular lambda stuff works as before add
one does nothing because we have to
install over a number package module so
we do like install NPM right yeah
so now you have a package system to sort
of both things into your yeah
and we have functions like zero which
returns true we have if statements if
takes like three arguments it checks
that the first is true or false so we
forgave it false of you would get Barnes
that right yeah so if we do like this we
get bar right and then I can do like
more advanced stuff and probably
everything together like a bunch of
computation right
so we have like kind of the primitive
functions they use in little schemers at
least some of them yeah we have a things
that will count but we have numbers and
we had one so now we should sort of
proceed to do more interesting things
like the general plus yeah so we can
look at how little scheming tough this
oh you can't really see it up there I
think but you can see it down there yeah
so it's a picture of the book but this
is the code Martinez so plus is lambda
that takes two arguments it checks if
the second argument is 0 if it is
returned the first argument yeah and
otherwise it will call itself
recursively and yeah so basically the N
is sort of cannibalizing on on the M
until it's 0 and then you're done
yeah the N needs so we can like quickly
try this out in racket which is just
this game and have like plus five you
have some unit tests that prove that
plus works yep so we're done with the
racket now we can sort of try we could
try to write this in our cervix yeah so
we should have like everything we need
now to write the round plus mm-hm
so we'll do plus this kind of equality
thing means that they're defining some
shorthand last thing we're going to plus
or plus prime right I'll do this because
it won't work for mark and we will do
kind of what I feel lambda n lambda M
those are going to be the numbers you're
opposing yeah so it kind of just
translating the scheme called right and
we'll see what so we're using if instead
of count so if M is zero we should
return and right yep
and then it's the else part which is
probably the more interesting part for
you yes I'm gonna get over here and
we don't have built in the recursion so
I can I'm not allowed to like do this
and refer to itself yes
and why is that because you have this
thing yes I have like I can't define
things to be like the definitions like
this and then in every case the
definitions with what I define them as
right this is kind of pre-processing
stuff right so it's not part of the
programming yeah so I should get like
one lambda calculus expression at the
end that I can evaluate right so we
don't know what to put here right but we
know that we are going to apply it to
the number n and the sub one oh yes no
it looks pretty much the same as the
scheme code or a record code yeah apart
from this problem
yeah so we don't know what to do about
it but it is it's not entirely useless
because you could so if you had like 17
to 0 right so as long as M is 0 this is
perfectly fine yeah so we can use it for
lots of different number and we can add
like 19 to 0 it works for a lot of
numbers yes it works for like infinitely
many numbers right as I say house but
just one one of the MS yeah so if you do
like I turn on one together we get this
expression at the end right but we could
conceivably fix that right if you
because because what we end up with this
this expression that add serum we
already kind of solve that problem right
so if you get past that into the thing
that we had so if it like take the
definition of like interest so the
definition of plus you basically this
copy-paste plus Prime in there and we
can go on and we get 11 so we can write
yes we can make the plus prime time and
be like let's see what stuck it
just prime just copy paste this here and
then we can add like more plus so it
works for the number one no it's like
twice as good right yes if it works for
infinitely many numbers yeah times 2 so
we can twist double Prime right yeah I'm
using the wrong function so like this
yeah and I get 11 works and it won't
work with 2 but we sort of know how to
fix that now yeah so you can go on like
this provide and this time we are
copying in a function that so I copied
the plus function again so this time to
think we are pasting in here
Wilbert for numbers up to 2 yeah but so
no it should do like twice as many
numbers as that again right so you can
do plus 3 as well right is that right
yeah so I get 13 so it seems like a lot
of work to add like that's just but
every time you copy the definition into
like the placeholder you get like twice
we kind of double the amount of numbers
it works right I messed up so now it's
sort of like a pragmatic question how
how big an A+ do you need right yeah so
if you can if you have like a domain
expert you can find out what kind of
numbers right are going to show up I'm
trying to get back where I was
yeah now if you sort of if in your
program you figure out that it's not big
enough you know how to fix it also you
can just make it bigger yeah like if I
do this and say that plus like at this
point I don't know home and the numbers
it works for right but I'm very like a
lot like seven is fine I mean you could
you can take a big one and upload it to
github and you have like an open source
thing yeah for a really good function so
at this point if we could be like claps
man and be like AG man but we kind of
took a look at this to begin with yeah
one kind of cool thing about church
numerals is that you get like five acts
for the number F in the function that is
the number five right so you have like
this concept of sort of many nests built
into the number itself right yeah so if
we - kind of like the quarter plus sort
of add one bit or something yeah we used
to get kind of like exactly as much as
much recursion as we needed right yeah
because it was built into the number
yeah so we're in in not quite as good a
place as we were with them yeah so that
seems like well that's it nice to have
and it kind of one we would like to have
something that just adds definition so
plus we have this sort of pattern now so
yes I'm pattern for it so at this point
it's like a design pattern yeah and it
would be nice if we could sort of I
don't know automate this sir yeah so we
kind of know that the lambda calculus is
supposed to be like even complete right
yes and there's also I start with that
when it was like invented or discovered
they made it to use for logic and things
it wasn't really supposed to be turning
complete right no it it it's supposed to
have like accidental Turing completeness
you hide it somewhere and that's sounds
like maybe what we want for this right
because turing completeness in a sense
entails that you have this looping yeah
so if anyone wants to like david's
workshop yesterday right so that if you
want to like prove things you don't want
to infinite loops right we want infinite
loops right it's always right would
enable us to do sort of loops that
terminate also perhaps yeah so what
seems like an a good way forward is to
look at what did people do in order to
make like a consistent logic auto lambda
calculus right and then come up with
something that wouldn't be accepted by
that logic right and they so they prove
that it was inconsistent i think the
proof goes like this yeah so right so we
have these types that are meant to
prevent it so i've no idea what i know
this means but we know that stuff like
simply typed lambda calculus does not
allow problem so what sometimes happens
is that people add like types to things
and they kind of rule out the
expressions that go on forever right so
we could go the other way right so if we
could sort of identify what it is that
these type systems prevent us from there
so Kenna were planned for discovering
and in general recursion is to find some
expression that a type checker wouldn't
like and then go from there then we know
that we're onto something
yeah so we'll try this out with like do
some small expressions I have some
standard ml running here so we can
translate some lambda calculus to
standard ml and standard
will infer a type for it right so the
first one lambda X dot X is like a
function that takes an argument
understand argument yeah that's not so
controversial that's probably okay yeah
it gets this type the next one
functionally hey that's probably also
okay so get a - B - a
the next one should be like a - B - so
we kind of try to do like a real sign
expression that just has a lambda
reference we try to add some more
lambdas and kind of the other thing we
can try to add this function application
so we have like you have the simplest
case for a function application I
suppose so yeah it's a paste argument
itself and we get operator it's not a
function and it says circularity with
sort of smells of looping right yeah
this is a clue I think and we have we
could try this out in some other typed
languages and just like virus and they
complain about stuff and they say that
it's circular or that it cannot
construct the infinite type that sounds
good - yeah so things like they're sort
of uniform in the judgement that it's a
bad idea to have these things so
probably that's what we should be doing
that yeah the resulting type will be
infinite when unified memory of course
you do have recursion is in these
languages but not the kind of yeah so in
Haskell and effort and standard ml you
have and a built-in recursion and it can
refer to the function that you are
defining right that's what they're still
ruling out kind of the accidental Turing
completeness right so they have this
recursion using self reference yeah
right so that kind of gives us a
starting point we're going to do some
stuff with it so we have this function
here that seems kind of interesting
right yes and it's a function so we're
probably interested in like applying it
something you give it something and it's
so you get stuff like this you can apply
to like the identity function and we get
the identity function right well we're
still not looping very much okay so the
kind of the part where the type checker
doesn't like this is that this is the
function and this is the argument so and
it's one variable so it should be the
same type yeah and making a function
type the same type as the argument it
takes this kind of sort of infinite so
there's kind of self application is
going on there yeah so it seems like the
next step should be to apply to itself
right and we can see that we can go on
for like a thousand steps and again
yeah the same repetition at least yeah
so each line that is like one step over
evaluation right and you see that this
bit goes into this X and this X and I
get this expression back to right but
you stopped after a while because yeah
so they kind of MX record set up stops
after a thousand lines right that way
good luck go on for a thousand more and
right so now we have something that sort
of generates recursion or loops or it so
this looks like an infinite loop
it doesn't like do a ton of stuff beyond
being infinite right because it just
sort of reproduces and is end up with
exactly what you had yeah but one
interesting part is that even though
like this line and this line does the
same it's really this expression two
times in the line yeah so it's not
copying the line so it's not like copy
paste of the entire line
gotten two copies of this and the XX bit
is kind of the thing that makes it go
forever right so if we keep the XX bit
but like add additional stuff to it then
maybe we get like more copies of the
stuff right so we don't want this to go
for a thousand lines because then we get
checked really long lines right but we
can get like a ton of force right this
is very promising and it's very
interesting because you have this sort
of here you have this sort of dead type
checker emoji thing going on
yeah while generating all this
extraneous foods so if we could sort of
instead of who have our plus prime
definition right yeah so it looks like
we could get at least as many losses
with like from this stopping but so it
was something else
so if you go back to the lambda X it
would be nice to build some sort of
termination into food so that it stops
at some point yeah so if we kind of pick
up the plus function we started with and
we do like and X and X X and remember
you can like put the plus stuff into
there so we can cut this paste it here
right so they were passing this that
type checker along yeah which is what
generates the copies yeah so we should
get like a bunch of copies of this
expression now the other thing is that
foo has been given one argument there
which is full which has been given one
argument which is full that has been
given one argument we still don't have
anything to put here right yeah and we
don't want food waste the first argument
to the plus function because or we don't
want the plus function as the first
argument to the plus function right
yes right so we're gonna need some sort
of self reference right yeah so you have
something to clone
according to like this stuff yeah the
plus should be passed into plus as its
first argument but already have been
given its first argument which is Plus
which has been given its first argument
so right the self bit should be replaced
with like what you hand up with like
this stuff you're going to pass that
into to solve yeah so if you're lucky
this should kind of work right so we can
be like are we gonna check that out ten
five that's something that we didn't get
to in the oh we got like seven so you
can do like ten I guess so hopefully
this works okay amazing that's right it
worked but how how and why did it work
so if you could sort of step through it
a little bit you can thing take a look
at the beginning if you look at the end
we see that we have like accumulated a
bunch of what I do so it seems to do
what you would like going on there
maybe if you could just sort of mark the
expression that we're passing along so
if you do like right so the first thing
that you pass in is that expression on
top I can't really point to it but and
then you get two copies of that correct
yeah so the first step of a real a
relation gets you like you end up having
two copies of a plus function right so
you sort of clone yourself yeah and
what's the next thing that happens the
next thing that you pass into just the
acts well that's that's the same thing
also is that right
at this point is like reeling forever
I'm sorry what's happening what do you
usually kind of figure out right so
what's the next bit yeah I was thinking
about this line something something six
four six what was the step from the
second line to the third line basically
because you're passing in now you have
to another copy to you to X right to put
it into sort of the dead eyes of the
type checker yeah so those two ice yeah
[Laughter]
and then on the next line we have kind
of removed all the outside access and we
get to this plus function death of the
line 647 it says lambda and lambda and
if zero and right so which is kind of
the first function we started bed right
so basically the first three things are
self free mechanics I know it's awesome
self-replication stuff yeah and the buzz
function that has to replicated all the
same self-replication stuff behind the
add one bit right and then you're sort
of ready to feed it the numbers right
yeah so know the two tenths gets thrown
in and attractive and zero
yeah both so it's also a the ten and
dusty add one stuff on this line right
and then it needs to go on because
because it wasn't ready to terminate
yeah yeah and it ends up with the saying
like we need to add one to this stuff
that ends up looking at what we started
with
yeah so now we've sort of looped once
basically yeah except we have done like
sub one am so right okay this should end
up being nine instead of ten and yeah
when we have done that ten times should
check out the truth when we do the zero
comparison right and everything should
work so maybe we can look at how it
terminates then because that was sort of
also an issue yes we can go on to the
end
and you have up here somewhere there's
going to be something that compares to
true right it should be this one here we
go right so what's going to happen on
the next line because then it's sort of
going to throw away all the garbage that
you use - yes don't know it if true
return turn right which is sort of the
number that we started with yeah and
we're going to ignore this stuff so
everything after this won't be evaluated
on longer we'll just right so this whole
expression will evaluate - yeah so you
don't you don't have it anymore it's
true that becomes can we just do the add
one stuff okay so that seems good so the
I guess the next step now is that we
have like we might want to do this for
things that are not plus right because
how does our Plus look now I'm not sure
we even started it plus like we didn't
read the fine it right going to do this
maybe we should define plus sign yeah so
we have like dysfunction yeah and we
kind of made it into this thing which we
right
which we put in the middle of the lambda
X X X so instead of throwing this in we
can do like abstraction and say that
there's an argument called F yep and
then we do the lambda X X X lambda X X X
X all right which is what we had on top
right we have this yeah so this should
still work yeah
so this is our right but this is more
like a general pattern right because yes
another something else we could like
give this function and nice name and use
this for old stuff if we evaluate one
step we get this function which already
has some nice name right yeah this is
called symmetry here why it works the
same as the line above but it looks
nicer because it says a bit that goes
after lambda f looks more symmetric yes
you have sort of two copies already or
so so yeah you should be able to do like
pick this one up again
and pass this thing - why and we can say
that this is overpass function right
perfect
so now we have kind of a general pattern
right I think so we have sort of proven
now that we can do proper programming
because we could do this one example
from and we have like some more examples
that we're going to skip and we can go
to move right on to the real-world stuff
yeah I think because now we can program
but we still haven't got a job right
yeah so we won't like stuff that comes
up but in the real world job interviews
like this bus right yes
so we have another package that's it's
called real world it does stuff like
this so we get few lines of output sort
of we don't want to run the fist Buster
flag for ten thousand nine so we don't
you like super optimize some bits so we
can do this in one step and we have an
aquatic check built-in hand and we have
modulo which we're going to need and we
have side effects
perfect so how does print work so Clint
writes a line that says like oat cone
and yes the argument it was given and
then returns true ready it prints the
result of absurd into the pipe and then
it evaluates to true okay and it's going
to skip some steps of all this takes
like three lines if you do it like this
print is just going to evaluate yeah
okay so this is a mess this bit and it's
decided that should evaluate to it and
it prints it and it returns true and
since its returns true we can and a
print statement expression with
something else yeah so you can sort of
keep computing yeah so if so hand is
defined to be this if done expression
it will print this bit which evaluates
to true right because I'll print cause
evaluate to true and then it will do the
remaining it okay so if we're going to
do your face bus yeah so we won't like
some checks that we can do on numbers
right and like I said we have equality
check built in now and we have model oh
they can do like this right so that's
just checking if the number is the yes
yeah I need to check that it is equal to
zero so right five is divisible by 6 is
3 so this looks good
we're going to check check for we're
going to need 5 and 15 also yeah 15
right so now we have sort of some
primitive helper functions yeah so we'll
make a helper function plus help yeah
and it may just take one number and kind
of return this or bus service bus or the
number right kind of the line we are
going to print with the print command
right so this is good what you're going
to do to each number yeah
so you check if it is divisible by 15
first right and then you're gonna print
fizzbuzz and we just use free variables
that's the stuff we want to and if it is
not divisible by 15 we can do a check
three so this is beginning to look like
real world programming yeah so now we
have like three nested ifs that's yes
that sounds like something that should
get your job yeah if it's divisible by
five
you should get bus
and well if none of those apply then
it's just a number yeah so yeah
something like this we can test it on
some numbers it sounds correct the whole
thing should be 13 right mmm 13 should
be 13 yeah they're kinda turned 13
so if you do like print s be help 13
that should intervene and FB hope 15
this seems correct yeah and we have like
Y available available to do the
recursion thing right so we want to
we're going to call this F P Prime and
we're gonna do this for a bunch of
numbers right yeah so we want to like
count up from 1 to 100
right and print stuff so we do like if
101 is equal to n because then we're
done yeah if not we're going to use end
to evaluate both side yeah so that
that's going to print the result of your
helper function right so we print result
of FB hope yeah when we come to need the
cursor you need the self reference and
we do yourself and one right
so we can you think this is gonna work
it's really careless because some if we
mess up it just goes on forever so we're
going to define this place as Y with the
FB prime function as its argument and
we'll start us in a number which goes
into this first and we say we're going
to start at the number 1 and let's see
yeah and we got a line like 2005 now so
if you pay close attention you can see
that it goes I volt column oh yeah I saw
out for no I think there was not there
yeah well we can see the numbers right
yeah I saw 68 - no we're more than
halfway there yeah looks like we are on
track well I'm not sure you get the job
but you get like taken care of somehow
yeah we can work for the outs now yeah
so we started like here so we can do
like search for out one two this five
six seven eight yes yes so looks good a
little bit noisy with all there yeah so
we can also do like so delete
yeah this shouldn't be like the good
results everything seems to check out
and that's how you get a job programming
lambda calculus I think yeah in the
enterprise yeah yeah four minutes left I
think that's about it yeah did you have
a summer we're gonna just get back
oh we forgot to summary slide yeah
so kind of just to recap oh we got to Y
right
yeah we wanted things that went on
forever so that yes kind of we want to
go on forever subtype trackers are our
enemies right and because we want to be
sort of on demand just-in-time recursion
thing that yeah yeah they're kind of a
yeah yeah and we noticed that type
checkers tend not to like lambda X X X
and then we have sort of like this bit
could be used to make like yeah it could
go on for forever unless you stop it and
we can get as many rules as we'd like
problem in more than as many as we'd
like and then if you have some sort of
termination yes and if you do like a
lambda extraction around that and
replace the pool with nothing yet like
the function lambda f and if we avoid
that one step we get like the definition
of the Y Combinator so I think we're
yeah that's it like some links available
on llama the ultimate there are some
lambdas you can probably tweet these
things yeah there will be available
somewhere but if anyone wants like do
lambdas in the browser Nichkhun
get something like this so no stuff like
this and do these things online yeah
yeah not a number stuff I think that's
it Thanks Thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>