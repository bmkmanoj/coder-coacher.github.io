<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Into Production - Jamie Winsor | Coder Coacher - Coaching Coders</title><meta content="Into Production - Jamie Winsor - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Into Production - Jamie Winsor</b></h2><h5 class="post__date">2015-11-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_Fb2lQOKKVQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright so thank you everyone for coming
this is a talk about some learnings
about making an online gain and putting
it into production basically I make
mistakes so you don't have to my name is
Jamie Windsor and I've been building and
supporting online experiences for about
nine years my entire career worked on
games like guild wars 2 lord of the
rings online does the dragons online and
legal legends and most recently I was
building games at undead labs which was
founded in 2009 by one of the founders
of arenanet the guys that made guild
wars I joined up in 2013 and was about
employee 20 and now we're up to around
50 or so the first game that we created
was called state of decay it was
originally released on the xbox 360 in
june fifth 2013 and year one survival
edition which was an HD remake was
released on April twenty-eighth 2015 the
neat thing about this game it was
created with just about 20 people but it
was still very well selling and very
well received game with a bright future
of the franchise ahead of it which is
what undead's working on now and the
first entry as a company into the online
space which is what I worked on was
called moon rise which is a competitive
online real-time creature battler
basically it's a love child between
Street Fighter pokemon and magic the
gathering I know it's very hard to
imagine how that would work but it
totally does one of the best games I've
ever worked on nevermind played but
unfortunately made some poor decisions
around our meta game and we had to go
back to the drawing board but we did go
into production with it in a number of
different countries and early x on steam
and the tech worked and the tech is
going to be used in the future of the
company and that's we're going to talk
about today so moonrise was an iOS and
enjoyed a game at first and then
throughout development we realized that
we had an actually solid game you know
wasn't and this is no offense to anyone
that's a mobile gamer in here but a lot
of mobile games are really simple
they're not triple-a games and we had a
triple a game that played really well on
mobile devices and also on steam so we
were also building it for a PC Mac and
there was some Linux support in there as
well but didn't get put out to players
so the purpose of this talk is really
just to do two things which is share
some insight on what it looks like to
build online games for anyone that's
interested in building online games it
hasn't been before or something that's
just about to get into it and learning
from an infrastructure or somebody that
has had some experience building before
and operating them and the second one is
to share key learnings from that journey
specifically in elixir and the Erlang vm
and some things that really helped me
out and i wish i knew ahead of time
before we chat about that let's first
talk about some less technical
observations just about the online game
space as it is today so this was our
company's first mobile game and also the
first for nearly all the individuals in
the team to work on anything in the
mobile space prior almost all of us just
worked on massively multiplayer online
games or you know Warcraft one Starcraft
do you know like big games but nothing
in the mobile space and it's completely
different than a triple a PC space two
things that are just common among all
games are if you're trying to build a
competitive online game it's best
balanced with constant player engagement
you need to be going out and talk to
your players as much as you possibly can
and the more people playing it the
better and as the complexity of any game
goes up iteration pain interation times
must go down the problem with the mobile
space is that iteration is not nearly as
fast as it is on the pc and this can
only be done
through an extensive beta test yet
there's no such thing as beta software
in the allow allowed in the app store
instead a common practice in the mobile
games industry is to instead perform
something called a soft launch soft
launch is basically when unfinished
software is released in the App Store's
of countries with lower usage or
engagement you basically show up and
take a dump in Canada you drop whatever
you have currently Beta Alpha right into
Denmark and you're lying to your players
and what's worse is that these players
think they're playing a finished gain
and then they'll rate your game based on
the unfinished content and I'm not okay
with lying to my players and I just
mentioned that iterating on mobiles far
slower than it is on PC you will be
blocked by Apple's review process if you
bait on android apple won't feature you
later either so one of the things that
we noticed through developing this was
that steam provided us with the early
access program which was a much better
option for us to develop because as I
mentioned as complexity goes up
iteration times must go down and the
game that we were building was a trip
it's a triple a game by all means and
what was surprising about the early
access program is that there was a
surprising amount of player engagement I
I never used a scheme for him in my
entire life and I've been a steam member
since 2007 or whenever the ati radeon
card came with a beta code to play
counter-strike go I'm sorry kind of
strike source I never knew that there
was a giant community of people there
and if you listen to that active steam
community they'll provide you with a
hell of a lot better feedback then the
reviews do of your beta software in the
App Store and drawing people into a
forum that are on mobile devices is also
pretty difficult next non-technical
takeaway here is that perceptions
reality I had a hunch when we were
announcing moonrise
that if you announce the game as a
mobile game and it's also a pc game
people will never think it's a pc game
they'll just think that's a mobile game
that's now been poured into the pc
what's interesting is players really
enjoy having the mobile client option
for their favorite pc game we see that
with hearthstone hearthstone released on
the pc and the mac first and then they
release their ipad version and they
released the iphone version and that
same game it presented as a mobile game
first we met with a lot of vitriol so if
instead Blizzard said we're making a
mobile game immediately the comments
section of whatever form will blow up
players don't care and media won't talk
to you either unless you have already an
established franchise or you're an IP or
you have a long-running history of
creating triple-a games as an entity the
company as an entity so if you are
releasing into the early access program
something that I learned was that you
need to battle perception as a priority
for instance did your game release in
Korea first then you definitely have
invert mouse if you're not familiar with
korean games most of the time they don't
put invert mouse into the games they
first somehow as a culture don't use in
for a mouse and i don't understand it
i'm an invert mouse player what's your
getting built for the console first well
you better have direct input options you
know you need to have first-class pc and
mouse support and it can't be emulated
through the excel at the same input you
know acceleration you need to have
direct input or in the case of moonrise
were you a mobile game first did you say
you're a mobile game well when you go
into early access you really need to
make sure that your graphical setting
options are there you have pc hot keys
that are clearly defined and painted on
the UI and a pc friendly interface that
doesn't look like a ported mobile game
and this is true for anything that you
think you're going to have a perception
problem with as soon as you go to
release the game headed off of the pass
understand yes we're going to iterate
but if you are going to be putting this
on to the public space
no cut the low-hanging fruit and take
care of it early alright so that's
enough of the non technical stuff and
now from pretty much for the rest of
this talk we're going to talk about
technical stuff around elixir or scaling
games and findings there and so if
you're unfamiliar in the room about what
it takes to play an online game
basically a server hosted online game
has a couple things a persistent
connection you are connecting in a
stateful way to a game server or to a
proxy server to a game server well times
there multi-service we now have a
buzzword for this called micro services
but this has been an architectural thing
for a long time where game developers
know they need to have failure areas or
failure points or you don't want to just
take the entire game down to update you
want to have little small services
running and almost all the times they
have persistent storage so your
character your inventory you know your
chat history or your friends lists all
that needs to be stored somewhere great
examples of this are world of warcraft
or legal legends guild wars have
requests altima online most online games
today work this way with some sort of
persistent storage and some more complex
than others and this is all accomplished
through something called a back-end
plateau or a platform this is the micro
service collection they usually perform
authentication chat and presence which
is a I came online and purchasing so you
can buy something in the store player
storage matchmaking figuring out who's
an appropriate opponent for you based on
your skill level or in your area and
then there's administration tools like
kicking and banning players from the
game and things like that an example of
this would be battlenet if you ever
played a blizzard game we didn't name
ours and brand it at undead but it is
back there and will support any online
game that we have we chose to develop
our back-end in a lick sir some of you
here might be familiar with Erlang and
wonder why we chose elixir instead
especially since when we start
building this it was over two years ago
and elixir was at zero nine zero which
is three or four versions before version
1 and the truth is I was very happy with
early I had already known Erlang for a
while I had been developing in her
laying I really believed in the paradigm
the actor model functional programming I
began this is the first functional
language driver used and I liked it way
more than I ever enjoyed any object or
dealings though i was using prior i just
thought in a functional way but getting
others on board was really hard it might
be the prologue syntax it might be no
name spacing it might have been the fact
there's no polymorphism or i should say
paramedic polymorphism i'm not sure why
but i tried a number of different
companies to get people on board with ur
lame and to be honest if he asked me i
really just wanted a better standard
library for lying erling was released in
1998 and it's governed by a company it
feels a lot like Microsoft api's they
just kind of live around forever
everyone knows the good parts of the
standard library everyone knows the bad
parts and then you also will figure out
oh the parameter 1 is the iterator
versus the thing I'm iterating over
depending on what part of the standard
library you're in but the truth is that
the elixir team delivered so much more
than just a better standard library they
also gave us great build tools and two
years ago rebar to was out in its good
but mix was so much better and amazing
first class Doc's a package manager
which even works for erling now hex
polymn apero medic polymorphism through
protocols and implementations and
hygienic macros which is a very Lisp
like and I use elixir every day for
about two years running like I said I
started using it at zero nine zero
originally it was told to me that elixir
was
Ruby on the ER laying vm and I said why
would I want Ruby on the Erlang vm and
obviously it's definitely not what it is
or maybe not obvious to the to the room
but I can tell you it's definitely not
that it is a syntax inspired only at
that point but elixir is really easy to
get started unfortunately it's not so
easy at first to get it into production
and but it's brilliant once we're in
production so hopefully some of the
learnings that I have here these are the
things I really wish that I had just
heard of so I knew I'll go look at that
talk again because I remember this
person had this problem these are some
things I'm gonna save me a hell of a lot
of time before we talk about any of the
problems that we had let me first just
tell you about what the infrastructure
looks like this is a high level
landscape of the backend platform at
undead and the blue lines are reliable
UDP connections the red lines are fully
meshed nodes over TCP and black lines
are just TCP but not fully meshed
anything that's a purple circle is an
elixir server the brown circles are C
sharp or mono servers and then the
routers are fully meshed i'll tell you
about fully mesh in a second where the
chat server is below it are more like a
service server and you can see that the
chat servers don't communicate with each
other at all and then they connect down
to a database which is sharded 1 2 128
times the client connects into the lobby
servers the lobby server will and find
the client a world server to connect to
the world server is what you're walking
around in the game and then once you
enter combat you'll negotiate a
connection through the lobby to find a
combat server through our matchmaking
algorithm and all those servers are a
client of the routers the routers do a
special job to pass the messages off to
the services below and they do that
through deterministic routing so we send
a message of the router and we don't ask
it hey where's my chat server instead we
say send this to my chat server and then
the chat server will pick it up this is
not drawn to scale
the chat servers are that are there
there could be any number of them and
then there's other services well like I
said like account fulfillment so the
last screen that we saw let me break it
down and what it look what it translate
to an elixir project there's a protocol
library that contains the things that
serialized in DC relies on the undead
binary protocol I gave a talk at Erling
factory which tells you exactly what
that looks like but I don't think that
the room really liked it so you do care
about the binary protocol which I find
very interesting you can go look at it
but I didn't put it here because I
didn't want anyone yawning at me this
time then there's the common library
which is just like a junk drawer stuff
the routing app which includes itself
protocol in common a chat app which
includes itself and protocol in common
and then there's various other services
that if you look at that or link
factorytalk I go through those as well
and we can chat about them at the end of
this if you if you want to if you want
chat so the routing service job is it's
a gateway into the back end is a client
to the other servers it has a ranch
listener which speaks TCP it speaks the
undead serve binary protocol and its job
is to disconnect misbehaving clients
rate limit them drop any hanging
requests or partial TCP connections and
forward messages across to these
services that actually need the message
and then to relay the message the reply
back fro that message to the requesting
client so reading a routing message
looks like this we read data from a
socket into a buffer we stop when we
have reached the message given length
which is located in a header of the
binary message it says you should be
expecting this amount of body length and
you should be expecting a binary portion
that explains it as a transaction or not
a transaction and some routing
information if its present or not once
we've read the message we
then tag it we turned it into a Erlang
struct I'm sorry an elixir struct and we
tagged the message with the pit of the
route acceptor this is important to note
because as this message now goes through
the system to any one of these machines
you can send a message to that pin or
reply to that message and it knows
exactly how to get back to the client
because wherever you sent it it has a
connection back to a fully meshed routed
server and all the routing servers know
about each other right so you reply to
that message and it bounces all the way
back to the client it truly feels
magical if you've ever written us
infrastructure like this in C++ or C so
much work is done for you in Erlang and
an OTP in the Erlang vm in OTP so this
is receiving a rounded message basically
once the router passes it off to one of
the service nodes it internally
dispatches that request to the
application performs some sort of work
and it replies to that message if it was
a transaction if it wasn't then it does
nothing and optionally if anything needs
to be retrieved or saved in a datastore
we save it with ecto which is an
integrated query language for lik sir
into postgres ecto and phoenix are two
very popular Alexa libraries right now a
lot of tutorials on the internet will
get you working with both of those ecto
has come a really long way I started
using it when Eric had just committed
like the first 10 commits and pushed her
to github and it was already usable by
the way like this is it's pretty damn
solid software that I use something well
before alpha and bet on it and talk to
the community which is just another
great point of elixir is that the
community is really engaging and the
people that are working on these
libraries are very open to discussion
and they really want you to succeed
spend a lot a lot of time talking to
jose a villain the guy who created a
lick sir and Eric who's the author of
ecto and the postgres data connector
and they did a hell of a lot of work for
us to scale our application out would
connect to our cluster at well there
Joe's a zit in Poland so I get online at
night and he come on and check it out
and he was really really helpful so it's
a super great community here as well so
the Postgres database is like I said our
sharted we do that through a postgres
schema a postgres schema is just a
replica of the same schema that you
would have if you were just using the
public one but it contains different
content is a different bucket we pre
shard the data into X buckets X is a
power of 2 in this number in this case
128 if we ever need to increase that
then we'd have to reach our the data but
we're probably never going to use 128
shards on X amount of nodes in this case
there's two nodes there could be 128
chat server nodes and 128 chat database
notes or there could be in this case for
22 database notes and one of the neat
tricks that we use here is to embed the
shard inside the entity that you
actually created so this is a wallet
text and I know that but basically this
is the the sequel a sequel snippet on
how to create an ID that contains the
shard you err on the time when it was
generated so you can figure out in a
monotonically increasing way what when
that content was generated and that's
just embedded into the ID itself so if
you had a account created it know you
know that it was on chard for for
example because it's embedded inside
that ID and this is actually a trick
take from Instagram and it's a blog
called sharding IDs at Instagram the
whole link is really long but if you
just Google that you can see the whole
explanation so this is great you know we
have an app running we have the we know
the infrastructure and we'll just fast
forward maybe three months to a point
where we're now trying to take that
and put it into production and the
problem with elixir or Erlang apps is
that the release story is is rough
literally the hardest part of the whole
thing making this app was that you know
how does it work on it works on my
machine how does that fit into
production so the first thing that
you'll read if you're reading blog posts
is to just deploy your source code onto
the note check it out a github run mix
compile on the node and now you're good
you have everything you need and
actually unfortunately the build tools
really support that they want you to do
that but don't deploy source to a node
in compilat rails users use this as a
practice a lot of web programmers uses
in our practice which is why you might
read this because Phoenix is such a
popular library but you risk a number of
things you put the source code in the
node one people can come take it too
it's not a reproducible artifact so you
could just have some weird thing that
you didn't know about it's just
happening in your production environment
and you didn't you didn't test that
artifact so what you want to do instead
is create a release this is still my
least favorite part about or laying an
elixir the user experience is just too
arcane i read a blog post once and it
called this dark magic you know like you
just got to get Sylvester Stallone
dressed up like Harry Potter to make
your release for you that's a real
picture on the Internet this is a few
ways you can create a release is rel
tool and some other old janky shit that
you could use from era laying then
there's relics which the same guys that
made rebar worked on and it had two
awesome there's exr m which is probably
the quickest way to get started going
unfortunately when I was building
releases this didn't exist at all again
I adopted it super early and the
figuring out releases was up to me so
the ex Rams nice way to get started it's
a little opinionated it thinks that
you're going to go on the machine and
edit config files that are human
readable
and you can do that or you could use a
tool to automate it and really all it's
doing is calling down to relics which is
Bioware and this is actually what I use
to create our releases I could
transition a TX RM especially as it's
getting more mature but I think it's
important to know how releases are baked
down in case you run into a problem with
exo-m or if it's not doing the thing
that you need so let's look what's in a
release this is stuff that I really wish
that was just all condensed for me to
consume when I first came into trying to
write production level applications you
can think of this like a manifest and
files to be given to the virtual machine
on startup the optional components can
be provided instead by a configuration
management but they're required to start
the app at least so those are the things
that say optional all you compiled
applications and they're compiled
dependencies come in to release the boot
scripts which is the thing that tells
the vm how to start up and how to get
all the content of your release started
control scripts start stop restart and
then those three optional bits are
things like it like I said can be
included or you can configure them on
disc sis config configures things like
the IM you can include other config
files and you can figure things like the
listened ports for the Erlang port
mapper damon i'll talk about that in a
second then there's the vm args which
are things that you can like turn
polling on or SNMP support you can set
your early node name and then Early's
can contain all so many OTP applications
and this was actually pretty unlocking
when I had figured this out that one app
doesn't need to go in one vm that
ideally you want to run one vm and put
all the apps in it so you can actually
create a release that has all your
all your applications if you want and
create various flavors of your release
and then what's in an OTP application is
important to note too because you can
have many of those in release basically
an OTP application is a group of related
code and processes it's wrapped with OTP
specific behaviors in a specific
structure so that way when you pass a
boot file to the contents and the vm
knows exactly how to start it and knows
how to supervise it is the entry point
for your supervisor tree and it informs
the vm how to setup and teardown that
application i think it's helpful that
you'll straight illustrate what an
application a library look like in
elixir terms this is a library it by
itself isn't an application but it
requires some that are started in the vm
and we state them here under the
applications key value or a list sorry
and then this is what an OTP application
looks like a mix it's called my app
which maps to the maya module and
implementing the application behavior it
also has some dependencies that needs to
be started and you can see those in
applications as well so longer and
crypto are required for this application
to run as well so one of the first
errors that I saw when I first created a
release for elixir was module not found
and I could not figure it out because
it's clearly there it's working on my
machine I make the release and somehow
the module is gone and it's because if
you don't list inside your application
what all the apps are that you require
they will not get packaged in so given
this mix exs file if we wanted to
include an application called discovery
as one of our dependencies you need to
make sure it's in that list or you'll
get module not found even if the
application is not required to start it
would need to be in that list there's a
way to do it without starting the app so
for instance we just need to make sure
we have the funk
shins for discovery in relics there's a
way that you can say I just want to
include this but just load it don't
start it and that's in the relics
documentation but you can specify if you
don't want to start a nap just a local
on then configuring release an elixir
which should i use there's these three
different files this was a little
complicated as well mix axs is the thing
that we just saw and that's how you
would configure your based application
then config dxs was added which is the
syntactic sugar on how to configure a
nap and then there's sis config which is
that little bit I told you about the
beginning which is an erlang tile that's
or laying terms in there and they all
take application configuration so config
dxs is the pathway that elixir exposes
encourages its easiest to use and
understand uses elixir syntax but it's
not respected at all by the release
tooling and that's really sad because
it's pretty damn nice to have that
syntax and it's a lot easier to read the
articles about it so then there's a mix
ESS it's another pathway that it looks
or exposes also uses the elixir syntax
useful for setting the default
configuration for your release pretty
much you can't change us at runtime
basically it's respected by the release
tooling and it's only useful for
configuring your applications not the
dependencies which brings us the last
one which is the one that I find most
useful which is inert like I said an
erlang term file so unfortunately
anybody configuring the node needs to
know earling if you are using a xrm
there's a different file format that you
can use as well but you use this to
configure the deploy applications and
unfortunately this isn't exposed in any
way by the elixir tooling so deploying a
release out you've gotta go to choose a
solution
going to create something pretty much
you can need for parts and then the ones
that I prefer you need a build server
use Jenkins chef just came out with
something called delivery just launched
it yesterday I would definitely look at
that over Jenkins I use it every day and
it's absolutely great the artifact store
you use github you need some sort of
configuration management tool I You chef
and you need a hosting solution
somewhere to run this stuff I think
eight of us is a great choice so once
you've downloaded and extracted or
artifact configured your app you go to
start it and you still need to run the
database migrations so your instructions
if you read a blog article would be to
change directory into the thing that you
need and run mix ecto migrate the
problem is that mix tasks are not going
to be included in that release
migrations are packaged and put in the
database node but an ecto migration
requires the application code and it
requires a start your application so
what could be a problem is if you deploy
this out on to a database node and then
you go to run your migrations it's going
to try to start your application so on
your database no now you have another
application running and if you have
auto-discovery enabled like I do now you
have this temporary server that pops up
and people start trying to log into it
and then they're like my accounts gone
and then takes you all day to figure out
what happened so basically I would
package up my migrations in a separate
package put them out on the database
node and then don't use mix to start
them I instead created this thing called
migrator which wraps ecto it's a CLI
binary use for performing database
migrations it won't start your
application and it doesn't require all
your code it does the very simple job of
running your migrations on your database
node another neat thing that it does is
it provides you with multi schema
migration which we needed because we
shot at our data 128 times and that's
how you run it you just type my greater
up with a path to the migrations with
the postgres connection if you chef I
made a useful cookbook that all
abstract all this away for you and
that's how you would use it if you're
familiar with chef so if anyone goes
back and tries to write this schema
stuff at home by the way you're going to
wonder how did I actually access data
because once we've got the stuff
migrated by default if you're using ecto
the query language doesn't doesn't
expose anything about schemas that's not
entirely true it was built in with this
prefix option which is now the code
above it is what I wrote which is a
small wrapper and it's just about to get
into ekdum main at this point but just
be aware that if you are working with
schemas that there is support and ecto
now or there's about to be and this is
how you'd go about it so I talked about
a fully fully meshed versus non fully
meshed fully meshes when all the nodes
connect to each other and share
information with each other so if you
connect the routers together you add
another router they all try to connect
to each other the problem with that is
that by default or laying nodes connect
together and if we have 128 chat server
is 128 account servers 128 routers once
you get past 100 150 connections they
they just can't sustain and this is what
that looks like basically you have
yourself a dumpster on fire with wheels
at scale you just you can't possibly
connect that many nodes together so
instead you want to find your way to a
partially meshed cluster cluster so you
have the routing service connect to each
other and then from there they connect
out to the guys below them and nothing
but the router is fully mesh and you can
accomplish that by using hidden notes
hidden nodes you can start that I'm
sorry you can define something as a
hidden node with the hidden vm flag you
can figure that in vm de args or on the
command line we apply it to all our
service nodes there's some downsides you
can't use the global processes you can't
leverage libraries that use global
processes and you also need to manually
connect notes together which brings us
to our next problem which is from
connecting nodes manually that's a lot
of time or you can use this library
called discovery which automatically
discovers and connects too early notes
this leverages console underneath so you
do need to run a console cluster console
uses a gossip protocol to tell each
other about things and this is also how
we accomplish the ability to figure out
what nodes service what shards so we got
all that running things are
automatically connected but things
aren't actually talking to each other
nothing's connecting and that's because
you just don't have the right ports open
so we were running an ad of us
everything's running but again not
connecting so by default the first thing
we will look at is the early appointment
for Damon and the port mapper Damon does
a job of telling VMs where other
connections are other via other VMS are
running so by default the nodes need to
have 4369 you can configure that as well
but that has to be connected between all
the early notes after that you need to
set the inet dist listen port for range
for a min and Max and then open this in
AWS as well you're going to want a
couple 100 probably a couple thousand
depends on what your needs are and the
range is configured in the SIS config so
we got everything running next things
bottlenecks this is the first thing
you're going to find if you ever write a
large earling applications you probably
wrote a hell of a lot of them and the
general tips to avoiding bottle process
file mix are avoid register processes
when possible another one that I ran
into is 141 supervision with transient
restart strategies is basically another
form of a registered process or a
process bottleneck really think to your
children need to be supervised or not
and then find them use the observer so
this is a contrived example of what a
process filenet looks like on the Left
we have one client talking to a listener
and the listener talking to a dispatcher
and then out to a user process and then
back up the red thing is the process
bottleneck if you have a request come in
you want the data flow to go straight
out and then straight
back out I'm sure that anyone that's
seen erling presentations is seeing a
much better version to this graph before
but you can find these really easily
with a tool called the observer you
start the observer with this function it
pops up a screen like this you can look
at a running list of the applications
imbue its entire supervision tree that's
what this looks like you can look at a
list of processes get process
identifiers you can look at the amount
of reductions and memory and message
queue stuff we'll talk about reductions
in just a second and that's what this is
you can get information about the
process like when its current state is
what it stack traces that's this and
then what you're really looking for is
low reductions and an empty message
queue reductions this was a hard one to
figure out so thank you all for putting
this on the mailing list and then me
reading it in the wayback machine
basically elixir processes are scheduled
on a reduction count basis a reduction
count is roughly equivalent to one
function call and a process is allowed
to run until it pauses by either using
receive or yield or until it has
executed a thousand reductions or so
this depends on the scheduler so I think
unfortunately I'm out of time I have a
whole section about the scheduler in
here but I'll put this online and I also
gave a chat including the scheduler at
elixir cough and this whole end of the
talk is online for the elixir conf 2015
talk so I'm so sorry that I blew out of
my time today but thank you very much
for coming and if you really want to
talk about the scheduler you can come to
me after the talk again I was Jamie and
thank you so much for having me here
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>