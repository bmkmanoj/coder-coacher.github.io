<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>David Nolen - A Practical Functional Relational Architecture - Code Mesh 2017 | Coder Coacher - Coaching Coders</title><meta content="David Nolen - A Practical Functional Relational Architecture - Code Mesh 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>David Nolen - A Practical Functional Relational Architecture - Code Mesh 2017</b></h2><h5 class="post__date">2017-12-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nbMMywfBXic" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">here at consultancy called cognitive
cognate act it's you know we work with
various clients and the CTO of contact
is Ricky who created the closure
programming language which is a modestly
popular functional programming language
for the Java Virtual Machine at cognate
act we sort of our philosophy is that
there's a lot of accidental complexity
in modern software development and that
one way to address that issue is to sort
of embrace simplicity we sort of adopt a
viewpoint which I'll dig into a little
bit more detail here but there's this
paper call out of the tar pit which
we'll talk about a second but you know
this idea that simply you know people
talk about simplicity they come up with
all these ideas and you know we're kind
of we have a very narrow definition our
definition is that in order to build
simpler systems you really have to
embrace more management over state you
can do this through mutability immutable
data structures so closure is a is a
programming language which I'm sort of
innovated it took like this sort of
theory of persistent data structures and
came up with ones that were
significantly more efficient based off
of research by Phil Bagwell a whole
programming language designed around
that that eventually got there's a
compiler for closure to JavaScript
called closure script I'm the lead
developer of closure script so we all
the persistent data structures that are
present in closure were ported to
closure script and they work very well
on modern modern JavaScript virtual
machines because most of the innovation
techniques around the JVM made that made
their way into j/s engines as well and
then we have something which people
probably haven't heard that much out of
outside of the closure community except
in passing which is de Tomic there's a
kind of stuff to talk about with around
atomic but I don't have like you know
eight hours so I'm gonna have to be very
narrow and very specific about that but
basically we build systems where
basically each major component of our
stack embraces this sort of immutable
approach to software and we believe that
it allows us to for
focus on the hard problems right every
domain that you have has hard problems
but at least by adopting this approach
to software the typical issues that you
run into we can at least mitigate those
so this is sort of like a system level
talk I mean again I don't have time to
dig into all the things around the
atomic the atomic is very cool
technology but I'm mostly interested in
tech Tomic with respect to its impact on
building practical system all right so
des Tomic is a very practical database
it's used at companies like Netflix
Facebook you know big companies use it
it's it's a practical component in
whatever application you're building and
it's very much focused on being
practical
so this is a sort of again a system
talking we're not I'm not going to talk
that much about programming language
this is really about when you're
building this typical sort of
distributed application where you have
clients the clients run JavaScript
whether that's you know native and
that's Android or iOS or it's a web
browser you have to build some server
component and some whatever language you
prefer and then you have a database
right the sort of three critical parts
of any system and then of course you
have all your other services but
whatever these three are extremely
important and very typical so this is an
image of a tar pit I believe the
original artist is Charles right this
image is I think pretty well known
amount software engineers because it's
on the cover of Fred books essays the
mythical man-month the tar pit is a it's
a really great analogy for modern
software development because the tar pit
you know you have you know some mammal
gets trapped in the tar pit and they're
they're they're and they're starving and
you know they're they're stuck there for
a week and then a predator is like oh
this is gonna be easy I'm just gonna
jump in there and eat this eat this
mammoth it's stuck
then it gets stuck and the buzzards are
there and they're like oh I can eat I
can eat them mammoth and the taiga
saber-toothed tiger and they get stuck
it's a big mess right so this this it's
a but it's a good analogy for software
in the sense that you know often when
you make a decision it's hard to see all
the other things they're going to get
entrapped
by that particular decision again this
book I don't think I'm not going to talk
too much about it what is interesting to
me though is this paper which is not a
response to the mythical man-month but
Fred Brooks is paper no silver bullet
where he's talking about there's no easy
answer to the the quote-unquote software
crisis but Ben Mosley and Peter Marx or
Haskell programmers they've spoken
before here at code mesh and they have a
they published paper about eleven years
ago in which their thesis was that what
Fred Brooks says is the central
complexity isn't really a central
complexity that a good amount in their
experience again their Haskell
programmers even in their Haskell
systems a lot of the complexity of the
systems are building arise from sort of
a undisciplined approach to state and so
they outlined this thing called before I
get to that before I get to what the
thing is called so they make a really
great point again these are these are
people of the sort of typed functional
discipline and they make this amazing
point this is this this quote is
actually often incorrectly attributed to
rich icky because rich icky did this
talk called simple made easy where he
was like you know what happens when your
programs fail well that means that means
whatever issue you had passed all your
tests and it passed whatever type system
you have in place and people were like
oh you're talking you're talking badly
about type you know test-driven
development you're talking badly about
types but actually he was just
rephrasing something that's in this
paper which is that you know given the
choice between testing and reasoning and
by reasoning they mean whether that's
reasoning power given to you by a
programming language with a compiler or
whatever but the most important property
in any system that you're gonna build is
simplicity it's really their quote that
simplicity is the only thing that's
really gonna pay dividends as you have
to move from I'm building a new system
to the long tail of having to maintain
that system and again they're there
their thesis is that fred brooks has
claimed that software is inherently
complex is not true of course it's
complexity needed to the domain but a
lot of the complexity that gets
introduced into software system is our
own construction in fact most of this
paper they're sort of apologizing for
being quite boring
since most of the advice they're giving
you is been known for at least three or
four decades okay so they come up with
this term FRP you may have heard of FRP
before but you're probably thinking
functional reactive programming which is
pretty hot these days with languages
like elm and other people adopting that
technique with a new I work with
languages like JavaScript but they're
not talking about functional reactive
programming they're talking about
functional relational programming and
what I really like about this paper is
this paper is not particularly dogmatic
with how one might go about doing this
in fact it becomes very clear upon
reading this paper if you haven't read
it I highly recommend it read it out of
the tar pit but that it can be adopted
in any in any system it requires no
particular choice of any particular
technology by functional they don't mean
you have to use a functional programming
language you can do this with Java you
could do this with JavaScript but to
basically take sort of a functional
mindset and to you know is you know
limit the amount of state and then you
might say well how is you know is that
really practical and I would say well it
may not necessarily be but I think there
is kind of a big change in the
mainstream and we'll talk about this
specifically around react in which that
actually a lot of JavaScript programmers
are actually now very functional whether
they're aware of it or not so I think
now is a good time for some of these
ideas to gain traction relational is did
this is their point in which that when
you build a system you're sort of define
your essential state and you're sort of
a central logic and they they point out
that one of the hugest drivers of
complexity
besides state state is definitely like
the biggest but it's that we often don't
take a declarative enough approach to
solving our problem and specifically
they talk about you know they have this
nice diagram on one side on the left you
have accidental state and control which
is basically all that stuff is about
performance and maybe some convenience
and caching and all that sort of stuff
but this middle area is what you want to
do a central state you want to define
that a central logic and you really want
notice and most of this is relational
they won't you want as much of the
system to be sort of oriented around
queries and not around writing
system code and then they have this
thing called other which is which we'll
talk about they actually in this paper
they didn't have a particularly in-depth
answer which is well where does the
state come from and this is gonna come
from users that's going to come from
interactions right UI is is definitely a
big place where the data comes from but
so they present they paint this really
nice picture it's the aunt you know they
say they say kind of say this is a way
out but you know and they talk on the
mainstream it's really quite different
you know so you so people say oh we're
we're we're doing TDD or we're using
Java we're using like you know we're
building a component like system or
they're all this engineering stuff right
we have all these interfaces all these
classes and and really in the end none
of that stuff really matters because
what's actually being done in the
mainstream is what we at Cana Tech
affect affectionately called plop plop
is a very technical term its stands for
place oriented programming right so it
doesn't matter how much abstraction you
create you if you build a stateful
system your ability to reason about that
is greatly diminished this is why people
sit around and debuggers all day but
because they have a stateful system that
they can't actually reason about at any
sort of higher level than being in a
debugger and trying to unravel how their
program ended up in a particular state
this is another another very technical
diagram this diagram could be used to
represent your front-end component your
back-end component or any really any
other part of your system right so who
cares what these things are generally in
the mainstream again it does not matter
where you can take this diagram put it
anywhere and it's gonna look like this
you have some component a in some
element of your system and it's stateful
and so when something goes wrong where
where did it go wrong did it go wrong
you know in this this first part of your
system did it go wrong in the second
part of your system did it go wrong at
some third party system and the thing is
when the problem occurs because your
system is stateful you have no idea you
have no idea and then there's a long
week of just being like trying to reduce
it down to a minimal case to remove
whatever assumptions you have about the
behavior system because again you have
something that you can't actually reason
about because state is not linear right
every time you add a stateful
opponent it's at least extending the
state space in an exponential way so
something else they they talk about
which I think is extremely important but
these are sort of side notes to the
state thing but they do they do they are
related to the kind of the points I want
to make about the atomic one is
subjectivity I think you know everybody
knows the power of distraction but I
think something that people don't really
understand about abstraction as
abstraction is subjective right right
you you your urine urine your in Java or
urine and you're making an interface
we're gonna ask me you make a type class
well that's just your idea that's your
choice and in fact you've now imposed
something on to anybody that wants to
consume whatever a choice that you may
and this I think is extremely difficult
you I would say it's almost impossible
to vebber and you've been doing it so
long where you have at least some taste
and likely you know how easy it is to
get it wrong but but this does affect
the design of a system or an
architecture right so one of the one of
the biggest issues is that you have
clients or you're building some sort of
system you have a client and then then
the backend people design some response
and there's a bunch of problems with
this right because you've designed a
typical response the client doesn't
really have any query power all they can
say is I want this many pages I want
this sorting that's all they can say so
what you've what you've then delivered
to them is the subjectivity of your
decisions right they are now stuck to
whatever you thought was a reasonable
thing but that's not it's not possible
for it to be reasonable because they're
building a UI and there's no way that
you could have made any choices that
were correct for whatever the UI needs
the like that is extremely low so then
they have to take on the sort of
accidental complexity of the fact that
your response does not match what they
need the other thing is that you that
you that you encounter in in these sorts
of systems which is everybody's building
there's I don't I mean I can't remember
the last time I didn't work on a project
where people were doing this is that now
the client has basically there's there's
path dependence right the relationships
are hard-coded the front end now has
passed
pendens right they have to know the
structure of the thing I mean it's
because of this problem that whether
you're at when you when you go the
conference's and you listen to people
what people do they they now say things
that you're no longer allowed to do
versioning I mean really really it's
over people don't even version api's
anymore the rules are you mean that you
can never change your name you cannot
change the structure you can't delete
names you can only add new information
right because that's the only thing that
won't break the universe once you've
made a rape eaj and you have clients you
have no ideas consuming it whether
that's internal to your to your to your
company or not you have no idea who's
consuming it and you have delivered
something which is path-dependent right
and you can make no choices that won't
break somebody and so this I think this
I think people do not take seriously
enough
how subjective API decisions are and
there's this amazing thing and that's
what they're talking about this paper
relational algebra get you out of path
dependence right if you deliver query
power some restricted set of query power
now now people can write relations and
they are no longer tied to whatever
arbitrary decisions you made which are
most definitely not the right decisions
the other thing that they point out
which is I think yet another thing but
that's data hiding and data hiding for
me is yet another typical sort of
abstract abstraction thing that people
like to do that really delivers zero
value but we can argue about that later
at the party okay so so I've been doing
front-end work for a very long time and
of course I was I started off with sort
of the object-oriented persuasion I
enjoyed it you know you're you're you're
young you do this a lot you're like god
this is fine this is fine this is fine
and then after about ten years like this
sucks because because you you realize
that that you you read these old about
these these approaches and everybody
says it's the right way you buy the
books you read the books you build a
thing and then you're well this isn't
doesn't actually work that well it's
just a lot of effort there doesn't seem
to me that much
there doesn't see me that much big
deeper thinking around this stuff you
know it's all sort of I don't know it
all feels pretty ad-hoc and so I was
feeling pretty bummed out about about UI
programming after
for about ten years and then I was like
we're never going to get out of this
this tar pit it's just really this is
this is the state of the arts pretty low
and it's not going anywhere
and fortunately something has happened
which is quite surprising to me
especially having followed the
mainstream for a long time which was
that at Facebook a single developer
named Jordan walk was building a
traditional MVC style thing application
of Facebook and he decided this sucks
I'm gonna do this crazy thing where I
make a virtual Dom and I'm gonna make it
so that I have a mostly functional API
we're gonna present a JavaScript nice
JavaScript object a layer but the whole
thing is basically to be functional he
was a no camel developer and he got it
was given six months to try this it
turned out the thing that he built was
at least at parity in terms of
performance and they built a thing and
then they announced it and this is
actually it wasn't being used that Mitch
used that much of Facebook Facebook had
a sort of open source initiative and
they they talked about it and you know a
small number of teams and then actually
really react exploded outside of
Facebook react you know really it had a
rough start because it had something
that programmers hate which is like xml
literals nobody likes xml literals and
fate and facebook lunch react with that
sort of thing as this sort of
distraction anyways my friend said hey
actually it's cooler than how it then it
seems you check it out and what i what i
discovered was that for the first time
and you know I've been doing JavaScript
professionally since 2005 for the very
first time somebody had written an API
which was functional meaning that it
could be adapted trivially with to a
functional programming language I had
been developing clojurescript
leading development for about two years
and basically everything that we
integrated with was stateful just a
typical stuff so there wasn't it was
really not much of a no benefit right I
would you you'd be using closure scrape
you have all these immutable data
structures but then in the end you have
to integrate with angular or ember or
whatever these things that are mutable
so what benefits were you actually
getting you were just writing JavaScript
with the function of programming
language no benefit but react did
something significantly different which
was that you could drive react with
immutable data structures you could have
some sort of tiny bit of state which is
a which of the route you could sort of
treat your entire application state as a
based on the client right this single
single global store you put everything
there and then basically the entire UI
can be a function of what's in the
global store and you can just render it
of course you do a couple of tricks to
make it be B for optimization but that's
all the accidental stuff that then
Mosley and Peter Marx was talking about
you could like react lets you do go
fully functional samman the semantics
are very functional and you have it just
a tiny bit of state and and the results
were pretty astounding
like with in like the data yeah in less
than two weeks or exactly two weeks I
was like well now that I know that I can
drive a bill to react UI that from
clojurescript that's mostly functional I
was like I miss being German by
functional data structures I wonder how
long it would take me to do like a time
traveling UI which is an object oriented
world it's it's really annoying you you
basically you have to reify are all your
commands you have to like keep that
history and it's really annoying
I mean it's definitely more than ten
lines of code and I was able to write
this in ten lines of code because the
entire state is in is an immutable data
structure I could just keep a list of
the states of the app and you could go
forwards and backwards other people were
like oh well you could do tree undo all
that stuff right that stuff is as
possible again because the UI is just a
function of whatever the current state
the application is and this I did these
two posts they were the most popular
posts ever written and I'd like to think
they helped kick off at least excitement
about react outside of sort of
functional programmers anyways so back
back back to my point so the point about
react is is that there's now a large a
very large segment of the main stream
which understands functional programming
whether they know it or not right react
you design a thing you basically have a
view you have pure components you pass
props props is supposed to be just a
value right components you activates not
just take a value and there's a direct
mapping from the value you pass in to
the thing you see on the screen so they
already know this react only has one
official API for doing something
stateful and people know to restrict
that only to sort of the root of the
application or in
Porton roots it's called set state so
react fundamentally encourages a UI
programmers to be much more restrictive
about state other other important things
that it does is that it makes event
handlers be mostly a stateless right so
if anybody I've been doing whether it's
whether it's like you know Java FX or
Java swing or our web stuff when you the
fact that you have to add event handlers
that's a stateful operation right you
you have to add and remove listeners
right even the most basic thing in order
to get anything done in the UI where
Christ requires stateful operations but
the way that react works event event
listeners aren't stateful you don't have
to manage their lifetimes which is
extremely awesome so can we take this
idea so my question is when this talk is
what happens when we take this very nice
discipline thing and say why don't we
just do this everywhere my cognitive
we've been doing this now for probably
was with clients for at least actively
for two and a half maybe three years
these are the types of systems that we
build for clients so instead of doing
this thing where there's a tar pit of
your database which is some mutable
variable in the sky some programming
language is immutable and the server and
some mutable mess on the client we
replace these things right so with react
you can you can just be like actually we
want to we want to simplify the client
we don't want to have to we want testing
to be easier reason to be easier
we just want something more maintainable
you can do that now you can choose to
use Haskell or oh camel or Erlang or
whatever and you top that on the back
end and you know our experience is that
prior to day Tomic is that you know this
is all nice and it does remove a lot of
problems but in the end you still have
this problem of the DB being a giant
mutable thing and when something goes
wrong you're there it's even worse than
trying to debug something client you
don't have a debugger it's all
distributed you're like what's going on
and then hours later maybe you figure it
out maybe not so the atomic is just a
different approach again add atomic is
not I would say it's not like okay we'll
get into its properties but real
our goal with using these three
technologies is that again clients are
building sort of typical stuff like
something in the past they would have
used you know PHP and JavaScript and my
sequel so all we want to do is replace
those three things with something with
that's again embraces the mutability and
that's what we do a cognate tech but des
Tomic is is actually again it's it's a
it's a it's not it's now it's now
language agnostic there's a client
protocol I'm only going to talk about
that briefly but you could do this you
could actually build a functional
relational architecture on now with just
no js' and you could use the various
functional libraries there and you could
use react and you could have the same
thing that they're talking about in out
of the tar pit so when they talk when
they wrote Harper they said there's no
practical off-the-shelf technologies to
do this but at but again in 2017 there's
a massive number of immutable data
structure libraries and functional
libraries for JavaScript react you just
you know it's mostly functional in the
front-end it gets you to many different
interesting clients and then des Tomic
is just replaces this notion of having a
mutable store on the backend ok so let's
talk about the atomic real quick what
are the properties of the atomic again
and this is going to be very truncated
I'll list them talks to see at the end
it's acid it's relational
if you're taught if you're interested in
the right scale then the atomic it's not
somewhat you know what you want to use
it's not it's not what it's for if
you're ok with the sort of ballpark
performance of my sequel or Postgres
you're fine it's immutable so this is
what we're adding is we're bringing to
the table and we'll see that uses data
log queries and rules which are nice
this is just kind of an affordance it's
just an ergonomic thing after having
used it day time like for a while
data log queries and rules are pretty
cool but I'm not gonna have time to dig
into that
and it's now programming language
agnostic so about two years ago I
started working on a on a JavaScript
client and we also have the beginnings
of a Java client so it's just over HTTP
we use transit which is a transport
format that we use and it's possible to
make very I do
maduk bindings to de Tomic I'm going to
show you show it to you in closure
because that's what I actually have
fully working but there's little
snippets of JavaScript so you could get
a sense of what it would look like in
you know option or any programming
language all right a whirlwind tour so
again the thing that I want to point out
here is I can't dig into every featured
atomic is it has a lot of features we're
mostly I'm most interested in describing
what are the ergonomics if you're
building a system get a sense of what
they're like okay so here we have I have
a closure repple fired up and I'm just
gonna go through just some high-level is
this big enough maybe the lights maybe
they should it possible to dim the
lights or maybe maybe I should just
switch the invert yeah yeah one second
it's a yeah okay theme default okay okay
there we go alright that was easy okay
so I have a repple here so I'm going to
just demo some quick things I don't have
time to like dig into every feature of
the atomic but just like some high level
stuff that affects what your experience
is like when you're building it out so
I'm gonna make a DBE
I'm gonna create it I'm gonna connect to
it I'm gonna I'm gonna set up a schema
I'm gonna transact some initial data and
the thing I'm going to do here is I'm
going to record the demo at this start
like I'm just gonna record the time and
then at the end I'll run a query on the
database the value of the database from
before I start from before I changed the
database okay so that's the start time
and what does the atomic look like the
atomic it's like data log queries above
I have what it would look like in
JavaScript you would have something that
looks a lot like link or something if
you're familiar with link C sharp but in
closure it looks like data log syntax
use here we can say you know we want to
find all entities where the the person's
last name is this logic variable and
that
we're looking for so the atomic is
basically light it's a bit like a triple
store you have entities they have
attributes they have values and we and
atomic adds this fourth hidden thing
which is what was the time the logical
time that that fact was added facts are
triples so let's do this and it returns
a set of results which is just just
those last names I can net I can ask you
can just make this a little bit more
complicated so here I have two clauses I
can say find the first name in the last
name returns that up here you can see
that it would look you know like this
fluent DSL for JavaScript you can of
course parameterize but am I gonna get
all that but here I can say find the
person whose first name is Co vos that's
just going to return the entity ID
that's the idea is just like you know DB
ID it's just a 64 bit long and here I
can say you there's negation you're
gonna say find the person's first name
as long as their last name is nots
missed and you have disjunction you know
the typical typical stuff that you're
used to it's all there you can do
fancier queries I can say find the
person named David Nolan find the
organization they belong to find the
organization name and then given that
given that organization also find all
people that are also in that
organization and this shows kind of the
power of like using data log we don't
have to talk about enter the typical
sequel madness around inner joins outer
joins so what's really nice especially
for doing UI development is that it's
very natural right graph queries so if
you've been following UI development one
sort of trend right now is graph QL as
well as Netflix has a thing called
Falkor in which clients basically get to
specify the graph of relationships they
want to pull and by doing this they're
eliminating this API problem that I
talked about in which that now client
you don't you don't you don't hard-code
some assumptions about what the client
wants the client gets a nice very highly
simplified query language which allows
them to express the graph and they then
it then they can simply pull that graph
are the DB and then immediately render
it they don't have to jump through any
additional transformations depth
you're just giving clients you're
preventing them from taking it on the
accidental complexity or whatever hard
corded choices you would have made in in
the in the previous world so des Tomic
is a good fit it's a very it's a very
good fit for this sort of graph QL
Falkor style front-end development here
I can go so related that if you know
graph QL or Falkor so here I can say
given given this entity which is just
this number so you know fine find the
entity whose last name is Bogota and
then I consider then I can pull so this
gives you a sense of how easy it would
be to integrate with something like
graph QL or Falkor I can say give me all
the properties of that entity so
actually recursively pull them in so
something that if you're if you're doing
like my sequel like a lot of the move
towards document style things or key
value stores or JSON database JSON
databases is that it's unnatural for
clients to get you know flat lists of
stuff you actually want to pull a tree
structure you want structured data
because that's what you're going to
present the UI is gonna present
structured data so it's more natural to
present structured data to clients and
so you get the so you get the sense of
indie Tomic that's like it's like okay
it's just a relational database it's
that we get to have all the convenience
that you had with a document store which
is that it's trivial for you to get
structured data out of the database and
this is you know there's no arm there's
no oriane this is data there's no
unnecessary abstraction it's just the
data that you want I can say I only want
the first name so here it's a it's a
vector you can say instead of pulling
all the properties so this is star give
me everything I can say I only want a
dictionary with just the first name in
it down here I can say I want the first
name the last name the address and when
I get the address I only want the city
this is this is this is absolutely
typical stuff then you need to do and
when you when you're when you're
building you eyes instead of instead of
getting this massive crazy response and
not getting what I actually mean I can
simply say I only need to render these
properties just give me those properties
in the
lay out that I need them to be in so I'm
going to wrap this up so you're here I'm
going to add some new data to the
database I'm gonna transact a new email
address for my friend kvass here I can
say you know given get given kvass give
me all the the data for the email entity
all the email into DS he has and I get
all of his email addresses but I
recorded the start time of the of the of
the top of the demo and here I can say
give me the database and I want the
database value at at the start time
right so the big value proposition is
that de Tomic is no longer this mutable
thing it's no longer this mutable
variable in the sky right I can say I
know when I when I want this crate
returned me the databases of value like
you get to treat just like one the
number one is a value in your program
now my database is a value I want the
value of the database when I started
doing this demo so I get a reference to
that and I can say yeah of course I had
not added that email to the DB when I
started to talk and so this is so
customers love this sort of people that
love to do auditing or sort of like more
powerful queries about what happened I
mean you know like you can think of all
these crazy business applications but
even just debugging like why did it does
it not work today but it worked on
yesterday's data and then speaking you
know you made some code change what's
different and now the database is not in
your way you can be ok let's let's let's
go back and get let's run the query or
let's move let's go up and get let's use
yesterday's database and you have more
tools for figuring out what went wrong
in your system ok so hopefully that
makes some sense
again that was had to be a whirlwind
tour maybe I have some time for some
questions if you're more curious about
the philosophy around this stuff I
definitely say look at a watch simple
made easy is very well known but I think
ones that are actually even more
important to watch our language of the
system by rickie databases the value if
you're curious about like all the ideas
around the atomic if you're if you're
curious about using the atomic there's
also some which is another reason why I
didn't talk too much about the specifics
about how the atomic work is because
changing so a few months ago not even a
few months ago last month at the cons
they announced that the atomic is
available on the ADA based marketplace
so that that just means it like you know
so whenever you choose a DB one of the
biggest problems is like it's all fine
and good but I don't want you know how
hard is it me to operate the thing to
make it operational and so that's that's
a new thing so we provide a version of
the atomic which is basically a button
click and then it's completely
integrated with all the scaling
resources on a DBS meaning auto scaling
auto scaling you know the oddest thing
like DynamoDB can be now be dynamically
provisioned and this version of the
atomic really literally you push the
button and then you can just start
talking to it
which is pretty cool and I think lowers
the barrier to entry for actually
wanting to use this for something so
that's all I had and I have I think I
have a few moments for questions but
thank you so we have some time for
questions so when you got a when you
saved off the time and then you got a
previous version of the database prior
to that time that seemed a little scary
because you were you were using Java
util date to get like the current notion
of time not like the databases notion of
time or anything like that so you have
to ask questions about drift and things
like that
is there a way to get the database for
the demo the atomic records both you can
you can get a value of a database based
off of course time which is you know you
should be careful but you also have
logical time every transaction says this
is the logical this is the this is the
basis of the DB you can use the basis to
get the DB value want but also every
transaction Purdue produces a squid like
a universal identifier and you can use
that as well so there there there are
multiple ways to get the value of the
database that you need great talk thank
you and so I realized you were talking
about relational relational not
functional reactive but I think there's
a really interesting crossover area
between the two and I be interested in
your thoughts about that
so specifically
typically with relational queries you
send off your queries you get back a
result but if the underlying data
changes you don't hear an update
afterwards the only thing you could do
is Paul to see if the result has changed
whereas with things like the reactive
programming style actually the data flow
gets changed the other way so that
changes and the underlying data can be
pushed all the way through to the UI so
diatomic has a transaction Q which you
can subscribe to so it emits every time
that there's a transaction it emits an
event and people built systems that
specifically read that and push data so
that that that was one of the original
design choices that the atomic has a
reactive sort of part to it
yep so what so tastes a lot so di yeah
so the people have dissin question so
diatomic is not an open-source database
is a proprietary database you can use it
for free we have something called atomic
starter which is basically the effective
leads I think it's pretty the licensees
it really lacks I mean I think you can
have oh I can't remember but I think I
feel like the number of peers you can
have is pretty significant but yeah you
can you can use it and you you know
there's no support but but you can use
it and people and that's actually almost
everybody starts that way and people
often build out their system over a year
year and a half maybe two years and only
when they hit some sort of issue do they
ever come bothering us about anything so
if I understand the atomic is a database
that's that run on the client so it's
just like it's just like my sequel right
or Postgres you you you you
operationalize it somewhere else
yeah yeah so it's not about so just to
clarify it the reason I was talking
about clients is because it's my belief
that all the design choices that you
make are of one piece right so often
when you make a choice about your API or
your database those decisions affect
everybody and my point is really that
you an ideal architecture at least to me
is that clients can get what they want
they can describe what they want you
have a database that makes that easy to
implement because that could be
challenging to implement yourself and
then you have a language of the backend
which allows you to basically eliminate
state and you the atomic is one answer
to that problem there's of course all
the ways to achieve what they Tomac does
closure is one way to get to that that
the backend to be less stateful and then
clients you know you can do whatever you
want there but my point is is that you
really want clients be able to request
what they need so they're not writing
all this unnecessary code just to
convert that response into something
they can present
so yeah so you talked briefly about
debugging in the database and debugging
in respect to databases sometimes having
to deal with buggy code client code that
only triggers a bug then certain values
in the database so you would probably
need a copy of the development of the
production database as a developer but
that's not always possible because of
like privacy rules and stuff like that
so it's their way to rewrite history
throughout the layers of rewrite history
say I mean outdated and atomic is is
based upon layers and layers and layers
of values I thought and you would have
to change all the values throughout
editions of I don't really understand
how rewriting in history has anything to
do with the bugging now I want to remove
say all of the credit card entries so
for me so for legal reasons you must
support deletion of data right so
they're not really deletion but just
replacement with other values so I don't
so your question is there's a lot of
ways to answer that okay first off so
can you delete stuff so legally we're
it's a requirement so we have a thing
called excision which you shouldn't use
unless you're doing your satisfying some
legal thing another question I think
you're trying to ask is can you add data
and like test it with that so the atomic
actually supports something called with
DB so you might want to do some sort of
testing query which means you want to
take some data set that you have and you
want to add some new facts without
actually committing the database and see
what those results might be so people
use that for testing you have some
database and you have additional
information you don't want to commit but
you want it to affect the query that's
also possible but editing the database
that's just like not in the that doesn't
seem to be really in line with what
databases trying to do here right do one
more the sounds very interesting as a
database for event sourcing do you have
experience with this people people have
used it for that I haven't spent my
haven't personally spent sorry spent
spend that much time doing that a lot of
the applications that we build are just
it's just it's just some complicated
system that you need that looks more or
less like you know we have to add we
have to add information there's some big
schema on there's a UI component but not
we haven't done anything specifically
around event sourcing I haven't I
haven't personally other people have
yeah yeah so we one tiny thing about the
atomic is that it's a single writer
model right so the way the way that it
works you can have many readers because
anybody can read it because it's
immutable anybody can read but all
writers are blocked does one there's one
machine that's going to be the trans
actor I mean anything that I might say
could there's also something to change
but that's how it works today let's
thank David</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>