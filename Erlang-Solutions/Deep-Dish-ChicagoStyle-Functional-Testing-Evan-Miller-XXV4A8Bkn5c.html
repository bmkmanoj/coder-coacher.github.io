<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Deep Dish - Chicago-Style Functional Testing - Evan Miller | Coder Coacher - Coaching Coders</title><meta content="Deep Dish - Chicago-Style Functional Testing - Evan Miller - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Deep Dish - Chicago-Style Functional Testing - Evan Miller</b></h2><h5 class="post__date">2014-05-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XXV4A8Bkn5c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Oh
talk to you bout the philosophy behind
the wheel okay there we go find the
framework and are behind the test
framework and why it's sorry jet leg
still but why I think it's that it
really can be used in a lot of different
project sites just web programming okay
so this is about a spot functional
testing but first I'm gonna play a
little story how many of you heard of
this book just to get some rough idea
here okay a few of you I think this is a
pretty important book but it's been a
new New York Times bestseller as you see
on the top here let's call the lean
startup and the idea behind it is taking
agile testing methodologies applying to
them to software products so most agile
development is often sort of custom code
for a specific client you can meet with
you chef coat every month or every few
weeks you meet with a client talk about
what they like what they don't like and
continue to iterate and what the author
here describes is sort of taking the
same process for a larger and applying
to a larger market where you have one
software product and trying to learn
about the market and shipping code to
individual customers and test customers
and really emphasizes learning about
customers and
your market in a very iterative fashion
and really a values knowledge so this
this talk is partly going to be a
critique of this book so I'll try to
represent it as best as I can and the
the reason I feel qualified to critique
s is a table story about what I was
doing before i was doing early but I
said there's 22 is surely after
graduating from college I went to work
for amazon com SAS as an operational
excellence engineer which meant that if
the something in the search service went
down I will find out about it pretty
quickly i saw i was on the team that war
pagers so when somebody searches for red
pants and no red pants come up one of us
would know very quickly service is
already in c++ not darling so
I would like so anyway so i was living
in palo alto and how many if any of you
lived and how else over in low parkour
and Silicon Valley you have okay it's a
great place to live if you're 22 years
old and when we care about working and
watching other people count their money
but what says these sorts of places
there are to live as through those
starting salary is there's a type of
abode native to Silicon Valley called
the programmer Shack which is usually a
like converted garage or converted tool
shed or something of that manner that
has a tiny little beds the rents are all
ridiculous out there so anyway so it's
living in one of these little shacks
it's a converted garage and it was one
weekend while I was on call and I think
the night before there had been some
some outage in Europe so I had been up
all night trying to fix amazon servers
and I'm going to knock on the door which
is I was not expecting so I groggy and
guide to receive before introduce
themselves said hey from your new
neighbor because I was its converted
garage there's like a main house where
this family could live and then there's
the little check where the programmer
lives
and I said okay so while I got a couple
questions for you all right I says no me
no we want to know what the recycling
situation well there's a recycling bin
right there and it is ok he says my
other question is has that has this
house been tented said what said you you
hadn't even see like a big blue and
white tent over the entire house and you
know said no it's like are you so
apparently this is a thing in California
what if you have termites and need to
exterminate them you put a big tent over
the house and then spray the bejesus out
the insides so apparently he had smelled
something on the inside the house
shortly after writing it and was
convinced in attentive and they hadn't
kept her the exterminator smell or
something anyway I thought was weird
little interaction that we had but we
kept talking a little bit and he's asked
me what I did so I talk about boys and
Amazon and writes the you know tell them
oh well you know I'm a programmer but I
got this job right where this pay dirt
which is why I'm so tired all the time
and he said well you know do you program
PHP like like yeah that's in PHP what do
you do program pearl like yeah I do i do
pearl so he kept pots like yours take my
resume oh gosh go away so he comes back
a few days later so he actually works at
this 3d avatar cat company in palo alto
and 3d avatar chat for those of you who
don't know as a service where you go on
a website and you can pick out like your
hair and like a shirt for yourself and
like you know you're like breast size
and some pants and then you go into a 3d
chat environment and talk to other
people who have picked out there
avatars for themselves the type messages
to each other so that was their product
and he asked me for one of yo interview
for them as a software engineer and
since it was not as an operational
excellence engineer sounds like a great
opportunity to make it so anyway so I
went over there and balance is really
interesting place because everybody
everybody and everything is connected so
this office as chance would have it is
on a street and right across the street
with my current office and right on the
fourth floor of that street was my
boss's office so if i wanted to go
interview at this new place I couldn't
do so without actually being the line of
sight of my current so I had a very
carefully planned when I would go in or
you know I'd like figured out what my
bosses meetings were and it's okay yeah
I was enjoying people talk about about
how like government workers always take
their vacations on Mondays and Fridays
or fifty percent of vacation like sick
days sorry or in one days until i can
valet it's more most of the vacation or
most the sick days are taking on a
wednesday thursday because people are
going to interview somewhere else and
you know don't want to say oh yeah I
want to take a vacation they make up
some story about terrible diarrhea they
have or something so anyway I went over
there an Arab you'd know I was really
impressed with the team they had some
similar interview questions were
completely impossible which I loved and
I've learned of time and another's were
just you know only difficult I think the
only reason I got the job was saying
recently interviewed at Google as well
and they asked a lot of the same
questions in both interviews so I
managed to get a few of them right
anyway point of all this gives i went i
ended up like going to work for them and
one of those there we go
okay great it was run by a really
brilliant CTO and he was Eric Ries and
what the company was doing was trying to
apply this sort of new philosophy to
software product development of having
an agile process applied to this product
where you're constantly learning and
constantly shipping and it worked out
pretty well except for a few things and
that's what I want to talk about where
this process falls down so it really
this sort of this business process
hinges on being able to do continuous
integration okay and most of you know
that means that you're constantly just
integrating new features into the
mainline branch and shipping it to
customers so the idea is you can get
actually feedback from the market very
quickly by continuously integrating and
the reason it's called lean is that
you're eliminating it form of inventory
so lean the lean startup is an idea that
comes from lean manufacturing sort of a
movement in the 80s and US manufacturing
based on manufacturing techniques
developed in Japan in the 60s especially
Toyota and the idea is that by doing
sort of what adjust in time supply
techniques you eliminate a lot of the
inventory that you have around
manufacturing process and that produces
your total capital outlay you end up
being able to manufacture with a lot
less money and a lot less overhead that
you otherwise would similarly in
software if you're constantly shipping
code you don't have these features
sitting there waiting to be shipped to
customers and they just because you can
run a lot more efficiently and deliver
value that much more quickly so that's
that's sort of like a whole lean idea
and the other part as many agile
developers know it just makes engineers
a lot happier
as they're constantly shipping code to
customers and they're not waiting around
for six months or several years in order
to see the code wyd encryption summer so
the key to continuous integration and
making that work comes down to test so
as you all probably know after two days
of the test track we got a number of
types of tests you got unit tests to
cover your individual functions and
modules and then you've got functional
integration tests to test things that a
little bit of a higher level if you
actually did something really
interesting so in view is the name of
the 3d avatar chat company stay at sort
of an immune system for online services
so the server cluster itself when you
should when you deliver new code would
test the CPU and memory levels on after
applying to code to a few nodes and if
the levels work too high then it would
proceed to roll out the code to more and
more nodes and if something seemed out
of whack it would automatically reject
the new code and go back to the old code
which i think is a very very good
technique that other people would
benefit from I think an immune system is
a great name for it we actually doesn't
have that name I saw for the first time
when I read this book but it's a good
phrase and a good technique that I think
more people should use but I'm not going
to talk about that today all right
continuous integration well and
and you know the old saw about the
theory and practice for computer
scientists the theory continuous
integration is you have this nice test
suite it covers everything and before
committing any new code you run the test
suite in practice as you get a large
team and as the team grows you get you
know you get dozens and engineers you
get hundreds of engineers and total size
the code base is just growing and
growing turns out people just run a few
tests that seem relevant to the code
that they're changing and then they'll
commit so it ends up things really ad
hoc process that has all kinds of
problems because people wind up breaking
things without realizing it because they
dead ruin the whole test suite most
people I talked to seems to be some
equilibrium out there of test Suites
running about three or four hours and
people will invest put it engineering
resources into improving the test
process and so they can get it down to
about three or four hours ago by it'll
build form the by what hardware and
that's and then it'll grow to five or
six hours and then put some engineers on
to trying to produce it but in my view
three or four hours is still much too
long so yeah again the theory with
continuous integration is you can
deliver several features several times
per day we were often doing that NM view
but that would be on a good day on a bad
day you just break the build several
times per day
finally one last bit of the continuous
integration theory is that you don't
need QA yeah you'll just cover
everything with tests and that was also
just not true of breakfast we still need
professional QA to make sure
everything's okay so the problem okay
now to the fact that our functional
tests were too slow unit tests usually
ran okay but when it came to actually
testing out individual web pages you
have these multi-step workflows it would
just get slower and slower and slower as
the code base grew so why are they slow
usually it's few reasons one is yellow I
don't peated logic you just keep if
you've got a multi-step workflow you
keep you'll do the same thing many times
across the course of many tests the
other reason that often comes up is UI
code tends to be especially slow you
also have drawing going on with the
inside of web browser for sort of
desktop development this comes up a lot
even if you just do HTML generating that
is fairly slow things tend to be
acceptable from a you know web browsers
perspective or for a user's perspective
of loading in 100 milliseconds but if
you have to do that hundreds or
thousands of times the course of a test
suite it's just in toddler incidentally
so well i'll talk about HTML more and a
little bit here and the other thing is
also has to do with gooeys is there all
sorts of weird things with the bent
luke's like timeouts and few dozen
browser test with selenium their little
things you have to do to make it work
and they just tend to slow down the
process so erling is a nice solution for
a lot of these or it can help out with a
lot of
of course so the UI slowness is not a
problem in Erlang brothel yeah yeah but
as for generating you smell I talked
about this a little bit and talking
again to the San Francisco Erling
factory but making heavy use of iOS and
binaries are especially binary there and
shared across multiple requests I can
make HTML generation much faster than in
other languages which tend to
concatenate a lot of strings together
and have terrible cache hit ratios
whereas Erlang can kind of recycle
memory a lot when it's building up this
Iowa list so generating HTML it's very
fast that's one of the things that
initially brought by dreaming too early
I said it says event loops are slow it
says don't use JavaScript and I kind of
joked about it just in the slide here
but in practice I found this it's just a
lot easier to test simple dynamically
server-side generated HTML and complex
on the script interactions so JavaScript
and one page websites are kind of all
the rage and web development now but
even though you know they're cool and
designers like them when it comes to
testing them out they're a real pain
because you got to actually fire up all
these browsers you got all this these
event loop problems and then sup just
taking you know much much more time than
running some tests on statically
generative HTML or even dynamically
generated HTML are you just trying to
search the Dom for certain
characteristics or certain information
so main problem I'm going to address
today is that of cutting down a repeat
is logic even though i think it's worth
keeping in mind especially these shared
by ordinary techniques is probably the
first thing you should do if you're
trying to you're doing a web test
framework and want to cut down your time
you probably get the most games from
that but this is sort of the most
generally applicable so the solution is
deep dish which I will be explaining all
right so let's say you got workflow I
could be like a user signup page or
anything where you got multiple little
choice nodes so either they do one thing
and say they cancel and you want to test
something about that or they do you know
or they go to the next step and maybe
they can cancel their or maybe go to the
next step or maybe they canceled their
or maybe they go to the next step now if
you want to test this workflow usually
you say all right I'm going to have my
here's my first test case the user comes
in they say no and they cancel I'll
write a test case for that all right i
want to write another test case maybe
now the first step instead of saying no
they say yeah they go here and then they
canceled so now here's my second test
case and now i have a third test case
where i'm going to go all the way down
here and then cancel and then I got my
outfit phase where i go all the way the
end through the blue box and thank so
what do we go about these tests well
okay your workflow is you know order n
then your total test logic and testing
time is order n square right if you got
this like triangle square getting built
up because you keep your going through
the first step every time and you're
going through the second step every time
except for the first
so that's that's really a source of
unnecessary pain and these test
frameworks we're in this test logic and
you can see it in the coat itself so if
you have sort of one function that does
something and then asserts something it
works okay if your workflow only has one
step but once you have two steps you
kind of add another thing in there in
three steps you're adding another line
of code and then if it's a four-step
workflow you got some more set up and
then you got more set up and more set up
two more set up so this thing just gets
longer and longer so not only is the
running time n squared but your code
size gets to be n squared because you
got to have a separate little test
function for each of these possible
bailout spots in the workflow does that
make sense alright so that's the problem
i want to address so these are typically
these would just be like trying to test
something on web pages and you're
looking very confused but I typically
just be download this page and click on
this button and then you want to click
on this button and then you want to test
something about something in the output
there are you thinking like a quick
check models or what yeah okay I'm not
sure exactly how you would automate that
I think I think you could you are you
think of doing sort of like a table
driven test with things that you'd click
or I don't know how to automate this so
all the time I spent writing tested in
view we this is the best we can do is
just do this do this do this but it so
I'm not sure without being more specific
about
talking to a human ate all the
subsequent
ya know and the state is the main thing
I want to want to talk about yeah you've
got all kinds of side effects here and
there I don't know I am yeah well I'll
let me go through this and then we can
talk about it in the eye not if its
database not its file system and okay
well we'll talk about it more well let
me get through this and then we'll we'll
talk about that so okay you look okay
okay alright so I just want to deal with
this problem particular here's some
delicious chicago deep dish pizza from a
giordano's so the main idea is it has to
do with the state and how we're going to
maintain the state dealing as we go
through the workflow so the main idea is
that any stateful resource that we have
should exist as a stack and anytime we
want to go down before we're good work
going down one path of the workflow
we're going to do a push operation which
will copy the current state and push it
onto the top of the stack and then once
we're done testing that branch and we
want sort of want to go back in time
instead of going all the way back to
Eden and recreating all of our you know
test models and all of our setup logic
we'll just hop back and go back to our
save point basically it's that will just
pop the current state off the top of the
stack and then we can continue to go
forward so I got a little fake animation
here with my slides so you got like your
first step here that you go through you
run a test say okay I want to go to the
second when now I'm going to cancel out
and I'm going to run a test on that now
I'm going to pop that state off of my
stack and then I'm going to do something
else and then proceed
so you going to do this for all of your
stateful resources so as you kind of go
through the test suite instead of
climbing up this tree every single time
you just popping the state off of the
top and going forward and then you want
to go all the way back you just pop all
these off and go down a different
testing path that makes us okay so then
that is that the kia is very simple idea
but that's the entire gist of what I'm
trying to get more people to adopt here
and I want to explain how to do this
with various stateful resources that you
might encounter because it's really easy
so here are the implementations of this
stack of state so if you have a gender
it's it couldn't be an easier so you
just add like a pot a push operation of
the pop operation and instead of having
a single state variables you just have a
list of all the states so to push you
got your state in your old state and
then you just add a copy to the front
and the reason I love erling is that if
this thing is you know ten megabytes
your copy isn't actually copying 10
megabytes data is immutable so that's
just always going to be a constant time
operation similarly the pop all you do
is guard the topmost state and then get
back to business then when you want yes
you don't send this somewhere what do
you mean
no what are we using in a message this
is
I'm not sure what you mean because this
is this is just the second argument to
the gem server subsist the internal
state main turn maintained by the gents
server okay yeah yeah I might I'll get
back oh well the long talk once i get
through this okay so the then when
you're modifying your actual gen server
arguments all the other ones instead of
having the single state argument you
access the state by pulling it out of
this list of states it's that's all you
have to do to go from a regular jet
server to sort of this stack based gen
server several lame you're working doing
an integration test sequel database you
can make take advantage of save points
and roll backs so this is the exact same
idea with a save point you say all right
I have gone through this workflow to a
certain amount I want to save where I am
then I want to do some stuff and then I
want to basically hit undo and roll back
to my save point so in this way so it's
yeah yeah desktop environment you got
undo and redo operations sorry about the
Sun here hard to see that but that's
that's really all you have to do when
you are sort of creating a test
framework around this you've got all
your resources receiving is push and pop
operations and it's just got to do an
undue it's just got to do a save point
of roll back and then you can you're
good to go a filesystem a sort of
similar idea is if instead of sort of
copying the entire file system you can
do something similar to what Erlang does
and sort of treating it as immutable but
if you use hard links you can create
kind of shallow copies and then sort of
do a copy on write if you actually want
to modify something so here I've got a
low file system that's supposed to be
like a user directory in a bin directory
with three files in the meat
for my modification when I start out
I'll just have a hard link to the base
directory so don't actually have to copy
everything and then when I want to
actually modify something in there I can
make an actual separate directory then
hard like the internals and then create
a copy of what I want to modify and then
modify it so this is how a lot of backup
systems work so for example apples time
machine uses hard links in this way so
you have this whole history of your hard
drive contained in relatively little
space and so you can use the same
techniques if your service relies on the
file system or you maintain state in
your application using the file system
so next I wanted to talk a little bit
about designing an API using this these
pushes and pops and stacks sort of the
most obvious way to do it this is a sort
of pseudo code sudo Erlang would be to
do a push and pop around each step whose
side effects you want to ignore and
that's a lot of graphics programming
looks like this I don't know if you any
of you info graphics program you usually
save your graphics context do something
and then restore your graphics context
and see it's the exact same idea but
doing that for all your stateful
resources so here I cancel but then I
got to do it and I continue then I save
then I canceled and I'm going to do it
and I can go forward that way is that
that's for the most obvious way to do it
another API you might use would be a
little more functional where you have
some kind of transaction function that
will take a fun and then perform sort of
implicitly perform the push before the
funds executed and then
pop afterwards so that's it's one of the
way to look a little bit nicer than
explicitly writing push and pop after
everyone so you don't have to worry as
much about syncing up your pushes and
pops and making sure you get the same
number all that finally there's the API
that I've decided to use with this deep
dish module and that is a recursive API
and the way the recursive API works is
it'll take two arguments and assertions
argument and a continuations argument
these are both functions so the
assertions are functions about something
that should be true about the output so
it's you know sort of the core of your
test and then the continuations are
going to execute code inside the push of
Hopsin sort of similar to the previous
design that we saw but it's constructed
in the way that we can sort of nest
these together and you'll see what I
what I mean in a second here so here's
an example of the sort of example code
of this dish module hard to see but all
explain what's up here first it's going
to do something so it's dish do it's
going to perform a get request and then
we've got as the next target we've got a
set of assertions we have the
continuations the surface says all right
we've get it we're going to get an HTTP
ok from this that's one thing we want to
be true and then we want the content
type to be text HTML so those are two
very basic tests we can perform on the
output then once that's done but if all
that looks good then we move on to these
continuations which in this module we
use these named tuples are sort of this
prop list thing or just just to give a
name saying we're going to click on the
login and we're going to take the result
of the last operation of this get
request and pass it to a fund that will
then do something else so in this case
I'm going to say follow link
that's named login and the API design is
the exact same as this get request so if
the slider bigger I would have put
assertions in here about the result of
my follow link request and then I would
have a list of continuations for things
to do after I walk down so I want to you
know it might be click on my messages or
so typically we'd have check HDD be okay
and then click on this click on that and
continue forward with the test so that's
that's sort of a basic example how this
would work in practice I like it because
the the test code ends up being
relatively nice and clean as you see I
don't have to repeat myself as in the
sort of the Simon Says code that i
showed you earlier you can just keep
pushing forward in your workflow without
building up all this sort of testing set
up crushed yes very weird is very so how
do you help the click login
because presumably that changed state on
on the server side okay now you're
talking you don't get locked out because
you talk the same in again
yes I mean if the login state is in the
gen server then you would after you so
this is this is performed inside the
push cough yeah yeah or you just yeah
we're while you brought you know while
you're running the test you broadcast it
to all stateful resources so yeah so
that's that's the idea yeah so if I then
if i added a test sort of after the
click login it would be something else
you know i forgot my patio click i
forgot my password which would execute
without being locked down yes yes yes
that's right but as I showed you the ca
go back it's not a complex modification
you have to make probably do a yes yeah
yeah so yeah process dictionaries would
yeah I mean sort of the alternative the
other thing that people use is just
writing what you know like mock services
for lots of things they basically
recreate all the functionality so this
seems like a relatively low price to pay
for that but it is it is a set of cost
and benefits if your if your tests don't
take a lot of time to run and you're
kind of app you or you'll have to
complex workflows or you're happy with
the complexity of the test code then
yeah it might make more sense just to
keep doing what you're doing so yeah
this is definitely it does have costs in
terms of implementations for sure any
other questions before I move on yes
okay that's what that would do one novel
thing here is that you're actually
designing the quote to be tested yeah
yeah it's already gone through the
framework of the dev server so that
would be probably the most part in
Jennifer yeah yeah yeah you could have a
gem server testable or four you gave
your testing it's a great idea other
cool yeah yeah you'd lose ya know that
would absolutely be possible that's sort
of a that's a sight yeah that's
essentially the same idea with snap
shouting or safe pointing a database
yeah so it's all engineering trade-offs
and how much time that's going to take
purpose of asians to make offensively
rock bottom and the test suite be
simpler and run faster yes so just you a
idea about the implementation of this
previous get requests slide it's pretty
simple what this does it kind of does
something this is get the page and then
it will run these assertions and then it
doesn't push that runs the content list
of continuations and then it does the
pop so that's sort of when I explains
the second ago and in reality you would
want to accumulate the number of
failures the number of successes I'm
going to report those to the user
somehow so the this is just sort of the
state of the module is we have it now
it's a really small module does it
really does not do much but it does get
requests post requests follow a link and
the web page you download and follow a
redirect that you receive even know what
this is a metaphor find something you
can find either actually find a tag with
a certain text inside the webpage
download uses like the mochi web HTML
parser and finally you can search for an
email that was received so it's the gen
servers that we have we actually have
this mock email inbox that follows the
same manner so you can check the inbox
for you know somebody creates an account
there you send out a welcome to our
website email you can check that and
then you can do the undo as if we're
never so so that's that's what we have
in the API okay now and then I just have
one slide to kind of summarize the
asymptotic characteristics of all these
different considerations sort of the
thin crust testing model which is what
everybody else does and then this deep
dish paradigm so generally so if and is
the length of the workflow they're
basically no benefits to this if you
only have one step work flows throughout
your application but if you do have a
complex thing the runtimes going to be n
squared under thin crust it's going to
be Orgeron that's that's what we saw at
the beginning skipped out here saying
the code size it's going to be N squared
versus and the space required it's going
to depend on the nature of your state
that you have to maintain creating those
copies is going to take up more memory
if it is erling terms or if you're using
sort of the hard link system that I
described with the file system it's
going to be around if the total memory
required for a single snapshot of the
state is M you're going to have roughly
M times n like the work load times the
log of M and the reason for that is if
you're making one modification way down
in this tree you need to sort of save
almost like the chrome trail going back
to the root of things that were modified
and leave the rest of the tree
unmodified if that makes sense that make
sense to people okay so that's sort of a
big o approximation for your space
requirements under that pattern but
something like snapshotting the vm if
you use another pattern it could be the
worst cases and times m finally one of
the drawbacks is the menos the scope
love will start to creep to the right in
the previous slide so if you have inline
functions for your continuations your
scope is going to keep moving over to
the right a better pattern would be to
actually create separate functions that
you call for each of those I wish will
prevent that but if you don't and just
brain tests like I do you've got this
scope level increasing and order in
which is the length of the workflow so
you might want to buy a wider monitor
yeah so how we doing on time 23 minutes
more okay yeah I'll you know do we make
questions them anymore yes I'm still
trying to wrap my head around this haha
seems interesting could be could it
possibly be used for like other use
cases I'm thinking like a restful
interface testing way yeah yeah so yeah
I've done this sort of in a context of a
website but I think anything that has a
multi-step workflows with state you can
apply the pattern to absolutely the
boring part is that the code has to be
written in order to be testable right
but yes quantitation through the yet
server it's actually it's a fantastic ND
to have an additional
the answer it's obvious it should be
there yeah accident and it's almost
lyric okay yeah exactly so this would be
the Newark eight guys to the camp yet
again follow me yeah yeah baby green oh
yeah oh yeah oh oh say you're sorry or
four requests yes
yes yeah i mean just my own experience
the sort of the testing time for each
test ellicott m view would be on the
order of hundreds of milliseconds so
like a you doing a little like small
test feet it's going to be 5 to 10
seconds or 20 seconds or something sort
of combining these techniques with the
other benefits of Erlang like with HTML
generation typically we can run dozens
of tests per second so it's it's at
least sort of a ten time speed up in
that respect but that's not it really
depends on the type of complexity to
workflow so there's an algorithmic
improvement that you get from complex
workflows and then there's kind of the
constant time you know see out front
that you get from having rolling just
being faster at generating HTML so it
really depends on on the application
what kind of outfit you'd see yes
yes yeah this will tell you exactly what
test fails so and the the way it works
is with these these sort of tags here
you got a tag so you know the position
and it'll say test number you know a
certain number whatever inside of the
click login you know save point that
sensually yeah so you can you pinpoint
that way yes
here the purity of the
okay only in the test environment right
right yeah that's that's a good idea
okay that's it thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>