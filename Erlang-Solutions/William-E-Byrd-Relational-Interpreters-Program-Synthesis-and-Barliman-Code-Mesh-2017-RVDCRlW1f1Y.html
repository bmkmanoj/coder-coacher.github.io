<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>William E  Byrd  - Relational Interpreters, Program Synthesis, and Barliman - Code Mesh 2017 | Coder Coacher - Coaching Coders</title><meta content="William E  Byrd  - Relational Interpreters, Program Synthesis, and Barliman - Code Mesh 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>William E  Byrd  - Relational Interpreters, Program Synthesis, and Barliman - Code Mesh 2017</b></h2><h5 class="post__date">2018-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RVDCRlW1f1Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you this always happens to me a
code mesh you know I have an idea for a
talk and then after seeing a keynote or
having a conversation with someone I'm
like throw that out actually butoh last
night tried to convince me to give a
talk on starcraft instead which I'm
sorely tempted to do but maybe next year
yes but I saw a guy steals keynote last
night which I loved and I have to say
that I love scheme I agree with alan kay
that lisp is the most important
programming language ever created and
for my money scheme is the most
important lisp so i think your scheme is
one of the great joys of my life i love
programming and scheme and when I went
to Indiana University to get my PhD I
went there specifically to work with dan
Friedman and get my PhD in scheme the
first day of grad school I walk up to
dan and I said I'm so excited to be here
at Indiana University so that you could
teach me scheme and he says I don't do
scheme anymore I do a logic programming
it's like something you could have told
me two weeks ago and I would have gone
Northeastern but I didn't anyway
but Dan should have told me something
else instead he shouldn't have said I
don't do scheming more I do logic
programming he should have said
something else and and so this talk is
kind of kind of about what Dan really
should have told me and and sort of
trying to explain what we've been doing
last 13 plus years I've been doing it
for the last 13 years Dan's been doing
it longer than that what is it we're
trying to do and what is this weird mini
Cameron language were working on and why
is it not prologue and how does that fit
into guys keynote and all these other
things
so the original talk was relational
interpreters program synthesis and
barliman strange beautiful and possibly
useful maybe you'll be useful someday
but I don't really care about useful so
much as you might see so the language
we're working on
it's called mini Cameron and I get my
memes and four and my ponies for boodle
but someone made this up fresh is one of
the key operators are there only three
three operators in the core language but
you know here's my second meme and this
is something I've heard a lot of mini
Cameron is the worst logic programming
language I've ever heard of but you have
heard of it right so people people often
say well this is terrible why you know
Prolog has all these extra features or
Prolog implementations are faster so why
use mini kenra and you know the point is
in my mind isn't to build a logic
language that's not what I'm trying to
do at least I don't care about logic
programming I don't care about mini
Cameron that's not that's not what I'm
trying to do so so let me tell you a
story and I'll do my first live coding
so I'm gonna show you the first program
I ever wrote I was nine years old my my
father bought this beautiful computer
anyone know what this is no one knows
what that computer is really trs-80
cocoa trash a tea color computer okay
believe it or not but one point in a
time this was the most popular computer
in the world and RadioShack actually had
summer camps my first class in
programming was taught by RadioShack of
the summer school and programming in in
logo so the trs-80 cocoa that came out
in 1980 hence the name and let's see if
I can show you the program we got this
new computer and normally I'd say that
like I used to think that I had seen war
games or whatever and I knew how to
program but war games I don't think was
out yet so I must have seen Star Wars
but I thought I knew how to program so
we get this computer and say alright I'm
gonna show off to my brother my little
brother because I'd watch all these
movies so here is exactly the program
that I wrote oh I got a click on it okay
okay that as as I recall as the exact
program I wrote 37 years ago and that's
the exact result I got
and I I basically flipped the table and
I said this is not for me and I didn't
type to computer or programming for for
several years after and in effect I I
haven't really changed okay this is
basic this this this is really my
philosophy of what programming should be
like and so the fact that I have become
an expert and have a PhD in programming
to me is offensive it's not it's not
something joyful it's like it's like the
same thing where you know writing the
books with Dan and all like you know and
you know or writing latex papers or
whatever the fact that become a master
and mangling latex files and
post-processing latex files with Perl
scripts is not something I'm proud of
right I'm ashamed of so the fact that I
still to this day have to program at a
much higher level in a sense I can't
write that sort of program really
offends me so let's see so so really I
think you can sum up my attitude with
this epigram in programming and if you
haven't read Alan Perlis as a programs
in programming you should read those are
fantastic but ever Graham 93 when
someone says I want a programming
language in which I need only say what I
wish done give him a lollipop okay so I
I understand his philosophy or why he
said that but if if someone wants to
just type something in sort of naively I
think we should give him or her a
lollipop well we should also give them
what they asked for and and so if you
think of it that way
what I really want to do is lollipop
driven development so Chris I'm sorry
rich Vicky has this idea of of hammock
driven development which is fine but I
prefer lollipop driven development I
want to just be able to say
what would happen and just have it
happen milkshake driven development yes
and you know going back to guys keynote
last night so he showed inference rules
typing judgments you know context-free
grammars you know BNF all these sorts of
things and and when I went to Indiana
really what Dan was trying to do at the
time which took a while for me to
understand was he wanted a way to write
these sorts of rules down make them
executable and be able to explore the
resulting system okay that's really what
he was interested in but anyway we want
some way to explore this and you know so
going back to two guys naming of the
sort in formal language use computer
science meta notation basically we want
to have an executable relational version
of computer science meta notation in
just one other source of inspiration for
the Commodore Amiga which was my third
computer I think there was a fantastic
program for it called Doug's math
aquarium I love this program you can see
you know this is on the September 87
issue of info you can see in the lower
lower left image again so you can do
Mandelbrot plus you can do wireframe and
you know there are a whole bunch of ways
you could visualize mathematics and the
way it would work is like hey I want to
zoom in the Mandelbrot set and the
computer was so slow and the software is
so slow like you would hit return and
you would see it draw each pixel right
and then you would go away and like
eight hours later you know you'd see a
little bit of the Mandelbrot set but it
was still amazing it was still
incredibly inspiring to me and so what I
want is you know a computer science meta
notation aquarium just like the math a
cream and even if it's slow and even
it's awkward to use just being able to
explore and play around with it to me
would be far far better than you know
just writing interpreters a standard way
so that's really really what what we're
trying to do I'd say so
I'm going to not teach you the Mini
Cameron language and I'm not going to
teach you how its implemented so we
actually have lots of resources and
talks and things like that about this
about about Mini Cameron and you know
how to use it and how to write many
kinder programs and to really do it
right would take far more time than I
have but I just want to show you you
maybe a couple examples of what the
rules look like so so this is a type
inference err for the simply typed
lambda calculus on the Left how we would
write it with the computer science meta
notation was that right CSM computer
science meta notation that's how we
might write it on the left and then on
the right is how you might write it in
Mini Cameron using like some higher you
know using a macro called matchi is a
little higher higher level syntax than
what we normally use but you can see
it's like kind of roughly the same you
know it's still kind of awkward it's not
not the greatest notation but you can
see it's not you know a hundred times
longer a ten times longer or whatever
you hear here we have something similar
for common Ettore logic okay so we have
another meta notation and on the right
is the mini camera and that's roughly
the same same length here is the program
that we're gonna play with today and
explore this is an environment passing
interpreter for a subset of scheme or a
subset of racket and if you know the
rules this is a procedure application
this is abstraction or lambda
that's variable reference here we have
lists there we've got quote we've
actually added some other forms to
various versions the interpreter I'll
show you this version first and then
here on the right is sort of the mini
Cameron code that that's the corresponds
to it and then we also have to have some
extra code for doing things like
environment lookup and some side
conditions where in the math when you
write it down you don't have to worry
about as much but anyway the point is we
can write something that doesn't really
look like the notation so it'd be very
nice to have something much closer
it's a notation but it's roughly roughly
the same same length or maybe twice as
long as things like that so we're gonna
assume that we've already implemented an
environment passing interpreter and mini
cannon and we've already implemented
mini cannon and mini cannon is a
language that is sort of a combination
of logic programming and constraint
programming constraint this basically
constraint logic programming language so
it's a mixture of constraints and logic
programming and I heard Peter Van Roy so
a question last night to guy both logic
programming and constraint programming
came up and so basically you can think
of it as a language that's been
optimized to write rules like this not
necessarily in terms of the syntax like
how you write them down but more in
terms of if you want to explore the
resulting rules the language is
optimized for that and the
implementation is optimized for that
okay so now is the most fun part this is
always the part that scares me loading a
file alright so we haven't really solved
the loading the file part that's a let
me make sure I can do this oh okay great
good alright okay can people see that is
that big enough okay so show of hands
please
who here can read scheme racket closure
or some other Lisp at least a little bit
Emacs Lisp absolutely okay so most
people maybe not a hundred percent I
think in the interest of time I'm gonna
ask the people who aren't as familiar
with parentheses to please please try to
bear with me and try to think of the
high level what we're trying to do okay
just just from the standpoint of time
I can't also teach you all of scheme
unfortunately although I gave a talk at
papers we love recently where I actually
do teach enough scheme to do all the
things we do it but I had an hour and a
half then so if you look on YouTube you
can find a papers we love to talk on
called the the most beautiful program
ever written
right talking about some of these topics
okay so what I've loaded is an
interpreter for a subset of scheme and
in a language like scheme sort of like a
language like Python maybe we have
something called a vowel so eval is an
evaluator it can evaluate an expression
which we quote so I could do plus 3/5
and this expression a scheme uses a
prefix notation and we're adding three
plus five that quote means that we're
delaying evaluation we're turning the
plus 3/5 we're treating that as as a
list of data instead of as a procedure
call so you can see the difference if I
put the quote mark we get back to list
if I don't put the quote mark evaluates
immediately we get back eight okay so a
vowel sort of cancels out the quote mark
if you want to think of it that way
we're taking this list and we're going
to evaluate it so we're gonna look at
the parts of Lists and do some
evaluation procedure okay so that's a
vowel and scheme what we're gonna do is
use something called a vowel oh so
evallo is the relational version
of the avowal function so the eval
function takes one argument which is
going to be a scheme expression as
quoted evaluates that and give us back
to value the value however is going to
take two arguments instead of one it's
going to take an expression as the first
argument it's going to take a value as a
second argument so let's try using eval
okay great so it's working all right how
about I do saeng's simple like oh yeah
okay so for the people who don't know
scheme Lisp stands for list processing
so the list is a very common data
structure we use so list three four
creates a list containing three and four
what I just did with this run expression
is I called eval o
which is my relational evaluator and the
quoted expression is list three four
just like I typed directly in the scheme
so that's the expression the first part
of the the first argument to a vowel is
the expression I want to evaluate Q is a
query variable you can say I introduced
it right after the run one in
parentheses Q is my query variable and
I'm putting Q in the place of the value
I'm saying that whatever a list three
four evaluates to bind that to the
variable Q okay so Q is a logic variable
query variable Y whatever you want to
call it
unification variable run one the one
means that I want one answer back
sometimes we can get more than one
answer back sometimes we can get
infinitely many bit answers back and in
fact we also might want to prove or show
that there are only a finite number of
answers that there are only five answers
that exist run is our interface operator
between scheme and mini Cameron so mini
Cameron is embedded in a host language
most implementations this implementation
minikin runs embedded and scheme I'm
running it in Shay scheme alright so
that's the basic interface the
underlying language that we wrote a valo
in is is quite simple it basically
extends three scheme with three
operators core operators and then we've
got a couple extensions for helping
write interpreters and type in there's
things like that okay so that's a vowel
oh and you can see that we can write
things like lists three four now what's
interesting is that evallo is written as
a relation
and so guy-guy talked about this a
little bit yesterday but you know the
interesting thing about the rules and in
fact I can show you the rules for for
interpreter the interesting thing about
these these sorts of rules is that they
don't really have a direction okay so
here is a paper that was in I CFP and
Oxford this year and in this paper you
can see these rules written as inference
rules and the code on the right which is
mini-camera and this is kind of the
lower level mini cannon so it's a little
longer but the important thing is to
realize that you know there's this bar
here right that the guy was talking
about and normally the way we read it is
we have some antecedents and a
consequent so we have some some things
that have to hold and if these three
things hold then we can infer the thing
on the bottom and we also sort of read
it as okay so this is this turnstile
operator we can read it as like an
interprets or evaluate so in a certain
environment row this particular
expression which is a procedure
application evaluates to the value v3
and it's the rules of top Tokyo v3 is so
if you're writing an interpreter in the
standard way you would read these rules
as okay I'm going from left to right
here's my expression here's my value
notice there's an arrow instead of an
equal sign so that's how you would often
think about it but there's no reason
that we have to go in any sort of
direction we could actually consider
this more like an algebra problem where
we have variables that we want to place
in the different parts maybe the ropey
we replace that with some variable X R
now what X is or the expression or the
value okay so if we can put variables in
and then have a system that can do a
mixture of maybe things like search and
constraint solving then we can try
putting variables in to to get more
flexibility so that's exactly what we've
done so what that means is if I go back
to this evallo call
I don't have to just put in an
expression that's known in the first
position and then put an unknown and in
the value position I can do the opposite
so what I could do is I say alright well
I know that the list is supposed to be
3/4 right and grab this list the extra
friends by the way and that answer up
top have to do with first of all the
fact that we can get more than one
answer back and also that we can get
some side conditions to help interpret
the answer anyway I'm gonna replace that
query variable with quote 3/4 so that's
the expected value and I'm going to
replace the expression with my query
variable Q ok so now what I'm asking is
give me an expression and scheme that
evaluates the list 3/4 so what would be
one such expression do you think list
3/4
okay so let's 3:41 quote 3/4 another so
I can ask for you know let me ask for
two answers
okay so list 3/4 was the second one I
got and I can ask for three answers and
we can see less three quote four so it
turns out that if you quote three or
four it's the same as just writing three
or four and so you can see that we have
a number of answers right and so some of
those answers involve things like lambda
and procedure application so say hey is
function call can give you three uh
lists before all right now I'll back to
lollipop land so Matt might who was
giving keynote tonight and whose lab I
work in I've worked with for many years
he wrote a blog post for Valentine's Day
a couple years ago called 99 ways to say
I love you in racket so the idea this
was to teach students and beginning
racket programmers a little bit of
racket and a little bit of how
manipulate lists because rackets a lisp
in Lisp is list processing so you know
the idea is to show 99 different
expressions and they're you know various
complicated ones and so for
that would evaluate to the list I love
you and Petey Aldous who's one of the
grad students said hey do you think you
could use mini Cameron to graduate to
generate such programs so let's try
doing that we're going to generate 99
programs that evaluate to I love you so
can you help me out with the query what
would that look like
run 99 sure okay what else is going to
change
sure okay how about I love you okay all
right so here are 99 programs that
evaluate I love you so I don't know let
me what's a fun one how about now let's
just start down here and just grab that
out and I'm running it and scheme now
and you can see that evaluates I love
you so we've got list quote I quote love
and then the last sub expression is a
procedure call to a function which is
very attic it takes any number of
arguments the underscore dot zero
represents a symbol representing that's
a symbol representing a variable the
name doesn't matter that's why I picked
underscore that zero us or convention
saying doesn't matter you could pick foo
if you wanted there and this quote
underscore one thing so this is a quoted
symbol also if you look the side
conditions you'll see these things so so
that could be any quote dissemble and
this will hold there may be some other
side conditions like the symbol can't be
called quote underscore zero can't be
called quote because you don't want to
shadow code that kind of thing okay so
that's a simple example and after after
we started playing around with us a
little bit Dan Freeman and I gave a talk
at closure cons and we we showed this
relational interpreter or a variant of
it and Stu Holloway at the end said well
you know you should be able to generate
clients using this anyone know what a
client is what's a Quine a program that
outputs itself that's right okay in fact
if we go back to history let's see if we
can go back and you know I love the fact
the guy went sit through so many papers
old papers well this is a paper I really
like by John McCarthy who is the creator
of of lists called a micro manual for
Lisp not the whole truth
and then this he gives rules for the
list language so you can see like what
equal means what cons means and so forth
notice by the way he uses an equal sign
but then he has this neat little problem
difficult mathematical type exercise
finalists II such that value of e equals
e so value is the name of his evaluator
function his eval so basically what he's
calling value is what we would call eval
or eval oh and so he's trying to find an
expression e such that the value of e is
e so that is also trying to find a
client so he was trying to find a Klein
or Geddes to find a Klein and I think
1978 so let's try to do that so given
what you know how would we find a coin
what would what how would we change our
query so we could generate a client QQ
evaluate QQ us right now of course
there's nothing special about the name Q
so why don't we out of respect for John
McCarthy call it e instead of a low E E
and let's do a run one okay so we're
trying to find an expression e that
evaluates to itself this is pretty close
to what John McCarthy wrote right I mean
we're calling it a valo instead of
instead of value but you know this is
exactly what you would want to be able
to type into a system so let's see what
any camera gives us back well the first
thing it says is that underscore zero is
a number which is true okay so in scheme
five is a Quine so five evaluates to
itself that's true okay so that's what
mini-camera is telling us let's ask
first
second one says hash T hash t is true
and scheme alright so those are all
Cline's hash F is a coin how about for
now it's thinking for a minute okay now
we got something a little more
interesting gonna grab that expression
and type it in and sure enough that's a
client so that's a self evaluating
expression in fact if you look at the
coins page you will see this coin this
is sort of the canonical coin and we can
generate all sorts of claims we can
generate twin coins and triple coins and
that kind of thing but what I love about
this and in some sense this is probably
my favorite mini Karen query using a
relational interpreter well I love it as
the query is so simple this is actually
the shortest query you can write in
terms the number of distinct identifiers
right this is like the shortest thing
you can write and it generates Queens
and it actually works and I would you
know I personally was shocked that like
oh yeah this actually this actually you
can actually do something with this and
you type it in I figured it'd take you
know a million years they're saying okay
so at that point grad student at Utah
named Michael Ballentine said well well
that's kind of fun but what if you now
you have this interpreter what if you
were to take a scheme program and fill
in the scheme program in the first
expression but leave some of the
arguments to that program so that
function you make those variables could
you could you get interesting behavior
and so he suggested append so let's try
doing that so a penned in scheme takes
two lists like a b c and d e and
concatenates the list so get ABCDE in
this case so what we're gonna do is
we're gonna write a pen
and the way I'll write append is using
something called Lautrec listen to find
a recursive relation or a function
Oh
a little
yes okay so that's a pend did I get it
right I think I did and now we're gonna
call append I use the same arguments as
before ABC to de okay so I just ran it
forward so so what do they do
I took the scheme definition of a pen
this is not Mini Cameron code this is
not logic programming code or constraint
logic program code this is just scheme
code I ran it inside of evallo is the
first argument this is the expression
argument and I said we have an unknown
value right so my query variable Q
represents the unknown value so what can
we do
okay so now what we can do is we can say
we know ABCDE is the output okay and
where else could I put a variable where
could I put this Q variable well how
about how about I put it in a position
of one of the arguments to append how
about I put it right here I have to put
a comma there because this whole thing
is backward and if you know scheme
alright so what do you think I'm gonna
get back in the place of the Q variable
ABC right so let's see if that works
yeah quote ABC is there a second answer
what if I do a run too should there be a
second answer or should it say no no
more answers list ABC all right well
let's see if we get something like that
ah we get it's not list ABC but we get a
procedure application and if I evaluate
that in scheme I get back ABC so what
happens is we get an expression that
evaluates to ABC if I put a quote I get
back ABC itself okay so that's a little
subtle if you're not a schemer but the
point is we're making a distinction
between expressions and values so if I
put a quote in front of the comma Q
that's so nice a well I want the the
value the list that's going to
concatenate to give me ABCDE if I don't
put the quote
that means this could be an arbitrary
expression in my subset of scheme than a
holding a handling all right where else
can I put Q inside the list like here
sure yep in fact I could have two
variables I could do like x and y right
and I can do things like in fact I can
ask for all the answers so if you're
familiar with logic programming in
Prolog or mini canter it sound like that
you've seen this before things like a
pen that's a standard answer there's a
standard program but we didn't write a
pendanski and mini-camera nor Prolog we
wrote a pendant scheme we'd get the
relationality through the relational
interpreter alright what else can we do
where else can we put variable how about
if we played a variable inside the code
what if I put a variable where the S is
okay that used to be the symbol s what
should I get back i get back the s right
so i could also replace it here like the
Caravelle oh I got to I was doing a run
too
yeah so I got Caravelle and another
expression which is the same as
Caravelle equivalent to it all right now
I could show you much much more if
you're interested in that sort of thing
I recommend you look at our our paper
and I CFP 2017 but I just want to show
you what happens if you kind of sort of
put an interface on this and you also
speed up the naive version by about nine
orders of magnitude because it's that's
what we've done like a Valentine and
Greg Rosenblatt have been speeding up
the system so Greg gave us a tour is the
magnitude in eight months or something
so now what we're gonna do is is we're
gonna do some program synthesis so this
was happening underneath the hood is
we're just generating calls to our eval
Oh
we're doing an example based program
census so here I have a call to a pen
I've got a fragment of the append effing
ition the comma a comma B come and see
those or logic variables representing
holes in our program
and you can see at the bottom the
parliament is trying to figure out what
we have I can do this in various ways
but one way I might want to do it to try
to keep the system from over
specializing is to use these G 1 G 2
things which sort of represent
universally quantified variables if you
want to think of that way or sort of
like Jenson's or skolem variables so it
don't quite have enough structure so let
me try one more example let that think
for a minute
okay now it's figured out the recursion
and it's a little hard to read it so I'm
gonna just put in variable names
concrete variable names and now you can
see you can read a little more and if
you know scheme this is the correct
definition of a pen
okay so what's happened we've taken mini
Cameron we've implemented the semantics
written in something similar to the CMS
computer science meta or cm in whatever
is called the computer science meta
notation or whatever okay something like
that and and through some cleverness on
the backend which we're hoping to
generalize so it's not just for our
interpreter but we'll work with with a
wider range of semantics and type
systems and things like that you would
just type in we can also do this for
grammars regular expressions and so
forth we're able to get to the point
where we can just type in input-output
examples and the system is able to do
recursive higher-order synthesis for our
subset of scheme we can also write type
inference tours in this way so I'm
hoping we can combine those we write
type inference in the same way we would
write the operational semantics for the
evaluator and we can also write grammars
there's also a grammar written in
exactly the same style underneath this
so we can do grammars we can generate
expressions in exactly the same way so
I'm hoping as we improve this technology
that we'll get closer and closer I don't
think we'll ever get there perfectly but
we'll get closer and closer to being
able to be naive and just take a paper
or some operational semantics or typing
judgments or whatever just type it in
hopefully with the nicer syntax and then
be able to start exploring this world
and asking queries that you know maybe
other people haven't thought of before
or just you know being surprised that's
the that's the best part for me that's
why I like Doug's math aquarium it would
surprise you and that's why I like
playing around with mini-camera there's
things like wines that surprised me
there there are all sorts of programs
that we're
generating that surprised me I didn't
think it would be either possible or I
had a different idea of which program
would meet a certain specification and
many Karen said hey this program it
meets it also often sort of trolling me
in the process
so anyway this is lollipop driven
development if you will where you just
type down the type the semantics sort of
like you'd read in the paper write down
examples maybe write down types and
things like that get the system to fill
in the unknowns for you in an
exploratory way so that's that's
basically what dan should have told me
he should have said well you know eight
years from now guy Steele will give a
keynote that code mesh and at that point
you know we want to be able to to type
in those rules and just have it do
things like infer the program so that's
the idea if you're interested in this
look at a I CFP 2017 paper go to mini
kenra Norg look at the paper on micro
cameron which shows an implementation of
a simple version and look for the second
edition of the reason schemer which is
about to come out thank you
Wow we actually have two minutes left I
think this is the first for you will so
we can take a question if you want so
the second test didn't work could you
just go back and do that again but fill
it in with kind of the readable symbols
so you can see why so you want you want
this one
yeah well the second one did work in a
sense it depends what you mean by work
so many Ken rooms or bar lemons idea is
prove me wrong right so you know this
program absolutely matches that
specification but you're right that it's
not what we had in mind and this is part
of the problem right so so even if you
can imagine barliman being 500 orders of
magnitude faster and in some sense it
solves program synthesis by example in
another sense you still have the problem
of writing down a specification that is
complete enough and correct enough that
you're going to get the right output
even if we're much much faster right so
so this shows that since this really has
at least two problems one is the speed
problem of dealing with this exponential
space and dealing with you know
synthesizing programs that could go in
infinite loops but there's also the
specification problem so how did you
know what to type in the box labeled
test3 how do you know what to type in
there well so so that's a good question
there are different ways to give a
specification so you could write types
right we don't currently support that
but you could write types you could
write examples you could write
properties high level properties right
the other thing you can do which I
didn't show you is that this is an IDE
so you can edit the code so you can be
writing some of the code and writing
some of the tests and writing some of
the types and it's gonna fill in the
rest for you so you could also use it as
sort of like an IDE but at some point if
you don't know what the program should
do and you don't know any of the code
it's not gonna figure that out for you
so you're gonna have to you're gonna
have to do a little work you know even
even with my example my stupid box
example I still had to figure out that I
wanted a box that was 2 inches by 2
inches
right so yes thank you so basically this
is automated TDD isn't it that's part of
it but but the the the the reason I gave
that intro is that the problem is every
time I give a talk and I've given many
variants of this talk every single time
I give a talk someone comes away
thinking oh well so your research is on
program census or your research is on
test-driven development or your research
is on logic programming or your recently
just like no no that's not it
the research is on lollipops okay the
research on lollipops and being able to
do things like just write down the rules
and explore it okay that's really what
the dream is program since this falls
out of this now if we can do if we make
the system much faster and we can get a
useful program since this tool or a
useful test-driven development tool or a
useful IDE great but that's that's only
a very small part of really the overall
goal thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>