<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2015 - Jacek Głodek - Typing better | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2015 - Jacek Głodek - Typing better - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2015 - Jacek Głodek - Typing better</b></h2><h5 class="post__date">2015-05-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5r7H93Fovlo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi guys and girls I met a gothic and I'm
skala programmer I have consulting firm
called hydrators and I have some
experience programming scout therefore
and today I'm going to talk about typing
better so watching it for you guys first
of all I want you to get some value I
would have to start so this is not like
really advanced talk i'm not going to
talk about female nets and and its top
and this is beginner and intermediate
level as was sent in the abstract I want
you to know like maybe two things after
this talk which is recognizing the
problems of statically typed systems and
being able to do to solve them in a
conscious in a conscious way so the
problems need to be solved need to be
solved the insight type systems and I'm
going to talk and talk about this
exactly ok so the types types are levels
that we put on the data I don't know
maybe how much of you guys know scallop
and study p type systems and okay so
okay so these are just you know this
stuff pipes are just levels with the
data type systems are rules that collect
those levels that lip
that let validate different stuff and
the rules of how we associate this
levels with the data so we have two
types of dynamic of type systems dynamic
and Static like this is a simplified
view but in dynamic systems the the
rules about connecting the value and the
levels the types are not enforced and in
static systems they are enforced by the
compiler by pipe checker so inside
static system during the compilation
time this the type checker gives us
feedback about how how's the integrity
of the system performing is it
consistent right so using this and the
functional approach where the type
system lets us build and transform data
in a predictable manner so so we said
that type system lets us reason about
code well right okay so the point of
this talk is this the enforcing and for
static type systems are enforcing type
integrity at completion time can give us
feedback about the problems of our
programs and we function they let us
build systems and using scallop for
example now we can build statically
typed systems that will give us lots of
people and we will be much more security
use but we must consciously choose to
build type systems and often people just
use your scholar and they are from Java
environment and everything
and they use normal like primitive stop
primitive types a lot not they are not
really consciously building the the
typology the type system to make the
system more secure and more and letting
us reason well this disco right so the
talks is the talking about what we
usually don't do what we should do and
what we can do in inside type systems ok
so I'm going to talk about primitive
types especially the case when we use
them too much I'm talking about an
unmarked link of the marshalling of the
data I'm talking about hide and effects
that are going to represent the decide
type systems Monica petrichor and high
design problems yeah but that's not the
slide right so let's start you know we
are all upfront primitive types they're
basically what really simple types like
string in double float at the
surrounding really don't give us much of
this security they're not really where
maybe concrete concise because even the
standards of the floating point values
are are are like nobody read read them
probably somebody read the standards
maybe in like nobody nobody knows oh we
got a one person who knows how how they
work and okay I could read the standard
so we open our
we want to build our type systems right
and and we often face this problem of
modeling early data our business object
inside pipe system so we just want to
model user so he has named he has a name
he has bio he has some password hash and
these are strings basically right right
and this causes a lot of problems for us
because we we don't have problems with
string basically can be empty so so this
is a vet this is a valid user right we
do we define the type that consists of
four strings and a user can be just a
combination of four empty strings and
this is not enforced by type system this
is this is not this is not safe and this
actually can happen when we get some
data from the user and just he just
passes NP strings he sub means the form
on the web and we get everything
emptying it passes because it's okay no
exception is reason and so on what about
if we try to if we another problem if we
don't know if we don't have stuff a good
pipe system we can have a problem of
changing the order of the of the of the
of the parameters when we call a
constructor of the of the type then no
no errors reason right it just it just
is completely useless out and we have we
have luck here so type systems first of
all we can use the dependent types right
so we can just build the user name he
has a name which is my name it actually
has some structures structure name have
structure email a structure
we can have my own which also is
validated by the type system we have
password hash can be strengthened of
course passport cash can also be piped
check for example we can check the
length of the password hash and so on so
basically these are these are the value
dependent types this is the Howrah
column and we can build the point is to
build the system like we try to define
user the point is to create the system
from the small building blocks that are
already safe and that are typed they are
not just primitive types we actually
build small types that that that build
bigger and like a bigger objects okay so
this is this is easy we can create some
some kind of a case class inside in
Scala specifically we can validate these
types and every time the constructors
run we can get an error so name cannot
be empty string so we can just validate
that it's longer so we build the name we
build the name type s from the building
block which is the string and we add
some logic to it we had some some
specifics is specifically which is we
want it the length to be proper for
example email has a format so we can
check the check the reg ex it with the
reg ex and so on which is as so we have
a types that are that are better we
can't now build a user with empty
nails and so on okay so this this kind
of thing always requires some syntactic
sugar like we cannot always if we if we
build email and we want to print it of
course there will be problems with
because its type it's not a string it
will call this two string method and
stuff we'll look maybe badly maybe it's
better what we all need to build not
only the type declaration and and
validations we also need to build some
or use some right library that gives us
some syntactic and sugar that likes the
usage of the type much easier yeah okay
so the second thing is enlarged showing
as we we got our pipes and and now we
get to we we need to get them working
inside of our system then marshaling is
like we can call it here the process of
transporting some data into internal
representation so we get some data from
the users from the form in the web it
gets to our server it's just let's like
JSON document and we need to parse it
and turn it a transform it into our user
type right so so this is this
transformation will call and largely
okay so so unnaturally we can work on
the different levels of abstractions
often we have like what we get from the
server our web framework is for example
HTTP requests
then we can put the data from the HTTP
request into some data transfer object
and this is which also can be type and
then type and then we can turn it into a
business business object that is
actually from our business domain that
we model with archives right so we can
respect and chaining of the marshaling
stuff I'm sorry it's not like border and
I order ok so so first of all when we
are marshall stuff and for example well
we get those we get this kind of
problems when we try to just just get
some email from our HTTP requests and
create art I and we get into problems
like this just raises exception so so
that's pretty bad we don't expect as we
as we are come functional programmers we
don't expect the functions to rise
exceptions we want them to return value
always so this is not much more
predictable when it returns value
instead of writing expect the exception
the second thing is that we need to
embrace the idea that the user can
provide us with the bed Valley but input
so so it's it won't just rise like
internal server error every time as
somebody somebody posts anything it
shouldn't it shouldn't always also
we shouldn't like we should have some
some some reasonable error msgs not just
get some input from the user and the
server would just die in them in this
moment right okay so on Marcia link must
be raised that bed including was that
the the the wedding is not exceptional
steak or often there will be very good
and any bigger system we need to embrace
that this happens even with if we got
our angularjs validations on the front
end we also need to validate things on
the API and it shouldn't kill the server
right so it's normal situation and we
need to treat errors like like we're
just validating it okay okay I'm just
this doesn't work so we got our hair
here we can we get our dependent type
and it raises exception what we can do
to wrap the our our our exception rising
type into a value we can use types like
fry which will just instead of a it
illegal argument exception it will
return a value that is that is actually
Taylor and and just with the data that
there was an internal
illegal argument exception so this is
normal value we treat it like a valium
we should we should model our
controllers our business logic knowing
using this this this this this this type
to to process the request okay so we
just we could just write email user
input right it would raise exception the
server would just fail it would return
500 to the to the web page to the web
browser I would be like it will be okay
what button want to have static
detection systems we won't have to be
like whoosh new we want to reason about
the code we want to know that if we
subscribe someone to the use newsletter
we won't know what's the result of this
function we want to know that it's
always responds it's not just an
exception that will propagate for the
stack up off of the program so what we
do here is we wrap the hour hour and
marshaling which is which is putting the
user input into our dependent type who
this video mouse okay so so we put our
dependent type inside this this special
try type so we can now just watch if
it's if it's a failure if it's okay if
it's an actual email we can then just
process it safely because it's are
validated business object we know that
it matches the reg ex its oh cool its
normal email or we can or we can handle
the exception and we can return
explicitly the bat request information
that the
email was wrong right right also this of
course can be can be chained and
embedded in 11 marshaling inside another
and and this function actually handles
the cases when when this marshalling can
fail and normally which we would just
put the exception to propagate and nice
five-hole era okay so so now we have
here we can use our email in services
with normal object that we know it's
validated its type site so it's soy
school and we should do that and we
often don't do that which is slated
thing without type checking right so it
just fails much more often is harder to
reason about the code ok so this
embracing errors and we went on our
Charlotte means that we don't have to
use try-catch finally blocks which are
which are not always easy easy to reason
about because they are not values we
cannot use them in functional functional
use them with functional approach we
cannot map over the strike edge finally
blogs and so on these are not values
these are just just most and we want to
program like using function we handle
errors add validation as normal values
and we embrace it is that they happen
and we handle them all okay so we use
the panel types to make validations we
don't use the if also the important
stuff is this email dependent type is
already validated right it's oh good
data we don't
put our input inside an object and then
ask the object if it's if it's actually
valid you know that it's valid because
it is playing right so we don't have to
ask anything you know it's okay we
mapped it we used we used detected
accountant the functional decomposition
22 now I let that in this one case when
the where the email is in the right
format it's a valid email okay so we
don't want the exception to propagate
and we want the direction with their
values to be values so this is often
omitted and I am encouraged to go to do
that again angel okay so one one big
problem that I see in when people
program scholar and type systems in that
once they have some object they can't
do-- to refactor refactor the code
around it yeah i mean like basically
reflect all right so how we have a nice
coat we probably have some validations
there and we just need to save this fing
into database right so so that's a
problem because when we create a new
user we want somebody signs up he
doesn't have an ID so the validation
won't won't pass because it because it's
just what we need long value and we have
one so so we put an option around it
with what good option around in it
because it's a it's maybe we'll do some
email verification so we don't stated at
the fat as it exists and it's and it's
really bad
we save so many lines of gold right we
just added option but the rest of the
system looks now really bad like every
coat style stylish style tips I will
tell you that in Scala you shouldn't you
shouldn't get on the option like this is
this is violating of that of this of our
functional type citing thing right this
is our new this is our new node pointer
exception we can download some something
from the database we will have never it
will have an ID we've tried to get it
it's empty so so everything Titus and if
it fails on the run time not on the comp
I'll times right so okay we can do
better we can have to two classes two
types right so you can have an same user
we can set a cap also a user which is a
site user and as you see there's not
this is like complete kind we don't have
any options here especially the problem
with the user is that probably our
business business rules state that user
must have an idea so this so when we
create user we don't have the ID now we
have two types which is unset user and
the user during the creating of the user
when we have some sequence in our
database the returning raw wind creek
when we insert it into the table we will
get for example the div inside the the
row and we can just feel the proper user
we get the unsaved user and we get back
a user so that's that's that's great we
don't have to touch around the system
type system right we don't have to
introduce options which
make our rest of us are caught cold I'll
perform unpredictably because every time
we think of the user we need to think if
there's an option there we have to think
that it the value is optional and we
should like in this case you make this
case when we get member I didn't get and
if it's an option we should explicitly
map it so so into a case where there
when there is an IV and there is no ID
every time we use it right and that's
not the case of wood if you if the
business rules state that the users must
have ID okay so so we should keep the
types concrete we should use if if
business rules take something we should
modeling inside type 6 system which is
the reflector around it and this
sometimes can be looked bad when we when
we see the amount of country we're
generating but we should well like learn
to do it better right we should find
libraries or or write our own libraries
that will add leaving macros that will
add some syntactic um sugar in order to
make this this look pretty ugly okay so
let's keep this type system concrete
right another thing is the problem of
hidden effects we can we also we often
see this kind of movement in scale and
get user we pass just user ID and this
is our our declaration right we should
get the user option okay so there may be
this user in the system hoarding maybe
he maybe not found or not fill up a lot
about not existent right so the problem
is that when we when we travel down the
rabbit hole of this function definition
we will now see that it tries to fetch
it gets the user right it was me fast
because we're doing krillion like having
throughput systems so it tries to get
the user from the cash he's not in the
cache tries to reload it from the
database at all there's like geocoding
that data that we may want and it will
just try to try to fetch from the google
so as so we can call the the great that
above the user alice and it's hidden
behind your name right and this stuff we
can reason alone it it's either user
exists in the direct database if are a
dozen right and it's simple this this
one is if this is the real
implementation of the the function the
option can return full or chemical now
even if the even the individual exists
so we now lost a lot of context around
lots of understanding of dysfunction so
so we get along because the google
servers were not available all right and
it's hidden inside the hour our
declaration of the function the name is
just it's just wrong right it hides
backs so so doing functional programming
we should control the number of side
effects then it will help us reasonably
cold ok
so we should state return types
explicitly to know what what we can
expect from the function and we should
link the functions according to their
actual maybe not implementation but
actual effects that it s and the things
that the function depends on okay
another thing is if we don't do if we
don't think the return types explicitly
we get into a problem where where the
type your parents make mechanism can
fail right so so we we create some
option here actually it's not option
it's a subtype sound sum of eight and
when we try to use it later that the
function will return actually some not
optional so we can't we can't process it
later like it was an option right we
will get an errors and this is not this
is not obvious if you just state the
return type that it is actually an
option then everything will be okay so
and it much easier to reason about the
code okay so here we're going to get
another function get quarter let's say
this is like okay I'm out of this space
or the power users has right so just
filter this is nick may be slick table
inside scala the our database aware m
yes so we have we just find find the
quarter by a user ID and return first
option so this is this probably retains
optional product great and it's the
problem is when the functions get really
long and we try to return lots of stuff
this gets unreadable automatically right
I don't know what this returns this
disorder is a couple with lot of
segments of couples with lots of things
going on and I'm not sure if the type
inference was working okay so this can
be like really bad so sometimes return
values are obvious like in the first
case they're at sometimes they're just
we just can't reason about them they're
just segments of string string string
and a couple of string and novel and
product with cereals know like this
doesn't make much sense so we can again
we use type system and define explicitly
what is the return type of the function
what kind of couples does it return we
can say its sequence of leather
information squatting informations other
staff accordingly me right so this is
like typesafe we can also reason about
it it's really readable it's it's cool
and and even though we have IDEs the it
like this is really not readable
exciting I mean so so also using type
system like like further programming
even easier because we have more and
more types you can the idea has easier
job total inference level in real time
for you to pop ok so there it is again
the the problem that we saw a moment ago
the tuples which are are really bad like
you can model things in
using couples or you can create our use
our type system they're rarely
explicitly type so we can make lots of
likes the idea won't help us the error
messages will be we will be really bad
and the code that we need to we used to
process happens if they're more
complicated couples it's it's really not
it's not obvious what this what is a
kind of stuff does also if we create
tables for example in two in two places
that will be like two lists of tuples
that we create in two places and we
concatenate them there there is a
possibility that we just we just swap
something and the ordering is not not
right and it's really bad okay so anda
one of the last things is that we have
shall we often do shallow functional
decomposition we use this this
mathematical concepts and functional
programming concepts low level functions
too early inside our business logic am
so so it gets brittle brittle really
fast so so this is kind of a readable
right we just got to get some form and
we get the user and we're trying to
prepare the form for the user and later
just gets really complicated waited like
a functional programming logic right and
we could just use another fight with
more functions because we could prepare
them like decompose them further so we
would have here only just get me the
form form tag and feel its body with our
forum for this user right and this will
be like two lines of code and hear all
the logic and readability is gone
and probably the functions that we would
use later on this this get me a form tag
and get me and fill the body of the
phone tag with the afforded this user
they would be much simpler and we could
just there would be explicitly said what
this function this this combination of
of mathematical and functional raters do
and it's not not obvious small
instrument okay so the simple pattern I
I my proposed here is we should do
top-down functional the compositions of
the elements of the power system which
we must handle the garbage in garbage
out stuff so we need to unmark things
consciously knowing that there should be
no exception the exception should be
shouldn't be the return value of the
function right so so it shouldn't be
that the exception is is popping out
somewhere and it just propagates over
this tag this shouldn't indicate me
because it makes reasoning about the
code words and we should keep control of
the side effects again so it's a more
MORE weekend vision about when we create
definition of types you should we go
with with with top down approach we
shouldn't say that user is for Strings
user is not for Strings user data
consistent email which is an email
consists of name that is a name and so
on it all has it should be built bottom
out so we will first of all we can build
a time which is named email URLs and so
on and then from this little building
blocks we built more complex things fair
right so this lets us keep keeping the
business rules concrete right
so we can wecan model our systems or
requirements that our clients give us
insight and type domain right layers
pipe pipe safely okay in reality there's
of course it's it's not like pipes are
all roses right when we don't use types
like in Ruby I'll productivity can be
really high right when we when we use
just creative types it sucks and again
typing helps us having a productivity
and also gives us another good good
things like like a reasoning about the
code so it's it's really fine the safety
often of the code is really it's it's
better than Knox type system because we
can reason about it we know that if we
do our no exception things propagating
for the stack we can we know what we can
expect of different functions also you
know readability is maybe the problem
because you can if you're tight magician
you can and you use really lots of types
you can program really beautiful dsl's I
think even better than them telling them
Ruby and stuff but you can you can go
into a map stuff and I mean laughs a
side business logic stuff which which
will make your cognitive brittle and
unusable also when we think of
maintenance of the system when we to
hire somebody or or let our colleague
take our system that we designed and
and he has to lengthen lengthen it it
can be really hard for him and so it
will be more like the slower laundry
here okay so if you want to know this
this was like like a simple stuff if you
want to know more I really encourage you
to write this type statically typed
systems and concrete systems and I I
think it would be great if you learned
about scalzi validations they're really
great esl-4 validations and very
comfortable you can you can subtract
types they they remove lots of problems
with our dependent types that means that
when we need some basically syntactical
sugar for our dependent types it's just
we can use tech types and they are
really great also when we were talking
about and marshaling and I told you that
you should wrap your function inside at
fri or or this kind of stuff if you're
using futures this can adjust future
what it should you should embrace these
errors and jump Ready which will will
have his presentation tomorrow he
created the great library for doing that
it just automatically wraps things for
you and you can just stay in which kind
in which type it wraps it around also
there's a great need help i created by
by conrad malevsky it's called types of
types and there are lots of lots of
examples of different types and and it's
great go go go ahead with it okay so
thanks I metric what I can't if you have
any questions or like when we
but the violation you've shown with it
tight quiet even if I yes of course
because it's like when yes it happens in
the run time because it lasts but it
must validate it is actually because you
are providing user input so user input
usually happens after the you run the
server you know when you compile it so
so so this validation win we'll run them
right yeah but you created explicitly
created the type that handles this
situation and it's modeled right this is
basically not checking a constructor the
require thing is a function that runs in
a constructor of the of the case class
so it actually runs a run in run time
right but it the idea is that this does
this little thing there this require
think lets you know that nobody will
ever construct this object with bad
values inside right so so next when you
get this object from other function as a
parameter you know that it actually is
think that has only like it it is real
email it's it has the ragged staff it's
it's it's not empty you can reason about
it like this so you know it's an email
it's not like nobody could construct
this object if it was
you if it was constructed with the read
data right so the idea is to validate
things using this so it Jones the static
link I'm checking validations and then
reasoning about the objects so that's I
mean I would need to see maybe an
example like i don't like so it was 100
said okay make your fit physically
return it by bucking some can to try or
adoption yeah I i if that's actually you
can you can return normal time hits it's
short right optional ID and it's AP I
guess we not search with that ah yeah
because it was never so it's also we
change here that we change the whole
height to use options in places when it
shouldn't be an option and then in the
rest of the system we have to use some
really obscure stuff and it was the my
point like this this get thing is not
not pretty sight but it will rise an
exception actually so it's not that safe
it's okay so going to use optional of
course arguments right
you can do about it's not the only way I
yeah and here maybe yes it's the place
where I these are these are optional
arguments for some salt function inside
one windows appear or or stop ha the
point is that it's it's really like
where do I put this dimension here here
here I am that's just like this is like
obscure and it could be married right so
if this was actually maybe types maybe
some better like better function this is
like really love Giuliana which can be
further modified just so good about
performance of games later I think this
objects will also that the young
generation collection post more often
yeah so I wanted to draw another one
with with the performance using first of
all the compiler performance can and
lower if you use certain types of
certain types of types we can happen
really a lot of calculation and phone so
you can use paste glasses everywhere and
we don't and we don't model it in a
proper way they will have run time they
will slow things down right but you get
safety maybe yeah I don't know if that's
that's not the answer it will certainly
be slower but if you if you there's
there's a
there's a Waco explicitly state
something inside a the case class that
will make it like a product that make
compiler think it's just a value it's
probably extends NE volim and it will
treat it like a value inside an object
so Justin just one when one value
primitive night SI different player but
they come the type checker will check it
so it's it's kind of letter also do you
run out of that great thanks</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>