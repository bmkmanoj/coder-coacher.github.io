<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Saša Jurić - Discovering Processes (ElixirConfEU 2016) | Coder Coacher - Coaching Coders</title><meta content="Saša Jurić - Discovering Processes (ElixirConfEU 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Saša Jurić - Discovering Processes (ElixirConfEU 2016)</b></h2><h5 class="post__date">2016-05-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/y_b6RTes83c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so thank you for having me here my name
is Sasha I come from the company called
air cloak and I have quite a lot of
topics prepared for you today so I'm
just going to start immediately and
hopefully I'll be able to make it in the
given time I'm going to talk a little
bit faster and yeah I don't want to keep
you hungry right the lunch is getting
close
so this abstract piece of art represent
how I like to think about the typical
system built with a lecturer line right
so it's a piece of software that runs
many processes at any point in time like
yeah these little yellow boxes these
Erlang processes like for a small to
medium systems it can easily be
something like in the area of few
hundreds or maybe even few thousands and
then for some larger systems it can
easily go even to above millions right
so we use a lot of processes and we get
a lot of nice benefits there we get we
get to use all of our cores right and we
can use more cores that given we are
scalable and we are fault tolerant we
isolate failures to individual yellow
boxes and we can detect failures and
recover from them and we can rearrange
those boxes and multiple machines so we
get distribution so quite a lot of
benefits come from relying a lot on
concurrency now these boxes are part of
the same system and some of them need to
work together to provide some service
right to provide some value so in this
like a simplified example let's have a
database worker process it's a thing
that has a socket to the database server
and it communicates with it right and
usually of course you will want to have
a couple of them like a pool but let's
stick with a simple idea for now right
so I have a DB worker and then I have a
bunch of other processes that want to
talk to the database and they in fact
have to communicate with the DB worker
right so here I have like request
processes handling HTTP requests and to
work together the communication pattern
is message passing right you'll probably
know that so we send a message it's an
arbitrary term it's like requests one
way one of requests asking the process
to do something and also to send a
message we need to have a process ID I
think which uniquely identifies the
process in the system we call this thing
a pit now the whole purpose of this talk
is to see how can we discover or get
determine the pit of the receiver right
this is what I call a process discovery
I
it's an official term but it's the one I
tend to use we are discovering a process
in the system and this is a seemingly
simple and a problem for which there are
quite a lot of different solutions I
would say there is no one-size-fits-all
here like with many other things and I'm
not even sure if we have a consensus in
the community as to which approaches
work better in different situations so I
want to say here are upfront I'm gonna
paint a picture from my own point of
view right I'm gonna give you some
subjective view and be aware of that
fact so this is not like an absolute
truth I'm gonna focus today only on a so
called local process discovery meaning
finding a process in the single node
inside a single VM instance there is
also a global discovery meaning finding
the process in the cluster of Erlang
nodes and there's simply no time for
that so right so that would be like a
separate dock so let's start immediately
arguably the simplest way to get the bid
is to start the process yourself right
when you start or spawn a process you
get the pit in return and then you can
pass it around the rest of the system so
let's say I have like a main function
the entry point in the system and there
I could start the database worker
process and now I get its bid and then I
could start the HTTP server process
which is the thing listening on port
right waiting for requests to arrive and
as I'm starting that thing I'm passing
the page to the HTTP server so not the
HTTP server knows about the worker and
as requests arrive HTTP server will
spawn request handler processes it will
pass the page to them and now request
handlers know about the worker so this
is the problem salt this will work I can
testify I have used this in my initial
early days this approach quite a lot I
have even ran it in production for a
while which is why I can also confirm
with quite a lot of confidence that it
has some serious issues right so the
problem here is there is a notion of
hierarchy here this is an ad-hoc
hierarchy a kind of implicit sense of
parents and children but really there is
no strong formalism here and this is
kind of where all problems happen
because over time things will fail right
this is a given some processes will fail
even if I am able to write the perfect
software there is Hardware underneath
there are external services there may be
other operating system processes
depleting resources causing unexpected
I have seen it all right so this will
happen a process terminates descendants
are left dangling behind probably
serving no real purpose but still using
resources the parent doesn't notices the
child termination and we are essentially
losing our system piece by piece over
time it slowly decayed but this is
definitely not what we want now this is
of course a solvable problem we have
tools in Erlang we have process links
and exit traps and monitors and we can
use those things to build a more stable
more formal hierarchy where a parent
notices a child termination and take
some corrective measures right to repair
the system so we could do this it would
be a lot of work it would be a real
reinvention of course we would be
rewriting that in Colo DP supervisor and
I would argue that no matter how hard we
try probably it would be inferior it
usually it would be inferior because
even if we're like a super smartest
people ever born and invest a lot of
effort we would be conflating two things
into one right so we will have these
workers which are doing some meaningful
service they both also have to worry
about their children supervising them
and do some actions and usually
conflating those things is less
efficient than separating them and I say
usually because it's not universally bad
it's even used right - this is the
example from Phoenix where we have a
socket process right this is a
abstracted two way connection between a
client and a server and it does like a
light version of what I have just
described right so when I connect to the
client I get my socket process and then
I'm joining some topics and so it will
spawn or start channel processes and it
will know about their pins it will store
them in their state and it will be able
therefore to forward subsequent messages
to corresponding channel processes right
so this is basically simplify the idea
what I have shown you and the socket
will also detect channel termination and
it will then notify the client that I'm
no longer on the topic and if a client
disconnects socket will do a proper
cleanup of channel processes it will
terminate them and this is basically
kind of the roles of what supervisor
would usually do for you so essentially
I would say there is a lot of overlap
between what the socket the worker has
to do and what an OTP supervisor would
usually do so it makes sense to combine
those things here because the
alternative would be to have a
supervisor standing side by side then on
top you need another process so that
extra processes per each connected user
for i would say little or no games I'm
not sure that they would really lift any
burden from the socket process itself so
sometimes it makes sense but it's real
like a special situation more than a
little rule right so more often than not
you will want to aim for your typical
supervision tree is powered by OTP
Supervisors so we start with the top
level supervisor we branch out at the
leaves we have workers right processes
doing some service some providing some
meaningful value and non leaves should
be supervisors cliff should be workers I
think some would say that this is like
the only true way personally I don't
mind occasional diverging from the path
for some good reasons such as the one I
have explained but it is kind of like a
general direction and this resolves the
initial problems right so now we have
proper detection of a failure a process
terminates a parent notices it and it
does it take some corrective measures
forgiven specification right and also we
have proper cleanup and it's very
important frequently overlooked part of
supervisor right so if like non non
leave supervisor terminates then you can
be pretty sure that the sentence will be
taken down as well and this is very
important thing so this solves the
problem right and in our example like it
could be as easy as having a top level
supervisor I start to work where I start
the server and suppose we'll then a
fault-tolerant right so in the code
something like this I have start clink
and I provide a specification a
description of how these children are to
be started or restarted now
unfortunately this presents a problem
for my initial take because now I don't
have the imperative control anymore I
don't have the place in the code where I
get the paid of the worker which I can
then pass to the HTTP server right so
basically the first idea goes down the
drain now there is of course there are
other ways one would be a supervisor
with children right so this is a
function it's basically a synchronous
call I need to have a supervisor kid and
then I issue a question to that
supervisor who are your children and
then I get a list of children back with
corresponding specifications of some
sort and then I can enumerate and I can
find the one I'm interested in and I get
a bit right so the basic idea would be
something like this I start the DB
worker and then I start HTTP server and
somewhere during initialization it would
ask its parent who are your children
basically who are my
they're siblings right and then I get a
list and a fundable worker store it in
the state and then I'm good to go
right so that's kind of a general idea
and you can get a parent fee that I
won't go there there are two simple ways
of getting the parent bit so it's like a
trivial problem right the principle is
what matters here now there are some
small print caveats there you cannot
really ask the question in the init
directly because while you're in the
init function then your parent waits for
you to fully initialize and as I said
supervisor which children is a block in
question so we have a classical deadlock
my parent waits for me I wait from a
parent we bought crash so I need to
defer asking that question
this will cause some other troubles such
as saddle race conditions if this
process is registered it's all solvable
I just want to mention there are some
kind of clumsy cab yet another problem
is this really does not scale well when
the call becomes more complex in my
dependency somewhere on the far end of
the super supervision tree right so I
could like walk to ancestors and then
move some descendants asking each one
about the children and I could find the
child it could be made to work but it's
obviously quite clumsy has a hacky feel
to it and it's very error-prone
right like I change this tree a little
bit add one supervisor remove one the
whole code breaks and then a special
problem of this approach as well as the
first one right both have something in
common which is that in prefetching pits
upfront during startup or immediately
post initialization and by doing this
I'm essentially assuming that the state
of today is the state of forever which
usually will not be the case right so
the whole point of these supervisors is
to acknowledge the fact that some things
will fail and we install supervisors as
the safety wire to react to those
failures and make the system heal again
which means some new worker will be
started and here we have a HTTP server
holding on to appeal of a non-existent
worker of something from the past and
this is the permanently broken system
right it is neither able to self heal
nor is it able to self terminate fully
right so someone's human has to come to
the console and do something to make it
work again until then no HTTP request
will be able to talk to the database so
that's quite a big issue now all this
being said the approach is used
sometimes and it will be recommended
sometimes you will find those
recommendations so I would say like on a
very type of scope there
level two hierarchy discovering your
siblings and you have to definitely make
sure by choosing a proper supervisor
strategy the determination of dependency
also causes the one who depends on its
determinate right the one who prefetches
the pit because like in this contrived
simple example the producer only makes
sense with this particular consumer so
if the consumer dies you need another
consumer and another producer something
like that yeah so it can be occasionally
used and it's fine under some
assumptions but on the general solution
now another approach would be to detach
ourselves from the supervision three
completely right because supervision
three is really about fault tolerance
about isolating failures and making the
system self heal whereas the process
discovery is about finding this is the
process in the system right those two
things I can agree that they do overlap
to some extent there is some correlation
but I would say it's not high right so
we could introduce a notion of a role
say process could proclaim itself
somehow inform the system that it is
assuming the role of database worker and
the system stores this information and
then the others can do the question
right who is the database worker and
they get a plate or they get nothing
and obviously the process terminates
then this information has to go away so
when a thing is restarted we get another
one who tries to be a DB worker it will
get it will store this information and
of course the system should not allow 2
DB workers to run in the same at the
same time right there can only be one
having this particular role and finally
if I defer asking this question to the
point in time when I need to talk to the
process then I can work with restart the
processes right so when an either thing
I discover a thing I talk to the thing I
forget about the thing but if I need it
like a microsecond later I will do the
same dance and maybe I will get the same
fit maybe maybe I will get a different
pit maybe I will get no pit right but
doesn't matter it's more consistent to
reality it's more close to what's
happening now and obviously of course
the way to do this is to use process
registration so we have this register
local elias's meaning elías which is an
atom can be associated with the process
and then anyone can discover it right so
there is this process register I would
say it's like recommended to avoid some
sun rays conditions to make the process
register itself it
it kind of works best so it registers
itself this will either fail if there
already is a DB worker otherwise it
succeed and hence for time known as a DB
worker for as long as I live
or until I explicitly denounce this
privilege and then others can just
reference me with this Adam and this
will of course again either succeed if
there is DB worker or it will fail if
there is not right and the discovery
sort of happens in the VM code itself
which resolves this atom so yeah usually
I tend to avoid this manual registration
as much as possible so I provide a name
option here like Lila's the gen server
start link it will also work with a
supervisor gen event and agent I think
it won't work with tasks but it doesn't
even make sense with that so yeah
basically that's it I provide the Elias
it either succeeds or fails and then
again I can use gen server call cast to
do the stuff and this is wrapped in like
a helper module and then the code of the
request process that wants to talk to
the base database is as simple as this
right so it's not burdened with these
mechanical details
it's just embedded there so this solves
the problem this is a good solution it's
frequently used it took me a while to
accept this fact because these register
devices really do resemble Singleton's
from oh oh but they are sort of
Singleton's but I tend to treat them
like aesthetical services right like a
fixed points in your system to which
others can hold on to or turn to to talk
to the rest of the system right and I'm
going to explain a little bit later I'm
going to show what this means so this is
like a supervision tree of or long
kernel application and you have a bunch
of register processes there
this one will be running in basically
every single system you write in elixir
and then I don't know Phoenix endpoint
will be registered under an Elias and
the Phoenix pubsub server and ecto
repository so it's used quite a lot and
you can use it to set up statical
services right but yeah what if I want
more what if I want a couple of
instances say I want a couple of DB
workers and I could like hack around
they they cannot all have the same Elias
of course so I could just do the
underscore hard code is made it work but
what if I need like some kind of
configurability say on my dev machine I
will run two on one deployment v one
another
100 workers so I need to make some
decision practically at runtime and one
way to do this is to create elias's at
runtime or to create atoms dynamically
right so this is kind of like a mock
function I have a start link it takes a
number right like a non-negative integer
from 0 to n minus 1 where n is derived
from some configuration right and then
it just does this interpolation it
creates DB brocro 0 1 2 3 and so on and
it creates this Elias and registers the
new process and then of course you need
an external like a loop or mapping that
will set up this code to be invoked for
every single integer and then when I
want to walk when I want to talk to the
process when I want to run a query
usually in this example I would just
pick the worker inside the code right so
I get a query string and I pick a number
from 0 to n minus 1 like a random or a
hash modulo N or round-robin whatever
and then again I create the atom and
this goes to the corresponding worker
this will work you will again find it
recommended sometimes but there is an
important caveat here right and this is
that I'm creating atoms dynamically and
this may crash my system because the
thing is that the you can only have so
much so much different items it's
limited right there is this item table
it's like you can have like above
millions of different entries so quite
large but still
and another part of the problem is that
atoms are never garbage collected right
meaning that create a foo bar once used
a couple of times never use it again
it's there in the table until the end of
time right so you can only save safely
use this as long as you're sure that the
total set of all lives you will generate
is finit and small ish right so here it
will probably work right I would use
like ten workers maybe hundreds maybe a
thousand definitely not million so I
should be fine there and you will find
this occasionally used I think it's also
worst quiz easy to use in Phoenix right
for pub/sub local for sharding for
example right so it's a kind of a cheap
solution that that should work but you
have to really make your assumptions
right because otherwise you will
pressure system so this is the example I
had in my first production it was a long
polling server so what happens is a
client
the connection to the server and we have
a some kind of a session and there is a
session process with a given ID say one
two three on the server and it basically
acts on behalf of the client it
interacts with the rest of the system
and the client does Paul's right what
else is new and it does a poll again and
maybe some other stuff so we have a poll
request subsequent it lends to the
system knows nothing about nobody
everything is completely alien and it
has to find a corresponding session
process right this is the discovery so
how can I do this I could use these
dynamical items just as I have shown you
and this would in fact work it may might
even work four days maybe even months
depending on the load but sooner or
later it will crash the whole system but
it's not a matter of if it's a matter of
plan at some point in time I will reach
the situation when my total history of
all sessions is about millions and then
everything collapses and it goes without
saying of course the bigger the load the
more users I have the more frequently
they come and go sooner or more
frequently will this happen right so
that's basically not a solution
now what would solve this problem is
what I like to call a rich process
registry which I believe is again
my own invention now I don't think it's
an official term and a rich really means
that alliances are not atoms they are
arbitrary terms right otherwise behaves
pretty much like a simple registration
and the way the reason why this should
then help is of course because terms are
garbage collectible
unlike atoms so I can I can add this
elías like a top will tag double
session with an arbitrary ID and I can
register this and then others can
discover the thing so yeah I really like
this approach I tend to use it more
increasingly over time because it allows
me to map to the problem and the way I
see it right so as I describe this
system previously somewhere in the
system there has to be a session process
for session 1 2 3 or there can be at
most one such thing right so it can be 0
if it crashed it can be 1 if it's there
but there cannot be two and I need to
discover that process and this is what
the rich registry really allows me to
implement it Maps quite nicely to that
idea so bad news it's not available out
of the box VM does not support the
you can roll your own or use something
else
the naive implementation will be that a
registry is a process it will quite
likely be a gen server and at the very
least each state will be of course
mapping from the Elias which is a term
to arbitrary kid and then when the
process wants to register itself it just
sends us in Cronus call right register
me is a full bar the register process
stores this information to the mapping
or otherwise reports and error sets up a
monitor this is important it has to be
aware of the termination right if this
process terminates it has to be notified
so it can D register it and that's
basically it and then you have a black a
bunch of readers doing lookups which are
again synchronous calls this is a naive
implementation it's it won't scale well
right so under load this will really
this register will become a bottleneck
so usually something called an ETS table
is thrown into the mix to make it more
performance to make it to MIT improve
the throughput I won't go there but I
can sincerely recommend you try to do
this on your own right - like implement
a simple registry gen server based then
try to add ets tables to the mix it's a
very good exercise but when it comes to
production I would not recommend rolling
your own unless for some specific
reasons there is a third party solution
out of the box which is called G proc
it's a pure Erlang library written by
all vigor I hope I pronounced that
correctly who is a bigger lung expert
and the library itself has been around
for I think almost 10 years or something
like that right so it's quite heavily
used I have used it myself had some good
experiences with it and I would argue
that it's the best if not the only
solution for the problem we have today
so it's available in hex it's available
on github and on github in the doc
folder you will find the PDF paper from
2007 or something like that which I can
also recommend it describes some
motivation decisions behind gyproc quite
a good read like 10 pages not super
involved fairly easy to read so yeah
gyproc has a bunch of features I'm not
even sure I can really list all of them
or name all of them it can be
intimidating it can be confusing
it's sometimes hard to tell forest from
the trees and I'm speaking from my own
experience so today I'm going to talk
about to which I find the most important
and basically like at least 99% of the
time I work with gyproc these are the
only two things I use so we have rich
unique alliances which is basically what
I said right terms as elias's and we
have also properties which pave way for
non unique alliances meaning that
multiple processes can be labeled under
some arbitrary category and discovered
as a whole so that's what what I'm going
to talk about G Prague supports a local
registration out-of-the-box
meaning finding a process or registering
it inside the same inside single VM
instance it can work with global as a
global registry with some optional
dependencies and I have never used this
myself and based on various reports I
have seen in many different places I
think that thing is broken right so I
would not recommend for me personally
Brooke is a local registry and nothing
else so I gave just my impression right
so use it you had a compile time
dependency or the run time dependency
and you're good to go and I want to
stress here again there are some
misinformation and gossip and rumors and
pure speculation that gyprock will bring
some other stuff to your project and
most notably the infamous notorious gem
leader and this is not true right so out
of the box out of the box gyprock
requires not on my jeep rock it's a
couple of modules and that's it it's
simple a pendency so yeah just want to
stress this because there are some
misconceptions about it when you start
your system there will be a single
gyprock registry and it's a singleton
registry right so every OTP application
and every single process in this node
uses that same gyprock and arguably this
is its biggest flaw in my opinion right
although I never had problems with it
myself
but I can see how that could become a
problem at scale and more complex code
base right so it will be nice to have
the ability to start multiple registries
either way that's the state today
so yeah let's see the usage right I want
to establish myself as the authority for
the session one two three and this is
how I do it it's recommended previously
was mandated that the process registers
itself and I call G proc reg
and I pass the registration triplet I
think describing the registration so the
first thing is a type registration type
registration scope and the elías itself
so the type is atom n which stands for
name which in gyproc stands for a unique
thing in a given scope scope with L
meaning local it can be G for global and
per what I've just said I have never
ever used G in my life and then we have
the elías itself which is arbitrary
term right and this will similarly to
simple registration it will fail if
there is such thing otherwise succeeds
and I'm sayin 1 2 3 and others can then
discover me using G proc where for
example there are a bunch of ways this
is one I pass that same triplet name
local elias and i get a pig or I get an
atom undefined
again similarly to simple registration
and I tend to use the name option as
much as possible so you can also pass
the so-called V at Apple as the name
option to join server and other friends
Aviat Apple is at Apple I'm going to
show you in a bit
it describes registration through a
third-party registry right so you can
use arbitrary registries such as gyprock
or something you build yourself and what
when you pass the stop hold engine
server start link will use that registry
to register the process and if you pass
it to junk so recall and cost if you
lose that registry to discover the
process so that's the gist of it it's
quite simple and the top of itself is
again simple triplet first thing is a
term via the second thing is a module
powering the registry right someone has
to implement it and obviously has to
export some set of required functions
it's four of them and I don't know how
they are cold but it's documented and
then there is the argument which will be
passed to those functions and that were
released obvious with the argument will
contain the elías which we are
registering or querying right so in the
case of gyproc I have a via I have a
gyproc and the familiar triplet name
local session one two three you pass
this to Jung server start link and your
process will be registered with gyproc
or it will fail of course and you pass
this to a Java server call cast and then
gyprock will be used to discover the
process and the caller cast will be
issued to that process so it's as simple
as
that the way I usually tend to use it is
a repeating helper function
like in this module which is powering
the processor had a session a function
name which is private takes a session ID
which is whatever probably binary but I
don't care and via a gyprock name local
session session ID and then I can have
like a start link which will take a
session ID and then here right I'm just
mocking the function which will return
the via topple and then it will be used
to register the process with G brach
similarly I have like this get messages
rights of something which will be used
by the subsequent poll process it needs
to provide a session ID and I just use
the name function to create a proper V
at Apple and then G prop will be used to
look up the process it's something like
this right so the usage from the poll
process can be as simple as this right
the poll process lands there in the
system think about it right it doesn't
know anything about anyone and it
basically of course knows about the
session ID which is like in a query
parameter or a cookie or wherever and it
just did this and under the hood the
whole mechanism is done so this is
simple of course if this is new to you I
can understand that you may be confused
and overwhelmed and it's fine because
I'm throwing like a bunch of stuff here
so try it on your own at home like maybe
it's weird for first and second time
around and then you can do it like in
the middle of the night without thinking
or blinking so yeah right so I should
mention that you can have multiple names
associated with same process unlike
simple registration where there can be
only one and you can have a bunch of
properties associated with the process
and the properties can have values I'm
not going to go there today but
properties allow us also to discover
processes as a group right so a bunch of
processes and that's what I'm going to
talk about so basically you can register
your register or property associated
with the process and multiple processes
can have the same property right so I
tend to use this frequently for some
kind of local pub sub patterns so here
let's say I have like a job with an ID
and it needs to emit some notifications
to a bunch of up front
unknown processes right and then I can
have these processes and they register
the property
I'm going to show you how it looks it's
quite simple so they all register the
same property which is then a non-unique
like a non-unique Elias and then when
this thing has to discover when it needs
to publish it just does gyprock look up
who are all prophecies registers as a
job 1 2 3 it gets a list of page sends a
message to all of them and I tend to use
this quite frequently in place of Jenny
went right so Joseph was mentioning the
Jenny went has some issues for me the
biggest one personally are is clumsiness
with respect to fault tolerance right in
a recovery of failure things and this it
works quite nicely right because
basically I'm using plain old
supervision 3 for fault tolerance right
so this for example this thing will fail
it will be the registered if I restart a
thing another thing will be we
registered right so I use supervision 3
for fault tolerance process discovery
for process discovery and those two
things mesh quite well and it's quite
easy for me to reason about it waste
simpler than genuine so yeah mechanical
speaking it's as simple as replacing an
with a pp4 property everything else the
same local job job ID and then you
register a property with undefined value
because here we don't care about the
value and then I can use for example
lookup bids right property local blah
blah and I get a list of bids and then I
can send a message to each one of them
and there is also a helper function G
proc send which will kind of shorten the
path for you so it will do a lookup get
the list of bids and send a given
message to everyone who is there so yeah
that's basically it to summarize in my
opinion gyprock is the tool for the job
if the job is rich local registration
and discovery meaning turns elias's
there are other tools for other jobs
right and if you need those other jobs
most notably related to global
registration the other tools are very
good and you should look into them but I
don't think someone recommend and I do
not agree with that
that you can use these tools for local
registration I don't think that's quite
fine because there may be some hidden
caveat or just a simple performance
degradation which compared to local
registration so for me when it comes to
rich local registration gyprock is the
best we have today I do not think it's
perfect and I can see some room for
improvement but it's the one we have
it's the one I personally use and is the
one I recommend summary right so I have
started with a couple of simple ways of
prefetching page during startup or
immediately post startup
I just shown you a couple of ways there
are a bunch of variations there but the
gist is the same be very careful there
it can be used and it's fine if you have
your assumption straight I would say on
a small scope a lot of tight coupling
and definitely all-or-nothing semantics
meaning failure of one is failure of the
whole coupled group something like
something of the sort but if you want to
really detach yourself from the shape of
the supervision tree and if you want to
work with restarted processes I would
say registration is the way to go right
assigning some kind of a role to process
in the system the simple one for
statical things probably stuff you start
like during startup and then reach
registrations for things that tend to
come and go over time and we don't know
how many of those things we'll have in
the system and dynamic items more like a
check under a very strict assumptions be
very careful there but if you're pretty
confident then that could be used as
well more details in the book write the
registries get a lot of airplay like
through a couple of chapters as a sort
of a side topic but still discount code
word for I think the whole many catalogs
should be valid like for next couple of
days so grab it while you can I have
brought two copies for a giveaway and
Leonard will take care that's yeah he
will choose the winners right so yeah I
guess that's it that's all I have so
thanks for the attention and let's have
some lunch
Oh
okay so did everybody hear the question
okay I'll sum that's yes so right
obviously the easiest way to do this is
do not do this right and that's usually
fine because things happen like at the
same time and it's okay we'll have some
kind of inconsistency while the thing is
restarting but if you really need to
preserve the calling process while this
other thing is being restarted then you
basically have two options one is to
extract the call itself somewhere else
where it can fail like a task or
whatever or another is to assume this
will fail and then you basically can do
a try/catch to catch an error in it's
okay to catch in there right because I
think Robert Robert Weldon freaking says
let it crash doesn't mean what
everything crash right so if you expect
an error there and you want it to to
handle it for some reasons you need to
keep this process it's what kind of
informally called an error kernel if
it's something very important to your
system then just catch the error and try
to minimize the scope of errors you are
catching and state the assumptions why
and should be fine I would say
yeah global this is definitely pretty
much similar to what gyproc will do it
will use an ETS table they will all be
synchronous through the same process in
a global as well as in G proc currently
but I think that could be in fact made
better with G prop itself and global
cannot have the luxury so every single
registration in global has to go through
the single process right but really
other otherwise is I mean today we have
one node tomorrow you may have something
which connects that node for example
right just for some interaction purpose
or whatever and then you already have a
checklist right so in my opinion local
registries local registry and global is
a global one right so that's kind of the
idea we have one in the back there
right so well I don't know but I can
only speculate that it's not as easy as
we think because it involves I would say
the biggest problem here would be a
garbage collection of these terms right
so I mean with my very minimal limited
knowledge of Erlang of the code of
Erlang I can't cook - occasionally I
would expect the implementation to have
a lot in common with ETS tables so the
question is whether why not just use it
yes table but it's just my assumption
right it's also stated in the rules
paper that there are such problems so
they went for just for the road of using
ETS table I am not aware at the moment
but I don't really follow the developing
future development talk for long I'm not
aware whether the team is considering
this option but I would like to see one
available out of the box as a library at
least I think the ETS based one I don't
think it can be made more efficient than
that I would say
what the here
we have we have here precisely so gyproc
has the support for global through some
third-party dependencies as I said the
one is called gen leader and I think
more recently they have been
experimenting with something called Lux
leader but I didn't follow that now from
what I gather and it's really just you
know hearsay I never tried it myself but
many people reported quite a lot of
subtle issues or with generally there
are in case of I think net splits and
yeah other other similar conditions so
my impression is really that that
combination is not working quite
reliable it may work for like a simple
demo maybe book for a while but when you
get to those nasty problems my
impression is that it might break so
this is not what I would currently
suggest or personal choice
no no all of these are Global's so rich
so global can be as it says here it says
rich right so that should be a clue
right but anyway global that was the
previous questions so kind of global
really diverges to something like a G
pro on a local scale when you have just
one node the terms can be the atoms as
sorters terms can be elias's there yeah
yeah so gyproc is supervised in its own
application because it's a as I said
it's a single don't think honest on the
same note so you start the Jeep Rock
application and you need supervision
three you will have the cheaper process
this is nothing you have to worry about
and it's one of those things I would say
it's like an error kernel a piece of
system which we don't expect to fail if
it fails then everything will be of
course lost because it owns some ets
table and all this data is just lost but
I would say it's quite unlikely this
will happen given how how long how
effort has been invested in in 2g Brooke
so it basically just store stuff and
looks up stuff in fact most of the look
lookups go outside of the process so
it's mostly revolving around storing
setting up monitors and reacting to
failures of registered processes I've
never seen crash like once yeah I did
you have another question or well yeah
okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>