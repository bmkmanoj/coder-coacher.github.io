<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2016 - Kostis Sagonas - A CutEr Tool | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2016 - Kostis Sagonas - A CutEr Tool - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2016 - Kostis Sagonas - A CutEr Tool</b></h2><h5 class="post__date">2016-03-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/XVOV0KQAf-8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">take away so thanks a lot as the
introduction said my myself and I have
been responsible for various tools in
the Erlang ecosystem this one is just
cuter is is really nicer it's something
that we have been developing for the
last at least two years and we have not
publicized very much this is actually
the first stock on cue there that is
being given and just this morning we
tagged the first version on github so
that we have something that people can
refer to so this is a bit of the
overview of my talk and since this is
after lunch and people are tired I
decided to do quite a bit of demos as
opposed to just presenting slides here I
hope that this will be entertaining and
interactive I very much encourage
questions at any point so this is a
token testing so cuter is a testing tool
and I will briefly overview the tech not
the options that one has in Erlang for
doing testing in particular unit testing
property based testing and of course con
colic testing which is which pewter is
about and then i will look at all the
other things that you can read here by
the way cuter stands for a con colic
unit testing in Erlang so without
further ado let me try to start by
saying that testing is important however
there are various people that don't like
to do testing partly due to the fact
that it's in many respects a manual
process so one of the most commonly used
frameworks for testing out there is
so-called unit testing
cheese started from languages like Java
and of course since a number of years
now there is any unit system in Erlang
also so what unit testing means is that
you have a program and you specify a
number of units that you test then you
specify also they expected outputs that
you get and then you write using some
language that you expect when you run
this unit tests that you get this output
so here is a program that I have so let
me show it first here in a bigger font
so that you can see it it's a small
function it supposed to take a list of
numbers and then does some
classification on the outcome of the sum
of this list of the elements of this
list if the sum is negative zero then it
returns negative if it's less than my
favorite four-digit number it returns
small otherwise returns big okay so i
have this program here so i can fire up
the Erlang shell i can compile it don't
worry about the warnings and i can say
classify of the list with 42 in it it's
a small outcome and classify this with
minus 54 it's a negative and with 5400
is a big okay so i can turn this one's
now into unit tests and use a unit
testing framework to have them
automatically run every time I
but you can see here it's a bit of a
manual process not very painful
obviously because we have a very simple
program but a manual process
nevertheless now this is not the only
type of testing that you can have in
Erlang in functional languages in
general but in Erlang in particular they
have been various tools that do
property-based random testing the Erlang
quick check is one of them proper is
another trick is another one there are
various frameworks and they give you a
way of having semi-automatic testing so
in property based testing frameworks
what you have to do is you have to
specify a property for the correctness
of your program so who could possibly
help me here in specifying a property
for this program anybody John somebody
else okay so i will not keep you here as
i have a property here it is I can take
it also and put it higher so that these
compiles here's my property does it
shown very well it says that the
classified function works ok be for all
lists of numbers then if I call classify
on this list then the result is either
negative small or big okay so we would
help we would hope that this property
works also i can now compile again this
program and i can write run with my
favorite property base testing tool
the probe classified okay so it past a
hundred tests I can actually run say
10,000 tests it passes them I can run a
hundred thousand tests it passes them so
I think I would you know hope that now
by program my function works it works
for all inputs right as we probably
guess this function here has a has some
errors okay it actually has at least two
kinds of errors and to understand sort
of the kinds of errors that this
function has you have to understand that
actually what this function does is this
okay so I there is a compiler it inserts
an implicit cultural case closed here
that will throw an exception if none of
the other clauses much and there are
values for which the other clauses don't
much and you can very clearly see here
by the way you can I can show you the
same thing with any four-digit number or
actually I can show you the same thing
for any integer there is an input that
will make this function crash so things
that we note here for property based
testing is that you it's a semi
automatic process you have to specify a
property manually and actually you get
no guarantee that the no matter how many
how many tests urine you have no
guarantee that actually work function
will never crush
never your program will not do anything
wrong and this is where con colic
testing comes to play con colic testing
just in case you were wondering it's not
a line it's not a word that exists it's
a made-up word work on colic it stands
from the combination of concrete and
symbolic and it it it does concrete and
symbolic execution at the same time so
it's a fully automatic testing approach
that aims to achieve very high path
coverage in principle it aims to act to
explore all posts all possible paths
that there are in the program now of
course there's in big programs is a big
number so we need some way of actually
exploring only some of them but in
principle if you have enough resources
it can achieve complete path coverage
and you know path coverage is not just
so property based testing or the other
the other techniques of testing if you
were lucky they were only achieving edge
car or a statement coverage we saw that
it isn't even achieve that in that
particular case here we want to achieve
path coverage so let's see a cuter in
action and and we'll run pewter actually
is a script you can use it from Erlang
but it's much more convenient to
actually use it from outside their line
and you specify the module that we want
to test the name of the function which
is your unit here it was classified and
then you give it a list of the arguments
and I have to use these funny quotes
because it's a shell and you have to use
you have to give it some arguments as a
seed and actually it doesn't really
matter what argument you give it you can
give it any argument you like
but it's a good idea to actually give it
an argument of that will make the
function not crash because other because
otherwise you will see it in the
crashing output this one too so as we
saw with the list of 42 this function
doesn't crush so now I start this
and with the mines are Eric have to
recompile this and now it works and it
gives you a lot of outputs that will
make the function crash and the
interesting outputs is of course this
one and at the end it tells you here are
the outputs this one is a very
interesting one if you call it with a
list of 4 7 11 it will crush this is
another interesting one here if you call
it with a list of these to argue numbers
that if you do the quick math you will
see that they are 24 7 11 and this is
also an interesting one if you call it
with a floating point number 47 in devon
2.0 it will also crush any random
property-based like testing tool will
have pretty much no chance of getting
this particular output input to crash
okay so this is the point where I hope I
have convinced you that there is
something different going on here in the
testing world then the other testing
techniques let's see how this one is
working so calm colicky execution is
sometimes known as dynamic symbolic
execution so the idea is we start with a
concrete execution and while we are
doing the concrete execution we collect
some symbolic constraints on the program
inputs that cause the program to follow
a particular specific execution path and
then we use these constraints by
negating one at a time to force the
execution to go to some other paths okay
so by negating systematically these
constraints we will eventually explore
all the paths
so that's what's happening here so
what's happening is that we do concrete
execution and we collect information we
get accurate information about program
state which might not be easily
accessible when we are doing purely
symbolic execution and that's why I
called con colic execution tries to mix
the advantages of both symbolic and
concrete execution at the same time so
what's happening under the hood is that
we are collecting so-called path
constraints so we could collect
constraints on the paths of the program
in each variable that depends on the
input has both a concrete and symbolic
value associated with it and we express
pass constraint in an appropriate logic
and then we use some smt solver
technology that during the recent years
has become very very powerful to solve
this constraint and generate new inputs
that will chair the future test runs to
explore unexplored paths so that brings
a three and we systematically explore
all this execution three up to a depth
of course because in general it might be
infinite we have might have some parts
are going to leave infinite execution or
the three might be very big so that's
what's happening here let me show you
another example just to show you to
illustrate what's happening here is a
variation of the previous one we have a
compare function that checks whether its
result is greater matches exactly or
less than 0 whereas greater matches
exactly where is less than 42 and it
turns an appropriate item for that sort
of thing we have F calm
function that has a sort of obvious
error it ignores the cue case and we
have a higher order also function that
takes a list and then calls list for
each with ef compare on each element of
this list and then we have food so let's
see what cuter will do on this sort of
thing the program is called SMS f2 and
full with the list of say 0 and Y is an
error
you can see that it's a live demo what
is the bug here
so it finds erroneous inputs 42 happens
to be the star so it prints them out as
like that but at the end you get the
inputs that lead to the runtime errors
and you can see that all of them have 42
in them which is the case that is not
being handled by this program ok so just
showed you this so that I show you how
this one works underneath there are
various places where things can fail
here there is a place here that there is
a failure there is a place here that
there is a failure by the way you can
add explicit assertions at any point in
your program and cuter will find inputs
that causes assertions to fail if there
exists so if you see this program as
control flow graphs for each function
you will see that for example there is a
pattern matching compilation happening
and there are tests so for example the
compare function so the F compare
function calls compare and then checks
whether we have a GT output or an LT
output otherwise it fails if none of
them is true so this is exactly the same
representation but in control flow
graphs the same for the list for each
function notice that now I called also a
function from another module and cuter
automatically knew how to instrument
this library and follow the control flow
graph there so actually cuter can handle
the whole OTP pretty much so what
concrete execution is doing it follows
initially one particular path the one
that is shown with blue core
and there are some unexplored paths that
are shown in red colors okay so we start
with say the list containing 17 lonely
and of course this list will match this
cones sell this pattern matching console
here so we'll go to the true branch and
so on so forth so what's happening here
is that we are following in concrete
execution and we're checking constraints
and since we went with a true branch in
the first time the next time we should
go with a false branch we get these two
constraints these to constrain jealous
unsatisfiable these are the exes you
were seeing previously wherever you were
saying a dot it found another path to
follow whenever you were seeing an ex it
it found an unsatisfied and viable
constraint so the next one is more
interesting it says that we have as a
constraint that the list is not empty
and the head of the list is greater than
42 so we ask the solver give us a value
that satisfy this constraint and the
solver would say safe try with 54 okay
so we'll get something with 54 there we
have one more constraint here it says
that the list is not empty the head of
the list is not greater than 42 and the
head of the list is 42 the only value
that satisfy this constraint is the 42
value and we'll get an error so
continuing like that we'll explore all
possible paths so there are various
things that are involved here that we
need the cell strategy which decision no
to reverse and the tool uses two metrics
and I will not describe them here but
basically it systematically explore
all the possible paths of existing the
program we also have a depth count that
checks how many of these branches we
will explore every time and after that
we don't we don't collect any more
constraints from these branches okay now
this is the vanilla tool the tool has
support for type specifications and
actually it's a good idea to get types
to put type specifications in your
program because they had documentation
but it also helps cuter when I run let
me run it again to see what's happening
here the classified thingy the tool was
also showing some it was showing some
interesting test cases this one but was
also showing some test case that look
like this one it says that if you call
it with a list that has a float and the
empty list then this will crash but
obviously and indeed they will crash but
you probably don't want this as an
erroneous input what is that want to do
is you want to write that in the same
way when we're out to the property based
tests that we wrote a generator here
that this is a list of numbers my
classifying is supposed to work with the
list of numbers
and we'll return either negative or
small or big okay so now with this type
spec the tool will only find lists of
numbers which is really what you want
by the way I'm showing you the very slow
version of the tool deliberately because
you can write running in parallel so for
example I can run it with four solvers
and for polar's and now we will run
these things in parallel and if you have
a 64 core machine you can play with this
very nicely ok so let's continue so you
can add the type specifications like I
did and you will get the the inputs that
actually makes sense and you are and you
are interested in and of course what's
happening with these type specifications
that they impose and you can make them
actually as refined as you want so for
example in the other in the second
program I could say that the this
supposed to work with a list of terms
because I was having a list for each or
you can say that I want to work with a
list of integers only ok so you can make
them as refined as we want so what's
happening that if you have the specs
this the type constraints that we have
from the specs are added as path as part
of the path constraint so they prune the
inputs that you are probably not
interested in this was a third demo I
think actually I did it already so let's
do one more change let's do it a bit
more interesting here let's put some
more constrained one more clothes that
will say that hey if I call the
classified function with a list
that has less than three has three or
less elements then this is a too short
okay so what do you expect that will do
now here's the program
come on it's easy
so it will only find erroneous elements
that have lists of at least size length
4 and above let's it ha no runtime error
occurred and this is because the default
depth is very low so i can increase this
depth I think it's 25 the default oops
no I need the bigger one that's doesn't
matter so this is my favorite at least
that adds all its elements 24 7 11 so
you can see that the prince list with
size for first then list with size 5
list with size 6
ok
I will let it run and continue on the
presentation ah here's another twist i
can write since i'm a functional
programmer i can write lists some this
way will the tool be confused by the
weight has finished and sells you all
this erroneous inputs so so i can write
lists fault l with fun airlink plus and
with zero so will that will be confused
nope
it will find exactly the same things as
before okay trust me and now the coolest
of all here is a generalization of that
program where we have two arguments of
the function and the first argument is a
function and if we call now this with
airline plus with a 32 this is exactly
the same function as before now what
should the tool do here what should it
do now here a tool that is supposedly
sound
it so happened that I have it here okay
not exactly the second as the other luck
the other
so I need to export this
and run it again and now I have to give
it here some my favorite function let's
say the function that only returns 0
ah I put it inside I'm sorry
it generates functions that if you apply
them recursively they will return for
7-11 of lists that are 4 and above this
is a WoW feeling if you want to make it
even more interesting here is the Y
Combinator and it will return recursive
functions that if you apply them to a
fixed point
huh you had a guess it stops did it
always stops okay so here's how it is
underneath it's actually it has various
components the con colic execution
component that uses processes in the
erlend way and spawns various
interpreters to do stuff the path
exploration component that has a
scheduler and controls which thing will
be explored next and the constraint
solving component that is using z3
currently a tool by microsoft research
but we are working on adding more SMT
solvers there are various technical
things on how it works underneath but I
will skip this stuff the tool is
available in github it works for airline
goatee p 17 and 18 it has some
limitations currently it does not
support maps we haven't added the
support for maps but it's a technical
ability to do that sort of thing it
works for binaries it works for
higher-order functions as you saw it its
support for recursive type is still
incomplete and we are working on that
now before I finish let me show you i
deliberately chosen small examples here
just to show the capabilities of the
tool and make this stock understandable
but actually this works on big programs
okay here is a real case there is a
posting the Erlang bugs mailing list
last May and it involved the
module from the Erlang goatee prc1 here
is the post by like some of my
applications don't compile anymore
because they have been necessary Koshien
explode oracle mr. the program's a clash
in the compiler error so I so happens
that I have this program here it's the
OTP internal but i have just renamed it
to OT paint so it doesn't clash with yo
TP internal module in the OTP version
that i'm using you can see that's the
real thing it's 641 lines in has a bug
somewhere where is the bug cuter OTP in
this were actually is a very good case
for Tudor I to tell you the truth this
is a very nice case for Tudor Twitter
because it only has one exported
function so it's very clear which is the
unit to test obsolete it's called
obsolete and it takes three arguments m
MF a so what's your favourite mfa lists
map map with two
I can recompile and I can put force
solvers and for polar's you can put
whatever you want in here it doesn't
matter you will if it's not it but you
want probably to put something that it
doesn't crash so that you don't see it
also in the errors here it is ssl
negotiate a next protocol with additive
one if you call this OTP internal module
with this input this will crush and
actually it's the only one you will see
that will finish so this one now does
also gives you guarantees that up to
that depth for search there is no other
bug in this module
so it will very soon finish so will I so
here is where some concluding remarks so
I presented the con colic testing tool
for the functional subset of Ireland and
there is a tool that has just been
tagged on github with a first release
first versions 0.1 but it's pretty
robust by now we have been working more
than two years on this future work what
we are doing is we're doing better
search strategies we are experimenting
with more SMT solvers and we are trying
to handle concurrency also so calm colic
execution just tries to do path coverage
but the interaction of processes is on a
different level so you need something
that controls also the scheduler we have
quite a lot of experience in doing tools
like that but not in the context of con
colic execution
this is still going on but believe me it
finishes in something like one minute or
something more something like that and
that's it
so so so this is this is a very good
question and this is was something that
I was prepared to also talk more about
on Saturday where I give a three-hour
tutorial on this that is much more
obviously than good fit talk this is a
very good question I will actually
slightly rephrase it and give you
another example partly inspired by your
talk so we have obviously been using
puter to test various things in their
language p system and yes there are some
issues with strange types that contain
semantic information a good example is
the calendar module okay whoever
designed the human calendar didn't
design it with simple types in mind so
for example you can have a very nice
specification that says that the months
are from one to twelve the dates are
from 12 31 and the gears are from 9070
you said till now or from zero till
infinity or whatever the problems that
not all all of these combinations are
valid dates so in particular 30 personal
februari didn't even exist in the
swedish calendar that you described in
your talk so in those cases just writing
a simple spec a simple type is not
enough so what you have to do in your
unit is you have to write these things
as a case statement so you need to write
something that tells you which are the
valid dates and right
wrapper around it and saying case
validate of true my unit to test else
okay now there in those cases you have
to spend a bit of effort to describe the
valid inputs and the non valid inputs
okay there are cases where it's not i
mean it is automatic but you will get
some inputs that they make your program
crash or write but it don't make sense
or if you have if you want to your
calendar module to also do something
reasonable for 31st of februari you have
to then change the code similar things
will happen of course with data
structures or if you want a balanced
search tree you know you have to have a
check that says case is balanced ER than
this otherwise not there is more to it
so the tool has also support for
whitelisting various things a typical
example is stuff that of do with login
you don't want to search all paths in
your lagger okay so you want to bite
with certain things
yep
well of course we have some learnin
course a we have multiplication for you
we have various things that are
nonlinear and yes of course we have to
to take this into account a we can take
this offline there were some sliders say
how the mapping is done but we can take
this a bit of line I think it gets a bit
too technical for yep yes of course
there is an airline version of it yep
psycho failure within a unit or more
sophisticated ly by the types that are
going in and thinking your initial
example is there a way of segregating
the empty list containing failure cases
automatically from here the very basis I
haven't thought about it quite frankly I
think you have to provide some extra
information and you saw that for example
when that you put the types this
disappeared so without giving some extra
information that truly you know just
generates whatever the smt solver
decides to generate you saw that some of
this you know lists were not exactly the
ones that you were you would expect for
4 7 11 you know
the sign of failure so say we're hearing
two different of finding both of it so
you're used to once again we know
exactly where each of these failures
curse so we could separate them based on
the program point that this would be
very very simple so in my experience of
our you know we use typically start if
you get you run with the default depth
okay if you get too many of these errors
you can just simply run with a smaller
one it will take actually less time to
Torah and you can eliminate those errors
and then start with a bigger one that
automatically segregates the inputs yep
a note that we have with this is on our
to-do list this one have to boost
I think it's obvious from the point that
this is on github that this is all open
source and you can contribute you can
post issues you can do suggestions and
stuff like that also this is distributed
by with GPL but it this is not at all an
issue because you absolutely don't have
to put anything in your code base for
this tool this is totally offline it's
not even an include like improper you
know I know that some people are worried
about this thing I though I never
understood it but I'm in academia how do
they know this stuff yep we never write
code with bugs yes where is the point
which is obviously they may be sure so
actually the probe you are you're right
of course you are absolutely right um
but actually there are some other issues
in applying it to say the airline
compiler you we need to have an entry
point that doesn't do file manipulation
for example
okay so we are actually applying tutor
to parts of the height compiler which we
know a bit better than the Earl and
compiler and there we are testing you
know modules at the time we are not
doing what you what you're telling me to
do and the reason is not is not only
that the scale is so big there are some
other engineering issues involved in
applying cuter and saying you know just
test compile you know this will open a
file that you know doesn't will do other
weird stuff that you know you have to
define what your unit test I mean cuter
the U stands for unit and you are
responsible to define what your test
unit is okay in that respect that Thun
is not totally automatic you have to
tell me that this this is my entry point
and everything will go with you else so
there is not an easy way of hooking to
the compiler currently once we solve
that I think the scale up the scale of
course the scale will be an issue but I
don't think this will be the main
currently not the main issue once we
ever come other issues
yes yes yes yes one thing that is not so
obvious perhaps the first time you hear
about puter is that cuter it's obvious
once I explain it cuter just finds
inputs that cause the program to test
tooth to fail so you cannot take your
unit test without it is zero functions
and start using because they don't take
any input so tutor will not do anything
on them you have to have a entry point
units that take some input and cuter
finds inputs that cause the program to
crash okay so that's actually won
something that most people don't think
the first time they hear about cuter
that they cannot just take their a unit
tests and now exercise them because
typically this unit tests are with zero
oddity they don't take any arguments
anything else yep
come again
this is related to some other question I
think we can you can you guide the tool
towards and the answer is currently no
the tool has a particular strategy sir
strategy we are working it's part of the
future work to experiment with better
search strategies we have not looked
into this yet we want to handle full
erlangen currently the only thing we
don't have well the main thing we don't
have is recursive handling recursive
type definitions in maps but you know
maps are not so commonly used yet yep
there is no issue with infinite loops
the depth guarantees that we are going
executions to a point
you
are you
we are doing concrete execution up to a
depth I mean to have an infinite loop
you have to have some branches you have
to go back somewhere you know and that's
no no no this handles the crashes it you
get you know it you have to have some
assertion that's getting violated or
some clothes but much or whatever else
you know there is this might not
currently get out of memory these are
particular program points where there is
some exception happening we can perhaps
this castle of line I don't understand
what the issue is perhaps i'm naive yes
we are working at the level of coraline
so actually in principle this could work
for release here also yep
we have no plans of supporting that but
we welcome contributions from users as a
matter of fact we had to do changes to
one file in OTP that does the pattern
matching compilation and we we are
carrying this around in part of computer
code base so I doubt that it will be so
easy to support previous versions
thanks for the questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>