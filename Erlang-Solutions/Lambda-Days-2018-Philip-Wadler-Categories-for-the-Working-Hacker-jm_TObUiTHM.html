<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2018 - Philip Wadler - Categories for the Working Hacker | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2018 - Philip Wadler - Categories for the Working Hacker - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2018 - Philip Wadler - Categories for the Working Hacker</b></h2><h5 class="post__date">2018-03-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/jm_TObUiTHM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">there's this growing community of
developer conferences about functional
programming it's an amazing thing landed
aces one of the groups has been leading
the way and the size of the audience has
been steadily growing so that Wow was
very heartfelt and I want you to give
yourselves a round of applause for
leading in this growing community so I'm
going to be talking about something near
and dear to my heart
category theory everybody keeps getting
upset that some of us talk about
mathematics some of you get excited
which is great
but some of you get upset and that's
very sad right there's a 17th century
mathematician who said if you can solve
a problem and use mathematics to do it
and do not use math look it's as if you
are looking for something in the dark
and refused to light a candle
this is what asthmatics is it is your
candle for seeing your way and some
people think oh no no no no no no no I
can't do mathematics it's too hard no
what's hard is not using the mathematics
when you can you can all learn and use
the relevant mathematics so if you get
nothing else out of today I hope what
you get out of it is mathematics is your
friend
okay and I'm always been to run down and
get my little fluffy land out the bag
but I won't ever look what no I will
see mathematics is fluffy it's your
friend its cuddly it's warm it's a
smurfy my daughter made this for me my
daughter has lots of little cuddly toys
which are called Smokies well she's
grown-up now now she has a kitten
instead but she made this for me because
she thought that I should have something
warm and cuddly and I think it best
indicates though attitude you should
take towards mathematics so how many of
you think you think math fact with your
friend
good how many are kind of scared of it
because they think it's not for them
okay of those of you guys who think it's
not fair how many of you know JavaScript
right
javascript is much much harder than
mathematics what mathematics is designed
to be understood and sensible
inconsistent
so don't panic right when you see
mathematics don't panic you can do it
it's your friend it's fun it is fun it's
exciting it's you know this is what got
me excited my first entered functional
programming the idea that people had
designed instruction sets for machines
back in the 1930s before we started
building stored-program computer
so you know functional program is just a
little bit older than the stored-program
computer right and we all talk about
Turing as one of the founders of our
field right and Turing went to study
with Alonzo Church and indeed Turing
wrote the paper proving that lambda
calculus and Turing machines were
equivalent at the very beginning of it
he says and this means we can use the
more elegant lambda expressions
so it goes back a real long way just
slightly further than the beginning of
computing and
it's great so let me tell you a little
bit about category theory category
theories is often the secret sauce
behind things so like people get scared
of the name mode add in Pascal and it
comes from category theory but the whole
point is you don't need to know any
category theory at all to use monads if
you know category theory then it can
help you discover things like monads
that's what it's there for help you
discover it I've what I've often thought
and you'll see here right what category
Theory really is is stuff that's really
familiar and that you know really well
made difficult and then you might think
well why do I want to make it difficult
but by stripping stuff away you get it
the essence of things and you can see
things that you wouldn't see otherwise
so I'll show you a little bit about that
I'm just gonna show you just enough
category theory for the very basic data
structures that we use in computing and
it's precisely because of learning this
category in theory that that drove home
to me why these are the basic data
structures right you might think about
some other stuff like the array no it's
not the array okay the three basic
structures that you need are the product
the sum and the exponential so let's
learn about those
and then sort of a boost to giving this
talk is that recently there have been a
lot of scripting languages for smart
contracts coming along and some people
doing this are very clever so there's
things like simplicity and Mickelson and
Plutus which is done by IO HK and
company I consult for and the category
theory isn't hidden anymore
it's right out in front you can see that
they're making use of these ideas in
ways that were you know previously
behind the scenes are now right up front
so I find that quite exciting and that's
great for motivating stuff right
cryptocurrency you know what could be
cooler than that and they're making use
of these ideas so let me show you what a
category is it's very simple you write
some stuff in blue and some in red and
some in black
that's great no flipped about isn't it
like that's what this play okay there we
go so you write some stuff and so in
blue right here thingies in blue are
called objects just a new name for a
thingy
thingies in black are called arrows and
I'll write their names in red and that's
it
so one model of this that you might
think of is set theory and you can think
of a as a set and B as a set and then f
is a function whose domain is a and
whose range is B that's one way you
could think of it another way you could
think of it if you know any algebra is
that a is an algebra and B is an algebra
and s is a morphism between algebra x'
or a homomorphism and that means it
preserves the algebraic structure so if
a has some operator on it and x and y or
two elements of a then we can either
combine x and y with the operator and
then do F 2 the result or we can do F 2
the X and s 2 the Y and that will move
them both into B and then in B we can
use B's operator and that'll give us the
same thing so this notion that you can
just things are preserved by functions
is called a homomorphism that's a big
name for a very simple idea and then
there are other structures that map onto
these as well this might be a type in a
programming language and this might be a
function that given a value of this type
computes a value of this type or you
might be in logic and this is a formula
and this is a formula and this is a
perms that this formula implies this
formula so there are lots of different
ways to viewing this and BK but if
you're confused by that just think sets
and functions that would be fine
okay then we're giving very little
structure about these arrows but we're
given a bit of structure we're told two
things well first of all if f is an
arrow from a to b and b is an arrow from
G to C then F semicolon G F followed by
G sometimes goes to a written G circle F
just if you like doing everything
backwards s circle G of course would be
an arrow from A to C we call that
composition of functions which is
mathematics for sticking a couple of
functions together
and the other one thing we have is that
for each object such as a there's an
arrow identity of a that goes from it
back to itself and does nothing right
one of the functions that exists is the
function that does nothing and you know
we're told a little bit about these oh
right they're called optics and arrows I
told you that right and then we know a
little bit about these things
we know that composition is associative
meaning if you stick F and G together
and then stick that together with H
that's the same as I'm sticking F
together with G H stuck together ok so
the order of parentheses doesn't matter
and if you do the identity and follow it
by F well that's of course just the same
as F and that's the same as F followed
by beta entity on B since B is the range
of F okay and these objects this object
is sometimes called the source of F and
this is called the target of that but
the sailors domain and range
are there any questions
No you're all being shot okay here is
how you learn stuff don't be shy if you
have a question ask a question I will
consider this talk successful if I get
some questions during the talk so I hope
you'll help me make this a successful
talk are there any questions yes
it's like does this imply a does it have
to be a homomorphism so there different
ways you can interpret objects and
arrows you can just set down the rules
and you can say every object is a set
every arrow is a function from the range
set to the domain set or you can select
down a different set of rules and you
can say every object is in algebra and
every arrow stands for a homomorphism
between the algebra so you just picked
your rules and one way picking the rules
which is common is to have algebra and
homomorphisms does that answer your
question okay
good question thank you
earlier yes
Oh can a B and C be anything generally
again you just set the rules and you say
this is my collection of objects I would
said set of objects that maybe my
objects are sets and then you need
something different for a set of sets
it's a bathmat metamathematics i won't
get into because infinity can be hard
but we don't need that so you just say
these are the things that may be objects
and a typical thing to say is it could
be any set whatsoever and then there
will only be certain functions available
between these things
right so the one constraint is that this
must be an F that's compatible with a
and B right so that is a very important
trait that's actually a whole type
system so we're already away from any
dynamically typed language right the
category theory has the types built in
and the one way to think of a and B is
as types and then F is a function that
takes something of this type and return
something of that time also a good
question
it's like let's move on I don't want to
take ages over this
okay you now know enough category theory
actually I don't Fisher you one more
thing you already have there enough
structure to do one of the most
important things which is I can say I
should have drawn a picture of this
sorry but you say you've got a and B and
let's say we've got F is an arrow from A
to B and G is an arrow from be back to a
but to hear beans Jesus draw an arrow
from be deceived but let's say G goes
from B back to a and let's say they say
and the composition of these two things
either way gives you the identity so s
followed by G is the identity on a G
followed by s or G followed by F would
be the identity on B
so you can already describe that in our
structure how many people know what that
thing is called you've got such an F
energy ooh very few of you great okay I
get to tell the rest of you what's
called it's called big name and
isomorphism so that's great you now know
one big word isomorphism but it just
means oh I've got a pair of functions
going back and forth that composed by
the identity in other words this thing
and this thing are in one-to-one
correspondence
how many people have heard of one-to-one
correspondence back in high school and
you had functions
at least half you're willing to admit to
it the other half have you heard about
it but are shy about raising your hands
so just the notion of things being in
one-to-one correspondence that you can
map back and forth either way and if you
go around trick you end up where you
started with that just two things in
very close correspondence and that's
called an isomorphism it will make use
of that in what follows
so already even though we have a very
tiny amount of structure here right just
function composition and identity and
that's it that's already enough to do
quite a lot so let me show you all the
things you can do in particular we can
build up the three things we want
products sums and Exponential's just
from this amount of structure
you want to see that it's cool okay so
we'll start with the product
so here's a little diagram
so I've got some objects a B and C and
I've got another object whose name is a
times B the product of a and B and the
product has to satisfy some properties
factor testifies what's called a
universal property and all that means is
that we're just saying for any object C
let's say that from see I've got an
arrow from C to a pull it out and say
I've got an arrow from C to B call it G
now also the product comes equipped with
arrows so from a time from a times B
there's an arrow called first going to a
and an arrow called second going to be
so I should start with that the product
objects a and B a new object a times B
with arrows first going from 800 a and
second going from a times B to B and a
universal property which tells us for
any object C this is specific a and B
that give us a times B and then for any
C whatsoever given an F going from C to
a and a G going from C to B there exists
a unique arrow called open angle F comma
closed angle sorry open angle FG f comma
G close angle here it is that goes from
C to a times B
and it's not just for any
sorry and then with the property of this
FG is not just a goes to a times B but
that this diagram commutes so you can
see there are two ways to get from C to
a I can go directly via F or I can go
via this FG thingy to a times B and then
via first peg right like an go this way
or I can go that way that's called a
commuting diagram not because it gets
you stuck in traffic in the morning but
because no matter which way you go
around it you get the same thing so this
is telling us that F is equal to FG
followed by first and similarly that G
is equal to FG followed by second and
right if there's those two equations FG
followed by first is that FG followed by
second after you followed by second is G
any questions about that
yes is the angle brackets the same as
oh it's you're a computer scientist you
understand this we use different symbols
for different functions so traditionally
this is just written as angle brackets
indeed there they must match the same
way parentheses match and it's just a
way of saying okay I'm taking I'm just
combining F and G to form a product
later we'll see something with different
shape brackets it's just a way of saying
which function this is so the thing
inside angle brackets is just the thingy
that goes from C to a times B it's the
thing that creates a product for it B
morphism into the product
the uniquely exist morphism into the
product that you know exists uniquely
whenever you have an F and a G
there's another question yes yes speak
up
oh that's fine okay so the question was
you're given K and B and a times B in
first and second so that's what it needs
to provide a product and then provide
and then there's one more so the recipe
serves as well
are there any products around here let
me see so the product of a and B will be
this thing called a times B it must have
an arrow first going into a and there a
second going into B all that's just for
a given a and B and then we say for any
C whatsoever for any F from C to a for
any G from C to B there must exist a
unique F G going from C to a times B
such that this diagram commute so FG
followed by first must be f FG followed
by second must be G and then your
question was what if there is no such C
that's fine we said for all city this
must commute for all C for all F for all
G this must commute what if there is no
C ephra G fine it's immediately a
product
so then you say oh right so that must
mean in the discrete category when with
no arrows whatsoever everything is a
product but not quite because they have
the product we need to have an arrow
first and we need to have an arrow
second so in a discrete category these
wouldn't exist right so there will
always be at least one choice for C
right because we should always be able
to choose C to be a times B and we could
choose F to be first and we could choose
G to be second
and then first angle bracket second must
be the identity because it's a unique
thing doctor I'll show you the slide in
a minute so there's always at least one
yes
what we're told not only that this
exists but it's unique
what does unique mean that's a very good
question
here's what unique needs let's say we've
got some other H and that H also
satisfies that H followed by first is F
and H followed by second is G and the H
goes from C to a times B so here we've
got that then what do we know since it's
unique at H Falls satisfies the same
properties as F G H and F G must be the
same thing so the answer is H and F G
must be equal
now if you were Bill Clinton you would
say but what does equals mean but we
won't get into that
does that answer your question okay
good excellent questions anybody want to
ask a question that will take me to my
next slide now have you worked out yet
what the product is in terms of stuff
that you know does how many people
understand what the product is probably
mysterious Oh most of you have worked it
out that's cool
okay so what the product is in set
theory this is what's called the
Cartesian product in computing this is
called a record with two fields called
first and second so at first the arrow
here just extracts the value of the
first component of the pair this is the
pair type that's another way of saying
it so and what do we do well see if
applying F takes a C to an a find G
takes a C to a B the way we get an a/b
pair is we apply F and that's the first
component of the pair and we apply G and
that's the second component of the pair
so it's just this FG is just a pair
builder that's one level up right it's
at the function level it says we're
given C apply F to get an A and apply G
to get a B that's a pair of things so FG
returns that pair of things is that
clear enough
I'll show to you in Java and in Haskell
in a minute
but nukes sprites I'm asking about
uniqueness can we do anything there yes
we can we can prove things like the
following so we already have enough to
prove some stuff
you can prove
love them love them all so remember this
works for any F and G I can pick F and G
to be whatever I want let's say I've got
an arrow H going from C to a times B any
H going from C to a times B then I can
form H followed by first and I can form
H followed by second and then H
satisfies the following properties
trivially right you go this way or you
go this way you get the same thing
because they were defined to be the same
thing if you go this way or you go this
way you get the same thing if they were
defined to be the same thing so right we
know H first followed by H second exists
we know H exists we know they both
satisfy the same properties so because
it's unique they must be equal
Wow wait what's that telling us neh
going from C to a product can be
re-written as H first followed by H
second
oh let's see what that's telling me is
if I do H and extract the first
component and use ask the first
component of the pair and I do H and
extract the second component and you
sense the second component of the pair
oh that's just the same as doing it
right so it says doing H deconstructing
it into two components putting those
back into the pair is just the same as
doing age right and then one thing you
could do is take H to be the identity
and this tells you that taking a pair
extracting a second component putting
them back together to build a pair is
just identity leave the pair unchanged
it's everybody follow about
and then here's an exercise for those
among you who are really key what you
can do is right this is the definition
of product and this is anything that
works this way is a product note that
there will be at least one other thing
that works this way which is B times a
and instead of first here we use second
and stef second we use first that's
another thing that makes the diagram
commute there may be more than one
definition of product there might be an
infinite number even of definitions of
product depending on what you're doing
that's okay you can use what I've shown
you so far to prove that any two
products are isomorphic right a times B
is not the same as B times a but there's
an isomorphism which is just flipping
the elements back and forth you can
convert one to the other and back easily
and all of these structures will have
the property that they are unique up to
isomorphism and this is one of the
lessons of category theory is that you
don't care too much about particular
structures but you do care up to
isomorphism so any two things that are
easy to map back and forth you can
consider in some sense as being the same
right and this is true right if somebody
said you know oh I've got a product here
it's got a first field in a second field
and somebody else says oh I've got a
different product over here mine is much
better it starts with the second field
and then has the first feel
you go no no no no no I don't think
that's much better I think that's
equivalent and now you can use a big
word right if one of your colleagues
comes in said oh I think we should just
flip these things around and then it'll
be much better you can say oh it's just
isomorphic
Hey right and why do we call it the
product well let's say that our object a
actually has three values in it let's
call them a B and C and let's say that
our object B has two things in it let's
call them zero and one how many things
are there in the product well it's all
possible pairs
that's a paired with zero and be paired
with zero and C paired with zero and a
paired with one and be paired with one
go away and C paired with one
so there's total of six things right and
in general if you have some number in
the first set a and some number in your
second set B and you take their product
it will indi have the product of those
two numbers of things in the final set
but that's why it's called the product
any questions about that
Oh questions required to doubt okay
think of good questions I'm sure you'll
have some so oh and we'll need this
construct later there's another
construct s times G and that goes from a
product to a product we say let F be an
arrow from A to C and G be an arrow from
B to D then s times G is an arrow from a
times B to C times D we can build that
up using the structure we've got in fact
its first on this followed by F right so
first gives us an A and then F gives us
you see and similarly second gives us B
and then we do G and that gives us D so
first F followed by second G using the
angle bracket construction that just
basically says given a pair apply F to
the first component and G did the second
component to get a new pair and that's
just saying this diagram commutes
so we've already got enough structure to
apply functions separately to each of
the two components of a pair
not if you're going guests on board
that's easy not if you're going oh I can
just barely follow that nobody thought
it
not if you're thinking oh that's kind of
cool go back and look at that later I
bet it'll make sense later but right now
I'm panicking I don't follow it
I expect their people in all three
classes that the pointed yes question
oh very good question why are some of
the arrows dotted so a dotted arrow in
category theory is just a convention
that means this thing exists and is
unique all the other structure here is
enough to apply that this structure
exists and is unique
you
right so the question was so does this
mean that we source assume the dot the
solid arrows all exist and then from the
solid arrows existing we can deduce that
the dotted arrow exists and that's
exactly right
good question
and you might think like that this
dotted thing is an absolute solid
convention and that it always has to
precise meaning but no you actually sort
of have to write the precise meaning out
later
sometimes the dots can be a little bit
ambiguous
but I hope that when I add some words to
explain it that stops being ambiguous
there was another question yes
you
all right so the question is this is
called a product this is called a
product is this called a product - yes
yeah everything's just overloaded
yes
okay so a dotted arrow we say this means
it exists it is unique what about the
solid arrows what does that mean no
they're not necessarily unique they're
right if we go back
but there are lots of different apps
that you might use here and lots of
different sees so they're not
necessarily unique and they don't even
necessarily exist right as we said this
is for all seed may be there no seed at
satisfy this property that would be okay
so dotted arrows exist in our unique
solid arrows
if you happen to have one then you can
use it
good question thank you
no no it's good question so the question
is is the bottom line if it exists then
it is unique
no the bottom line is it does exist and
it is unique so it's quite powerful that
this thing exists we are creating new
stuff out of nothingness it's like being
God
yeah
effigy may not be unique we're just
saying give me an F give me a G that
satisfy this property
sorry can list an example of when it's
not unique yeah let's try something so
let's take C to be the type bool
and let's take a to be the type bool and
let's take B to be the type bool okay
can you name me an F that goes from C to
egg
the identity and we can take G to be the
identity and then we thought this will
give us the pair of that boat so this
takes a single bull into that bull copy
twice okay so if it takes true into the
pair true true and false into the pair
of false false so that's a choice of F
and G can you pick a different app
negation so that will take true to false
and false to true
let's pick G to also be negation and so
now the product would be the thing that
takes true to false false and false to
true true and you can also pick one of
these to be the identity and one to be
vina gation
okay that's four different possibilities
right there now if you want to pick this
to be the set of natural numbers and the
set of natural numbers and the set of
natural numbers I bet you can think of
lots of s and lots of G's that you could
use okay good question
I'm not gonna ask John cuz he already
knows the answer yes
oh very good question are there things
that are almost products but not quite
and the answer is yes
for instance paring in something like
standard ml is not quite a product
because it doesn't work right with non
terminating programs if either bit
doesn't terminate the whole thing
doesn't terminate so in the case the H
was in um sorry let's say F is something
to term up let's go back for example
right so we mentioned two possible
arrows going from C to a the identity
and negation in a programming language
you'd have another possible arrow the
program that never terminates okay so
now we've got the let's this be the
identity and let this be the program
that never terminates now have we got
this right so then when we build up a
pair what do we get oh it doesn't
terminate because this one doesn't
terminate so we don't have the property
that H followed by first is the identity
in that case because it doesn't
terminate so it's almost a product
except for things that don't terminate
and the fancy word for that in category
theory is shit I bet there is one but I
don't know the names of all so you've
already pushed me to my limits because I
can't remember the name for that concept
if there is what John you get to ask
your question after all
yeah
but to just pointing out that I've done
a crap job here I've done the same crap
drop that all category bears do which is
when you look at this first and second
look the same as F and G but that's not
quite true
right as I tried to make clear with
words but is not made clear in the
diagram first and second and a and a x
and b and a times B are all fixed for a
given a and B whereas C invariant you
can have any C you like
thank you John good caller
yes
does this mean 1st and 2nd are unique Oh
No
as long as you have a first and a second
that work that's allowed and then can
you prove that first and second are
unique I think you can
good point given two different first and
seconds that work can you then prove
that there are the same and I think the
answer is you can but I can't do that
off the top of my head so I will leave
that as an exercise for you but I
believe you can prove that first and
second must be unique if you've got
another first it satisfies the same
properties it must be the same as the
first first
good question absolutely yeah
this one right so you're pointing out
this is called first and this is called
first but they're different arrows so
we've overloaded the name first first is
the name for the thing that projects out
the first component of the product
and here for instance again the names of
thing that projects out the first
component of the problem but strictly
speaking this should be written first
sub a B and this should be written first
sub C D so we're using a bit of
overloading most people who use
computers are familiar with overloading
so I've just simplified the notation in
that way but you're absolutely right to
be technically correct this should be
first sub a B and this should be first
sub C D that was a very good question
last question then we'll move on to some
yes
can you have a thing that combines only
some stuff yes but it's not a product
how is it cold well it depends on what
you're doing I would call it Fred I I
think you have a specific thing in mind
but I don't know which thing you have in
mind
you don't have a product
okay so let's implement this in Java
right so we'll have a class product a B
it has an a field called
sorry a field of type a called first and
feel the type B called second and we'll
make them private and then the product
constructor just initialized as opposed
to those and then we have two operations
following Java conventions called get
first and get second that retrieve those
fields so the things that correspond to
the first and second arrows here are the
functions get first and get second
so this is clearly a right this is
already for me harder than the category
three keys not have to understand
classes and generic types in Java and so
on but for those of you they understand
such things
are you happy fast a definition of a
product then we could use a product
right we could make the product of the
types integer and string so we could
make a new product with the integer one
and the string quote too and then we
could extract things right get first
gets out one and get second takes out
trick
okay
and the way you do it in Haskell is we'd
say we form the product of a and B and
I'll use the record notation for Haskell
so we've got a pair whose first
compounded to say whose second component
is B and that's
that's equivalent to just saying I built
a pair of an A and a B and then first
extracts the first component of the pair
and second drop the second component of
the pair and I could build a pair by
saying pair of one and two and I could
extract the first content by saying
first a pair and the other one by saying
second affair
okay
some we are now ready for second a
destruction the some so here's a diagram
and again following John's convention
these bits are work for given a and B
and then this is for any C so given the
n a and a B I say there exists an object
a plus B there exists an arrow left
going from a into a plus B and then
arrow right going from B into a plus B
so left is the arrow on the Left which
points to the right and right is the
arrow on the right which points to the
left and then we're saying okay given
any arrow F from A to C and any arrow G
from B to C there's an arrow now we use
square rather than angle brackets square
F comma G close square that exists and
is unique
and again that means that these
equations are followed and again that
means that what does it mean to be
unique what means that if left followed
by H is the same as F and right followed
by H is the same as G then H and F G
satisfy exactly the same properties and
they must be identical so we're given
after you exist and for any H that makes
this thing commute we know H must be the
same as f3
and similarly we can then do a proof
showing that H is the same as left
followed by H combined with right
followed by H
this is the same proof we did before and
why is it called the sub well let's
write what is the how many people
understand what the intuitive
interpretation of this is
okay quite a few of you a bit fewer it's
a little bit harder so this is what we
sometimes call the disjoint union or
some is another name for it and it just
says what is a value of this type well
it either says I'm a lefty
and then it consists of an A or it says
I'm a right thingy
and it consists of a B let's do an
example
so here what's the sum of three and two
well three remember contained a B or C
so the values of this type are either
I'm a left thingy followed by a B or C
or I'm a right thingy followed by zero
or one
let's hold this sum or disjoint Union
does anybody else have a favorite name
for this I think there's several
different names for this yep
discriminated union yeah
either is what Paulding haskell indeed
in Pascal I think it's called a record
variant that's another name for it
what's it called in C I can't remember
Union and in C it's called Union so
everybody else is discriminating and C
is not
and oh I was missing an equation on
oh yeah I skipped over something right
there's one other thing that's very
important I should tell you about
products which is what is the product
telling us well it says that the arrows
from C into a times B right the only way
to build such an arrow right is the only
arrows that exists are those arrows that
you can build by taking an F F of G wait
how do I know that how do I know that
any possible arrow is one of these well
remember we prove that
but here's neh going from C to a times B
that H must make this commute must make
this commute
therefore this H must be equal to H
first followed by 8 second so any
possible arrow going from C to a times B
must be expressible as a pair
this proves that right you get a lot
from very little structure so in
particular what does that tell us it
says what is the set of arrows going
from C to a times B well it's in
one-to-one correspondence right because
you can build an F G if the arrows from
C to a and the arrows from C to B so
different way of thinking of all this at
a higher level is look so curly C
they're in black just dance
curly C's the name of our category this
stands for the set of all arrows from C
to a times B and says that set of arrows
is in one-to-one correspondence in
isomorphism with the set of arrows from
C to a and from C to B so it says if you
want to know about narrow from C to a
times B you can break that up into
saying I've got an arrow from C to a
that gives me the first component and an
arrow from C to B that gives me the
second component or it says given these
two things I can build such an arrow
this is a very compact way of describing
products it says the arrows from C to a
times B are in one-to-one correspondence
with or an isomorphism with pick a pair
of arrows one from C to a and one from C
to B
and when you learn more category theory
you learned that this thing here is also
a product in the category of categories
we won't worry about that but it's true
okay so and then similarly right what we
learned for some is just the same thing
it says an arrow from a plus B into C is
the same as having an arrow from A to C
and an arrow from B to C alright and
what is this arrow right this is like a
case expression right it says look at
this thing if it's a left thing apply F
to it if it's a right thing apply G to
it that's just the case expression but
again it says the Earth's from a plus B
to C consists of a pair of arrows one
from A to C and one from B to C
yeah it's a very good question exactly
what I was going to point out right
people look at this and go wait time is
know shouldn't it be Plus this time
no it's still times but cuz we've got
pair of thing it's not a choice it's not
the errors from a plus B to C are given
by having either an arrow from A or an
arrow from being no you need both one
for each case so it's time to stop +
very good question
yeah
yep
right so in algebra this is called the
sum of two algebra this is a concept
that already existed in algebra before
category theory came along and then
category theory captured that in a very
nice way
sorry what you're asking what the
operators of the algebra are
what
so algebra smae have any number of
operators they might have one operator
or two or three and they might so you
don't always have plus or times you can
have any lots of different things in
your algebra but if you had plus and
times what this will be saying is that
less preserves those and FG preserves
those and F preserves those so that's
giving you very strong properties about
the sum of two algebra
okay and then we can implement sums in
Java all we need to do is use a smaller
font right because something Java are
significantly more complicated than
products so we need to define an
interface sum and that's going to have a
case expression which says well give me
a function f from A to C and a function
G from B to C and I'll return and given
a sum of a and B I'll return a seat
and then we define two instances of that
interface the left instance and the
right instance and the left instance has
a private field of type a containing an
X and the right field has a private
field of type B containing a Y and left
and right are the two constructors for
this type right prepares we just had one
constructor for sums we have two
constructors either it's an A on the
left for it to be on the right and then
the case expression for something on the
left this picks out the ass it applies
it to X but the case expressions with
something on the right takes out the G
and applies it to Y and you need to
provide both a pair of things F and G so
that you can do something whether you're
giving something on the left or you're
giving something on the right
there any questions about that any
criticisms of my java programming style
okay and then we can use that again we
need a smaller font so we'll define
arrant as a sum of a string and an
integer so that is this is either an
integer or an error message and so we
could find error as less of error
something went wrong well one is right
of one and then we can define a function
add that takes an arrant called this and
then other errands call that and adds
them together and what will we do well
we have a choice we have to look either
at the first argument or the second
argument let's look at the first
argument either it's an error and if it
is we'll just return that error or to
number em and then and in that case
let's look at that and either it will be
an error and then we just between the
error or it will be a number and then we
add the two numbers together and return
that so this just takes two things are
either errors or numbers if they're
numbers it adds them together and gives
you a number if one of them is an error
it will give you an error
Zach yeah
sorry interfaces and polymorphism are
speak up
if your faces and polymorphism are sums
in category theory no polymorphism you
would actually model using a generalized
product polymorphism says you get one of
these for any possible type
we can deal with that one offline if you
want
and interfaces are uh what is the nice
categorical interpretation of
object-oriented programming
no one knows maybe there isn't one what
is the lesson I derive from this
object-oriented programming is very well
made when somebody tells you they want
to use object-oriented programming
they're telling you what you should do
object
we've got very little time left so let
me rush on subs in Haskell are very easy
it's the type of I've wrote some here if
it's actually called either in Haskell I
think as a constructor is called left
and right or they called inulin dinner I
can't remember sorry
they are called left and right I should
have written that as either
and then we can do the errands program
the same way except now we can write it
in a big font
I'll put all this up on my website if
you want to look at the slides in more
detail exponentials the third important
data structure
so now we're building on top of products
which you've already done so I'm saying
given a narrow F going from C time oh
this one's hard by the way this one made
my head hurt really a lot the first time
I learned it it's like yet you're just
defining functions and you need products
and it's about currying and and boy
category theory is just about taking
something simple making it difficult
isn't it but this is the easiest way of
doing it justice constructors we've got
so this is what we'll do so it says
given an arrow F from C times A to B
there exists a unique so this should be
a dotted line except the ID isn't a
dotted line so I drew it solid but maybe
I should have drawn it dotted
see I told you it was hard and what are
we saying there exists a sorry so we say
this is like first and second so for any
a and B they're just a prop exponential
from A to B if you take the product of
that with a there's an arrow app that
goes to B
and then we're saying there exists a
unique curry of f so it's the Korea
that's cross ID so curry of F takes you
C to an A to B ID takes your a to the
same a and then we're saying this is the
same as this move
what's going on there okay this is a
function space it's right arrows go
between objects this is an object that
represents the arrows between a and B so
we've turned arrows into objects
ooh it's it's almost like turning code
into data ah okay we can live with that
we're computer scientists we know how to
do that so this is the set of all
functions from A to B in a sense it's
the object that represents all the
possible arrows between a and B and then
given one of these and given an A what
can we do oh you apply the function to
the a and that gives you a B so that's
what app is it's just applying a
function to an argument and then why
does this diagram commute well saying
okay I thought f that takes two things a
C and an A I'm turning it that C into a
function from A to B so that's the thing
that takes an A and I give it an A I get
back a B so it says okay instead of
taking representing something from a
pair to this will we represent it as
something to act on the first component
of the pair gives you the second
function from the second component of
the pair and then we can apply that so
this is a trick for representing
functions of two arguments in terms of a
function of one argument curry F that
gives you a to be a function on the
second argument so this idea goes back
to Pascal curry which was why it's
called curry actually goes back a bit
earlier than him to Moses sure and
finkle so it should be called for sure
and inkling but that's less tasty but
actually so that's the joke I was told
when I was a student much later I
learned actually goes back to Gottlob
Frege a noted inventor of logic and
anti-semite sadly it turns out basically
that lots of the people are really good
at logic are anti-semites or Nazis
you
that's not a recommendation in favor of
anti-semites or Nazis
but anyhow so this idea of currying goes
back to fray guys so we should call it
friggin
so that's an exponential and this is the
equation that we get it's a little bit
hard why are they called Exponential's
oh well and I've got a function from it
says two objects to three objects how
many are there
well zero kidnapped 2a and one can map
to a or zero kidnap to a or one map to B
or zero could map to a and one could map
to C and so on and you can see that
there are 3 squared 9 different possible
such functions so the number of such
function is just given by raising the
range type the number of elements in the
range to the power of the number of
elements in the domain
so we flipped things about and take the
exponential that's why it's called an
exponential okay now we know our three
basic functions right we've got oh and
we can do all this oh right and then
what's that telling us it says well the
functions from C into a arrow B are in
one-to-one correspondence with the
functions from C times a into B that's
the important isomorphism that this is
captured
and then Java now contains that
financial so we can go back to using a
large font right because the function
type is built into Java now
and it's of course built into haskell as
well it's all very straightforward so
here's an example of currying right ad
takes an integer and returns a function
from integers to integers so it takes
the function the given X adds and add
acts and so add one is the increment
function of type int to int and then
increment applied to two gives us three
No
I mentioned at the beginning simplicity
in Mickelson I'm running out of time but
here's the complete type system of
Mickelson and this line and this line
and this line are giving you the
definitions of some right this is left
this is right and this is your case and
that's the complete type system of
simplicity really is very simple that's
the complete semantics with these four
lines here just saying inject left is
that's their way of writing left inject
right that's their way of right and case
is it does a case branch right so if
it's the left of a you apply to a you
apply s a and see if it's a right of B
then you pick out T and apply that to
the B and the C
and Mickelson also has some built into
it so here's a little bit of the
Mickelson documentation which is about
20 pages it's much less simple than
simplicity but again they have sums
built right into it called whore
and Plutus let me mention about Plutus
so I mentioned I'm a consultant for IO
HK we're designing our own smart
contract language called Plutus Mei
anybody who's looked at cryptocurrency
will know of exploits like the Dow
re-entrance e exploit which let somebody
steal 30 million dollars u.s. from
investors and that sounds pretty bad if
you can have an error in your code that
lets people steal millions of dollars
worth of stuff but
that's not the real story the real story
is there have been similar exploits
about once every six months
and one of the things that IOH Kade that
they're attentive doing is providing a
drop in copy of Assyrian so I keep
reminding the CEO Charles Hoskinson
who's a an amazing fellow I keep saying
okay so what you're saying is you want
to maintain the ability to have an
exploit every six months so that's the
bit that's duplicating aetherium but
we're not just going to duplicate
aetherium we're going to have our own
smart contract language hope ludus and
the hard part here is how do you design
it so that these very clever errors so
some of the errors that have led tens of
billions of dollars but so are really
stupid you just look at that you go oh
the problem is they were using
object-oriented programming with
delegation don't do that that's easy to
avoid and that one cost another 30
million but the dowry entrance fee bug
is really very fiendish so how do we
avoid these fiendish bugs
let's apply category three
how do we do that that's an open
question do you want to help us do that
we are hiring
so we're hiring six programming language
engineers for the Plutus team there's a
long URL here at the bottom as I said
I'll post this on my website too you can
find it there but the easy thing is to
enter your favorite search engine type
io HK is hiring six programming language
engineers and you will find it so please
applaud if you're good
please apply if you think you're not
good and please apply anyway but you're
probably good right if you think if you
think you're not good you're probably
not male and we want you to apply
conclusions to cool things I want to
show you the first is right when you
look at the Sun diagram it probably
looked a lot like the funk the product
diagram right you're going oh there's
something similar there I wonder what it
is
and what it is is if you look at it
right the diagrams are exactly the same
except in seven arrow out from a times B
to a we have an arrow in and seven arrow
out from a times B to B hold second we
have an arrow in
and it's seven arrow out from C to a and
then out from C to B we have arrows from
a and B into C and then it's have an
arrow from C to a times B we get now
from a plus B to C so you just turn
around all the arrows
so there's a very close relationship
between these two things and I never
would have seen that without category
theory
like this is the real advantage of
category there right we've already seen
a benefit from that right the second set
of proof for sums I went over very
quickly
that's because since all the others are
just turned around it follows
automatically from things being proved
for products so every theorem about
products turns into by just turning the
arrows around into a theorem of out
songs
so this is very cool
and what does this mean right I'm
waiting for something to exploit this it
should mean that you have a compiler for
a language that just have products and
from it you can automatically derive by
just flipping all the arrows a compiler
for a language with sums
there's actually been a little bit of
work along those lines but someday
somebody will reduce this set the size
of their compiler by a factor of two by
using this trick
if here's the other cool thing you
haven't learned anything new today at
all
you knew all of this back in high school
let me prove it to you
right what were the three things that
summarized all this it said that the set
of arrows from C to a times B is in
one-to-one correspondence with arrows
from C to a and C to B arrows through a
plus B to C aren't one-to-one
correspondence arrows from A to C and B
to C and arrows from C into the
exponential of a and B are in one-to-one
correspondence with the arrows from C
times a into B notice that these
themselves stand for sets of possible
arrows so these are essentially like
Exponential's
let's just write them as Exponential's
and then that tells us a plus B did the
C is the same
that's right the sev all arrows from C
into a times B sorry a times B it's the
same as the C to a times C to B
in other words a times B raised to the C
is the same as a to the C times B to the
C you've learned back in high school
C to the a plus B all the arrows from a
plus B into C is in one-to-one
corresponds with arrows from A to C and
B to C in other words C to the a plus B
is C to the a times C to the B
and be raised to the a and that itself
raised to the C so here we've got the
exponential of A to B and here we have
all the arrows from C into that
so we've squished two different kinds of
Exponential's writing them the same way
our one-to-one correspondence with the
arrows from C times a to d
silent all perfect I will put this on my
website there's some further reading for
you I'm sorry that phone over time so I
will finish now but I will leave you
with just one idea which is you should
think that when you have a tough job to
do this is a job for mathematics this is
a job for lambda calculus
they do something non-pc
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>