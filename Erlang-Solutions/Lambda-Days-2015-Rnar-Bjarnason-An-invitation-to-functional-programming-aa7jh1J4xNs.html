<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2015 - Rúnar Bjarnason - An invitation to functional programming | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2015 - Rúnar Bjarnason - An invitation to functional programming - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2015 - Rúnar Bjarnason - An invitation to functional programming</b></h2><h5 class="post__date">2015-04-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/aa7jh1J4xNs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right yeah some so my name is Minar
and so this talk was originally going to
be about primo nuts
but I talked about three minutes a lot
so this being you know lines of days
here I'm gonna sort of take you to
church about functional programming
alright so what I want to concentrate on
is sort of why we're all here
so why we're all here it's a lambda a
functional programming conference what
is it about functional programming that
excites us and then how do we
communicate this effectively to other
people like why does this matter
so first let's get a working definition
of what functional programming means so
some people will say oh there's no
function burqa means whatever you want
but that's not really very useful so I
want somewhat precise actually means so
in the simplest possible terms
functional programming is just
programming with punches so its assassin
but but then the question arises what is
a function so a function don't let's go
to a pure function so it has a type it
takes values in type a as arguments and
it produces values of type B as a result
and for every value that you give it it
will give you an answer and it will do
nothing else it will only compute the
answer given the arguments this means
that a function will always give you the
same value given the same argument and
as a corollary of that it doesn't have
any dependencies on the overall program
state which means that it can't sort of
know what else is going on so in other
places to your program the only thing
that it knows is its own implementation
and the arguments that you gave and this
also means that when you look at what
appear a function gave you as a result
you are looking at everything that that
function did with your input so the
result that you get is a function of the
arguments
so a pure function that doesn't use any
side effects if we want to be purely
functional then we can't you can't you
set up this so for example we don't use
IO directly in the implementation of
your function so if we want to do I or
we have to we have to put that in the
value that return somehow so we return
to the caller a value that says hey you
know here's some IO that needs to happen
and then it's up to the caller to then
pass that to some IO subsystem or
something to actually make the IO take
place at some convenient time but
importantly the IO isn't in our program
so we are not however used allowed to
use local effects which means that it's
not considered you know a side effect if
we allocate an array proceed to mutate
it and then throw the right that that so
the mutation doesn't escape our function
and so it's not considered a side-effect
so we're absolutely allowed to do
mutable memory in pure function and we
are allowed to return of X and if we
can't have side effects that is for
example a function can't they play music
through your speakers on your computer
so it could take for is that for example
a piano roll and turn that into a
waveform then then you could take the
waveform and play it on your sound
hardware or you know you could have a
further gear function that turns a
waveform into instructions for your
sound parlor so the importance property
and pure function is referential
transparency so the definition of
referential transparency that I'd like
to use is as false an expression E is
represented transparent if for every
program that contains that expression
you can replace the expression with its
evaluated result and that will not
change the meaning of the program
okay and so a program then will consist
of some sub expressions and then we can
take any expression and we can evaluate
it and replace the expression with that
value and we have wind up with the same
program that we started with so that
gives us the substitution model of
computation and so a pure function then
is simply one that is always
referentially transparents when we call
it that it's if we call it we've got
really transparent arguments the
function call itself is also referenced
and transparent so the in functional
programming is just programming with
with your questions without signs but so
why why would we do that why would we do
that to ourselves like why would we
reduce the set of things that we are
allowed to do right it's like you know
we're we're sort of losing something
right we're losing some power but no
actually gaining a tremendous amount of
power we gain you know but by throwing
away something we gain an ability at a
sort of a higher level of being able to
reason about what we're doing so the the
first benefit of a functional
programming that I want to talk about is
modular so modularity is the property
that you're taught for it can be
separated into parts and those parts can
be recombined in ways that you didn't
necessarily anticipate when you've
designed those parts and in practice
that buys you reusability so functional
programs are naturally reusable because
you know a pure function isn't really it
sort of stuck to any other things like
you can always take a pure function
that's somewhere in your program you can
just pull it out and then use it
wherever else you want because it
doesn't have any dependency on the sort
of overall program state functions are
testable because you know you can always
take a pure function and just give it
some arguments and then look at the
result and see that it matches
you expected so it's always possible and
safe to test a pure function
they're also parallelizable because you
know referentially transparent
expressions can be separated out and run
in parallel they can't have any kind of
sort of effects on the on the overall
state of the of the machine there are no
race conditions or walks and and the
last point here importantly pure
functions can be understood in isolation
so that gives you a sort of a
comprehensibility so you separate your
software into individually
understandable components in my language
icelandic to understand something we say
skinnier and skinnier literally means to
separate so in order to in order to
understand something you've separated
from its environment and look at it in
relation to other things but you look at
it in isolation and that's what
modularity
so yeah you might say well I'm already
doing separation concerns and you know I
don't do functional programming but
that's great and if you do that
consistently I think you will invent
bunch Alberto so yeah let me try to
demonstrate this plan with testability
so if we have a method like this this is
a Scala code and this is not a pure
function this is just a method a caffè
class called cafe and it has a single
method it allows to buy a cup of coffee
given credit and so it returns a coffee
but it also has a side of it and that it
will actually go and charge our card for
the price of a cup of coffee so this is
this is not very well testable because
you know if you give it it's a credit
card it will actually go and charge that
car so it's not really safe to use
anywhere except you know
where you actually want the effect so a
partial solution to this is to to pass
in payment system so you could pass in
like a mock payment system or you can
pass in you know a production payment
system and then you know instead of
calling sort of like a global charge
method that charges your credit card you
call the charge method on this P object
which is your payment system and so if
you're in production it actually goes in
charge of your card if you're not then
it might go and just make a record of
the fact that there was a charge
somewhere and then you can go and
inspect the record and make sure that
that our record was created somehow but
this this solution is not really sort of
reusable and it is all very sort of
sight effective and terrible
so the purely functional solution is to
produce a charge so we so they literally
make a record of the chart and we return
that record to the caller instead of
sort of having a side effect of making
that record somewhere else so now this
is a pure function it takes a credit
card it returns a cup of coffee and it
will also return it charge to that
credit card and then the caller can take
that charge and then pass it to like a
payment subsystem or something at a
convenient time but importantly this is
now testable so we can write a test like
this where you know and that test is now
just pure function it takes a credit
card it will call buy coffee get a
coffee in the charge and then it will
just assert that the charge amount is
equal to the price of a cup of coffee
and the cards was actually charged is
the credit card that we gave so this is
really you know simple but but it works
you know the same way for for very large
programs I mean the same principle holds
and and this is also reusable the the
cafe is now reusable if we want to buy
cups of coffee we can we can do that so
we could just call this method you know
end times or a hundred times or
something and it will give us a hundred
cups of coffee and a hundred charges and
then we can sort of coalesce them we
could log them somewhere we can we can
do open to things with charges as
first-class objects that we weren't able
to do but we were just calling them I
mean we're just charging the credit card
directly as a side effect all right so
yeah that gets us to reusability so pure
functions are are reusable and they're
really reasonable because you know they
don't they don't have any hidden
dependencies there is no initialization
step that needs to happen like before
you call up your function it's always
like safe to call a function and a
function no matter where it is isn't
doesn't have any sort of unwanted
side-effects there there are no there
ever going to be any sort of wires
hanging off of it when you we pulled it
out of your program right so it's very
sort of friction free you can you can
take a function out of your program and
put it wherever else you want it's
always it's always going to work and
it's always going to be safe and and
what's more referentially transparent
code is reusable because whenever we see
duplication we can always extract that
duplication tax we can abstract over the
differences so for example here are two
definitions that are that are very
similar one of them sums a list and the
other one takes the product of a list of
integers so they both process a list of
integers and very much the same way the
only difference is that one of them sums
and the other one takes the product and
I've highlighted the differences here in
red
so what we can do is actually just punch
a hole in one of these things and take
those red things as arguments to a pure
function and abstract that out and now
we captured that inner function and that
function is originally called fold right
so here now we take a list and
Fulbright's
will you know walk over that list and
combine the
of the list using some function that we
gave it could be plus there could be
multiplication and then you know there's
gonna be something identity element for
that which is it represents what to do
in the empty list case so we can write
something products using bolt rights and
so fold right is now highly reusable
function so we can do this wherever
wherever receive duplication now I'll
take I'll take questions someone
collects a bit possible right in here so
yeah anyways so wherever we see
duplication like this we can always
abstract it out is that better here I
think this is the it's just washed out
okay good enough so so yeah so in fact
with with fulbright we we didn't
actually care that we're working with
lists of integers so you know now that
we've taken take taken like sum and
product and abstracted into a new
function we we can see better now that
we don't actually care that we have
integers whereas with us but summing
product we actually cared about the
integers but here now that we have this
abstract function this is something
that's that's even more sort of general
it doesn't really work with the fact
that these things are integers and so we
can make this problem work and the
implementation remains exactly the same
this is the type that the changes now
this is now a highly reusable function
and and the type system actually is
guaranteeing that this is well behaved
for all types of arguments and we'll
talk about that a little bit in them in
a bit so so we can instantiate this this
function using all types of arguments
for example we can fold the list using
pulliam's
uphold the list of boolean's using ant
with true with the identity we can fold
it using poor with false is the identity
or we can concatenate a list of strings
using this concatenation with the empty
string is e so walking over a list is a
very much sort of a reusable function so
the property that that we can do this is
called parameter C that is the property
the parameter city is the property that
the polymorphic function or you know a
an abstract function that works over a
number of types that it behaves the same
for all types of arguments for example
with full rights if we look at the
signature hold right for carry in scala
hope you don't kind of see this so it
takes a list of some type a and it
doesn't know what that type is and then
it takes a value Zed it's like B and it
also doesn't know what that type is and
it takes a function that takes an A and
a B and produces a beat and the whole
function for great returns a people so
just by the signature we know a lot
about this function for example we know
that it must return a B if it is a pure
function it must are trying to be and
we're gonna get that B from it so we
must either return the value Z or it
must combines that using F with the
elements in the list and and it has to
do this right but with some caveats
because there there are degrees to which
we get this guarantee so in an untyped
language like for example earlier or
closer you do not get this at all
that doesn't mean that you know that you
shouldn't write highly reusable
generic functions but then in you know
typed in pure language like Scala or or
Java you know that the the function
conforms to the title or it has a side
effect that kind of cheats in a typed
pure line
like hospital or clean you know that it
conforms to the type you know that the
function will do what the type says or
it hanging to your thumb score
I gave it'll either crash or it'll do
the right thing in total functional
languages like a dress or act or or
you will know that the function
conformance of the type or the machine
is perfect right if there is a problem
than that the problem is either like in
the compiler or in the machine that is
not in your program guarantee all right
so the next benefit of a functional
programming is is paralyzed ability so
not only our function is naturally
reusable and testable they're also
naturally safe to run in parallel and so
since there are no side effects across
threads it's easy to to reason about how
they how they pay so for example if we
have an HTML document like this
that's no imagine that this is a really
long HTML document and then also imagine
that it's useful if if you have a
document like this and you want to parse
it right you want to you want to turn
that into some data structure now if you
have a machine with a lot of cores you
want to use all your course to parse
this structure so you can do it as
quickly as possible all your available
course at any rate so a strategy that
you might take is to partition the input
into into chunks and in chunks where n
is the number of cores that you have
available and then you want to run the
parser and all the chunks simultaneously
each one each parser is for each run of
the parser is working with a small
subset I think yeah at the inputs or a
large subset of the input or whatever
and then each one of those rooms will
have a partial results and then you
merge the partial results at the at the
end so you know you do this in parallel
so a partial parse results might look
something like this so but the parser is
not going to have Lex inside of it it's
not going to
mutating sums of data structure some
some global somewhere it's just one to
return a result it's gonna be a pure
function and a partial result might be
for example a string an HTML like a
parsed HTML document and another string
where the string on the left is sort of
the garbage that it wasn't able to
recognize as HTML that was on the left
of that the actual HTML content it
wasn't very nice and then the middle
here is the the actual HTML document
fitted or snippet that was able to
recognize and then there's some garbage
on that on the right right so then we
have two of these partial results that
may have been parsing chunks that were
next to each other then you can take
these two partial results and just sort
of line them up and then you can add the
two strings that are in the middle and
now you have you know a concatenated
string and then you can just parse that
can generate a string into HTML snippets
and then you take the three HTML snippet
so you have and you can catenate them
into it two one and now you have a new
partial result so the the larger result
is the same as a as a smaller result so
yeah I have a little diagram here like
how that might work so you have a I
can't really see this but so so you have
at the bottom you have these four
partners or four partial results right
there results of afford they print tough
runs of the car there and then you take
the two partial results on the on the
left and you add them together and then
you take the two partial results on the
writing action together you can do this
simultaneously and that will give you
two more partial results and then you
take those two partial results in you
method together so you have a tree of
parse adults I mean you can sort of
combine your conclusions in parallel so
it's not really that's that functional
programming is like more parallel it has
inherent
or is that faster than you know using
like actors or beautiful state it's it's
not better in that sense it's just that
it's easier for us to reason it out
because you know we work we can we can
reason about what is our input what is
the output of the of the function and
then how do we combine the outputs of
the of the functions and this kind of
reasoning scales very readily to very
large problems because we can reason
compositionally and we'll get to
composition that compositionality here
in a second but I want to say that this
reasoning scales because of conceptual
integration so our brains work a certain
way like I don't know about you but at
least in my case like not a lot of stuff
fits in here right so in in functional
part of meeting where wherever we see a
pattern and it might be might be you
know something really large but we see a
pattern in a lot of different things
then we can integrate all of the
instances of that pattern under sort of
a single concept and then we can give
this concept crucially a name and we can
hold on to that name and and that's
label will you know serve as a you know
an entity that we can hold in our minds
and then so the entity might give us
access to you know a great deal of
actual concrete's so this allows us to
you know to reason very sort of
compositionally but it also allows us to
communicate ideas to other programmers
with with extraordinary efficiency like
just like you know let's say that you
know I wanted something to sit on and I
could say well why don't you get me a
platform that has like sort of for you
know things coming down from it and you
know or you just go well just could you
give me a chair right so that that's the
idea of chair right we can communicate
that to other people with efficiency and
it's the same way in programming I think
say oh I had this new phenotype you know
I want you check it out it's a data type
but it's kind of like a tree and it's
you know there's data at the leaves of
the tree and it has like you know you
can graph trees at the at the leaves and
it has a normalization step that
preserves some invariants or you can
just say if both you and your core would
know monad is you can say it's a Moana
and nothing else needs to be said so
communication with others becomes
becomes very easy and quick and also in
in functional programming we're very
working very closely to sort of the
underlying mathematics of software I
mean that the properties of functions
have been studies going back like
hundreds of thousands of years and we
can draw on all of that knowledge in our
own programs and I think that's a
tremendously powerful so yeah let's talk
about compositionality so we functional
programming software at every level is
constructed from some modular pieces and
those pieces can be individually
understood and if we understand the
pieces and how they are put together we
understand the whole because our
reasoning about programs is
compositional because because functions
can pose so so yeah compositionality is
the property the software is constructed
from parts that can be individually
understood and he understood the whole
by understanding the parts and how they
fit together so in sort of classical
architecture and opted oriented
architecture or something like that you
you combine things together if you have
a lot of different X's and you can
combine them together you get a larger
structure right combined it lots of X's
to get it why not like another X and an
example of that is like an IRC container
or actor systems or even physical
systems like if you take two physical
systems and you combine them together
the surface complexity of your overall
system is increased but in functional
programming this is not the case so you
you take lots of different components
lots of Exodus and you combine them into
another X and whereas you might consider
that to be a larger X the the surface
complexity of the composite is the same
as the individual pieces so the whole is
the same as the parts so it's sort of
bigger on the inside but it's not any
more complex on the outside so this
doesn't really have a physical analog
but it doesn't have a mathematical
analog so compositionality is is
everywhere in mathematics for example
numbers are compositional like we can
take the numbers 2 3 &amp;amp; 7 and we can
compose them into the composite number
42 and in the same way we can take two
functions F and G and we can combine
them into a composite function called F
G and it doesn't matter if F and G are R
if they represent millions of lines of
code that at this level we don't care
about that right so the composite
function f G is still going to be just a
function and it's going to be reusable
and parallelizable but it's going to be
modular and you're going to be able to
compose that with other functions in
exactly the same way so programming in
the large and programming in the small
have very much the same character so I
want to show you just sort of like an a
medium-sized thing
so this is not like a very large system
but it's a it's a medium-sized library
that has this kind of property so it's a
Scala library called Dubey it's a purely
functional library for talking to JDBC
data sources
Scala and every one of these components
in in red is a valid program in and of
itself okay and it's also a just a
reference to transparent value right it
doesn't actually go and do anything it's
it's a recipe for doing something and
the the things in blue are sort of
combinators are functions
we can use to to compose things together
so just like we can add and multiply
numbers we can you know add and multiply
where we can calculate on programs when
we will be used pure functions so this
is a program here you know the meat of
it is to set the password of Rob to v
it's just a super secure password
and so that's so that's the meat of it
took then the first little blue thing
says that before you do that auto commit
I mean set on committed false and then
after you do it then commit and then we
compose that with support programs one
called rollback flows with on exception
and ensuring to make sure that you know
if something goes wrong then we roll
back and at the end we make sure to
close the connection but importantly
this program PRT is just a pure body it
doesn't actually do anything and we can
continue to compose it with more
programs and but at some point you know
there would be there's some machine then
we give this program to and that machine
will go execute it but importantly that
machine is not inside of our burger so
so yeah to quote Bradford Larsen
functional programming feels like
playing Lego constructing castles from
simple composable pieces that snap
cleanly together so we're always
composing things and a reasoning about
programs is is compositional as well so
to conclude some property about some
system ax we can just take X apart into
its component parts and then we could
include the property P about each of the
components and then we assemble the
conclusion was very much in the same way
that we were assembling our partial
results of our HTML parsing so we can
think we can do the same thing it's sort
of a higher level and our reasoning
about programs and another important
property of compositionality is that we
don't have to start with any particular
component in our overall system because
every
is composed out of individually
understandable components we can start
working on whichever component
intersects the most at the moment or
whichever one we feel is the highest
value at the moment so to quote my
friend Jessica
she says functional programming makes me
happy because it can start with the
interesting part but notice notice she
says functional programming makes me
happy and I think this is really the the
most important thing about when some
programming that we should be
communicating to to people is that
functional part of you makes it happy so
happiness is sort of a property at this
because I mean think about it why are we
here like why do we do this at all you
know I mean his programming right so
we're not supposed to talk about our
feelings right so work but but I think
this is an important point to make all
right we program because it's
exhilarating it's an exciting thing to
do right but in a lot of systems like
you start with a greenfield system and
then you sort of lose control of it
right it's it starts to become a big
ball of mud and it's sort of difficult
to to have sort of a large overview of
systems and I think that's especially
true in systems where you know there are
side effects and things are you know
talking to each other in a way that you
you might not where things are not
cleanly separated right
so yeah functional programming it is not
like that like the character functional
programming is is not oh it doesn't have
all this friction and frustration very
much or as much because functional
programs are clean and they follow up
predictable laws so it's easy to move
things around and change them and if you
make a mistake it's not so bad because
you know the laws will ensure that that
you don't fall off and then you don't
have to worry so much that the program
will do something unexpected all right
and and because you work at a higher
level of abstraction you have fewer
things to keep in your mind
you know you can you can keep the
abstraction in your mind and sort of
forget the details and so you have less
cognitive load on your brain and so this
this makes me feel relaxed easy and my
reasoning is easier because I can take
each piece of my system out individually
and I can think about it and and I think
I'm more productive because you know the
search space for solution is in my
systems is smaller and and then yeah at
the end of the day when I built
something I feel proud of what I've made
because I feel like I'm making something
that's sort of reusable and you know
maybe even beautiful and and useful so I
don't feel as much that I'm making a big
ball of mud and I also have confidence
that it would be suitable for the
purpose at hand and if it's not that it
would be easy to change so I asked a
bunch of people on Twitter to share with
me their emotional experience about
functional programming and I found that
it was overwhelmingly positive like
people love functional bergman and why I
wanted to know why and raceless Rob says
FTP makes me happy because there's never
any unstated context I had to know
there's no understated context I have to
know about the rules are always the same
I say I feel less mentally tax has been
Dylan says I feel like FTP was how I
wanted to work all along I feel like
they can trust myself more
you know people people have positive
things to say and this is my favorite of
all of them that came in so this one's
by Katie she says functional programming
makes me feel sane I feel like a
mathematician and an artist living in a
beautiful structurally sound clean house
and I mean that's awesome right I mean I
want to feel like that
I I mean I I want to be like that all
the time but not everybody you know Kate
came back with a very positive response
and I thought this particular response
was very nice because there's a lot to
to speak to here
so he says functional programming is
nice to play with but I feel it's not
practical for the programmers in the
trenches so sorry so first what is this
person trying to convey all right so
what I get from this is a feeling that
functional programming represents you
know play and joy and creativity but
this person will with this person's
actual work isn't like that
it's not like that at all so his actual
work is is about duty and sacrifice
trenches right and I mean I know I know
first hand like I spent a lot of time in
enterprise Java I spent about 10 years
than any brave Java and I mean I I know
that like a long career in software can
leave you cynic cynical and jaded and I
mean you know writing credit locations
and like transporting XML all over rest
services it's mind-numbing soul
destroying work but I find that with
functional programming even that kind of
work is you know it can be beautiful it
can be enjoyable because you are you
know you're composing even though it's a
crud application or you know something
really uninteresting you you're
composing it from components that snap
cleanly together so I always feel like
you know I'm playing with LEGOs and it's
actually really fun because I mean new
thing like programming should not be
transformed at right it's it's a
creative discipline it's it's an art and
a science it's about truth and beauty it
is about things that could not be
further removed from the horrors of wars
and trenches so I would say no
programming is absolutely not practical
for the trenches but it is or it could
be a ladder to get you to get you out of
there so also he says functional
programming is nice to play with and I
think playing is important all right so
if you think back to when you first
discovered programming which may have
been a very long time ago or it may have
been just yesterday so I mean yeah just
just think about what made you want to
be a programmer I mean I'm sure the
first program you saw that said I want
to be a programmer it's not like
surprises
I mean it could have been and we still
love you
but I mean I remember seeing a computer
game for the first time I mean I was
thinking well I really wonder how they
did that right and I want to do that too
so so right from the start programming
for me it was was it was about
creativity and wonder and joy so it
became sort of an outlet like an arts
like a creative outlet for me but also
like figuring things out like that like
science
so I want to resist the idea that it
being practical is like conforming to
duty and being conventional and doing
what everyone else is doing so I I think
being practical is ultimately about
figuring out what it is that you want
out of your work and your life and then
going to make that happen figuring out
how to make that happen practically in
the world so it's not all or nothing
like functional programming is not all
or nothing I think to the extent that
you use functional programming you will
reap these benefits or you know I think
you're highly likely to read these
pendants but I I also think that
sometimes you know you may want
something to go really really fast
and then you may have to throw away this
sort of human simply and just you know
go run on the hardware you know in the
future we we may have tools that will
allow us to work at a very high level of
abstraction and then you know compile to
a representation that is really really
fast and we do have that to a certain
extent but I think that that will only
only get better also I think you want to
make the boundary between your purely
functional stuff and and your not purely
functional stuff you want to make that
boundary very clear and this applies you
know to people who are working in
programming languages that are not truly
conquer them like this person doesn't
even come up in you know in high school
right flakes should I be pure should it
be in here it doesn't it doesn't come up
but if you're working in you know a
language that isn't the purely
functional language you should make the
boundary between the pure and impure
parts abundantly clear like if you know
if you call a side affecting thing from
a pure thing it's no longer pure right
so yeah and you will get reap those
benefits like to the extent they use LP
and that extent should be dictated by
you know your skill and your comfort
level and the technical requirements of
whatever you're you're working on but I
think that when we talk about comfort
level I think it is important to always
be slightly beyond your comfort level
always be a little bit uncomfortable you
know like always feeling a little bit
like you don't know what you do maybe
maybe that's just me so I hear this idea
like I can't use functional programming
because oh my co-workers won't
understand it and I think that's
nonsense
i work at a company called verizon on
cue and we are building a next
generation television service so this is
this is everything from the silicon up
to like the service platform and we have
a hundred or more people doing
functional programming in Scala and most
of those people had no exposure to
either one of these things before they
start and this is not very long ago this
is just in a couple of years so
the way we did this and I've seen this
play out in other companies as well is
that you know you start with sort of a
purely functional core your core
services you start building them really
functionally and you have sort of
functional programming expertise in the
core teams that build those systems but
then you know you build that outward to
sort of peripheral systems and so you
sort of be in fact so functional part of
me sort of infects the larger
organization felt like a zombie virus
right so what we did was distributed
education so instead of having like you
know okay everybody come to a lecture
about functional programming you know we
hire people who know something about
functional programming we're sort of
maybe even functional programming
experts and we put them on on teams and
we make them ask them to teach their
their co-workers and that verse
tremendously well so so yeah and we have
like team sessions with care programming
and so yeah we make education sort of a
part of the organization and I think
it's important for for managers who are
managing teams to give people were
working on the code to get them time and
freedom to experiment like given the
room to like fail a little bit give them
room to be a slightly beyond their
comfort level and I think that like
doing that you will be able to in your
project reap all of these benefits of
birth so yeah I actually wrote a book
about functional programming with my
friend Paul
it's called functional programming in
Scotland it was published a few months
ago and you should be able to to get it
wherever you buy books and so this is
this is a tutorial with a lot of
exercises
and I think that existed in if you're
just starting out professional
programming if you're interested in
learning that I think this is a good
place to begin
so yeah in in summary functional
programming has real practical benefits
and those practical benefits include
modularity compositionality and
crucially a conceptual integration and
happiness and productivity and I want to
say that this last point is the most
important one like I think I think your
happiness matters immensely you should
think about what it is that makes you
happy as a bird and I think that's it's
the most important thing in the entire
world
so we can't answer five questions or any
questions
is that my problem
I have very complex algorithms which
involves mutation that size simulates
with quit start okay which sells loves
mutation can be decomposed but the sub
functions like swap and partition
usually of some changes some of it is a
so we could move the functional boundary
around the whole big bowl of mud that is
quit sir okay
or we could refactor it using the
functional technique so you say
something like it
well there are tweaks up which is not
bitter at all because it's very slow so
because it's constant so creating lots
of garbage so what do you recommend for
the functional programming problem in
the trenches well no actually in this
book in chapter 14 of this book we use
exactly that as an example where you can
use mutation curly bummer so why you
what you end up doing is that you have a
monad the captures
keep talking I did yesterday so it was
even slower because of sky is actually
scarce as demands are very very very
slow Bella you could just put it in a
function and say I promise I won't
modify experiment words so this is
enough depth that gives you ability to
do notation but do you recommend living
it as is so having a big ball in my of
Martino River boundaries around around
or even robbery factory losing
performance with your practical advice I
would use if you're going to use
quicksort with mutation in there it's a
monolithic thing because like I say
sometimes you want things to be really
really bad right and in Scala like we
don't have the machinery at the moment
to like compile that monadic
representation down to the fast though
right but in Haskell them that would
work but in as the representation of the
Mona and Scala that doesn't work so
therefore I would recommend you know
doing them the best thing making the
monolithic the quicksort you know as a
function is pure right yeah thanks
what do you think about the trade-offs
between different functional languages
like Haskell and scowl first of all what
is the reason that you are coding is
common and most recently Nesta the
reason I'm coding in Scala is that
because I want type does that a question
is time-consuming to test two things in
fact talking about the Scottie example
because you can test with a Mach one
thing if your function or then you can
test function simply but you also have
to write this this machinery that runs
is out to programs is yourself isn't
making two systems instead of one too
expensive I don't think it is because
both of those systems are individually
reusable and then composable with other
systems and also the benefit that you
get like for testing think it it may pay
for itself right because you know you
now you're able to I think write tests
that are very small and simple it means
to understand a little bit to have like
really big like integration tests so I
think the benefit is definitely that the
part about payments will not change very
often but the body are that's their
business logic during the iteration
change often right you have to believe
you have to change all of them each time
their business requirement changes well
yeah importantly they can change
independently of one another if you
change pathetic our implementations
right you know if you want to use the
fax machine instead of the Internet and
you can do that
so my question is a little bit more
functional programming Scalla
mediators part two I don't think that it
would be a part two but I mean I have a
blog right - that occasionally Paul also
has a blog and he writes that as well so
you know we're doing all kinds of stuff
and we're publishing about on that
that's what we're working on but I don't
think that there will be a sequel to
this any officers here
I don't want to start the language wow
it's just a conversation yes the
constant in Java and my Java is maybe
not the best ocean for the enterprise
languages and birbee degree of freedom
it is real to us plus we may say that
C++ is the octopus made by gluing
additional legs to the dog and isn't the
same with this color when we can use our
tutorial sporadic functional and yes I
think I think this kind of flexibility
is is both scholars strength and also
its weakness that you know there are
lots of things that you can do but that
also means that at a higher level there
are a few things that you could say
about what you are doing but yeah I
think that if you want to do functional
programming and you you end up wanting
higher kind of types and there and
pattern matching there are their
facilities in Scala that you don't have
in a language like Java that make it
more suitable to functional parts
animals okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>