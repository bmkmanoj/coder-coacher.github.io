<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Learning Erlang - the advantages of keeping things simple | Coder Coacher - Coaching Coders</title><meta content="Learning Erlang - the advantages of keeping things simple - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Learning Erlang - the advantages of keeping things simple</b></h2><h5 class="post__date">2013-04-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/W3szsF6X5r8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to the third in the
series of align solutions webinars
entitled learning align with the
advantages of keeping things simple my
name is Martin malicious and i'm the
solutions director here at airline
solutions today's webinar follows on
from the one we had last month which was
dealing with Mongoose I am our instant
messaging platform and which is
available for viewing on our airline
solution web pages today's webinar goes
into the very heart of what we do as a
company completely devoted to the
airline programming language learning
their language that key step in every
perspective your language life starting
from the right foundations can save a
lot of time and maximize efficiency of
invested efforts and the line is all
about efficiency and saving time it is
also a language that is very easy to
pick up and start with this is all why
we here at erlang solutions place much
emphasis on training companies and
individuals in Erlang and introducing
them to a new and a bigger world we
spare no cost and effort in providing
customized airline training tailored to
needs interests and backgrounds of the
attendees and we have been doing so for
the past 15 years getting organizations
across the globe to become knowledgeable
in Erlang and self-sufficient and
confidence in their airline development
and ambitions when her line solutions
were formed as a company where you have
the distinct privilege of having people
who invented airline as a language join
our ranks
it is indeed these people who today
perform our language credited training
and who traverse the globe in spreading
the airline skills and knowledge
today's webinar will tell you all you
need to know about getting started with
learning airline and what makes our line
so simple to pick up and to begin with
as with any life events please excuse
any technical issues we may encounter
today to start by telling you a bit
about airline solutions we are a
products and services orientated company
completely devoted to our land since our
founding in 1998 we have worked with
organizations and individuals using our
line helping aboard the language and
supporting people and businesses you
today we have about 70 people across our
offices in London Stockholm Krakow and
Budapest and working on projects across
the globe we fly the airline flag and
are keen on creating value and
competitive advantage for our customers
across industries and through the unique
features and characteristics of our
language language we are ambitious in
development of Erlang based products and
we work to create lasting partnerships
with our customers in terms of today we
fought too long and hard about our
speakers for the webinar and have opted
for two people who are second to none in
terms of providing an introduction to
why and how to learn our like I'm very
glad to say that today we have with us
the airline solutions product
development manager Torben hoffman a
self-confessed
priest of our line crew has taken his
ministry to a whole new level in driving
ul and solutions his product creation
Tobin has many years of practical
airline experience across industries and
has spent a number of them supporting
the spreading of our line and the
strengthening of the airline community
we are also deeply privileged to have
with us Robert verdict Robert is of
course one of the inventors of our line
from the early days of the language at
Ericsson labs and today uses his time to
spearhead our research efforts and also
travels the globe and performs all I'm
training for our customers across the
world I'm sure you will all agree that
there is no better way to learn our line
than from the person who created it
should you or your organization be
inspired by the talk today and wish to
arrange a tailored training session
performed on your site you might be
lucky enough to have Robert Verdi
delivering the training please allow me
to finish by saying you are welcome to
post questions throughout the duration
of the webinar by using the chat
facility our speakers told that in
Roberts will answer as many questions as
time allows at the end of the webinar if
any questions do go unanswered you are
welcome to raise them via email using
the following address webinar at our
line - solutions comm that's webinar at
our line - solutions comm if you are
interested in learning more about Erlang
training or if you wish to start
which whether it may be a solution for
the challenges your own business may be
facing please feel free to use the same
email address or email me directly using
my email details which will be shared at
the end of the presentations the same
goes for any other questions you may
have
feel free to contact us I will now like
to hand over to Tobin Hoffmann who will
be glad to start us off
yeah Thank You Allen for the kind words
I will give you an overview of the key
features of Erlang today and also a bit
of background so you can get an idea of
why learning is the right fit and how
you can go about deciding if you should
be using your line for a particular
problem so we'll start with a bit of
history and and also a bit of how things
are when you're developing software and
it started this started back in in the
80s where X and has an enormous pressure
on getting their products to market a
lot faster I don't think that's the same
pressure we're all feeling today getting
things out there in a product priority
that lasts in a fast is a huge pressure
then there's also the ever challenging
thing about utilization of whatever cube
computing your resources you have
available then there's also the
fortunate or you could say a rich man's
problem is that when you have a success
you need to be able to scale it and not
have your software break down on you
when you end up having millions of users
are using your software and then at the
end of it you also have to in the long
run maintain your software and that also
turns into a burden Ericsson saw this in
the 80s and the realities are sortable
and it hasn't changed much since so how
did they go about it Ericsson well they
started out by saying a number of things
about what they needed but what we will
just have a short information here and
say what could be and this is the
promise of Erlang what if you could
finish up three to four times faster
than your competition so you'd be the
happy man on this picture what if you
had software that you could just
magically scale on the number cores in
your machine and also the number of
machines you throw at your problem
without having to rewrite the code and
what if you could avoid having huge
stacks of code but just a smaller stack
of code that's more readable and
understandable and if you could have all
of these that equates money and that's
what we're all here for to learn how to
make money and the future is actually
here and the futures learning and it's
gone
some 20 years in the making and yeah
now Ericsson started out by posting a
number of requirements for Erlang not to
be a general-purpose language but to
solve the specific needs of they had for
telecom so they wanted large-scale
concurrency so this is about having tens
or hundreds of thousands of processes
ongoing in it an assistant at one time
this or or innate originates in the
needs they had for telecom where you
have a number of ongoing conversations
in a telephone central and these things
given that they are related to audio you
have some soft real-time requirements on
it because they need to respond
relatively fast in order to have
reasonable performance these systems and
then these they also had to be
distributed because you couldn't really
live with the fact of having a system
that was just one node no one machine
Europe that would be too small to solve
your problem so you needed to distribute
the application over a number of
machines also for the sake of poverty
and disease then you needed to interact
with hardware because not all things can
be handled in wonderful software
sometimes you need to get closer to the
metal and that's why you need to be able
to interact with hardware you also had
to provide quite large software systems
because they had a lot of features in
them and a lot of those features were
actually quite complex and anybody that
has seen the code or most or the feature
sets and most telephone switches will
testify that that's a complex system and
and then they had to have the things up
and running for many years without going
down and at the same notice related to
this they also they needed to be able to
have software maintenance on the fly so
that they could keep their telephones
which is running because if they weren't
running Ericsson wasn't being paid they
were being paid for uptime and then they
also needed high quality and reliability
because well people tend to think of
their phone there's something that just
has to work when you're trying to make a
phone call and then they also have to
have for torrents in the mix
if you look at that it sounds familiar I
think many of you would have been faced
by requirements to honor your project
you've been working on that could take
off a number of these requirements and
the thing is it also sounds good what if
you could have something that helps you
get all these things with a little more
ease than what you have to do today and
this is what Earling is about and then
the trick here is that you need to
separate the notions between having
something that did general purpose
program lambie's and something that's
domain specific so in here we have the
domain of Telecom in order to meet the
needs of telecommunications and the what
they had back then they Ayrton mostly
looked at at sea as the starting point
but today you'd have C++ and Java as
your starting point for many of these
things and then there's the entire gap
you need to feel between what the
language provides and what you need to
do in your domain that's the work you
need to do and the bigger the gap the
more work you need to do the way your ex
and then created was that they added ur
line which fills out a lot more of the
requirements of the telecom domain and
then there's a smaller gap here and that
smaller gap actually equals a lot of
benefit you need to write far far less
code that's let's go to maintain and
I've written it in a nice way here
smaller gaps so a smaller gap equals
benefit but actually this equals money
you say money in the both and
development and also in doing it now how
do you go about doing that yeah well you
make sure you have a focus the focus for
Erling is that it focuses on the
coordination the middleware the control
part of systems not about the graphical
user interfaces it knows how to interact
with graphical YouTube user interfaces
but it's not good for writing it it also
knows how to interact the drivers but
it's not good at writing them so the
sweet spot middleware coordination
control so you fear health system or
problem where middleware coordination
control those words come up earner might
be a good fit and then if you look at it
this way we take the dimension I just
mentioned before
you can see how you can go and mix and
match to get the right solution for your
problem
so Telecom has a high need for drivers
because there's a lot of heart when I
need to interact with it also has a high
need for coordination due to the fact
that there's a lot of things going on in
telecom system and the need for gooey
things are is not that great you can
catch other systems on for that or the
Ericsson so on the beginning there that
they had C which is phenomenal for doing
drivers not so good for doing
coordination bit better for doing user
interfaces because there's a lot of
libraries you can interact with so you
can get by on that so what they did they
created Erlang in this way so I actually
I would say sucks at doing drivers but
excels at coordination and it's not that
good for for gooeys they're there and
then when you go and tech the problem
with the combination of C and Erlang for
telecom you have a perfect match because
you have the best language in the world
to write drivers in let's see and you've
got the best language in the world to
handle coordination and that's Erlang
and together that they can rule the
world here another thing here to notice
is that earning is very good the has
good libraries for interacting with
other things for instance C but other
other things so you could take in and
have a system that is written in Erlang
and has Erlang and Ruby and you name it
and you can integrate them and use one
the one tool for what's good at in the
other tool for what that lets go that
now so it would be a short story if this
was only about the telecom but the 10
requirement you saw before we all
recognize those as being generic
requirements and that actually means
that there's a number of domains where
Erlin can be used in so we have things
like messaging systems a jeopardy this
LPP server and also our own current
solutions own mongoose i am for a video
buddy that that's a few more features is
would it be compliant and things like
that and then you go on to have things
like web servers you have yours which
has a lot of years behind it very solid
chicago boss cowboy you can also go into
the area payment switches and soft
switches where we've done a lot of work
with book link and we've created our
softswitch for open for coal think and
you can read more about that on our web
page then Ireland also has found use in
distributed databases react counts to be
Scolari's and actually couchdb has a
success story behind it where the
scalability you get from Erlang was
inherited by cows to be and allowed the
makers are draw something to scale to
enormous Heights and make a ton of money
and that's what we all want to do to
make a ton of money and have fun in the
meantime and then it's also been used in
queueing systems rapid mq is a famous
product that's implementing the AMQP
model the entire back end is written
inner line so you can see there's a
device rated and diverse range of
domains we're like this because the
inner requirements actually fits a lot
of the domains today now now I'll come
into and explain a few things a few
features of Erlang that makes it so
ideal for having a high productivity and
one of this this is the notion of when
to share and not to share memory and
Erlang actor operates on a AI is a
process oriented language which has been
processes communicating by misses
passing in all systems we have memory
and if that processes existing this
memory I've seen that I've have a legacy
in Telecom this is how you build those
systems you have number processes or
frets or whatever you call it in the
language you're doing it in and they are
manipulating say memory the problem
arises when process one dies there it
corrupts the memory what is what are you
to do with the other processes that
accesses the same memory there's
actually only one same thing you can do
and that is to kill that process off and
start all over again that's not optimal
and that's why Ireland has a share
nothing model where each process has its
own memory space you can only exchange
messages between the processes by
sending messages from one process to the
other and in this case you'll see that
if process one dies it still corrupts
the memory it had but then only runs
with the runtime system that has a
garbage collector it'll come around
it will garbage collect the corrupted
memory
process two lives happily without
knowing anything that process one has
died so that's this is a heavy scenario
compared to the old one but you had to
kill off all processes then another
thing that's built into this was the
last item knowledge in a list about
failures we would should remember
Murphy's Law here that anything that can
go wrong will go wrong and the way you
see that when you're doing big systems
is that you can have programming errors
we're all humans so this is to be
expected then you can also have disk
failures which is a bit nasty and all
the sorts of hardware failures and then
you can have network failures which is
also quite irritating but it's things
they can happen any normal post normal
programming paradigms they have fought
intolerant meaning that you need to deal
with the error when it happens or at
some other point if you have in your
flowing exceptions around but you need
to handle that error or yeah you will
have to die your system will have to go
down now omen is this is fault tolerant
by design and that actually means that
failures aren't braced and managed and
that may sound quite weird when you're
looking at it from the first time but
it's actually a sane stance to take when
you're looking at systems you know
systems will have failures so it's
better to have a technology like Erlang
that helps you deal with the failures
and trying to be intolerant to them and
write it on a defensive code and this
actually then turns into money is this
not just a academic feature this is
about money and we'll see that in a few
seconds but the way you do it in Erlang
he did have a piece of airline code that
takes a day of the week and turns it
into the number of that day in the week
and here you have it the full-blown
thing where you act you have a catch-all
cross at the end saying that if it's not
one of the days of the week then we
throw a return an error unknown day as
the value instead of a number but in our
line we burn that code
code we need to see we will let it fail
the corner of this function if he calls
it with something that is not one of the
weekdays we know he should fail because
in this case he will get a case calls
not matching and then you'll have to
deal with that error and that comes with
a notion that error actually encourages
you should be aggressive or offensive in
your programming style go for the happy
day scenario and that somebody else deal
with the errors and we'll get to that
somebody else in a few seconds but this
has as I said and it knows effect on the
amount of money you make on this and how
is that well here's a study done by
Motorola labs in collaboration with a
young Henry strong and he went in and he
took a C application then he rewrote it
in Erlang you don't have to look at all
the details of this thing but the thing
to know notice here the code that
actually solves the problem the problem
of your customer what you're being paid
to solve this is the app code here for
the C and the C library you have
something like 18 to 12 percent of the
code going into solving the problem the
rest of the code is all sorts of
mumbo-jumbo you need to do to make meet
the requirements the full requirements
and in the system you have a lot of
defensive code around 25% now for Erlang
you end up having 60 over 60% of your
code is actually dedicated to solving
the problem of your customer this is
money in the bank right here do you have
at least a free X productivity when it
comes to addressing the needs of your
customer and I've also done studies
while I worked for Motorola and it shows
that it actually takes the same amount
of time to write a line of Erlang code
as it does to write a line of C code so
the fact you have fewer lines of code in
earning and more that is devoted to
solving the problem actually means
you're making money now
we all floated all this fingered same
you should let it fail the only way you
can deal with having a system where you
can have processes that fails and it's
part of everyday in nature you need to
be able to deal with these failures so
you have one here you have two ways of
doing this either you link two processes
together that means for p1 and p2 in the
top part if one of them dies the other
one will die with it and if you need
that that's part of what depends on what
you try to solve another case you can
also have a monitor thing by p1 is
monitoring p2 so if p2 dies p1 will be
notified but he will not die from it
you'll take a decision based on ok p2 it
is is gone let me deal with that failure
and this is key to making a full
tolerant system is you find ways to link
errors up and you have somebody standing
on the side fixing the problems and then
those things are along what we call
supervisors supervisors have basically
one task to do is to start and monitor
worker processes so when in your system
you'd have it a heat atrophy of things
where the workers are the ones doing the
work of your application and have
supervisors that just sitting there
watching out if the workers they started
if they're still happy and if they die
they take a decision on what to do in
some cases you need to kill off an
entire tree and restart it in other
cases you just restart the worker and
Robert converting will later on explain
more about how this work in the OTP
library because that's built on this
principle but this is the core
functionality of Erlang and this is the
key point to understand if you want to
make you sober like that you have this
notion of workers that are supervised
now the benefit you get from from from
sharing nothing is that you end up
having that even you have if you add
more course to your machines you can
actually have processes running on each
of these cause there's nothing matching
in that but the magic is the totems like
if you call it magic is that you have a
scheduler running on each call and it's
the runtimes
then coordinates between the schedulers
and have processes distributed amongst
the course and have the word distributed
so you get a speed up when you add more
course without having to rewrite your
code all of this is of course limited to
the amount of parallelism that is in
your program but you don't have to
rewrite your program to make user more
coarse you might have to rewrite
something if you're not having a problem
that's not parallelized enough but
that's a different issue this is
something you won't find in many other
languages in your line you get it for
free due to the fact you have share
nothing message passing between
processes and that actually enables you
to do this and that also works over
machines the way earng operates with
having a system that runs on different
machines is every time you have a
machine you can run an instance of
Erlang runtime system and we call that a
node in Berlin lingo then if you had
another machine and run the runtime
system that you connect the two nodes
using a TCP connection and then you will
have a system and when you're
programming that and you're
communicating there you can't tell the
difference if one process you're talking
to if that's on your local machine or
it's on the other machine at the other
end of the world and then this then
extends by adding another node then you
hook them all up fully meshed here and
then you continue on and you have ended
up having a fully connected graph
between all the nodes and it's totally
transparent to the to the programs again
whether the processes that are doing the
work are located and that allows you to
scale over machines now staying alive
you have to learn some new moves to stay
alive in the other stem entities you
have Kyle kept guys like David Bowie
with the punk rock and everything then
you turn into a disco some call it the
Dark Ages I don't know and then it
turned into Michael detection in all
cases those people that were controlling
and mastering the dance floors of the
time they were faced with the challenge
every time you had this disruption you
can think of this as a direction in what
you have to be able to do the
requirements do you change and most in
most cases in most systems you either
have to stop dancing you have to have a
total restart and learn everything and
those things are not nice in the way
this is handled
earning is quite different this is
staying alive Erlang style
there's no curling dance like there's a
kind of style dance yet but maybe we can
get up with a fit up to the point of
some day now what do you do in our line
you have a process it's running version
1 of your code now instead of having a
total stop of your system and take some
time to learn the new moons what you do
is you load into the runtime system
version 2 of the code for the same
process then when you want to change
some version one to version 2 you send a
code change signal to the process and it
actually stands running version 2 of the
code and that this is how Ericsson
managed to with some of the switches to
get nine nines of uptime in the systems
because they didn't have to take down
the systems to operate the systems there
it's a quite powerful feature and that
concludes my part of this and now we'll
leave the word to Robert Burton who will
take you through OTP and what it is and
what why it's good for you thank you
hi mrs. Robert Verdi yes so I want to
talk a bit about OTP and well therefore
at the OTP why OTP C yes now it goes yes
question is why should I learn and use
ATP as Tywin explained darling in itself
has a lot of nice features so why get
what way why not just settle for those
and well one simple reason of course is
I should use it for the same reasons
most even of all production systems that
are running air like use ATP I honestly
don't know of any product which doesn't
is not based on OTP well the question
then it becomes of course why do most or
all production systems use OTP not just
using the bare outer this boils down to
what you need to do what you need when
you are building a system so when you're
building a system you need libraries
unless you're writing an extremely
trivial application you will find very
quickly that there is an awful lot of
code that needs to be written an awful
lotta libraries that that are very
useful if they exist so you need
libraries doing orders you can of course
do it yourself there's nothing stopping
you
it's just often a lot of wasted time
what is also very important is you need
a set of design principles patterns for
building lists and structuring your
system how am I going to map put my
sister together how am I getting it
and what structures am I going to use
how am I going to make everything fit
together nicely these are the type of
them because of these design principles
there's patterns there you need both of
the beginning when you're when you're
actually doing the initial structures of
your systems to build things you need a
methodology for building things and
putting things together you also won't
need but it's also extremely us to have
a set of tools that help you when you're
developing your system tools for
checking your system tools for doing
testing wrong time analysis all these
types of things you need these tools
between and what is also
very important that all these things fit
together so that the libraries that
you're using actually fit in with the
same design principles and design packs
that the rest of the system is built on
so you don't get conflicts in those that
the tools work together with everything
like this so you make full use of it now
they're all these existing OTP an OTP
was designed to tackle these issues in a
way that makes good use of elements
features so it appears pacifically
designed to fit on top of our line and
use our range features in the best way
to all written a now I understand that
that is the reason way to be is what
it's owed EP it stands for the open
telecom platform but there is nothing to
be worried about you should be not be
misled by the name or scared off by the
name as some people have been it is a
completely generic middleware and if you
look inside you'll find there is
actually nothing about telecom in it we
will develop it up the telecoms company
and there was a very nice name for but
there's nothing about telecom dinner
unless perhaps the goal a building
massively concurrent reliable fault
tolerant and distributed systems those
the properties that really no TP those
that those the fundamental properties
that don't if you will design today and
which are the same strap that's really
the only teleporter part that's in
that's India that's you know TP as I
said it's based on a set of design
principles it's in different layers here
so at the top level we have releases
releases are made of a number of
applications and at the bottom level we
have something called behaviour I'll
just just mention these briefly what
these are so a release is a complete
balanced system containing well it
contains the allen runtime system urns
here the actual virtual machine it
contains a large number of applications
OTP applications both those provided by
the ITP
and those that are user-defined it also
contains a number of rules for starting
stopping and managing the system one is
running you can define what's going to
happen how does the system is the system
supposed to be started how much better
to stop the system in a clean way and
manage it and including in the managing
is how am I can I handle up and down
rates of the system while the system is
running so I can I can define all those
things when I'm building my release and
use that so for example if I have a
release running and I have cupboard
upgrade release that will contain
information how this upgrade is supposed
to be done and how can we done while the
system is actually still online and
being used the next layer is the
application and it's well the name is a
slight misnomer it's not quite the same
thing as you ignore expected when you
heard the other word application I would
say it's more a component and it's one
logical Lulu Union room together
it contains well it contains our own
code the modules for building the admin
part of the system it can contain static
data which which this application is
this unit needs to run this unit this
application might actually be running
need code running other languages as
well like C or whatever or Java and this
code will also be part of that
application so the whole application one
unit here that's the static part of it
and at runtime there will also contain
information of which processes are to
run when this application is loaded and
started how's that how's the process run
what this supposed to do the application
as you can as I said you can use them as
components so your system would contain
a lot of applications for example if you
are accessing a database your database
access system part and system access and
database most likely be an application
for that you have applications for
interface in other languages interfacing
other parts of the system so you tend to
split your system up into a number of
applications which are units and they
are interacting with each other working
together for the whole system
mayor what can say this an OTP we have
the concept of it is an other behavior
and a behavior is a formalization of a
design so you have a certain design
pattern that behavior is that cone in
OTP which implements that design pack
and the basic idea behind behaviour is
you try to abstract out the common
generic code of the design pack in order
you want to extract that able to bunch
that together that input that you the
other one unit that is the behavior this
also provide by it's a well-defined user
interface to the specific code for each
usage of the instance of the behavior so
you know exactly what's going to happen
you know which functions you need to
define you know you know exactly when
they go to be call and what they are
expected to do though behaviors also
provide a lot of built-in functionality
which is there if you need it or if you
want to use it for example there are
logging facilities baked into the baby
there's Tracy the basic support needed
for doing proper or easily not quite so
difficult code upgrading are also in the
behavior so it's all there to all the
well-defined exactly when things work
and how things work so the basic
principle behind a behavior is you try
and split the code necessary into two
parts there is a generic part it's
called wall engineering behavior and
these are these that passed them
provided by the ATP's library modules
and there is a specific part which of
course is is what specific for what what
every improve every use of that behavior
is it's a callback module here as
provided by the programmer or the user
now the generic part of course it is
generate it's common it will be used by
all instances of that behavior they'll
be using the same code you just have to
supply the specific specifics for your
use this means that a large portion of
the code you'll be running is will be
Jerry it's common it comes with the OTP
system it is extremely well tested and
routing Peter Taine's actually very few
so the system very well whoa this is the
basis of what what towable was talking
about the nine nines reliability was
using OTP of the bottom are using this
concept for Ian yeah there are well a
number whether they're five predefined
behaviors that come with OTP there's a
gem server which provides a
client-server pattern
there's the gen FSM which provides a
finite state machine pattern and there's
a generator which is something called
event manager event handlers there are
no pro events will events will occur in
the system and these will be sent to an
event manager and then this manager can
have a number of handlers that decide
what to do with this vet arises this is
also a behavior the supervision dream
adamant that Torben mentioned that is
done with the supervisor behavior this
is the behavior that does that this is
the one that that actually manages the
supervision trees like this and the
application itself is a behavior so that
being capsule AIT's the application
pattern and in it is what you eat it
them is used when you want to start the
application and manage the application
it is done through this babe so what
sorry in the first three behaviors the
gem server the GFS mhn event they are
working behaviors therefore the worker
processes that do that do the work
depending you can choose which one
depending which best fits what you need
the supervisor behavior that is the
basis for building the supervision trees
and the reason you have a supervision
tree is that in your system if you want
to be long-lived
there are a number of services that
always must exist always must be running
whatever happens in the system they
always must be available and you used
you tend your supervisors to ensure this
so a supervisor it has a number of child
processes which can be worker processes
or they can be other supervisor
processes using it nested supervisors
you build something which is
a supervision tree our supervisors they
monitor their children that is their
sole job to do and when a child dies
they restart that child depending on
which rules they have used to have where
they've been set up on how to manage
their children so sometimes if a child
dies normally that's perfectly okay it's
done its job is to now go away
it may be for crashes it should be
restarted well sometimes if a child
crashes it is not enough to just restart
that child you may have to kill off all
the children and restart they might be
interacting in such a way that is not
what's not acceptable that one of the
Chester time but the behavior system
OPPD's ot is open-ended and that is
perfectly possible to define new
behaviors if you need a behavior which
is not one of these five predefined ones
you can define your own babe you can
implement processes which fit together
with the rest of ATP I might just need a
one-off process which does something
special which one of the babies can't
give me I can write that process in
using OTP using them following the rules
I can make a process fit in with the
rest of OTP can be managed perfect world
and supervision tree like this so all
the tools are there for doing this so
the OTP is a completely open-ended
system you have your five behaviors when
you start off but you can add more when
necessary so it's not closed in that
sensible so that is some of the reasons
why you would use most of all most not
all products actually use OTP - based it
allows you gives you a lot of extra
functionality a lot of reliability and
it allows you to add things when you
need it allows you to mix with things
that aren't written an OTP as well -
that was just a quick version of a quick
description of OTP and some of the
benefits of using OTP so yes that I'm my
part I'll hand back to model and if you
want more information please contact
okay well thank you for that thank you
mobile phone problem and what I think
would be interesting now is to answer
some of the questions that we've been
receiving during the webinar and I guess
I can start and read out a couple of
these let me just have a quick look at
the list of questions that we've that
we've had okay here's one that's
interest angle I think this might be a
just something that both Tobin and
Robert can answer the question is
effectively on the topic of the child
processes that both Tobin and Rob would
have addressed an effector refers to the
situation where a child process has
failed the supervisor has restarted it
and then the issue is what happens if
the supervisor process just keeps
restarting the child process without
actually dealing with the issue that
caused the crash in the first place
gentlemen if you just want to pick that
up an answer that would be great yeah
well I can say one of the things one of
the rules you can program into a
supervisor is is how long it or how
often it is it is going to allow to
restart something so if you get this
case which we start to work at the
worker dies at restart to work again it
dies etc you can say how often is
allowed is it going to do that and if
that limit is reached then the
supervisor decides I am giving up I
can't work with this anymore I give up I
will die myself and I'll just pass the
back up to them to the next step above
that to decide what to do whether is to
restart me to try yen or whatever that
might be and that that's that's the
building way of handling this problem I
think that's about that's better like I
say a thing about this at the moment I
mean you still have the problem working
out what actually went wrong
and you will most naturally haven't been
locking the system so you can actually
see what errors go
and you can go in and fix the system
one thing I've mentioned in with this I
think Turin when mentioned in factory
code upgrades these type of things were
consist we can do while the system is
actually running spot - so you don't
have to take the system down to fix it
in fact I thank you Robert one other
question that has arrived and that seems
quite interesting yes sir
what is the current limit of multi-core
scalability of our land so that would be
on how many cores would you be able to
utilize the along runtime system and
currently provided you come with an
application that has that level of
parallelism in it then you can utilize a
60 course before you run into
performance hits and that's actually
something where learning solutions is
involved in a number of EU projects
they're trying to address and take this
limit even higher there so we're trying
to move that limit but right now you can
utilize 60 course and I don't know how
many of you guys at home that has a 60
core machine I don't even a but at least
that's what you can do if you have a
very powerful machine
ok here's another question that both you
Tobin and the robot might will answer
the question is effectively Erlang
started within the telecommunication
sector obviously being sort of created
by Ericsson within Ericsson labs now
would you say that Erlang has spread as
actively to other sectors and if you can
give a couple of examples of
applications outside of telecoms yeah I
think I listed list of the few and when
I taught and I can say for instance if
we take the notion of react which is no
sequel database distributed the one that
they're the all the things that are so
good about the core requirements coming
from the telecom actually rings in here
you need to be fault tolerant if you're
dealing with a distributed database need
to have a massive amount of concurrency
if you have a lot of people accessing
your data that that's what you have in
those systems so that it has
spit quite well and the legacy of
telecom also shines in RabbitMQ because
one of the things you need to deal with
on a daily basis in telecom systems are
protocols and AMQP is a very well
defined protocol and it's like running a
hot knife through hot butter to use
Ireland for for AMQP and that's what the
the people that did rapid mq did so it
has that ability to spread when the
problem is wide so we need to have a
keep in mind if you have a coordination
problem Berlin might be your friend if
you have a hard core CPU intensive
computation you probably better off
going somewhere else because mine is
designed for low latency not for high
throughput for these things and also not
for really going through the metal and
getting the max out of your computer
it's a coordination language and that's
also why it's as I said it's a
domain-specific thing and that has a
certain domain or range of profit it's
very good for and then it out sources to
other programming languages things like
being in the drivers or a hard core
parallel computation that's sped off
done in C so that's the kind of
flexibility you get with owning the some
hope that answers the question I think
about it
can I get if I can just add one thing
and it's actually well it types it is
actually being used more outside of
Ericsson in the telecoms branch than the
inside at the moment and things we need
we want to handle a large number of
connections for example sue Dowling very
well it's being used in the gaming world
the backend for those reasons that it's
very easiest of the system which can
handle large number of communications
and it uses quite a few resources to
that compared to other to other systems
so if you want hundreds of thousands of
connections parallel connections Allen
is a very good choice for that so just a
quick comment
thank you Robert so there's another
interesting
question that touches upon the heart of
the topic of learning Erlang along is
obviously you know the community of our
language is a growing community and the
question specifically says if you have
not used Erlang previously but you are
using a line based solutions and sort of
black boxes that give you performance
scalability and so on
do you actually have to learn Erlang or
are you able to sort of hook in using
your existing tools and you know happily
coexist with a black box whilst using
your current tools I think we can speak
to that from from the standpoint of the
example of rapid mq and let's take from
that standpoint that you can actually
use rapid mq for years without having to
learn yourself one line of Erlang
because you can interact with it from a
number of different languages and so
that's absolutely doable and you can do
the same thing with react actually you
can interact with a from a number of
different languages and get the magic of
that that set then for instance for
rabbitmq sometimes you want to take the
system a bit further than what it was
originally designed for because having a
a queuing system there already created
for banks like AMQP might not be the
perfect fit for whatever queueing system
you have in mind and in those situations
you need to go a little beyond under the
hood and look at the engine and do
something but you can live happily for a
very long time with these systems
without knowing early but then again I
would say that it would be a great pity
not to learn Erlang it's been one of the
biggest joys of my life so that's a lot
of fun you're cutting yourself out from
but on the business-wise you can live
happily for a number of years absolutely
well thanks for that organ my one that
has arrived is one that I can provide an
answer to and that is what kinds of
training do we have Carl friendly well
I'm glad to say as I mentioned briefly
in the introduction we effectively offer
tailored customized courses online
training courses that are performed
on your organization sites so
effectively that means that you can
choose between a beginning or a
beginner's level course or an
introductory level course of our line
and an advanced level course of course
is lasts for five working days which
basically means throughout the working
week one of the course is entitled
Erlang by example which is the
introductory level of course the other
course is called our long go TP and
we've talked about LTP during the
presentations the course is we always
tailor very specifically towards your
organization towards your specific needs
and requirements towards the attendees
themselves so the people attending the
course their backgrounds and unique
interests and this is where the sort of
power of learning really comes through
and finally as I mentioned in the
beginning we have some remarkable people
actually performing the training courses
of Robert wording for example it's one
of our leading sort of individuals going
around the world and training people
across organizations and industries in
our life so if you are interested in
organizing the course within your
organization then feel free to drop me a
mail or top us a mail and we will be
happy to sort of discuss your specific
requirements and make it happen okay one
sorry one additional question that has
come in as we speak is how easy is to
integrate our line with other languages
in other words how open is our line to
that connection go further you go ahead
you get I think no I thought stupid upon
it because Aricent created Erlang in a
space where it needed to fit in with
other technologies so Alan is actually
is a Robert Stein saying very easy to
integrate with the other languages it
has a binary term format that's very
easy to decode so it's very easy to set
up a communication path between an early
process and something that's
written in some some other language the
biggest library around and that the
church with OTP is focusing on C but
there are also lowers out there for
integrating with Python and Ruby and so
you can mix these things in quite nicely
and one of the research things we are
looking at right now on isolations is
how to integrate with OpenCL and find
ways to get the benefits of AB running
code on your GPU which is normally quite
caramelized pure intensive code and then
have the coordination still handled in
our line I think you can you add for
that proper yeah yeah I mean as you say
I mean a language design talk to other
systems from the very beginning
initially it was some telephony hardware
I think almost all applications they've
been built products with built in in
Ericsson Allen has been the controller
and look at the control and logic level
and there have been things written need
and specialized hardware or it's C for
doing the low-level data transfers so
this this split between now and Daily
News other things has been in from the
very beginning and there are a number of
mechanisms built into the system at the
low level which allow gives you
different ways of talking with the
outside world other systems and there
are a number of specialized things built
on top so for example there's something
called application called J interface
for talking with Java and you can be
mated anything it sure thanks for that
Robert sir another question from a
person who is clearly a prospective
Erlanger Vivek is asking how long does
it actually take you know in your view
to become proficient in Harlingen in
particular proficient in OTP okay it's
batard even it depends a bit on your
background and I use a functional
language and that can take well say a
few days getting used to the style that
we're doing it of how you know you
program in these things
the very
explicit and deep-rooted concurrency a
line means a different way of how you
structure your problem just all your
solution to a problem which can take you
people getting used to
OTPs is very in many ways very
straightforward once you've just
mastered programming writing code in a
line going to ADP I think anyway is
quite a small step the fundamentals of
design patterns bind ATP over other
basic and very embarrassed I think
easier needs to understand then of
course just need practice so I mean a
week or two that's perfectly well follow
that's perfectly well for knowing moment
learning most of the language and most
of OTP and even building systems in OTP
then it was as I say you need practice I
know you going to act incentive a bit
our reply to that yeah well I lived in
an organization the one what very much
into performance and or productivity
rather not performance in the sauce
productivity and I measured out that at
the end of the project which included
the learning curve falling after after
four years where we include everything
and this is everything from the system
requirements all the way down to system
tests and also have sex acceptance s by
customers all the effort that went into
this inner line comes out as free times
as productive as see see flip the C++
and Java and and five to six times as
productive a see and and then you can
say when one is a crossing point and
thence Robert says depends on your
background if you are a imperative
program or a guy that worked Drummond
with all things I would say that it
takes you about two to three months to
reach the same productivity you have
before and by doing and then doing it in
Erlang and from that point on your curve
just goes up and up and up because you
are more productive in Erlang if you
have the right fit between the tool and
the problem at hand and this learning
curve is then faster if you have
functional programming background or you
have some
of background in closest algebras as so
that's meaning the more theoretical
computer science those kind of things
will boost your learning but I was
saying two to three times a good
programmer will be more as productive as
he was in the old days using C++ or Java
and he never Lang and then from that day
on you have a heavy man
that is just seeing his productivity
lazy day by day okay we we have an
interesting question that has just come
and we must make this the last question
now sadly as we've sort of run out of
time but the question is effectively how
would you compare our language and what
are the benefits of Erlang compared with
tools such as Scala and acai so this is
on the topic of using the right tool for
the job and obviously you know seeing
what what do unique benefits of our
langar in comparison to these two tools
I can just say one thing here that actor
is very much a copy of OTP they don't
hide it themselves they're quite off
they're quite open about this and saying
it they've had many ideas for designs in
yanaka I've been taken for a TV yeah I
will say using something like Scala that
would if you're coming from
object-oriented background you can still
program in the object-oriented way but
in that case you lose some of the
benefits you would have from Scala and
akka having in a sense is much stricter
and forces you to fit in but at the same
time you get yeah you use your agents
much much safer in using these in the
using that they are in features yeah I
think Roberts right and I would like to
add to this that akka is is is a rewrite
of OTP using the same principles the
same notions as there is in OTP in
Erlang there so if if you have to be on
the JVM that if that's a business
requirement for you then akka is
probably a best choice to do some
which reliable fault-tolerant systems
there but if if that's not the key
requirement then you have to keep in
mind that Scala and AK have they come
out of the school that is a bit more
that those in the way you write code so
you end up writing a lot more lines of
code there and that's actually something
when it comes to common tech maintenance
time which is for most secure systems
unless they fail utterly is 80% of the
time so you have a lot less code still
when you're writing Erlang and that's
actually a key point to keeping your
engineers happy in the long run that
they don't have tons of code that they
can't find their way through there so so
Erland is more to the point there and if
you're not forced to be on the JVM I
would go for your line a in those
situations okay well thank you for that
and I'm sure you will all join me in
thanking Tobin and Robert for a very
inspiring talk online and golang as we
have all just heard learning your line
can be done quickly and efficiently if
your organization is interested in
training you and your colleagues in our
line do let us know we will work with
you to create a tailored introductory or
an advanced level Erlang training course
that will last for one working week as
mentioned we can accommodate the minimal
class size of five students in a maximum
class size of 12 to ensure optimal
quality of the learning experience we
can of course organise concurrent
classes if you have more prospective
students wishing to take the course
again feel free to contact us on webinar
and airline - solutions of Chrome on my
own email address and we can discuss
this more specifically in relation to
your unique learning requirements many
thanks to all of you who have joined us
for this webinar please join us again
end of May for our next webinar which
will be dealing with open flow and our
work in this emerging area you will have
a chance to hear about the developments
to date and the work we have been doing
in developing our own implementation of
the open flow switch on that occasion we
will have Stewart Bailey the founder and
CTO at Infoblox
joining us to tell you about info boxes
experience in the open floor
we will also be sending you a short
survey to make sure we capture your
feedback of today's webinar please note
that the presentations that were shared
today will also be available for you to
collect on erlang solutions is corporate
website at www.att.com/biz</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>