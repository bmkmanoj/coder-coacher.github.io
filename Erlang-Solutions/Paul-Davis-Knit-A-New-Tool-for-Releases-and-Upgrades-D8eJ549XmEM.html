<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Paul Davis -  Knit: A New Tool for Releases and Upgrades | Coder Coacher - Coaching Coders</title><meta content="Paul Davis -  Knit: A New Tool for Releases and Upgrades - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Paul Davis -  Knit: A New Tool for Releases and Upgrades</b></h2><h5 class="post__date">2014-07-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/D8eJ549XmEM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello um like I said my name is Paul
Davis I'm a software engineer senior
software engineer Cloudant which
actually is now IBM and today we're
going to be talking about hot coat
loading releases upgrades the you know
production side of running an erlang
system and specifically about a tool
I've been working on to try and make the
upgrade side of this a lot more easy so
the first side hot code loading most
runners have actually used this even if
they don't know that they have when you
do see module name in a shell you're
actually not loading code into a running
running BM and most of the time when
were just you know editing code and
compiling it and running it it's not a
big deal but hopefully will show that
it's quite powerful to use the the
biggest constraints here is you're
actually limited to two versions of code
in the BM for a given module the
interesting thing is that processes
running old code are killed as soon as
the third version is loaded and the way
that you upgrade a process running code
is to call into the exports table of any
module so a quick example which is just
a small thing to Prince the version of
the module and then looped the thing
notice there is the qualified module
colon function name so when we upgrade
the code that will actually load new
code so this is just a simple shell
stressin the social process the thing to
note that we're actually upgrading code
is the i just added a prefix on the the
wiser they're being printed and it just
shows you that each time I recompile the
module its change the actual code that
is running a very simple change is if
you just take out that module colon it's
no longer qualified so it's no longer
upgrading the code as the marginal
changes so a little bit harder to read
but on the fourth
entry in the shell session there I just
wanted the process to show when I
compile in and install the new version
that it ends up being killed this is
very useful in production for instance
you know Saturday morning when things
are burning down and you want that log
message to see you know whatever is
being swallowed it's you know just a
handful of steps to actually change
production machines to actually show you
what you should have been logging a long
time ago there are a number of ways that
this can make your life more difficult
there's an L and NL for load and network
load and one of them alota in the local
vm and want to load it into every vm
that's connected the interesting thing
about never quote is if I one of the
machines reboots it will lose that and
so if you've patched something saturday
morning on a notary boots and it comes
back you'll be woken up an hour later
another interesting thing if you run an
upgrade I know that's been patched it'll
lose it so that will you know be another
wake up in a couple days there's also
the you know the question of you know
what code has been patched by some other
operator that was you know woken up on
the last shift and then the other thing
is code changes for behaviour gencer
virgin event all those things they don't
actually have their code change run when
you're doing loading at this kind of a
low level another useful thing for doing
this when you're in operations is
finding out which processes might die I
mean you can do a couple Biff that you
can use to check for which processes are
running old code which modules have a
code old code still in the vm and that's
useful during upgrades and and when
you're hot patching code just so you
kind of have an idea of where your
system is that and then you can
investigate why certain processes
haven't been upgraded and that just kind
of as into an example of the basic you
know of primitives in the vm that we use
for a little more background we talk
about releases i don't know who's
familiar with
what kind of production deployments but
you know and erling release is more or
less a tarball that contains enough
stuff kind of run you know your entire
early application application with a
capital either the interesting thing
about this there's a lot of
documentation there's a lot of man pages
and there's a lot of stuff and money's
remodeling they're very configurable and
so it kind of really depends on how your
op system is set up whether or not you
include and Erlang vm and their release
whether or not you know you include
source code all that different stuff in
your your actual releases in general
it's basically just a set of compiled
applications and it's with extra
metadata that kind of describes a
release and generally distributed as a
single file the outline of an unpacked
release is you know optionally the vm
the the lib directory is well your
compiled code goes with the app iphone
version structure and then the releases
directory is the important thing for
managing and upgrading releases the rail
version sub directories container of the
metadata is specific to a specific
continue of the data specific related to
a specific version of your application
the releases capital releases file
contains an erlang a textual earling
term describing all of the releases that
have ever been on that node or have ever
been unpacked on that note and then the
star turtle data is tells the the boot
scripts what version of the Erlang vm to
boot and then the version of the which
released version to boot and that is for
operations that's a very useful file for
shell scripts to know what's currently
on your node so that you can connect to
the right using the right versions of
all your applications when you connect
some of us that have just covered and
the one thing I skipped the releases
well version real name dot rel are very
useful for describing exactly what
release contains it gives you your
entire list of applications and their
specific versions
and then the other thing real named boot
there is a real name that script which
you can actually look at and then
they're all named up boot is basically
just a load that term to binary and
write that binary disk and that binary
version is what the vm actually uses to
boot your release so assuming that you
know you're all familiar with actually
developing rolling the way that's the
ways that you can actually generate a
release systools is kind of a very low
level library interface that you have to
spend a lot of time reading man pages to
actually understand real tools kind of
my understanding was kind of a an effort
to make it easier to use systems and try
to give a lot more support and
configuring and releases then rebar came
along and a guy named Joe Williams that
used to work for us wrote the release
interface to rebar and that's basically
kind of trying to make it easier for
people to generate these things and
relics is a semi recent come up it comes
from the Earl where group and that's
newer it kind of the shoes real tools
and kind of does everything by hand and
it has a more of a complex version
constraint on silver so for those of you
know like we have an application with
dependencies that say you know between
version X and Y and you have a set of
those and it tries to find the set of
things if I on the set of applications
and and their versions that satisfy all
the constraints and then net which I've
been working on I basically do the
further release generation is just
modeled after rebars the hope a little
bit more user-friendly and that it does
a lot of things like expanding tarpals
and generating tarpals rather than you
know requiring that you script on the
command line so once we have releases
which is a necessary step for upgrades
we can start talking about actually
doing production style cooling and an
upgrade is generally a set of
instructions it takes a
the vm running release a and turns it
into release be and that means you can
either you can upgrade you can downgrade
and it doesn't have to be linear so you
can you know you can upgrade from
version 12 version 2 and then you could
go ahead and downgrade to version 1.1
dot something for some reason you had
that issue and practice mostly you just
want to do upgrades you know if you if
you upgrade and you have a bug generally
you're just right up you know you'll fix
the bug and make another upgrade the
other thing is if an upgrade to fails to
apply the node will reboot and when you
reboot during that you just fall back
into the version you tried to upgrade
problem so most of the time the actual
situation where I've upgraded it and all
of a sudden I want to downgrade it
doesn't happen that often if you've made
it through the upgrade generally
speaking you should be good to go long
enough to write another upgrade if
there's something broken so contents of
an upgrade are very similar to a release
but it elides like the the vm and some
of the other kind of support files the
releases as a similar setup you know
you've got the raw version we all named
up boot the start up booties from
systools and then you basically just
have to copy it so that's consistent
with the way that releases are made the
other inconsistency the rel-nei male
version is actually out a directory
level which is confusing but the
important part is that rel up there
which is the actual file that describes
how to actually affect that chain from A
to B oops yeah so what is real up and
this is basically a script written in an
early in term format it's textual it's
not the binary version of the term de
binary so you can actually open it up
and read it in spectryx so if you
generate an upgrade you can unpack it
look at that and see exactly what's
going to be happening it's built by
compiling a pups which we'll talk about
and then it's the other thing is this
only using low-level instructions which
will talk about the format for this
thing is the the version that it will
get you to so if you've got you know
version 2 there there we go and then
it's a list of I can upgrade from
version
oreck and gone rave two versions using
that roll-up so a nap up very similar
they're very close to same thing except
for a nap up is just limited to a single
application I can contain these higher
level upgrade instructions systools is
the there's a systems call that's pretty
straightforward to to invoke to actually
collect those and compile them down it's
not quite a director expansion but it's
similar to kind of a macro language of
sorts I should talk about and it's got
exactly the same format as well so
digging deeper tobacco um one of the
interesting things with upgrades is you
have to worry about not only adding and
reloading but also removing code over
time there are a lot of other
instructions things like just allowing
you to execute an arbitrary function
during the middle of an upgrade in case
you need to synchronize or things like
changing supervisors will talk about
later on then there's also instructions
and newer Erlang viens to upgrade the vm
itself which gets confusing but is
possible so an example high-level
instruction is just a couple this is
there's about six versions of this
basically just remove some of the
options here but just going to those
quickly mod is obviously the module
you're going to upgrade the Mont type if
you do generally speaking it's always
going to be a dynamic of its static
there it's you basically don't get as
much support when you upgrade it there's
no code change and it just kind of
forcibly loads the the version of the
module that needs to be in the BM the
change soft is basically just is just
changing the module version advance
extra is how you get the code change
functioning your gen service run the pre
purge and post birds have to do with the
coding we're talking about there's two
versions the upgrade system allows you
to say forcefully kill everything before
I start the upgrade and optionally
forcefully kill everything after I
finish the upgrade or don't and just let
you know let them hit the vm constraint
and then the dep mods is a list of
dependencies so if you have a module
that requires a separate module to be
upgraded first and that's where you
would specify that sure yeah so that
when I said earlier that there's it's
not quite a direct macro expansion the
interesting thing here is the dep mods
when you get into the compilation of a
pops and develops the dependency amount
of the dependency modules is mostly what
it is and it generates say for the graph
of oliver dependencies and move things
together so if you have a module on
application a it depends on a module and
application being those upgrade
instructions will be moved in the same
section of the robot right which can
lead to confusing behaviors during your
upgrade then the expansion of that is
when used to spend all the processes
running the module for this in this
particular example any of your
dependencies that might have been listed
will be loaded then you load the modhri
upgrading and focus code change and then
let the process start running again this
is all handled by the cysts module and
the gen behaviors take care of all this
before I know for you some of the other
instructions to be aware of point of no
return if you ever reading a relat there
will be an instruction that is point of
no return there are only a few things
you can actually run before that and
most of those are just loading code into
the BM after that oh and I said if
there's an air during your upgrade after
that point of no return is when the vm
will reboot before that it will abort
the upgrade but generally speaking
there's not much that goes on before
that apply the MFA was you to run
arbitrary code is one of the few
instructions that you can run before
point of no return this sink nodes I
haven't actually used it yet but
theoretically it should allow you to
synchronize all of your nodes in the
upgrade process but the I think the
downside is that you have to synchronize
all of your notice in the upgrade
process that make sense then you add
remove applications obviously if you're
running an entire application you can
load in one instruction removing them
and if you want a hand going to have a
blunt hammer with you upgrade you can
just restart your application and let
supervisors restart everything you want
us to do that with the entire emulator
and then the restart you emulator it
gets complicated but basically what it
does is it and loads the new standard
lib Colonel Prem code and then set some
stem pre-release stuff reboots into the
new orlean vm version picks it up and
then I finishes the upgrade I don't have
much experience with myself but it is
there so this is basically the hard part
of upgrades is how we generate these
apps right I mean those instructions you
know you can write them by hand but
usually they're very tedious rebar has a
very straightforward algorithm for kind
of generating this it basically just
compares the beam files on disk you have
to you know expand to power balls until
to generate the upgrade between two and
we'll just do a diff basically and then
if it's a supervisor it gets a special
upgrade instruction and if it has a code
change function exported it becomes a
code change up grin when you get into
kind of more advanced things for
instance one example off the top of my
head is I had a gen server that was
running and it had an LRU implementation
that only it used and if you update them
in the wrong order then you know it
would crash so you know one of the
things that we did there was to take
rebars a pub and then going in reorder
instructions and then package everything
back up which gets to be a pain you know
if you're you know most people have a
build server running all of this so you
know you have to kind of manual
intervene
and so what I've been working on is
trying to affect these sorts of minor
tweaks to the EPS based on module
attributes so right now the the kind of
the set of attributes that we use are
just a priority to kind of give you a
rough way of saying which modules to
upgrade first within the context of an
application the extra is if you need to
pass anything to your code chain
function the dependencies timeout is not
something I've ever run into but it's
basically when you that instruction to
suspend a process they're that good time
out and so this lets you know if you for
some reason have a slow-moving James
over then there's the the pre imposed
strategies which is the purge whether or
not you kill anything forcefully before
you start and after you finish upgrading
and then the ability to call a function
at various points within the upgrade and
then that's just an example of what I
mean by module attributes if anyone's
not fair once you have all of your app
ups the next step is to create that
relic file like I said there is the
system's maker out but obviously you
know you'd want a tool to kind of in
vocal then rebar relics net any of these
could kind of equal except a rebar has a
lot of a lot more manual script steps
that you would have to end so once we
have our upgrade created the you know we
have to figure out how to actually apply
this thing and so if you you know you
you have an application running you know
you've expanded release you've started
running the tarball for the upgrade
actually goes in its releases directory
and then there's three release handler
functions so the first thing you'll do
is yell unpack it then you'll install it
and make permanent the install release
stuff between the install and their make
permits if it's important to note that
if the node reboots anywhere in there it
goes back to the version where you
started so that's what I'm saying like
if you install the release and you think
it's not working you can just kill the
note and it'll come back up in the old
version right
so unpacking the release doesn't do a
whole lot it's basically just kind of
saying okay this is a valid release
effects it's kind of interesting by
default releases or upgrades three
upgrade tybelus will include all of the
application code so if you you know like
currently it has a copy of kernel and it
has a copy of XML and whatever you've
added then when it and it just expands
it over top but it does the the keyboard
pile thing from tar so it only adds new
code and then it updates that releases
that it's got that on disk and it's been
unpacked install release is the the one
where you cross your fingers as an
operator but the basic idea is that it
will upgrade kind of the information
about each application that's going to
upgrade to its going to apply that rel
up script and then it's going to notify
each application of the environment
changes from the new app named app files
that you've loaded or the system config
files and it runs the optionally if
you're I don't know how to describe this
in English in your app named app pile
there's a mod specification for when
you're starting your applications if you
export and that module a config change
you'll get a notification and you're up
doing and then it marks the release as
installed in memory so this is saying it
doesn't it doesn't actually make it
permanent so it's kind of a it allows
you to see what's going to happen when
your upgrade it without kind of
permanently adding a bug that you know
you didn't senior up grin and so i
should say when we generally speaking
when we install an upgrade will let it
sit for anywhere from 10 minutes to in
couple hours depending on what we've
upgraded you know depending on how
depending on the side of the upgrade if
you've added you know a new application
something you might want to look at its
runtime performance you want to be able
to you know is just going to behave on
this particular cluster so it's very
useful and then make permanent is
usually pretty quick little update that
start oral data
the release is to say that it's
permanent and then one is your thing i
found out that is actually updates the
boot and config command line arguments
so that way if it up if you do in it
reboot it will actually boot quickly so
some more specifics on unmet so my
github account it's very alpha at this
point but my whole entire goal with this
because it might in my experience there
aren't a lot of people that either use
releases or if they do use releases they
don't use upgrades and so I'd really
like to try and make it easy for people
to generate upgrades and test them
because I think they're pretty awesome
and like I say my goal is to you know
just typing net should get you most of
the way there you know if you need to
tweak things and you have to read the
readme and whatnot but the the use of
rel tools rotos is interesting but it's
kind of a it has a knob for everything
under the Sun and most people I think it
is just at least do a lot of confusion
and I think you know if we just had a
system where it was just you know here's
what it released looks like it would be
a lot simpler I talked about release or
sorry upgrade terrible uh you know
include duplicate code if I know I'm
going to upgrade from these three
versions and they all have this version
of a nap there shouldn't be any reason
to included so just for when you're
distributing you know turbos to your
infrastructure that that would som down
a network usage and then another thing
so rebar does not do this relics does
this they when you create a release it
will install things like a set of been
scripts to actually start your
application and so does all the Shelf
who it does all of you do you know the
correct path and vm plagues to get your
things kind of installed knit does this
the other thing though is you know if
i'm focusing and creating upgrades is a
tooling to do those really st. more
function calls from the clan line so
that way if you know we you know give
software to operators we don't have to
require them to learn
how to run those you know those Erling
commands from the show Joan all right
this next section is basically kind of
just a few examples of the way things
break during upgrades to try and keep in
mind the first is a fairly obvious dump
thing but if your process is sitting
somewhere stuck and receive you'll never
be able to get it to you know the next
point where it calls a fully-qualified
function so another upgrade so one of
the ways that you know you can do this
is just set a time out and have it loop
through one of my bigger issues and
production environments is sharing
records is very bad outside of a single
module when you have a you know when you
have a cluster running and you have
these records in memory somewhere it's
very surprising how long they can live
in memory and so after you've done
upgrades and then all of a sudden you
started getting bad matches and you know
bad records exceptions and so we've got
a gun through a lot of effort trying to
remove public record definitions from
all of our code that one is n it's yeah
that one so yeah I'm sorry um and we
just do that by just making a private
room module and having better access or
functions to each record and like say
it's it breaks up great soft enough that
I'm trying to make them just private two
modules never have them in an actual
header file oh so your message isn't
either anytime we're doing our PC type
calls like those messages can live if
you have a if you have a sloe-gin server
that has a large mailbox I've been
surprised a number of times on messages
reappearing after an upgrade and the
ordering of code loading like I was
talking about with the the gin server
with the utility module behind it
it's interesting that the the way that
the relics are defined it's the ordering
is not defined and what it is
deterministic and so you can run
upgrades that work for a while and then
like the fifth upgrade all of a sudden
two modules will change and then you'll
realize that you had a dependency there
that you didn't know about and the other
big one after modules is anonymous
functions or the double anytime you have
an anonymous function living past the
scope of the function where it was
defined is a recipe for disaster they
just don't know the interesting thing to
me is you don't have to be executing
them you don't be looping through in a
known as function for it to break your
upgrade as I understand it it's
basically just a pointer into a module
file into an actual binary file so just
referencing an anonymous function anyone
you're a code that that process is
marked as having old code and that is I
spent many hours removing references to
anonymous functions the the API say the
APS that I generally go for either just
an NFA or fun because you can use a
fully qualified function there but then
with some state in case you need rather
than I should be more specific usually
when i see anonymous functions its
they're capturing scope they're using
the closure to kind of instead of
passing the state specific you know
explicitly so it's caused a lot of
broken upgrades one of the other big
things supervision tree changes are
fairly difficult for upgrades you have
to be very careful in specific on them
and this is one of the things is you
know your supervisor child
specifications come from a function so
there's no static analysis of these are
you know the children that I used to
have in these actually I need to have
and then being able to automatically
kill some of the children and load the
new ones so that that NIT apply is
hopefully you know allow us to at least
make that a little bit easier I'd really
like to figure out a better way to do
this
but I don't see your way through the
dynamic specification of the challenge
of the John specs but luckily in an
actual use we don't do it that often
it's just that when it does happen it's
have a pain another one the release
hinder the retailer of the process is a
registered process we actually have a
bit of code that a lot of clients tasks
you know what version of code are you
running I've actually had that screw
with releases because it's a heavyweight
operation and so that that will run slow
and as it's trying to do the upgrade
it's not terrible it's just you know as
you're doing an upgrade and you sit
there for five minutes like is this
running or is it you know there's
something in the upgrade stuff the other
one I don't know how many people do you
know RPC calls but this is one of our
more heavyweight upgrades this actually
takes about four so you'll do an upgrade
to add code on all of your notes I do an
upgrade to start calling it and then
you'll do an upgrade to when you add the
code yeah at a second module then you
basically go back that is I'm not
entirely certain if there's something in
it that we need to kind of do for this
or if that's just kind of a pattern that
we need to look at more closely let's
see any questions
oh how do you solve the NL the problem
like you said if use NL your load beam
on a lot of notes but if you restart
them they would fall back to the old
version great how do you success problem
oh well you upgrade is the the best way
that's one of the things is that I'm
focused on when I have free time is
trying to make these so much easier to
generate and then ship to actual nose
and do that the if you're in a pinch um
just I just actually p to the entire
cluster and that way when they do it
they'll pick up you know the version
that's on disk but I mean that's the
uniform part is basically then and I'll
it just puts it in a ramp it doesn't
actually right into just but if you do
that by hand then you can do so but yeah
the real I mean if I had more time as we
all say i would just dictate that we
wouldn't do it in production if you ever
wanted to do that you would use an
upgrade but you know it saved our butts
a number of times so thanks
hi is this is knit supposed to replace
relics and Reba sitting is knit supposed
to replace relics and Reba just the two
commands just to generate release just
the generate Pat bubs but ya know I all
of this recording you know I rely on
rebar to compile and everything like
that and it's you know whether or not i
donate this back to rebar and whatnot or
relics or one of them that's fine it's
just you know right now trying to play
with these things and get a better idea
on how to dis because this originally
started this originally started as an
idea to try and write those scripts by
hand with you know some way I could
never found syntax so until I think I
have something that I've used for a
while I don't want to burden another
project with a PR that might be
pointless yeah
what kind of system are you using this
for right now and you find that it's
really like actually worth it to you to
do these live upgrades rather than
actually shut shutting down nodes and
bringing back up again with a new verse
oh so that's that's a good question so
the the system we're using is a
distributed version of couchdb so it's
the distributed database dynamo style
distribution the the bigger question
though is why not do rolling reboots
instead of upgrades the i mean the the
brutally honest answer is that decision
was made before i got there and so
they've been doing upgrades for a long
time and it's kind of been to our
detriment a little bit because because
all the upgrades we do our Erling
upgrades are focus on actually booting a
node has not been completely there and
so some of our larger clusters you'll
get stampeding herd effects because you
know as that note comes up in all this
when it looks like it's available to
take RPC request you know you can have
100 cup on your notes you know nailing
that node and so it's easier and on a
lot of circumstances to not take them
down that said there are a number of
times where upgrades can be very
difficult and you know it's you spend
more time thinking about how to write
the upgrade rather than the 5 line patch
that you know you just wrote and just
being able to just do a rolling up it
will be useful so it's I think that's i
would say that both are useful and in
most of the cases that I you know that
we do upgrades I think are very nice
because you're not taking down machines
but it's important that your notes can
come back very quickly which we're not
very good at sir
ooh speaking of which one of the comment
on that heart is actually a very good
example of them are not hire a PMD is a
good example of a stampeding herd on
that one of our large clusters we have
so many people when that note goes down
it's obviously an hour notice when Lee
comes up it starts EPMD which is the
December deepen yoga so when it when
that no goes down EPMD is still there
and then all the other nodes in the
cluster start trying to find that node
and then you basically will exhaust your
ports on again hour before EPMD off
mother talked my head but that's another
example of one you don't want to know to
go down is because I stampeding herd on
EPMD itself yeah right actually I'm not
subject we have problems where we just
cause EPMD to stop the erlang no it's in
our startup scripts so what was going to
ask was how often using upgrades do you
find the sort of time bomb effect where
you've made a mistake and upgrade but
not realized your upgrade was a mistake
so you end up with a node that works
after the upgrade but doesn't boot if
you restarted well i don't think i've
ever heard that I don't think I've ever
had a node refuse to boot after an
upgrade so if you if you patch the
supervision tree for instance you can
you can have accidentally relied on a
new process that requires to be started
before analysis um and then when you
restart and out of course the process
isn't there but it was there when you
really nice to it I happen to you like
that but yeah I mean I could definitely
see how you were getting that position
and it's yeah i mean i could see that
but i haven't haven't seen her
personally but yeah there would be some
yelling
and I just so that in the last slides
you presented some kind of rules that an
application needs to confirm in order
that it could be upgraded in life is it
a good idea to write some kind of post
compiling something code and analysis in
traversing the app sex industry in order
to emit some warnings that maybe that
code won't be upgraded is it possible or
you say anything there's a possible to
warn that something might be hard to
upgrade yeah you can be some kind of
code analyzer to UM it's hard to say I
mean you're saying and if I have this
right you're saying can I if I make a
patch is there some sort of static
analysis that would make it kind of a
maybe um I would say it's not impossible
but it seems like it seems like having
one of the like the the seven things for
performing sterling it's something like
you know what kind of a best practices
or in examples of things are hard would
be more productive kissers it's it can
be very surprising what things are hard
to what things are not so yeah I don't
know yeah at least a good topic to
research yeah yeah so thank you very
much and we will have the next
presentation five minutes later
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>