<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Implementing languages on the Erlang VM: Robert Virding | Coder Coacher - Coaching Coders</title><meta content="Implementing languages on the Erlang VM: Robert Virding - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Implementing languages on the Erlang VM: Robert Virding</b></h2><h5 class="post__date">2012-06-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hry_BUidOAk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay thank you can you hear me at the
back ah yeah okay great so yes I'm
talking this will be a bit about
implementing languages on the vm I like
implementing languages okay so this is
my favorite topic and so a bit well I go
through generally is a bit about what
languages very little some of the basic
tools that exist in the standard a line
distribution okay there are a lot of
other tools you can find on the net but
these just under standard ones and then
I'll do show three case studies i have
done of different languages with
different requirements so there will be
different results i implemented and also
there will be some techniques that you
might enjoy while working so from my
point of view what languages anything in
your online application that's written
in another language one so they can be
config file so you can have
domain-specific languages you can like
I've done here implement other languages
do other front-ends for a line if you
don't like the existing hour in front
end you can rewrite your own right lots
of other things like this so my my
examples are from well that mode mainly
from the other languages bit and there
exists a number of basic tools in the
standard distribution which you can use
just to get you going so for example
there's leak leaks which is a lexical
scanner generator there's yet a parser
generator there are a bunch of syntax
tools for managing our line code alling
abstract code very XML passes there's
one in the system XML and of course one
of the most important one you can play
with is the compiler itself right the
compiler is not a black box it's not
just of a black box you put a file in
one end and get a file out the other you
can actually go in and do things with
that
by them so to start off leaks well it's
a lexical scanner generator and it's
based on Lex and flex so what it does is
it uses regular expressions to define
tokens so you can define your tokens in
leaks you can use it to generate code
which will then tokenize your input and
return a sequence of tokens so it's this
thing of collecting characters together
into tokens right it generates by
default three scanning functions to use
there's one for direct use which you can
just meant to just call directly you
have a string I recall my scanner string
and it will just return a list of tokens
from that stream or an error if it
bombed out there are also two functions
which are you which are meant to be used
with the i/o system now the i/o system
is a pretty neat thing but you have to
know how it works and how to interface
it and leaks generates two functions
which do that you can use them yourself
I'm not going to exactly describe the
interface though it's in the
documentation where you can use itself
but they're intended for the scanner
generator so what does the leak file
leaks file look like so here we have a
very simple example of a leaks file it's
a dot a generally called a dot x over
Delta X RL file containing information
so at the beginning week under the
definitions heading I can define a
number of macros so here I've defined
three macros you for uppercase letters l
for lower case letters and d 4 digits
and we're using regular expressions here
so I I can't don't have time to teach
you regular expressions but we do using
regular expressions and it's the general
standard POSIX regular expressions not
the pearl runs they are differently
unfortunately they have different
semantics and the Pearl regulations
wouldn't work in this context so for
example the upper case says the
you macro here says it's a letter well
it's a character between a and Z capital
aliens at the lower cases it's a letter
between a little aliens ed and these are
digit which is a little character
between 0 and nine so that's that's what
that regular expression construct means
and using that i can define tokens so
for example the first one here is the
airline adam token young unquoted adam
token so we can see when we wrap the
macro in curly brackets which did that
says take that macro and we can see that
that means it starts with a lowercase
letter and then it consists of either an
uppercase letter or a lowercase letter
or a digit or an underscore and the star
at the end means is zero zero or more of
them so this is our simple definition of
an atom so here we've defined what an
atom is and when it when it finds an
atom here we have an expression saying
what is supposed to return so it's going
to return a topic which call the tokens
which is going to tell the leaks that
this is a token and then here we have
the actual value of the token so we're
turning an atom this is actually what's
returned from the standard a link
possible or a leg scan it by the way we
got token we have some predefined
variables token line here and token cars
and token lines the line which a token
occurred on and token cars is a list of
all the characters if found in that
token so in this case I just take the
list I make an atom and I return the top
will Adam the line and the actual atom
itself I'm wrapping in a token saying
it's a token I can do the same thing for
variables so variable starts with an
uppercase letter or an underscore and it
contains uppercase lowercase letters
digits or underscore zero one of them
zero or more of them when I get one I
will turn a token this will be the VAR
token on this line and that's the actual
value of the token
or i can define a comment which starts
with a percent and contains any number
of characters which aren't the newline
character and it returns skip token say
i don't want this one just throw it away
if I want to return my comment token I
can of course do that what I decided to
do was up to me and yeah so if i run
this through leaks it will generate a
file so i thought this example put it in
my my scan dot X 0 it will run through
leaks and I'll get a file my scandal
which I don't can compile and I can use
and it will just do this which is not
really very helpful but it will work
yeah this format of tokens we've got
some point token class here the line is
on and the actual value that is quite
commonly used and it's actually what yes
the next tool we're going to look at
expects for its input formats so if I
use this and generate another format
which is perfectly free to do I can do
anything with it I won't go to pipe it
into yech which is also very nice so
after I run this through I will get my
file out i'll have my my scan dot well i
can compile it and then i can call the
three functions in it so the direct
usage one is string and I call that with
a list of characters a start line and it
will return ok a list of tokens and the
end line so it keeps counter lines in
this every time it gets a new line will
bump increment the line number and
things like this and keep track of them
and if you've got a token which spans
over multiple lines you'll get back the
line number of the first line to token
to curdle so this so i can use this
directly to get back just list of tokens
if there's an error it'll return the
toppled error what the error was and
ending line number again if I've written
my scanner and I want to put it in the
i/o system for example user directly
against the file there is no direct call
to do that in
system right that's one of the things
missing the i/o system it's been missing
since since the ayah system was written
and just never got added right but it's
easy so I can do an i/o request here
into my i/o device to my file or
whatever it might be what it might be or
TCP characters or whatever it might be
and I the request is a get until the
second one here is a prompt seeing a
similar marine against the file here I
don't have a prompt it's this module
calling this function with these
arguments so if I've written my scan and
myself or any handwritten I can still
use it in the files in the i/o system
calling it this way I don't intend to go
through the i/o system if anyone wants
no more ask me afterwards do I the i/o
system is really neat right it's
extremely dynamic you can basically do I
owe any i/o to it towards anything right
you need to do it the right way so this
yep you've got these two functions token
and tokens tokens obvious it gets back
the next token line in the i/o system so
you can do token token token token token
get one at a time tokens that scans
returns you all the tokens up until the
end of file whatever that might exactly
mean or until it gets back one of these
things where it says in token so if
we're talking our line here dot is a
typical end token because we said so if
we do tokens on doing our line will get
back all the tokens up to and including
the dot if we don't have an end token
will get all the tokens up to up to
including the end of the file so it's
just a nice little hack written in there
which fits our lang and a few other
languages as well
is that so this allows us to scan it
it's simple it's it can't do everything
Lexor flex can do but it can do quite a
lot unfortunately yet it can't detect
beginning of line and end of line it's
almost there and I do have a patch which
will actually give you the cut the
column the clear token start on if you
want that as well too I just have to fix
up all the tests and stuff like that to
poor they put in the system it
works so there's leaks right so it's the
first step in passing our language we
now even get tokens and there is a
built-in parser generator yech it's an
lalr 1 parser generator it goes from
left to right it builds it from right to
left and it's 11 token look at it's
based on yak it's a similar idea to the
ack to standard yeah parser generator
and it generates parsing functions as
well but only generate one join its
function pars which you pipe in a but
list of tokens and will turn what you're
told to return very simple so we've got
a y X example here here's a very small
yak file which will pass simple
arithmetic expressions so we say the
non-terminals that's the thing in the
middle here which expressions terminals
is in session teaser term and f is a
functor here also the terminals these
are what i get in from the outside so i
give it a list of tokens and these
tokens will be the type plus star left
right bracket and the number ok so i
define an expression expression is an
expression plus a term or expression
minus a term or it's just the term
itself and where terms the term x
functor or term / a functor or just and
the functor is just a number or an
expression with parentheses around it
and doing it this way I get the left to
right the left priority and the right
priorities of the operators so I can
generate this and I say the root symbol
where I want to start you know bung this
into yech into yrl file it will generate
an old file which I then compile them
i'll get the function pass I haven't
said it but in both showing it but both
leaks and yet you can put our line code
in there as well so if you want a big
example of a yekke file going to look in
the standard distribution because there
is the definition of the a link that the
a-line syntax one dot y alpha it's quite
a lot so that's nice so now I with this
I can it quite easily passed my my coat
my input lalr 1 parser they manage quite
a large set of languages but not
everything and there are a few problems
you run into when you write write your
description you'll typically get things
like shift reduce errors and they're not
actually errors but depends how you look
at them that means that it looks at York
your sauce your grammar and it counts in
some cases it can't decide do i click
more characters which is all more tokens
which is shifting or I do try to do
something with what I've got which is
reducing and by default it will click
more and that is generally what you want
to do so I think in the a-line syntax or
two or five shift reduce errors there
that that's not that's nothing critical
that's not uncommon that's nice but
what's worse you can get reduced reduce
errors and that's typically the thing
the parser generator is looking at your
grammar and it says when I get here I
cannot determine what I'm going to do I
cannot take one token decide if I'm
going this way or I'm going that way I
give up I generating excuse me I
generate an error and the typical case
is if you've got our line for example
when I define an expression i would like
to write in something like this i mean
it's very simplified i would like to say
it's a pattern followed by an equal sign
followed by an expression that's why
that's how it
I'd like to do the pattern matching the
assignment there but I can't because the
pattern is so close to the expression
that yet can't decide which to go it can
I cannot just say by doing one step look
head say I'm now doing a pattern or I'm
now doing an expression if you think
about the pattern it's a subset of the
expression so yet cannot decide it says
I give up I give a reduce reduce error
and they not good because I can't go on
until I solve that and a typical in this
case I write it like this i say an
expression there's an expression
followed by an equals followed by an
expression that case it's happy right
because then it can work out it's just
expressions and his confession followed
by an equals I can do that and it comes
another expression it can do that so it
works but that means I'm going to the
grammar is going to allow things which I
don't intend there so i can write a
function call equals a function call
which is not allowed in the grammar not
allowed on the a like syntax so I have
to put somewhere later long line we
actually have to check the left-hand
side here and see if it actually is an
expression so that's that's what's done
in the a-line syntax you have this exact
problem and it's checked in the next
pars part 1 fun the first passes the
compiler call the lint which checks that
that will find those errors that is
something a problem when you have one
with just one character look at
yeah so that's leaks and yet and they're
nice because they give you a big stir
give you an easy start and for example
look at the airline's in taxes in the
distribution in the standard live SRC
directory it's big you wouldn't really
want to write that by hand definitely
not there are the tools bro syntax tools
these are tools for working creating and
working with the owling abstract syntax
I'm not going to go through those I
think Richards doing that after after
the break talking a bit about that so
I'm not going to do that and there are
other parsing systems that aren't part
of the island distribution there are a
number of PEG passes and just another
type of grammar so I'm not going to talk
about those is either so now we've got
our stuff in we're parsing it we've
passed that we've quite an abstract
syntax now we want to do something with
it right and one way of doing something
with it is compiling it and we've got
the a-line compiler which compiles down
to the beam code which is very nice so
we can do things for that and it as I
said it's not a black box it is quite
open your can for example work on both
either files or alling abstract code and
it can generate beam files or it can
generate binaries so you can take
something in abstract Pastore directly
in memory compile it into a binary and
still in memory and then you can do
things with it send it to other nodes or
load it down or install it in the system
so if you're generating our line code
say from your syntax you never have to
generate dr. L file to the compiler you
never even have to generate a beam file
to get into your system you can do
everything in memory compiler struggle
but it also has a internal level call or
internal language called core core a
line which is a very nice intermediate
language airline frauds beauty is not
quite simple and regular it's not that
bad but it's not quite simple and
regular core is it's a simple regular
functional language and it I think
anyway it's much easier to compile to
than doing darling that means nothing
stopping you doing telling we're going
to core is easier and internally the
outline kanpai look something like this
so there are at least five passes in the
a-line compiler this is just generating
beam right so we're getting our laying
in from the left here and first we're
doing some pre expands which basically
just looks well before we've got this
stage we've done the macro expansion
this is an umber are done the macro
expansion even before this here we've
actually done the parsing and we've done
any pals transforms we want to do then
we're going to pre expand phase which
looks at mainly at records and expands
records and removes all the record stuff
and does a bit of adding a bit of
information about the system and then we
go into Pascall v3 core v3 means of the
version 3 there's no greater
significance than that it was a version
to an aversion one but they've gone now
and that generates quarreling okay so
after after the airline's gone through
that after it's gone through V call v3
core we've got core element as the
quarreling pass here and for core our
line there a nice bunch of optimizations
so most the optimization work in the
compiler works on the core level so if
you're compiling things don't compile
the beam assembler code because then you
have to do everything yourself free
you've got nice things down here and
then it goes to kernel which does other
things like pattern matching
optimizations it lambda lifts all the
local functions and does other things
the life looks at the variables looks at
the life lifetime's the variables to
work those out and then the code
generates the beat the beam code so core
it's a nice simple functional language
and to be different from our lang it
does have sort of more normal lexical
scoping which is actually easier to
compile too it's easier to work with and
but it is just the basic language right
so there are no records in there
there are things like this
comprehensions they've all been compiled
out in the v3 core level so it's just
functions just raw basic simple
functions but it does have patterns so
it does do pattern matching of this
level so you can put patterns in which
is a great win because one of the things
afterwards is a pattern matching
compiler which is quite optimal in
handling patterns although semantically
our line does close close close close
close when its pattern matching
internally the compiler is quite a
little work to get rid of the claws
claws claws and do it much more
efficiently it looks like it's doing it
but it's not internally and that's
something you want and as I said most
optimizations are done on core and
another feature is that dialyzer speak
score so if you if you're if you
generate quarreling then you can put
your code in and get it into the
dialyzer and have dialyzer check your
code together with any other code right
in the system I'm slight prodding here
too costas and in the dialyzer group to
open up the front end slightly so make
it easier to load in files of other
types but if it's big score dialyzer can
work with it except patches yeah well
one of these days one of these days yes
I know Oh specs okay yeah right you'll
get one you'll get one you'll get one
but then I can do it then LFE can run
run dialyzer together with everything
else and everyone including me will be
happy so yes okay so here's a very
simple example of corralling the syntax
is rather the boasts there is actually a
core core pretty printer and there's
actually a core parser as well too so
you could actually write quarreling
directly if you wanted to verse say the
syntax is not not compact will put this
way so I've got my standard factorial up
here fact when n is greater than 0 n x
factor x back n minus 1 in fact 00 right
and it generates a function here fact
one and it's a fun and the argument
score and then we do a case here
to look at the other to do pattern
matching on the arguments so one of the
things that happens is all patent
matchings broken out into a case
internally and if it's in and we got the
guard here then we do this create a
temperate local variable here and then
we apply faq one to this variable and we
left that in and then we set that
variable to that and then we return that
value there so the compiler breaks all
down all explicitly handles all nested
expressions and breaks them down the
flattens everything up amongst other
things that the reason they are linked
and pilot does it amongst other reasons
is that it enforces the left to right
evaluation of a line of course actual
not define which order you take things
into airports a thing to remember if
you're doing this yourself is to try and
do exactly the same thing because most
of the optimizations assume this
structure so if you don't do it then you
don't get some of the optimizations
fortunately you don't you won't do
anything wrong but just wanted optimize
it so you can see it's a very simple one
and for example it's a simple language
this is most of it actually you can
define local functions there's a let rec
for defining local functions and things
like this as well seeing its using case
for everything here it adds on an extra
case Claus at the bottom here which
which says what error it is if none of
the arguments match so in this case we
see it's a function Clause error if this
was actually an internal real case an
Allen case it would be generator a case
closer so we using case for everything
like we even use case reefs then we get
the degenerate case here where there's
no expression and no map no matching
here just the wet just the guards run
which is exactly why we need to put in
if and originally to get rid of that
syntax but it's in here anyway but it
means that it's quite easy to generate
this and there is a definition about
there this is all record base so their
records their the record definitions in
the compiler and there's also a module
called see
oil to allow you to build these things
through function calls instead so it's
perfectly feasible to do this there is
also a paper from when did you write
that paper which Richard wrote a paper
describing core that's long as long ago
but very little has changed since then I
hit one change between are 12 and are 13
13 that's valuable so yeah if you're
going to compile stuff compile to call
that's great I find it much easier than
compiling to Ali I find definitely you
you can for example compiled config
files if or do just compile them down to
our line code and run them I think a few
applications already do that I think
it's yours and maki web do that or
something like this so it's really nice
ok so they're just some tools and do it
it's nice yeah ok so the first example
is this play with LA and it's something
I did a while back and still working
we're still running and there are no
known bugs in it so if you want to use
it well there's one actually is one if
you're doing nested query list
comprehensions it will not handle that
properly if you're doing simple queries
comprehension that works for not nested
ones or fix one of these days ok why do
I do this I like Lisp simple and I don't
while I don't have anything against the
ailing syntax duh I love lists and this
provides a lot of nice goodies you can
do it's really it's a real home iconic
language and it's got real macros right
owling macros just for a simple token
substitution list macros you can do a
lot of stuff in the macro level that's
very nice so that's that's one reason
for doing the lisp syntax at all another
goal I had or was that it would
seamlessly interact with a vanilla
airline OTP so you could write your you
could write your LFE files that worked
directly together with OTP
so if you want to write a behavior
callback module for Jen server behaviour
OTP behaviour you could write that Nell
a fee and everything would work so it to
be nothing strange going between LLC and
our line you can freely mix them yeah so
you could do that I wanted to make it
easy to implement I wanted a small core
Lang small core language and most the
other things built on top using macros
right and I wanted to go as fast as
vanilla Ali ok I I didn't if you chose
to write your module in LFE or chose to
right now in our line the speed wouldn't
be the reason for choosing one or the
other so yeah that meant a few problems
it meant I had to modify the late had to
modify a lisp because most of the
standard lisps would not fit directly on
to the a lengthy beam in such a way that
it seamless interact with the choir so
for example no mutable data they could
only use the standard our line data
types you have atoms numbers lists
tuples that's about it right you can
binaries of course but you cannot do any
other sort of user-defined data types it
also meant that if they have records
they had to look like airline records so
I could not define Lisp type records or
slips types trucks in there because they
just have no a line corresponding a long
datatype it also meant for example that
I need modules I could not do packages
for example I couldn't have a common
list namespace package package name
spaces because that just just does not
map into our line you can hack it but
then the interface is not going to work
properly it also meant you wanted our
line functions typically our line
functions so for example you could not
have functions with variable number of
arguments which mostly give you because
our long does not support variable
number of ligands not if you want to do
it fast anyway
so you get these limitations but again i
get i get the benefit i can have
multiplied kind of functions with the
same same name and different number of
arguments and different functions so
it's very close mapping it also means
Mac unfortunately macros only compile
time because in a real Lisp the Lisp
internals know if a function is a
function or or if it's a macro and now
Lang doesn't so I cannot have a macro
that works at runtime because there's no
way to say what this is and that's
important not for what it does but for
how it's used so enlist if when the
system knows it to macro and I call a
macro it knows I'm going to return an
expression and evaluate that expression
once again automatically for me right
and the ailing system will not do that
in the compiler I can do it so macros at
compile time and they really work it
means i've read i wrote a sport I rotor
and LFE evaluated to run at an MP and
looking at some of the macros people
written I am overwhelmed but they
actually work trying much more than my
simple tests and but it works and it's
lisp to which felissa people means that
variable name space and function
namespace are different in list one
they're the same in Lisp to their
different schemes typically least one
because they're the function name the
variable names the same same space
Common Lisp is to listen to and i found
my opinion anyway list to better suited
fitting together without how our link
functions work our line functions are
sort of neither right there sort of Lisp
2 plus but this too was closer I know
other people have done list ones instead
and it means it is as fast darling which
is not surprising because it just
generates normal a line code through the
compiler through core and everything
like this so it does compile down two
quarreling and what I've got here these
are the actual core expressions in a
fee and if you remove the ones with red
over them they're the actual core
expressions in quarreling so it was very
easy to make it make choose a mapping
there which was practically 121 I added
an if because i wanted i didn't want to
use normal hour long if they're so i
added added alyssa bitch type if there
and I can't do this was a bit a pity yes
i can define the curse i can define
local functions but there the recursive
local function so the namespace they
work in is recursive i cannot define
them not to be recursively defined local
functions so how to fix that myself
which is really strange it's not it's
not a big fix but just not their match
laminas and lambdas were always so they
sort of both exist right depending on
how you look at it maybe I should put
the red line over lambda instead because
in our lang the match lambda still
always have pattern matching so that
depends but it works it's fine and did
everything I wanted to but the
limitation is I change the language to
fit into the a line system and accepted
those limitations at those limitations
and those features while forgot to
mention it I had a very very nice
feature of our patterns so of course
pattern matching is part of it part of
the language ones I've got them it's
waste not to use them so there you
restrict the language to fit the
implementation or fit the underlying
system and as I say worse the next
language I'm going to talk a bit about
is a call or log finding a good name for
these things actually worse than
implementing
so if you think the language the names
are corny to I quite agree but I could
not think of anything better next one
was actually worse but yeah we'll see so
yeah I did along her log and it's a
standard prologue of course had to do a
prologue seeing where Ellen came from
had to do a product so this is a problem
do and in this case the semantics of
course are completely different Welling
there's no there's no nothing here about
trying to map the outlets into semantics
over that they're just extremely
different so just accept the fact so for
example prologue gets backtracking so if
you can make a choice if it later
decides this was a bad choice and go
back and make another choice it has
logical variables so I can fill in holes
I can pass them around I can fill them
in later bandit has unification which we
don't have amongst other things so here
the problem was I want these features i
do not want to change the language so i
have to put the hat or get these
features into alley and data structures
were quite easy which is not surprising
again seeing where ellen came from so
we've got our log atoms are our lang
atoms illustration there the love
numbers are a line numbers lists and
lists Earl or prologue structures like
this one here they map very nicely on
two tuples there is no problem doing
that so that so the datatype mapping is
very simple in this case except for one
thing for logical variables there exists
nothing in our line which looks like one
behaves like a logical variable okay
syntactically look the same thing the
behavior is completely different so
there are global in a sense and they are
mutable in a sense they're not freely
mutable now can change them but it but I
can take this variable and I can give it
a value and if I give that variable
value everyone else who sees that
variable will get that value as well so
its global immutable I can unify I can
unify them which I can't do with our
lank variables so i can say x equals y
now neither might have a value but i
know that in the future if one of them
gets a value they'll both get the value
because they unified
work together this is something else and
changes in this case is seen everywhere
so I might unifies 10 variables together
and one of them gets a value and
suddenly all of them see that value
let's have to do this type of thing and
there was no corresponding Alan data
structure which matches but we could be
cunning we could use a couple here of
one element which did not match anything
here because here they had to be in
Prolog there has to be at least one
argument one element inside here which
meant the top will here's at least two
elements so we can use a top of one
element for the variable so we can use
that an index but seeing these are
global we have to keep them in a global
table I cannot just pass them around to
bind them as they go because out then
then the variable bindings won't go so
we have to keep those in a global atem
table or a global variable table which
can either be a dick to rate depending
anyone do it and this is quite nice in
one sense because one feature prologue
has is that when you're backtracking
variable bindings get unbound so when I
backtrack back if I backtrack over a
variable binding the variable gets
unbound so next time I took control get
another value and keeping them in a
global table adicto array here and
keeping these tables in the stack when I
unwind I just automatically throw away
the latest versions and get get the old
version back again and everything's fine
so actually is made it quite simple to
do some things but also meant that when
you're building these things when you in
this case was just interpreter it could
be a compiler I just never got around to
it you have to carry around some state
amongst containing amongst other things
the atom table or sorry the variable
table other things you have to contain
is the database as well prologue has a
database I have mentioned herein slide
but has a database and that is dynamic
and it's also global you need to carry
that around with you as well I found a
dict actually work better the Nets
tables I tried both
the way prologue accesses that table
when you add and remove things from it
it actually worked easier with addictive
if you wanted to use that yet it become
much more cunning to do things to make
sure it's just the way the logical
database the logical database is defined
right so if I'm if I'm backtracking if
I'm working with something and something
someone else changed under me in some
cases i don't i'm not supposed to see
those changes until later so if i bang
that straight into a net stable you can
get difficult so there again kept an
addictive work what worked well okay
backtracking so this our leg was an
interpreter which does all this I'm not
going to show code examples of backtrack
of this because it's it's pretty hairy
coat working on the prologue semantics
it's quite straightforward in one sense
but if you know what you do if you know
if you know what it's doing it's quite
straightforward for this one but our
long does not have backtracking which is
a shame right incense so as we see as we
know once we make a choice we have to
stick with it so if you've got a
function you've got a function
definition you call a function once
you've chosen function clause that's the
one you've got same thing with a case
when if you cannot go back and try again
afterwards yeah so it's a it's
unfortunate and sometimes it's a nice
feature sometimes you'd like to do that
we'd like to try something go forward
and see if it works if it doesn't work
go back and try again it's not easy it's
not difficult but we have to do it but
we have to do it ourselves so this is
just an interesting i think an
interesting feature so we can do
backtracking ourselves here we will use
continuations through this so every
level will say when i call a function i
will pass now given say when you're done
call this function just keep on going so
we always keep going forwards forwards
forwards forwards so at a top level here
we've got some succeed fun here which
returns succeed in a value and when we
call find solution we've got our data we
putting in and we pass it to succeed
what did
so it knows that fine solution knows
when it's done what it's supposed to do
it will call the next time so here we
have an example which is not doing
backtracking it's get a here it's got
data it's got the next it does some
stuff locally just a normal airline call
here we're not going to backtrack over
this one the nice thing about here we
can choose what to backtrack over we
don't have to backtrack over everything
and our next is taking this next and
doing some more stuff there and passing
that on so we're passing the next that
came in to us on and doing some more
stuff before so we're changing that
through the whole time and here we do
our more stuff here with our data and
the next after that so now we know that
more stuff a here when it's done it's
going to call this one which will then
call that one which will then call what
came in here so if building this or
whether they were going down with
building this chain of functions so we
never never really from the backtracking
point of your not returning so if you
want to backtrack what do we do then
well we set up a choice point so we do
some stuff here and here is a choice
point which is a list of funds to do all
right so we'll do this then we will do
one of these and what that means is
we'll try the first one if that succeeds
we're done if that fails further on then
we'll try the next one if that foot well
it's it does it sequentially yeah yeah
yes I do that okay yes I don't do that
assume the cuts okay other otherwise it
gets very otherwise it gets very messy
right we only want one solution this
says actually I can handle multiple
solutions it can do that right there's a
problem i'll mention that talk about it
the choice point function is very simple
it's so simple it's disgusting right so
we take the first first goal the first
fun we call that and we've defined to
say that if we succeed we return the top
of succeed in the value so if we succeed
we just return that value and keep in
pass it off to the next level if it
fails then we return fail and we call
ourselves recursively to get the next
element next goal on the list so we try
each goal if they turn succeed we just
pass it on back upwards here if we turn
fire and if we run out we just returned
file the problem here the problem with
this is that they're a couple of
problems here is that when we hit the
end we sort of we sort of Coco Coco call
and walk out at the bottom here we've
got this big stack of stuff here and how
do I keep track of things where I get
there right if I want to do the final I
get all these solutions I can get one
solution I have to put it somewhere then
I can fail and get another solution and
put it somewhere that's the problem with
this implementation I can put it in the
process dictionary I can store it
somewhere else or do something we have
to put it somewhere to keep it if I want
multiple solutions then I can be fined
or it's not
yeah that's the next problem I'm not
going to take that up because that'll
take about ten moments right I'm not to
talk about that well no this actually
worked um the Justice one of the
features of prologue the prologue syntax
is that the grammar is definitely not
lalr 1 it's actually a backtracking
grammar so in the worst case you can
look at the very first token or not and
decide is that is that a operator or not
an operator and I cannot tell until I
get to the end whether it was right so
you get through strange cases and this
is how i wrote the prologue puzzle using
this data networks it works because of
the data I do in this case I don't need
variables prologue variables you can fix
it they don't need polar goggles
prologue variables put another layer on
this you have to pass around some
variable structure which you chain
through in the same way in buying
variables in there I've done it but you
can do it it's busy but it works this
gives you not backtracking anyway so I
can choose I like third one I know I
know the third one which I'm working on
now is I call the world there was no
other good name Aloha was already taken
and I think someone else had already got
lure Earl Earl lower was already taken
by someone else so I couldn't find a
better one and this is a goal to
implement standard lower standard 5.2
Miller and lure if those haven't looked
at it it's a small scripting language
it's designed to be a scripting language
designed to connect it to other systems
do things typically used in the gaming
gaming world and it's a simple rather
simple to the language is quite neat
it's imperative so it's definitely
imperative all the way down it's a
dynamic language things can come and go
and you'll dynamically search if you
want to call a function will actually go
and search for the function definition
in a predefined way so they can change
things it's lexically scoped
and it has mutable variables it has
mutual environments and got mutable data
so we're doing something extremely on it
alling a hero it's a small language with
only a small number of data types so
it's quite an ill which they use for no
value or false or a lot of other things
as well right seeing there's so few
things here they tend to use everything
for everything wrong so so Neil means a
lot of things they've got bullion's to
and false they've got numbers which are
just floating points and they've got
strings which are pretty much like
binaries and they've got tables which
are mutable key value tables and they
use tables for everything losing four
tables use and for raises and for lists
it's the kitchen sink every anything
they've put in a table and the thing
where the table is its global so if you
make a change to a table anyone elses
referring to that table will see that
change it's a global data type its
global data and it's mutable global data
and that means you have to manage global
data there is just no way around at
least with the Urlacher was very
restricted and was hidden behind the
back here it's very explicit and the
only way to do that is you need a global
date table store you need somewhere you
need to keep a global store of tables so
everyone refers to it so for example you
can use a Nordex you can use an array or
you can use a net stable for its tables
didn't work very well with a naive
implementation I'll show you an example
later why it has mutable environments so
the environments they also behave like
tables so you use use or dicks they work
very well because they're generally
quite small I've got my tables and
internally in the table they do as I
said to do funny things with them so
they're using numeric keys keys from one
to three upwards they treat them as an
array and they treat everything else
separately so I'm working now with the
structure where a table it consists of
an array for those and a Nordic for the
rest
that seems to work very well so this is
basically what my global data my global
state looks like here so it contains
tables here here is a table store here
is well here's the next free table
number i'm using just using indexing
into the numbers and well this is a list
of free tables so if i had a table i
freed it goes back in here and here's
the next number if I there's nothing
left in the free list this matter
certain data types have metadata so
here's putting in which are tables so
here's the various meditate meta
technical types that metadata for
various types here's the current
environment which is a stack of
environments which are tables and here's
just a unique tag so i can do catch and
throw and make sure i'm not doing catch
catching something else right which I
want so yeah that works fine so just a
really quick code example undone so this
function this is the function which when
I get a table I have a key get the value
for that key in the table this is this
is this is the code for it so it's get
table key and the first argument is the
table here which in this case it's a
reference to a table I cannot put the
table I have to put a reference to the
table for the tables global and here is
the key and here is my state and I have
to check seeing I'm handling numbers
specifically I have to check if it's a
number and then I check your fat
floating point is actually an integer
value is it 1.0 2.0 etc and if it is i
call the integer keys otherwise i call
with the normal the key keys of the find
a better name if it's not a new value i
just call the key keys and if it's
something else I go in and check does
this thing have a method method table
but meta table method so if it does even
if it has a meta table with that object
and there's the key which is called
underscore underscore index I go in and
find it if there isn't one then it's a
legal index if it is one I use that and
use that to try and find the value
so it's it's very staged step step step
step step and we see it exactly the same
thing when I'm actually referencing a
table so if you've got the normal key
here I separate the table there's a meta
table so each table has a meta table and
there's a table itself which is the
value I try to find it in the value if I
find it I'll just return it with the
state which in this case hasn't changed
if it's not there then I try and find a
meta method for it within that table so
keep stepping down if you can't find it
you're going to try and find a better
method for it and you actually keep
going round round round round until you
find the actual value at the end and
with the integer ones I extract the
array part and I do exactly the same
thing there if I can't find and get the
meta method almost done getting the
method method is looking up the method
method meta method of underscore
underscore index so if there's a meta
table there it will try and find the the
the underscore our index value of that
and use that and if it's a if it's
not there we just return nil because we
couldn't find it if it's there and it's
a function it then calls that function
and users in returns return value if
it's not a function it's something else
then we called it get table key
recursively on that with the same thing
so we if it's a table we can actually
step around table we get look at the
tables meta table and then the meta
tables met a table and keep on going and
you can't actually put put them in a
loop as well too and we'll crash so if
you want to enjoy yourself that said
that that's that networks that's it that
describes very well exactly house based
these things are just macro so I could
test different table implementations
doing this does not work very well with
a net stable because when you read in
the table in this case you're reading in
the whole table and that could be
hundreds of elements big which is very
inefficient doing it it's because you're
writing backwards awards and it's maybe
if you were to combine these two
operations into one perhaps you could
have as a bag or something like this and
match out of it and get get it going
better so it's that the final slide if i
want to set my something like this this
is this the function for setting a key
here so i get the table I've got the
table here i am trying to find the key
if I find the key don't ask me why they
do that like this exactly right I don't
know I'm trying to trying to work out
why did if I find the key I just replace
the value okay if I don't find the key
then I try and see if there's a matter
index there's a matter this is a meta
table with a key underscore underscore
new index and if there's that then I use
that to store the value if there isn't
then I just put a straight back into the
table and I replace the table fix up the
tables in my in my estate and return and
return the state right so this is a type
of thing you have to do if you want to
carry clip if you want to work with
global statement you have to carry it
around with you all the time it is not
very blindingly fast at the moment I
will grab that but it does that does
work and attached does actually be most
of the language I haven't got used I
haven't got meta tables for user data
yet but we'll get them final question
well one thing I would say is is this
useful can you use it I mean is it
something i could actually plug into a
system and use it and i definitely think
you can write other languages on top of
the ailing vm and use them some cases
you can get them very fast some cases
you won't and it just very much depends
on what you're doing so in the for
example in the oil case if you have some
lower code and you will need to run it
but it's not very much and you don't
want the troubles of cat packaging up a
lower system and including that in your
release never them and interfacing that
then you can use something like this if
you're running a lot of lower code it
depends on what type of code you're
running if you're running lots of small
functions then this is probably quite as
fast almost as fast because I don't have
to copy data from
out to the lower system I can run this
directly in our if you're running big
functions doing a lot of computations
then this is definitely not an option so
it depends very much yeah so just some
some things on implementing languages
and how the choice of language and it
features the language affect the
implementation watching get out of it
unfortunately there is no way around the
immutable data in the system and I hope
they don't change that sorry okay that's
it questions yeah grab me afterwards if
you want yeah yes I have and I've done
it well in something it depends bit on
the text sometimes you can see for
example your unwinding the call stack
and then you can see there you can free
those you can free tables sometimes that
is not good so yes I have a small I have
a garbage collector which will run
through and free to remove tables from
the table store and then let the Allen
garbage collector collect them like it
seems a bit off I would actually i would
need that actually in the ER log system
as well for the variables so I could
keep now I have to a backtracking style
to do that if I had had a garbage
collector they are can do it forwards
going style the whole time okay that's
that okay much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>