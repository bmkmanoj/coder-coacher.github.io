<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Meta-Programming with Elixir - Yurii Rashkovskii | Coder Coacher - Coaching Coders</title><meta content="Meta-Programming with Elixir - Yurii Rashkovskii - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Meta-Programming with Elixir - Yurii Rashkovskii</b></h2><h5 class="post__date">2013-10-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/a3eJoM5FFiQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody so my name is Yuri and I
gonna talk about meta program and Erlang
with Aleks here so how many of you are
actually familiar with Aleks ears ideas
at all or you just heard about it
somewhere and you decided to come over
to the talk so just few of you uh-huh
well it's the one question of the basic
guy if you familiar with it it looks
here at all
okay something all right okay so how
many of you didn't know we shake it a
little bit more okay so basically this
is the quote that he set somewhere and I
stole it from somebody else yeah
basically least traditionally really the
Empowered developers because you can
eliminate anything that is tedious
through macros and that is the power
that really is what people keep going
back for so what is meta programming in
a very practical sense my understanding
of it it's it's a program that writes
program it's as simple as that
so some practical examples of that would
include domain-specific languages so you
can build a language that specifically
addresses the domain that you're working
in and can be very specific about those
details and you don't spend too much
time in underlying language trying to
express express more complex paradigms
another one would be embedded databases
so for example mime types Unicode and
any other kind of protocol descriptions
or formal descriptions that you can
embed in your code and use it right from
the compiled file another one could be
conditional compilation so if there is
any ability in the language to compile
your stuff differently compared to
dependent on some parameters even Erling
you can do that with say if dev so if
something is defined during compile time
it will compile one version of the code
otherwise it will compel the the other
version of the code
so that is a code that writes : anyway
generating a code that dispatches things
like requests for example there was
actually a very good example of that
done by Joe civilian but but the author
of Alex here you can generate a very
efficient code if you know all the
routes that you have for your requests
you can produce tons of tons of code
that will very efficiently dispatch your
your routes and pre-compiled templates
so you have a say for an HTML template
with all the logic inside of it and
instead of interpreting it every time
you need to render it you compile it to
your program and it executes as a real
program instead during runtime so here
is the unicode database example
Python actually does that kind of
made-up programming where they generate
C code from Python and this is just a
tiny tiny part of that implementation so
they take the Unicode database and
produce tons of C code that is an
efficient implementation of Unicode so
they can do lookups and the Unicode
databases this way and here's again a
small part of Unicode database in LX
here but it's about probably 25% of the
whole implementation that we have in LX
here all it does basically eat it
invests all the Griffons all the code
points and other data from the unicode
data bases in LX your code but unlike in
pythons it doesn't generate a code by
writing strings it actually generates
code from it from within itself during
the compilation process but anyway let's
make it easier and start from the very
beginning so here's a very simple code
in Aleks here so any takes how this will
work
what does it does this code do anybody
so here's the output so when you try to
compile it it will actually print out
the for the
during compilation time and here you can
see it's what you had in the in on the
module level and when you execute hello
world well you will get the hello to the
world outputs that we defined in that
function called world so basically that
means you can actually have code that is
executed at compile time while you're
compiling your program so how does it
actually work so the main difference
here is that unlike in Erlang every
everything in Aleks here is an
expression so in Erlang for example you
would have a model a module definition
for so you have attributes like module
export and then you have a syntax to
define functions with say a world
function and any other function but in
that syntax you cannot insert any other
erling code at the module level it's
just not possible the parser will not
work that or the compiler will not work
that way
so yeah you can't really do that it is
though technically possible but you'll
be really sorry for trying to do that
because the parts transfer monsters will
really come and get you and I know these
because I actually wrote a bunch of
libraries in Erlang that we're using
parsed transform techniques to enable
some interesting things but that is the
most horrible experience I had
manipulating my own code so with this
technique is that enough actually to
have another language just to enable
this technique probably not otherwise we
could have just wrote a library or a
tool for Erling that would take another
form of Erlang sources and just evaluate
them and run those compile time
operations that will probably be just
enough but what elixir is really great
about it actually has
macrosystem how many of you are familiar
with any kind of list say Common Lisp
closure anything like that okay about a
half I guess so a macro basically is a
function that will generate code instead
of being executed in runtime so it's a
function that executes compile time and
you get that function to produce an
actual syntax tree that will be injected
into that piece of code where you call
that macro from and for those who are
familiar with Lisp they will find
themselves almost at home with quote
unquote and unquote splicing techniques
so here is a very simple example even
though Alyx ear has its own
implementation of the unless construct
here we're just using it as a good
example so what we have is this
structure can you see this I hope so so
it says if not available do something
and end it and it looks like a regular
construct but now what we can do we can
say def macro unless and take two
arguments one will be condition and one
will be the rest basically and here we
say within this quotes we basically
transform this to if not and here we're
inserting the condition as an actual
source tree instead of the evaluation
and here we're inserting all the options
that are the same as in the eve
construct so this way we can actually
have an unless construct that looks
indistinguishably from the if constructs
so we just extend the language was
something that looks very natural it's
not different from anything else and
this is actually how we implement unless
macro is just a little more complex in
the actual library but it looks the very
same way anything else does so what does
enable this
so one of the important things in
networks you're unlike knurling is that
all HD nodes so abstract syntax tree
nodes are actually very uniform there
are always topless of three so the first
one will be a name the second one will
be in meta information about that part
of the tree so usually that would be a
line number and maybe some other
arguments depending on some details and
arguments let me give you some examples
so here is a one plus one expression it
actually gets compiled into it you can
actually think about it as plus function
and two arguments one and one here is a
little bit more complex example so it's
the HD representation of erling zyo
formats
hello and here you can see it actually
consists of two tuples of three so that
would be the first one it has a name of
dot and then it says IO format so it
basic connects the module name and the
function name then we again have made
our information and then we have the
argument you I have format itself being
just right down there and it's easy to
explore how those trees actually look if
you start IX which is Alexi shell you
can just do quote do one plus one and
you'll see the actual our way it's
represented internally so you can
actually play with it whenever you don't
really know how it will look like you
can actually just test it very quickly
so why don't we need them again because
they eliminate anything that is tedious
great but know what Alex series not just
macros for airline it actually turned
out to be a great jar of other goodies
so one of them are so let me actually
list them first and then I'll explain a
little bit more about every feature in
detail so we have protocols it's a way
to define interfaces to different
limitations we have a more uniform
thought-out standard library can
comparing to earnings we have a what we
call the first class shell that is able
to do a lot of a lot more things than
Erlang shell we support Unicode in a
much better way so we actually support
Grif teams up keys donkeys correct
lengths everything that is related to
that and obviously more and at the same
time it's still the very same Erlang so
you don't actually have any penalty for
calling from LX ear to ear length or
from Erlang to Alex here it's the very
same thing it's just the front end that
you have to the language is a little bit
different so here's a highlight about
protocol so consider you have a JSON
parser written by somebody else and they
just support a couple of types a string
literals integers floats and they just
wrote a module that matches on the type
of of well you pass into the system and
they just produce a result but what if
you have your own type normally that
would be tupple with it with the tag
that defines your own type how would you
extend this JSON encoder
in this case to actually support your
type so there are a couple ways to do
this you can pre-process your data
structures before passing them over to
the encoder but that actually means you
have to pass your through your structure
twice
yeah so the first time you pass to
convert your data structure to something
this encoder understands and then you
pass it over to encoder obviously it's
slower you allocate more memory that's
just not nice the other one you can fort
that library and make a private copy of
that library and extend it by basically
writing your own additional clause for
the encode function which is not a great
idea if you expect ever expect to
integrate new developments in that
library back into your project so what
does it lecture do protocols allow you
to define that interface so here you can
see a JSON and holder interface that has
a function called encode that just takes
a piece of data and it's actually a
module that
generated out of this and here we have
just two implementations of it they're
using the Deaf in pole macro and they
implemented four strings and integers in
this case just a minute keep it simple
so for every keys it defines the way to
process that piece of data and what JSON
encode or module does whenever it
receives some piece of data it
dispatches it to a correct module based
on the type of that piece of data that
you pass state so if you decided that
you actually wants to support your own
own data type that normally will be a
record in Aleks here which is again
pretty much the very same thing as in
Erlang so it's it it's a tuple with the
tag you can add your own implementation
and then the JSON library can actually
automatically start supporting your data
type without you doing any extra work
besides implement in this implementation
of the protocol any questions so far
good I mean you can override the default
encoder basically whatever is the module
that is loaded for that specific type
that's the that's the implementation
that's gonna be used because it actually
just looks like your type it constructs
a module name for that type so this case
it will be JSON encoder dot string the
full name of the module so if you're
overloaded with your own implementation
that's what's it's gonna use because
it's dispatched by name make sense
another one standard libraries so
obviously a lot of people complain about
Erlang library because it actually had
to vote for about what twenty years not
a little bit more than twenty years
obviously has a little of crust and
inconsistencies and basically we were in
the best position to address this
problem from our own perspective but
creating our own standard library
and I will just highlight a few things
like enumeration API dict
and few others so what's interesting
about a numeration API if you have a
collection type of your own it could be
just about anything if you can implement
a very simple function that actually
reduces through your collection and it
reduce is the same thing as fold all in
in Erlang so you define something that
just goes through every element and
calls a function with an element an
accumulator the whole module of a noun
is available to your data type so you
can map you can filter you can do just
about anything with any kind of
collection that you have an
implementation for in this specific case
the file iterator function here so it
looks its EGC password file what it
returns in this case it actually returns
a function and that function just calls
the standard reducer so what this means
is that this another filter function it
just dispatches to the enumerable
protocol and there is an implementation
for functions for the innumerable
protocol and it's able to apply this
function to to the collection of lines
and in EGC password files so here you
can see that I'm filtering out comments
out of EGC password and you can see a
result there it actually prints actual
user names and all the whole line with
the with the password record the other
one show so what we can do we can define
module so we can explore type specs and
we can explore the commutation without
ever leaving shell here are some
examples so here we are asking for all
types defined in the inner module and
you can see a T type that is defined
through a iterator at session hold slide
it's now enumerable elements and index
so there
to find there and then you can ask for
in this case specifications for all
variations of the sort function so the
first one we'll just sort an enumerable
type and the other one will be doing the
same thing but with with the function
past it so a function that defines the
order for your collection so you can do
that from from the shell
as opposed to standard airline where you
pretty much have to go back to the
source code to find the actual
specification of the function that
you're you're exploring and you can do
the same thing with this function by
using H helper the H helper will produce
the commutation the reason why it's
actually possible in LX here is that
every function that has a documentation
it actually gets that the commutation
embedded into the beam file so it's not
just in an HTML or any kind of other
file sitting on the file system its
issue right in your module and you can
request this very easily and here's the
example that so h and i map france the
documentation for for that function
another highlight unicode so I was
showing a little bit of an example in
the beginning of this talk basically
it's it's a really interesting keys
because it's a little bit over not on
it's actually a little bit over 200
lines of code but I actually generates a
file that is 250 or 60 kilobytes in size
so what it does it reads the unicode
data and named sequence databases and
just creates tons of tons of clauses
that will match every possible scenario
and that creates a very fast
implementation that has no bottlenecks
because it doesn't use any concurrency
primitives it's just an embedded
database so the status of yesterday 0 92
was released and the community is
growing the amount of contributions has
really exploded over the last month or
so we have two books coming out this
year
they're already in beta I think you can
actually buy them even now in eBook
format and I think the actual books are
slated for the release when we'll have
1.0 so they're coming out soon and
that's pretty much it and I'll take
questions any questions
is it possible to define functions in
the shell yeah you can right now the way
it works the shell is not an implicit
module by itself but you can define a
module and a function so we can actually
go here so let's see
def module M and I would define a
function and then I will just call it so
you can create the whole module without
leaving shell and trying to compile a
file like you would do in our own shell
costura macro expand the facility in the
shell as well yeah there's one it's not
recursive so there's macro expand so we
can read documentation that is pretty
big so the macro expand unfortunately
it's not recursive but it probably will
be at some point but so you can start
actually expanding your macros and see
what do they transform to okay cool cool
yes Alex here seems nice to to make a
shorter syntax to have some vertical
tricks in the shell does it bring new
functionalities it is not directly ready
to use in ever how would you define
additional functionality something that
is really much much faster to do in the
next year compared to era
faster as in programmers productivity or
yeah of course like here's an example
that a lot of people like so in we can
actually even do an hour lunch show for
that as well yes so when you actually
have to combine a lot of functions for
example you want to process some data
typing pass it through different
functions you will often write something
as
simple example like F of G of H of I and
then some data right so this way you can
actually have to control where do you
close your brackets you know whether you
have the right number of arguments and
everything so it actually is very hard
to read because you have to read from
the center so you have to find the
center and go left and still be able to
process arguments so what we have to
solve this problem is a string a Surya
it's a pipeline operator so for example
I can do something like this so I can
have a value on the left and a function
on the right and basically what it does
it passes the value on the left as a
first argument of the function on the
right and I can do things like this I
can extend this contract and say strain
length so you can actually see the whole
pipeline of operation that that you're
going through and this way you don't
really have to endure all the complexity
of reading this kind of code so here you
can really have the whole pipe it's more
of a syntax feature the other X X ox
well it is a pipe right so it's been
called pipeline operator so so yeah this
thing the other things we have a pretty
good file module that allows you to do a
little bit more than earlier so you can
do RM RF you know and all this kind of
stuff so it's actually just ready to be
used without writing additional
functions comparing to the standard
library the UNAM module again is it's
it's a really great example of an
addition to productivity so for example
I was able to write implementations for
and numerals for ETS details tables so
that you can actually work with your
tables in a lazy way but processing for
example with maps filters ami all so you
can actually apply that to any
collection data structure and that is
very very productive in my in my opinion
and protocols I think it's one of the
greatest things there because it
actually allows you to swap out
different implementations rather quickly
and I guess there's a lot of things that
I don't remember off the top of my head
but some people find them useful
so you mean the hash dick tour was yeah
yeah well you can create a new
dictionary for example with some values
and you just use the dick protocol
it doesn't actually care what's inside
it could be a hutch dick it might be
your own implementation and then you
would do something like this it's quite
possible to do that and actually yeah I
think it's a great example that hash tag
is actually faster than other early
implementations of dictionaries and
what's even more important about it is
all the implementations of dictionaries
in knurling they have different API so
whenever you need to change from one
dictionary format to the other one it's
really painful because the APIs are
different and it's really easy to make a
mistake while converting from one data
type to another one and the beauty of
hash dict itself is that it's actually
adaptive to the size of your of your
dictionary so whenever it grows it
actually converts what's inside to a
different more appropriate format no it
does not have include files i've i
personally think they're quite evil but
it does have inter module dependencies
so the compel the compiler can actually
stop and wait until the other file is
compiled so you can require other other
module to be present before proceeding
further with the completion of the
module that you're compiling right now
so the way it works we have a parallel
compiler so it just starts multiple
workers for a bunch of modules and then
whenever there's a dependency it just
waits for another one to to finish the
other the compilation of the other
module and it just does that but there's
no include and i don't think it's you
know anywhere in the pipeline to be
implemented because it only creates
problems
are there any restrictions in the
airline VM which you are restricted by
today I mean Alexia can probably move
very fast paced but the VM won't how
does that affect language and your
future roadmap I think it's a nice
blocker in a way so it doesn't get us
really crazy about things so we still
have to you have have to sort of work
work around that and if we just were
able to change the VM you know at our
wish we'll probably would change a lot
of things and I'd later regret those
decisions so that's sort of a limiting
factor you know the experience factor
that is really great for us with that in
mind we're we started to open up the
conversation with the OTP team you know
how can we we contribute to two OTP you
know we're you know suggestions or ideas
or even patches how to make it even
better VM so it's gonna be a slower
process than then it will have been if
it was say a fork of beam and then what
would just do something with it
but I think it's a great thing because
this way we can throw ideas and patches
and get the best out of this integrated
into the inter beam I think it's a it's
it's only great for everybody is it's
the only you know the only changes that
I think will be integrated back into
beam are those that benefit both Alex
here in our lab which is a great outcome
for everybody any more questions
do you have any examples of features
that were just early in the history that
seemed like a good idea at the time and
then you rolled back on mmm yeah there
were a couple of actually a lot of ideas
like that especially in the very early
ages of Alex year when I wasn't part of
the core team they basically let me give
an example so we have what we call an
access protocol it allows you to use
things like this so you can define and
this is basically just a prop list it's
just a syntax trigger for a prop list it
allows you to do things like this so you
can action for two key that keyword
lists how we call it by using square
brackets or if we use some record like
we have a file stat record so we can say
I think first of all the mode
hundreds so you can see we can use that
it's the same thing it's actually
implemented through protocols but
originally this was also available to
lists so you could have done something
like this now it's just not gonna work
and basically they were using that a lot
but then it was decided it's bad idea
there are probably a few more that I
just don't remember right now but I
definitely remembered that even in the
past year we have dropped a lot of ideas
and at this in time we took in many
ideas from different languages that did
show that they're really great like very
recently about a month ago or so or two
maybe we added duck tests just like in
Python and now actually the whole the
whole distribution has every example in
the documentation tested automatically
every time you build Alex here so things
like that you know they go into the
language and whatever proves to be a
subpar idea they get eventually get
thrown out we're still pre pre 1.0 which
does allow us to deprecate stuff quickly
we usually have two releases kind of
cycles so in one release but deprecated
something in the neck
one we just throw it away and it's I'm
not even talking about major issue
releases I'm talking differences between
zero point nine zero and zero point nine
one so that would be a deprecation cycle
and then in 0.92 that will be just
thrown out so it's a very first cycle
which we still have you know an
opportunity to use before we go 1.0
anybody else question yes there is a in
Emacs mode IV mode
sublime text mate I think that's about
it can you build sir can you bring it in
to you existing Lang builds and work
alongside so you might have someone
working on a nail file and so basically
you're saying for example if you have an
early project yeah I'm just thinking how
to adopt it if you brought it into a
team or would you have to go from bring
the to bring into an existing building
yeah
actually though there was a change that
we made about a year ago it allows you
to use elixir as a as a rebar dependency
then you only need to add one more line
that will add elixir libraries into the
path so you know the compiler can
actually see them and this way you can
actually use the whole Alex your
standard library from Erlang for example
I think the most common case would be a
string library so that you have access
to the Unicode functionality that we
have the other one will be in um library
and I think it's a good example as well
and maybe few more for example we have
your your eye parsing
and has dict actually it is another
great example if you just want to use
this really great implementation you can
actually just integrate it into you know
into your project and use it and I wrote
a library called X Earl some time ago
what allows you to do instead of writing
the longer Alex your module name because
in erling they all look like Alex your
dot something so it would be Alex your
hashtag Alex your string and you
actually have to put them in quotes
because they contain dots so that's
rather inconvenient so that that X oral
library what allows you to do it allows
you to generate a parts transform module
from a very simple DSL I think I should
show this there's a simple example that
so that's Earl so here's an example so
you will write something like this it's
a really short code I hope you can see
this so it defines in Ehrlich module and
says it transforms any call to module
called some module to this Alex your
style module name and then it will
generate this transform module that you
just include in your
Erling module and then you can call this
as if it was just a regular Erlang code
so it doesn't look Alex Irish at all
well you know after the compilation you
actually have the Alex your module name
in there but for programming convenience
you can just use that and nobody even
needs to know how it's actually called
on the ellicsr side anything else
oh you mean from from LX here right
basically what we have we have
implementations for Gen server for
supervisor gen event just haven't had
time for jet and FSM but basically you
would just say use gen server behavior
for example and what it does really it
just defines all the standard
boilerplate for you you know behind the
scene and this way you can only
overwrite those functions that you
actually use so for example if you don't
write any handle casts or handle infos
why would it just write them it's yes
you just define handle call and you're
done basically standard boilerplate
should be generated automatically it
only makes sense and the same actually
the thing that I like even more is the
implementation of the supervisor module
so I can never like after I actually
started using
erling in about 2001 and to this day I
cannot remember the order of arguments
in child specifications it just it's
impossible I just always copy paste them
or use macros provided by rebar
templates but that that module that we
have it allows you to basically use
keyword lists so something like you
would say just module by module function
my function so there are action name
keywords so you can use those to define
your children specifications and you can
actually understand what's going on and
you don't need to consult with the
documentation just to remember what was
the freaking formula for that so yeah I
think that's a for me it's even better
than the gen server part anything else
so yeah we have a little bit of partial
application so what you can do is things
like this so you can take an up map and
let's say we have one two three here in
the list so instead of writing something
like X plus one and you can actually
just write something like this so it's
not the full-blown thing but it allows
you to do very simple definitions of
function this is actually under another
discussion cycle now so there we're
trying to work out even a better format
for this is there's a lot of problems
when you try to make something more
complex with multiple arguments and
multiple functions that you use in the
very same call like if you'll do one and
two and three you probably will compile
to something that you do not intend it
to be if there are explanations so that
and with that in mind it is considered
that it's not very intuitive that's why
we're trying to improve on that but it's
just an ongoing discussion they may not
list so I don't know about the outcome
yet but that's pretty much it I mean
this is the probably the closest we get
to partial application as you know
obviously with the early VM we cannot go
into more complex stuff when you can
specify a function with just two
arguments you you have to create a
closure for that basic right just like
in our line so where it's you know
coming back to the question how are we
limited by they being VM that's probably
one of those cases where we are limited
to the very same technique of creating
new closure to do a partial that the
real partial application of the function
nothing else yes I guess we're done
thank you very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>