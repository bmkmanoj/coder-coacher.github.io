<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Writing Beautiful Code - Garrett Smith | Coder Coacher - Coaching Coders</title><meta content="Writing Beautiful Code - Garrett Smith - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Writing Beautiful Code - Garrett Smith</b></h2><h5 class="post__date">2013-04-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IdJwECjylB4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">next up we have Garrett Smith from
cloudBees you might also know him from
his open-source eetu project or the
MongoDB as web-scale video thank you Bob
so so these conferences work this way
there's a call for proposals I sent it
out and you fill it in and you submit it
they look at it and they approve it or
they don't approve it and if you get
accepted you're like oh I'm going to
this conference I'm going to speak and
then you forget about it completely
months down the road you're like I've
got to go to this conference so you
booked your flight in your hotel and
then you check the website to see what
you proposed months earlier and
apparently this is what I get so thank
you very much for coming I got a vote of
confidence just before I came in from my
friend Loic who's like I have absolutely
no interest in this topic but I'm
interested to see if you can pull it off
so here we go yeah I mean I'll be I'll
be very honest with you I think this is
more of a reflection of a pathology that
I have and than anything else for some
reason I am extremely interested in the
general topic of code craftsmanship and
it may just be sort of like a insecurity
I have with myself I have to like you
know it's something that I make has to
be perfect and i'ma obsess over every
little detail and of course then I want
to make other people obsess over that
and it's just that it's not functional
so so I thought about you know what so
I'm gonna talk about code beauty is a
metaphysical aesthetic to to folks going
to an airline conference where there's
beautiful running Erling on neutrino or
you know running uh embedding or laying
in a super computing cluster and all
sorts of really interesting technical
topics so now I have the challenge of
talking about something completely
non-technical more process-oriented at
best but you know as of this horrible
tendency to devolve into like personal
opinions and you know I like the shade
of green better than the shade of blue
and so how do I make the specific how do
I make this even valuable to an audience
sophisticated is that
so thankfully just by pure fortune a
thread came up on the Erlang discussion
list just a few weeks ago and joram
strong god bless his soul
gave me my outline here it is so the
topic was do I use K statements or or or
functions and of course being mr.
opinionated you know yours perked up
when this topic came on typing and
typing and typing this long diatribe
about what you know I think is right and
Jo fortunately weighed in with you know
his you know meaningful slice and it was
right on the money and it really
actually helped me to understand why
this is an important topic
this is his point of view so let me walk
you through this these are essentially
accumulative or additive steps so I
summarized it so that it would fit on
the slide but it's basically this and
this and this and this
etc so let me walk you through it it
starts with code that appears to work
and that as practitioners is sort of
what we all do that's like 99% of our
work we want the stupid thing to work
that is great you get the thing to work
you're pretty much done if you observe
it working with their eyeballs that's
pretty good if you get you know working
within a repple that's pretty good if
you can get it to like replicate in
tests that's even better
so you're basically observing it working
as expected so it appears to work so
that's what we do so joe says look
that's great it's easy to do that in
fact it's actually probably not that
easy it can be challenging well let's
assume it's easy to get it correct is
far more difficult so correct that's his
term I'm not exactly sure what correct
is we can debate what correct is I'm
gonna probably spin that a little bit
down the road to something a bit more
specific but we'll just say it's gone
from apparently working to now it is
correct that's really hard now we're
gonna go to correct so it's a good
program it's it looks like it's good and
it is a good program too now it can be
easily understood by other people so
somebody else comes by and takes a look
at it and says
I get it right so now we've expanded
past the mechanical operation a software
into the realm of collaboration there's
being social animals and we're sharing
and it's like okay we now there's just
not just me but other people understand
this and acknowledge this is good and
correct to be able to change that is
even further more difficult even
increasingly difficult so it's like I
understand it but then to be able to
modify it sensibly as a result of
finding a bug or adding a feature that
is even more difficult and then finally
the very very difficult to get all of
this plus make it efficient is off the
charts hard so I think he's not the
efficient in there because efficient
tends to kind of sneak up toward the
toward the top of the food chain and I
think by listing it this way he's
implying that at least from his point of
view and I would tend to agree with this
that energy should with sort of no other
information no other given requirements
of performance requirements moving from
the mechanical operation of software
into the realm of collaboration and
change and evolution is a very very
important part of software development
so with that I want to take actual
Erlang code and sort of apply it to this
model we say it works great fine what
now and Kent Beck fortunately as well
not more than I think four days ago
tweeted this now I don't know if these
are his actual words or if he's quoting
somebody cuz they were in quotes and
they're kind of messy and it took me a
while to figure out what he was talking
about and they're in two separate tweets
but let me tell you what he's talking
about
they're also swamped in order for some
reason so he says it doesn't eat if it
doesn't even work it's no time for
scruples right so don't talk don't talk
to me about correctness or you know
modify ability or grok ability or
efficiency if the thing doesn't work to
begin with those are the scruples those
are the higher aspiring goals that we
have is software engineers suppose
scruples if it doesn't work it doesn't
matter right those scruples now it works
now it's time for scruples so this is
kind of the basis of what I'm going to
talk about
there's a thread of aspiring to be
excellent software developers there's
also a practical element that says our
software engineers as programmers our
job is just to get it to work you know
adding all these other features on top
of that is is beneficial it can be
incredibly beneficial but it's a
progression it doesn't have to be
either/or it's not a religious thing
where you're either terrible evil you
know damned soul or a heavenly angelic
soul who is writing beautiful code so
it's not one of these dichotomies it's
much more of a gradation all right so
you've probably have in your courses run
into the Whopper some code that either
you've written or someone else has
written that is just absolutely
fantastically awesome so this is just
one third of it that's the other part
and I said that's one function so we
have one function that spans now this is
Airlink so you're all laughing but this
isn't very this is very common in
Sealand or you know it's many imperative
languages so this actually isn't all
that long for a single function but in
Erlang land it's pretty it's pretty
extraordinary you actually have to look
pretty hard I didn't do an exhaustive
search across they're very interesting
to do a study across the github to see
what the statistics are probably
somebody's done that but I will tell you
and I do name names in this talk I'm not
afraid of that I tell you why I name
names I'd I'm not afraid to name names
because I've written this stuff before
you've probably written this stuff
before and frankly it doesn't matter
there's no shame in writing this kind of
function this comes from CouchDB if you
want examples of really really horrible
Erlang code CouchDB I'm all going on the
record saying this CouchDB is second
only only to core Erlang core Erling is
by far the most horrific it's so easy to
find terrible code in OTP source and but
that's sort of the point it's like this
code has worked wonderfully for years
and no one gives it a second thought
right and so here's some you know
jackass coming by and saying you've
written terrible code that's absolutely
not
there are things that we can do better
there are things that we can can can
craft and hop and hone and we'll take a
look at the specifics of that but really
again at the end of the day just get the
thing to work so my theory is this
though
so we'll talk about scruples so Kent
Beck talks about scruples as kind of as
scruples as if it's a cost so it's an
advance so you have something it works
now I'm going to spend the energy to
have scruples but what if we could have
at work and have all the goodness for
basically the same price it's the same
cost so in other words to do the right
thing if you have if you have an option
of a the terrible code or be decent code
or C awesome code and it really doesn't
cost you much more to do see why not
just you see all the time so I think
really so the benefit of that obviously
is more than it works it's when I come
back to it I understand it so it's you
know I can understand it it will
anticipate if it's quote-unquote correct
code you will probably have fewer or no
bugs and if others can contribute to it
you now have extend your ability to
mutate and evolve a software it to meet
other needs so really it's a huge lever
so I think this is not just a matter of
aesthetics or opinion or feel good pride
of work of craftsmanship it is all that
but it's practical as well okay so
that's the Whopper and what I did is I
looked at the Whopper and I said you
know what are sort of the some of the
the you know elements here that we might
want to think about possibly changing
and so it kind of breaks down like this
so in this talk we will cover I hope to
get through most of this without boring
everybody to tears function names
argument variables function scoping and
types basically the first four there are
kind of tied into the same thing the
weapon of choice and Erlang is the
function so that much else you don't
have class abstractions or you other
structural data structure oriented
abstractions it's pretty much as
functions so if you want to kind of
improve you want to think about
functions you want to think about all of
these things we'll get into that and
then case and if I've got some
miscellaneous things and comments here
case and if actually turns out are also
tightly tied to the ideas or the
problems associated with so we'll see
this is going to be a lot about
functions okay so let's transition from
the world of metaphysics and philosophy
which is just so gripping and compelling
to our link they're like community into
something specific
when I say specific I mean like naming
convention specific really boring things
okay so you don't see this very often
but like lower called camelcase
conventions just don't ever do that
probably never no one ever does but if
you see it it's it's just it's out of
place and this is better the underscore
convention is the standard in her life I
find that and I did this I you know I
actually didn't well I came into Erlang
I I kind of made a point of studying the
canonical forms just to make sure you
would make sure that I didn't just sort
of randomly name things so there's a
number of standard function names that
you tend to run into set element add
element store element put though the
things that right instructors those are
not standard those seem to be like
deliberately non-standard
I think every action every put verb in
the English language is used
someplace in Erlang core so there are
certainly things that fall outside of
this but but these are fairly standard
well there's exceptions to Nooh Nooh is
typically used when you create a new
structure of a record some type of data
structure so dict new start and start
link you should never change those you
should never if they all have a very
specific meaning always use those and in
it handle is a convention handled
message handle info handle passed on
flipping into e to handle cast handle
call handle info handle something is a
very typical pattern to see so if you
will see some prototypes some function
prototypes that if you find yourself
writing one of these functions name it
handle underscore something so the more
you if you're a seasoned they're letting
developer you know this so it's kind of
silly to even talk about it and if
you're not just pay attention to too
the OTP I think OTP Coors is quite
consistent in these long on these lines
just pay attention to it to pay
attention to the types of functions and
how they're named don't worry about
getting it all right just code however
the heck you want to but then when you
set when you discover oh this is this is
standard in Erlang and I've been not
doing it that way just see how long it
takes to fix it and now all of a sudden
your code is is now somebody who's not
you can look at it and say oh I know
you're doing there so that's the
advantage of being on the same page this
is kind of common sense block-and-tackle
but it's shocking to see how how rarely
it's followed there's just a lot of new
projects a lot of folks come in and just
they don't seem to probably bite fillet
don't care that's fine I'm not saying
they should care but it is just one more
barrier to collaboration with other
developers and and the grok ability
factor starts to go down and and I might
even argue that the code quality in
general of those libraries tends to be
consistently lower but whatever I'm just
being a jerk there all right argument
names and variable names you know I
skipped something yep hmm yeah I like
cut off that slide admits lie there yeah
so let the last two are so the last one
is actually not that canonical it tends
to be a pattern that that's used so
that's that's accumulator it's an
accumulator pattern and we'll see an
example of that type of function later
on that's that is extremely
controversial I should publish shouldn't
even be up there it's not good to call
it canonical is it quite a stretch to
put it in the same league as start link
is extraordinarily stupid of me so
anyway that's I should have an asterisk
next to that or should just delete it
okay so this is what I do I do this all
the time when I'm naming a function
apart from these things which are
standard that's easy the difficulty
comes in when you have a function I
think the most probably the most
important effort that you can spend in
improving or lining is is to is to pick
good function names it's remarkable how
much how little you know until you've
actually picked the right name that
process I find at least is is it can
extremely
healthy in difficult process it forces
you to just put a name on something that
is working like you can see it working
it's fine but to name it correctly
forces you to understand the problems is
it's one step into understanding of that
problem or more clearly if you can't
find a good name for it ask yourself why
why is it so hard for me to name this
thing
chances are it's either a very strange
function that does a very strange thing
when those exist so there's just some
functions that are hard to name or you
may simply not understand what it's
doing why it's working why why it seemed
up here's to work it actually may be
incorrect but appears to work so this is
the first step to kind of getting your
brain into that space a lot of times
what I'll do is if I get into a function
right I just don't know what the
function I know what I know I can see it
working but I don't know what to call it
I don't know what it's actually doing I
will I will call it but Allah under X X
literally and I will call it I'll just
make up some crazy name and I will call
it and I will look at it and be like
okay now what do I name but now what do
I need it so I get it working first once
it's working I have a model like I know
this is doing what it should probably be
doing now what is it doing
and then I'll rename it hopefully well
but this is also recently I think it was
this was more related to the the number
of characters you tend to use in
argument variable or arguments to these
things two functions I'll talk about
that next and and there's I think that
there seemed to be a tendency to want a
rule like here's the rule for me the
rule is just common sense if it's it's
either clear or isn't clear and it
usually comes down to sometimes things
are unambiguously better but a lot of
times there's simply a matter of opinion
that's fine at least at least think
about it so I think that that process is
it it's getting it to work plus plus
plus plus plus plus it's moving down
that road and yes it takes time and yes
it takes time away from drinking beer or
writing tests or whatever other things
are writing drinking drinking beer and
writing tests at the same time all that
stuff is like eaten into by this but
what I found is if you get if you do
this more and
learn more and exercise it you just go
faster and so pretty soon it becomes do
I pick option a which is not very good
but but fast or option B which is really
good but slow if that difference is
little right if B is just about the same
as a just go with B simple you'll never
get the B though unless you unless you
keep start down this road
okay so argument names and variable
names obviously in an early and you have
to start with a capital so you're forced
into that and I haven't really seen look
at an upper camel case underscore
convention by anybody who's not totally
psychotic so that's probably a moot
point there I would just say yeah this
is this is getting the like the loss of
her talk short but not too short or
whatever it sounds horrible but it's not
bad you know just don't be something
I've seen variable names that are
extremely long and verbose like it's
almost like a sentence and the the
developers tend to take pride in that
and think that that's a feature that's
oh that's an advantage and maybe it
isn't for me I like if the scoping of a
function is limited enough arguments
tend to be fairly unambiguous you get
into problems when you have like scope
creep in your functions and you
functions that where you have similar
variables and you'll have extremely
bizarre terrible names like argh we'll
see we'll see something some examples
there's a choice that people have for
these oh here just go back to this
okay pick on couch love it I mean look
at that handle changes you might as well
say do something and this call it do
something
do you understand right so I'm like okay
well that must be something that changes
because do you tend to see a suffix of a
numb of a number when I was like I
expect to see iterations of that look at
arcs too so I'm like okay well he's
starting with one usually you start with
zero but in this case it's starting with
one but then it's got a DB zero so now
that just I'm just completely confused
and then a rack which I assume is
request so that is just an unambiguously
to me bad and it could say an
improvement but if you look at this
function and you start to change that
you say well it's in fact I think I did
start to restart to refactor one of
these I'm just like this is intractable
like I'm just you know if I start to
modify this thing it's gonna fall apart
and if there's a bug in this it's gonna
be very hard it might be it might be
easy for somebody I just say it would
probably be hard for me to sort through
this soup and it's really not that hard
to go from the Mount of the whopper to
something not quite so whopper ish so
just by naming things you get there and
by keeping the things smaller your scope
smaller here we go it's much easier to
name variables if you have an increment
er for example that just adds something
to a number you don't have to say number
right just one simple variable just say
N or X so that's innings just like a
very predictable example of a very small
focused clear function you don't have to
get caught up in elaborate variable
names so you know these these these
design patterns or principles kind of
help each other out as you use them so
again common sense prevail and not a big
fan of what's the Microsoft Hungarian
yeah I'm not a big fan of that even in
even in the languages are meant to be
used in certainly not in Erlang if you
have I don't know why you'd ever do that
but I see this quite a bit so yeah so
you know user list users is unambiguous
so its users plural it's you know it's
more than one there's only one list type
in in Erlang so there's one pattern and
this is this gets into sort of yeah
yeah that's that's a great question so
it would to me would it so what common
sense prevail is like total BS response
so so here here's here's here's how I
approach that if there's really no point
to calling a map in the in the context
of the function if there's no value of
that to that then I wouldn't but a lot
of times in a case like that the map
will be a map it's important to call it
a map because it's used as a map so it's
not just a list in fact it isn't a list
it is so in that case I will probably
call it users mint user map because it's
really it's um it's more of a map in
that case than it is some congregation
of users but let's say I have a set of
users versus a list of users what I call
it a set yeah I do sometimes call it a
set because it you know the API that
you're interacting with this differently
so it helps to clarify it but you know
maybe you look at it and say you know
users makes sense or users list or you
look at your stop watching you're just
like I'm spending way too much time
fixating on this particular point now I
do that but I'm messed up I really am
I've spent oh I've done like what should
I call it should I
in it's not I know that I'm wasting time
I know that this is not a productive but
it's like what do you mean when you go
to bed and read a book that's probably a
waste of time too but it's it's
enjoyable its edifying its is should I
call it a map or not that's like you
know what is this thing just grapple
with these massive issues of the
universe and eventually you get faster
dat or you develop your own patterns or
you know if you're working with other
people and you see a convention you're
like oh I like this better you don't
you'd you adopt that and off you go yeah
so I don't my person this is completely
me my approach is I don't like I like
the code to speak completely on its own
spec would be used for a validator or or
for documentation for something else but
it doesn't help to clarify the code in
fact I make it I'll make that point a
little bit down the road but yeah I mean
in general comments I mean even just a
comment is is a flag that there's a that
there is a there's something ambiguous
and odd about something so I tend to as
a point not make comments but instead
we've refactored to make it clear but
you know whatever
it's it's really the baseline is each
person is on there is it just approaches
it with whatever wherever they are at
that point in time it's much more
important to be on the road to to
improvement whatever that improvement
looks like you know I think the the net
value to the universe of you know
whether it's something is suffixed with
with map or not is minimal but but if it
helps to clarify something if it helps
to save CPU cycles when you're reading
brain cycles when you're reading a
function by putting three more letters
just do that it's it it's it's fine
and you don't know until you've seen it
over time I mean I've been I mean sort
of on this exercise for a little over a
year now I'm still changing things
around I mean I have it's just a a crash
course I'm trying to figure out what
what is best here and I think if
everyone did that over the course of a
year
everything would would would some things
would converge into a sort of a best
practices pool but everyone would have a
set of things that are different for
each person
okay so this is a pattern of this is the
get opt pattern and it's used it's used
quite a bit in Erlang it's it's a little
bit more modern version because arity is
the only way to differentiate functions
you don't even have overloads based on
type you can you can run into collisions
very easily so if you have functions
that have lots of arguments it's
generally a bad idea and and I what I
would shouldn't say it's a bad idea it
can cause problems
in a number of different ways one way to
fix that is to adopt this pattern which
is for every function you create a bare
minimum requirement so if it can be done
with no arguments then you have a
variant that does it does it with none
if you can assume logical default values
and then you gradually build build up a
set of required optional required
well because arity you can you can keep
adding new functions I'll show you in a
second up to a certain point so you have
a minimum number of required arguments
and then you have a single options last
argument which contains whatever you
whatever else you want so it's similar
to to a command-line interface where you
have a minimum of set of required
parameters arguments and then options
which are - - whatever you know that's
get opt so that's that's that's its
convention so here's here's an example
of that so this is real code this
actually isn't a very good example but
my goodness it's very time consuming to
find these good examples I do apologize
it was lazy here I just didn't have the
time to find the perfect example but
this is an OK example so replicate
master there are three you know official
require I can't I can't possibly do I
can't replicate a masters in my sequel
replication command so we managed my
sequel servers is one of our services so
we set the replication up for it in the
backend so I need a master I need
filename I need position impossible to
do it otherwise so that's the bare
minimum and then I've got another thing
here which is of there's a there's a
check there's a validation is
interesting as I was looking at this I
realized this is actually kind of a
badly conceived function and and you can
even see if are you looking afterward
don't don't worry about now but once I
sorted immerse myself I started to think
about what am I doing here and that got
me into the domain space which is really
where I want like where I want my code
so it's it's not that big
only a few lines so I can read it but
I'm clearly when I wrote this I just
didn't really think this through very
well but it anyway it's a good example
of the use of options that's even though
it's a function so in this case there's
there's a don't check flag if it's
true then it takes a different path so
that's a very very I think of an
extremely elegant pattern and erling
that works very well with consider
because of the arity restriction you you
don't have type function overloads okay
so this is so let me I'm gonna like just
punch this is it boom that comes out
function scoping like this to me is it
like it comes down to our line functions
I'm not talking about a physical
physical abstraction and some philosophy
I'm talking about naming and Erlang
function and in particular what does
that function do because once you
understand what it does it becomes much
easier to name it so it does come down
to scoping what does this thing do to
stress it again I think it is very very
fair that this be an iterative process I
find it difficult to write the first the
the correct version initially I have to
get it to work I have to see it working
and then I have to get my head around
what is going on after I see it working
so iterative get it working then improve
it's very difficult to write functions
that do more than one thing but this
happens all the time it's all over my
code all over the example and you just
throw a dart to the wall you're gonna
find you're gonna find functions that do
multiple things that should be simply
split into two different functions or
multiple functions just based on that
alone so it's very simple to say what is
this thing doing describe it to this is
the this is another Joe Armstrong ism
which surfaced recently I think actually
this one came out a while ago but he
meant he mentioned it again apparently
Joe Armstrong has a rubber duck I don't
know if this is real or not but but
let's just pretend it is because it's a
great story so he's a rubber duck in his
desk and and explains to the rubber duck
what the function does and if he can't
explain to the rubber duck then he needs
to go do work so what this simply is is
a matter of taking an abstract concept
and turning it into concrete language
which English language whatever your
language is explain it to the duck that
is a different can be very difficult to
do when it's difficult to do it's a sign
that you've got some work understand
what that thing is doing
what are you creating why are you
sitting in a desk in the first place why
are you typing into it what why am I
here that becomes existential right so
when you're talking to this duck trying
to explain what this function does and
you can't it becomes a crisis for you
and then you start to talk to your
therapist that's when it becomes or the
duck too starts talking back the duck
starts talking back saying what do you
mean by that or do you really need to do
that or that doesn't make any sense to
me so that the dialogue with the rubber
duck is important and to me this this
really is work I mean I just it was it
was shocking - for me personally to see
this emerge as I started to kind of go
down this road that I would land into I
would just go as like a vice I'm just
like boom I don't understand this this
problem and the reason I'm having a hard
time writing this this focused
well-named function is because I just
don't understand what I'm doing now if I
understand what I'm doing and I work on
that and I solve that day me the
function and the function scope becomes
completely trivial it falls into place
boom like Tetris so that's it if it was
one slide that you could just photograph
don't photograph it because it's it
would be this though all right so what
do we have here 20 minutes oh we're
gonna do this we're gonna get this thing
done the question is will you survive it
20 more minutes of like but because this
may be like code stuff this is
interesting this is fun so these are my
there's there's probably some some
prototypes that I've left out but these
are kind of like prototypes they sit
calm types but it's really more of a
prototype I don't know what it is it's a
description of the type of function so
we'll go through each of these but the
purpose of this exercise is like just
thinking about it is I find it very
helpful to recognize when I'm writing a
particular type of function I say oh I'm
writing this type of function number one
if I can't identify that type of
function that's a sign like like and
again there's probably something I've
left off here but if I have never seen a
particular pattern before if I don't
know the patterns in the first place
it's hard to recognize something that
doesn't fit recognizing something that
fit is one of those you know those
triggers like what is going on here why
am I doing this is there a more direct
or canonical or standard approach to
hailing this in Erlang
these put these functions kind of serve
as a basis for that so let's walk
through them okay dispatch this is
really really common you'll see a
function that simply takes an argument
does a pattern match on it and delegates
it out to another function it's very
very common and it'd be fascinating to
do Studies on to see what how this
breaks out in actual a github github is
just like this mine this goldmine of
information but to see what percentage
of air lying functions actually come
into this category but what a dispatch
does is it's just an application of
logic it's a transformation it says it's
just it's a gate it says I'm gonna I'm
gonna get an input and I'm gonna I'm
going to you know direct it out over
here based on its type and it's
remarkable how much work how much
effective work can be done by chaining
these gates together it's just a bunch
of functions all lined up and if you
look at your code and code of others
you'll spot this all over the place and
the dispatch should simply look like
pattern match call pattern match call
it's not doing anything other than that
so handle message I should have done
handle info better that's I'm cheating
with an e to because we everything's
called handle messing everything is
under handle message but handled info is
an example that Hale cast handle call
that's it that's in gen server that
peeing in this case so that's the ping
is the front end it's the client facing
function to a gen serve recall to this
server so it's a dispatch very simple so
this is similar to a dispatch kind of it
looks similar but it doesn't actually
dispatch to anything it's just a
translation what you're doing is taking
state in and and from one that's
intended for use in one context and
you're translating it into something for
another context so in this case we're
talking about this this example it's per
am to action what it's doing is it's
taking a HTTP parameter and and which
could be anything it'd be like whatever
the web developer wants so whatever's
submitted over the forum which is a
string in this case and it's converting
it into something that the program in
this case wants so it's a little
translator and this is actually a fairly
so this is actually fairly common you
know you might be taking a reply Oh a
great example would be dict find which
returns ok comma value or error maybe
you want to translate that into
undefined value or some other thing or
maybe you want to raise it
you'd use fetch if you want an exception
but you get the idea that you know some
API is out here that I didn't control
but and I don't want to deal with that
interface it's not my interface I want
my own interface so you create
translators that will do what you want
and so that's that's yeah you'll see
you'll see these examples that I have
sort of a functional model in the case
example so keep an eye on this I don't
think I have a time to point that out at
nauseam but you'll find that case and
function are kind of like good
doppelgangers or like they can kind of
go back though so those are the same
thing it turns out that that they come
often compiled down into the same code
they can be used to do the same thing
they can be used to describe the same
thing and which one you pick is off in a
matter of just what is clear and it's
very subjective in some cases it's not
it's not one way is better than the
other but case and the use of case and
the use of functions is can be
interchangeable in a lot of cases though
so I have them top and bottom you'll see
alternatives to as we go here so this
one is this one you see not so often but
in a functional world where you you
don't have to try to avoid if or case
expressions but let's say we didn't have
there was a time when I believe when our
line didn't have case expressions or
certainly if expression so it you'd have
to handle a conditional logic this way
it's a type of dispatch but it's a
dispatch on a canonically a single
argument variable in this case we have
delete expired user so I want to know if
the I could say you typically would say
if down here you'd say case user expired
true than delete so I think that's very
clear
I would probably opt for the case form
in this in this case the personal
expression opinion
but you will often see a maybe form form
out there and that's typically when
you're doing a bit more there's a bit
more to process in the condition or
maybe your pattern matching and the
pattern matching just syntactically
starts it's not very clear or maybe you
want to put the documentation on on the
the you know you want to formally
represent this translation this
conditional logic as a function so that
you can test it so putting it up into
the functional later gives you that
advantage completely independent of
readability a result handler very common
so rather than handling the result in a
function so a result you know assignment
result equals and then handle it
you just pass it on to it to a another
function so it's like a pipeline so you
you do something with one function you
handle the result with another and a lot
of cases it makes sense to use case but
in a lot of other cases handlers are you
just the variation of what you can
handle is is just makes more sense for a
function and it can also be tested and
it can also be documented accumulators
so that was that under a KCC that come
that standard canonical form that you
see all over the place you actually
don't see it all over the place so I'll
officially remove that later but there's
a lot of alternatives to doing this you
have higher-order functions in the list
module you've got in this case list
comprehension works well because it's a
it is a list it's a it's a comprehension
over the users list but accumulator is
you basically so the front end here is
form form at users that's what you would
typically it's very simple format users
you don't pass in an empty list that's a
crazy interface but the implementation
of that calls the under AK which is an
accumulator that gets an initial empty
list and now I'm going to you know pull
the head off of that list form at the
user and push the head back on to the
accumulation and then reverse at the end
that's a very very very very common
pattern there's alternatives to it but I
this is such an easy pattern to write I
tend to use it quite a bit
but just recognize it if you don't
recognize it instantly you you you ought
to because it's it's I mean start
getting used to it because it's so
common
in in Erlang and then the flip side of
that is a list process I should have
switched the orders of the order of
these but this is simple we're just
going to process we're going to pull the
head off the list
and do something with it until it's
empty very simple there's a for each
function which is a higher-order
function of list module which you can
pass along function to which arguably
makes that clear so which one you want
to use I would probably use the second
one in this case but a lot of cases that
print users that second you know that
could that could fill out quite a bit
and you'd have a second function here so
this starts to look bigger
again bottom line these are this is the
this is the ingredients to the soup you
make the soup taste that does it taste
good good keep doing that tastes bad
rejected but at least now we kind of you
know can sort of think about the the
types these prototypes all right two
more here we're good we're good
so these are these a little bit more
esoteric this one and I've starting to
use this a little bit more I've used it
for a bit but I thought I would I'd
highlight it because it's I think it's a
very useful pattern probably using it
more but it's basically whenever you see
a function that that is doing a bunch of
different things it's a candidate for
this type of pattern if you if you say
do this and then do this it could all be
function delegation I think every line
could be a call to a function but what
that might be is is more of a workflow
type of a function when you want to do a
whole bunch of things and they're
chained together it's at a certain point
you might want to put it into this if
you want conditional logic to be applied
in between those phases because putting
if statements inside of that you is you
you end up with this horrifyingly nested
and very difficult to read I should put
an example if for that clump of Erlang
code you can get rid of all of that and
make things very elegant I think using
this pattern basically you load up your
operations in a list in computer these
can be represented as atoms or you could
just put the functions directly in so
those
start in it verify notify those could be
the functions directly and you pass that
into an apply some something that will
go and and you know take the the item
the phase and make it and make it so and
then handle the result so in this case
we're handling the result of it's okay
we just keep going so we move on if we
if we get an error now we handle the
error so we have effectively implemented
you know if sort of what you would you
would see very naturally done in a
parrot of languish because you can have
you know conveniently returned out of
the middle of the function you don't
have to nest you can have you know if
just if statements so it's difficult and
messy to do that and when you start to
do that in Erlang your code starts to
look like we're liking like hell really
does I'm gonna skip state and in its
trivial let me jump ahead to a point
real quick here and this is this is the
imperative trap this is why only
imperative Travis it's very dramatic
I would say that most of the pathologies
in an airline code the really really bad
things I mean just things that shouldn't
be a result of somebody taking some
imperative code and like translating it
we're taking their imperative worldview
and applying it directly without any
thought because you have an if you have
an if expression and it seems like it
might be useful for this type of this is
this is a disaster so it took me a while
to look at this and even figure out what
was going on is just so odd-looking and
in Erlang so what he's doing is is I
suspect this is from early DT L this is
not having Miller's code so to my
knowledge that Devin's not here so I can
make fun of them but what I'm hoping
this is is a design is like a
translation decision to go from like
Python or something so that they kind of
keep it in sync because it's really
non-standard this is much much this is
how you do that you don't want to take
your your your literal code from Python
or Ruby or whatever and try to copy it
and make it fit into early so knowing
that you implement conditional logic
either using a function pattern matcher
or a case expression will help to avoid
that so you're not having to you're not
having to bind enough and there's an the
lower bound is unnecessary behind there
and it just clutters it and I was
confused as I saw it now imagine this
side type of pattern in a function that
long we have you know just like and I
was trying to come up with some
refactoring examples and I ran into a
few and I started down that road to
refactor I'm just like I literally like
I would never want it to to refactor
it's too time-consuming it's just I have
no idea what's going on here that's bad
because that's like you know bug hits
that code and you're afraid to change
because you have no clue what's going on
the good news in Earling is there's no
reason for that to ever be the case you
don't have to have that sort of code so
just avoid this imperative trap by not
doing it just avoid it don't do it
here's another example I looked at this
I'm like this surely there's something
clever going on here that I'm not I'm
not seeing but it's again a case of
somebody trying to make it look like and
this is not a criticism it's a bit of a
criticism but it's not a it's not a
terrible criticism again it's just like
fix it here so this was easy to fix
that's what this looks like so what's
going on here
so for parsing this and it took me a
good it took me probably a good 60
seconds I'm just going what on earth is
going on here but I started with this
and say okay well I I don't care what
that is I know what the result is
fortunately this is a side-effect free
there side effect free function the
guess of things that's what the return
value is then I just reverse engineer
that so what he's doing is returning
three a tuple of three elements and in
my point from my point that wants to
those want to be generated by three
functions because of three separate
logical functions and now you've got
this nice syntax in Erlang which is very
very compact and readable default start
if it is passed a I don't know what that
empty list would be that's a little
strange and might be other me I don't
know why I don't know what that is so
then that variable should be renamed to
something clear something should be
fixed here I don't know what's going on
but the code is least you know a world
better than that almost before but
that's an example though of you know
once you
yeah I know if you were starting and you
just said that look that looks perfectly
fine but but you know if you're gonna
criticize Erlang for looking like hell
and that looks like hell don't do that
and then it won't look like hell so if
you're tempted to write really really
horrifyingly bad code you know what I
would do here's what I would do send a
note to the list don't do not be afraid
or timid or and just send it out cuz
it's literally if that works ship it
fine don't worry about scruples just get
it out the door but from it's so much
faster for me to write something like
this than it was that so just do that if
you get to the point where you can do
that why not yeah
yeah I mean if you if you want to
minimize the number of functions you're
gonna hate everything I'm talking about
you're just gonna be like this is
horrible
now there's an explosion of functions
it's it's not even it's it's a it's a
good order of magnitude more I would
argue that's a good thing you know the
the the the functions are are clarifying
devices in in this language this is a an
extremely simple straightforward
language you pick a name of a function
arguments you know them to go and go
into the thing and something comes out
that little machine that you create if
you can tag that and reason about it
understand
standard it doesn't matter if there's
10,000 other ones you're a universe of
interest is only in the one and so it
doesn't matter what level you look that
could be a highly leveraged function
that goes calls a bunch of other
functions but it doesn't matter to you
it's like you know it's like a taxonomy
that has to be hierarchical versus
tagging you know a tag system or you is
infinitely scalable you can have you
know in in trillions of things that are
all marked and it doesn't matter you can
you can mix and match them and rearrange
them and it doesn't have to be
hierarchical so I think there is a
tendency to try to organize these things
so that you can understand them but if
you get over that hierarchy or you know
having to say this is the top this is
the you know the top node and has
children's and now I can reason about
each stage just flatten it all and
describe each one as it is independently
and you forget about levels and
everything becomes just very simple like
oh you know defaults start
that's a terrible argument name and what
is that why the number being lined up
with a list like doesn't make any sense
now but I can reason about that now and
improve it then this is the this is the
extend on my universe I don't care about
anything outside of that function for
that particular point in time okay I
have to yeah
so here's what I'm doing now and I think
I'm gonna stick with this because I like
it I use them in the order in which so
everything starts with the exports so
the exports go first that's the that
basically you're starting with is the
reasoning is this you know the purpose
the function is to provide exported
purpose of the module is to provide
export function so those go up top and
then as you invoke the functions you
define them
you don't group them together and the
reason the reason you do that and the
reason I like that is it makes it much
easier to find the function when you're
trying to read down the code you
basically want to be able to read the
code from top to bottom so if you're if
you're because there are so many
functions and this whole world view is
is predicated on a decomposition around
the functional abstraction searching and
hunting and trying to find functions is
expensive so make that cost as cheap as
possible and I found the cheapest way to
do that apart from a fancy IDE you know
that would give you completely you have
all sorts of novel views to this this
world the easiest way to do it is just
say you know if it's used here it goes
immediately under it and there's a
there's a there's a sore during to these
functions so you can say this is wrong
and this is rice doesn't come down to
opinion I used to do it if you if you
use the Emacs templates you'll see
there's like they break it into these
sections they have like public interface
you'll have the the behavioral functions
and then you'll have the internal or the
private and so lots of my old code has
that stuff I can't stand it
because I have to go all over the place
looking for this that and the other I do
have I tend to have banners that I don't
have the comments for every single
function but Halle banners that will say
like start slash in it and so all of my
in it if if it's if it's a if it's a
process of as a gen server or you to
process they'll be in one section
sometimes I'll have a thing at the
bottom which is a general purpose
so obviously I'm you know my religion is
breaking down here a little bit but
that's the approach I'm taking I want to
basically minimize the amount of time it
takes me to find
the function I'm interested in okay so I
am officially out of time
let me quickly scan I just want to make
sure that is a super important plot
point that I don't miss it but then
maybe like just a few questions and then
we can be done oh yeah just this is
right this this is one thing that I just
this is literally the one thing that I
insist on in in any code that hits
repository of anything to do with if it
isn't 79 its I go apeshit
it's like this if you can't figure this
out and the argument is like well
textmate
you know whatever it I'm running a Mac
and it doesn't like dude the one thing I
ask is the simplest thing how it's gonna
be impossible to talk about like all the
other stuff we just talked about if you
can't do this this limits the amount of
nesting this is why is this important
first of all an Emacs you can get on
this on this laptop you can get two
windows in parallel that's why this
number is important because my laptop
Emacs so that's number one number two is
it limits the amount of nesting that you
can reasonably do there's oh here's it
here's a good one this is this is one of
my favorites this is the amazing nested
do function it's like a v' it's like a
ten name title of a video I'm gonna use
this for a video this is amazing if you
go into the HTTP the eye Nets
application I'm making fun of we're all
in the same family so I'm making fun of
you know who knows who wrote that code
originally terrible code but it keeps
going and it's like it's just crazy and
all these modules look like that they're
super nested and this this is this is so
far off the like I'm basically here with
my lap with mine with Emacs if I do
truncate toggle truncate lines or
whatever toggle truncate it cuts it off
here so no 79 it's the rule for
everybody in this room
yeah yeah so so do this I mean if you're
interested in there's some other
interesting examples in here if you're
interested in it maybe this is this
evolved at some point into some other
community document that we could throw
patterns or whatever who knows if
anyone's interested though I'll have
this certainly posted and it'll be on
it'll be available so you gonna dive
into it afterward any quick questions
because we are have to have tea time I
I'm sure there are you would be
surprised to find that I have an opinion
about that I I'm kind of like feel like
code craftsmanship the thing like it's
not that hard to do this is so it's not
that hard and if you're doing it
manually you just get really fast at it
and like I know developers who who will
use the code for manners and and they'll
do they like literally do this I'm just
like you've got to be kidding me and
they'll hit ctrl shift F and then it
just gets formatted based on the you
know their formatting engine but then
everyone has the same that have the same
formatting engine and just using Emacs
and then it's all the same it's very
simple so simple if I had to do pages I
do you know tabs I would you know spaces
that yeah
yeah sorry so the question was the the
the practice of including records in a
module versus and include an occluding
hrl file but I think it's also it
probably has to do with whether you
whether others can see it right there's
that the yeah yeah okay so the question
is will the my thoughts on a data
structure module yeah data structure
modules are very canonical that used
dict as an example when you do dicta new
it's some god-awful thing every time I
see it I you know I hurl but it works so
that's a good example of just like it's
an opaque data structure yeah you can
see what it is and pull it apart but
know that module wraps that up that's
that's its territory and you want to do
that same thing so if you're dealing
with a data structure you want a module
dedicated that all that slice lifecycle
and mutation all of its operations going
to that one module just like dict just
like sets just like lists just like all
the other ones yeah okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>