<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>(...)Distributed Systems - Alvaro Videla - Erlang User Conference 2015 | Coder Coacher - Coaching Coders</title><meta content="(...)Distributed Systems - Alvaro Videla - Erlang User Conference 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>(...)Distributed Systems - Alvaro Videla - Erlang User Conference 2015</b></h2><h5 class="post__date">2015-07-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yC6b0709HCw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I already see that there are distributed
T in the audience so if you don't know
who they are they are watching you well
the talk is call what we talk about when
we talk about distributed systems you
may wonder why I chose this horrendous
colors it's because his talk is also
called it's very system for the ikea
family or EK a family so i tried to
adapt to the to the swedish mood let's
say I'm even using verdana from from the
font and I went specifically 12 website
to choose eki yellow and Kiki blue
anyway so distributed systems definition
by Leslie Lamport you probably heard it
many times even attributed to different
kind of people probably Einstein who
knows a distributed system is a is one
in which the failure of a computer you
did not know even even easy not even
know existed can render your own
computer unusable it's basically when
Facebook goes down you cannot use the
internet anymore because of all these
like buttons they don't let you load
your your website or when github goes
down we cannot program anymore that
that's basically how to make a
distributed system centralized that's
what we did with get help but more more
seriously the idea of it of the talk is
that when we try to learn distributed
system that does my case currently there
is a lot of jargon there is a lot of
definition of a lot of terms worse that
they make they might mean what you think
they mean or not and it's a very
specific definitions on each of them
that will let you understand why a
theorem means something or why
unimposing bility results means
something else so yeah that's jargon
defined by google special Wars or
expression that are used by a particular
professional or group and are difficult
for others to understand that's what I
feel about the distributed systems
literature
so as a definition that this is from a
book by my Michelle rhinol french
distributed systems researcher if I said
basically you have many nodes trying to
solve a problem or many processes they
have partial knowledge of the whole
system and they have uncertainty they
have no idea what's going on on the
other side and then is the other node
alive or not you don't know in a
distributed system that's basically what
defines how computation works here is
uncertainty we don't know what's going
on basically which is quite hard in
computer science when we are used to
everything be so deterministic and I
found that it's a very deep rabbit hole
there are lots of things to read there
are blocks out they are telling you read
this paper that reads SLP read the
original cut paper or blah blah blah I
have no idea if I should do them so
which papers to read there is the flp
paper the paths of paper the time clocks
that if you don't sign this paper you
are kicked out of the distributed system
community you have to call that paper in
your paper basically this is the zap the
zookeeper paper from yahoo and so on and
this is the raft if you are a history of
the Civil assistance you need to know
raft basically the pack sauce is to all
already so yeah we have all these things
and what do I need to read why should I
read about a raft or FL be the first one
the impossibility result or whatever I
don't know the and that was my problem
and still is kind of my problem that
there's so many things and it's hard to
focus on to know if let's say I work for
RabbitMQ I want to improve how RabbitMQ
in mirroring should I read about raft or
should I read about Paxos or I should I
learn
that Joe is here because a lung solve
every distributed system problem right
there are no more problems it's just you
sellin right so what to do then there
are books there are a ton of them these
are some of my library that I managed to
collect over the years some of them they
don't even talk about this tribute
system like this one sorry for the
camera this one called parameters of the
systems let me tell you something
spoiler alert is not about programming
distributed systems is a book about the
actor model the PI calculus and all all
ways of writing or specifying
distributed systems but I bought that
book and say wow I'm going to learn
about the DVD system and fail get out no
it's a really good book if you need to
learn about this formalisms but it's a
not one if you need to practical
implement something I'm sorry for mr.
Villella that I gave him this review but
anyway and just on in the second one the
art of multiprocessor programming this
is very important sometimes people
confuse multiprocessor programming
distributed systems I want to put
everything into the same box is not the
same there there are related problems
because you have states in many
processors but the algorithms and the
literature is not the same so for me
simple was quite important to realize
that that year maybe you can implement a
concurrent queue and there are many
problems that they so that you could
later apply on a concurrent this video q
whatever but the literature is not the
same or targeting the same exact problem
so be careful and then there is a why
like why why chill you learn and do all
these things and waste all this time we
don't have all the time in the world so
should I just grabbed let's say flashes
react ensamble and be happy in my life
or or try to know what's going on behind
and so on so continuing with the hekia
theme this is from somewhere
and yeah that's how you end up when you
start reading about these two beauties
systems I guess what that means in
Swedish is not so polite buddy I don't
kick me out please anyway I'm just
quoting right so the problem the problem
of learning about distributed systems is
there are different different models on
which papers books results theorems
apply that's the main thing I hope this
is new for you as it was for me again
prob Lee's description and the talk on
the website this talk is in certain
terms its beginner level but it's
beginner level in a quite a complex
problem as distributed system so i hope
you get something out of it if you know
this already I'm sorry so one model is
the time in model algorithms they define
something about what time means for them
then there is the inter process
communication used by these algorithms
and there are failure modes so
algorithms in distributing systems they
combine these things and based on what
they take from each of them you have a
CRM or impossibility result and so on
timing model there is the synchronous
model where algorithms they usually are
in executing steps and it's very well
known in this model how long they take
to execute that particular step either
receive a message from a message queue
put a message on the message queue
implement a step of the algorithm like
traverse a tree whatever they're doing
but that's very known bounce on how long
it takes to execute that step and the
same in the message passing in this
model is known how long it takes for a
message to go from one node to the other
null you know that is faster let's say
five seconds the the other note didn't
reply you know is down is failed and you
can detect that we're on the synchronous
model
that's that's I shall be called the
living la vida loca model actually
because there are no guarantees about
anything there is no guarantees how
longer process will take two to run a
step you don't know how long it will
take to receive a message to put a
message on the q how long the message
takes going through the network you
don't have any of these currencies I
schedule the scheduling of a logarithm
could be fair to be unfair your process
never got get to be scheduled and you
don't know anything so that's the
synchronous model again maybe if we like
now in no chase I mean in the current
programming world you can say a
synchronous use know synchronous Java
whatever I mean I'm making a very stupid
example that point is synchronous means
one specific thing and a synchronous
also it's not like I and I've seen a
thing before you know you do a sink all
the time no it's not that it means
something else in this context and then
there is a semi synchronous mode because
both of the top ones they're kinda
unrealistic I'll accept probably on
real-time computing you don't have a
synchronous model where you know exactly
what boundaries you have for computation
and so on and on the asynchronous model
I mean if you go to an ATM and it
doesn't give you the money at some point
you stop and go to the next itm I mean
you are not like going to wait forever
did somebody decide to schedule your ATM
for example and the same happens a user
using RabbitMQ they expect that we
replied your message after some time and
so on so there are very nice theoretical
models but they need a semi synchronous
one where some boundaries are put in
between two to do things this book by
Nancy Lynch that I had in one of these
links pass algorithms is very well
organized book because as I listened for
the first model for the second model and
so on so you are not guessing what
you're learning interprocess
communication is pretty simple there is
either message passing or share memory
most algorithms I would say yeah
message passing systems and yep you know
you need to know how communication is
gone and what message passing means are
the channels inventing messages of the
thin air or they are reliable and they
don't come up with new messages do the
reorder messages are there 50 channels
random channel whatever in all these
things they define very specifically
what this algorithm covers under that
particular model and finally this is
also quite important are the failure
modes of that a process can have four
for the algorithm to be correct or for
the proof to mean something crashes top
models very simple if the process
crashes is gone there is not going to
keep doing computations it's not going
to come back or anything it's gone a
crash recovery the process can come back
and join the system for example in a
crash top model is the process let's say
the machine recovers and joins the group
later that's a different process
completely different in the class
recovery is still considered the same
then a process can do a mission fault
that means it may omit to reply to a
message or or to receive a message
depending on the kind of emissions that
the algorithm supports is what can be
done for example and a process that is
managing to receive messages but it's
omitting to reply we can assume that
that process has stayed up to date to
what's going on and algorithm so we can
trust this as a replica let's say that
that kind of got everything that should
be in the system but we have no idea
what it did we are not sure if you did
it but at least data is is there somehow
then the receive arbitrarily failures
more be sometime this is quite
interesting it works like this excuse me
you on the first row what's your name
he just tell me that he's called Carlos
what's your name he says he's Leandro
that's a victory failures model it's
like a process that will do whatever it
wants it can reply exactly what it was
say to make us believe is behaving
correctly behind the scenes doing the
opposite thing or it can give any kind
of answer it soon replication and saying
this machine here told me that the
resistor has value 10 but the machine
told them it is five or whatever so be
some time that you don't want to deal
with that but the real ago reason for
this and the thing is if you handle a
recent I'm failures then you're the
algorithm supposed to handle all the
others so this is like a hierarchy of
failures we will see why this is
important soon then another concept in
algorithm this lightness and safety
there's a paper about this where safety
basically says something bad never
happens cool so what is what does it
mean and I go reasonable say we are
using i think is called reliable
channels and if the algorithms assumes
there are reliable channels it means
messages are not going to be invented
out of thin air thus the safety property
of the algorithm is telling you that or
if you have a first-in-first-out cue the
cube will always take the first item and
give that came into the queue and
returns that it won't return items out
of order something like this or that
particular order and likeness is a good
thing eventually happens this is hope
basically and a destination process
eventually delivers a message which by
the way the livers means something
particularly in distributed system
usually if I think about delivering i
think that the
liver this cup of water to him then I'm
delivering but actually in distributed
system is this is my message box when a
process delivers a message it means it
grabs a message from the message box and
used us some use of that message that
usually in the literate literature what
the leavers means to so basically at
some point the process will grab a
message from the from the inbox so
having these models let's take a look at
what flp flp is call like that because
the authors of this paper are Fisher
Lynch and patterns on the paper is
called impossibility of distributed
consensus with one faulty process this
was as far as I understand a problem
that was heavily debated on the 80s if
what happens is a process crash it can
be achieved consensus come we not and so
on the abstract goes the consensus
problems in balls on a synchronous
system of processes some of which may be
unreliable the problem is for the
reliable process to agree on a binary
value we show that every protocol for
this problem has a possibility of non
termination even with one with only one
the faulty process and so on and keeps
going from my point of view if I don't
have this previous knowledge of models
and so on I have no idea what what
guarantees or what they think is trying
to prove so it goes somewhere in this
paper we show the surprising result that
no completely a synchronous consensus
protocol can tolerate even a single
unannounced process death and they don't
consider Byzantine failures and whatnot
so we notice the system is completely a
synchronous this means that there might
be an execution where a process never
get scheduled for some or we never get a
reply from from from another process and
why this is important if you need to
decide between people what to do and
some of your friends never replies to
you you cannot achieve consensus
deciding on a value
in a synchronous system you have no idea
if the other process is not replying to
you or the middle or the other process
is dead for example there is no way to
actually determine that just in these
settings so they say nevertheless even
with these assumptions the stopping of a
single process at an inappropriate time
can cause any distributed commit
protocol to fail to reach agreement thus
the important problem has no robust
solution without further assumptions
about the computing environment or still
greater restriction on the K kind of
failures to be tolerated crucial to our
proof is that processing is completely
synchronous that is we make no
assumption about the relative speeds of
processes nor about the delay time in
delivering a message we also assume that
processes do not have access to
synchronize clocks algorithm basis on
time out for example cannot be used to
solve that and so on and so on and they
keep explaining what the model is wise
strong and so on so before I go into the
concerns to think why this is important
and why is what there are they trying to
tell us under all those constraints and
assumptions are arriving to consensus
that we will see what it is soon is not
possible what it means to us is like if
we have one crash crashing process we
are not going to achieve consensus under
those settings so tomorrow when you go
home and you try to implement your own
consensus algorithm please don't I've
seen projects that do that another one
to give names but you can guess which
which one is it I don't know you I mean
if you are naive enough to think that
you can solve these things without
reading the reading the theory you will
probably obviate the flp result which
means you will try hitting your head
against a wall to solve ok but this
process failed maybe I put a time Madame
then maybe I do this and then I do that
and you will always be chasing your tail
because there is no solution that is
proof that there is no solution in the
most week of the things which is only
process crashes if you go down that
hierarchy is even worst that's the take
out so what's consensus anyway the
consensus problem is a paradigm of
agreement problems so it's not just one
thing there are many agreement problems
which are called concerns to agree on a
value for example if you need a have a
distributed database they need to agree
they commit datanode or not to the
harddrive that consensus problem all
these replicas natural reef that value
needs to be written if you are
delivering messages and you want to do
like atomic broadcast when they have two
respects on all over there and every
every processing the group receive the
message they had to agree that they
receive the message or deliver that
message so what are the properties of
consensus or uniform consensus sorry is
C termination is called the first one
which means that every quarter process
eventually decides on some value then
there is validity which means that if a
process v if you process the side be
then V that value was proposed by some
process you cannot come with a value out
of thin air some process based on on the
state since the algorithm started
executing and all the states that was
taken reach to some state whatever that
is like in my case let's say how old are
you m 33 so that is my current state I
cannot come up with some random value I
don't know where I got it from and when
I'm going to have that value that if I
decide on that value and everybody
decided I'm 33 somebody proposed that n
33 let's say no not just like people
coming up with ideas about what my age
might be agreement it means that if
process are correct they don't decide a
different value if they agree that the
I'm 33 years old everybody has the same
idea maybe my mom has a different thing
but I don't know like you may find this
funny but in Uruguay back in in
like hundred years ago to register
yourself you have to cook grab a horse
and go somewhere and so my grandfather
discovered after all the tales he was
telling like you know when I made this
guy and we went to school and with this
blah blah he was one year older actually
then he was registered because nobody in
his family managed to get to the Civil
Registry on time Milano anyway they and
the uniform consensus so without without
these is just consensus uniform
consensus means not to correct processes
whether not to processing sorry whether
there are correct or not decide
differently so the difference here
everybody decides the same only correct
processes decide the same then when do
we need consensus a set of processors
have to agree to take a common action
like atomic broadcast or for example
group membership atomic broadcast
correct processes deliver the same set
of messages in the same order that's the
problem that is the this is trying to
solve you need consensus to achieve that
oops so SLP tell us that in consensus
cannot be achieved then atomic broadcast
or group membership cannot be achieved
either I've seen also people trying to
do like a atomic broadcast for example
or group membership but at the end of
the day that's a consensus problem so if
in your current system settings
consensus cannot be solved the other
thing cannot be solved either no matter
how smart you are and how many PhD you
got from the university you're not going
to solve that that's very important so
we pack our bags and go like some people
leave already I don't know what's with
my talk nothing to see here like okay
with we cannot do anything besides
probably using the line that it doesn't
have this program no there is a very
interesting paper where Markos Aguilera
I think he was a researcher
microsoft the main problem with this
paper is that when he left microsoft his
paper disappear from the net so I if you
if you have money enough money to buy
Springer books you can read this paper
if you are not that kind of person then
I'm sorry in my case I think I made my
company pay for it anyway he says that
when you get into reading concerns of
research there are many
misunderstandings and SLP is one of them
flp is not an impossibility result as
the halting problem that in this case
for a completely a synchronous system
where the scheduling of processes can be
completely unfair it may happen that you
have that problem but it's not that in I
think in the passage literature they say
that you can reach agreement as soon as
you have a stable system for long enough
for example they say that lays like
kinda hoping for good but yeah that's
something and it's really is really good
to read that thing and see what it means
actually it doesn't mean that you are
never going to reach consensus no that's
not the case why because there are
failure detectors what's a failure
detector according to the literature
there is a whole thing paper they are
defining them there is thermal processes
the provide information about suspected
processes so they are like the police
saying that guys may be misbehaving and
they have a property where crush
processes are detected that's the
completeness property so an easy and
accuracy that means that is a process is
correct is never suspected so i have a
question i don't expect you to answer
and the one to two because we don't have
time but the question is completeness
crashes processes are detected if you
have a complete a synchronous system how
are you going to solve this problem when
you have no idea the other
process is replying or not or it's just
I don't know taking a siesta like we do
in South America or what and the same
with the correct processes are never
suspected you give a time out of one
minute you don't get a reply you are
going to mark the student as not coming
into your class and then suddenly they
enter so your accuracy went out of the
window as we like to say grab some
perfect failure detector on it he has
this problem you start having this aunty
until you you are you're done let's say
perfect failure detector this is from a
book and it says you have a perfect
failure detector with an instance p and
this algorithm will give an indication
to whoever subscribe that detected some
process p has crashed one of the
properties of the perfect failure
detector is that it has strong
completeness it means that eventually
every process that a crash experiment
permanently detected by every correct
process and accuracy or strong accuracy
if a process p is detected by any
process then p has crashed so that's a
perfect failure detector it will give
you the properties you expect question
is is this completely useless why do I
care about a perfect failure detector
that I'm not going to implement ever on
an a synchronous system is really useful
because it's telling us these things you
only get them on those like even in this
case sorry is on a synchronous system
because you know what's going on sorry
and I think you need to have perfect
channels is another obstruction these
uses that never is a message lost and
never is a mystery order and like there
are a lot of constraints so at least you
know if you are trying to solve this
problem of accuracy or completeness I'm
sorry you can't because unless you have
this perfect world then this is not
achievable so again you are super smart
you don't read papers you jump directly
to code and you wind your way with your
keyboard like this hacker
man on the on this Swedish movie I think
it is the kungfu something confusing
sorry I guess everybody incidents with a
nose cone fury yeah unless your hacker
man you're not going to solve this so
there are they eventually accurate
failure detectors eventually every
process that crashes is permanently
suspected by every correct process and
there is a weak accuracy that there is a
time after which some correct process is
never suspected like all the other
correct processes so maybe we think that
process is not working ok it replied to
us back to us is actually it wasn't
failing let's say that's a paper
training all these failure detectors and
there is this one other also sorry and
reliable failure detectors for reliable
distributed systems based on flp they
came up with all the solutions to solve
the SLP problem and to achieve consensus
for example here it says we proved that
consensus anatomic broadcast a reducible
to each other in a signal system which
Azrael blood you can read that at some
point but they can solve that using the
failure detectors and failure detectors
have read their like there's a very deep
theory about what each of them allows
you to do on which system and so on I
think this is the paper describing each
class of failure detectors so why do you
care about that there are some failure
detectors that are really powerful of
course harder to implement down invest
time and on on implementing a failure
detector that is maybe too much for your
for your there is maybe too much for the
problem you're trying to solve that's
the thing to to keep in mind again as I
said deep rabbit hole quorums this is
quite simple long story short
intersecting sets you if you have
checked that at some point they have a
common process then you have a quorum
what did you ever say it doesn't make
any sense ok
a quorum in a system with n crush fault
processes abstraction for example is any
majority of processes for example more
than hulls what does this even mean
again for example an algorithm will tell
you like if F F is usually used for
failed processes yeah if you have a
failure of less than the half of the
processes then another remember which
kind of quorum this or consensus this
one is but you sorry let's say you have
ten processes and 411 processes and fire
them fail you still have you I mean you
will have a majority of processes than
if later again five more crash on those
six that remain alive at least one knows
what happened on the previous round it's
like a ssl intersection of sets and
there are some properties I'd say if
more than F are failing you you know
next keep keep going so there are a lot
of mathematical theory about quorums
there is a very good book by there is a
series of focuses on distributed system
i will tell you someone at the end they
are created by Nancy Lynch and one is
specifically only about columns and it's
quite this book are really cool because
they are related to the point and die
like hundred hundred fifty pages
specifically about that topic you wanted
to learn about consistency this is a
hard one there is a seminal paper
calling a disability a correctness
condition for concurrent objects where
they define by both linear is abilities
and so on and usually they take an
example of some kind of data structure
in this case for example a concurrent
FIFO queue a linear accessibility it
means you have a particular kind of
object like a FIFO queue
with some semantics like first in first
out so if I get into the queue and
somebody has get behind me in the q1
consistency condition can be that I am
the first to go out because it's 50
that's the thing that is expected from
the cute for behaving correctly then
depending if you want atomicity or
sequential consistency or whatever is
depending on the view of which process
in the system accessing the FIFO queue
of FIFO queue what is a proper execution
of that algorithm so there are many
kinds there is a tummy consistency
linear disability i will give a small
example soon sequential consistency
there's another kind and color
consistency where you have a few just a
really good job here explaining all this
but basically in sequential consistency
he says like if I'm Mona on YouTube
let's say commenting as soon as my
comments are in order the ones I mad in
there on facebook that's good enough
then you are at the same time adding
your own comments as soon as you see
them coming there to you that's good
enough but if in the case of casual
consistency if you reply to one of my
comments and I only see the reply and
not the original comment or the reply to
the reply then you broke what casual
consistency means I let you to go to a
fear I think it does have way better
shove data and trying to do here to
explain consistency models the point is
when I can algorithm or a theorem like
the cut theorem or whatever i'm
mentioning consistency we need to know
what they mean by that is not i mean
which of them or their way more in a
paper that i mentioned there or kyle
after has a name is called Kyle
again jargon there is a lot of jargon
and we have to know what they mean so a
linear disability the ideas always about
histories of what the process are doing
what is a legal history for example here
is a registry and the idea of the legal
history is that where is it for example
sorry here this in this registry the one
was written so here we read one if we
were reading two out of it that's
completely unconscious tened because you
expect that this order of what's
happening in real time let's say is
respected this isn't in atomicity or
linear stability the problem is when you
have this kind of concurrent operations
where the start of the operation and the
end coexist with the start and the end
of another one is how you decide the
linear is a linearization point which is
on this real time line where you have
like an omniscient of server is seen all
the operations happening if you reorder
that those two you can do that let the
right to succeed before right three okay
that's fine but read the one on top then
they need to keep being consistent so if
this process now managed to read three
out of it this also has to read three
out of it you cannot make this one
concurrently read two from back there
something like that again there are more
details for example in this book and so
on now nearly the end of the talk I am
where I'm a book critic for the New York
Times rolling I don't know this book
this book will be your your best bot or
the worst why it's called distributed
algorithms for message passing systems
I'm Anna longer I found the perfect book
to do
distributed algorithms but at the end of
the book this is no i'm not lying here
that the author explains that actually
this book never considers failure so all
the algorithms consider a perfect book a
perfect world sorry so you can save
flipping tables what while spending my
money here if you think you don't need
this book I will say you're not ready
for distributed systems because this
book has a very good explanation of
atomicity sequential consistency vector
clocks how to build graph with processes
and many more things that if you are
just learning the basics of distributing
distributed systems they're perfect to
get started then you know okay that's
how you solve deadlock the tension on a
distributed system cool without failure
school maybe there is a pass and the
author described that pass are all the
books he proved he published later so
hearing his club basically you get money
otherwise you get poor anyway I
recommend this book is that what you
Alvaro approves let's then
fault-tolerant agreement in synchronous
message passing system me a longer
buying books we have without having a
clue it says message passing system so
and it's a fault-tolerant so I need this
book right but it's about synchronous
systems so here all this algorithm
consider there's a specific time for
running each step a specific time for
message passing and so on not like the
real world at least in the air land
let's say rabbitmq react whatever
systems it's useful or not I guess it is
quite useful but maybe not the first
book i will buy actually the books from
this series which is really good the one
I was telling you for from Nancy Lynch
the editor I will them by them as the
first book on distributed systems I will
buy the master I have some theory that I
know what they might be even talking
about but they are quite good because
they go straight to to practice
communication agreement abstraction for
fault-tolerant a synchronous distributed
system so we are getting closer to what
we want here the flp result is discussed
failure detectors and whatnot and
everything is built on on top of that
theory it's a really good book i
recommended algar approved then
distributed algorithm by Nancy Lynch I
think this will be kind of some Bible of
this review system instead of this title
they just should put like the Bible log
on top whatever that is because it is a
I was going to make a joke that came to
my mind but I don't know if how
Christian people is in this country so I
better refrain from it but anyway this
book is really good has a whole first
chapter defining all these models i was
mentioning before so you know what you
are getting into is not like you read a
whole book and then out oops there was
no failure mode now hear you say these
timings the assumption blah blah blah
and then each section of the book which
are quite big describe algorithms on
that section or the other or the other
and so on introduction to reliable and
security video programming this book
also has a very good introduction on all
these smalls failure detectors what not
as a lot of chart like a chapter on
consensus and other more on uniform
consensus I think and broadcast
abstraction I think but the thing is it
talk about secured if you will
programming I think is the only book at
least from the ones i have that talks
about security in the sense how do you
want a decade parties and so on which
most of the books assume the along
cookie approach which is if you have
access to the system you should be
trusted if you don't if you if i'm bad
guy comes there to access your system
and this screws you up and like we told
you to keep that cookie secret right
that's the day long way so that book
this book goes a bit beyond that that
those are some assumptions guide to
reliable the Sevilla systems I present
the book
because I'm not in the US why you may
ask the author of this book cannot bear
man in the eighties created a protocol
called Isis so I'm pretty sure he's in
some lists like blacklisted like what is
god this guy is talking about Isis in
fact Isis was one of the first protocol
solving consensus on broadcast and
whatnot but don't Google don't Google
that because you will get in trouble but
the cool thing I mean what he build was
used the stock exchange and four
airplanes traffic control and stuff like
that so it's something that was in the
it's the last book so I'm finishing it
was used in practice for real in the 80s
and this was all before back sauce and
all this research came about this book
has kinda ten chapters describing all
the evolution of groups membership
systems which need to have consensus how
we reach back sauce and how we reach the
current state of the art I highly
recommend this book just for those ten
chapters before talking about cobra and
other things replication
state-of-the-art replication very good
book by it last slide don't kick me out
finding non-pay wallpapers a big problem
is how you get the papers usually this
may be too obvious but the problem is
that if you know the author is just go
to university page usually that pay
wallpaper is there so sometimes it works
sometimes you need to receive resorts on
to some other out of the low weights
conclusion it's a deep rabbit hole has
he brought is already its computing
science where science is still a thing
here you cannot come up with a consensus
algorithm and people with a a cool know
they will ask you what about boxes what
about the ice is what about this what
about that because it is a corpus of
research that people respect that's
something I really like about this area
the history of the field mothers and
again breathe breathe and read thank you
very much
I would like to add about finding
paywalled papers is that contact the
authors if nothing else works people get
flattered and we'll send you copies it's
good way of getting out any questions we
have perhaps time for very short
question thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>