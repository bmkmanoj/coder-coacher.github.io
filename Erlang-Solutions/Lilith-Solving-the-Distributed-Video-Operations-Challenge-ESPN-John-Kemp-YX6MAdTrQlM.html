<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lilith - Solving the Distributed Video Operations Challenge @ ESPN - John Kemp | Coder Coacher - Coaching Coders</title><meta content="Lilith - Solving the Distributed Video Operations Challenge @ ESPN - John Kemp - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lilith - Solving the Distributed Video Operations Challenge @ ESPN - John Kemp</b></h2><h5 class="post__date">2013-04-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YX6MAdTrQlM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I had spent some time working on some
Erlang projects that were essentially my
own playing on my own outside of work
and you know part of my thinking about
this is that you know nokia being a
finnish company in Erlang being a
language invented in sweden the fins in
the Swedes don't really get along for
any of you who know I sake at least so
nokia didn't pay very much attention to
my Erlang hacking because it's a Swedish
thing so in all of that time I spent a
lot of time doing web technologies and
working with JavaScript and in
particular I was working in the early
days on server side JavaScript because
in those days in 1997 no one did
server-side JavaScript at all apart from
Netscape with their livewire server are
now server-side JavaScript of course is
cool again although it was never really
cool the first time it's now very cool
with node and you know at ESPN and Nokia
and many other companies people are
using know to do a lot of things and so
one of the things that was interesting
to me was to say okay we've been doing a
lot of stuff with no Jas so what about
doing something in in Erlang and you
know in addition to all of these things
i'm also new at the Erlang factory and i
tried to come here twice before while i
was at nokia and of course because of
the anti swedish bias i wasn't able to
come here twice before and now i decided
to make sure i would actually make a
presentation and submit a presentation
and then my boss absolutely couldn't
argue with me so here where i am and
this is Lilith so basically as I said
this is something that I basically came
up with from nowhere I've been
interested in in react and react core
and Erlang for a number of years and so
I wanted to play with those things so I
decided what could I do that would
actually be related video so I came up
with writing a proprietary protocol over
web sockets and then i would use react
core to store all of these video files
in a distributed way across the number
of different servers and then have a
JavaScript client that would playback
this video upload and play back the
video now Lilith I can't even remember
how I started with this name but Lilith
is a mythological character from
Mesopotamia manned then Hebrew mythology
the picture is actually of something
other than Lilith I found out afterwards
found this nice picture of Lilith it's
Ishtar or some other mythical creature
Lilith is the controller of demons
within her own tree so I thought that
was sort of appropriate for controlling
my set of video demons in a tree of
erlang supervisors so here we are this
is an experiment this is not anywhere
near ESPN production systems at all in
fact this is as far away from ESPN
production systems as you can imagine I
didn't actually do my own science i'm
really not that smart but what i did try
and do is just try and do random things
and see how i would feel about
programming in erlang Howard feel doing
this particular thing whether web
sockets and video would go together in
any reasonable way whether react core
would actually do what I wanted it to do
it was an experiment and by its nature
that means I really wanted to do this in
a sort of exploratory programming way
and partly that is because of
understanding a little bit about Erlang
and the fact that you can use the
console and so on it has some ability to
be interactive with the the running
program so I thought that might be
helpful so that leads me on to the why
of all of this why do I bother doing
this so part of this was just an effort
for me to learn Erlang at all and some
part of this is also how do i use react
core I've known react for quite a while
since react was actually a start-up and
has only a small number of people and
I've read about react or and I really
wanted to see if I could use it for
something useful
and this is my attempt to do that I've
heard that cowboy is very cool
especially from Luke who's told me that
it's very cool i've been using cowboy
web sockets because i've done a lot of
other stuff in web sockets protocols
using node and other systems in the past
and then finally you know i really
wanted to try and do something that ESPN
actually does which is to work with
video so what i believed when i started
was that because Erlang is a functional
language that that I would get some
benefit from actually it being
functional on its own so the functional
paradigm itself would make this
inherently paralyzer parallelizable and
distributable a process-oriented model
the same kind of thing because Erlang
supports a very nice process oriented
model has a shared nothing architecture
and so on well I thought these concepts
would actually help me build a nice
distributed system without having to do
too much hard code it's for you you know
and these these are basically my
assumptions so this is before i started
with the limited knowledge i had before
i started working on this system and of
course you know i work with the team of
people we all work in a number of
different languages and most people look
at me and they go why would you want to
work with Erlang i mean like it has
stuff like semicolons and gone away or
they're only in this position and comma
zero and other position and then they
have periods or dots in another position
depending on how you want to end your
statements why would you want to do that
I am having some mouse control issues so
the basic protocol that I engineered is
written over web sockets as I mentioned
the WebSocket allows you to send both
textual as in encoded over the wire
messages as well as actual binary data
over the over the network I did that
because I thought it would provide more
performance than HTTP and mime uploads
and so on and using the event based web
socket model on the bra on the browser
client-side is both actually quite nice
to use with the browser callbacks and
it's also something for which there are
a large number of examples which meant
my client code could be relatively easy
to write so that's the first part that I
tried to do as I mentioned this is kind
of an exploratory programming effort and
so the first part I did was I wanted to
get my web sockets working between the
browser and the and the server and with
cowboy that was very very easy indeed so
basically you just write this dispatch
table and invoke one of a number of
handlers based on your incoming requests
and then you write the handle messages
that actually do something here and
there's a nice pattern matching going on
here saying I'm pattern matching for my
binary web sockets and this is what they
should look like basically so that was
really very simple indeed react core was
a little bit more complex so react core
it's not the same thing as react key
value stores so I'm not using a database
here at all so react core is a separate
library that the react key valleys
stories based upon that implements the
notions that come in through distributed
computing such as having a quorum for
your reads and writes in order to read
and write certain replicas all of the
abstractions that go along with the cap
theorem I don't know if anyone has
either either knows his stuff or doesn't
know this stuff this is probably not the
talk where I'm going to go through at
least my meager knowledge of
of those concepts but suffice it to say
that react core implements all of these
particular architectural abstractions
which means that you can build
distributed systems on top of it that
are not key Valley stores so they can do
other things and in my case I'm storing
video files it's a lot like a key value
store but not exactly the same but it
has a lot of advantages to doing this
sort of thing and these advantages are
as useful in video as they are in
anything else now a lot of people might
say well Erlang provides a lot of this
already doesn't it doesn't it provide
all of this already like distributed
fault tolerant single point of failure
missing systems and it does provide a
lot of the underlying functionality that
you can use the react core provides a
bunch of other things on top of that
like this so this is my horrible I
didn't know how this would go across in
terms of a slide but it's my back of a
napkin sketch because I'm really bad at
doing powerpoint type things on the
computer so I apologize for that so for
what i was doing this is basically you
have my clients here which is a web
browser it makes requests to these
coordinating processes and these
coordinating processes then figure out
where to send requests in this virtual
layer so called virtual nodes now react
or has this notion of a ring of virtual
nodes 2 to the hundred and sixty a--the
potential virtual nodes on a ring that
are partitioned to accept data these
virtual nodes can be brought up and
killed without affecting the overall
state of the system in terms of it's a
failure so this virtual layer is really
a very nice abstraction so the first
thing that I had to do was to work with
the virtual layer and implement my
virtual node code and then these virtual
nodes as you can see map to a physical
layer which is physical machines and the
coordinators coordinate all of the
virtual nodes so
the TLDR is go to ryans as s keys try
try try blog and you'll see a series of
templates you can get for actually
starting off with react core based
systems and I use those templates myself
to do this and you start off by writing
a react corvy node which essentially
means filling out some handle command
operations so basically filling out
templates for these handle command
operations and then implementing your
own API so your own API is basically the
set of commands you want your actual
vino to handle so in the reactor core in
the rear kV case that would be things
like a gat and a put in my case it's
play a video or upload a video and that
command set is basically your interface
that is then offered by your system and
because of the fact that Ryan did a very
nice job with his templates this allows
you to deploy and start running a
cluster actually really quickly it's not
quite that simple so yes I did my vinodh
implementation and I implemented my API
and everything looks nice and then I
started calling the API and that all
looks good but V nodes on their own can
die and lose data so on their own they
don't do very much so in addition to
that you need to do a few other things
so once you've done your vinodh and
you've implemented this handle command
operation there's actually as I say here
there's lots I didn't understand here
yet and haven't implemented as a result
so for example there is the notion in
these distributed systems of hinted
handoff whereby you get a piece of data
that was actually meant for another node
but that node was down so you dealt with
that data but now you have to tell the
other node hey I got your data you need
to be updated to get this new data all
of that stuff for now I left completely
unimplemented so I didn't fill out all
of the more complex parts of this react
core system
and V nodes need supervision so you need
to do something when they die in order
for this to be fault-tolerant so
something else you have to implement is
this coordinator now the coordinator is
something that actually talks to the V
nodes and figures out which ones are
actually going to store or retrieve your
data so if you think in the get case
it's going to go get data multiple times
once from each vinodh potentially and in
the put case it's going to put data onto
multiple V nodes right data to multiple
V notes now something needs to figure
out which V nodes exactly it's going to
put the data onto or retrieve the data
from and the typical way of dealing with
that at least the way that react core
does it is or react kV does it also is
with this finite state machine so I had
to start by writing a finite state
machine Erlang offers this gen fsm
behavior that to some extent helps you
write a finite state machine or at least
organize your codes so that it looks
like your idea of a finite state machine
so my back of a napkin finite state
machine is up on the board these
operations in it prepare execute then in
a waiting state and then you're done so
there's not I don't have very much to
say about in it and prepare here other
than between prepare and execute you
have to figure out which nodes you're
going to send your request to and then
the request can be executed and then
once the execution is done you are in a
waiting state until you get back
responses from all of those V nodes now
this again goes back to another
foundation of distributed computing the
cap theorem and the nrw values the
number of replicas you expect reads and
writes to occur on before you account
the transactions being finished and so
you're in this waiting state and then
once you've got back the right number of
responses from your V nodes then you are
done
this is not the only thing I expected to
do with my system I had hoped to
actually spend some time looking at the
media files and writing an F or a port
or something else to get the metadata
from the actual file and then basically
store that data to I didn't have time in
the end to finish that work and I had
never written an F before until I came
to this conference where homer yesterday
got me writing an F on top of a
Raspberry Pi running Erlang which was
very cool this was this this was
unexpectedly hard for me I didn't expect
that I would have multiple different
ways of doing gluco between C or C++ and
Erlang and not knowing yet how important
it was whether my C code would crash my
Erlang process I didn't know which of
those options to choose but anyway so
what I ended up with was a system that
looks like this again I can't tell
whether anyone at the back and actually
really see this but my client is doing
plays and uploads to a WebSocket server
which is cowboy and you can see the
little cowboy hat there so you know it's
really cowboy that then calls these
finite state machines one for upload and
one for play which then route the
processes to different V nodes and these
are all Erlang processes at least from
this point onwards and so they're all
supervised as well so I wrote
supervisors for the ones that aren't
cowboy and I have to say that it was
surprisingly easy and mostly it's
surprisingly easy because there are
other examples out there of doing this
which I will mention later so you know
what what am I one of my takeaways from
all of this well my takeaway was was
that I was really struck by Erlang
basically I really enjoyed having done
this work but they were certain that a
number of issues I sort of came along
along the way the first of these is that
it was very difficult
print things out so I do unfortunately I
debug by sending print statements out to
a console because I'm still rather
primitive like that and using i/o format
and lager debug was not as easy as they
would have hoped now partly the reason
for that was the Erlang's way of dealing
with types or not dealing with tights
sort of led me load me into not
remembering what it was that I was
actually trying to print out in the
first place so I'm like is this a list
or is it a binary oh I just forgot and
partly that's a good problem to have
because it was just much easier using
that way of programming where I did a
lot of programming without having to
really be too aware of what I was
programming against comes back to the
mod adds I guess we were talking about
this morning there were cases though
where I had trouble seeing that there
there are terms or atoms that were
defined in particular places where I
couldn't tell where that fit in the
distributed architecture so if I put a
different value in here with my system
still work it wasn't really clear to me
so there were lots of cases like that
which was sort of difficult to deal with
i was using rebar for this because all
of these multi-core templates are done
using rebar and rebar seems to be sort
of becoming standard as a make system in
some way for Erlang but that wasn't
totally clear to me either I also had
some problems actually getting it
working in particular with trying to run
a system and also compile in quick
succession rebar make dev rel had a few
issues as well which I had to deal with
regarding parameterization of a multiple
nodes setup so when I tried to cluster
things together it was sort of that was
a bit more difficult that I would
imagine and debugging a distributed
system as I will show you when I do a
little demo at the end here was really
not very easy so figuring out some of
the more subtle bugs about one something
being written here but not over here or
why something was broken it's not
tobias in a system like this but it did
work and and as i mentioned i was really
sort of thinking about this in terms of
well we're working with node here at
ESPN as well as other systems how am i
doing here am i able to do something
real here within a finite amount of time
and I sort of have a sideways answer so
you know JavaScript code is much easier
for me to write and just get it going
and i can write lots and lots of lines
of JavaScript and have it work fairly
quickly and mostly that has to do with
experience but there are lots of things
that I could not do in node and I don't
even know if they're possible in node
and I certainly wouldn't know how to do
them and one of those things is writing
a real scalable distributed system in
node what libraries would I use to do
that and again maybe I just don't know
the answer to that and someone can tell
me but again I somehow don't feel like
it would turn out like a lang and react
or exactly I've looked at the testing on
cowboy web sockets and in general Erlang
web frameworks versus other web
frameworks and it really is clear that
Erlang is great at handling concurrent
web connections and really predictable
performance so it's a really good
takeaway for me any way that I can
really recommend it as a system for
doing web-based video in the end you
know I'm not really comparing two things
that are very much the same node another
lying to me seem to have different areas
where they're really strong and in
particular Erlang seems absolutely ideal
for distributed systems development and
here are some of the things I like about
Erlang as a result of having done this
work so I'm really a fan of this
recursive way of using functions on
lists this seems so elegant to me the
fact that you have a termination when
you get to the empty list and you're
still here then you can say that I
didn't find what I was looking for those
sort of things I think are really
wonderful it makes this feel very much
more elegant than for example if sore
case statements
that you'd see is the the equivalent in
in a imperative language and that leads
me to pattern matching so again the
pattern matching is seems like a very
very elegant way of dealing with with
ifs and cases again I've really enjoyed
programming this way it makes things so
terse and yet elegant I'm not just going
to talk about language features itself
the console turned out to be really
wonderful for me to use so a lot of the
time my programming style would mean
that I would get here I would actually
find a bug somewhere and something would
break and then I could actually just
write statements at the console and
figure out what was going on and if
there was something where I could
inspect values of the variables it just
worked very nicely and this was actually
a nice way of debugging and then also
writing the code which I would then be
able to cut and paste directly into my
actual application clustering was very
easy so this is a cluster of virtual
nodes running on my individual 11 system
so one laptop running three nodes the
templates for this meant that I could
just make dev rel and it would produce
me a cluster of three vinos then getting
that cluster up would just mean doing
the following operations and then
joining them together so then they would
act as the the cluster together so that
was a really nice thing as well so in
summary this looks like a previous
version of my talk but anyway so I'm not
going to talk about data parallelizing
nicely this is just an advantage of
using a functional language but it's not
something that's particularly true of
her laying so list operations by that I
mean operating on a list of data and
then running map and reduce operations
on them is good I didn't really do that
here so I had actually removed this from
some version of my talk but I guess I
gave you a previous version using the
console was wonderful for programming
and debugging I really enjoyed that
and you can see the rest of these these
particular items now you know that the
question really becomes with all of this
okay so I had a really nice experience
and I built actually a fairly complex
system relatively quickly and having
been more or less a complete novice in
Erlang when I started so that's great
but now what do i tell my boss so at
ESPN we have a very large investment in
Java programming we have a large
investment in many other technologies
that are not Erlang and and I think that
you know when it comes to where we go
with this next then I have to sort of be
mindful that well okay we're already
distributing video in a in a large-scale
fashion on the web why why would they
why would be change that and start using
Erlang and so the next part of my
project is really to figure out okay
what's the story why would you start
using Erlang so I've seen some nice
success in the beginning but now we need
to do a few other things in order to
actually bring this model to a place
where I can really make a nice
presentation and say well now you should
invest in hiring Erlang programmers and
building systems this way more generally
and I still don't have the answer to
that question so let me show you if I
can my demo
let me just check that it is actually
running
it seems to be
okay so i'm going to choose a file and
you can watch a debugger down below if
you really want to and i'm going to
upload this file and that's all done
over web sockets and if i show you my
terminal you can see all the debug stuff
and you can see that some of it actually
failed now what I'm going to do here
what is I'm going to take this because i
need this value here to actually play
the video
and
I'm going to hopefully play it oops oh I
need to actually reload this
bated breath I can tell
course
the demo effect
yeah it says it couldn't open it okay
this is great to go to my first airline
factory conference and then have my demo
not work well I can actually try one I
already uploaded at least we can have
some video playing I hope so one of the
things I discovered right before my talk
while I was actually testing this was
the I do have a subtle distributed
system bug in here only I couldn't
immediately see what it was here we go
no actually
changing as well anyway there we are so
that was my little demo and I'm sorry
the the first attempt failed and then we
had to go with the file I had already
uploaded but in general that's my system
so now I wanted to say thank you to a
number of people because without this
without all of these things I couldn't
have done this and it worked actually
surprisingly well and surprisingly
quickly because of these people and
their projects so basho banjo is
something where rusty Clubhouse who I
believe used to work at bash Oh or maybe
still does was playing music in a
distributed way so it's kind of similar
to the video operation here and Ryan did
these templates for starting react core
applications which make you make the
getting started part easy and everything
else I think you probably know and if
you want to know more about the basics
of the actual architecture there are
many presentations but that's that's one
the one that rusty did about the the
distributed computing is react core is a
very good presentation so I am finished
what does anyone have any questions
more coffee oh sorry yes they were
basically there were two separate
periods of programming so the first
period of programming was to get the
basic system running web sockets and so
writing my protocol and getting the
client talking to the WebSocket server
that took I'd say under two days of
actual programming then the reactor core
part was probably a week of actual
hacking so in total i would say i spent
less than two weeks of actual
programming on this in to basically in
two parts so you know when it comes down
to Erlang's a weird language and you
can't do it i have to disagree i'm
afraid i found this actually
surprisingly easy to work with by the
way i just can't see people's faces very
easily from here because of the light
shining in my face
obviously this is already has
what would be the metrics that you use
so in terms of performance no yes sorry
so the question was about have I done
any performance testing and the answer
is no I have not done any performance
testing but that is my next step because
part of my message is really okay can I
do anything with performance here that's
useful now I don't think my WebSocket
protocol is a real world system but I do
believe that people will do similar
things in the real world web RTC for
example is doing something similar so I
can imagine that hooking my system up in
that way i would get performance that's
the kind of similar to those kind of
systems and that that might be
interesting to test now I was going
there was a second part to my answer but
I forgot what it was while I was
answering the first part but anyway so
no no performance testing yet but that's
part of the next step
yeah well I think one part is the is is
going to be a high-performance
distributed system that scales and its
fault tolerant but the truth is is I
don't really know enough about how
ESPN's existing systems work in that
regard so I may not have a really good
message we you know I'm assuming that
we're already really very good at doing
that so my message may not be as strong
there yet so then you know then the
question becomes what else is
interesting here and perhaps it's
nothing perhaps it's programmer
productivity is really the only thing
but I suspect not but I'm going to go on
looking
so that's I'm not even sure it's
possible in node I don't know how I
would have done this I would have
actually had to think of an architecture
so the I think the thing that's really
interesting is the the react core part
where you know you basically get this
ability to write a distributed
architecture just by writings filling
out templates of code essentially and
the thing is supervised and its fault
tolerant as a result and it just works
so you know like my feeling is is that
that is a big aid to program a
Productivity now if I was doing the
system in node or Ruby or Python or
something else and I'd actually have to
think about what would I use to do that
and how will I do load balancing and so
on and so on and start to me Oh mess up
the physical and the logical parts of
this system and I have to actually think
about how to get started in reality and
you know that maybe because I don't know
enough about node or Ruby or Python as
well but it could just be the this react
core system and everything that comes
along with Erlang is actually unique and
making things like this work well just
comes with the territory essentially and
so it isn't really well duplicated in
some other environment and I think in
some ways I already knew that I mean so
for example like garbage collection
sweeps on the JVM or a really big
problem when you have a network system
so we had you know I've had this problem
before erlang avoids a lot of those
problems so you know it's things like
that where I don't know that I know
enough about either architecture to say
there's one thing really better than the
other but I'm sort of leaning towards
thinking that Lang is ideal for
distributed systems development and so
therefore it should be the first choice
and then you should have to defend why
you use any other language in that
environment but I need to know more in
order to make that argument strong I
think
well did you consider a hybrid approach
like maybe embedding JavaScript
interpreter in react car I'm much like
react Navy does no i didn't but that's a
interesting thing to consider
what would you want the benefits of
using Alan to be what must replace
anything again
well it depends so if you mean personal
aspirations so personally I really enjoy
programming in Erlang and partly that's
because i enjoy programming functionally
to begin with but also it's because
Erlang is good in the distributed
computing space but now you know making
the argument to anyone else is requires
you know much more detailed knowledge of
what it is that you want to do and why
you want to do it so for example if we
were doing a new product so ESPN was
working on a new technology product then
I might suggest you use Erlang for that
product first of all because we can get
something up and running that's working
quickly and and second of all because
the performance is likely to be
predictable and excellent without you
having to do anything special to begin
with so we can make a minimal investment
in hardware for example and get
something up and running that's that's
workable for our system but you know in
truth like I say I don't really know
enough about the real details to say oh
yes I should make this the argument this
way but I'm sort of you know heading
down that path yep
board to go to production for instance
clearly built the demonstration of
Technology
but
well the ESPN has a number of different
systems so for example we have systems
for tagging and clipping metadata along
with video clips for example so you know
the your question about what systems
would I have to integrate with really
depends on well what's the actually use
case that be you that we'd be using this
for now so there's one use case which is
streaming video downloads for example
and that would involve some front-end
web systems and streaming files of some
kind then there are other cases where
you have an internal system that's used
for clipping and tagging video files you
know which system do we want to use this
kind of approach for I don't know we had
so that what systems they'd have to
integrate with would very much depend on
having a real actually use case at this
point and so far that would again be a
very good next step for this project at
ESPN Jared
so the question is do I have more than
one web server or more than one cowboy
server and the answer is yes so I had
actually been prior to the actual doing
my presentation I had this running on
three web servers on three ports on my
local machine which i think is what
caused my problem with the distributed
systems bug of some kind that I found
while I was doing my demo so yes I've
run it both with three nodes on
different ports on my own laptop I've
run it on one on a virtual machine and
one on my regular machine on the same
laptop and then also on three separate
machines so it does indeed work
I'm sorry
you mean storing the videos itself in
react kv me well really i just wanted to
use react core to be honest with you and
to see how i would actually do this if I
were using react core I don't you know
yes it's a relates a lot like a kv
system and you can imagine using a
backend for react kv that would do what
I wanted to do without me having to
write this in react or yeah well
yeah so I think the the part I think the
part that was hard for me was as I
mentioned there are there are several
cases where I were put in a value of
some some Adam and I'd write that value
in there but I didn't know what that
would actually really mean in some other
files but see the same at and repeated
in multiple places in different files
and I wouldn't know well if i change
this will it actually is it does it
refer to something real and like I will
actually screw up my system or do I need
to refer to the same value in multiple
different places does it have to be the
same things like that so there were
things where where the code had gone
beyond its ability to explain itself to
me anyway I guess I would say so there
were there were things like that and
then I think the other part is that
distributed systems debugging is hard so
I don't really know how to actually I
don't have a canonical way of going
through and debugging where my error is
now in meyerland code for the for the
bug that I had while I did my demo and I
think it would be very nice if you could
address things like that in some way so
how do I find out where this went wrong
on the ring and debug that system
properly so that's kind of the thing
that is missing for me anyway any more
questions
sorry I'm late so I might have missed
the setup but was the thought behind
making it distributed system for
scalability
was the environment
yeah so I mean it's sort of the
classical requirements so first of all I
want to be able to scale by adding cheap
hardware and have the system deal with
that and then the other is I don't want
a single point of failure within the
system and the other is I would like to
have the ability to kill V nodes and
bring vinos up and again not affect the
overall system or effect as minimally as
possibly there Theo as minimally as
possible the overall system so that the
question was why you know what kind of
distributed system do you want basically
what were your requirements
anyone else
ok I think that's it</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>