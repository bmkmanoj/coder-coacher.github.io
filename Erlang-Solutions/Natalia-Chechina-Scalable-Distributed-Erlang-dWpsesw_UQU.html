<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Natalia Chechina - Scalable Distributed Erlang | Coder Coacher - Coaching Coders</title><meta content="Natalia Chechina - Scalable Distributed Erlang - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Natalia Chechina - Scalable Distributed Erlang</b></h2><h5 class="post__date">2014-07-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dWpsesw_UQU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi I'm I'm Natali from the University of
Glasgow and today i will talk about the
work that we do in the release project
which is a european project and we have
eight partners so we have five academic
partners from UK than greece and sweden
and we have three industrial partners
that these are EDF airline solutions and
ericsson in particular i will talk about
the work that we do am a glasgow
university heriot-watt university and
katie universities so and that is about
as callable a scaling distributed Erlang
oops I'm sorry doesn't listen to me
right
alright
something happened with the slides for
some reason the van just switched
forward sorry yeah let my question right
so our brief Leonid years the release
project for those who haven't heard
about it that and I will talk about the
limitations of distributed early and why
won't we want to scale it and then about
scalable distributed airline so it's
really about what we do how we do and
why we do those things and I will not go
into too much details rather will give
you a flavor what's happening and why we
do that so first of all the release
project the release project is about
scaling real arm scaling the radical
actor model and that is about building a
reliable software on that massively
parallel machines and here we talk about
something like 10 to five calls for that
we use airline and we use on three
levels so we work on the vm level on the
language level and with tools and i will
talk about the language aspects so and
this is the typical hardware that we
kept in mind when we were thinking how
would we scale Erlang so first of all
that is commodity hardware with the
non-uniform communication and then we
thought about something like so we have
closed and we have caught a service
something like 35 service service /
cloud and then each serve would have
something like 100 hosts and those hosts
which contain those modules and each
module would be as SMP more deal with 68
pause so distributed along well first of
all this famous famous picture so we
have hosts Visser blue oh I'm sorry
yep we have hosts and a host I can have
multiple number of nodes and then they
have multiple calls and we have
processes inside but the thing is that
they can we have a fully connected
network of course we can switch that off
and we have can have hidden nodes but
here we talk about normal nodes with a
fully connected network and another
thing about distributed Erlang is that
we have these explicit placements so
when we want to a spawn a process on
another note we need to explicitly say
which node we want to spawn it and that
that's fine ofcourse distributed erling
is also about reliability and this is
the react benchmark so what we do we
have our nodes and then we just killed
some of those nodes and the system and a
stable state then we get those nose back
and the system in the stable state again
so react this is a DBMS a distributed
database system and the user line and
they use this reliability modem so what
what's the problem what's with
limitation along scales well the
problems are for example with this
global namespace so for example if here
we use global module then as soon as we
start registering names there then we
get into problems and here this this
picture it shows a de bench which is a
modification of Basha bench and we have
a fully connected network and we have
this tiny tiny rate of global operations
and then we can see how the performance
so here we have throughput number of
nodes from ten to a hundred and then we
can see how with even point zero zero
five percent of global operations the
performance start rotating and of course
mobile operations they are not only
about global module there about for
example using RPC calls and multiple
nodes and these are also global
operations another problem r is with a
single process bottlenecks so we run an
experiment with react and then
we have again throughput we have 10 200
nodes and then we can see that it scales
beautifully up to 60 nose and then there
is some stop at 670 nodes and then the
performance goes down and by the way
this is rayon 11 they did some
modifications that unfortunately we
didn't matter that anymore but the thing
here that the there was a huge problem
with a single process bottleneck there
and we think also do to alter all
connections so our design approach well
when we need to scale a system we need
to scale our first of all persistent
storage and we need to scale in-memory
data structures and then we need to
scale the actual computation so well
well the rack and Cassandra they're
quite good with scaling those things
though we'll leave that to them and then
in memory structures and here we talk
about Ed's tables and this work is
tackled within the release project and
absolve and Ericsson work on that so our
beat is about computation and here we
had those design principles how we want
to approach that and that is about
working on the o-line level as far as
possible then we want to preserve their
along philosophy and our programming
idioms so Owen philosophy it's about let
it crash and then no church are nothing
and then we want to keep the
unreliability model and change as far as
possible so these are three main design
principles that we kept in mind when
thinking about scaling and stupid it
along so what is a scam as dr well as
real lang is a small extension of
distributed along modest one and here we
looked at two parts so the first one is
about network arm scalability so we have
this problem that we have a fully
connected network and what you want is
to reduce that and this reducing all to
all connection and reducing the shared
namespace and we tackle that but by
introducing as
by grouping nodes and then another
problem is some exquisite placement so
the problem here is that it's fine if
you have a small system and you know
every node in that system or if you have
a highly structured system where you can
automatically can know the nose but what
if you don't then then it becomes a
problem another problem our edges are
portability so we tuned the system for
one hour hardware architecture then we
moved it and then we need to tune it
again so some explicit placement it's
else about tackling the portability
issue so network scalability first of
all we group nodes into as groups and
then we have two types of nodes so it
isn't by introducing as groups we don't
wipe away the distributed system so but
as groups is about using providing
programmers additional to and that is
grouping nodes in turn into some sort of
groups so we have a free note and these
are actually distributed along that and
they can be hidden and then can be
normal and they have just the same
properties as they haven't distributed
to go on and then we have as group nerds
and s group nodes is are the nerves that
belong at least 21 as group so the
feature of as groups is that they are
overlapping so and node can belong to
multiple groups and so the thing here is
that as nodes in the as groups has
transitive connections with the note
from the same as groups and non
transitive connections with other nerds
it doesn't matter whether they're from
another as group of three nodes so non
transitive connections so in this is
just an example how it works so we have
two groups of nodes there's a free nodes
and sir and their petitions so we have
one two three connected and four five
six can act it then for example we
connect node 3 and 5 and then what you
get is a fully connected network when we
have nodes in in as groups there again
transitive connection within those
groups so they just performed just the
same as those nodes
but when we connect snows three and four
they don't share connection so it just
stops them so what's that what types of
connections we have between those nodes
well we again we still have our free
nodes and they behave the same way as in
distributed along so they have fully
connected a network transitive
connections a shared namespace then we
have those hidden nodes and the hidden
nodes they don't share connections so
when the established connection that is
just direct connection and they don't
tell other nodes which other nodes
they're connected and each hidden node
it has its own namespace what what it
means so if even you use global module
for example to register name it will
just stay there it doesn't matter
whether it's connected to other free
free nodes any nodes doesn't matter they
don't share information and then we have
our as group nerds and they have
transitive connection within nodes and
there have an old namespace but they
don't they don't share this information
with other nerds so again and here the
question we are very often gets so why
ask groups well we considered a number
of approaches here and during these two
days we heard other approaches that
people use for example using hidden
nodes and then just establishing their
connections or just switch all of this
transitive connectivity and just again
connect now to each other so what you
wanted is to preserve along philosophy
and this philosophy is that any node can
connect to any other node so any node
can directly be connected to any other
and then we want to reduce to add and
remove nodes to the as groups really
quickly so by quickly I mean with no
pain like Ed remove fine and then we
wanted that those nodes could be able to
belong to multiple groups and we wanted
this mechanism simple we didn't want
something complicated really so we
considered group grouping knows using
the hash values but the problem with a
hash values was that
when we started adding notes into
multiple as groups and removing them so
when we have those dynamic things so
when we add nodes group do we need to
change the hash table would what do we
need to modify how how would it work if
nodes belong to multiple as groups so
probably there is a solution that but we
still just didn't see it probably
somebody later already is we decided not
to go that direction then we thought
about hierarchical structure well that
is quite straightforward right it's
something like from DNS we can think
about something like that oh we can
think about like those tree structures
when we have a class and we have a cloud
and have multiple clouds we can see the
tree structure over them but the problem
with this that it contradicts these
philosophy of direct directly connecting
nodes so if knows are in hierarchical
structure they just can't connect notes
from different hierarchical level so we
decided not to go there so what we
introduced our overlapping as groups and
using overlapping as groups allows us
first of all group nodes in petition
like for example global groups so we
just know knows just don't overlap and
then we get this partition or we can
build nodes in a hierarchical structure
or in any actually structure that we
want so what can we do with those groups
well as I said we can group them into a
hierarchical structure so for example we
have knowed a over here and we want to
send a message to node n so what happens
is that first of all are we partition
the whole set of nodes into as groups
then we take one note from each group
and we connect them so creating
something like this like hierarchy and
then one note from this one we can act
with one note from thatÃ­s group and
what we get is that when we want to send
a message from A to M ay send message to
be than to d e f and sir messages can be
routed like that but some people can
introduce a simple another system
so probably they don't want this streaks
hierarchical structure may be the one to
introduce redundancy in that system so
they can have multiple nodes for example
here on this top level multiple gateways
and then multiple nodes here and they
want to communicate with free nerds so
that's also possible if they want that
all some people may not worry about at
the number of connections they have but
they are really worried about the
namespace their share so what happens is
that we have this largest group and ask
the in that age group we just register
some names that used by all nerds then
we we have another group a bit smaller
that contains notes from a smaller group
of nodes and finally we have just tiny
tiny group of nodes that have specific
information maybe it's often updated or
something like that so we can do that as
well so as group functions we can add
new us group we can remove us group at
add and remove knows from as groups and
then we can't there are some additional
there are some additional function so we
can collect information about as groups
about knows which as groups it belongs
which names we register and so on so all
kind of additional functions so what
about scalability well this is again the
same example I showed in the beginning
when we looked at different types of
different percentage of global
operations that we have in the system
well in the in the global using as
grouped it shows that actually it helps
yeah the scalability improves and just
to show you how we construct you those
rybka we can users groups I'll go
through an example this is an orbit
example so it's it's a closure symbolic
a computing colonel so it's a
generalization of transitive closure
computation and what it does actually so
we take a given space from 0 to X and to
this space we apply a set of gin
raters and this generators they create a
new list and we continue this process
until no new numbers are generated so
this is the example so for example we
have all right so why obits why I
decided to use orbitz well first of all
that it is a simple structure for
example like reacts it has this
distributed hash table and which is
similar to at no SQL DB menses and
another thing is that its peer to be
connection so that's that's also quite
common feature of distributed along
applications and the last thing well
quite important one is just a few
hundreds of lines of code so we can
easily understand it explaining just
around the first experiments with it so
we have known distributed along we have
one node and we have a master process
and we have worker processes so what we
have is that master process its creates
the first generates the first number and
it's sponsored and the worker process it
checks whether this number is already in
the table and if it's in the table then
we just terminate the process then two
other results back to the master and
that's it if the process is not in the
table we put the process in the table
apply the set of generators we get in
your list and repeated the process from
the beginning so here we have spawn just
a spawn and we have a set of those
modules then we want to do a distributor
to airline so now we put our master on a
separate note and workers on the
separate note so the thing here is that
the table it became a distributed table
that it's not kept on one node anymore
but it's rather distributed hash table
on multiple nodes so when we are the the
master node it's again it generates a
the first number but now it takes the
hash value of the number say and this
hash value defines to which node we need
to spawn this process so we for example
spawn into the first node
then again we check whether the nerd is
already registered and if it's not
registered we put it on the table
generate the new list of numbers and the
process repeated so the difference that
happened here is that they are we just
modified few modules that is masked and
working out there are minor
modifications and the main thing there
the change that was this spawn link so
instead of sending just to a module now
we send it out with defined to reach
node particular node we want to spawn it
and now we are moved from distributed
allen to SD Ellen so now our distributed
a hash table is on is over all those
nodes so again distributed it but and
master node it again it generates the
first number it takes the hash value but
now the hash value defines not the table
or the final worker node where our
process will be spawned but it's rather
defines the a subgroup wait fogo so
master node generated a master process
generated the number it's spawned for
example to this as group here when it
arrives to the this gateway node we take
another hash value and from this hash
value we define to reach exactly node it
should go and as you can see the
transformation is much more complicated
now so what we get we now need to modify
not only one simple but we need to
modify our two modules again we need to
introduce new new modules that will take
care of grouping take care of funny
functionality of the sub monsters and
Ken team of the release project the work
on the dfac steering mechanism so what
we need to introduce that to simplify
the process if we already have a
distributed along application and we
want to move it from distributed to
scalable distributed along that's the
back and this is the the first
measurements that we've got so we did
measurements from 1 to 160
note and that is around 1,300 of cause
and this is throughput right right and
then the number of noise over magical
ability so the difference if you notice
well the difference is not that large
but on another hand we don't handle that
that many notes either that is 160 notes
and this is a premier preliminary
results that we show you but important
thing to note here is this change so
actually from 0 up to 20 notes up to 20
notes distributed erlang shows better
performance and after that we have this
tweak and scalable distributed along
begins to perform better another thing
to notice here is that note here is that
we don't use global namespace here so
this particular benchmark we don't use
global names here like at all it's fully
distributed so the improvement that we
got here is just because of reduced
number of connections right so another
direction that we work for SD Erlang is
some explicit placement so why do we
want that well as i said before wants
that for possibility reasons we want
because we just a program it can't
expect a program to remember thousands
of nodes in the network and another
thing is about well how we want to put
our processes whether we want to put
them together because they communicate
quite a lot maybe we want to spawn this
process quite far away because we know
that the computation is going to take a
while and so we don't want to load our
own system but we better to be executed
in the cloud or we want some clothes
some just phone it nearby because we
know it will take just a few minutes is
better to be here somewhere so and how
we tackle that well we notice that those
system that they actually have a tree
structure so
something like Rex and then clusters and
then a cloud for example and here we use
a distant function like like this where
it defines the longest path shared
between the root the shared path from
the root between nodes x and y el show
an example so for example nodes B and C
they have to the level is too and so the
distance will be one-fourth but nodes
B&amp;amp;G the shed path is just one so the
distance will be just half and so on so
these are measurements that we did at
glouc at glasgow university her twat
universities and these are our these are
available of class sir and these are
nerds and that's another cluster that we
have them so what we did we measured the
the distance it's actually the main
reason we did it is just to prove that
actually the communicate we can rely on
the communication time as some sort of
identify that it's really it's really
works that we have closed knows we have
far away nodes and we can use those
metrics and for that we implement it
choose node function so what we have we
have a set of attributes parameters this
is a list and we did it something like a
least because we won't extend it further
for now we have attributes and we have
as groups we can use them so for example
note three are wants to spawns processes
only to the nerds that belong to group 1
group 1 and group 2 so it can spawn only
note form or we can give attributes to
the Nezzer what sort of attributes
German well it's software so for example
what particular software is available on
that particular node and then for
example hardware so on which hardware a
node is running or for example some
properties of the known right this work
it's I don't know server what sort of
note that is we can give our all sorts
of attributes there and then we have we
can choose a note from just saying for
example I want this set of attributes
and I want to spawn to any node that has
those attributes and another thing that
currently were working on is about
distances so for example we want to
spawn the process to note that nearer
than our point zero four or something
between point zero five and 10 and 7
something like that another thing that
we did was about defining as group
operational semantics why do we need
that well because we want to reason
about our scripts want to see the
properties want to see what's happening
there and for that we need is semantics
and we introduced semantics for 16
functions nine of those functions change
their state and six of the functions
they just return a value but don't don't
change actually any state and this is
our semantics so we have a set of groups
as groups a set of free our groups a set
of three hidden groups and a set of
nodes and every group is defined by a
nose so all of those nodes are defined
by notes but free hidden group consists
of only one node and every group has a
namespace but a free are but as groups
they also have a name free hidden groups
and free normal groups they don't have
one and knows they have no DG type then
set of connections and group names that
belong to a nice property that we can
see immediately from here is that a node
can belong to only one group either it's
a nice group node or it's a free normal
nodes or it's a preheated nerd so if we
see this there is some sort of
overlapping then there's definitely
something is going wrong all of them so
this is how our transition semantics
looks like so we have an initial State
reply command on a particular node and
we get a new state and we get a value
just to give a flavor what's happening
there and how we introduce that
I'll give a simple example with a
register name so we register name on as
group they are in an hour's group give
it's a name it's a bit and it's either
registered or not registered so we
initially we have a set of groups
instead of free groups a set of three
hidden groups and a set of nodes we
apply register name function as group
name name bit unknown ni and then we
check whether this particular node
belonged to defined group if it does
then we check whether the name or peter
already registered if they're not
registered then we register modifying
the namespace and return the new state
and the value otherwise just the same
stat and we don't register anything so
how we check that it actually works how
do we check that our functions first of
all so that we implement it work and
then the mathematics that we wrote for
it actually true and the thing that they
can correctly well what we did we use
Greek check fantastic too so we have a
command as group command and now we got
our we go into two directions so first
we run the real system we apply the real
we apply the function in the real system
and we get a new stage and then we do
just the same but for the mathematical
part so we apply our semantics take our
abstract model some abstract state and
we get a new state and then we we check
those so they should concur if they
don't that something something went
wrong this is an hour precondition for
example 41 Action News Group so the
precondition hear that well as groupid
it can't be empty there should be at
least one node over them and post
condition is looks like this so we have
abstract state and abstract result and
we apply the function we take the state
and our abstract a result should be the
same as actual result and our state
should be
name is our abstract that that's how it
works so our future work well first of
all that about some explicit placement
we think that that's really really nice
property that SD erlang should have will
have and really work and on that so
first of all that's about abstract
interface and that is well I showed you
those numbers how we calculate how nodes
are close of further away from each
other and probably programmers don't
want to handle that information right
it's quite quite a lot like knowing ok
this is on 14 10.4 that is 0.2 what we
may want to have is rather something
more straightforward something like very
close or far away something like real
terms over them and then um another
thing is that currently what we have is
that we have a configuration so our we
we have this configuration file and it
tells us how far knows our from each
other and of course that that's not the
thing because we have a dynamic system
and go and fall and they come back and
want the system to recognize to see
their the real system rather than
something abstract and another thing is
about reliability and here is about
again about for falling nodes then they
come back first of all how we discover
them and then how they impact on our
structure because for example if you
have a three level structure we add
additional nodes example we are
connector cloud and then we have a full
level structure so how we deal with that
we are looking at those problems another
is running some dhasku so those of you
who attended Salman stock heard about
sim jaska this is a simulation engine
that was developed and maintained by EGF
real life application that requires a
lot of a lot of computation in
simulation so once you run it in a blue
jean which is approximately 65,000 cause
and we work on implement first of all
running now I simply asked on the blue
jean and then just refactoring it using
our as groups to check how the
performance change but it helped and how
it helped well another our ambition is
that as de long to become a standard
Erlang we also work on that and that is
about testing just now so to prove that
actually our library that we wrote is
it's worthwhile it's people can use it
and they better use it so that's what we
need to convince OTP team another thing
is myth a lot a methodology because
refactoring it's not as like
straightforward as it falls for example
from non distributed along to distribute
it Alan because now we need to introduce
those gateways for example and now the
for example even we have something like
a master and a slave for example nodes
then those stop masters they have they
take functionality from both so for some
application that can be quite easy you
can just put submersed in the middle
it's acts as a root we can implement it
as a library but and that's fine but
some for some application that can be a
problem so we also work on how what what
are the scalability principle would
advise we can give what tips how to
refactor problems systems and of course
continue to work on the SD Alan
semantics found that you know writing
semantics for for the language it's
really great first of all it helped us
to look a bit differently at the
function that we wrote it helped us to
find problems something we didn't notice
it made us look at the consistency so it
was really helpful and then of course
quick check using quick check was really
really helpful because again we found
problems we found mistakes in the
implementation found our mistakes in
their mathematics that we did and some
inconsistencies when we used both of
them so it was really really useful
right so these are some sources that
some of you may found find useful
general information about the release
project then github repository so please
have a look at SD Erlang any feedback
will be very much appreciated than de
bench orbit so this is a this a
benchmark that we are working on but sep
two is that will be used to refactor and
to look how applications work then bench
l and c me simdi ask assimilation engine
for those of you high who interested in
this kind of applications so thank you
and while feedback will be very very
much appreciated thank you questions
comments
is it is it possible to change the group
the DEA's group structure like the
application might want to decide that
you know it should be ideas group yes
yes we implemented a few so the way you
can start an older arm I would say can
join as groups two ways first of all
that is configuration so for example if
you expect that your as groups then the
structure is not going to change you can
define that in the beginning in the
configuration it will read it it will
structure you and then later ID if you
want to modify that configuration or
initially you started without that
configuration you have you can use
dynamic functions and you can
dynamically add nodes remove nodes may
be creating us groups if you like so
those functions they are they exist and
they're dynamic and you can do that
during the run time and also when you
choose a note to learn something on you
can specify the attributes it can these
attributes between during runtime of the
system well I suppose so um I mean for
example if that is something about
software if this is a software to be
tried so probably year oh it's about
modules available modules that you have
on the node right so you can load
additional modes modules sorry and then
they become a new attribute so you're
all set and for that we also thank you
for the question I just absolutely
forgot to mention that we have dynamic
functions for HCBS so you can add
attributes you can remove some
attributes so you can also do that
dynamically would love to we are working
on that just now to introduce those
attributes that they could be collected
from the vm so the trium would provide
those attributes rather than because
just now what we have is that a
programmer himself or herself should
like ed or remove those attributes
rather than those parameters are
triggered during the run time yes thank
you so thanks very much again Natalia
and thanks to everyone who's taking part
in the track today so thanks very much
Thanks so we've got a five minute break
and then back to six o'clock</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>