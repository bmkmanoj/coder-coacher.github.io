<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Of Heisenberg and Hawthorne: Measurement, Visibility and Guidance - Cons T Åhs | Coder Coacher - Coaching Coders</title><meta content="Of Heisenberg and Hawthorne: Measurement, Visibility and Guidance - Cons T Åhs - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Of Heisenberg and Hawthorne: Measurement, Visibility and Guidance - Cons T Åhs</b></h2><h5 class="post__date">2014-05-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/hs4pgQneHcY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay possibly one of the longer titles
of this conference Heisenberg not
measurements visibility in guidance and
the last word possibly should have been
controlled really because that's also
what this is about okay so who am i then
well I can't boast quite as well as long
as a career as a Mike Williams did but I
was actually born when he started
writing code and started writing code
some well ten years after he did doing
functional programming for about 30
years and most of it in a lisp of course
and groups well yes that's where the
name comes from actually soon well what
I've done then I've done a lot of
teaching actually so I can claim some of
the responsibility for some of these
software developers we have in this
country and I see some of them in this
room as well I worked at a university
for a long time and then doing teaching
is of course actually a very good way of
learning something so but but after some
15 years or so I thought maybe I'm
actually done teaching and then maybe I
can do something now as well so I I left
the university and after that I've been
doing things like implementing prologue
implementing the one writing compilers
doing graphic graphics networks
networking speech synthesis some music
notation video decoding some of them
unless plummeting in prolog and somebody
in the sea and other languages so yes
this talk is about technical debt and
then for those of you who are at Mike
Williams talk well most of really agree
with a lot of what he said about how
things can go wrong and I also seen a
lot of things go wrong as well during
the years
so this is a depending on on your view
and what it represents that this is a
sort of a scary slide if it may if it
represents the complexity of your
algorithms because being exponential
isn't very nice you want to okay it's
sort of tolerable down here bearable
down here and scary everywhere else on
the other hand if this actually
represents revenue it's much nicer and
well these are sort of the years for
Lorna starting at two thousand five and
up to now and well yes our revenues and
our growth has been exponential from the
start that's of course ver nice from a
revenue point of view but it of course
brings on its own set of challenges
really and we're running a 24-7 business
where we have to be available all the
time taking purchases and the actual
number of transactions we handle each
day that is number of purchases isn't
really too impressive in terms of for
example comparing the number of
transactions per second handled in a
telecom switch or something like that
but the growth is more impressive so
growing exponential is well that that's
nice and we're still doing it
essentially so this is probably means
that well we are successful and of
course we have a company of some 800
people today and that probably means you
at least been doing they're doing the
right things but that doesn't
necessarily mean that you're doing
things right and of course this rapid
growth comes with with problems so
choosing the right technology and of
course we're all here because we ask you
that or long is the right technology
isn't really enough you can write
something bad in any language and I've
seen bad stuff in sort of most of the
languages I've been working with but
what we have is a very fast growth not
only initially but sort of all the time
so what we have is more merchants coming
in more and customers we're expanding
into new countries and we're adding new
pro products all the time so from the
start we just had the sample invoice
here in Sweden and now we're present in
seven countries with additional products
check out and installments etc etc so
there's a lot of new challenges coming
all the time and actually entering a new
country is also a bit of a challenge
because well in Sweden most of it was
very easy because we have personal
numbers so as long as somebody gives us
their personal number we can get a lot
of information very fast and very simple
this is not true in a lot of other
countries so that poses challenges so
since this track is a bit it is about
being agile and I really liked for those
of you or at Mike Williams talked in one
of his agile slide he actually had a
picture of an agility dog and well this
might actually be that the back side of
being sort of too agile because what
we've had and what we probably still
have it is a very fast pace with a
rather steady flow in and high flow of
new requirements and developers of
course as developers we want to deliver
on these expectations we want to say oh
yes of course we can fix this of course
we can implement this new feature and
well we can almost have it done by
yesterday
and one way of doing that is of course
to well cut some corners here and there
so this will mean that short term
delivery will be more important than
long-term long-term quality long-term
sustainability and of course in any
instance regardless of where you are
you'll try to solve your problems with
your available resources and okay we do
want more productivity and with an
exponential growth in revenue we have a
rather nice inflow of money so we have
money as our main resource so what's
happened is that we've been we've been
adding more developers all the time and
of course having a lot of money makes it
easy to add developers it's not
necessarily a good idea to add more
developers just because you can and of
course this has been known for an
embarrassingly long time so Fred Brooks
the mythical man wants written in 75 if
you haven't read it I suggest you read
it because it contains a lot of wisdom
on how you should and what you should
and should not do and a lot of what Mike
Williams talked about it is reflected in
this book so this was known a long time
ago so essentially well since most most
of you but not all before you were born
but what happens if you add developers
is that after while long term quality
and adaptability will suffer and this
slowdown is gradual you won't see it
that suddenly in one sprint to
one-quarter your productivity just drops
down it's very much like the an audio of
boiling a frog because if you take a
frog I haven't done this experiment
myself it's just read about it but if
you put a frog into cold water and then
turn turn on the heat you will boil it
because it will no notice the gradual
change but if you drop the frog into
boiling water it will do its best to get
out of there so adding more developers
especially if you've cut some corners
along the way means that things will
slow down and if you want to look at
this well you can't just look at the
productivity for the whole development
department you should look at it by
normalizing against a number of
developers you have and there you might
actually see that oh we're actually
slowing down in terms of the
productivity for developer although we
might be more productive as a department
and of course well here you can go into
the discussion about evolution versus
design because what at least we have
done and I haven't been a floor now for
more than about two years but I've seen
the effects of this and I've seen it
continue to happen is well evolution is
a it means adaption it means adaption to
the environment growing market market
changes etc etc and of course having
something to adapt to that's good
because it means you're successful you
have a market that wants your product so
that's nice but
all evolution will leave some kind of
artifact along the way well just look at
the human body we have a most of us have
still have an appendix and ideally it
would just sit there and do nothing and
just be harmless but in the worst case
it will actually cause them harm and can
kill you if it acts up at the wrong
place on the other hand so evolution
especially fast faster evolution will
leave some artifacts on the other hand
if you're doing design well yes this
will carry more purpose and some kind of
sense a direction but of course
adaptability might suffer because you
don't know how you want to adapt in the
future which is somewhat problematic so
it's sort of not just one or the other
it's about being prepared for changes
that might come and especially learn
from it from your mistakes and if you
have some if you see some kind of change
happening more than one time well maybe
you should try to adapt and say that
well this change is probably going to
happen again an example of that at that
Laura is adoption two countries doing a
simple quick and dirty adoption for this
for the first country is ok because it's
sort of seeing well can we do it and can
we make it work and will we be success
successful in this first new country
doing this second country in the same
way is well possibly ok but but maybe
not and after that well you have to
realize that we're probably going to
grow not not only 27 countries but
possibly chem 20 etcetera so that
they're somewhere along that line that
is time for an abstraction and of course
you can't design for every possible
change well as software developers say
of course you can but that means you'll
probably
never ever get anything out on the
market because you're just waiting for
this perfect product and say oh well we
can't actually take care of this change
yet the way we'll just wait a bit so
what we have done is a history of
evolution and adoption at adoption and
after a while so take care of small
children this is a scary picture because
this is what we get no real detail in
this but this is actually a dependency
graph so that this is sort of what what
nightmares are built of really soon and
here is zooming in on some level of
detail we the innocent or are still
protected well sorry the guilty are
still protected in this picture because
what we see is that yes well we have a
lot of dependencies between a lot of
really really small parts and it's a
great big mass really this means yes we
have problems and we have a lot of them
so I'll list some of the problems we
have our dependencies are way too
complex which is very apparent from from
the previous picture we've been growing
very fast and not in a very structured
way so starting out with a small code
base and I do know we have some of the
guilty parties from that small code base
hello Chuck yeah you want
but they s they left in time relating
but what happened was that the the
number of developers grew and the code
base grew and the necessary
restructuring didn't really take place
so you can't manage or you can't have a
small company run a small company in the
same way as well as running a large
company and of course not vice versa
either so when you grow both in terms of
code base domain responsibilities and
developers you have to put some kind of
organization into place this really
didn't happen it was very much when I
came to corona for somewhat over two
years ago that at that time there was
something like 50 or 60 developers
sharing one git repository and everybody
sort of owned everything because well so
I need to do a change here and they did
and somebody else well actually I need
to do a change over here and they did so
ownership didn't exist really everybody
owned everything and the result of that
is that you have a development that
doesn't really scale because you have
all these dependencies and these
dependencies grow all the time the
interconnectedness just just send it
really gets horrible after a while we
had a lot of testing and still do which
is done most of the system level not at
the unit level so the ports are
difficult to test in isolation so one of
the things nice things with a system
like our language is interactive which
can do code loading on the fly is that
you can ideally have very short
turnaround times do a change and see
what happens for my colleagues here at
Florida and
them are in the room know that this
isn't really true for our system we have
a very long development cycle so long
that it's not really reasonable well
doing all the development on on a local
machine takes a lot of time if you want
to really test things so we have to
submit it to some monster machines that
does the testing for us so of course
with long turnaround times the the
productivity goes down as well so I I
could sort of talk a lot very long time
but a lot of code smells we have the
system so I'm going to spare you those
details and there was also rather rigid
cultural development of how development
and testing was done because well from
the start having a rather small system
doing testing at at the system level is
fine but when it grows and you can't
test parts in isolation it doesn't
really work too well after a while and
then adding more developers adding
junior developers they will of course
tend to look at the code and say okay
this is probably a good way of doing it
because they don't have the experience
to see that it's a bad way of doing it
so they follow the existing patterns and
build on the bad stuff instead of
getting rid of the bad stuff and after a
while this means that following these
existing patterns will be much easier
even if you're a seasoned experienced
developer either from outside experience
or within clora you'll see that well I
know that we shouldn't be doing like
this but you do it just the same because
it's so much easier so again this
descent continues and of course what we
have then is a technical dealt and
technical that it's very much like any
debt
take it when people buy a house they
tend to take a loan because they want to
have the house now not just say for like
30 years and then by the house cash so
it's reasonable it's a reasonable
behavior but the bank actually wants you
well probably not actually ideally they
they possibly should but at least they
possibly should want you to pay off your
mortgage especially they will probably
be a bit careful about giving your you
give you giving you more loans
especially if your income doesn't match
on the other hand Drona doesn't really
have that problem they have incomes to
match they are a steady flow of in
income saying okay well we can buy more
developers and our technical debt
increases but sort of nobody really
talked about that i will say hello
management are our technical debt is is
actually increasing somewhat like our
revenue exponentially that's not really
too good and i I'd say actually any
product will carry technical death you
will cut corners hands up if you have a
product that doesn't carry technical
debt no yeah well me neither self and of
course this is due to things like so
taking the loan on the house is like
well we want to get to the market fast
so rather than building the perfect
product now we build something now put
it on the out on the market to see what
happens and of course you will have to
adapt your insights which are gained you
have to change directions now and then
and again this might be it might be
faster to cut some corners it probably
is just to see what happens then saying
well okay we have to stop and read this
the system and of course you never never
actually know we're going from the start
if you're not building something is like
an ADA compiler where you take this
really big specification and says okay
this is what you want to do when you've
implemented everything that's in this
specification you're done so here's a
truth solving technical debt is actually
trivial if you have a time machine it's
just total okay go back in time with
your knowledge and and do it right but
sorry Prime machines seem to really lost
in time like like tears in rain so I
guess we'll have to do something else
about it then and this is sort of where
you have a turning point you have to be
open about your technical debt you have
to say go to the technical data
non-anonymous meeting saying oh hi I'm i
work at clownin and we do have some
technical depth because at that point of
course well I don't have any 12 step
program or or anything like it but
actually saying that you have technical
that will make it more easy to solve it
or manage it at least and this is about
being open yourself actually saying well
I have cut some corners along the way
but also the team as a whole and
management at all levels if you don't
say to management that well we actually
did this feature quite fast and it we
cut some corners a lot along the line
they will probably expect that it was
done according to best practices and you
can build upon it in the future this is
not often the case so you have to be
open to to all involved parties about
this
and in the long run when you're
developing new stuff when you're
implementing new features you probably
know that you're going to cut some
corners either because you have to
deliver on a deadline or management
wants it done really really fast and in
that case I say it's very important to
make it clear to management that well
yes we can do it in a short time but we
will have to cut some corners and we
will incur technical depth so the next
time we touch this this code whatever we
will do will take longer so so everybody
knows that you're actually adding a
technical debt or it could be that going
getting back on the previous track will
take more time than you want and this
increasing technical debt will slow you
down over time but it's not easy to see
it actually because it's gradual and you
might be compensating by buying more
developers if you're successful and of
course even if it isn't increasing not
decreasing the technical depth will
actually keep you slow so this is about
measuring don't guess you're saying our
well we have some technical debt try to
measure it in in some way it's not easy
but I'd say you have to try at least to
to quantify it and if you can monitor
change you can see that you're actually
going in the right direction focusing on
trends rather than actual values might
be more important see that well our
technical debt is actually going down
and that will make us more productive
and especially having a team saying well
we actually see that our technical depth
is going down and then you can
well are you actually being more
productive because of this and well
hopefully they'll say well yes actually
we are because they're hitting less of
these cut corners less of these
artifacts that are left in the code but
measuring is also about knowing where is
you have to focus your efforts it's not
just well opening a file and saying oh
well this is bad I'll rewrite it I'll be
factory to make it beautiful but if this
code hasn't been touched for two years
there's a good chance that it won't be
touched in another two or four years
either don't touch it but that's a bit
that is really about being pragmatic you
can have bad stuff which has been lying
there but if it's not changing just
leave it be because every change you do
will of course impose some kind of risk
on your system and running a 24-7 system
well we want to minimize risks in our
upgrades you can also manage your
technical depth by looking at what's
ahead and prepare the code for future
change well in three to six months we're
going to do this well let's rewrite this
code and see where it goes
and of course this is doing measurements
is Heisenberg and hawthorne in effect in
action so I guess everybody knows about
Heisenberg so this is a small-scale
measurements affecting stuff hawthorne
on the other hand is if you don't know
about him did measurements on our
productivity so this was something like
during the 17th 17th century and they
wanted to measure the effect of lighting
in the environment on and the
productivity of workers so they
increased the lighting and productivity
went up our cool so that was good and
then someone said well what happens if
we decrease the lighting so they
decrease the lighting and productivity
went up okay so that wasn't very
conclusive so the only really conclusive
from that from Hawthorne and this is
actually called the Hawthorne effect is
that well if people know that they are
going to be measured it will affect
their behavior so if you want to do
things like that you have to do it in
isolation you have to hide the fact that
you're actually measuring stuff from
from the people being measured on the
other hand doing these measures can have
what will have effects and hopefully
there'll be positive effects because if
you have a measure you measurement or a
metric you want to look good according
to that metric so it's definitely a well
known fact that if you have code reviews
and they are done in a good way the
people writing the code will actually
write better code because they don't
want to be caught out on a code review
with trivial stuff curry reveals you not
catch the trivial stuff which
can't catch complicated stuff things
that you really didn't think about but
of course and this is the sort of a
backside the effects are never better
than the actual measurements you're
doing every system every kind of metric
you have can be gained in any way so you
have to be aware of that both as when
you're doing the measurements but also
if you're being measured don't focus on
the actual metrics focus on the sort of
idea of the metric what are we trying to
do and as I said before trends are often
more important than single values
because so what does it really mean that
you have 200 or 2000 violations
according to to some rule well
essentially nothing but if you three
months later have 200 violations less
that's probably a good thing so look at
trends rather than absolute values and
things like this like trying to make
everything you try to measure it is very
much long-term short-term absolute
values don't mean too much so you should
well look at trends but also look at
secondary secondary effects for example
if you're working with increasing code
coverage from your unit tests you have
to ask yourself is this actually
resulting in better quality in the live
system is the work effort being done
that does it actually have any effect on
the quality if it doesn't well then you
either have to increase well I have to
look at why are the tests bad or the
test just there to increase code
coverage and of course it's easy to
write tests that just increase code
coverage don't do any scary stuff like
actually asserting
anything in them just run the code they
actually will have some effect of course
because doing measurements is well
running the code at least Joseph's works
in some sense so possible metrics done
without actually trying to define things
like quality and productivity which are
inherently difficult in our world
productivity for core is for example it
is sort of simpler because you can count
the number of cars that leave the fact
to each day productivity for a software
development department is is very more
difficult to actually define and so is
quality and when I talk about quality
and soft with the development it's much
more about the ease of adaption rather
than the perceived quality for the end
user then you can do things like well
static code analysis measure your
dependencies and this is one of the
things of obviously I'm doing access
patterns records for our line well type
checking we have a dialyzer code smells
code courage just some of the things you
could measure so at kelowna we we do
have some tools for this and one sort of
problem airline possibly is that why the
packet or module structure is flat so
any module can access the exported
function of any other module and that
might not really be what you intended
from the starch so we've defined sort of
additional external ases not not any
patches to DP or anything so externally
define the additional hierarchy where we
have applications but they're not
applications in the ordinary OTP sense
but where we call them applications and
an application is a collection of
modules
and some of these modules are for a
certain application is defined as an API
module so another application may only
call the api modules of an application
and if not it we call it in api
violation and of course when people do
that it means they're accessing the
internals of another application and
it's a bad dependency because it will be
difficult to change the internals so
that's that we also have defined layers
in the system and how these layers are
allowed to call each other API
violations are rather rather easy to fix
now because it's about defining api's
and using them layer violations on the
other hand are more difficult so what
this does is it well confuse the call
graph and then finds the violations
according to these rules according to
the defined api's the layers currently
it works on beam code meaning the any
dependencies injected for example
through macro expansion will be a false
positive that is well a false violation
because the source code doesn't have
actually have the violation but the beam
code will so what's the effect of
measuring dependencies like this well
the bad dependencies well for one thing
we try to prevent adding new bad
dependencies so in the long run making
the code while making the code less
badly dependent and thus enabling more
parallel work
and this is done by well for the API
violations it would be done by defining
api's and actually using these api's for
some applications there weren't any
defined ap is at all for labor
violations and we actually have circular
dependencies as well so that's not too
good of course more work because you'd
have to move code you have to refactor
it possibly do it with dependency
injection instead of hardwired
dependencies upwards creating circular
dependencies and nasty stuff like that
we also have a tool for finding what we
call invalid record access so again this
is about bad dependencies but on a very
more detailed level this is about
actually using actual representation of
records in other modules which have not
defined them so its of course the nice
thing about using this actual
representation is that you can do things
like pattern matching and so on the bad
thing is that when not if when somebody
wants to change the internal
representation belonging to an
application or a module well they're
going to see a lot of other code break
because it depends on on some kind of
actual representation
and again this is about at least trying
to prevent additional violations and in
the long run getting rid of these
explicit egger record access violations
to make the code less dependent and of
course we do we measure code coverage
from unit tests right now we're just
doing it from a unit but as said the
system isn't really unit testable
because it wasn't built unit testable
from the start it was built more to just
test on an honor system level so we're
introducing unit tests is slow and is a
bit painful we actually did a slight
adjustment to rebars we can do some more
precise measurements another as well so
some results then well the people at
clora will have seen this not once but
several times this is a graph of our bad
dependencies so the yellow line is the
total number the blue line is the API
violations and the slowly decreasing red
line is the layer violations it's going
in the right direction it hasn't always
gone in the right direction we have
spikes here and there for various
different reasons but it's going rather
slow so this is October 2011 and this is
a today this very sharp dip is very
artificial actually so I should should
really adjust the full graph with that
difference because we adjusted the layer
via definitions at that point so we
but I take responsibility for it but but
it was a step in the right direction
actually was killing off an unnecessary
layer in the system so we started out at
about 4,000 actually 3,900 violations
but it should be noted that these are
unique violations so the actual number
of violations was is from the start
about two and a half to three times
higher because we have several
violations that are identical but we
only count the unique ones and of course
well could we go faster well sure we
could but if we go faster we probably
wouldn't have time to actually produce
something and we have to keep the system
running and we have to produce new
features so again this is about being
pragmatic both in terms of production
and in terms of actually going somewhere
and actually reducing your technical
depth and I'd say one way to do this in
a good ways is to take your development
team and then decide on okay we put
aside twenty twenty-five percent for
reducing our technical depth and that
probably means that you have one person
working full-time on reducing technical
depth it's not about saying okay hi guys
it's Friday let's do some technical debt
and everybody gets to do some technical
debt reduction for one day that will
never work because you won't be going
anywhere it has to be done all the time
and the effect of lowering these the
number of dependencies is that we're
going to we already increasing the
possibilities for doing parallel
development so it's it is actually
getting better so some results then well
we have seen the teams that are working
aggressively with increasing code
coverage they have a positive effect
because they have less incidents in the
live system so that that's a very nice
secondary measurable effect from the
initial effort of actually increasing
the code coverage and I've seen the bad
the dependencies are decreasing and it
also has a nice effect that the sense of
code ownership is increasing we actually
have more than one or faucet or e now
which is nice we have a great number of
them but but we still have for the main
system it's one large repository and I'd
also say that the pride within the teams
he's increasing because they feel that
out this is our code we do work with
increasing cloud coverage and we see the
results and they also see that well they
have less incidents in the live system
that are wrong to them so the perceived
quality of what they're doing is
actually increasing which is nice so
some closing remarks on you will have
technical depth so don't don't pretend
otherwise and you have to let you have
to management manage it if you don't it
will control you by slowing you down and
of course as in any type of optimization
because this is optimization don't don't
guess measure and doing measurements
will have effects you have to be careful
of where you're going so you're don't
just start to game the system so there's
a lot of work being done to make
something look good but
actually doesn't so if we have to
measure in several at seven levels and
one of the most difficult things is
changing culture changing the ways
people work it's not just about saying
well you have to increase your code
coverage you have to make things better
that's very difficult and of course as
said we are running something 24-7 but
we're also now at the same time building
a new architecture to slowly replace so
this is very much like rebuilding a road
with all the car's still running on it
which is a nice challenge but you should
be aware that any legacy system you have
and legacy tends to be defined as code
that nobody really likes anymore so I've
seen people call code legacy which was
sort of just written two years ago and
say oh that's legacy we really don't
touch it but your legacy system will
live a lot longer than you expect and
definitely a lot longer than you want it
to live so even if you are building a
new system you have to take care of the
old system until the new system actually
can take over and more interesting
reading if you haven't read a read up on
the terms second system syndrome which
is definitely a real syndrome it's about
the problem of rewriting or replacing an
existing system with a new one and what
will happen with both the old and the
new system thank you
any questions this Leah dyslexia thank
you it's very interesting talk we have a
lot of the similar problems and it's
quite interesting seeing the way you've
approached it I kind of had send you a
comment and a question you talked about
gaming metrics yeah and i think the
impression that gives is people
intentionally manipulating them i think
it's also worth mentioning that when you
when you set one of these metrics you're
essentially making a statement of this
this is good one one end of the metric
scale is good so you have a sense of
innocent gaming where people are trying
to do good by pushing up these metrics
and I think code coverage is one of the
ones that's very common especially if
you have simple code coverage people
just try and push the number up without
really doing anything useful yeah so I
totally agree so code coverage is what
you can if it's low you know it's bad if
it's how you really really don't know
anything with if you don't start to look
at your tests and I guess guess the
other question was you saw them one of
the slides that if you don't say
anything about technical debt management
take the assumption that you've you
followed best practices and everything
is all good would it not be more
realistic to always take the approach
that you haven't done this refactoring
and that by default you always just
trying to get to the product and that
you should maybe build into your
workflow of an entire step for
refactoring if that's something you want
so it's more visible that when I've
delivered a product I've delivered a
product I haven't I haven't done
cleaning cleaning is something that we
have to state we should do well I did
very much much depends on what level of
management you're talking to because if
it's the level of technical management
especially if they are guys with
at least some experience in coding
themselves they know that there will be
technical debt if you're talking to
three guys which knows a lot about
economics but nothing about software
development they have no idea so we have
to be very explicit towards the upper
level of levels of Management if you're
not as sort of a fully technical company
and Clara isn't thank you and i'm also
looking very forward to the the client I
talk this afternoon about migration yeah
any more questions okay let's go eat
something yeah thank you guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>