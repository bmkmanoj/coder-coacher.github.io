<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2018 - Lisa Passing - Functional Rust - An Exploration | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2018 - Lisa Passing - Functional Rust - An Exploration - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2018 - Lisa Passing - Functional Rust - An Exploration</b></h2><h5 class="post__date">2018-03-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Ve8HUfU3ELQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is my first number days so I
thought I start by introducing myself so
hi I'm Lisa usually based in Berlin
where I do web dev things also hobby
game dev recently turned artist whatever
that means and in Berlin I also helped
organize closure bridge which brings
free programming workshops enclosure to
women and on binary people this is also
how I got into closure a couple of years
ago and I also helped organize crypto
parties which are informal gatherings
where we teach people their privacy
preserving and privacy enhancing tools
for their digital selves so last year
like about a year ago I started learning
rust I've since like been happy enough
to like talk it to rust conferences
already there are not that many so this
is kind of cool and if you've been to
Toby's talk previously like just before
lunch yes I am the other person on the
photo with him in the unicorn onesie but
enough about this about me that's all
about rust the rust programming language
and some like key facts are like just a
few introductory words the rest of the
new systems programming language it is
aiming at the same like realms that C
and C++ aim at Buster's for the more
safe fast and concurrent all of these
three which is kind of cool and there's
certain like mechanisms and rust that
make this possible it's also relatively
young so the first say release zero one
one zero only happened in 2015 of course
there was some like development prior to
this but there was like highly influx
like things were moving like pretty much
all over the place there used to be a
garbage collector which like got thrown
out for example and I like fun stuff and
I think the important part is that rust
is gaining popularity the the community
is growing it's a very friendly and
welcoming community and so if you want
to if you want to like get into this I
think it's fairly easy and you can see
it was like the the ecosystem like
growing and like different aspects or
like some people focus on like
and stuff and like other people like
find the crypto aspect really is really
interesting and there's like things for
everyone I think and this is like just
at the beginning so I think in the next
couple of years it will see more rust in
like all sorts of areas so this is them
two days after all so you might be
thinking oh so rust is actually
functional language is this why you're
talking about it and the answer is like
no it's like imperative multi-paradigm
things are going on and you might be
like so what this is like every other
language like why would I care and only
give you two reasons first of all which
is like one of like the things that I
find important about functional
programming is like in like a paradigm
that is you can still apply a lot of
like functional thinking and techniques
to like even unfunctional languages and
I think this is sort of like the the
superpower was like oh I know how to
solve this problem in a functional way
and then you like heck your way around
it and this is like one of things that I
really like doing if if I learn a new
language and just like see is like oh
would I what can I already bring from my
background of other languages to the new
language and for example it's like one
of these aspects can be functional
programming the other thing is that
rusts in its design like in like
stemming from the from the fact that it
is so young it like drew have the
inspiration from languages that that
came before it and it also to a heavy
heavy inspiration from language design a
functional programming languages we see
we will see a lot of things like
concepts that were like they're inspired
from high school for example and so I
think there's like a certain yeah like
functional core that is like inside of
rust also I think this was like Russ is
a really cool language and I want to
talk about it a lot so I think it's also
useful for people to just like know a
little bit about it because I think rest
is here to stay and yeah as I already
said future is rusty okay and I think
I'm not the the only person who is sort
of just like thinking of like oh yeah I
rust there's some like functional
aspects to it this is a screenshot from
the Humble Bundle website so they offer
yeah bundles of digital things like
games or ebooks for a certain amount of
time and you can like pay what you want
for it and last week or two weeks ago
they launched a functional programming
bundle so you had like two weeks to like
buy like pay what you want for Riley
books on functional programming topics
and if you scroll all the way down on
the page you saw this the brand new from
like the print.you programming Rus book
that O'Reilly just launched on the same
row as like closure Scala and Haskell I
was like okay it's not just me there's
something about it so yeah before we
actually start looking at rest code
though I want to give a little
disclaimer because this is not and it
doesn't aim to be like a talk that
should cover all aspects of Rus that I
really want to like focus on things that
I think are functional there are certain
other concepts that are also very
important and rust but they don't fit in
here there's other talks that you can
watch that cover those the other thing
is that would like I do hope that after
this talk you you will start like maybe
looking into rust and like maybe like
you didn't open minded about like oh
maybe this is something for me the thing
is that the the concepts arrests are
like very very closely like they work
very closely together and if you start
learning it it's it might not feel like
the learning curve is like oh I know
some things and then I learn more things
that's more like you hit a wall because
all of the concepts hit you at once and
then you need to start figuring out how
you can get through this wall the cool
thing is that once you stuff like once
you you have enough or like you learned
how to walk through this wall you can
walk through walls and then you there's
nothing else in your way because you
already know what to do okay but let's
get functional for real I hope you're
ready as a little like guiding thing I
made a list so we can like check off a
few things that I would like to talk
about
I kept the list chart so that it's not
like too too scary maybe it was like oh
my god we're gonna sit here for hours
and hours and
like talk and talk and talk like no it's
hopefully it's it's short and sweet
let's start with the immutability um we
like function languages like immutable
things because they prevent us from like
mutating on over and then like totally
messing up whatever we like stayed we
wanted to have at some point the cool
thing is in rust when you define a
variable the default is immutable so
when you just like this define a thing
it get an immutable thing and that's
nice so here's some rust we have a main
function which is our entry to the
program we create a variable a with the
let keyword assign a string hello and
then if we try to reassign a to foo the
compiler tells us no cannot assign twice
the immutable variable a this is like Oh
Thank You compiler of course like I
already assigned it here I cannot mutate
the other thing is that you can opt into
mutability though so even though
mutability is an option and rest
I think the signal of saying okay the
default is immutable and you can enter
mutability is kind of like the reverse
of other like mainstream languages where
mutability is the default and then you
like have to opt into immutability if
you want so let's all this works with
let mute a we just indicate the fact
okay this variable can be mutable and
then if we were to reassign a with the
string food it would hold food so yeah
this is possible it's not super nice but
what to do
aside from variables there are also
constants that you can use for if you
really want to make sure that this value
will never be touched it will never be
changed and constants are always
immutable he used to come so that word
becomes keyword
it's then written the name is written in
all uppercase and then you have to
annotate type so this is our first
little type annotation in this example
and we say is like after the call as
like after the name
of the constant use : and then we said
this is going to be an unsigned 32-bit
integer and it's gonna be 1000 because
why not and yeah we will see different
type annotations later in the examples
but I thought it's like I wanna like
sneak it in really smoothly and
constants type annotations are mandatory
on variables they are optional unless
you do something really weird and the
compiler gets confused and then it will
tell you I'm very confused
please annotate type there's also an
example later okay so we have this like
so if the default is immutable so we
just like work with the default and be
like never opt-in to mutability so it's
like we're fine
the thing is Russ does not implement
cool things like persistent data
structures so if you start dealing with
like a lot of data and you like start
like copying over like generate like new
things all the time and then at one
point Russ is like okay like allocating
yourself no stairs no stuff and you you
will realize that this comes up
performance cost so eventually you will
just like see is like ah I guess I need
to mutate now whomp-whomp luckily there
is rest of the systems programming
language so you can implement your own
immutable your own persistent data
structures as for example buh deal with
I am arrested this is a library where
you can that you can pull into your
project and just use the data structures
that are defined there they are always
immutable they are like persistent and
it's like nice this is one way to do it
the other way and this is the one point
where I mentioned ownership and
borrowing for the only time in this talk
ownership and borrowing are big concepts
in rust of like how it manages to like
guarantee type safety and it's also like
the guidelines and like the way the
compiler holds your hand while you like
deal with potential immutable things is
actually like it's kind of like your
safeguard was like well this well this
is technically a mutable thing I will
tell you exactly when you're allowed to
mutated and went nuts and this is kind
of this prevents a lot of like like
common errors or like common yeah rabbit
holes are like your data falls into an a
like what did I do and yeah rust usually
has your back with this it's just a big
topic that I will leave out for the rest
of this talk that was the mutability
immutability so we kind of have this
like okay there's like some things were
functional aspects shine through that we
like but like not really but I guess
it's look at functions because
functional programming without functions
is kind of not functional programming we
already saw one function and so far
which was the main function so we have
an F and keyword the name of the
function parentheses and in curly braces
the function body in this case we print
hello world so this is nice but
functions get cooler if we like at
parameters to them functions can take
parameters unfortunately not an
arbitrary number so you like always have
to define how many arguments function
can take in so okay and if we have
parents we do have to annotate type and
this is where rust is later than like
for example and variable assignment is
able to infer type because we know from
the function like what type we expect
and then from like the function is our
sense of point of like type definition
we can then or rust can then like figure
out what other types are needed
okay so let's like change the example
bit I'm also now defining a function ID
which will take a pair of the unsigned
32-bit integer and in this function we
will then print hello whatever we got
dozen as an argument and then in main I
call this ID function for seven this
would print hello seven
but we don't only when I want to take
things into a function we could also
like you turn things from a function and
if a function returns a value you also
want to like annotate type like your you
have to annotate type actually so let's
make the ID function like the actual ID
function so we we take something in and
we just like return the same thing and
both of them are of type of the unsigned
32-bit integer and the return value is
the function signature indicated by this
little arrow that then points to the the
type that we expect and then in main we
call hello and then call ID 7 so cool
question what is the function return
this is something that I confused me a
lot when when I was like starting to
look at like rest code it's like if I
put up the bed put the example back up
it's like ok ID returns X but like main
doesn't return whatever like println
evaluates to or something there's no
return statement and like ok so how does
how does rust know what the function
returns and this is indicated by by this
character the semicolon or the lack of
the semicolon and this is where whereas
talks about statements and like it's a
statements versus expression sort of so
on one hand we have statements that
perform actions but do not
they don't evaluate things they don't
like return something expressions on the
other hand - it's like do exactly this
and expressions do not have a trailing
semicolon
for whatever reason somebody thought
does this make sense I don't know but
it's that way and we have to deal with
it and no worries you will get used to
it this is like certain other like the
the statements and expressions thing has
certain other implications so Russ deals
X or Russ treats function declarations
as statements but function calls as
expressions hmm okay this for example
means that statements cannot be assigned
to variables but expressions could be
and here comes a cliffhanger for
functions because you have to keep this
in mind because we were like later come
back to this because functions is a big
topic I split it up into two but there
is something that kind of needs to go in
the middle before we return to this so
end of functions part 1 let's talk about
types types and traits as you've already
seen there are types in rust rust is a
statically typed language with type
inference so it can figure out things on
its own but what I actually want to talk
about about the type system is that rust
also has generic types and traits
what's a generic type generic types are
just generics are stand-ins for concrete
types that the compiler will later fill
in for us traits are abstract
implementations of functionality
you might notice from other languages as
for example interfaces they're not 100%
the same but very much the same and
traits like implementations of
functionality and we can implement those
unlike concrete types so we can like
take a type that for example we defined
and then like put some more
functionality that comes for example
from a library and do this but we can
also implement traits on generic types
so what
exactly here's a little example like
just one line of code like maybe
illustrate this so in this case we have
two two traits Locke and debug and if we
read this out loud it says implement log
for a generic type T where T also
implements debug and then in the curly
braces would come the actual
implementation but this is sort of like
okay we implemented the trait log for
any generic like for any type that is
already like implementing debug that's
left like a like a trait constraint kind
of like definition so this is like okay
this is kind of cool we can work with
this and this like will be really really
really really cool if you look at
another few concepts the rest I call the
slide enums and pattern matching enums
are another type and rust with
enumerated possible values so we know
exactly that a certain you know can be
one of a set of like predefined set of
options or variants and these variants
of the UNAM can also hold generic types
what this is like it's all very abstract
I know
but bear with me I have an example this
is an enum that rust comes with it's
called the option enum and option of a
generic type T can either be sum of T or
none and if you think like oh I think
I've seen this before
you probably have here's a little
example function that's called plus 1 it
will it will take an option of an
integer and it will also return the
option of an integer and then in the
function body we we match on the on the
parameter that we get so like we get an
option and then we match on it and then
we can decide so if we know that option
can only be one of two things
sum of something or none so if none do
nothing like return them but if it's sum
and we can access the value in sum then
like return sum of whatever was in there
plus 1 this is why the function is
called plus 1 and this is pretty cool if
I then were to call this function plus 1
and then we give it a sum of 5 and that
we call unwrap because enums are lazy
evaluated so if I like would not use the
unwrap and just like say plus 1 and some
this would just sit there and be there
and just like wait for it to be like
accessed and then for example we can
call unwrap to like then access whatever
value we have then yeah because we can
see what like is actually in there rust
people actually don't like unwrap that
much I used it because we all know that
monads are like burritos and you need to
like unwrap them and like a nicer way
would for example be calling expect and
then like have the option to pass in a
string for if there's something that
like unexpectedly happens like we have
like some sort of error message that we
can use for debugging for example
and yeah this is just like a little tiny
example of cool things with like types
and send also pattern matching that Russ
makes heavy use of so like we have
certain error types that you can like
match on error types and then then
handle errors differently depending on
what kinds of situations you find
yourself in and this is really cool nice
so we think is like types are cool and
like with pet and matching and stuff we
can like really like do some like cool
cool things that like I don't know like
maybe like Haskell people do sometimes
but we still we still have like kind of
like the thing that we didn't talk about
with functions so I think it's time for
a functions part to higher-order
functions so higher-order functions are
yeah
functions that take other functions as
input and like also return other
functions or like yeah taking functions
and returning functions inverse we have
a little bit of a problem with this so
if we define a function and rest the the
name that we give that function will
become part of its of the function type
so what does that mean this means that
if I define two functions with the exact
same function signature the the types of
these two functions would be different
this in turn means and since we might
need to always annotate the type of
whatever input or output we have of a
function is that we we basically can't
dynamically create functions and like
pass them around as we would usually do
I put here like easily in in brackets
because there is a way if you like want
to deal with function pointers but it's
probably not very economic to like go
that way
so like this is kind of like a bummer
it's like okay this is this is kind of
like really raining on my functional
parade the other thing is that like
functions also are not able to like
capture values from their environment
they're just like if I were to wreck if
I could or like in our example I create
a function dynamically and then pass it
pass it around certain things that like
you know capturing like environment and
that make sense that okay we can use
this from wherever we define this
function and like then pass it on just
like this doesn't work because functions
I just like I don't care what's around
me I just I just don't care what like I
only care about what's inside of me so
of course this would be not like a
functional talk if I were to stop here
and say it's like oh yeah you can't
actually do any of these things with
higher-order functions of rust rust has
another way of working around this
because rust wants you to do functional
things in it and the thing that rust has
is closures terminus and rust are
anonymous functions that do have the
ability to like capture values from
their environment closures can be saved
as variables and used and returned from
other functions this is this is the
reason why closures are implemented
interest this is like but people like
people think like we really want this
because this is really cool and useful
we should put this into our language so
let's find a closure we have basically
assign a variable lets a closure for
example and after the equals we use two
pipes which is also quite nice and the
pipe character is in russ only appears
in in the context of the closure so if
you see pipes
it's a closure so in in pipes we put in
the param at the argument and then in
the curly braces like the body of the
closure in this case i just multiply our
parameter by itself and return that and
I could call it like just like this and
might have noticed that foreclosures
they are no type annotations necessary
they are optional you can if you want
but it's not necessary and the the
reason for this is that the assumption
is that if you for example write the
library you would probably expose a
function or like some sort of like
function interface to like people so
that other developers could then use
your function and then Ross needs to
check okay
are these inputs what I want them to be
otherwise I'm just going to like yell at
you that this is not possible the other
thing is that you would probably not
expose the closure you would like
generate it and like use it internally
so it's kind of like okay we don't make
this mandatory here in case you you do
want to like an attempt you can but
usually rust is able to like figure out
from like the first run of the program
to say okay these are the types we can
expect I also put a link here where
there's like a description of like how
to like also implement memoization
with closures and like custom types but
this is an example that I will not run
through in this talk but it's really
cool ok so now we have closures so like
anonymous functions and but we still
don't have like I still really haven't
talked about higher-order functions
whereas our like map and and fold or
reduce and like all these things and
they in breasts they come in the form of
iterators iterators are a trait so
abstract functionality and that we can
also implement on our own types and the
iterator is sort of like defined as
functionality that handles the iteration
on a sequence for you also like other
got chairs iterators are fred safe also
iterators are lazy nice it's let's
create an iterator from a sequence in
this case a create vector v1 and just
like in the vector i put the numbers 1
to 5
and then I create a sec like a second
variable V - that would hold our
iterator and this is just I create this
iterator by calling hitter on our
sequence okay
now we have an iterator what do we do
you can make a for loop a no nobody
likes for loops it's a possibility but
this is where whoo iterate is release
time iterators can can take those as
arguments and usually we deal with two
types of iterators
there's the consuming kind where you
actually like kick off the the
evaluation of an iterator and like
progress the sequence and then do
whatever needs to be done what you
define so I have an example where we
call fold on our iterator and this
example only had like a vector of one to
four we call it err on the sequence get
the iterator and that we call fold fold
takes as first value as first parameter
the the starting value of the
accumulator and then we have pipes so
it's a closure and we we have this a
then it takes the accumulator and then a
reference to X star xx a reference so we
get each element at the sequence and
then as function body which I put on one
line here and you can omit the curly
braces which is like at X - our
accumulator and then v2 would not hold
the iterator but the the sum of like the
the numbers and the sequence so in this
case 10 if I'm not mistaken because we
just basically added all the numbers we
cannot only consume iterators we can
also adapt them so like transform
transform them from one kind of iterator
into the into another one and this is
also really cool
here's an example where we use map as a
iterator adapt as an adapter
so in this case after the vector after I
create the iterator I call map and then
I give the closure which just which adds
one to each element and sequence if I
were to stop here which would only hold
an iterator that does not yet evaluated
it would just sit there and wait for me
to like do something with it in this
case though I just after map I then call
fold with the same closure though after
we added one to each value in the in the
vector we then sum up everything else
and yeah this is it and there is all
kinds of methods that that can be used
with iterator so there's like all your
standard filter' zip and like whatever
you want to do with it I think we have a
little bit of time and as I said traits
can be implemented on your own types and
also the iterator type can be
implemented on your own types so I
thought let's look at a bit of an
example this example I took from the
Russ programming the Russ programming
the the Russ programming language book
which is available online for free and
in this example we will create a like
our own type which will be a counter
that holds a property count that we then
will count up the the thing in this
example is that we only count up to five
and then we will stop so how do I do
this in rust I call struct with the
struct keyword I say is like oh I want
to have a new type you call it counter
it holds the property count with the
unsigned 32-bit integer for example let
me implement this counter by defining
like what should be done if we create a
new counter so this new function will
return the counter will return the
counter type and the count property of
this new counter will be set to zero
another important part the
implementation of the iterator so we
like implement iterator for counter then
we have to like define the type which is
an associated type so like what each
element in the sequence like what what
type this will be
in our case an unsigned 32-bit integer
and then we define next and Nexus the
only function that we need to implement
like have access to like all the other
up to all the other possibilities of the
iterator universe basically and next is
a function that defines like what should
I do when I jumped from one like one
element at the sequence to the next and
then we see that the next takes like an
immutable reference to itself so we call
it on the on the counter object if you
will and then we return an option that
holds the Associated type that we
defined for like an option of in this
case the unsigned 32-bit integer the
actual like if we want to count from 0
to 5 what do we do with just like count
up by 1 this is what's like this
function does so it's like self count
plus 1 plus equals 1 and then since you
only want to like count up to 5 and
don't care about the rest so if we like
still and until we have reached 6 we've
returned some of whatever we have is
like or internal counter and if we're if
reach 6 we return nothing and this says
the iterator that we will stop ok let's
use this in our main function we can
make me carry 8 a new counter by and
assign it to a variable by calling
counter : : new which is like a little
constructor and then what in this case I
want to do is like ok we count up to 5
but then I only want to have the the
even numbers from our little counter so
I create a variable even nums which will
be of type vector like it will be a
vector of unsent 32-bit integers this is
something where the Ross compiler told
me I don't know what you're doing please
tell me what type even a mess will have
and I was like ok I can tell you and let
me say it's like ok from our counter
which is now directly implementing the
iterator
so before we needed to cut
to call it er on a sequence to return an
iterator but now counter itself is an
iterator so we can call filter directly
on counter which takes a closure which
since that's like checking like modulo
modulo to say is it zero or not so it's
like is it even our odds and then return
either true or false and then since
filter is also just a just a adapter
this would not kick off evaluation yet
so we need to call a consuming thing in
this case I chose collect which just
like puts every value that it like
receives into a vector and this is where
the vector type comes from if I don't
want to print like even numbers or like
even and then the whatever I got back I
would get this two and four which is
when we come to five give me all the
even things to import it's not that hard
is it okay that was the checklist I kind
of cheated by like always segwaying and
it's a topic into like different
directions a bit but I hope you got the
a little bit of an overview of like some
of the concepts and rest and it's time
to take a breather cool this is almost
all I don't think that I told you a lot
of new things or like starting
impressive things that are new and like
the world of computing no it's just that
and this is kind of like the point where
Russ even though it's like systems-level
it's it's not it's not scary this is all
like things that you know from other
languages that you can use right now and
I think there's also like you the parts
of rust that were influenced by by
Haskell and Oh camel I think you can see
this in the type system and the if you
look around the rest echo system there's
like heavy use of like the of higher
order functions in the way that I've
shown you or the pattern matching and
this is which leads me to like my kind
of like call to action that Russ is new
and it's still like needs to be explored
I would really like to have more people
like look at the functional aspects
because I feel a lot of times people
about the talkbot exactly like ownership
and and borrowing like all these things
that I like there are important but
there are so much cooler stuff that is
just waiting for us to like get into
this and I talk about it and like help
other people jump onto this wagon that
is yeah going to be the future I think I
want to give a shout out to a couple of
people in Berlin Florian and Andrew who
helped me review earlier versions of
this talk and also to Carole who did a
lot of like rewriting of the the rust
the rust programming language book which
makes it so much better and so much
easier to understand or evoke amended if
you want to start somewhere start by
reading this book and this is it thank
you for your attention
can you can you tell us a bit about
where it's headed
do you have any ideas sort of if it is a
frost is moving in the direction of
implementing more functional concepts or
what what's the talk in the community
that's a good question so the rest
community is right now compulsively
people coming from all kinds of
backgrounds like there are some see
people but there's also like Ruby Python
JavaScript people they come from
everywhere and there's still like a lot
of you know the community is growing
right now and there's no like specific
direction and it's very much led by what
people want to do right now
I was asked like yesterday about Oh
rusty for embedded systems and I'm like
it's yeah totally
but I don't know any people who do this
right now and like I think if there's a
couple of people who like things like oh
we should like totally push forward in
that direction like rust would go there
and I think it's the same with the
functional rust so it's like more people
with like come and say it's like these
features are already really cool I want
more of this there's definitely like the
chance that like rust can evolve in this
direction and this is like the cool
thing that is it's such a new goal like
language there's like input from the
community is highly appreciated and then
yeah if you want this you can do it and
this is also like kind of like why I
gave this talk because I want more
people to like do this yeah oops answer
the question
hi so when you said that uh the names of
functions are part of their type that
caught me is a really weird thing do you
have any insight into why that is or is
there a good reason and look at the
question that way it's a very good
question because I was also surprised by
this I'm not a hundred percent sure but
I I kind of assumed that's the also part
of the response safety and we need to
check a lot of things to like like have
this kind of safety I didn't talk about
like how harassed it deals with like
memory management or anything but it's
like a part of this we want safety and
like safety is the first concern which
is why we have a lot of these
constraints and I'm pretty sure that for
a reason that I don't fully understand
um making function names part of the
type of a function is part of this we
need to check this so we like want to
have this if anybody else has like like
knows the exact reason um please say but
I think it's it has definitely to do
with this so
did we have a question down here
ah sending more questions
are there any automatic conversions from
function to closure or you have to write
like X f of X instead of just passing F
come up as far as I know there are no
automatic any like anything that like
does this automatically so you have to
like do it manually basically
as I understand this is a systems
language so the performance
consideration going to be a pretty huge
thing right so is there any performance
penalty for using higher abstraction if
your whole system going to build on your
functions and maps and reduces and in
the whole heart it is imperative
language is the performance gonna be
still considerable to C++ version
excellent question and this was of
course also like part of the things that
I crust people wanted to like we want to
have this like possibility of like do
higher higher level like programming
even though it's a systems level
language and rest calls them zero cost
abstractions so like we can have nice
things like MapReduce and like all these
kinds of stuff and they run it basically
the accept the accept exact like just
exactly as fast as it would if you would
like to if you would like to construct
your own like little for loops so this
is like months rust compiles you code it
will basically do this but it will do
this for you so you can like write your
programs in a very like high-level
looking style and then the compiler will
do like over the work to make sure that
this effect gets written down to like a
bare-bones thing and it will like be
just as fast and this is really cool so
like we have there's no performance
drawbacks for using this in rust which
is really cool
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>