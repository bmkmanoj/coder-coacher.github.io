<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Basic Erlang II by Simon Thompson | 2/13 of Erlang Express Course | Coder Coacher - Coaching Coders</title><meta content="Basic Erlang II by Simon Thompson | 2/13 of Erlang Express Course - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Basic Erlang II by Simon Thompson | 2/13 of Erlang Express Course</b></h2><h5 class="post__date">2017-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eAGfNVNZstE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so what I'm going to talk about in this
the second and final part of the basic
guideline section I'd like to talk about
how functions are defined modules which
is where functional definitions reside
and how we how we call functions from
the shell
so we'll see those basic bits of online
functionality let's start off with
looking at an example of a function
definition this is a function to
calculate the area of a geometrical
figure and if you remember a few slides
ago we talked about representing data so
we said that we would often use a tuple
where the the first atom in the tuple
would say what sort of data we have so
for example here we're saying a square
of side 27 and the circle of radius 32
so those are examples of the sort of
data that feed in to a function like
this now let's have a look at what what
we see here we've got a function whose
definition consists of four clauses the
clauses themselves are separated by
semicolons and each Clause represents a
different case in the function
definition of the function the first
Clause themselves for two parts let's
just establish the terminology each
Clause has a head and those are the
things that occur to the left of the
arrow and that consists the head
consists of a the name of the function
applied to a pattern you can see here in
the first head what we have is area
applied to the pattern square which is
an atom square begins with a letter and
side which is a variable and that
variable will get bound so those are the
heads
four different cases each one false
Abbot has a head and corresponding to
each of those heads tools is a body and
that's the represent calculates the
value of the function in that case in
the example it's circled here there are
two expressions we first calculate the
value of s which is a local value and
then using that we calculate the square
root of s times s minus a etc and that's
the return value when you calculate the
area of a triangle whose size is a B and
C so you can see here what we've got is
a function that calculates the area of a
square the area of a circle area of a
triangle and the area of another single
variable other and that is the the case
the captial case which will return an
error because we're only thinking of
coming the only geometrical objects are
interested in square circles and
triangles so anything else is now just a
bit of syntax about how these these
clauses and heads and bodies and so on
are separated the clauses are separated
by using a semicolon within a particular
body the expressions making up the body
are separated by comma and the whole
function itself is terminated by a full
stop
so just like the syntax of English will
stop ends a whole sentence or function
and parts of the sentence are separated
by semicolon and within those parts use
a comma to do separation so that's the
general syntax of the function in fact
the next how do we then call a function
well there are two ways of doing it one
is to write the name of the function
followed by these n arguments in
parentheses
within its own module but in general the
way you call a function that resides in
a particular module is - like the name
of the module followed by a colon and
then the name of the function for again
followed by the list of arguments the
module and function names here are atoms
they having one principle in Erlang is
that module function names are always
atoms but one thing to be aware of is
that a third thing is significant about
a function its lives in a module has a
name but also another thing that is
significant is the energy of the
function so we can define a function foo
of X returns x squared well we can also
define the function same name which has
two arguments and these are two quite
different functions this is a function
foo of era t1 this is the function foo
of era t2 so they have no relationship
no relationship between the two and if
we want to talk about the era T we say
this is foo verity 1 this is who i
verity to on writing a slash followed by
a number okay so we've seen what we see
on this slide is a generalization the
general form of a function definition we
have a series of clauses separated by
semicolons each Clause has a head where
you see the function applied to a number
of patterns and the whole thing is
terminated each body is a sentence of
expressions the whole thing is
terminated by four stop now when you
apply a function you pattern match on
the clauses how do you do the pattern
matching well you do it in order in
which the clauses are defined so you
first see does the clause the first
Clause match the arguments that I
if it does you evaluate the expressions
in the body and return the results of
the final expression if it doesn't you
go on and see whether your arguments
match the patterns in the second clause
and if not when you're successful the
results you get is the result of the
first match matching clause so a number
of clauses might match but you you
attempt them from the first case and so
it's the first one that matches that
works on the other hand it may be that
none of them matches in which case
you'll get an error so it's crucial to
know that this function courses are
matched what happens if we apply this to
indeed our two arguments are equal so
the result will be three whereas if we
apply it to two and three the first
Clause won't hold and so we use the
second Clause and we add the two
arguments together give us five now what
happens if I write these in the opposite
order
well in this case we'll get the same
result
but what happens in the case where we
have the arguments - and - well - and
too much a and B so we'll get in this
case the result for moreover we'll never
hit that case there so the order in
which you write these things down affect
the final result that you get and it's
usually the case that you put the most
specific nearly always the case you put
the most specific cases first so you do
the case where the two arguments are
equal first and then only the case where
they're different second general case
will be the case where they are
different just returning to example we
saw a couple of slides ago just looking
at that what happens if we apply that
function - if we apply to that you'll
see that the first ones won't this this
does not match the first and you need
the square but this will match the
second and what will happen is that 17
will be matched to the variable radius
and so the result will get will be 3.14
times 17 times if we apply the function
to rectangle three four people none of
the first three clauses will apply and
so the final Clause this will always
match the variable other will match any
argument what we'll get back is this
this tuple
era and so on so that's what we get in
that particular functioning salt let's
move on to another example and here
we've got the example of factorial
function so this only applies in the
case of the argument to zero
in another case if we apply this to two
three the first case doesn't hold so
what will happen is that this n is
matched to three and so the result we
return is three times factorial 2 now
again two isn't equal to zero so we will
again be in this case now if you
remember we've talked about their
language having single assignment we've
assigned n - 3 what happens when we call
factorial with two well each time you
call the function you get a new variable
it's a fresh N and so what will happen
now is that n will be assigned match
with two so two times and so so that's
an example of a recursive function and
we'll see later on that many of the
functions we develop in in Erlang are
recursive and that's the major one of
the major control structures that use
that replaces things like while loops
and for loops which we see in we're
familiar with in in more imperative
languages okay so that's shown us how we
define individual functions now what I
want to talk about a bit is how those
function definitions are put into files
modules so airline modules are have a
dot L suffix and it's expected that's
the name of the file and the name of the
module are the same and you find the
name of the module in what's called a
module directive inside the module
itself usually comes at the start of the
module and the other directive that you
see it in every module is a list of
functions which are exported the
function if you want a function to be
usable cool from outside the module
it must be exported and the export list
consists will have the name and then
we'll have an export list which will be
a list of suppose we've got a function
food fun variety of the names of the
functions if a function isn't exported
then we can't we can't use it now let's
look at an example of this got the
module called demo you can see it's name
is demo and the function exported from
those two function double Verity you can
follow anything that follows a
percentage in a line in Erlang is
comment so you can put those on a line
on their own or indeed inside with some
code to the left return and then what
we've got are some function definitions
as well definition of double and a
definition
times but note that only double is
exported now what I'd like to do is show
you how to how to use functions from
within the L shell we've seen that
already you type L in a UNIX shell we
get the shell prompts 1 greater than 2
greater than and so on and what that
tells us we the young shell sits in the
read eval print loop you type in Erlang
expression followed by a full stop and
you get back the result now the one
thing we've not seen so far is the
what's called a compiler directed and
that if we write C you followed by the
name of the file name of a module that
will compile the module so let's take a
look at now let's take a look at let's
fire up the Erlang shell and let's
compile a demo file when we get back the
result a tuple saying ok demo there's
being compiled and loaded now let's use
the double function remember we can call
double let's call it two nine oh yeah
now what's happening here we're getting
a an exception we're getting an error
undefined shell command double we
exported double from demo but of course
what we've not done is we've not put the
name of the module before the name of
the function so you can only call the
function by in the form module colon
function there we get demo colon double
just as we expected good we could also
call x demo : x remember and . but here
we're getting another error and the
problem here is that we have not
exported x and so we're getting an
undefined function error here undefined
function so that shows you how to
compile and also how to call functions
now we didn't get undefined function
here in line c'mon - we got undefined
command because what the shell is
thinking is that it's getting a command
here because the commands look like this
there's the compiled command and if you
remember we had to forget command and so
on so let's have a but look a bit more
about what Lancome does shell commands
there are and how we can use them so a
slide which is showing pretty much and
one thing you can do is help among the
commands you'll see listed there are H
which prints the history the prints the
last 20 commands plus their results
print Joe the shaktimaan B will say show
you all the variable bindings and if you
just type F open closed parens and
finally the e command will evaluate the
end command in the history by the
corresponding number in the prompt and
if you type minus 1 that gives the
premium previous command and you can
also use ok so let's assign one thing we
can do is we can scroll up and using
editing using the arrow keys on there we
can create the command to assign demo :
double to nine we've done that that way
and we can also say let's say B equals
37 so we've got two now by typing asking
for the bindings in force we can see
that both a and B abound and their
values if we forget the binding to a and
asked for the bindings and forth
we can see that only B is bound now if
we get everything we will see that
nothing is still about um if we ask to
reevaluate command v we get to see that
that's 18 at indeed it was when we did
it first time if we reevaluate tomorrow
6 you can see that that is that is
indeed giving us the result 37 we can
scroll back up so we could scroll back
up to demo double at 9:00 and get the
result 18
so using scrolling and as I say we can
we can scroll up and down and then use
the arrow left and right arrow keys to
go through the line to edit as we as we
might see fit so we can assign C to 1 +
demo double at 9 and get the results 19
and then look at the bindings in force
we see we've got a b and c are bound and
i think the final thing to say is if we
want to quit the Erlang shell you see
the command Q and you can see that it's
quit the shell now will conclude the
basic Erlang section of this course just
reminding you what we've covered here
we've covered how to call the function
how to define a module containing a list
of function definitions how to write
those function definitions and also
showing you how to compile those modules
and access the functions in those
modules in the Erlang shell what we'll
be doing next is looking at extent
extending the way that we can define
functions particularly your recursion
and just showing getting you to do
getting our like to do some more complex
tasks thanks very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>