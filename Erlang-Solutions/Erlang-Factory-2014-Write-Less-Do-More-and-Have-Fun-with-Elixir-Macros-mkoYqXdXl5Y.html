<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory 2014 -- Write Less, Do More (and Have Fun!) with Elixir Macros | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory 2014 -- Write Less, Do More (and Have Fun!) with Elixir Macros - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory 2014 -- Write Less, Do More (and Have Fun!) with Elixir Macros</b></h2><h5 class="post__date">2014-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mkoYqXdXl5Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright welcome everyone this is
actually a great segue from Bruce's talk
because we're too good go into like the
nitty gritty details of how macros work
and kind of learn how to write them from
like a very basic level so again we're
going to learn how to write less and do
more with our code and also have fun and
again I'm Chris McCord and a little bit
about me is I work primarily in Ruby for
last four or five years professionally
before that I did a lot of PHP and Java
so elixir has been my first foray into
functional programming but I got
interested in about a year ago a
prominent rubios Jose a gleam had put
this language out there books written
about it he use all of his open source
libraries in the Ruby community so I
thought it might be worth a look and why
was learning i discovered the wonderful
erling an OTP ecosystem and it kind of
blew my mind that this like nugget of
innovation has existed I've been
oblivious to it for my entire program
and career so since then I've basically
learned about process supervision the
whole lot of OTP and I'm having the most
fun I've ever had programming and a
large part of this is due to Luxor
macros so we'll hop in what are we
talking about today so basically we're
to go over what our macros and Bruce
touch on them a little bit and we'll see
how they work fundamentally as far as it
looks errs astu structured then we'll go
into some of macro use cases far as how
can we eliminate boilerplate in our code
to basically do things like remove dry
code up remove things that basically we
otherwise would have to write by hand or
would have been very tedious to write by
hand how can we do like advanced compile
type cone generations so how can we take
like flat text file as a compile time
and do much in code generation based off
of the file contents and how we can do
you need things like composed
domain-specific languages so how can we
almost operates out our own language
level on top of elixir to basically
exist in whatever domain we're in and
lastly how can we have fun with macros
because that's why I'm here programming
is a very creative process for me so
anything like macros are giving the
power to explore the language and
develop my own keywords are just a lot
of fun
I enjoy that a lot and then we're to go
through like a guided lesson on writing
macros so we're going to implement an
assert macro via slide but it actually
should go pretty straightforward because
it turns out composing like little bits
of cogeneration is the best way to write
macros and it works really well to show
as a slide presentation and we'll
implement in addition to a certain macro
we write our own kind of like mini
testing dsl that's going to be like a
bare-bones version of ax unit from
elixirs test framework and I will close
with some real-world use cases and
examples so macros aren't these things
to be avoided they're not something that
you should be afraid of they're out
there they're being used in the real
world we'll go through and see how
elixirs Unicode handling is using the
cogeneration to compile time to
basically provide the best unicode
support I've ever seen the language and
we'll go through some examples of a way
from wipe for America starter called
Phoenix I probably shouldn't call it a
web framework because Bruce said that
that's probably incorrect term but a
application framework called Phoenix
we're using a macros for the routing
layer right now we kind of have a really
nice routing dsl and we'll see how that
works so as soon as you're getting to
macros you'll find out that the first
rule macros is don't write macros and
you'll hear this from everyone who's
into a lick sir this is on the website
on the macro section and as we're
getting into this we need to keep
thinking that macros or easy to be easy
to get carried away with so we can kind
of make on our own web of cogeneration
that can make stack traces difficult to
reason about or they can hide basically
the entire factories and they can
basically introduced complexity where a
simple function would have been better
in the first place so having said that
macaroon number one is don't write them
macro rule number two this is my rule is
i use macros gratuitously and this
conflicts with rule number one but i
truly believe to properly learn macros
you have to use and use a bunch of them
and write them a bunch so you'll hear
door I macros and don't let that prevent
you from learning how to write macros
get in there experiment write a bunch of
them to properly learn how to write
macros and then take a small fraction of
that insight to apply to something you
would use responsibly for productions
so keep these two with these two
dualities in mind for the rest of the
examples of as we go forward so what are
macoris as we saw earlier macros are
essentially something that takes a lick
sir code representation in and gives us
an elixir code representation back so
put more simply it's just code that
writes code and as you get into this
you'll find out the elixir itself is
primarily implemented with macros so a
lot of key words in the language like
unless cond def def module these
themselves are macros and elixir that is
doing some cogeneration so it's really
neat that lick sir itself is leveraging
macros at compile time and you also find
out that we have full access or to
elixir the language at compile time and
to me this is really neat concept so
it's not this extra special half-baked
in feature of the language it's full
looks or at compile time to generate or
elixir code and when I mean full access
to a luxury right really mean full
access here we have a simple module
called calculator and then right in the
module body I have arbitrary put
statement that said any code can live
here and if we compile and run this
module we get that any code in here is
valid statement out the standard owl in
addition to our function call and this
is because an elixir everything is an
expression and any code in the arbitrary
code in a module body is totally valid
so it's not a large leap to go from well
if we can embed like a put statement in
a module body what if we had some like
dynamic function definition at compile
time for a calculator maybe we could
dynamically define some functions based
on some operators and do a little bit of
more advanced cogeneration so keep this
in mind that we can put arbitrary code
in a module body and it's totally valid
in the look sir
and to really understand macros we need
to understand how it looks to represents
code internally and it turns out that
elixir can be represented entirely by
elixirs own data structures and this is
a extremely powerful mechanism because
it allows us to have a lick sir code
represented in elixirs own terms so we
can basically look into elixir using
liquors own terms manipulate the code
and generate some other looks or code
basically and elixirs own terms and this
is what allows us to a right elixir that
generates a lick sir because it's all
just our own native data structures and
you can get at this data structure by
using a quote keyword and a little is ur
so we can give any expression in this
example I'm giving it a mathematical
expression 1 plus 2 minus 5 times 10 and
we can see we get back this very simple
data structure we get the operators as
atoms so like minus plus multiplication
and then the arguments passed of those
operators we just get in a list so it
says very simple data structure that we
can then consume to either manipulate or
do some other cogeneration off of and we
need to at least understand how this
data structure works or be familiar with
it to write macros because this is that
this is the domain that they operate in
so quote as we saw earlier gives us back
the representation of any expression and
that's the elixir abstract syntax tree
and the AST is represented basically as
a series of three element tuples so all
luck sir code that you write is always a
series of three element uppal's the
first element is an atom usually
representing function call to perform or
another thrill at uppal second element
is metadata and the third element is
basically the arguments to pass through
the first element which is a function
call and that's it so every thing you
compose an elixir boils down to a three
element tupple and what use that in our
examples going forward and it's here's a
couple examples so if i have a div which
is a built-in function elixir to divide
two numbers if i quote that to get out
the representation of the divin vacation
i see i get back a three element topple
the first element is the atom div
because that's our function call name we
don't have any metadata and then the
third element is just a list of
arguments that we passed to do I ten and
two so it's almost this it's very simple
straightforward transformation from the
elixir code you write to the AST
representation and then we can kind of
see how this stacks on top of itself we
take an ad function what a fine
anonymous function named dad it just as
two numbers returns a result and if we
quote the invocation of AD we see that
we get this like stacking three element
tupple so if we quote that we get a
three element uppal whose first element
is another three element tupple and if
you read through this it reads very
similar to our looks or code we can say
that colon dot that's just the atom dot
it's a dot operator so we can almost
read through it as apply the dot
operator to the function add passing the
arguments 1 and 2 so for me it's this
really neat that it's just a very simple
mental exercise to go from the elixir
representation to the AST representation
and what use this going forward to write
our assert macro and for anyone in here
even after this talk I recommend going
home and riding in a certain macro as
your first macro and elixir because it
really shows off how you can consume the
AST and how you get the representation
of code versus the evaluation because if
you go into a lot of languages i'll pick
on Ruby for example we have like for our
testing frameworks we have an assert
function or a certain method that takes
a boolean result and we have things like
a cert equal same with like JavaScript
testing frameworks on many languages
will have these assert and assert equal
functions because if you say that you
wanted to assert that or test the two
numbers are equal you could say assert
number 1 equals number two if that test
failed all you would get was test
failure we got false we expected true so
we lose the information in our test so
we had to devise some other functions
and these other languages like a sir
equal to maintain that information but
in an elixir since we have the
representation of code in a macro we can
write a single assert macro and
basically shove any expression to it and
it will be able to maintain the data of
that test and give us a very helpful
failure message so before I begin
writing a macro the first thing I do is
fire up IEX which is interactive elixir
and I basically feed it some expressions
that my macros going to take in so if we
write in a certain macro to assert like
two numbers are equal I'll basically
quote that and say okay what is like
five equals equals five look like as the
AST is concerned
and as expected we get a three-element
tupple whose first element is an atom
that represents the operator is going to
be colon equals equals because it turns
out the equals equals operating elixir
is just going to be referenced off the
colonel we have some metadata here that
we're not going really be concerned
about and then we have the arguments of
the left hand side value and the right
hand side value that were passed for
equals equals and the same thing for
greater than if I want to assert that
two numbers or greater or whenever is
greater than another if I quote that
expression I can see the operator is
just the atom greater than and then my
left hand side value my right hand side
value so basically starting macros
hopping IEX use quote see what the
direct AST looks like and then use that
to drive the design decisions of your
macro and here's our first it looks or
macro so macros always have to be
defined on modules so we'll create a
module named assertions and then we'll
define a macro with def macro and we'll
name an assert and a core concept here
to realize is our macros get the literal
AST from your code so we can pattern
match on that directly so if you notice
since we can quote like five equals
equals five we've got a three element
uppal while our cert macro can just
pattern match directly on a three
element elbow because all looks our code
is represented as a three element double
we know that the first argument is going
to be the operator and then the last
argument is going to be a left hand side
value and a right hand side value so
what pattern match on that directly so
we can say our first elements going to
be some operator by that to a variable
second our movies argument is metadata
which we don't care about in this case
will discard it and the third element we
know is a two element list well pattern
match and bind directly on the left hand
side value in the right hand side value
so we're pattern matching directly on
the aste and then macros job is to take
in an AST and return an AST so we use
quote and quotes going to start some ast
generation and all we do is basically a
tiny bit of code generation we proxy
this to a do assert function and then we
use this odd-looking unquote thing that
Bruce introduced a little while ago and
the best way to think about unquote is a
quote and unquote together almost like
string interpolation per code so if we
have quote we're starting some aste if
we want to interpolate some values into
the AST that we're generating we use
so it's almost like if you had a string
you're starting a string you want to
insert a variable value into it unquote
would do that for you and we have to do
this because if we didn't use unquote
here we just said operator left hand
side right hand side those would
actually at the call point B local
variables that didn't exist so we want
to inject these values directly into the
ast here then all we do is we have to
implement our do assert functions and
these are very straightforward since we
have the operator that we pass soon we
just pattern match on it directly and we
can say well if you have the equals
equals operator when the left hand side
value is equal to the right hand side
value print a period because we know he
passed any other clause we know we
failed and we can print a very helpful
failure message saying that we got a
failure we expect the left hand side to
be equal to the right hand side so we've
retained that information that we pass
to the assert macro because we have the
representation of code and then we
basically continue to do this for every
operator in the language we can say ok
do a cert when you have a greater than
operator when the left hand side is
great on the right hand side print a
period any other closet we've matched we
know we failed so we can say we expect a
left hand side to be greater than the
right hand side so again we retain that
information and we basically would
continue to do this for every operator
than language but they would all look
very similar to these function bodies so
I'm not going to continue that here so
then to basically consume this macro
will create a module may be named my
test import the assertions module to
pull in the macros and other functions
it contains and then maybe like write a
run function and make some assertions if
you notice we have a couple failing
assertions like asserting five equals
equals zero asserting 0 is greater than
eight and if we run this with my test
run we get a couple of passing tests and
then we get those failure test failures
with very helpful failure messages
because again we got the representation
of 0 greater than 8 not the evaluation
and you might be thinking all this is
pretty nice
and it does our surgeons for us but
wouldn't it be nice to operate at kind
of a higher level we had to like write
our own run function and then we didn't
get any kind of like test case
description would it be nice if we could
give us some kind of string test case
description and in addition to the
failure messages that maintained our
information we had some kind of test
case description to give us an idea of
what we were trying to test so we'll
implement this as a test macro in like a
test dsl similar to VX unit just to show
you how easy this is to compose and this
is where use comes in that we saw
earlier so use is just a macro that
provides a common API for extension
since any kind of module can have a
macro know that is does any kind of code
generation uses just a very simple
mechanism to say I wanted to do some
code generation on this module and
that's it so we can use this use
mechanism to produce something like this
so our goal basically for the next four
slides is to implement what you see here
we want to be able to say def module my
test and then say use assertions and
then within that we can then just use a
test macro and a string description to
say test adding two numbers give it a
Bach of code between a do an end and
then make some assertions I just cut off
a little bit down here and then wouldn't
it be nice if we just defined a function
named run automatically for the user so
they didn't have to define in their own
function to run all their tests and
that's what we'll do here and you can
see by we have a comment up here that
says the use assertions all that does
all uses job is is to invoke an
underscore underscore using hook or
using macro on the module passed in and
we'll see how the work how this works in
a moment so again our goal is if we run
that test we get a failure but we also
get the test case description that we
were trying to test 0 is greater than 1
and obviously we expected you to be
greater than 1 so this test failed so
how will we go about implementing this
well we need a test macro before we get
started we have to open up our sources
module that we just created and we have
to implement that using macro and this
is just a very this is all using is is
literally this simple API for common
extension and our using macro just as a
few things it's going to import the
current module we're in which is the
assertions module and this is just a
convenience so the user doesn't have to
write import assertions like in our
first example and then it does something
very important it defines a module
attribute on the module being defined
named tests with the accumulate true
option just cut off here and what
accumulate true does in this loop but
accumulate true does in this case it
says anytime at compile time that we
assign to this tests module attribute we
want to accumulate that in a list of
assignments or a history of changes that
way active during compile time each time
we say tests we can shove value into it
and keep that growing in a list of
assignments and then the last thing we
do is set a before compile attribute
which is another hook in a look sir that
says just before this module is done
being compiled that very that very last
end block you get to invoke this before
compile hook to do a final bit of cone
generation from our assertions module
and obviously we need to test macro so
one per minute
and we'll say def macro test and our
test is it just going to take a string
description and then we can pattern
match directly on the do in contents
because if you're familiar with elixir
everything between doing in is just
syntactic sugar for a keyword list who
has a single key of do and whose value
is some block of code so in our test
macro we can say well take some string
description and then your second
argument pattern match on the key do and
the test block is going to be some ast
of code which is everything between the
do an int then we convert the function
name to something connecting that can be
invoked as a function on our module so
if you said test 0 is greater than one
we would convert that to a function name
of 0 underscore is underscore grader
underscore than one and then we just do
a little bit code generation so this
bottom quote here will say okay do a
little bit of code generation here
assign to that accumulated test module
attribute and basically give it a tupple
of the test case description as a string
and something that we can invoke to call
this test and then we define a function
that was the zero or zero underscore
underscore greater than one whose
function body is literally everything
between the do and end of our test macro
so is everyone clear on this because
it's a little bit hard to get into this
initially but everything between the
quote do it in at the last bit is
cogeneration that we're performing on
the module that said use assertions and
all we're doing is two lines of code
generation to say hey remember this test
case description save a test function
that we can invoke to call this test
case and then literally literally define
the function whose body is everything
that we gave between the do and end of
our test macro go ahead
which one writer yeah Creek if I tried
to write if I tried yeah so we're doing
some code generous or some code
generation here with quote we've defined
a function name which is just going to
be an atom and then we give that to def
which it turns out def is just a macro
great yeah so this mod review here
you'll see how that works in a moment so
at compile time every time like at the
top every time we say test 0 is greater
than 1 it's going to store a basically
remember that description as well as
what a function it can invoke to call
that test case and each time if you had
another test if you had like four of
those it would accumulate that in a list
and then we'll use that in a moment at
using our before compile hook to
actually do something special with it so
at this point as the first compile pass
is coming through it's just remembering
the test case description you gave as
well as defining a function that you can
invoke to call the test case but though
yeah
up here so import also all using is is
literally this def macro using all it is
is it just invokes the assertions
underscore underscore using underscore
underscore macro so if we go back to our
ideal world example what we want to even
see her all use assertions here does is
literally calls assertions underscore
underscore using underscore nurse cooler
and that's it and that does some code
generation it returns the AST back now
import underscore underscore module here
is saying we're within the assertions
module so underscore nurse for module
since we run quoting like a basically
could have replaced that with assertions
to be clear but if we were named the
module this would pick up whatever
module are in so this line is literally
just saying import assertions that way
the user didn't have to themselves yes
correct as the common API for extension
that's its sole job it's up to the
person implementing this to do import
their modules always yes almost always
and you can do multiple imports
so our last bit of this is we had we've
accumulated these tests attributes is
everyone clear on this humor questions
on this we have to write our before
compile macro and this is where I think
your question came in that we have one
job and our job is to implement a single
function name run so we start a quote
and we write a function named run you
can then reference that at tests and
that test mantra attribute is going to
be a list of every assignment at during
compile time containing a list of tuples
of our test case description and a
function that we can invoke to call that
function that we generated to run our
tests so then all we do is just iterate
through each of those tuples invoke the
test case using apply on the module
because it's just an atom pass it to a
report function and our report function
received a slightly modified version of
our cert macro that we wrote earlier
that instead of printing just returns
okay or failure in a failure message so
we all we have to do is print our
failure message or our failure
description as well as the message that
our certain macro was doing in the very
first a certain example and that's it so
this is all that was required to
implement a very simple test dsl and
elixir and this is how we would use it
and I have a couple of comments to show
you as like the first compile time pass
like what's happening and will I go
through this top to bottom so i can say
death module my test and then i say use
assertions that invokes the underscore
underscore using macro and that that
imports all of the assertion functions
as well as the assertion macros and then
it creates an accumulated tests madra
attribute and then it says hey just
before you can compile in this elixir
and vocal before compile hook on our
surgeons module and that's all it does
and then it starts stepping through this
it hits the first test macro and it says
okay see the comments above that it says
remember that the test case description
was adding two numbers and then convert
that to something we can define as a
function named adding two numbers and
then we'll define that function that we
can then invoke later
and then once elixir gets to the very
bottom in here it's going to say okay
I'm done is there before compile set
there is so invoke that before compile
hook on the assertions module and do a
final bit of code generation that just
defines a run function which iterates
through all of our tests and runs them
reports failures and then we can just
say my test out run and we get very
helpful failure message saying well you
were testing 0 is greater than one and
like doug has failed we expected zero to
be greater than one obviously this is a
failing test so if we can grasp this
you've grasped I guess how macros work
at a fundamental level so if anyone's
unclear here feel free to ask questions
at this point because this is supposed
to be like a guided lesson so before we
move on to like some more complex
examples I'd love to clear some
confusion up at this point everyone
clear on this okay so we brought our
first assert macro we wrote a testing
dsl that was pretty neat and that was
very similar to what elixirs doing in
its ax unit test framework but a very
basic basic version for learning
purposes but that's essentially if
you're running eh tuna and elixir you
can pass anything to assert you get
those very helpful failure messages this
is because it's just using macros and
getting the representation but we can
also see some like real wood use cases
so we if we check out lik sirs unicode
support we'll find out it has like
fantastic unicode support and if you're
getting into like how it's doing it you
might say like oh well that's not very
cool like you know string support and
what's the big deal but if we check out
like a lot of mainstream languages like
i'll pick on Ruby for example if I want
to take like the string thanks Josie you
know for this awesome language but I
want to uppercase it because like I'm
super excited about it look sir I Denzil
might work in Ruby we can see like the E
and Jose a is not uppercase didn't
properly map that code point and this is
like the latest ruby version that just
shipped and if you're like a rubios you
can you would think that ruby has like
really excellent string support
inserting the plea age manipulation and
it does but it cannot properly map these
unicode code points but if we check out
a lick sir uppercase thanks jersey and
like bam we get the proper uppercase
version of EE and then it doesn't garble
the code points in the en el and the
reverse example
so this shouldn't be that surprising but
go try this in a lot of mainstream
languages that you're using today and
they'll likely fail this test and you
know if once you want to investigate
like you know how is it looks are doing
this you'll find out that it's extremely
simple and it like butter a huge smile
on my face looking through the source
code and hopefully I can convey that
year so how is it look sure doing this
great unicode support well it turns out
that unicode is handled by pattern match
function definitions that are all
generated at compile time and they're
generated from a text file named unicode
data txt and it's basically a giant code
point database that's checked in to the
source code repository and a
compile-time it goes through opens this
file up and then a compile-time defines
like thousands of function definitions
doing that code point mapping and then
it lets the virtual machine pattern
match on each character to do the proper
code point representation to like
convert a string to uppercase and the
cool thing about this is like this for
any additional code point in the future
all we do is open up a txt file save it
recompile elixir and like bam we have
support for it so it's a really neat
mechanism in a really great example of
what you can do with cogeneration and
probably my favorite example to date and
we'll see how this works the next couple
slides so if we open up that Unicode
data txt we basically get like a
semicolon delimited list of code point
mappings and if you know it and this is
like twenty thousand lines long this
unico data takes to you file you notice
at the bottom there's like a rocket
helicopter high speed train those are
all like emojis so elixir has great
emoji string handling support because
they're all just unicode code points we
adam to unicode data txt file and like
we're done so to me that's that's a lot
of fun and here's an example if you open
up the Unicode edx file and elixir
standard library this is not the entire
file don't be tricked but it is
surprisingly succinct and i pulled out
the interesting bits from our previous
example with ruby verse elixir and what
kind of walk through this so i think
this is like
this is basically all the bits to
generate uppercase string hanley support
of unicode code points and we'll walk
through it so on like line two we open
up a unicode data txt file read that
into some data path and then on line
three well basically I've cut the line
off but all it does is that parses that
unico dat txt file by semicolon and
reads that in to that codes variable and
that's going to contain a bunch of
Unicode code point mappings of that
entire file and it defines a single
public upcase function that takes a
string and it proxies to a do up case
function passes in that string in and
like the last 5 lines are like where the
magic happens so I'll probably like
repeat myself how this works for a
couple times but like LC is a list
comprehension and it's basically saying
go through every code point mapping that
you read in from that Unicode data txt
file define a private function name do
up case pattern matching on the code
point and then returning the uppercase
mapping of that code point concatenated
with the recursive up case of the rest
of the string so I repeat it one more
time we go through every Unicode code
point mapping that we read in from
unicode data txt like 20,000 lines we
say if you have an uppercase version
defined like hundreds or thousands of
functions all named do up case pattern
matching on the gibbon code point
returning the uppercase mapping and then
recursively up casing the rest of the
characters in the string and just to
drive this home like how simple this is
like these top two examples are
literally defined and everyone's
compiled a look sir unicode module after
you compile this there will literally be
a function defined a the top matching on
like the E and then returning the proper
code point mapping to the uppercase
version and the neat thing that this
gives us the cogeneration gives us is we
can basically define very succinct
composition of the Unicode module and we
also got high performance so we're
leveraging the virtual machines like
pattern matching engine to say pattern
match directly on that binary character
and then return the uppercase version so
like you know the bean vm has been
optimized for decades who can leverage
the pattern matching
engine to literally have like hundreds
or thousands of do up case functions
just pattern match on it we don't care
whatever it is pattern match return it's
the uppercase version and they continue
recursively on the rest of the
characters if you notice like a rocket
emoji like literally if you try to
upgrade some rocket emoji you would just
say like well I had no unicode mapping
for it just return the rocket emoji and
then up or face the rest of the string
so for me like this is the best example
I've seen of cogeneration at compile
time and hopefully this gives you some
example of like the kind of power that
looks or gives you that kind of neat
things you can do productively at
compile time because this would have
been impossible to do by hand or I mean
I guess you could literally defined do
up case for every code point mapping in
the language but that would have been
very tedious it would have been much
harder to maintain and then we can do
other neat things so I started a web
application framework called Phoenix
that we're using a macros for like the
routing layer so we've created a routing
dsl that model familiar to you if you're
coming from ruby and we can just say
like death module router i can then say
use phoenix dot router which we saw
before is just the one to allow us to
define some macros and pour some
functions and i get this very nice
expressive dsl layer where i can say
like get to some kind of pattern URL map
that to a pages controller and then call
the show function or i can say like
resources users map that to a user's
controller and that's go to jenna
generate me some like restful routing
automatically and you might be thinking
like this is really pretty but like is
the cogeneration crazy like is this
hiding complexity your Maxim complexity
underneath where we wouldn't necessarily
want to introduce into whatever app or
building but it turns out this is
actually pretty straightforward so I say
get two pages and then colon page is
kind of like an idiom for we want to say
if it was like pages contact pages about
we want to have a name parameter whose
name is Paige
the cogeneration for this is like three
lines of code so when you the macro for
get pages colon page all it does is
generate the code that you see here it
generates a function they match pattern
matching on the request type which is
get and then it splits the request path
by /and in pattern matches on each
segment so we have like pages as a
string will pattern match on that
directly but then we can generate an AST
at compile time that says instead of
matching on like that colon page is a
string generate an AST that is going to
literally create a variable named page
and then bind whatever was in that
second element to the value of page and
then we merge that on to any of the
middleware queering parameters with the
name page and then we invoke our
controller function show so literally
this is a there's no extra complexity
going on here at compile time that top
get macro is just producing these lines
of code that you see here and again for
like I get two files and then asterisks
path it's very similar but there's a
slight difference in the code generation
we can take Asterix path to mean that's
like a splat name parameter we want to
be able to match like / files /
documents / images / whatever dot PNG we
want to have a path being named
parameter that matches anything after
that second forward slash and turns out
we can do this with head tail pattern
matching and elixir we just in rate a
function match again pattern match on
the get request and then we do a head
tail pattern match that we're able to
generate at compile time that's got a
pattern match on the string files and
then since we split the URL by forward
slash that path variable is going to be
another list containing the entirety of
the rest of that request path split by
forward slash so no matter how many
segments there was it would match on
everything and then we add that to the
queer sing parameters for the moto where
we rejoined the path to make it
something more digestible for the user
and then we invoke our controller
function show on the files controller
and that's it so it turns out that when
you compile this router that you saw in
a couple slides ago so everything you
see here after this is compiled your
router module will look something like
this
remove the function bodies just so I can
put this on a slide but it literally
every macro get post put delete are just
going to define a function named match
and then we let the virtual machine do
all the work and the neat thing about
this is it's highly performant so
literally almost a hundred percent of
requests our router dispatching is
handled by the early emotional machine
so a request comes in from the web
server we have the request path all we
do the only work that we do is we split
it by forward slash then we literally
say we call the function router dot
match pass on the request type and then
pass in that list and the virtual
machine does like a hundred percent of
the work to actually match what what
controller function to invoke and jose i
did this first so the first time i saw
it in the dynamo framework so this idea
was not my own but it's very neat way to
handle route dispatching because most
languages you'll have like a routing
layer they'll build up some kind of like
map in memory so they'll basically go
through every time you define a route at
runtime let's say if you got a request
does it match this record so the first
route no doesn't match this one no and
we'll just kind of go through and it's
much slower than the approach here where
we're literally just invoking a function
router dot match let the virtual machine
pattern match on it now that's how I
perform it and the code generation is
straightforward and just to kind of
illustrate how this happens is we have a
couple dsl layer by sec resources users
and then i can nest resources comments
so we can nest macros and if a request
comes in that's like a get request to
the server to like my up calm / user /
one says commas sash to all we do is
split that request path by forward slash
and you can see how the pattern matching
takes over here we literally just invoke
the function match which is all that
exists and it's good at pattern match on
the first segment users but then if you
notice we were able to generate an AST
instead of saying hey we want to match
on the string we were able to generate
the STA compile time that says no we
want a variable name user ID and we want
the value passed in to be bound to one
same with comments pattern match on the
third segment and then
at the end pattern match on the comment
ID but bind that to a variable named ID
so we get the pattern matching for free
and then we get the binding to our
piercing parameters for free basically
by the virtual machine same thing for
like files / astrix path it's a very
similar operation but it's doing a head
tail pattern match on the list that you
see at the bottom and this is again is
one hundred percent by the Erlang
brochure machine right here it's just
taking this list and it's able to say
okay first thing is files do a head tail
pattern match that were able to generate
at compile time and then path is going
to be the list Doc's photo image.png so
you might be thinking like you know this
is pretty but you know it's fancy it's
neat the code generation isn't that
crazy but you know the first row macros
was don't write macros all we're doing
is a single function definition like is
this enough of a win might be asking
yourself like all it is is just this
pretty layer but we could write these
max match functions ourselves and I'd be
totally valid so you could open up in
Phoenix and say deathmatch pattern match
on some list and not be totally valid
and it would work but we can do some
extra work for the user so there are
some more wins that we can gain other
than a single match definition we can
generate named Rao helpers so anytime
you say like get two pages and then
colon page at the end there I can say as
Paige and I can say hey name this as
something I can call later to rebuild
this path and then at the bottom I get
after my modules compiled in addition to
the match definition that's invoked I
also get a router dot page patch page
path function defined for me and I can
pass in a keyword list I can say hey
router give me the page path or where
the page is home and that regenerates
that request path of pages / home and
then with like the reefs or the fancy
resources route generation gives me some
other like nested conveniences so if I
said resources users I want to nest some
other restful comments resource I get
like a router died user common path I
could pass in the query string of each
name parameter or a pass on a keyword
list of each name parameter I get the
request path reconstructed for me so
macros are used here for a couple
conveniences and then
extend this in the future to do some
other things so for me this is a big
enough win overriding just simple
function definitions so lastly I said
that macros can be used to have fun and
hopefully all this was fun so like
riding macros day to day for me is a fun
experience but we can also do like crazy
things that you would never want to ship
to production but they're fun and that's
what program is all about for me so I
came up with a example here I wanted to
hit my I went to write a module that I
could say hey launch a web browser to
any github repository that I have in my
profile and I can just define that as a
function so i can say like github go
phoenix and it just launches at web
browser to the phoenix framework project
of webpage so we can do that in a single
slot it's like 15 lines of code I can
say okay def module hub for github and a
compile-time take the string to my
github com / chris mccoy jason URL
transform that into a get request make
that get request pull out the request
body decode it as Jason go through is
Jason result and define a function whose
name is whatever the github repository
name is and whose function body is
literally the keyword list parse from
that Jason request of like my repository
information and then I define a function
named go it takes a repo name it calls
my max os10 open command and it calls
the function of whatever repo was and
then it pulls out the URL launches the
web browser there if we wanted to see
what that looks like at runtime a little
like I just say like hub go Phoenix and
like BAM it launches my web browser to
github.com / Phoenix framework I can say
like how many watchers are there on the
repo hub Phoenix Watchers it's going to
call the Phoenix function pull out the
Watchers and I can see you last time I
compile this I had 103 Watchers so
hopefully I need to drive home that
everyone used to realize that this is
the github API request happened at
compile time a single time at runtime
this Jason information was embedded
directly as function definitions and I
guess it's pretty crazy like I don't
know that you would ever want to ship
code that like relies to even like build
on the third party API be available but
this is pretty fun like for me
like this is like the fact that this fit
on 15 lines and this is just just
straight elixir ride it like generating
elixir code for me is like something
that I've never seen in a language and
it's really fun and hopefully shows what
you could do I don't know that you'd
ever want to do this but maybe this
could inspire you to do something in the
world got my yes yes there's a lick sure
you can basically say like eval the
string and give me like the quoted AST
back and you could totally do that like
I don't know why you would ever want to
but like but do it so like what's up
wear it anywhere in here yeah this line
right here yeah so like in a module so
like I have a deaf module hub do and
then I can literally put any arbitrary
elixir code here so I start with a
string oh there's a this cut off thurs
in down here but
yes so enum each has an end here and
then we're good on our end okay so i'll
close with like as far as like doing
crazy things like if we review our macro
rules and like this is a very important
concept of drive home like what do we
learn today so we learned that like one
we shouldn't write macros and you'll
hear this time and time again from
everyone and i want everyone in lecture
community to stop saying this and to say
we should write macros responsibly and i
say this because we don't want to
prevent people from exploring language
and also this would ruin my second point
of we should write macros irresponsibly
and i truly mean that so like there is a
duality here but like it's I'm of the
opinion that to properly learn macros we
have to get in there get our hands dirty
and write a bunch of them we need to be
very responsible we don't need to be
like concern that we're doing something
crazy we want people to get in like get
their hands dirty and properly learn
these things and like ninety percent of
like these crazy things you write
probably isn't something when a ship to
production but it could give you
insights on ways you could write macros
in a responsible way to a library that
you would ship to production so keep
this in mind and I would like actually
the documentation we change to say get
rid of the first rule even though it's
kind of funny and say like just be
responsible with these things we can get
carried away use a simple function if a
simple function with suffice but if you
can do something extra let's do it but
let's do it in a responsible way let's
make sure it's well tested and make sure
it's well documented then to explore
right you're responsible code and have
fun because you'll undoubtedly like if
you do something crazy like a valine
strings in a text file you're not going
to ship that as a third party at least I
hope you won't but you'll undoubtedly
like understand how the asda structured
fundamentally because you'll have to
like explore and learn how these things
work and you can take that exploration
to apply to something that you would do
for a production system so it's like a
win-win it's fun and you can also use it
as I'm learning experience so that's all
I have I'm Chris McCord on Twitter you
can reach me by email and I pretty much
idle and live in elixir lang freenode
IRC at all times
I worry about being like two active on
there but I'm always willing to help so
if you have any questions or stumbling
blocks hop on there there's a lot of
helpful folks Joe's days in there all
the time and I'll help you out and
github com / Phineas framework is where
you can get access to Phoenix we're
looking for collaborators ideas it's
very early but we have some ambitious
goals and I'd like anyone to hop on and
contribute so if there any questions I'd
be happy to answer them
in your corner pieces without a
many-to-one relationship so you could
have the same string are you have
different strengths are the same
technically yes yes so you're saying
like this function name theoretically
we're just stripping out alphanumeric
alphanumeric characters we could end up
with clashing functions yeah the nice
thing so like I actually realized this
after I wrote it but I left it because
it would have wouldn't have fit on the
slide here but the nice thing is that
the vm will warn you about that we
wouldnt want to show the library like
this we could do other things we can
make it not friendly we coulda pin like
since we have the test smile draw
attribute react will actually check it
during compile time and maybe I pinned a
number of like the test case how like is
this the third one and that would make
it potentially make it unique we can do
some other things yeah
oh my gosh you're totally right yeah so
we could we could literally can we could
literally convert this to just an atom
with at be totally valid with the spaces
so so Josie you don't you don't be able
to invoke that via like the apply
function right you would be able to
black I wouldn't be able at runtime
would I be able to call that function
defined apply and that would invoke it
katra awesome
anybody else
are there I mean is there like a list of
stuff
programming is the solution for like we
need to find the language of macro
asleep all those other sort of goodness
like is that how you find it as far as
like replacing like inheritance or for
me so I like to think of macros is just
a few use cases like I you could do like
absolutely crazy things you could
probably like implement your own
inheritance later but like for me it's
about making things more convenient or
doing things that compile time like
going through a flat text file and
generating some function definitions but
really the sky's the limit so it's
almost like we can define our own layer
on top of elixir define our own key
words and language essentially so you
could do almost whatever you want to do
but for at least for me it's some really
defining like a couple things like dsl's
or a big for me defining my own layer in
the language and then secondly it's like
doing generating hundreds of functions
that I would have otherwise how to write
by hand and that's kind of where my
thing stops but yeah
basically a great point about an hour of
various languages and he always put this
at the top of the list because two
bathrooms I mean basically any any place
any time any place that the language
comes for
and speaking of lisp like the first time
I saw this 3 element uppal I don't come
from a list background but I was like
this is basically like Lisp but like we
were placed brackets with Prince like
very similar idea that was really cool
to me
the same
yes
language thread so most languages have
the shelf life of about 10 years
the world Rose MTG by script language
right but Java they solve that problem
with black coat enhancements to c c++
but you always see these successful
languages have at extensibility
that's it so I have helped
destructive assignments or lazy
evaluation so there you can define a
macro that defines its own like by
default variables you define in your
macro or like hygienic you could also
pass a option that says any variable i
define here I want to be able to clobber
some outer scope variables and that's
doable right now so you could do yes I
see no reason why you wouldn't be able
to but you are you are ultimately bound
by the constructs of the language but as
long as it can take in some kind of
valid AST I could minute like a loop
macro give it some valid elixir code and
it will be able to take that in
manipulated do whatever I wanted and
spit a st back out but it's all
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>