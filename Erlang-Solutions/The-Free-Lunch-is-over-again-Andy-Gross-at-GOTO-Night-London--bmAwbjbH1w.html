<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Free Lunch is over, again - Andy Gross at GOTO Night London | Coder Coacher - Coaching Coders</title><meta content="The Free Lunch is over, again - Andy Gross at GOTO Night London - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Free Lunch is over, again - Andy Gross at GOTO Night London</b></h2><h5 class="post__date">2013-08-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-bmAwbjbH1w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">that's the community playground time any
rice on the
I chief architect invesco already lost
my phone according to drink a little bit
more about myself a bit bachelor for a
long time start appears about six years
now before that I was at an apple and I
do together distributed system stuff so
I've been pretty lucky so far for a dude
a CSV or get some pretty good places so
this top is really not about react or
not about any particular system I'll
cite some examples mostly from the
history of react when it's really about
distributed systems the title of the
talk first quite work where it's due his
stolen from 2005 paper by kurt sutter
big c++ guy i don't know any of you guys
spread this those the train care
medicine it may work that but it was
about two thousand five is really the
where the chips stop getting faster in a
single corsets and started getting wife
and that you have you know instead of
going through too big it hurts the
formative her to get to 40 difference
course in your system and what herb
summer was talking about in this
original free lunches over paper was the
challenges of that pose for some
ordinary developers of ordinary software
any software and this paper really sort
of really bad people to pay attention to
challenges that okay how many of you
eventually debug multi-threaded do you
enjoy how many enjoyed okay maybe
there's always one of my life that I'm
one of those how many people has partner
every day job either debug develop or
operate distributed systems so if you're
on you know a cloud provider or whatever
you're already debugging mr. distributed
system because to the platform that your
employer codons I'm going to use a no
sequel database introduction so then
you're definitely in and if you
know if developer of debugging time
developing multi-core systems is harder
than distributed systems
from an unreliable network link to a
bunch of beautiful multiple cores you
have a massive problem there in terms of
being able to keep your head around the
whole problems all the factors of people
but nobody's really made a call to arms
like this about the difficulties that we
that we face nowadays or distribute
systems this paper you know we're
acquiring about you can change the
existing tools that we have to cope with
the multi-core error now we have you
know gdb that's not half bad actually
through different threads inspecting
what's going on so it sort of subtitle
this paper in two thousand files
fundamentally term words and currency
and software okay we're in the midst of
a function there's only so much you can
do what one machine now is especially
when you're using someone people cloud
licenses you're expected to distribute
your software over many many sheets and
sometimes it's easy ish you know HTTP is
nice and stable it's an absurd bridge
you know put a load balancer right way
but when you start any databases and
when you start writing your own
distributed system keep it all right it
can be quite different element if I
convince you of anything negative the
negative point here is that we are
pretty severely handicapped by the tools
language is enough yesterday but I think
there's there's hope so this really
affects the entire software design
implementation testing all we know
ongoing operations and maintenance so
I'll touch on sort of design first I out
and say that we're going to distributed
systems Renaissance all the fundamental
real work you know the real science
academic stuff distributing systems
happened a long long time ago and I know
that you know ever since there was the
first ever since they made the second
computer people have been theorizing
about what can we do with many of these
computers and it wasn't until you know
about two thousand eight with ec2 that
it was even very easy to get to
computers doing something together I
remember that automatically to test
something had to look ill desktop
surrounding my destiny physically I
think at three computers underneath
their trip to play with things and we
were on the cutting edge back so now
with you know cloud computing stuff and
ec2 you can fire around 100 spot
instances for two cents in at work and
test large large distributed systems and
scale so I think we're all streaming
assistance people now and you know maybe
a secondary global this is to convince
people to go back and look at some of
this early research because people that
Leslie Lamport and extra Nancy Lynch
they really figured all this stuff out
in the 70s but in a much more
theoretical access nobody had access to
large amount a large amount of systems
but as it's worth looking at why you
know why are we doing this now in a lot
of ways we have larger problems I've
gotten through this talk before without
saying either cloud no sequel work
I think I've already screwed up and in
general if I if you think I or
if you have a question feel free to but
I think the bigger thing would be more
and more stuff on the internet I lost my
phone today or the other day and I was
literally lost without it like that
wouldn't happen 10 years ago Geeta can
vouch I was you know like oh I mean
another very metaphor but I needed the
phone was there was so much stuff on
there and people have increased
dependency and increased expectations of
systems back in you know the late 90s
early 2000s no it was okay for even any
commerce site to go down for a while
with a little animated gif to the guy
shovel and stuff but now it is and then
you know people will quantify it amazon
says that every millisecond that it
takes longer to load their surrogates
like a million dollars in revenue but
here I don't know if that's the exact
older than that but it's a formidable
amount of money tied to a very small
amount of things so these things matter
in order to you know combat high latency
in a global sense you need to have many
computers closed two users so and that's
only going to get worse people are going
to have west of us patients with bugging
your snow systems and the answer really
along has been you know to distribute
this problem for many computers for both
the locality and the fault tolerance
benefits that you can get from that the
other reason is a lot of time you
starting on w don't really have a choice
if you want to a venture capitalist
today and said you know I need something
I'm going to use some of this money for
buying my own depreciating surfers
well you better feel really good reason
because they're going to tell me he'll
know you're going to put that stuff on
the cloud and you're going to live with
it so there's really no way out of this
connector thing I don't officially
fascinating stuff it's time to be but
the problem is obviously discussion and
then we actually so far to this problem
has been something like this I stole
this from my friends and foundry their
website but I call this happy news
driven development we're in response to
distributed systems problem you just
pile on more and more immature stuff and
hope that throughout all those things
somehow because you see a lot of holes
that practice in my database for the
slide
reacts in their risk guilty as to this
and this is immature stuff too serious
trade off though from my sequel to you
know a new no sequel database because my
sequel heads and 15 years on the hard
stuff but again we often we don't have a
choice if you want to meet the
availability of time takes requirements
that our customers are chosen and if you
i am not have a kidney follow me on
twitter by the queue if you look at sort
of the whole industry now there's a nice
tight feedback loop between industry and
academia I don't want to credit Twitter
live for the name one that's putting the
sense it has you can give a nicely strap
showing up previously recognized for
temple we go back and forth very quickly
in cyclist up you didn't see many years
ago so sometimes for some reason people
invite me to talk about what can
academia venture industry I think right
now we're a really good spot a lot most
urbanized really cool people are studied
to publish source code with their papers
so I think we're sort of in a revival of
distributed systems and because of that
does all this renewed interest in a lot
of the stuff i was talking about from
the early 70s before as these systems
get more complicated when they become it
becomes much harder for you to keep your
head around all the things that
possibly go wrong there's a renewed
interest at least for myself and two
people i know of formal specification of
systems meaning that you know you write
a specification and then write a system
verification actually but you're right
assess amusement captures everything
that the system is supposed to do and
then you write an implementation of that
and you can verify your implementation
against this model and actually be
certain that the system is correct that
sort of a pipe dream in my opinion I
don't think I don't think that's really
possible it's still sort of an academic
interest and it takes a long time and
systems are sort of limited and so but
there's a rigid interest in this stuff
and distributed systems tend to have
this history of the discovering work
that was done and decade or two before
and then it gets pushed into the
mainstream again so another thing which
I talk a lot of in-depth is in Texas
protocols which is really the
fundamental problem i distributed
systems it's you know how do you get
multiple machines to agree on you know a
certain value that goes through this key
or machines degree on you know that's
the one machine it's going to take out
this action if more than one machine
doing a certain thing would be harmful
it's sort of the fundamental problem in
distributed systems and if heard of the
taxes who sort of Texas that was written
or that was the original packs of a bird
it's written many many years ago dark 89
I think written horribly if you've never
read it and there's the history of taxes
literature technical side the history of
taxes that are shared is equally
unfortunate I need your key programming
languages early there's all this renewed
interest Skinner land right where land
is older than job yet in the past four
or five years you see a lot of startups
and certain sort of verticals choosing
databases as one mobile gaming is
another you see a lot of elimination
again this is highly available whoa wait
and see applications for which downtime
is literally an historic a gaming
company and when the system was down
literally here's a sucking sound with
the cash though I got window in
advertising etc the explosion of new
languages on the GBM definitely wasn't
like that 10-15 years ago people though
more conservative
and again the databases you see all the
ins new always needed because relative
so we're sort of being this in this
renaissance of distributed systems and
in the process of you know apparently
was talking just in my job I've gone
back and read along these old papers and
it's sometimes amazing that you know
people could conceive of these problems
years ago and just a purely theoretical
doubt I've always been the type to sort
of go right to cope and not spend a lot
of time on it you know abstract design
but these guys have the stuff figured
out many many years ago when he hit the
implementation languages again how many
program in a functional ish language
Scala closure Berlin that just didn't
happen in the sort of object-oriented a
C++ has closures now and job it is not
closures and now finally and I'm not an
object-oriented Peter but it's 0 is not
the one and they'll be all paired up
people are implementing nice
domain-specific languages that are very
declarative and focus more on the how or
a focus more on the what that you're
doing then on
and I think if we're going to have any
hope of more formal verification the the
difference the gap the conceptual
conceptual data and the cognitive gap
between you know the the what you know
the specification and the how the
implementation needs to get narrower and
we'll see I think we're off to decide
what this means that we have to make our
existing tools and tylers static
analysis tools better and more suited to
the task if you've ever been an asshole
programmer they're often very confident
that once their code from Pylos that
works and that's because so many more
things due to haskell strike system show
up as semantic errors in the compiler
that would have slipped through in a
moralist in Texas and I'm not saying you
know type systems are the answer but
maybe they could be if type systems
could express temporal logic and have a
notion of time and partial failure of
the type thing seems different systems
that we might be able to let me close to
get something very interesting
a dsl algun on UC Berkeley is written in
Ruby and it has a sort of formal model
that you write your system and the
compiler will tell you for always plenty
of for them is ninety-eight percent yer
program whatever your regular work
eventually consistent world is fine but
in these couple spots you need strong
consistency that's a case where you need
to add like zookeeper or funnel stuff
through a strong consistent symbol
system in relational database already
taxes on Iran so the idea is to get
these bugs get these potential issues in
our code followed up sorting Peter and
tools that we use okay because no
compiler nowadays didn't tell you
you know distributing race condition
here natural process time I'm sure you
say food hulu beat LOL its imaginative
something that I don't probably some
from Joe hellerstein screw vet at UC
Berkeley and you know any language sure
you can implement you know two-phase
commit in like five lines of code on the
screen that's exactly what I'm talking
about narrowing that gap between you
know what you're doing and how you doing
and sometimes the need for that kind of
strong consistency it can be subtle it's
not always obvious and I think compilers
static analyzers have a perfect place to
sort of put those markets in issue so
distributed consensus that's the sort of
the big distributed system problem this
setup can see it is just a screen
capture of what comes up when you type
paxos into google scholar and you see
paxos made simple there's a couple of
those taxes made simple taxes made by
that's has made simple fasten byzantine
tax me practical factors for
reconstructing Paxos access mate
moderately complex and taxes maybe even
simpler so there's already you can tell
just from the history and literature
that hey maybe this thing is actually
not simple right lesson import the
original author you know swears that
it's trivial but if you corner academic
put a couple gears into them and ask
them if they can you explain access to
you right now and all its weird little
guarantees nobody so this led me to rant
and the slide is a little about a date
where if I would access I mean how do we
normally solve things in you know
software engineering we make a library
to encapsulate the tricky stuff you know
one of my biggest pet peeves is you know
in an interview someone asks you to cool
the complicated problem on a whiteboard
when normally if you were actually
facing that problem in a real job you
just use some library that did it right
I know I understand what was in those
questions but we don't have a lot of
good distributed systems abstractions
nowadays a file system for example file
systems in noise exists you sir right
Rob likes to a plot device so imagine
you know living without a paucity if I'm
thinking or if you have to write a web
application we actually be circled with
it every time we're very good at making
software artifacts that are abstractions
over complicated stuff so we can focus
on what
Delaney's so my argument is that being a
modern operating systems if they're
meant for the cloud or whatever should
have these modern capabilities
implemented instructions in the
operating system properly VMs which I'm
fairly old enough to remember had one
like a zookeeper thing distributed lock
manager see say hey clustered i'm going
to enter this critical section and i
don't want anybody else to you know
perhaps corrupt this data while i'm
accessing it so VMs have one of these
and if you build nowadays to the
wikipedia entry for distributed lock
manager you see VMs which is like late
70s early 80s and then fast forward a
zookeeper we have PMS we don't use
anymore and so zookeepers the only thing
and I think that even Razoo keeper
Community the informal tagline that
makes software is because there's
nothing else and this gets to people
don't trust you know version 01
distributive consensus implementation
especially when it means that a fog in
that implementation because corruption
of data or worse and if people don't
trust the Bieber because it's been
formally verified the software itself
and the protocol I think has been
formally proven they trusted because
it's been around for many years and
other people have already gotten bitten
by the bad bugs in it so it's this sort
of ad hoc trust in that that all the
other really disastrous bugs have been
found already I'd like to draw the
comparison
a little story when I was an apple my
job there was to write a distributed
file system to make compilation faster
for different customers so I was on OS
10 so we didn't have fuse like like you
had a linux and I spent like a year
running the loopback NFS server and
twisted Python dealing with all these
horrible bugs so much to where I
basically well the daily shifted around
the week we should get confused her
macros and Nina confuses the quad flat
system and use of space toolkit which
allows you to very rapidly prototype
enigma toy ish or experimental process
and I have enough to quit Apple right
after I shifted and promise never again
is going to go into a problem with that
so under quipped but what you saw in
genius came out even for linux is that
all these interesting experimental file
systems I mean some of them are just
toys like a file system that you know
amount of 4chan or reddit thread not
your system and you know toy stuff but
you also had a lot of good
experimentation going on that's what
it's that what we're talking about when
it comes to you you know having these
abstractions enables you know quick
implementation quick prototyping
feedback loops and you know sue keepers
fine but the fact that zoo keeper is the
only thing I think
a little more serious that we need to
address this one's a little works here
but it down into the nitty-gritty of
developing these systems Andrea
description algorithm super it says you
know no day writes this little bit too
stable storage and no more well that's
actually really hard Ares is the
protocol the right ahead logging
protocol that most modern data just
excuse you know they transaction example
they commit the old data new data to the
to the right ahead blog take the change
memory and that mark transaction logging
this number it's definitely very
complicated if you read the papers
almost impenetrable but this is another
example of a system that arguing in the
for example of access implementation you
need reliable voltage states or if
you've ever been through file system
race conditions and colors you know well
enough you probably appreciate this and
historically a database of in some sort
of tough down and when things sequel
worktop don't really mess around what's
underneath that it's been hard at the
table meant in a in a layered fashion so
the unix way more complex
complex abstractions I talk about love
UC Berkeley Lab Russell Sears not easily
one of Eric gurus grad students did try
to do this in every part of the database
as a library or you can mix and match
not have to opt into a whole bunch of
stuff just to use the right ahead love
it's a good start and Bailey's working
on it anymore so once you start talking
about a ok fine let's write a patch this
instrumentation that's reusable very
quickly you find you need a bunch of
local tools that don't necessarily exist
in this case right applause Oh santosha
we've tried to provide some musical
distributed systems abstractions react
or is one of these what you know is
react is actually sort of a plug-in
application to our distributed systems
framework dynamo style framework that is
free on court and react horror is not
specific to databases react or just
knows that hey those are your writing an
application that's going to have the
notion of members of the cluster that's
going to have the notion of
members joining and leaving the cluster
pro mentally and it also deals with the
back ten members are also in addition to
sort of permanent membership going to be
flapping up and down because you're
buying you know cheap commodity servers
and the Internet's not perfect and up
all the time and it's dr. been really
successful so far the documentation is
crap and you know it's in Erlang so
right off from the back of limiting our
audience but that said Galu openx
opening some big accident company stack
mom have written pretty significant
react for applications that aren't
necessarily databases I think I've heard
less than most here that's using a
couple university systems classes so you
know if you're curious about this kind
of stuff check out the up or actions
indoctrination crap it's just we don't
treat it as a first-class product
bashing yet so it tends to lag behind
just to sort of illustrate what I was
talking about there this little blue bar
here is react or high so it does kind of
all the hard stuff consistent hashing
and off gossiping what your global stage
is around no life is checking detecting
the notes fail and the way that you said
a write an application against it you
write the sort of client API your app
and the client API receives a quest a
request from the user and then says to
real course hey fancy distributed
systems thing here's a request you know
distributed among nose and report them
figures out okay what's the key for this
request or how it will be powerful we're
sort of sharding it insurance backward
it didn't used to be this and then once
it figures out what knows that request
needs to go to it dispatches that to you
know local nodes and these
just carried out the action both so the
top half doesn't really need to know
about the fact that it's a distributed
system and things are going up and down
all the time and the bottom half doesn't
we need to know that stuff either so
it's not necessarily this simple it
would be great it was but the idea is
that you can keep all the complexity and
the hard stuff in the middle and that
freezy welcome and you know so if spread
that kind of logic all around here all
right of hook because in the past I'm
until back show every time you wanted to
write a new district system the
circumstances were just different enough
then you tended to have to rewrite all
this stuff from scratch and this is the
stuff very pro pro Jane's a long time G
today testing this is one of my favorite
topics here another quote for the ice
road testing only shows the presence not
the absence of books and this is a
difference between testing an actual
formal verification right testing just
you know you find a bug or a failing
test for whatever it shows that you have
books but not no matter how many unit
tests you right you're never going to be
sure that there's no ladybug still in
the software so we improve the
correctness of algorithms with purpose
systems and their groups and stuff but
can we say anything about an existing
system and I think as long as we treated
as a black box i think that's impossible
so this is really a design first thing
we have to
sort of design for testability up front
regular unit testing really is not
sufficient for our realities you know I
think as programmers we tend to have a
hidden bias towards not wanting to break
our systems and regularly even testing
just isn't enough coverage for myself to
gain confidence about erectus click
check 11 something you use very
intensely passionate is a big
improvement anyone heard of quick check
before right on so quick check is what
we call a property-based testing tool so
instead of writing an imperative sort of
just piece of code that exercises you
know a certain method it takes certain
arguments
something you know we tend to write
those things you tend to gain the
testing distance ourselves quick check
you know instead of saying I'm calling
this exact method of these exact
arguments you instead say okay this
method takes two positive integers and
returns a string or whatever the
signature is right and then once you've
given that high level property click
check will generate for as long as you
let it run random arguments you know
random parameters to those functions
that satisfy the property and then wait
for a break and then when it breaks it
will go back and shrink down that call
stack to provide you with a minimal
failing case so that if you have
cutest stuff to get their face it down
minimal so the understanding pace and so
you know we start talking about code
coverage you can get one hundred percent
coverage with unit tests and a lot of
times if you have continuous integration
you can go to a little website and see
hey you know the coverage is trending up
but that's a very easy thing to gain I
know I used to do it friday opportunity
to mark great you know you want to do
anything as certainly knew so let's try
to make that web page look Morgan I mean
by adding tests just treating the number
as its own absolutely ND itself instead
of really thinking about hey how my
system so quick check yeah you'll get
the same percent coverage if you had it
before with um test but you're covering
that code over and over and over again
with all sorts of different arguments
and so it sort of case some of the
season at how easy that number is to
gain with check at least gives me one
example of that is a earl and processed
pull the library called pool boy and it
came to pass and react that we needed
the process pool when we didn't want
we found one that looked reasonably
complete and we integrated into react
and we made all the parts of react use
this process pool and we ran two tests
and we ran our integration tests and
everything seemed fine but every january
i think john hughes the cupid without
Nev is a script check training and we
decided to subject for boy to this and
when we drove some relatively simple
bookshelf properties full boil we
realize that just about every single
lady I call bull which was broken in
some sort of weird corner case I'm not
always necessary parties we're grace
conditions right so something that and
this gets into maybe quantum physics see
stuff you know if the bug doesn't get
triggered is there a butler these are
the kind of bugs have always had
triggered as Heisenberg's introduction
rice ago it happened once you either
ignore or you puzzle over for
overthrowing and refined it quick check
does a lot beyond just simple function
specifications it can test your state
machines for puzzling we know you only
see this bug when you enter a the state
machine with this type of arguments and
then you timeout and you know you can go
many steps I think further then you know
we can keep in our head gear me too
debugging session another way of of
exposing these sort of Heisenberg's
there's talk of pulse there's a lot of
quick check and that is the changes the
scheduler inner land to do these very
pathological scheduler traces that are
possible and probably only likely under
severely degraded sort of production
systems that are heavily loaded with
stuff you'll be hard to reproduce
reliably a testing situation and then
sort of immediately surfaces bus LOL
doing what is crazy is obvious cited at
the these line for the old msgs order if
you curious it's free on 42 number 2 98
and so now that we you know instruments
are our reality stuff and have these
tests run after every checking the level
of confidence that we have four releases
and stuff goes goes up pretty far and
again this is not a formal verification
this is not you know exhaustive state
space exploration but in terms of how i
can sleep at night you know knowing that
quick check random
against my software it's definitely an
improvement there so I've been aside a
lot of famous distributed systems people
died strong Lamport least somewhere in
the career they sort of quit distributed
systems and get into formal verification
methods and after six years of trying to
ship above free reauthorizing sort of
understand why it becomes so the issue
of people's minds right you're not
comparing myself to either of those
general but this isn't problems quick
check is complicated it takes time it
takes training it takes a real
investment as long as your code is
evolving separately from your tests what
tends to happen if someone spends a lot
of time writing a quick check property
or check model for a certain part of the
SoftLayer and then as long as that quick
check passes nobody thinks about it and
then you know a year later we change the
change of function signature ii change
the api some way and the test fails and
then someone usually around at least Im
some of us the least amount of effort
you know just to get that test passing
again but not with that same original
investment the code the tests as long as
they're separate from the code tend to
decay over time and you become less you
know they tend to give you less
certainty is there you know the software
is progress you want to start to
question you know how much we actually
testing the system hasn't
you should get a large upfront effort
we've actually I passionately try to
address this one of our guys Jovan says
Jay two people on Twitter or the paper i
think is for my workshop on how they are
based development of concurrent systems
where instead of having the model or you
know having the tests in the code
separate you just sort of annotate your
actual code in an attempt to sort of
unify the tests and and the envy and the
actual implementation so that you don't
have that separate set of decay and
there's actually tools that did this I
think they need a lot of work to become
friendly to your average developer this
stuff is way over my head but I think
people are thinking about this stuff in
making progress this thing called MCR
line model checker for land that that
actually does exhaustive state space
exploration so after you from that you
can be sure that it's actually tried
every single combination like these
Hospital sure good room with no chances
of it
yes yeah you can be sure that they
terminate and even more superficial but
but relevant I think is there they all
have that sort of width of academic
software to that works just a pain in
the ass to build those those things are
important and who knows what the model
chapters right right how do you object
model checker so there's there's a
genetic problem and there's I just don't
think it's ready for you know your
junior developer to or if it's
worthwhile training you to be developed
over and go quite that far but I think
what checks a nice compromise but you
definitely do builds into the local
expertise so the group I wasn't sure so
we just said so now let me have a CI
process you know we every time to check
something in it will kick off a build of
all the platforms and support and you
know
regular sort of make file implication
will will run the tests uh sometimes
these things take a while so good Jeff
you know when we're developing something
someone will let project run overnight
right and it'll tell you how many test
cases it generated for this for dating
integration tests the we proved that
number way down so that when I was just
waiting forever but I mean I think
running checking the react if you just
checked out the outcome source then
wrote make task or checked all the
different action subsystems you you'd be
spending a good 20 25 minutes so its up
its not immediately but then we have
layer policy on top of that you can't
merge to a certain branch have stricter
guidelines without miss damage I think
we intend to open source of our CI stuff
or somewhere now testing the group
myself in Justin she be our CTO and
Akamai was I guess it was getting up for
you pelvic dead last it was a small
group responsible for writing software
that deployed are in production network
which at the time was twenty five
thousand machines which is a lot for 99
was nowhere near the largest deploy
distributed system navigate for a while
was so operations is sitting near and
dear to my heart this is my friend cliff
moon rocks and what's that look I would
pay a lot of money for debugging
distributed systems
what is asking why so how do we give up
the service systems that I get how do we
avoid but introduced us in a certain
sense once you're you know with a
multi-threaded program resources once
you're debugging eight you're already
screwed so how do we get coming monitor
and if you look at and with a sort of
standard monitoring approach day is you
know you have these discrete variables
I'm gonna go sentai latency for this
metric and so on but where you go what
is like a post-mortem for like an AWS
outage very rarely is it just one thing
usually it's many systems conspiring
together in ways that we never foresaw
they were interact to scream and rather
than just one variable so we need a way
instead of just graphing every single
state variable in our system that seems
to make sense we need a way to sort of
open-ended li for these emerging
companies systems when you start to move
on put them together and the current
open-source options at least from what I
can tell all kind of selling one what
this is maybe somewhat ironically sequel
but this is something you can type into
the Akamai query system and if you look
at it fairly obviously the maybe you
can't see it but it's basically
selecting all the machines where the
role is a dns server selecting all the
IPS and processes where the residence
size of the process is greater than
seventy five percent of total memory by
julian's manage to distinguish drawing
on these things and then reporting back
the IP IP processing and precedents eyes
in the pic and where we were able to do
this not because we foresaw that we
never want to do this query but because
we reported fairly simple information
about every process and then you know
exposing it in this manner makes it
possible for anybody at the entire
company without I would open a ticket
without having to write it hard coded in
the software even a config file to in an
open-ended fashion sort of look at this
big Gator in whatever way you wanted to
after the fact and the way that you got
alerts was every time has created return
many rows somebody's patron we go walk
what it was responsible for the query so
if anyone everyone were to write this
open sore or whatever you make it you
make a timeline if you want to because I
haven't seen anything quite this crisp
just feeling a little bit more about
emergent properties stuff that goes
wrong you never plan for this is one of
our favorite tube a show called PCP in
casts who's ever heard of that yeah it
sucks Scotch machines grandfather I just
had the greatest growth or hereafter
generated you can't go to you about some
manure into one bucket and that's
basically what happened to DCFS and this
is such a problem that's not unique to
react i think you should get best and
others
where you have as many to one messaging
aspect will suffer from it basically
what happens is in react we have a
coordinating note and it sends the
request to many replicas and in the
normal state albeit replica it's time to
reply at about the same time and then
the switchport if the law if the results
are large enough you switch motor
doesn't have room to buffer so it's
going to start dropping unit frames and
then DCPS flow control congestion
control mechanism chicken and the end
result is that I'm like a 10 gigabit
network you can see down to like 1 2
megabits actually realized throughput
and the stuff happens in such a tiny
window that unless you you about Jesus
being cast before which we didn't have
time you wouldn't be suspicious of me to
this business in a lot of places and it
cost them now when they were here
through the collapse we know you know
like this there's ways to fix this is
sort of the design tip anytime you can
send a hash with some data rather than
the healthy data let me do that so what
we should we what we should do in real
is send you know when those pre replica
send the results back I've only send the
data and have the other two sent hashes
and only then the hashes are different
you need to do that second round for
each of reconcile all data and that
turns out to be a trade-off because in
the normal case where everything's going
well react actually you see regular
consistent Scott so it's a fair
Cassandra does this right and then
somewhat finally I'm almost there I'm
teaching this is sort of near and dear
to me because they'd all be right
production code flashing they'd I'm just
I was so good at such a good engineer
the mania sales come now such reticence
so does something happens but selling is
in when you're selling these sort of new
systems like this and a lot of ways
selling is teaching I'm a better more
you know easily you can teach something
the shorter your sales cycles more money
and some of there's the issue of you
know is perhaps else really that
complicated I said you know we need to
lift access there actually is one it's a
it's a protocol called raft it turns out
to be equivalent to Paxos develop its
Stanford I'm at the kitty did it my
style but it's much easier to explain
you know there's maybe some tension
sometimes between being able to explain
things in a way that's amenable to
formal proofs and being able to explain
things in a way that's amenable to
actually so how complicated are
complicated things really how much of
that complexity is necessary complexity
and how much you know can be factored
away by explaining in a different way so
I'll end with one of my favorite stories
what would you finally who remembers the
connection machine the connection
machine was one of the first massively
parallel computers I don't think it had
many applications outside the NSA
like most in our technological
innovation spies kind of hit at first
but it was very cool machine you had
64,000 relatively big processors and a
big rig messenger you know they could
mess of each other and it was good for
simulations and you know massively
parallel embarrassingly parallel problem
so Danny till it's one of the guys
confounded thinking machine to mid
detection machine was talking to a
friend at Stanford and his friends at oh
hey I bet you an intern for the summer
I'm tending livestock you turns out the
intern was what you find so he was like
 what do I do with Richard Feynman
so after like a couple weeks of
fineman's sitting around and my painting
the walls and going to the store for
snacks and stuff they finally found a
use for him which was to basically
analyze the message routing
functionality of this 64,000 ship beast
in order to determine how much memory in
the buffer space saving it on him switch
to you know sort of fully utilized so
they like find them go with this for the
summer and he came back and instead of
sort of a-what a computer science person
to expect wishes inducted
recent case analysis he came back with
just like a very short elegant-looking
list of partial differential equations
over like the thing values like the
average number of ones in the address
buffer and so Danny and all the others
in computer science that's like you're
smoking crack five mins said they needed
a 85 million dollars per chip day and
said they needed seven so they're like
you know what we're going to ignore you
we're in the same ballpark you know
you're kind of watching anyway so they
called the factory and said make us
these boards with seven buffers
pritchett and I make the manufacturer
calls back we can only fit five not
seven so all right well fine Henry
sentence works we'll do it with five
it's your ass it doesn't work and it
turns out it does and the point of that
whole you know anecdote is that you know
sometimes I think we need to look
outside of our own little silos and try
to find better ways to explain things
computer science and specialist
different systems are very very long
disciplined when you compare them to the
rest of science all together and I think
that you know if you look at academics
academic papers they all site within
their own variable thing their own
narrow sort of domain and they don't
cross site other disciplines so I think
if you look at things like game theory
computational
biology is probably in there a future of
sort of distributed systems leadership
that has a much more accessible and easy
to understand natural explanation than
some of the sort of Byzantine ways no
pun intended doesn't she weighs we've
we've come up to explain this stuff so I
think you know there's some very
interesting work ahead in trying to nail
some of these down these things down be
a more inherently understandably as
consensus seems like a simple problem
when we look out in human terms right if
you need to get people who've just to
agree on something like you know they
might not be damaged their phone you got
to get a quorum of people it's all very
natural so I think we're just beginning
of a whole bunch of interesting outcomes
here so in summary pretty much is over
not that we ever have free much really
and it's really a cool time to be part
of this community I think the the next
15 years probably some of the most
interesting in terms of realizing simple
and to the extent of the event once over
this stuff let's sharpen the tools that
we have make them better incomes from
the challenge I want to thank Erlang
solutions and try for for having me one
note it's a little selfie motion reacts
es wound up for came out today reacts es
is our s3 compatible distributed objects
courage platform built on rehab it's
open source apache2 and we just came out
with compatibility with the oldest back
for a mole so you can drop it in your
OpenStack to plan that look just like
Swift except much better so thanks I'll
take any questions Rihanna
oh you're a few question honey oh sorry
yeah Santa puss up Sandra does sense
hashes instead of full objects and send
equallogic team cause tcp and cast to be
to clarify that a little bit the objects
would be pretty big from above our
recommended object size to really run
into it but yes it's absolutely we just
try to be honest someone does something
beautiful neck yeah Only Fools
perspiration yes I hear the russia uses
sample yeah so we have really played the
whole truth assistance my experiment of
them is like you know they're they're
helpful but the art experimentation term
has been creating academic and cursory
at this point they need a lot of work
and we would need to do a lot important
making our system amenable to some sort
of color
including perhaps be running in task for
some reason other than task or o camel
or something managers that are three
office language but we're always looking
in Andhra and Joe bumstead the handset
himsr I paper pretty much represents the
fasho state-of-the-art regard to going
into that sort of formal verification
directions I'm Tom say haan SDI or the
Citra hops a girl and again for you
doing oh you want the you want the real
answer do you want the one that sounds
good well because there's truth to look
about it's a language probably the best
history of lending high uptime latency
sensitive you know soft real-time
systems and Justin and I were really
into it at Le como right yeah yeah we
had both gotten some exposure to it at
our jobs immediately prior both of our
job separate jobs immediately prior to
that show and really it was sort of a
perfect storm the Dynamo paper had just
come out just starting a company to
write some databases and we were both
into the dial paper we said hey you know
all these speak machines that you know
all distributed systems in general
they're all described as these state
machines and the again the cognitive gap
between reading those descriptions in a
big dick textbook and implemented Earl
and seemed at the time these to be
narrower than say
the job our clocks or whatever once you
account for all the sort of accidental
complexity of the system and
user-friendliness then you know it
drifts apart but still a good choice we
had I think I think Justin actually just
15 years he goes through and sort of
takes 45 years on he still comes out
from the background parallax is
specifically so like problem to shoot of
existence yeah i mean the Erlanger says
the perfect sort of feature set the
immutability and this an actor model and
the ability to even though we don't take
the carrier we don't actually use the
hot code loading in rioc smoke soon yeah
definitely very summery know what we can
see hi time what's our Java Java is out
the window because of the stop of our
garbage collection although I hear that
sound but you can start that something
with that whole kind of heavy GC
cool well felt subject of our consensus
he said Jerry's kind of our live blue
box Austin is called round yes I read
the rockledge are except they're on the
distant America party came out and maybe
yeah we can bring this to a
battle-tested right right so it makes a
solution to a party yeah so sick people
zookeeper is so if you're in Java maybe
you can use mess with access you can use
it as a service which is I think
different than a library the question
was about raft this new consensus stop
them versus an Egret I think more
interesting is the fact that rats number
warm skated goal in the actual paper was
understandability which i think is new
for any computer science hey there's an
implementation of graph in that's the
standard project called Ram cloud the
actual implementation of a box of log
cabin is grant cloud as many many months
lot of cavities the long neck has the
raft for all and state machines that
implement distributed throttle body huh
I'm sure that raft incantations have
some bugs I'm sure
stand that up for suzuki 3d cover fines
and bugs but focus on understand bill
was be gay yep which is more than access
I think I a lot of time on me go and for
academic C++ code if Diego ever watches
consumption I in its actual people
outside aha it's it's a mystery a lot of
stuff interestingly though they can't
see me get the paper submitted to the
continents because all the referees say
it's too close taxes it's not now and
meanwhile like if you look at this sort
of industry community people are here
there's already like 17 implementations
of raft and name your language but
hasn't been deemed not enough to get
into like an SOS p so that's take that
deliverable different priorities cool
well sure sorry excuse me if evolution
is there no no no I'm about in that as
our long day today do you have an
opinion a lot of headaches era which o
things I'm the controversial I am happen
I haven't fightin elixir that much I
definitely applaud I'm voice instead of
a language think I let you know I'm not
going to come down hard on one for
writing writing their own language and
it seems I got just a brief look at the
syntax esteem pool I have friends with
strong opinions about it I think the
main 1i voiced is the fact that it
glosses over the the way of Earl end of
assignment and let's use sort of have
the appearance of mutable state mutable
variables when you when you know and I I
don't know if that's bad enough to
condemn it or not but I think it looks
very interesting I'd have to play with
your tip to have a strong but you don't
yeah is that a beautiful version of you
guys want to
yes the question was is so funny what a
special care about strong strong so we
do actually we have so react to that o
is coming up relatively soon and we have
to double l will have single key strong
consistency in other words like right
now you can write regular eventually
consistent rock you could write
something and then get a timeout or an
error back but actually been go pretty
that done anytime how that failure was
regular so regular reactive that
strongly consistent reactivated will
mark maybe a bucket the strong
consistent and then have visited
impaired swap related or just wrote
consistent right capability where either
you wrote it absolutely partial failure
cases I'm faking energy with regular
sort of dynamo sloppy form and so the
goal is you know you can implement
particular types using the strong
consistency that the mapper said but
then we also have crd keys so you have
nice sort of spectrum okay here's
eventually consistent with rich
properties rich data types and strong
and consistent velocity do the same
stuff so sort of fulfills the promise
that I think in the beginning we all
stop those dynamo and our w knobs
actually coupe that she do strong
consistency when they can't this I think
is
nice step you know eventually consistent
strong consistent my only hope is that
people don't choose the strong liking
system stuff because it's easier and
then miss out on some of the critics
parts of preoperative feasibility but
they're gonna have said yeah no
absolutely oh really could you what's
that really G oh that's that's Chris
yeah um no introduction never is a
perfect that's that's a side project not
in anything in react EG something about
a paper kind of project one of my
co-workers Chrismukkah chakra that was I
think to the experiment with what kind
of guarantees you divide and eventually
consistent system you know I am looking
at the other modes of sheet rock which
is an existing my process registry thing
Jared eaters we use it in our enterprise
stuff but I think once we have strongly
consistent react will replace it that's
sort of the weekly now termite they're
the best my knowledge it's not nice a
nice din official with dasha but
probably some seems like I just
yeah no I took a look at those this is
we tend to reorder yeah yeah absolutely
cool well thanks everyone enjoy rest of
you night
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>