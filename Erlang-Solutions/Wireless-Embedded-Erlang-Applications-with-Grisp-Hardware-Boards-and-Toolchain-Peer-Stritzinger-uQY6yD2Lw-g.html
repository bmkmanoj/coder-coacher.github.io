<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Wireless Embedded Erlang Applications with Grisp Hardware Boards and Toolchain - Peer Stritzinger | Coder Coacher - Coaching Coders</title><meta content="Wireless Embedded Erlang Applications with Grisp Hardware Boards and Toolchain - Peer Stritzinger - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Wireless Embedded Erlang Applications with Grisp Hardware Boards and Toolchain - Peer Stritzinger</b></h2><h5 class="post__date">2017-03-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/uQY6yD2Lw-g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I want to tell you a little bit about
how to actually use air lung on small
embedded systems getting smaller and
smaller but before I get into that I
wanted to show you the path which
basically led to the smaller and smaller
embedded systems so we started basically
with a larger embedded system so that a
box this size five kilo it's not a
really embedded system you could say but
it has all the parts is the flashing
system were program update system for
car electronic control units to actually
mass reflash them before they go in the
car and this system was basically what
started what's good actually pretty
Assessor of this aversion to got me
started with dialog so I'm reimplemented
the first version air long because it
was kind of poured and we wanted to have
a distributed system so this devices
surf Network and then I heard about this
distributed language and I checked it
out and I had a set myself like four
weeks for point of no return
I mean four weeks into the project I
could go back to the old source code and
like go the boring way and after four
weeks there was no going back obviously
as you probably all know so I'm stuck
still till then until then I trying to
apply along to more and more smaller and
people with more deeper embedded systems
because I see very big value in that so
in this system just to show it all of
you so there we have FreeBSD running on
the main board on the industrial main
board the airline runs only on FreeBSD
and we have a hard real-time operating
system called items we will come to that
later which runs on gateways like
separate hardware which talks by a USB
to the two or the Erlang talks to why
USB to the to the to the gateway modules
by the way since we are hearing about a
lot about like all the hassle of
building embedded Linux things and we at
build systems actually FreeBSD comes
with a built in thing that's called nano
BST which gives this everything for free
and which is very easy to use and you
don't need to go to five websites and
get your tools together it's just
in the box and that's why we use freebsd
also because I'm a like I've been using
BSD before Linux existed kind of so
let's look a little bit more these are
times real-time operating system it with
quotes which we actually use on these
gateway modules it's for hard real-time
more on that a little bit later well
actually be heard about like that the
real time is hard real-time is kind of
probability distributions of timings
more or less so there's more or less
hard real-time so actually in some sense
Airlines software time is also hard real
time was very with a more broad
distribution of timings so it can run on
very small systems it has reliable it's
very reliable it's like oh s all this
air long it's like from the 80s it was
built for our space applications and
it's actually used in several space
systems like Mars rovers for subsurface
I think the radio in the Mars rovers use
autumn's and several other military
systems I don't know anything about
there the ISA ISA is also using autumns
on their probe so it's it's kind of like
a very robust platform the build on it
can it's very quickly for context which
I mean this is like 25 megahertz so this
is this is all numbers
somebody did a measurement like in the
Stone Age MC is 68 360 is the controller
which was basically yeah it's the same
thing that in wasn't the first Macintosh
like the same size processor and it also
has a POSIX API which comes which will
be fortunate later in the talk it
actually it has a core operating system
it has a it has the option of having
several api's on top of that and one of
them and now the most used there's a
classic API which actually implements
these standard for military aerospace
systems and there's about there's also
POSIX API and you can actually mix and
match those and then there's some weird
API is nobody knows anymore about some
something some some Japanese API
which is I don't I don't think it will
be if I ever supported because I think
there are no users anymore
so it doesn't have processes there are
actually threats it basically every
everybody there's no kernel or anything
kernel space user space or whatever
every every every part of the system can
access the memory that's it you don't
get memory protection and all these
things so it's it's one of those the C
codes where you can like yeah you have a
little error for some like corner case
you didn't think about in your cube set
maybe and you crash the system because
you overwrite stuff you know about the
stack off the others so and everything
so it runs on basically everything
that's 32 bit and there are some weird
parts to 16 bits so in theory it runs in
60 bits but it's more focused on
embedded systems with 32 bits which is
basically nowadays almost all
interesting embedded systems which
actually needs some kind of operating
system because the 8-bit systems you use
no operating system usually just have C
code and just run loops or whatever you
don't need a scheduler there and also
very neat
it has SMP support right now and it also
uses lots of freebsd code you can have a
freebsd tcp stake on it and an old one
which is smaller and the latest one
which is actually SMP capable which is
larger and you can get drivers from
FreeBSD there's a library for actually
porting over FreeBSD drivers to autumn's
so we can actually use drivers from
FreeBSD so there's actually a connection
between my FreeBSD work and the Artemis
work by kind of accident so in in this
all system we had it separate but if you
want to have a small embedded system
where we have only one core and they're
like a small border controller thing we
actually want these things together we
want to have the LM VM and the autumns
thing together on one hardware and we
did this in 2010 for a customer for posh
for manufacturing control systems and so
they paid for the first part which I
think to them takes time for that here
again and so I thought the new platform
is a name and the name was crisp
which was actually the name of a
programming language I was developing
but yeah I gave up on the program early
entry incidentally because I learned
Ellen because Ellen destroyed my whole
plans because it took somebody stole my
ideas out of my brain sent them back
into the 80s and implemented at that I
think Joe Armstrong has a time machine
okay so that's how the system looks if
you combine the autumn's thing in there
like vm so we have the EF our long code
we have the a long runtime from from the
viet basically LM VM we have drivers in
the runtime currently poor drivers but
we can also we can also use NIF's of
course but what ARPA Travis had back
then when when we started at Heather a
bunch because you can statically link
them ports are very hooked up with
dynamic loading and dynamic linking
which are 2000 support very well but
nowadays you can statically link poor
Travis thanks to the OTP team because
they actually implemented that for a
similar system so this is basically
there are teams plop here so we're using
the POSIX API here from the drivers so
this is convenient because you can
basically just port over the Linux or
UNIX variants of the Alang runtime which
was very little friction there and not
much extra code to implement there's the
whole classic API and then there is
Network and file system there are some
file systems a fat file system some
flash file system so there's a bunch of
memory file systems that you can use in
inner tubes and so what can I do for my
allen code I can basic from there and
how it goes through these drivers and
the POSIX API and talk to like the
network stack or the file system or some
other thing where I actually have a
device like a device of abstraction in
the autumn system but I can also
basically write a LinkedIn driver or
also known as port driver and and call
it for my airline code directly and go
directly to the hardware so it's a very
short wave between the hardware and the
airline code and like for example
interrupts happening in the hardware
something happens in the real world and
interrupts gets triggered the the link
that the pot driver basically gets the
interrupt so you have to interrupt
handler in your pot driver
and you can immediately send a message
and you have a very very low latency
from the interrupt happening to the LM
cold getting a message and waking up so
this this makes the airline much more
much less soft real-time so the softness
gets much harder when you run it
actually on a hardware time operating
system but you don't get your whole VM
preempted on all the time you can also
use nips for the same use cases and in
all those things you can directly access
the hardware or a library that that
somebody else built to actually access
your hardware as you like it so coming
back to Bosch that in says Rexroat here
but it's a subsidiary of portion which
actually paid for that it's postural
actually so these are these are devices
these are prototype devices which
actually the board is only the upper
part here the lower part is just cables
so these parts actually run along on the
hardware in this operating so that's
what that's our first system we built
and it's used for like conveyor belt
systems which I can show a little bit
more about I brought a little video so
that's the conveyor belt system we
actually control this with you see there
these sports these running along it's a
distributed network of 15 the other
nodes will control the assembly line
here it's like the model assembly line
with eight meters right 10 meters and
these are the pellets are where the
products on and you need to like go go
around with that we control everything
that's moving here from aerelon
like the going around corners you lift
it up and then goes on the other ribbons
you stop it and then we have you have
they are if I did revise also in along
so we read the RFID from airline that's
you need to fix it basically to drill it
because it's like loose on the from
variable so there's some kind of it's
called indexing and fix it so that's the
application we actually built the first
part from Aaron to autumns and so since
then I actually want to open up the
whole thing and try to find a way to
make it more accessible for everybody so
for one basically I needed to clean up
the code because there was customer
like mingled in and so we need to
separate it there so this has been done
but then there's in if you want to get
into small embedded systems and run
directly on the hardware you have the
problem of drivers so the get started
with a new hardware actually it's a lot
of work initially because you need to
write all the code that gets the system
out of reset because you don't have an
operating system you might have a
bootloader it does this for you that
makes it a little bit easier but you
have to provide all the drivers from the
silver console to all kinds of like I
all drivers USB drivers whatever and
even if you have basically a bunch of
drivers in autumn's you have to assemble
all those into into a system image and
so these drivers are costly and if the
hardware constantly changes on on you
for example if I make this for Raspberry
Pi which would be totally possible
actually Raspberry Pi is much too large
for that but yeah but it doesn't hurt if
it's too large but but then there's a
new version of Raspberry Pi with a new
CPU and then you start over and have to
have to do all this stuff again and what
I want but whatever what actually was
the dream was to have like a serie
friction way for people to get started
with that like to have a hardware put it
along and just write your stuff in there
long and don't touch see even so and
this was this was the birth of the idea
to build a board which is called grid
space so the software project is called
grasp and the board is called grey space
the first board for grasp and that's how
it looks
that's a prototype that's basically
picture of this thing on my table
well actually the other thing in the box
so let's look at the parts of the of the
board so we have a CPU of course and
that's an arm seven CPU from Atmel which
gave us some pain so that's why we are
delayed so this is a fault because
actually we wanted to be delivering a
before Christmas already but yeah it's
not before I mean it's still before
Christmas again but yeah
we had a different yen in mind we
thought it will be boring to just have a
thern ette so we put Wi-Fi on which is
by the way also a big hassle if you want
to have this in the small embedded
system because you need to write all the
drivers for the right-facing which are
more complex than any other driver made
mainly you have all kinds of like crypto
setup stuff and you need to port the
tool to actually set all the parameters
and everything so we put it on a fixed
one so we can actually we know which
module is there and we can provide the
drivers in the base system right from
the start this this kind of slot thing
is this D card you can seed here it's
like the is a SD card in so it puts from
the SD card and that's is basically a
micro SD card actually and that's
basically our disk reason for that and
actually in the other system and the
initial system we had actually NAND
flash on the bonded shell on the board
by itself no SD card because like your
contacts and falls out maybe or whatever
but if you have a NAND flash then you
need a NAND flash file system which the
mainly used in FFI system are atoms is j
FF h AF FF s so J some count of F's and
s2 which is which is 2 a license so it's
GPL code and you can buy you can pay
like 50 50 thousand euro and then you
get exempt from the GPL code if you want
don't want to get your own stuff
infected but which is inherently bad for
a for embedded system which is which
should be open source because we don't
want we link everything together and we
don't want to get everything infected
because of that just because with file
system and there's D card basically I
get I get the low level stuff of our
flash files to make it on the SD card
chip for free and also it's nice to just
swap the chips like pull it out put it
in their laptop make a new system on
stick it on it's actually nice to work
because otherwise you have to flash over
the wire all the time we have memory
that's SDRAM only one chip so it's only
a 16 bit wide so we reduced the chip
count here a little bit
has 64 megabytes which is about the
smallest SD cards DRAM chip you can get
you get you can buy smaller ones but you
can't don't get guarantees that the
combine in next year and so if you want
availability in the future you need to
buy at least 64 megabyte bytes this this
this is a USB connector which basically
hosts two USB devices
that's two USB serial devices one is for
the console so that's why that's this
cable here so we look at the console on
the USB so it's basically a serial USB
thing for the console so nowadays you
don't make you don't put USB you don't
put our the serial connectors on your
board you just make an USB serial on the
board so you just need a cable and the
driver which is usually comes with the
operating system and then you can just
plug in the USB and you get your console
which is always very good to have like
if you if you into low level stuff
sometimes you do print debugging on the
console you eat that or like flashing
LEDs on and off if it's like timing
irrelevant and then have a having a
scope on the LED live wire basically and
see what timing is actually and the
other USB device that's that's basically
it's a dual device FTD I think is a
cheap chetak debugger replacement
basically so it hooks into the JTAG so
every every controller CPU has a
chatting interface which you can use to
run a low-level debugger where you can
basically single-step the CPU with
hardware support no now let it sleep so
you can single-step the cpu in the
hardware so you can actually see without
that without debugger so you have a
debugger device on on the outside and
you can single-step the CPU without
software that's supporting that and so
this this over the FTDI chip and USB
there is a there's a library called open
OCD where which gives you basically gdb
support for free so you don't need
because all the chai tech debuggers cost
money and some of them cost a lot of
money so the one I got for this for
which can do a little bit more cause
2500 euro like and and that's considered
a cheap one so next thing is yeah we
need like a few inputs so we have like
five switches on there which you can
actually read out from the from your
program so you can configure it somehow
like without the config file maybe just
as an example and that the two small
dots down there are red green blue LEDs
I mean it's always nice to have a LED to
show a blinking light
everybody loves blinky lights and the
black connectors on the outside their
connectors for a module system called P
mods these are these little modules are
half a year so it's about this is about
the size of P mods this is a larger one
and I will tell you a little bit about
more periods that they are from digital
and which are now known owned by
National Instruments who do the the
Simulink the LabVIEW Simulink things
where you can have ports from them and
then if you LabVIEW stuff and so they
have a lot of i/o modules for that and
we figured out that it would be very
convenient to be able to use those
because you get a big infrastructure of
of these P mode modules and they they
connect the space it come in different
flavors depending on what you want to
connect because it's a very low-level
interface so we have a GPIO which is
basically just four bits which you can
switch on and off and another GPIO
because four bits is not that much and
then we have a UART so it's basically
you are but not with the plus/minus 12
volt thing so the serial line basically
on the PC had plus minus twelve volt but
this is basically a 0 to 3.3 volt
because like the plus minus 12 volt
nobody I mean if you want to longer run
or long wire you can use that still but
if you just plug in a module locally
that's wasted and it's like a lot of
effort to generate this plus minus 12
volt so they they simplify the standard
here we have something called SPI and
when they can explain later what SP is a
lot of sensor chips
what spi directly out of the chip so SPI
is very important for talking to sensors
and there's an ii spi which is a little
bit larger you see that it's a little
bit like more more pins on it it's a two
row thing that's SPI plus some interrupt
lines because some devices can actually
be talk to it via SPI and the device can
notify you that it has new data or that
something happens via the interrupt line
then we have this small connector here
that's one wire I will explain what one
- later it's also for sensors lots of
sensors with not not but not very much
wiring lots of cheap sensors if you need
lots of temperature sensor somewhere one
wire is your friend and that's about it
but I forgot in the slides about this
connector that's also a p-mod connector
but it's the middle of the board because
it's eye square see a nice Krissy is
usually a bus so you run a ribbon cable
basically from from so the the pin Watts
was I square C also have the connector
an optional connector on the top
basically which then fits to the to the
chain of I square C so you can like you
can connect n end devices to this little
bus there so I mentioned a few so we
have to the the arm cortex-m seven CPU
and cortex-m is basically the mobile or
the embedded things for arm CPU so it
loose it uses less less energy and has
more sleep more variants of sleep modes
and it's more suited for this size of
application it runs at up to a three or
megahertz but you can run it slower if
you want by configuration if you want to
conserve energy maybe which is by the
way actually not the way it's done
everybody thinks you need to get the
clock slower to conserve energy but what
you actually do you run at full speed
but you run very quickly to the next
sleep and then you sleep because if you
really sleep then more parts of the chip
is actually switched off and that
conserves actually more than running all
the time for with a slower clock so but
you can do that it has a signal
double-precision floating-point which is
also kind of convenient you have you
want to port on high-level language
which has floating-point so you don't
need a software floating-point unit
and it also has some DSP extensions with
like like vector stuff and low-level
stuff to actually do some numerical
calculations very quickly memory we have
an internal memory which is actually on
the controller chip on the actual CPU we
have 2k 2 megabytes of flash and we use
that for the bootloader so the board
comes with a pre flash bootloader
which can read from the SD card so the
bootloader boots whatever is on the SD
card which in our case happens to be a
along vm link to out autumn's but you
can actually put anything with that it's
just a binary image raw binary image we
also have 384 kilobytes of SRAM which is
a little bit little for running Elenin
so we needed to add the external 64
megabytes which is actually too much to
run along and it's actually wide spaces
of tape off of memory because like I
mean they are long VM together with
autumn's uses about two depends on what
TCP stack you use it uses between 1.7
and 3 megabytes the actual image and the
rest of the memory is for your data and
the beam files to load but what I plan
to do is actually because this memory is
faster because the zero cycle it doesn't
have to wait and it's actually 30 a
little bit wide I actually want to put
the inner loop of the Erlang VM on into
the memory because that would speed up
the thing and actually conserve energy
at the same time because touching
external memory it uses energy because
you actually use more parts on the
system that actually then draw energy so
we have the micro SD socket and we also
have an EEPROM like the little
configuration things that mainly cost
nothing to put a serial in a minor stuff
like that
we also put encrypted memory device like
a like a kind of like on on the board
smart card device to store maybe license
keys if somebody wants to build
something more propriety where you want
to protect your license so I mean
everything we do is open-source but you
might you might want to use it for
something on open source which
want to protect and you can also use the
same memory for example to store your
your HTTP key is securely on the board
so you can just put it in there and then
use the crypto operations of the chip to
store the the keys in there and nobody
can read out your keys so about a little
bit about the i/o yeah GPS with lines is
basically which includes all the the
switches and the LEDs also they are
basically all in the same interface and
they will be supported by the same
driver
it's just lines that you switch on and
off zero or one power or not power and
so we will we will have a driver that
supports pulse width modulation so you
can basically switch it on and off it
with a certain with a certain frequency
in interval of on and off which like you
can use to control the brightness of the
LED so you can have lots of colors on
the LEDs also but for example also our C
servers for remote control like flying
drones and stuff like this they directly
use this pulse width modulation thing to
to get the deserves this demo to angle
where you want to actually position the
actuator so that's that's why it needs
and the plasma smoke modulation would be
kind of wasteful to make any along so
you put in the driver because usually
there the trip has internal support for
like a timer connected to the port but
actually doesn't for you SPI nice Krissy
SPI is short for serial peripheral
interface is very simple you have a
clock line you have a data line going
out and a data like going in which are
called mozi and missile means master
outs life ins life master ins life out
which is not politically correct anymore
I've been told but well yeah the the
shortcuts are kind of in and all the
chip panels they call it mostly in
missile I square C is very similar to
SPI so SPI is basically you wiggle the
clock and then you put the data
synchronous to the clock on the lines
and it's very very primitive
and if you have a chip select also so
you can have multiple you can use the
GPIO line to actually tell the chip yeah
I'm talking to you now the please listen
so only if this line is on it listens so
you can have more multiple chips on the
same lines with that I Square C is
basically the same or very similar but
it's a bus and it doesn't need the chip
selects because it actually has an
address so all these all these slaves
have havin an 8-bit address and you can
actually talk to it by sending the
address and then the data and then you
get a response and that's why you
basically you have in the middle and you
have a ribbon wire connecting all your
your sensors tell us one wire needs only
one wire for power and data except
that's not true because it you need
ground so you need two wires but it's
one one active fire and ground is kind
of ignore ground and one wire sounds
much cooler so yeah so it's branded as
one wire it's still very neat yes power
in the data on the same wire you also
can never separate you can have a three
wire and have your power separately if
you need more power but that's up to you
it's very similar to I square see it's
it's slower and more reliable so it is a
better checksum so you can run long
lines I mean I Square C is built for
like run on the PCB actually some people
make it over longer ways actually I've
put it all micro satellites use lots of
ice cuz it's between boards which is
totally crazy and and one wire is
actually built for having long lines you
can have like a 10 minute 10 meter line
yes there's a picture of an eye button
on the next slide so you can have 10
meter lines or through your whole house
and you can have connected you just saw
love the temperature sensors on it and
you can talk to each of that which is
also for this facilitate but that you
don't only have an 8-bit address but you
have a 64-bit address which is actually
pre-programmed in every sensor and it's
globally unique so if you basically hook
your sensor one by one you can actually
configure it yeah this is the sense on
main boiler and this is the sense on a
secondary boiler and you store their IDs
and then you know which sensor
are talking about to talking to so it
has a device discovery so you can
actually discover all the IDs on the bus
if you hurry up a little bit so this is
the I button this is used for some
access systems because for the Telus one
where there are some smart card like
chips so you can use it for for access
so you use the one wire so this is one
contact and this is the other contact
and you put it in a little hole it's
kind of it looks quaint now that said
you have everything this RFID but
actually I know the instable the subway
system runs on these eye buttons so
they're charging yeah you get lots of
small IC form factors like you can
solder those directly or you get lots of
on chip things and lots of sensors for
that so let's look at a few key modes
hearing up here so this for example
would be a P mode with a magnetic
compass free access magnetic compass
that's a that's a motor controller for
two arms motor so you can basically
control your motor let it run forward
and backward and at one PSU you have to
have like connectors for the power
separate connectors to actually get the
power into the thing this is actually
for controlling their RCC hours like
them the model building several
motorists it goes into one GPI own you
have actually can actually connect for
several more for several connectors
there and it has the right signals here
and you can have external power for the
service so you can hook for actuators
that move something that's a GPS module
and you get lots of communication
modules like Laura barn like the sub
gigahertz one thing you can get Ethernet
of course and ZigBee all kinds of things
as communication things that's an
accelerometer three-axis accelerometer
and what's the third one we have let's
look
that's a 3-axis gyro and that's actually
all already because there is a p mode
now which has three axis accelerometer
three-axis gyro in three axis compass in
and an air pressure sensor
so you get like 10/10 location things
four out of one ship out one p mode so
that's the latest p mode that we're
suppose was added it just came out a few
weeks ago
so yeah that's how the p mode connect on
your lab table and you can build like
small prototypes with that or like small
batches and then once you know what
what's on then you can basically you or
we could make a board basically you
reuse all the complicated stuff here and
just put the sensors on the rest of the
board and make the board actually
smaller and then that would be the
professional use case for this board so
yeah that's explanation about the p mode
there's 80 plus I think it's a hundred
about 100 P mods it's also very
convenient way to basically get started
with hardware because it's very easy to
build a P mode you get a you get a
breadboard P mode and you just sold on
your sensor you get a sensor you sold it
on and you have the usual interface that
the sensors have or the different p mode
connectors and that's a very easy way to
to get started also we made the the iOS
we made short circuit proof so you can
actually not easily break the board with
your badly riot p mode so up about time
for demo
so let me reconnect the laptop here
so I have a board here connected by I
use P power Bible by the USP no I hope
you didn't mind that it actually slept
now let's get rid of Emacs
so this is actually different now than I
intended it so let's make it a little
bit smaller this is my little window to
cut and paste my lines so yeah there you
see Aniyah long shot but which is kind
of boring so let's put it I just put
push the reset button so this boot time
is not what we will aim in for the other
system the industrial control system
boots into their long shell in three
seconds and this will this takes much
longer it's still probably a little bit
faster than most Linux systems the
reason is they say that the SD card
driver has no DMA support yet so it's
not done yet so it's a poll driver which
is very slow so reading all the beam
files which you need until you get to
their land shell is that takes a long
time also there they are link VM is oh
it's actually some things cut off let me
move the window a little bit over so
that the L and VM is still doesn't use
i/o threads yet so actually you see you
see this bursting io that's basically
the two aisles fighting for each other
because there are no threats for that
yet so it's blocking still so this would
this would be much faster three seconds
you switch it on because the CPU is
actually faster than the CPU we have in
the other port and so we can actually
put at least in the same time so now we
have the along shell here and I built a
few drivers already let's start a little
server so I built a port driver to talk
to the LEDs because you want a blinking
light and I'm stuck can you see this
should I put it further up or a larger
can I really read this yep
further up okay let's let's like make
this window shorter better yeah okay so
we are we I just started my the port
owner of the port's reiver
for the LED thing and then I can like
have I have little little things like
switching on oops
that's not supposed to happen no well
okay let's just reboot yeah that
actually didn't happen today like I
tried it like five times and it didn't
happen at all
yep but yeah that's how it is I I did I
didn't video the the demo so because
that's kind of like yeah actually now
this is the second boot time would be
really convenient so but I let me talk a
little bit more about what's my next
slides actually yeah we actually want to
have a really nice build process for
this so what goes on a SD card is
basically the there's one image which
contains the the the LLVM and the
operating system quotes now we get in
there and the rest that goes on the SD
card is just an normally long release so
you can build it with whatever way you
want but we will provide nice ways of
building it if you want to include
drivers because then you need to cross
build the VM again and we will I will
show what we will what we plan for that
but now I can actually try to actually
appease the demigods again so we start
start this server and I want to switch
on an LED and now it worked
yeah this um yeah you didn't see it I
should have hold it up so that the green
LED was supposed to go on and so let me
switch on another LED so you can see
actually more so I actually I pull off
this I put a tag on it because it's
they're so bright that if you have it on
the table there it I really hurt your
eyes oops
well that was just a okay that's even
worse yeah I need to copy the other line
no I'm running one right sorry blue one
yeah
so we basically the first number is the
channel and the three digits are
basically binary still binary because I
didn't have the pulse width modulation
the red green and blue part of the LED
basically
so since every hardware demo needs a
blinking light I wrote a little a real
loop that actually you can actually
configure what sequence of numbers you
want to have and yeah so that was the
blink light just having yeah this is
completed now so I also wrote a driver
for our sensor so I I connected the
accelerometer here so that's the
accelerometer from the front picture and
let me start the spi part owner so
they're basically only the SPI interface
is written in C and I'm talking I'm
sending SPI bits rings basically already
for me a long-- so I need a part owner
for this that's the SPI process I also
need to actually send a short string to
the accelerometer to set a certain
register and let me check if it's really
sad because otherwise it wouldn't work
which basically tells the accelerometer
yeah yeah okay so this list needs to be
a tool here so it's one bit on which
basically switches on the thing like two
measurements we told it so then we let
let's see what we can actually get from
the thing let's get a measurement so we
get three coordinates in integer now
that's the raw coordinates that's the XY
is Z Direction and what you see in here
two numbers very small one is like quite
large which is our gravity well pulling
down so to prove that it's actually the
gravity bill I let's just change the
direction and do the same line again and
now you see another number is large now
the first one is large now and if I put
it like this then the middle one is
large now and if I put it like this then
all are kind of in intermediate so yeah
so we can read the acceleration but
that's raw numbers and we actually need
to like calibrate this to the thing and
I wrote a little server to calibrate
this to extend the demo I'm sorry I've
started the server now which the whole
whole whole purpose
of the service to hold the calibration
value I mean yep that's how we do it
denier Lange and now I calibrate it
supposedly to 1g so I'm expecting 1g
here so usually if you really want to
calibrate it precisely you need to put
in the the latitude and the height you
are because you're actually a gravity of
our gravity well it's not constant and
don't do it do this during earthquakes
because then you have a wrong
calibration so that's the calibration
factor we get and now I should be able
to actually read the XYZ in G values and
you see this one is very close to one
that's the precision of the device and
for you what you can see also is that
actually the calibration needs to be
done for all the XS I learned so you see
this one is actually not really Oh
actually this one is a little bit high
so I probably was not like lining it up
right but it's a little bit yeah it's
filling but yeah that's not the point
so let's get the absolute value of the
calibration by like square summing the
whole thing and putting it under square
root so I'll be getting like one ish
whoops sorry
and you see it Wiggles around a little
bit and if you if I wiggle the board you
see I get all kinds of values like 2g
1.7 G 0.7 G when I go against the
gravity and go around so yeah so what do
we have now we have four sensor and an
actuator and let's hook them together
because that might be nicer so I wrote a
little loop and put I spawn it off in a
little server which actually gets the
acceleration value and puts it puts it
to the LEDs so the RGB of one LED is now
the if the G value is like above 0.7 I
think in this direction and the other
one is the negative direction because
positive and negative so what's supposed
to be I've blue now you see the blue LED
no you already don't see it but if I if
I actually turn the board and the color
actually changes blue again
and you can see I'm proud you can't see
from brag if I basically change over
here so now the one red LED goes on and
now the other green goes on the negative
one and yeah there was one demo then I
thought maybe something more exciting
let's just like switch on the LEDs and
so I'm stopping the server that's a
different transformation they're
switching to LEDs if I basically go just
beyond some some acceleration basically
so like some kind of more differential
so if I shake it the LEDs flash and
their flesh and different colors
depending on how I shake it and you can
like if you do it like you can make a
lecture here yeah so that's the end of
the demo I have a few slides but we're
running out of time I think yeah so let
me put the last slide up yeah the build
process I'd whoops no I broke the Bema
no the build process basically it's
supposed to be its rebar sorry and it's
supposed to be seamless and really we
really want to get you into the into
playing with the thing on air long
seamlessly by providing all the drivers
for all the hardware you can have to the
Erlang level and then you can just have
more fun and less like annoying C coding
whatever yeah there's also yeah forget
about it it does it doesn't only run and
it runs all the languages that I mean
you put beam files on yeah the no matter
how you produce the beam files it's up
to you we using Arirang but you might
want to use one of the other ones so it
can if you lure Alex here this flavor
they learn whatever you want there's
some slides about hard real-time that's
planned for me to get hard real-time
process on Aaron which I have to skip
over now it was like the stretch goal if
I was like the Emma was broken at too
much time or whatever so the status of
the board we actually we have behind our
time table because we want to actually
do ship for Christmas but we open our
web shop now for pre-orders
the board was a SD card which already
basically unpack it you hook it with
wire USB cable to your laptop and it
basically puts into a long that's that's
the whole thing done already will cost
about one hundred seventy nine euro
which is about the same amount in
dollars which is kind of high for these
boards but actually we're selling these
at cost and it cost means we basically
we subsidize the development cost for
the board so we will never recover this
we try to basically real support for
internal prototyping and and kinds of
things so if you sell lots of boards we
maybe can drop the price a little bit so
buy a lot of boards then the price drops
but that's what we get supported the
bots are very good quality they are made
in Germany actually we have soldered in
Germany not in Romania or China where
you get like lower prices of course but
it's only valuable for very large
batches actually and so if you have
small batch manufacturers you usually go
to your local manufacturer and we have
very good ones in Germany lots of PCBs
are produced still in Germany even if
it's expensive like because we kind of
have higher salaries okay I don't know
do we have time for questions no
actually yeah sorry about that so just
come up to me in a speedo</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>