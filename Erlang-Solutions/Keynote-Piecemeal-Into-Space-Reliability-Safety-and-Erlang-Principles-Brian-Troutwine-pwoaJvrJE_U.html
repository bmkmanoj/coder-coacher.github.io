<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Keynote - Piecemeal Into Space   Reliability Safety and Erlang Principles - Brian Troutwine | Coder Coacher - Coaching Coders</title><meta content="Keynote - Piecemeal Into Space   Reliability Safety and Erlang Principles - Brian Troutwine - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Keynote - Piecemeal Into Space   Reliability Safety and Erlang Principles - Brian Troutwine</b></h2><h5 class="post__date">2017-03-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pwoaJvrJE_U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I've been doing airline for quite a
while I encountered Joe CSIS I think
nine ten years ago and at that point
I've been hooked I also speak about
Space Systems a lot and the question I
get is why aren't we using airline in
space or what would it take to use
Erlangen space so my talk today is
piecemeal into space and I want to try
and answer that question
I want to answer what will it take to
actually get airline into space and I
think it's important to to start to
understand first what is airline it's
important to understand the computation
model it's important to understand the
machine that Aaron Lang is proposing so
this is a process in airline this is
kind of the fundamental unit of
computation a process is sequential
internally so in a computation you write
is sort of going through in a way that's
easy to understand and predict it has a
unique name it has a pig you can also
assign a more human-friendly name to it
and it has isolated memory so you can't
fiddle with the memory of a process from
another process you have to send
messages so this is really the first
basic component of the the airline
computational model memory separation
and then fiddling with memory through
message passing and each one of these
processes is responsible for
interpreting and these messages so
messages end up being little units of
computation to processes interact by
sending what one another asynchronous
messages and they do so by sending to a
name either a pig or a human readable
name now if you want synchronicity and
we use synchronicity that's not actually
a primitive any in the airline
computational model that's actually just
built on on top of asynchronous behavior
you simply have two processes one sends
an asynchronous message to the other and
then wait for the process that it sent a
message to to respond back appropriately
so that's not built into the the basic
language processes can be linked so
links are formed either by spawning
automatically or by two processes that
are alive one knowing the process that
it wants to link to as links are
unidirectional so if a links to B it
does not imply that being be links to a
and by default links don't do
called trap exits which means if you
have linked to a process if a links to B
and then B crashes that exit will
propagate back up so you have a process
here that is linked to another one the
process is crap
or crashed the exit is not trapped and
then that process flows up as well now
it is actually possible to trap an exit
which is how you catch these exits which
tell you do something intelligent with
them and they end up just being
asynchronous messages so this is a
situation where our friends with the
dangerous link if it should crash it's
linked safely by trapping the exit on
the link to a process up at the top and
this is how supervisors work in OTP so
OTP is set as a set of behaviors built
on top of the primitive computation
model it's not based into the language
it's simply formed out of this
fundamental computation model and
crashes end up just being messages just
normal messages that you receive and
then you can act on so it's possible for
a process to to link up you can make
many links from a process and you can
build increasingly complex hierarchies
of processes and these processes
represent some unit of computation there
they're running independently of one
another they're sending messages back
and forth and it's up to you the
programmer to build order out of all of
this so it's a relatively limited set of
primitive now there's one small bit
about messaging that really needs to be
explained each process it's hard to
overstate this is uniquely identified by
a pit and that pit encodes information
about what machine is running on it
encodes information about the individual
process running on that particular
machine but you can also assign a name
to a pit through this sort of global
registry that all the machines that are
coordinating in an air link system are
able to understand so here you see some
process that's sending a message to a
named process now the neat thing about
that is should that mange process die
it's supervisory or supervisory process
can simply restart it so the process
that's sending
just doesn't need to be involved in the
the re replication of a certain part of
system so if you have a defect if you
have a crash that part of the system
just comes back on and anything that
sort of coupled to it is none the wiser
which is fantastic because it means that
you're able to remove an entire classes
of state management out of certain
subsections of your program and etc etc
you build larger and larger these don't
even have to be running on the same
machine that sort of transparent
transparently handled for us you can
inspect that but you don't necessarily
have to and there's really one last
piece to the fundamental airline
computational model and that's time so
airline is a soft real-time system and
what that means if you have two
processes a and B and a wants to send a
message so in this particular case a is
a process that is sending a spin
stabilization message to process B which
presumably handles firing engines or
what-have-you
it then calculates the deviants and
fleets for a little bit so in this
diagram a sends a message to B and
calculates that it needs to sleep for 3
seconds after 3 seconds exactly 3
seconds it receives a wake it wakes up
and then it sends another message
because it's done its computation now
this is an example where the timer has
returned in the exact amount of time
that you would hope so this is
accidentally a firm or hard real-time
system but airline doesn't guarantee
that what airline guarantees is that
your timer will return no sooner than
the deadline that you've set so for
instance this is also a valid situation
so the process a is said I will sleep
for 3 seconds and then after 6 seconds
it wakes up intended message
now the the joke about real-time systems
is actually that firm and hard deadlines
are are based on probability and it's up
to you as the programmer of assistant to
sort of drive the probability of a
deadline flip down so if you have a
micro meteor that shatters a bus your
computation might be interrupted past
your deadline so it's possible to build
firm real-time systems in airline you
just have to work it correctly so the
the primitives are soft but you can you
can drive that probability in the
way so you know out of these primitives
what qualities is is that airline
provides what classes problem does
airline solve so these we should all be
pretty familiar with the first one is
fault tolerance so you know if you have
a process that is managing some type of
computation and it crashes that you've
given it a name you have a process up
top that catches that crash and then
restart a Nupur rather starts a new
process and assigns the same name at the
same code then anything that calls into
that is none the wiser
and that's fault tolerance and it's
great it provides soft real-time
operations as a fundamental feature of
the language to sleep the timers these
are fundamentally built into the VM you
get concurrency which means that the
processes that run an airline are what
are called preemptively scheduled every
50,000 reductions which is effectively a
function called plus and Fiddle factor a
process gets switched out and a new one
starts to run if you have only one
processor in machines you can only one
run one process at a time but the neat
trick is because you have memory
segregation between processes as soon as
you have multiple processors you can
start to run them in parallel and
they're none the wiser and airline fun
dimension provides memory safety it
doesn't provide memory safety in the way
that something like a to spark does by
denying allocations at runtime or rust
where it has an a theme type system what
it does is it just disallows any sort of
memory access patterns that isn't
copying that isn't passing a message
which is a pretty neat trick but if
you're going to try and apply air laying
in extreme situations you you really
have to understand how it maps to the
machines but this is a high-level
computation model but it doesn't really
reflect the basic reality of the the
machines there's no mechanical sympathy
to this explanation and space systems
are usually in extreme environments so
it helps to know what does their leg or
how does their leg do what it does
you know the computational models we've
been discussing above is accurate but it
doesn't you know really get to the the
core of how you're interacting with
these complex machines
so if you'll recall this is the first
simplification that we showed simply a
process but this is another more
complicated simplification of water
processes so this is the same process
with a view toward its internals so the
first thing is a process has its own
allocated block of memory that sits
inside of itself so if you actually
start to tear apart the beam the the VM
that airline runs on each process will
be a C struct and you'll see this simply
referenced in there a block of memory
the neat trick about this is every
process because they're the potentially
running concurrent or parallel to one
another each process is able to allocate
and deallocate in its own space so it
doesn't have to reach across the VM it
doesn't have to take a lot to do it
because it is simply executing
sequentially in itself the other really
neat trick about this is airline is a
garbage collected language and if you've
ever read any papers on garbage
collection in real time system you know
it's a problem real-time systems
effectively mean you can't pause for an
unbounded amount of time and garbage
collectors mean hey we're going to pause
for a potentially unbounded amount of
time to collect your garbage Airlines
pretty cool because it does not have a
global pool of memory which is not
strictly true as binary heaps and
whatnot
but because processes have their own
internal memory pools they're able to do
garbage collection per process which
means that if you in fact suffer a GC
pause you only suffer it in one process
the other nifty trick here is most
processes and airline systems are
relatively short-lived
so you allocate a process in the VM it
gets its own memory it allocates some
stuff that fiddles with those
allocations and then it kills itself you
don't ever have to do a garbage
collection there you just free the
entire thing at one go and because
you've achieved strict memory isolation
by by hiding airline process memory
inside of the process itself you don't
have to reason about concurrent memory
access patterns which is extremely
difficult if you've ever had to do it
it's just a problem that's totally solid
so as mentioned you have to manipulate
process memory by sending messages and
and when I say you I mean you send a
message to a thing and hope that it
manipulates the memory in the way that
you've agreed upon ahead of time so on
the left hand side you see the the
message queue so every process has a
FIFO queue it's an unbounded queue that
it receives messages into so there is a
dual lock situation there's a lock on
the received side if you send a message
in you take that lock you put the
message in if you read a message out you
take a lock on the bottom and you take
it back out
it's FIFO ordered so you have to do
something if you want to receive
selectively that's kind of unfortunate
so receives in airline are selective so
you can set a pattern for the type of
thing that you want to receive which is
a pretty nifty trick if you combine that
with an unbounded queue you run into
pretty harsh situations if you have a
process that's overwhelmed selective
receive does a linear search over your
queue until it hits hit the match if you
have a process that's programmed to
selectively really receive only one type
of message but it just received a random
garbage from the rest of the system
which can happen if you have a bug it's
message queue will fill up with random
garbage and you'll start to see latency
stick up for each one of your received
the Selective receipt or receives an
airline are also one message at a time
which is a little bit unfortunate
because if you have to act on ten
messages then you have to buffer them
inside of yourself but that's okay
that's not too hard to do airline
messages or excuse me airline processes
have a link to their own code so they
don't store the code in themselves but
because they have a link to a code that
link to code that allows you to do nifty
things where you can live update the
airline system so when you start to
reference code you have a pointer to a
pointer that sits inside of a pool but
that means that it's possible for you to
say apply a new release into a running
system and and that's just how that
works because each process sort of knows
what
version of the code that's pointing to
and what it should be executing on and
and multi-version code running is great
when you realize that you're you're
deployed system has some type of bug
that you can fix it's a relatively low
frequency bug you fix you apply the new
code your processors or your processes
restart you get the new version of the
code
if you've ever done hot code loading in
an on-air Lang system you tend to patch
a binary my favorite example of this is
Voyager 1 which is uh excuse me Voyager
2 which was programmed in Fortran it's
now past the heliopause which means it's
outside of the solar system once it did
its primary mission they wanted to
upgrade this upgrade the system software
but there's no facility for doing that
so what they did was they realized that
they could cause or they could trigger a
bug to cause the code loader inside of
the Voyager computer to reference a new
place inside the voyagers so they
uploaded a tiny little program they
triggered that bug that tiny little
program then pointed a satellite Hertz
receiver back at the earth it received a
new stream of data and then over wrote
that in memory that new stream of data
happened to be a brand-new program which
would allow it study the heliopause in
15 years when it slammed into it
Airlines a little easier to do the map
it's also safer you can roll back if
they had screwed that up
it would be a dead spacecraft it would
be a testament to human hubris flying
outside of the solar system and then
airline processes you know have a little
bit of metadata in them they have
references to timers they have
references to links their priority if
you didn't know you can set airline
process priority it's relatively coarse
grained but it is possible to do so
that's that's an individual process and
you know we have talked about you know
concurrency and parallelism of airline
processes but how does that work so the
this is a view of a relatively small
virtual machine on the right hand side
you see the process that we've been
discussing and the structures bottoms
are scheduler threads there are
different types of
Red's running in Airlines we'll ignore
them for for this Youth scheduler
threads are the things that simply run
processes their operating system threads
processes only run when they're in the
scheduler threads dock so if you have
say two scheduler threads as you have
here and you have four processes only
two will be running at any given time
now that's a little bit complicated
because it depends a number of CPU cores
that you have as well if you have two
scheduler threads but one CPU core then
even though you'll achieve two processes
running concurrently you'll only have
one process running at any given time
and that will depend on the operating
system swapping your scheduler threads
in and out and as I mentioned before but
it's worth repeating air Lang is
preemptively scheduled so these
processes run for a certain amount of
time they then get frozen and then they
get pushed up to the top and a new
process run so this is an example of a
VMware one scheduler thread is very
overwhelmed there's one scheduler thread
running a process there's one that's
totally empty and the schedulers in the
beam work steel to to balance the load
between them so that you you drag down
the latency of the individual process
because if you're if you're the process
at the top and you have to wait for all
of these processes to go through
effectively from the point of view of
one of your timers your timer will start
to slip so if you'll recall back to the
situation earlier where we had a process
that got its timer exact or its sleep
excuse me of three seconds and then
another process later that took six
seconds maybe it was at the very top of
one of these scheduler thread stacks so
the VM will try to work steel and that
just means that the other scheduler
threads will come through and just pop
work off and they'll start to run them
the exact algorithm that the beam uses
varies a little bit from release to
release and it's not available to the
airline programmer for manipulation it's
simply a fact of the beam so the beam
itself is optimized for a particular
kind of workload so this is messaging
you know one message sends hello Jo to
another process what does that actually
look like in the reality of
machine so here's the situation where we
the process of the left-most
sends a message to an on running process
and the right-most scheduler thread so
it's possible to send a message to a
process that isn't actually being
executed by any scheduler and so that's
why there are locks only these message
queues because a to two threads might be
running two processes can in parallel
and they might try to send a message to
the same message queue so if we sort of
zoom in on that one process this is a
process that's very overwhelmed it's a
very popular process and and this is
where unbounded message queues get
problematic so we don't actually know
how many messages are in this process
but if it's doing a selectively receive
its latencies are going to go up so you
have to control for unbounded message
queues you have to do an analysis of
your system to make sure that individual
processes don't get overwhelmed if
you've ever run high scale airline
systems you'll have hit this problem one
particular trick is to periodically just
query in your process how many message
messages you have and then just drop
them you figure ok well I've gotten
overwhelmed
I can't process them anyway I just drop
the messages that's that's a little
unfortunate but that's one way that I've
seen people resolve that and that's how
I've resolved that in my own systems any
of these processes can be you know
supervisors gen servers any of the
high-level constructs that we work in
from day to day none of those are
actually reflected in the reality of the
machine
those are abstractions that we've built
over the top of the reality of the
machine
you know airline schedules
self-contained units of work over
operating system thread and the
manipulation of memory has done through
message passing and that's the that's
the fundamental idea anything else is
kind of sitting over the top it's a
pretty tidy system it's a really unique
idea executed in a way that doesn't feel
owners so if you've ever programmed
real-time systems you've probably built
something a little like this it was much
more difficult to do so airline provides
that method of computation to us
effectively for free but with trade-offs
in that we lack certain types of control
and the VM is a little a lot more
complicated for instance you have a
global binary heat for binary server
above a certain size the naming the
human assigned names are actually in a
hash table that's protected by some
locks and is just a hash from a name to
pin and I think vice versa the VM is
really complicated it's also fun to read
through if you want it's not simple but
but give it a shot
so how are space systems structured so
that's how air lighting is structured
but but how our space is constructed so
this is the new horizon it's currently
past the orbit of Pluto so it was
launched in January 2006 and it zipped
through the solar system and did a flyby
of Pluto in July 2016
it took this pretty famous photo of
Pluto on its way out the the heart photo
which I don't know if you've seen
somebody drew eyes on it and really very
happy put of a pretty devastatingly
terrible planet it is it is almost as
cold as you can possibly get so New
Horizons is so far out in the solar
system you'll notice that it doesn't
have any solar panels that's because the
Sun that this distance is basically a
dim star so solar panels are effectively
a waste it's not worth the large cost to
to shift them up New Horizons runs on a
relatively limited amount of power it
also is so far out that that huge
antenna dish it collects all this data
it stores in a memory scientific data
about Pluto and then it sends it back at
600 bits per second so it's still
sending the information that it
collected on it's very fast flyby today
and it's supposed to to to wrap up at
some point in the middle of this year
so that's New Horizons sort of viewed
from the outside but this is also new
horizons viewed as a block diagram so
the New Horizons is powered by a radio
Thermal generator I said that solar
panels were a waste of lift mass which
is true a radio Thermal generator is
is pretty cool if you've never seen one
it is a tube with radioactive pellets
inside that tube heats up and then you
surround that tube with electro thermal
couples so as that tube heats up it
heats up those electro thermal couples
they generate electricity and that
electricity then powers the spacecraft
the nifty thing is there's too much heat
now new horizons for instance its
propulsion propulsion system has a
little catalyst in the bed of the
propulsion system that has to be heated
before you can turn the thing on so they
just bleed heat off of the tiny little
nuclear reaction in the back of the
spacecraft into the catalyst bed or if
you have scientific equipment that has
to be warmed up before you can open a
shutter same deal so it's a tidy little
self-contained
system and RTGS are generally used in
areas where you don't have access to
thermal power it's one of the odd
benefits of the cold war that we've got
a lot of waste plutonium sitting around
and what we've done is decided to put it
out into space for instance we are we
are littering Mars with radio thermal
generators this is an RTG sitting in the
back of the Mars Curiosity which is an
SUV sized scientific robot that just
kind of tools around Mars
so we're particularly interested in the
computers subsystem of New Horizons so
there are actually two computer
subsystems in New Horizons the command
and command and data handling which runs
all the radios and interprets all the
information that it receives over the
radios it sends information back and the
guidance and control subsystem so
because New Horizons was so horrific ly
expensive because you can't go out and
repair it if it should fail each one of
these computers is redundant so there
are actually four computers to C D and H
and then to G and C computers and
they're able to detect failures by
analyzing the bus so there's a as I
understand it there's a tiny little
microcontroller sitting in the middle of
each one of the buses detecting signal
degradation and they flip them off New
Horizons is a really weird computing
environment if you're going to get
irradiated in the solar system the first
place you're going to get irradiated is
is in the orbit of mercury if you if you
go basically any further in you're just
going to get vaporized and I don't know
if you can rightly call that irradiated
if you want to get irradiated but you
don't want to go near the Sun fly past
Jupiter Jupiter is a pretty radiation
harsh environment and New Horizons had
to boost do a gravity boost around
Jupiter so it got irradiated pretty hard
when it flew around so the processor
inside of New Horizons has to be what's
called rad hard it has to be able to
survive a radiation hard environment it
runs a mongoose processor which is 12
megahertz and it has a few hundred
kilobytes of available ram to manipulate
because the Mongoose processor is
relatively tiny it's worth noting but in
any spacecraft especially a spacecraft
that goes out quite far to the solar
system this thing was launched in 2006
which means that it started being
designed in 2000
based people are pretty conservative so
a cutting-edge processor in 2000 wasn't
going to be something that they would
fly they would fly something that would
be 10-15 years old so really any time
that you you deal with space equipment
you're looking into the past and my
understanding is that now John Hopkins
Applied Physics Laboratory built New
Horizons now they've upgraded to
something that's a couple hundred
megahertz processor in any new thing
that they fly so the the power
constraints on New Horizons are
particularly tight you know the the
craft is powered by a single RTG that
only gives you 200 Watts New Horizons is
unusual and that has such low power
capability but this means that the
software that runs in the New Horizons
has to be very power conscious the
software really controls everything it
manages all of the different hardware
requirements the each one of the pieces
of hardware send real-time streams of
telemetry beam over buses and then the
computer system evaluates that and it
either execute the sequence is a
sequence of commands so if you're going
to interact with New Horizons what you
do is you
have a little packet of information you
ship it to it over the Deep Space
Network you wait for the speed of light
to hit that spacecraft the spacecraft
receives it and then interprets it which
if you squint real hard is message
passes passing we can't go out and
fiddle with the memory of New Horizons
but we can send it little packets of
computation and then require that it
operate on them and that's a common set
of Hubble Space Telescope is the same
way you send it a little packet of
information and then that causes the
on-board computer to to fiddle with the
actual hardware new risings is also able
to detect faults in itself generate a
beacon tone tell the human operators
that it needs some work or go into safe
mode and safe mode for New Horizons is
pretty fun safe mode for any spacecraft
it's pretty fun it can't come back for
repair so they have to point themselves
at a well-known spot so that we can
interact with it so safe mode for New
Horizons is either earth safe or Sun
safe Sun safe is the least preferable as
I understand it because there are fewer
opportunities for pointing the Deep
Space Network at it earth safe is the
best but that means that even in a
degradation state the new horizon still
has to be able to do orbital
computations to figure out where in the
solar system the earth is because it has
to keep pointing at the earth you have
to understand that New Horizons is flung
out of the solar system it's achieved
Solar state velocity so it's important
for it to be able to even with its
deviated by gravitational perturbations
to be able to point at a well-known
place if you if you kind of look here in
the guidance control system you know
there's star trackers so it's able to
point a telescope and then read the
stars to determine its position in the
celestial sphere inertial measurement
unit so it's and detectives deflection
it's a really complicated thing it's run
by a 12 megahertz processor some even
more primitive computer that I'm very
fond of is the Apollo guidance computer
and I've talked about the Apollo
guidance computer a lot it was a
computer that was designed in the 1960s
it was it was pretty advanced for the
late 50s and it was flown in the late
1960s to the moon the thing that I want
to point out real time environments are
very strange
in terms of time so in airline we get
this very nice high-level time facility
but machines sympathetic environments
have to actually deal not with time so
much as interrupts and that's what I
want to focus on this is a view of the
Apollo guidance computer interrupts in
one second there are six different
timers or interrupt timers
the first two are mission time so the
the Apollo guidance computer had 14 data
bits in any word and these timers still
registers in in memory so if you is the
software engineer want to know what time
it is you have to pull two registers so
the the first time is time one and
you'll notice that time one is actually
lower in the in the list than time two
and there's a reason for this time one
fires every 10 milliseconds and if you
sort of do the math in your head that
means that the word that it fills up in
memory will overflow periodically and it
overflows up so it overflows into time
two's register which if you sort of do
the math in your head means that the
total clock time for the Apollo guidance
computer before it wraps around time
zero again is slightly less than a month
but that's okay because the Apollo
guidance computer really only need to be
on for two and a half weeks so the
second type of time is the wait list so
the operating environment of the Apollo
guidance computer was written in machine
language with abstraction built on top
of that the wait lists are simply
low-level routines that the computer
needs to do it periodically needs to
listen to buses it periodically needs to
swap some bits of memory so that you can
receive command telemetry from the
ground and that's what the wait list
does and it's written in the lowest most
hateful machine language available to
the programmer time for is T for ruff
which fires every 20 milliseconds and
this is for synchronous i/o processing
so if you're an astronaut inside of the
Apollo guidance computer excuse me
you're very tiny inside of the Apollo
spacecraft which are still tiny they had
to be short men
if you're in the Apollo spacecraft and
you flip a toggle or you press a button
on the disk II which is the the more
direct interface to the computer that
the astronauts had you have to wait 20
milliseconds for one of these timers to
fire and this is just a periodic pull of
the computer so the Apollo spacecraft
was fly-by-wire to free up the
astronauts to do actual science instead
of just flying a tin can to the moon and
back the computer would be commanded to
hold certain attitudes to perform
certain functions but the computer had
to know that had been commanded to do
that one of those commands was the
digital autopilot or the DAP and the DAP
has its own interrupt that fires every
20 milliseconds the 20 milliseconds to
120 milliseconds a should say this timer
is programmable even so the software
inside of the running inside of the
Apollo guidance computer is able to say
I need the digital autopilot to kick on
in 40 milliseconds and then the digital
autopilot would do so and that it would
compute what needed to be done so at the
astronaut commanded the computer to keep
a certain attitude or to do a certain
burn so that it you could inject into
lunar orbit the digital autopilot would
manage that it was possible for the
astronauts to avoid the computer
although they preferred not to the
digital autopilot 20 milliseconds to 120
milliseconds is a long time if you're
exposing hydrazine in a combustion
chamber to the vacuum of space so the
digital autopilot actually has a finer
clock that it can program part of me and
that's called the fine-scale clock and
that's a sub millisecond timer so if you
need to fire an engine for say just 10
milliseconds then that's what the
fine-scale clock would be for so time in
a real-time computer is very strange
there is no concept of time there's
concepts of counters driven by certain
ticks and and that's how time works and
we can build time over the top of that
you know even in our own personal
computers we've really tricked certain
tie
crystals that are vibrating a certain
rate to act as time and they just
perform interrupts so if you've ever
built an operating system mm-hmm part of
me
if you've ever built an operating system
one of the first things you have to do
to do anything interesting is build an
interrupt handler and that interrupt
handler is just the thing that that
handles these tics and real-time
computing environments expose that as a
first-class citizen and that the neat
thing about the AGC is that many of
these timers were programmable so it was
possible for software to manipulate the
rate at which these things tip the wait
list the people roughed in the
fine-scale clock so if someone was
pressing buttons on the disk ep.4 reps
would be programmed to fire more rapidly
so the astronaut didn't get frustrated
and if you've never seen inside of the
lunar module the interface to this
computer is pretty crazy this is the
interface to the computer it's also the
spacecraft the astronauts were simply
trained to know what these would do but
the computer is responsible for
interpreting every switch of every
toggle and every every program that gets
entered on the disk each which is this
lovely device right here
the other interesting computing
environment is relatively newer and
these are cube SATs so keep stats are a
new development they are small and
they're because they're small they're
relatively lightweight the primary cost
of any major Space endeavor is actually
just getting it out of Earth's gravity
well if you're out of Earth's gravity
well you're halfway to anywhere in the
solar system
so Cube sets are an approach to to work
around that they are the smallest one
are called 1u CubeSat they are 10
centimeters by 10 centimeters by 10
centimeters internal volume and 2
kilograms or less is my understanding
cube sets are also neat because they're
so small because they're so cheap it
opens up space opportunities to
universities to particularly rich
individuals or sub organizations inside
space agencies that want to put a thing
up for a couple of months so new
horizons I think cost around five
hundred and fifty million dollars and a
CubeSat one long
we'll set you back a cool $100,000 not
including hardware cost but the hardware
is actually pretty cheap because cute
apps are basically disposable they just
burn up in Earth's atmosphere it's their
their off-the-shelf hardware so on the
left-hand side you have an earth sensing
CubeSat which has a pretty nice camera
in it and then off-the-shelf hardware
boards then on the right hand side you
have a 3u CubeSat which is 30
centimeters by 10 by 10 meaning that you
have more internal volume you can do
more complicated space stuff you can fit
more batteries in which is an important
consideration but it's still
off-the-shelf hardware NASA even had a
series of CubeSat called phonesat which
were exactly what they sounded like they
just embedded an Android phone inside of
one of these housings and then launched
it up this means of course that your
computer is not rad hard but if you're
inside of a low Earth orbit you're
within the Earth's magnetosphere so
you're relatively protected from solar
radiation so if you flew one of these
things past Jupiter you'd have a real
bad time actually you'd have a dead hunk
of metal but you're actually flying
these things in low-earth orbit so who
cares the other neat thing about Cube
sets for private organizations you know
it's off-the-shelf hardware so they're
easier to program because they're so
light you can test them you can test
them in production by sticking them on
the bottom of a helium balloon and
lifting them up out of the atmosphere
and you get a sense of how your
batteries will behave one of my favorite
defects is when people put a lithium ion
battery up that isn't space rated and
they expand them and pop the housing and
then your CubeSat flies apart there are
a couple images of that happening in
from lower end lift agencies so
basically if you have enough money you
can go to anybody to have a rocket and
say I want to put a phone into orbit
you've wasted money but you can
absolutely do it the Indian Space Agency
has done something really interesting
recently that lowers the cost of CubeSat
they in February of this year they
launched 101 CubeSat from a single
fairing so it's a shame that there was
nobody around to look at it but the
fairing would have popped off that that
aerodynamic cover that you see there at
the top comes off once you've started
doing your gravity turn but then it
would have just been like seeds coming
out of out of the housing but these were
all satellites for Earth sensing
purposes for lunar sensing purposes
running on trial runs now because Kives
apps are so small you don't get the best
equipment this is a photograph of
Western Australia and if you've ever
seen photographs of the Earth taken from
space in the 1950s this is about the
same quality but its color instead of
black and white and it wasn't taken by a
man in a can the particular spacecraft
that took this was the Vermont lunar
CubeSat and it had a relatively long
life it flew from November 2013 to
November 2015 which is two years it got
a free ride up from NASA and its class
the other Cube sets that it went up with
83% of them failed but this one operated
for two years and it would have kept
going had it not slammed into the
Earth's atmosphere the the thing that
distinguished the lunar CubeSat is that
they use a programming language called a
de spark so if you've never programmed
in a de you probably also not work for
the Department of Defense a doe was a
programming language invented by the
Department of Defense meant to be used
for avionics satellite systems things
like that spark is a subset of ADA that
disallows dynamic memory allocation it
takes the runtime checks that are
available in Ada and turns them into
compile time proof so you're able to
build relatively safe systems and and
the software programming for this was
done by University students working in a
to spark most cube SATs are killed by
software defects yeah
most keep that's are killed by software
defects the hardware is relatively easy
to do most of them are written in C or
C++ and they hit unusual conditions and
then they crash because if you've ever
tried to write supervisory structure in
straight fee you'll know that it's
relatively difficult to get that right
especially if you're a second-year
university students so you know what
problems actually need solving in space
systems if we're going to try and apply
airline which has this particular notion
of safety to space systems we really
have to understand what the software
systems running and these devices are
doing the first is you need explicit
interrupt control you have to be able to
interact at a low level with the
interrupts that the machine is sending
you this is incidentally this is my very
favorite rocket it is the delta 4 heavy
if you've ever seen the space shuttles
got three engines on the back this is
actually just three shuttle engines
mated to three shuttle main tanks and
the the two tanks on the side just fall
off at a certain point watch it on
YouTube it's crazy to launch a watch it
seems like it should blow up on top of
this is the Orion d4 so NASA is
currently working on a manned mission to
Mars and the spacecraft that will take
people there the crew cabin anyway it's
being built by NASA the service module
is being built by the ESA Orion is going
to do a shakedown cruise around the moon
meaning that we'll just go around the
moon late 2018 is what NASA has been
saying who knows if they'll be able to
keep that schedule when the Orion goes
around what they're going to do is
release a bunch of cube stats so you
were calling I called it the Vermont
lunar CubeSat which is weird because it
was in low-earth orbit what they're
going to try and do is take that CubeSat
technology made it to some ion ion
propulsion and then soft landed on the
moon and then send images back from the
moon languages also must be able to
create and manage real time computations
so that's pretty native in airline you
know we spawn up a process and then we
spawn a timer at the same time if that
process
signal back to us we kill a original
process BAM management of real-time
computation that's actually really
tricky to do depending on your real-time
operating system support in C or C++ or
ADA it really comes down to the
fundamental operating system that you're
running on you also have to be able to
do dynamics computation so you have to
be able to do number crunching you can
build a special-purpose ASIC to do these
things for you but that draws power so
maybe you want to use spare cycles in
the general-purpose computer to do these
computations which is what almost
everybody does the space shuttle had
special purpose hardware inside of the
GPC to facilitate orbital computation
the GPC was the general-purpose computer
for the shuttle we now just call those
floating-point units the the last thing
that you need is or not the last thing
but you also need fault tolerance so
this is the Mars Opportunity down there
in the lower right hand corner the Mars
Opportunity developed a really fun
problem one of its engines on its wheels
burned out so the Mars Opportunity now
has to be driven backward because it has
to drag that dead wheel had the software
of the Mars Opportunity not understood
fault had it not understood that it had
gotten a mechanical fault it would have
continued to execute its program if
you're going to interact with a lunar or
excuse me a Mars rover what they do is
they they pass it a message they send it
a little unit of computation and then
the computer that happens to be attached
to a nuclear-powered robot executes that
sequence of commands but because of the
real-time stream of telemetry it's able
to know well I shouldn't burn out the
rest of my engine so now it drives
backwards it drags the wheels and they
were able to achieve that because they
had full tolerance inside of there
inside of their software system you have
to be able to do multitasking so you
have to be able to to operate and do
multiple things at once so this is a
high-resolution strip of Pluto
so the New Horizons just streetpassed
right past Pluto and it had to be able
to at the same time turn on its camera
start to capture the image but as it
went by turn itself toward Pluto because
it's flying past interpret
Keillor ark if you have a programming
language that that doesn't really
facilitate this or allow you to cope
with the interrupts then you're going to
have a bad time you're you're going to
slam into an object or you're just not
going to get the signs that you wanted
and for some situations you need extreme
minuscule size so this is the Celaya
Lander it was a it was part of the
Rosetta project it was supposed to land
on a comet to do a soft landing and then
send science back it only have 30
minutes of battery life so what it
needed to do was land on the comet
unfurl its solar panels and then start
to do some science unfortunately it
landed in a shadow so it quickly died
but the this lander is really
interesting because it has such insanely
low power capability it runs an eight
megahertz 8-bit processor and the reason
they used the particular processor which
is the r-tx 2010 was because it had the
lowest power profile of anything
available in the market this lander also
had to be programmed in force which is
if you've ever programmed for I highly
recommend it it's a stack-based language
and it's a language that's it's barely a
language but it's designed for density
so it crams itself as much as possible
onto the available systems so they were
able to put an entire scientific package
on a you know a couple watt robot that
would soft land on the comet and send
information back to Rosetta which would
do the beaming back and a language has
to be able to integrate with existing
real-time operating systems so this is
Mars Curiosity it's able to take selfies
because it has a boom and it can point
the camera back at itself you can you
can see the boom sort of cut out
strangely but that's not because we
decided to build a spear robot even
though that's a pretty America thing to
do it's just missing from from the
photos
it runs VxWorks and see I believe it's
fifty thousand lines of C code running
in a real-time operating system and in
the back unfortunately you can't see it
is the really cool nuclear battery so
what languages have actually been used
in space so as I mentioned forth this is
a view of the comet and in that shadow
is the
little Lander that's only powered by
solar power which which is pretty sad
wah-wah
so forth is not commonly used anymore
for large-scale projects but New
Horizons carries forth in some of those
microcontrollers the shuttle flying the
80s and 90s had a lot of experiments
that we're running for space programs
and you'll see it scattered through most
space agencies in in weird places
assembly is very very common
this listing actually is from the Apollo
guidance computer lunar module landing
and I want to point out a comment on the
top that reads temporary I hope hope
hope temporary I hope hope hope permit
x-axis override I want to point out that
that was not temporary um it landed on
the moon
six times go read to the Apollo guidance
computer software it's really funny the
comments are really funny the program to
kick the engine zone to start to do the
landing on the lunar module was referred
to I think it's programmed 66 they just
had numeric names for all the programs
the software engineers actually had fun
names for all the programs that
particular program they referred to as
burn baby bird Hal s was a fascinating
language how I forget what Hal stands
for hi something language and the the -
s there is the shuttle variant so this
is a language that was invented by NASA
for its avionics project but
unfortunately it really only got used in
the shuttle the diagram that you see
below is actually the diagram of the
shuttle computer system and all of the
buses that connect it to all the
avionics hardware the shuttle ran four
computers primary computers and then an
additional one in parallel they did this
complex voting thing over buses
fascinating computer system what is of
note about how is that it baked real
I'm notions into the language itself so
nowadays we have computers languages
that are meant to adapt themselves to
the Machine NASA invented a language
that was meant to adapt the machine to
the language so if you were going to
write how support your computer has a
support hal as well so from the hal
programming manual
Halla how s suggests the point of view
that real-time constraints are an
intrinsic part of the application ie
that timing is part of the algorithm
rather than something to resolve later
as a result real time statements are
integral to the language and allow the
programmer to express the entire
algorithm directly in one place so what
was cool about how if you had a
computation that was supposed to last
for just 10 milliseconds you would put
it in a block that was just a 10
millisecond block and then if it didn't
execute in that 10 milliseconds it would
cause an exception and then fill in and
so on and so on but it would be
concurrently in parallel scheduled with
other blocks and then the the GPC would
figure out how to schedule these things
according to priority and according to
time which I don't know of any other
language that exposes that particular
style of interruptive priority real-time
scheduling other than how s which now
that the shuttle is grounded is a dead
language C++ and C are king
the Hubble is a hundred thousand lines I
think of C code and you send it a little
packet of information C is very very
common in the embedded space and most
space systems are really programmed by
people that just apply what they know so
C shows up a lot a dub at a spark is
also not uncommon especially in the ESA
as I understand it it fills the same
low-level niche as C++ but it has
high-level code it has high level
constructs that has abstract data types
it is distinctly a language from the
1970s but it's a it doesn't have
backward compatible compatibility with C
so it doesn't have some of those same
defects and like I said spark resolved
certain classes memory errors because it
simply does not allow you to allocate
memory
at runtime and it has a similar method
to airline in that you you you define
bound of variables on computations and
then you crash spark extends that
further by turning those into proofs so
you can never violate those bounds but
fascinating language and I highly
recommend that any money's that is
interested in building high reliability
airline systems also go build some stuff
in spark it's part of the good new
compiler collection so it's slow to
compile but you can fiddle with it so
with all of that with Space Systems what
the languages have been used where can
we actually use airline today and the
first one is CubeSat
you know you just put up a hardware
inside of a relatively minuscule fairing
and you can kind of do whatever you want
so the cool thing about airline is it
runs on relatively small computers now
you don't get the nice firm real-time
hard real-time constraints built into
the language but for the most part
they're really interesting papers asking
well how can we apply Linux in space and
Linux is not a real-time operating
system for CubeSat applications and all
the computations needed to be timed in
some way
most of them are soft in one CubeSat
application for sensing lightning
strikes that go up they found that only
1% of all the computations they needed
to do had any type of firm real time
requirement so they just launched a
Linux computer program that python up
and 2 up into orbit the other thing is
this is dear Mongor over to Google
XPrize lunar rover on Mars
anytime you you stick a nuclear battery
and anything airline is appropriate
because you have a lot of power airline
is kind of a power-hungry language
especially the beam you know if you've
ever seen why does beam keep all of my
processor cores spinning it's because
it's optimized for a certain type of
problem now there are things you can do
to fiddle with that but big deployments
I think really where airline would shine
our private space station so Bigelow has
expandable module on the International
Space Station now if you've ever read
about the computer systems inside of the
space station the space station is a
bunch of tin cans linked together by
airlocks each one of those tin cans has
its own individual avionics system for
life-support things like that there's no
one computer system that controls the
entire thing however if you were to
build a space station either Plunket on
the moon or put an expandable one in
space you want a unified programming
model especially if you want field
programming which i think is is where in
the future something like airline could
shine if you if you've seen the Martians
they have a programmer onboard that
spacecraft there was actually talk of
having the Orion field programmable
because it would be a two-year trip so
maybe you would take a programmer along
to fiddle with these things you know
Airlines ability to to do rolling
releases to have these high-level real
time constructs in a relatively
manageable computing environment very
useful for that but airline needs to
change you know what can we do to
actually change airline to to help in
these environments and the first of the
big one are bounded queues you know we
really need the ability to say this
process can only receive a certain
number of messages before it's simply
overwhelmed and I talked a lot with
Pierce trip singer about that which if
you're interested he has a lot of
interesting thoughts this morning you
know and the methods that you would take
for this - to deal with an overwhelmed
or you know crash sender crash receiver
crash both it would change the
computation model of airline to say that
you know a message might not arrive and
I don't actually know what the full
ramifications would be but I do know
that bounds inside of critical real-time
systems are a common need priority
messages so right now
messages inside of Erlangen FIFO I would
like to see that broken so that you
could send a message that would pop to
the top Joe is shivering that also
changes the computation model yes
it changes it's very unpredictable ways
yeah yeah then you have the starvation
problem so then you have to do a
different type of analysis on your
system and and the last thing that I
would like to see your programmable
schedulers so this is a situation where
the processes have tagged themselves
with priority and then the schedulers
are meant to order the processes in
terms of priority so here it's just a
simple greater than and you'll you'll
note that they're they're ordered in
priority in terms of running this is a
common setup in real-time systems the
AGC had at the horizons has it where you
have processes or units of computation
that must run this is Joe saying you
should never do it yeah oh it's saying
it has horrible consequences so it's a
common set up in these types of systems
it's wrong he said so I'm it is very
difficult to programming what one of the
one of my favorite things is when Joe
heckles you from the audience because
you know you're doing pretty well yeah
what a very famous case in the computer
systems that had priority scheduling and
would have killed people without it was
the Apollo 11 landed because of a
software bug they needed to keep
reprioritizing the engine firing but the
displays didn't update they got
preempted none of these changes make
programming airline easier they just
make it they adapt it more for what
people who program these types of
computer systems are familiar with I've
definitely in my work one at bounded
airline queues it's not straightforward
to know exactly what would happen but
when you propose them you get heckled
from the audience which is great
yes No yeah you can but then that
drawing power yeah it's a tricky problem
right right so obviously there's a
further more interesting conversation
back and forth to go after this so I'll
wrap up and then I look forward to it
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>