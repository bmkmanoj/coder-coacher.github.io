<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Justin Cormack - Immutability and State Making an Immutable OS - Code Mesh 2017 | Coder Coacher - Coaching Coders</title><meta content="Justin Cormack - Immutability and State Making an Immutable OS - Code Mesh 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Justin Cormack - Immutability and State Making an Immutable OS - Code Mesh 2017</b></h2><h5 class="post__date">2017-12-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ImPkgl_oTb0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody I'm Justin come back and
I'm going to talk to you about kind of
operating system things you can do with
Linux and and trying to be practical
while also trying to make things better
I'm based in Cambridge I was reminded by
the code mesh Lego this is just up the
road from where I live in Cambridge it's
kind of its kind of iconic Cambridge
things as far as I'm concerned Cambridge
is a is a village that does tech and the
farm land grows telescopes rather than
crops and it's it kind of feels like
that I moved from London and it still
feels kind of it's an interesting it's
an interesting place I work at docker in
Cambridge mainly on open source projects
at docker and I I'm going to tell you a
little bit about kind of how I got here
and why I think this is interesting and
why I think you might find this
interesting
way back in the 90s which I was I was
reminded of having met Sofia Sofia
yesterday III I was Imperial and I I
learned very simultaneously I learned
both Haskell and the Nexus admin has a
sort of simultaneous thing which was it
was a kind of weird combination I
suppose but that's the way I'm Miranda
as well for that matter within a school
and for a long time I've been both a
develop around someone who gets involved
in operations and actually running staff
and they're very different communities
and I kind of you know why can't we have
nice things and operations to why you
know we have nice program languages but
when you actually operate computers is
kind of horrible still over the years
I've watched an industry a lot and
I think I pragmatic about actually
shipping things because shipping things
is fun and people use things and you get
feedback and it's great and I having
that people use something you've built
for doing something really exciting is
great fun but I'm also an idealist at
heart I think we really can do better
with what we ship and there's so this
talk is kind of also about trying to the
combination of the pragmatic and the and
the practical and also trying to keep
the the dream of making things better
alive as you do that I can talk about
project I've been working on for a few
years now actually but it's been open
source for six months back in 2015 when
I started I when I first heard docker
they gave us a little project to work on
which was dock of a Mac which was as a
sort of integrate into the company
project and one of the components we
needed in that was we had to run Linux
in order to build containers and I've
worked on and often embedded Linux
systems for quite a long time and they
were all horrible to work with and I
really didn't like them at all
and if you look at if you look back in
the history of netiquette replay the
first commit has it is there just a list
of kind of useful and guidelines for
what we want to build and one of the
things it said was not required self
update treat this thing as a mutable
just we want to build an appliance and
that's what being the kind of philosophy
and it kind of it kind of came out of
somebody already immutable delivery that
has kind of interested me for a long
time from 2013 this is something that as
a sysadmin
I am always sort of resonated with me
you know once if you get a system that's
been running for a long time you really
have no idea what state what state it's
in what's happened with
things have changed and you really you
don't know what they are if you know
it's never changed you know what you
know what state your system is back in
2011 Netflix started doing immutable
delivery of servers they said you know
we we don't ever change anything in
production we just make a new one which
say always know the state but this kind
of process has not become the normal way
that people run servers still they still
I'm kind of disappointing but it's it's
always something that struck me as
logical and from my experience of
running of you know the maintaining
state over time this was always
something that really was important to
me
another thing that's always been
important for me off of kind of worked
in industry is designed for mass
production when you build things but it
can't be mass-produced and operating you
know computers and systems are now
mass-produced items you design them for
mass production the the ethernet cable
is designed to be made for almost no
money at all it's designed to be easily
customized you know you can make cables
different lengths you can know it
terminate them by hand and things like
that but mostly they're just they're
just mass-produced now you don't even
know the days of terminating your
Ethernet connections by hand a kind of
that's common now but it can be done and
there's that you know they come the
thing is built with tooling there's a
crimping tool every you know every cable
in a data center has its own crimping
tool this is and a set of tools for for
customizing it but it's um you don't you
don't build things that they're new
craft and make them expensive you have
to make things really cheap if they're
going to be mass-produced and and that's
kind of always was in the back of my
mind around this as well and state you
know state things get in a real mess if
you don't control stage
I think you know I think some of the
lessons from functional programming
where that uncontrolled data updates are
a total nightmare and will make your
systems unmaintainable and there is
state but it's controlled state you know
where the state changes you know where
the state lives you know how the control
the state happens and you know can we
apply some of this thinking a little bit
to operating systems I want to go a
little diversion kind of on the way
there though I went to uni Colonels four
men still do on the for many years and
uni Colonels were this great idea about
why do we even need an operating system
you know why are we why are we building
systems based on Linux and other
operating systems this is do we need to
do this at all
a unique kernel basically says an
operating system is gives me a bunch of
services and code that I want to use why
isn't that a library look because that's
how I consume all the other carried I
use and this kind of simple idea of a
library operating system or you know
okay libraries for code is really quite
powerful really cool and it's it's
becoming relatively practical there are
there are rail systems Mirage OS how
they include OS and they're allowing on
Zen are kind of the biggest examples
these are used in production in niche
areas generally they're used in niche
areas partly because all the live system
things system code is not written as
libraries by default you know the learn
a tcp/ip stack is very difficult to use
as a library I mean there are people who
trying to make it work like that but
it's really really hard it's not built
like that it's not maintained like that
it's not designed to be linked in GL
into your program
so mostly everything's been written from
scratch so it's it's slow work building
production grade
libraries for everything an operating
system does the predominant use cases so
far I've been various kinds of network
appliances and and often kind of
stateless things about they the
production use cases are real and if you
can use these things I recommend giving
them the go drying them out there's a
particular overlap between functional
programming languages and you know
kernels which is which is great and but
they tend to run as virtual machines and
they tend to still have a party system
underneath that you deploy them there
are loads of problems in production like
cloud providers don't provide the right
size VMs for the kinds of things you
want to do the Union kernels you want
loads and those are small ones usually
so they're still kind of new and still
trying to persuade people that that's
the way to deploy in production and so
in reality the vast majority people are
deploying on Linux who mostly sometimes
on Windows and other operating systems
but let's let's say in a pragmatic world
what do we need to run on Linux in a
nicer kind of way I work for docket we
do containers containers are great way
of packaging applications and one of the
things you notice when you use
containers is that you don't really need
much inside your containers you
generally the great the nice thing about
them and you can just package your
application you don't need much
operating system you can get rid of it
all you can have a static links
executable inside or a few libraries
maybe some certificates and some secrets
at runtime that kind of thing and it's
it really kind of focuses people's minds
on I want to run my application not how
do I want to run my application on this
operating system so that was kind of
already kind of stage one of
we've got people that we we see people
have learned kind of to package up their
application in a standalone way that
doesn't involve building a whole Linux
server which is a good start and then
all we need underneath that really is
enough Linux to actually run these
containers that people have packaged up
so the kind of iteration process within
escape was finding out what you really
need to actually do a completely
minimalist boot you need an init system
you need to configure all the things
that Linux doesn't configure for you
like devices devices you might need to
format a disk mount it have some program
to run containers we use container D
which is a kind of minimalist container
runtime and that's much smaller than
docker itself it's component of talkin
now and then you run system things like
DHCP in containers it's um you could
just see a system D system D I think is
still too complicated for the minimalist
thing this is really a few hundred lines
of code and it's kind of relatively
straightforward and manageable so the
kind of thing we designed we've created
is a kind of kit it's designed to get
you started
it's not opinionated it's totally
designed to be built in a CI pipeline
it's not you know it's not complicated
I'll show you going to build times are a
couple of minutes most tests like
leadership to production small minimal
fastboot and it's got a very simple
structure some sequential startup to
configure things and then you run a
number of services which are your
application which might be a few
containers is really kind of simple
actually the same designers kind of POD
some cuban essays it's kind of a it's a
it's kind of natural simple design
sequential startup because it's
predictable
and then run everything once
everything's configured we have a Yambol
file for config which I'll show you in
the demo just I'm just going to show you
because so we've got just an example ml
file here we have the basic stuff
certificates DHCP we have long version
members which are hashes of guitry
hashes and this one runs just runs nginx
standard nginx image and it has a few
other config about trust we can just
build this this is titled kind of
defaults to run locally but there's some
there's more complicated options you see
it's assembling our and operating system
nice and quick
it's a bit slow actually when you make
something when you when you can't you
kind of when you reduce something down
from taking a few hours to build to to a
minute then you get annoyed that doesn't
take two seconds
so it's kind of annoyingly slow now
because it's because you it's not long
enough to go to make a cup of coffee
anymore and then we can we can run this
image we've produced in theory that's
never not rather oops
okay and we've booted up the system and
it's running a very minimal systems it
hasn't even got curl and that's we can
there's a there's a console to login
which is obviously entirely optional and
you can see we've got the welcome to
nginx so we created an operating system
it's it's there it's got a you got an
address from DHCP and it's only got
exactly what we can figure it is very
straightforward there's really not very
much in there at all and when we've
finished with it we can shut it down
shut down a message that's also in the
config file and that's kind of how I
feel that's kind of how you should and
again that's kind of how you should kind
of consume Linux I think it's like it's
not it's not a different we're not
making someone change to not using Linux
but it's a new way of consuming it
there's much much simpler it's the root
filesystem usable you can run it from an
ISO or anything
there's no package manager because we're
never going to do any updates it's going
to just correspond exactly to how you
specified its if you want to update it
throw it away build a new one if you
really want dynamic services you can run
docker or something that runs or you can
you can actually run containers
dynamically if you really want but
there's no particular need to and you
really cut down on that all the sort of
complexity of installation and things
like that you just have a script build
it run it it does what you want
appliance model particularly for this
audience always say Oh NIC sauce isn't
that the same different what is it
what's it didn't why didn't he use Nick
sauce it's a question that comes up
quite a lot
they're definitely very different kind
of things Nick sauce is has still got a
package manager it's a you know it's
designed as a better package manager but
it's still designed to be updated in a
very controlled way but it's designed to
be updated we don't even have a package
manager
there's actually no reason we shouldn't
use next to build the containers finesse
kit it's great for building containers
and the other way around there's no as
of this morning I came across this as an
hour
those Cape based container builder for
Nick's so you can use a further Mack so
you can use both absolutely together and
they're they're complementary I think I
kind of summarized it as Nick sauces for
sort of more obedient pets that you know
they're totally controlled whereas kit
is really designed for mass production
of computers where you really don't want
to do this kind of update and maintain
thing so but they're definitely
complementary and different kind of
approaches to things I think learners
kit is designed also to be really
approachable and easy for people who and
we found people can it can try it out
and work out how to use it in in a few
minutes which i think is really great
you don't have to invest a huge amount
in it we kind of do this through a lot
of practicalities there's loads of
tooling built-in so you can build any
kind of image you want ISO is you can go
cloud images directly you can build
phd's and raw disks and Raspberry Pi
images and kind of it so we have a whole
set of tooling around common use cases
for going into production cue cow images
and all sorts of stuff and these are
really quite easy to add and then
there's a simple developer style
workflow with build push run so you can
build these images push them to AWS as
an ami run it you know I was in using
tools we have the
stop kind of things I showed you because
as so you can run it locally on Mac or
Windows or Linux without any issues you
can totally use Linux you know without
having a Linux machine which i think is
really nice because I think that notice
is great for appliances you don't
necessarily want to use it as your
day-to-day system a lot of people don't
you can use it on all sorts of things I
have a V Center and OpenStack and all
sorts of whatever people use people come
along produce produce these things which
is really nice as I said there's a
really simple bill push run kind of
setup designed for normal use so if you
run it on Google Cloud it behaves
exactly the same as the example I showed
you except it'll be running remotely
you've got the console and the log in
and everything exactly the same estate I
talked about state earlier state is
obviously really important the example I
showed you didn't have any state which
is great for some things but lots of
real applications have state so we're
kind of dividing that so the file system
and the image you build is totally
immutable it's like your program or your
function there's you can pass in some
config for secrets and things and then
there's you can add disks for
persistence and you know that every all
persistence date will be on those disks
because nothing else can be modified and
then you can manage these disks as your
data sets you can reattach them to other
machines if they're cloud if they're
network attached disks or for physical
disks and things like that we're looking
at tooling for doing nice snapshot
Hristov all move disks to somewhere else
and kind of maintain your status and is
a thing that you can have control of
so coach config immutable state all
cleanly separated and and managed
separately most of the time the way
people use it they just have a single
volume per state and it's like and so
it's it's really sort of you can imagine
it's a so everything that you want to
persist goes on this external chunk of
data the volume ideally it's like it's
you know it's just you yeah the data
from your one application because the
system itself doesn't need any state so
your application writes its database to
that volume and you know that if you
snapshot that volume that's your
application stage and then you can
unsnap it somewhere else back it up
restore it or whatever and all there is
on that is your application state it's
not the system today because the system
is designed to be totally stateless and
just dynamically configure things other
than any kind of conflict like secrets
access keys and things are there which
you obviously need to pass in separately
and you kind of get sis to sort of
systems as functions you know in a I
mean III definitely like to look at them
like that because it's it it's my kind
of mental model that a stateless machine
is a simple function with no with no
arguments and everything else you should
be designing as with this kind of model
of I have one application it has a chunk
of storage that its input stage if you
re execute that machine from the same
stage it should behave in the same way
if you take that state and put it
somewhere else and boot the same
function are you the same machine image
it should behave the same way and you
can kind of you have this kind of model
of where a mental model are from if
you're if the European system as in this
nice clean well structured kind of way
and and I think that's that's definitely
a much simpler and I
the way of modeling stuff it's it's it's
definitely an improvement on on how you
know your standard than a system where
there's mutable state absolutely
everywhere there are programs that
mutate this musical state that you don't
really know about lots of people like to
you know trace their programs to try and
find out what's modifying what you know
there's files and etc those files in bar
those files in anywhere in home that get
modified and you don't really understand
you haven't got a simple state model for
your machine at all and then things get
and you then there's an update process
that's randomly updating your code or
the organ system you don't you've got no
real model of what of the state the code
and clean separation between the two so
it's kind of I kind of feel that it's
kind of there to make Cather's fun again
make it a kind of usable thing make it
something that you can play with explore
you could it's reproducible you can
build things fast even if it's still you
know it should should be seconds not
minutes but not a minute but they're you
know we're getting there I think that
some of the things that kind of I've
tried to kind of do what I've been
working on this project and try to think
about and tried to do this compromise
between pragmatism and where where we
want to get to eventually try and remove
layers from software and systems you're
using don't try and build everything on
top of each other you know I think that
system software for doing updates and
things built on top of things like
package management that was designed for
humans and then you built automated
tools like puppet and things that run on
top of tools that will go for humans
rather than saying hey we're building
this for computers not for humans or you
know
it's not we're not trying to model use
the computer to model the human
operators way of updating a computer
let's throw away that layer they start
again let's make something that's an
order of mine choose simpler and that's
so kind of my sort of feeling that
design for manufacturing you need to if
things going to be cheap and easy you
should throw away the layers don't build
on top of them and I think this is a
really important model for all sorts of
systems that there's there's loads of
stuff we do need to throw away that
right and there's a real tendency to
build layers and layers and layers and
make things more complicated and there's
times when sometimes you just have to
say no it's time that stuff needs go
let's do something you know Minimum
Viable Product style throw it all the
way and see what happens most computers
that have systems that run never have an
actual user ever login because most of
them are just automated and they're
doing something every now and again
people you know I would reckon that
we're probably down to well under sub
one percent of computer imaging
operating system boots ever have anyone
long a human login most of them you know
CGI systems and all sorts of things that
no one ever logs into or appliances we I
mean the the CI system for learns kit
has builds hundreds of machines every
time we do a commit and no one's ever
that they don't have they don't have a
login shells we don't you don't login is
optional in this case thinking about
things as appliance is is kind of I
spent a long time building appliances
and to do things and it's a good way of
modeling what you want to do because
appliances are things that just work
they have a function they do it they
sometimes they go wrong but you know if
we can diagnose how your plan says go
wrong or you buy new plans and you know
our plan sees are getting increasingly
disposable and and so it's a I find it
great model for building any kind of
system is making the appliance rather
than a things that someone will
endlessly tweak and try and keep working
and you know the whole kind of I you
know having been a sysadmin I used to
log into all their systems and try and
keep them working and it was a nightmare
and frustrating things as appliances is
it's just much simpler being able to try
things out and just really easily when
you build when you build a new system
having it so that someone can try it out
in five minutes
you know just get started try it out see
how it fits with what they want to do is
really important sort of building
community we've had a lot of interest in
contributors we've had over I think
we're getting up to ninety contributors
for those kids in the six months since
we've launched it and I laid more people
who have not contributed because it just
seems to do what they want already which
is great but having that kind of easy
easy steps for trying out a new project
are really important it shouldn't
require people do a sort of great leap
and dedication to it when they don't
really know it's any use so I making
sure that when you when you launch
something that you've spent time
thinking about how am I going to get
people to try it out is really important
and making things kind of simple and
helps with that or just generally
removing all the barriers to trying
things out don't make people fully
commit to it just let them incrementally
adopt it as part of their workflow maybe
for some some little use case and then
they'll think oh this is nice I like it
I'll use it for something else and then
that kind of grows takes time but it's I
think it's really important when you're
trying to actually get people do use
your codes rather than just
experimenting and I which is I really
like we haven't lost the war against
complexity but it's a war that we all
have to you know fight in I think
complexity is everywhere in software and
I I really hate it and
there are simple things hiding under all
the things that we use and I I think
it's really important to not give up in
this kind of you know there are things
that are that really that need to be
complex because they are complex but
there are loads of things are complex
for bad reasons just for because they've
been led on top of each other over the
years and no one is kind of pruning the
mouth and built a simpler version and if
you need to use Linux and if you're not
using you know you know user unit
kernels please but if you if you have to
use Linux try consuming it differently
and that's going to kind of they get a
pre page there it's all it's all pretty
easy to use try it out and thanks very
much hi there this looks very
interesting indeed I've got a stack of
Intel compute stick saan my desk which
aren't doing much is that a piece of
hardware that you currently support it's
kind of a black rectangular thing about
this big it's like we came out about
three or four years ago for now and so
I've been newer versions we've got the
first generation yeah I think it was
yeah yeah we actually don't have any 30
bits because yeah we've we only went for
64 bit because we kind of I think at
some point we'll probably get some 32
bits to check goodness it's not
difficult to add but um we basically
have support the name for x86 64 and arm
64 and we kind of prioritize the kind of
server platforms because that's mighty
over the years but now we got to support
two architectures adding more is really
easy okay cool thanks very much
thanks for that that was very
interesting I'm intrigued by what you
said about problem with tooling like
puppet being built as a layer of
software above what's meant for humans
use I suspect the reason it's built that
way is so that that means that any
software that's built for me to use as a
human I can also automate so I'm curious
what William what you would imagine
would be a good alternative to that that
wouldn't limit me to only Sophie that
was built for a manifest for for you're
talking about and yeah I mean I think
that there are kind of there are kind of
halfway stages I mean I think that for
example the shell was designed for
humans but we also introduced shell
scripts and you know loads of automation
and programming based on shell scripts
and but the functionalities of the you
know the kind of the the POSIX shell for
scripting computers versus the human
shell for human to interact with the
computers have have diverged because the
human shell emphasizes things like
autocomplete and this kind of scripting
shell often strips those things out
nowadays and there's a that there's a
useful I can take my ideas from one to
the other but the way they used as has
gradually diverged and some tools are
definitely more you know some tools in
sort of command line are definitely more
aimed at the human I mean top is not a
scripting camera hands and and and you
know so the shell has taken on this sort
of rich interactive model and but it
kind of forked at some point from from
the the kind of program language and
then then we got Perl there's a better
bash you know kind of way and and and
it's kind of at a whole set of how we
need scripting programming languages and
there's those two paths kind of
kind of diverged over time and we sort
of went when it's kind of different kind
of use cases and I think there's a I
think there's probably a lot of other
things like that
I mean puppet are working on loads of
ways to use the puppet tooling for doing
things that are not installing packages
now so managing the state of multiple
servers and and and you know they're
turning it into a more general desired
state convergence tool and desired state
convergence is a really important idea
in maintaining systems and so so I think
that I think you know there's I think
there really are these different paths
that we can take and we don't have to
throw everything away just because we
changed our mind about how we want to do
things
you know else
okay all right let's thank the speaker</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>