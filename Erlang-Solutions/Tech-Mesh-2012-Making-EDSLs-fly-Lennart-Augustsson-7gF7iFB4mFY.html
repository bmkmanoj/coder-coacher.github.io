<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tech Mesh 2012 - Making EDSLs fly - Lennart Augustsson | Coder Coacher - Coaching Coders</title><meta content="Tech Mesh 2012 - Making EDSLs fly - Lennart Augustsson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tech Mesh 2012 - Making EDSLs fly - Lennart Augustsson</b></h2><h5 class="post__date">2013-08-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/7gF7iFB4mFY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so before I start my talk just love
sentences about me so I walk to the bank
now but I used to be an academic work
they give keynote yesterday morning you
might have seen in picture where I had a
face sticking out I'm somewhere I'm more
hair so contrary to what Simon's that I
was not on the original high school
committee there were two of us from the
same university when they have to admit
it was for me and Tomas eurozone and we
flipped a coin on who was going to be on
the committee and he lost so I i was on
a decrement electron so i made the the
first publicly available Haskell two
pilots I've been around with ethical for
a while yeah clarify letter can't
explain is clear but what happened was
that a Glasgow we would work on the
Glasgow Haskell compiler it slide been
taking guns and will parte when sit down
me we're very hard for months and months
and months and they do release at the
glasgow pascal compiler make two days
let it would do his new release of the
his Haskell compiler and it would be
much faster than ours then the same
cycle to get arranged but I did manage
to release the first release before last
well because I stole the name but they
wanted
the different virus called hpc which are
hostile be Curry's initials anyway so my
plan for today is to show you a simple
embedded domain-specific language and
i'm going to show you two embeddings so
there's something more shallow and
letting and deep embedding we'll come
back to that little and then I'm going
to show you how you can generate actual
machine code for your adsl so it also
ready said that EDS else are something
that has was very good at and I'm not
really sure when something is in a DSL
or not I mean it's just a library I
guess it depends on what sort of the
target audience for the library as if it
were meant for some kind of domain
experts who's going to use it you things
in their domain or not so I'm going to
leave that up what immediatel actually
is so I work in a bank banks are very
secretive and you have to get permission
to say things so to avoid getting
permission to say anything about what I
worked on I'm going to talk about what
other people work on them don't work it
our bank about something that they've
done at barclay capital instead because
they published a paper about it so I
couldn't possibly be revealing any
secrets about what we're doing so they
have a DSL I don't actually know the
name of their dsl is there any bark at
people here okay so it's it's a dsl for
describing exotic trade stood up to to
value a trade and this slide pretty much
captures the essence of that adsl so you
have couple of specialized types like
dates
and assets i'll come back to assets in a
moment you can do things you can add and
subtract numbers and so on i'm calling
these numbers ewww stay usual haskell
type for four numbers thees EES you
should think embedded so these are the
doubles in my little language by the way
I'm going to assume you recognize
Haskell syntax how many people here
recognize her well understand the house
goes well so if you don't understand
something just ask me but I'm not going
to explain Haskell syntax unless it's
something really obscure so we have some
operations for arithmetic max and min
some logs and doubles and so and we can
compare these things there's a
conditional constructs we can do some
things on lists and so the the thing
here that really makes this different
from just arithmetic is this observed
functions it takes an asset and a date
and gives you back a double and so
assets are things like some stock for
instance and you can observe what the
value of the stock was in a particular
date so given an asset like apple stock
and a date you can see what the value of
it was on that date so depending on what
you're doing these are not necessarily
dates in the past you could be doing
some kind of modeling and these could be
dates in the future where you have some
models trying to predict what's going to
happen so here is the example I'm going
to use in my talk it's called best of it
has a list of assets and two dates and
it's going to tell you how much the best
performing asset has increased in that
built between those two dates so what
you do is that you you have your assets
you map this function that computes a
number call the performance or how much
has it increased we get that by
observing the asset at the later date
dividing by the observation of the asset
on the first date
subtract one this is sort of the
relative increase of that and then you
have all these numbers and you compute
the max this is a very simple function
but it's a realistic function it's
actually one of the examples from the
papers at barcap that I mentioned just
to show you something else that I'm not
going to talk about here is something
called that computes a click a I think
it's called I don't really know what
these things are just work at the bank
guarantees know so first a shallow
embedding so a shallow embedding means
that all these functions that we have
we're going to implement them in Haskell
and they're going to do what I sort of
said they do so the plus function will
add numbers and so on and so this this
way we're going to contrast this with a
deep embedding later so they in the
advantages of the the shallow embedding
is that it's pretty easy to write it's
reasonably efficient when you want to
run things but it's not as flexible as
the deep embedding I'll get back to what
the difference is when we get to the
deep one first some words about what the
date and asset types are we have to pick
something I mean we're going to
implement this now so I'm going to pick
these specific implementations for days
the dates are just unsigned numbers 32
bit unsigned numbers i picked could
represent the number of days since
nineteen nineteen hundred if you are if
your windows or you could have something
second since 1970 if you're unique so
you could have nano seconds since the
opening of this myth Sounion institute
if your VMS but doesn't really matter
except you'd have more bits if you need
the nanoseconds phones also be a mess is
dead
assets I'm going to pick something
really simple as an asset will just be a
list of date double pair so at the
particular date it had a particular
value and this is definitely not how you
would want to represent that if you were
doing this for real you would have
something but you could quickly look up
the value of a particular day but I'm
going to make this simple so it can fit
it on my slides so here is the the
implementation of the shallow embedding
so the type II double is just regular
Haskell doubles and the Bolians are just
regular Haskell boolean and the list
type I had a regular Haskell list and
plus and minus and so on well they're
just a regular high school plus and
minus so really only two functions that
were not the standard arithmetic
functions that it's observe and cons the
cons the conditional and it's just
implement by if then else then we have
the observed that takes an asset and a
date and what it needs to look up this
observation so you have a list here
update double pairs and need to look it
up so I'm using just the Haskell list
lookup function and I'm saying if it's
not in there I'll say it has a value 0
that's really stupid but it made that
line short enough to fit on the slide
yeah that's it that was pretty boring I
mean that's all we need to implement now
we have this we can take one of these
things like the best dog function give
it a few assets give it a couple of
dates and we'll get the number back
because there was only really observe in
there that was anything that we needed
to implement and that was just a look up
so let's move on so if you have a deep
embedding of Annie dsl you don't write
functions that actually do what you're
supposed to do all these plus and minus
and observe and so on they will build a
representation sort of some kind of
syntax tree that describes what you're
going to do
so the advantage is that it's very
flexible you can do a lot of things with
this syntax tree and it can be very
efficient it's much more work to
implement it this way and we can also be
much less efficient well I'll actually
have some numbers at the slides at the
end what I mean by more flexible well if
you have a function so in this shallow
embedding the best of function was
really just a function it took a list of
assets and two dates the only thing you
can do with the function you can give it
the arguments and you'll get the number
back now we have built as a
representation of it so there are lots
of things we can do we can run it of
course we have to write some kind of
interpreter that runs it or we can
pretty print it in some sort of
mathematical notation or something like
that we can analyze it we can see like
what assets are actually used inside
this and so on so there are lots of more
things we can do once we have it in this
form and we can compile it to machine
code which is will i will do at the end
here so how do we do the deep embedding
in haskell well first we have to have
some representation for the things in
our dsl so there were a bunch of things
you could this is just a haskell data
type that says well I'll have some the
types for or constructors for adding
subtracting blah blah blah these are
exactly the functions I had they will
all have a constructor then we need some
kind of constants I mean there are
doubles there are billions their assets
their dates that can also be in the code
so we need some constructors for those
so this is untyped well there is the
expert type does not carry in any
information about what type it is so all
of these are the same so for instance i
mean this expert has to be a double and
that has to be a double otherwise the
subtraction doesn't make sense and in
the conditional here this needs to be a
boolean and so on but that's that's all
gone here there are ways to make this
representation type safe but I'm going
to ignore that I'm going to use this i'm
going to put another layer on top of
this to make it type safe so this type
expert will never be exposed to the
users so sort of the the people are
actually using the dsl they won't see
this this is under the hood so what they
will see is a type called e for embedded
if you will which is so II the type II
it has it it's parametrized over some
type so this is called a phantom type
variable because it doesn't actually
occur on the right so this the e that
type here just sort of tags things to
say well the expert you have is actually
a double or a ball or whatever it is but
it's just an expert underneath but it's
been tagged with what type it has so
plus and minus and so on it will now
have types ewwe TT e double and less
than would be e double e double to no
bull it's a typo here there's always a
typo and so on and if you want to have
the types we had before we can just make
some abbreviations so we want to use the
standard Haskell syntax for things so we
want to write class even when we're
doing the the plus for the in our
embedded language so we can make it a
new instance so we say e doubles our
numbers two and if you have something is
in the num class in Haskell which means
you can use plus minus and so on there
are these six methods that you have to
implement plus minus times abs from
integer and signum so if I write plus
it's going to be been up add
and you can see what bin up is oh yes so
it takes something that operates on
experts that is the ad it takes to be
things and gives you an e thing back so
all it does is just sort of strip off
the e thing from the first operand strip
off the e thing from the second operand
do something with it to experts and put
the new Aeon it and I given it the most
flexible type there there is here so
these are not again not things that will
be exposed to the end user they will
just see these things they can write
plus minus and so on and that will
construct the syntax tree underneath
here are just some more to be able to
use slash for division and to be able to
write numeric literals and
floating-point format an expert log so
this is sort of if you have some
embedded language that uses number this
is sort of the standard way of doing it
in Haskell the observed function it just
builds an absurd node in your syntax
tree less than build the less node
conditional builds a conditional node
all kind of boring so something will
want to do is to move between real
values and eval use we need that because
at some point we're going to interface
our dsl code with real things sameen
will have two dates that we want to use
in our best of function and those will
be real dates and not these embedded
dates not the e dates so we will want to
be able to lift values say dates into e
dates and we want to be able to go the
other way around if we have an e date we
want to be able to get the real date
back out again so lifting it well if
it's a double we just say tag it with
double and so on they will just tag here
so there's a new class here set called
value so these are the
acceptable values in our EDS L so this
exactly controls what things can go in
and out of e there only doubles dates
bullion's and assets that can go in and
out and so conversion the other way that
could possibly go wrong because it might
not be a double here I'm just left out
the cases where it goes wrong because
well the way the rest of the code will
be structured it will never go wrong or
at least I claim it will never go wrong
so to just to illustrate if we were to
fire up GHC I the interactive system so
we could write something like 1 + 2 but
we say the type is edible so that means
that the plus operator resolves to our
special + operator numeric literals will
resolve using the from integer method so
we can just write 1 + 2 and it will
actually turn into this so that is the
syntax tree we built but we use normal
haskell syntax it's just the type that
decides what the overloading will do and
here's some other example if you use con
one less than 2 blah blah blah we'll get
this syntax tree and of course this is
all typed so if we try to do something
wrong like one plus one less than two
will get the type error saying couldn't
match expect the type double with actual
type bool and it babbles on a little bit
because this is a double this is a bool
so I think being able to make a typed ed
SL it's great I mean I'm all for types
so I want if I make an e dsl I want to
make it typed as well so the cool thing
if you want to make typed EDS Ellis in
Haskell is that the type system is
extremely flexible you can really
program the type system to make a type
system that behaves like you want to in
n
you're in your adsl you don't you don't
have to sort of have arbitrary
infelicities you can really program the
type system it can be quite complicated
the program that type system but it can
be done what can really suffer is error
messages because error messages are
often in terms of your implementation
rather than what the user wrote so the
here this error message turned out to be
quite nice but they're not always that
nice so there are advantages and
disadvantages to having embedded dsl's I
learned a new word neuritic it's
apparently the part of the ocean that is
between the shallow and the deep so
there was one type I didn't mention the
list type so there's no doubt what it
should be if we have the deep embedding
so the list type should be an e
something and I mean using the Haskell
list type to sort of be the tag for
those lists that seems reasonable if it
weird shallow embedding it would be this
Celeste's would be real Haskell list so
this would build a representation this
would be regular lease but there's
nothing that says that when we make an
adsl that we have to pick the same thing
everywhere just because we're deep in
some things don't mean that we have to
be deep in everything so in my
particular example I'm going to in the
best stop function I'm going to have the
first argument which was a list of
assets and then there were two dates so
I'm going to be shallow in the embedding
of the list and deep in the embedding of
the dates so that's why it's sort of
between the shallow and the deep so
exactly what how you going to do this it
depends on your domains i did it for
simplicity for this particular example
so I'm going to mention what what sort
of what the differences are so once you
have an e dsl like this there are sort
of two times when the code runs in some
sense so you write something 1 plus 2
that turns into this syntax tree the
syntax tree does nothing we later on
have to do something to the syntax tree
write an interpreter for it or code
generate or whatever but first sort of
the Haskell code runs that does some
processing and then later our
interpreter or whatever it is runs and
that's some further processing there are
really two stages when things run and
I'll call them compile time and runtime
which is not really the compile time and
runtime of the Haskell code but of our
adsl so this is the type i'm going to
pick for my example and this is the
alternative so here the ass list of
assets would be something that exists at
runtime here the list is a real Haskell
list it doesn't exist at at runtime it
only exists when the Haskell code
operates so this is fine if your lists
here are always of some fixed length
that you know why you can sort of look
at your coding you see well i'm always
passing in three element list or
whatever or you know it at the first
stage of your processing then this works
fine if you need to have a dynamic size
of your of your asset list then you need
to pick this one where you may be
constructing their list of assets as you
the code is running then you have no
choice then you need this one if it's
fixed you have a choice you can use this
one or that one so I picked this one
if if I had picked the deep embedding
then I need more functions here I didn't
mention the things for list but I need
some way to represent fold and map those
were two more functions that were
available I need some way to have list
values in there as well and even here I
have made a choice that this thing the
function in the fold and the function in
the map they could also be experts
depending I've we're embedding functions
deeply or shallowly so I'm going to
leave this out because I'm not going to
use this I'm going to use the shallow
thing for the first argument okay so now
we need to take an expert and compute
the value of orbit this there's a lot of
stuff on this slide but it's all pretty
boring if you've ever written an
interpreter it looks something like this
if we want to evaluate addition of two
things well then we evaluate the two
things they better come out as double
and double and then we add the actual
doubles and we tag it again to be a
double and so on if it's a conditional
we evaluate the conditional depending on
the boolean we will pick the first one
or the second one and so on and
observations we use our lookup
obstruction and all other cases they
were the constants a double I bool and
so on so this could clearly go wrong I
mean if these are not two doubles here
there are lots of error cases with this
one is a bool and that one is a date or
something like that but again I claim
that I will never use it in the wrong
way because what's exposed to the user
is not the expert they are only can only
use the e thing they can only build
things with plus and observe and so on
and they all construct things that are
type correct
so the thing that you can actually use
at the top level to compute things is
this eval e function which takes and be
something into an a you can only do this
if it's something that is a value that
you can represent in your dsl so though
a here has to be double bull date or
asset those who are the four things that
I made instances of value and you do it
by well you pick off the e-tag do the
extra valuation than you downcast it or
whatever you want to call it alright so
this is an evaluator for the deep deeply
embedded language so now well a little
test here a couple of dates a couple of
assets and best of it takes a list of
assets or rather takes a list of key
assets so we need to take our assets and
lift them into e assets and it takes to
heed eight so we need to take the two
dates and lift them and then we can
evaluate that and we'll get to double
out and if we run this particular thing
we get this to be point five I guess
don't ask me what it means so now we get
into the actual interesting bit we're
going to generate machine code for this
because this interpreter is kind of slow
which I will show you later on so what
is the llvm its stands for low-level
virtual machine so it's like assembly
code but not for a real machine its
assembly code for a virtual machine but
the virtual machine is not like the
Erlang virtual machine the Java Virtual
Machine or anything like that it's a
very low level one it really looks like
assembly code for a real processor it's
just some kind of idealized processor so
it started out as a university project
and now it's mainly sponsored by apple
which apple are using this for a lot of
stuff that actually runs on the mac so
if you have a back chances are that the
llvm is involved somewhere when you're
running graphics for instance so what so
the llvm is a big C++ library and what
can you do with it well you can somehow
pre generate some some llvm code and
then you can do either a batch or a
just-in-time compilers if you do use the
batch compiler take the llvm code it
will translate it into assembly code for
well are lots of processes like x86 and
arms as part and so on or if you use the
just-in-time compiler you give it some
llvm code and it will generate machine
code in memory for you and you'll get a
pointer to that function and then you
can just call that function and you can
use this it from many languages so there
it's a c++ library but you can use it
from C++ from see from Haskell from o
camel and there should be a dot dot dot
here because there are other languages
that have bindings to this as well so
I'm of course going to use the Haskell
bindings so yes as I said to use the
just-in-time compiler you build an
instruction sequence you call the JIT
you get to point it to the code its uses
to see calling conventions you just call
this code like you would call any other
C code unless you I mean you can have
other calling conventions but normally
you do that so there's also em the
Glasgow Haskell compiler has a back-end
that uses the llvm it's completely
unrelated to what I'm talking about but
it's there it's another way to generate
code instead of using the gh sees native
code generators you can generate
llvm call them from there go to whatever
machine you're running on so this slide
has a lot of stuff I only want you to
look at the black stuff not the gray
stuff so here is a function two
arguments they are doubles say x and y
and it's going to compute X plus X times
y so what you have to write in Haskell
to to generate machine code for this or
rather sort of the llvm code for this
comes from these three lines so if
you've ever written assembly code you
can sort of see how this works so well
so the arguments will be called x and y
so you add X to X we call that X 2 and
you multiply x 2 x y stick that in some
temporary register and then we return
this temporary so depending on what
machine you're on this will turn into a
few machine instructions and add a
multiplier some kind of return and a few
things in the beginning here to set up
your activation record and so on the
rest of the stuff here is just to show
you a complete example so this is an
example you could run you could take
this stick it into a file and just
compile it if you've installed the llvm
libraries for haskell you can run this
this will take this function after a few
little things here to actually compile
the function you can call this function
with the arguments two and three in it
will print 2+2 4 times 3 12 so that's
what I'm going to use so so the basic
idea now is to to get an efficient ed SL
is that instead of having an interpreter
we will translate our ed SL because we
have the syntax tree we will translate
it into some other language and that
other language is the thing that we're
going to actually run
so when we actually run it there is no
Haskell involved whatsoever we're going
to run it in whatever this other
language is so if you were at the
keynote yesterday morning you saw John
mentioned translating to see which is
another example of this you have an e
dsl when you run that code it doesn't
run the code it generates a sea program
and then you have to compile the sea
program and run that that's what you
actually run this is very similar when
you run the Haskell code it will
generate some llvm code then you will
run the jitter on that you get some
machine code and then you run that so we
do it all in the same process they're
not multiple stages but it's sort of
when it actually runs there is no
Haskell a involved there's only the
machine code generated by the llvm so as
I said before this is an example of a
two-level language which is it's kind of
like macros in many languages or C++
templates you have to think sort of we
on two levels are some things that
happen early on when you have some of
the information and there is some other
thing that happen later on when you're
actually running it and you have all the
bits around and you can use this for to
sort of control when things have how
efficiently you do think so for instance
if you have you have no yet you have a
loop from one to ten say of something
you can then choose to either generate
the loop you can run it at runtime or
you can duplicate your whatever you're
going to do in the loop you can
duplicate that ten times and have it so
the actual looping happens at the first
stage and then the second stage will
just run straight line code so this is
the kind same kind of decisions you have
to make if you're writing a compiler are
going to I've do things in the compiler
are going to do it at runtime but here
you have you have control over hood
because you're writing your own compiler
all right
so I'm going to translate type correct
experts that we have into llvm machine
code and translation will proceed by
type there will be a few different
functions gin double taken takes an
expert and will generate llvm code that
returns a double so this gem type hides
a lots of stuff that would have involved
in and actually the actual type of the
llvm code generator and so on so the the
llvm bindings that I showed you a little
example of before that's another ed SL
it's the ed SL for generating llvm code
and l nvm has a very complicated type
system but it's all programmed into the
the ed SL that you have available there
so it will do the kind of checks that
are necessary for the the llvm code to
be type correct and that will if you
make it an error in your llvm code so
the llvm code would it make type sense
it will show up as a haskell type error
when you try to compile it anyway so
here is the function that generates the
doubles so we have to handle all the
cases where a double can occur or
throughput you can generate the double
so well there are the arithmetic
conditionals the observed function and
you can have double constants or I
forgot expand log but it doesn't matter
so i'm going to show you the arithmetic
once here in a moment and also
conditionals observations the assets I
haven't told you really about how we're
going to represent assets in in when we
generate machine code here so it's just
a bunch of question marks and I'll get
back to that constants are easy we're
just return the constant there is some
value of thing here that lifts things
real values into llvm value
so Jen off double double it takes an
opcode this is an llvm opcode and it
takes two things to generate code for so
let's look at that so it takes an LLB an
opcode which happens to have this type
you know maybe it can do it an arbitrary
thing here but these two experts have
the e1 e2 they have to be double things
so I recursively call a double to
generate the code for the first
generating in the first argument
generate code for the second argument
and then this up just your opcode
applied to two argument if we will go
back here now this was the opcode
floating add floating subtract floating
multiply floating divide so this is
going to be one of those four so this is
where it actually happens this is the
thing that generates the llvm
instruction yeah the type is scarier
than the function so you don't have to
write the type I mean Haskell we infer
it for you I like to write them out
conditionals you don't really have to
read everything here conditionals are a
little bit complicated in llvm because
it uses something called static single
assignment so it means that you have
each we have a conditional you have to
choose if you're going to do this thing
or that things you're going to need new
basic blocks and you're going to sort of
depending on your condition going to go
to the one or the other and then when
the basic blocks meet again you have to
do something we had to make the things
from the two basic blocks end up in the
right place so the the interesting bits
is this this is the conditional branch
instruction that
generates the once jumps to one or the
other here is the branch that ends the
the the then part here's the branch that
ends the else part and here is the thing
where you join things back up again you
have to have a Phi instruction which
doesn't turn into any real instructions
if you had a ver down s si you know what
if I instruction is if you haven't you
can ignore this well until you try to do
this yourself boolean comparing you use
floating compared with a floating-point
ordered less than that's the opcode and
then that's the only seeing here date
there is it much to date there are no
where is my take on dates or anything
you can just have conditionals and date
constants and dates were just words 30
tues are just past those around yes what
about assets so we have this type it's a
list of dates and doubles so I'm going
to let it run time we need to take a
date and we need to find the
corresponding value for it so this is
what we must generate machine code that
looks up the value in that list but I do
have the list the list is right here so
I know how many elements there are so I
could generate the loop that looks
through some data structure but I'm
instead going to generate straight line
code this is a really bad idea if this
list has thousands of elements but for
my example where it has two elements
that works quite well so i'm going to
Jen change my gem acid function a little
bit all the others they took an expert
and returned a gin asset here so I'm
going to change it a little bit it's
going to take an expert which will be
the asset thing the date that
want to look up and it's going to return
the lookup value so it's an asset okay
and we have the date that we're going to
look up here is the function that will
generate the straight line code that
will do the lookup so if we get to the
end of the list and haven't found it I'm
going to say ok it's going to be zero
that's what i did in the interpreter as
well if we have some date well we have
to see if it's equal to that date so we
need a conditional when you do a compare
there's a missing bracket here we do a
compare equal to the date if that's the
thing no no this is all right as to
compare equals take the opcode how to
compare this one thing the D the value
that and here is the the constant that
we're comparing against so if the
comparison comes out equal we're going
to return this value otherwise we
recurse and generate code for the rest
of the list so this will generate a
bunch of compares return there the right
value another compare and so on yep and
am returns this thing yes yes it is
yeah and indeed in my previous version
of this talk that I gave at skills
matter I actually represented assets as
functions from date to double but that
has other complications yeah so we
modify the observed function a little
bit for engine double so we generate
code to produce the date then we pass
that date into the gen acid function
that will then generate the actual
double so we're almost there now we can
we can generate code for an expert that
is sort of it of type double or bool or
whatever but what we really have is this
function this is the thing we want to
generate code for with a list of assets
and a date than a date and then we have
this e double you don't really know how
to generate code for functions yet so
this first argument is static so that's
going to be handled sort of it will be
unfolded so it's only these that are
interesting so this is the thing that we
need to generate code for so we need a
function that takes one of these and it
will generate the machine code function
that we want so if you do embedded
languages and you deal with functions
you need to have something that sort of
have functions around if there is a
standard trick you need to augment your
expert type with some kind of variables
and then you when you generate code or
whatever you do you need to have an
environment around where you can look up
variables so I'm not going to go into
the details you can sort of look at
these slides later on if you want to see
so everything will change a little bit
will need an environment here and when
we get two variables will look them up
in the environment and then this is the
actual function that takes an e de tunis
date into an e dubble we do it by
inventing a couple of bear
names in doing an environment generating
function for the double or the code for
the double and then returning that so
this will be the function that takes to
e dates generate codes for the final
return value and returns it and this is
just the top level thing that will test
it so i have a have to have a little
benchmark if i'm claiming that this I've
done this for efficiency so it caused
this best of function 10 million times
have a list of three assets okay do
these so if we do the shallow embedding
it took 3.7 seconds to run so the deep
embedding with the interpreter so the
thing I show you first that took about
15 seconds it's about five times slower
to do an interpreter on the shallow
embedding than it is to do I sorry and
interpret on the deep embedding than it
is to run the shallow embedded directly
and then the llvm version that is when
we generate the machine code to evaluate
this is takes about point three seconds
so it's about ten times faster then sort
of the original Haskell one yeah is it
much to say so on this one I actually
have the top level loop to think that
iterates 10 million times that bit is
actually written in C to avoid the
overhead of sort of 10 million looping
10 million times in Haskell I'd I wasn't
didn't trust Haskell to generate good
enough code to loop 10 million times I
guess I could have figured out how long
that took what so I think these are
typical numbers order of magnitude from
interpreter to Haskell running it and
then here you regenerate machine code so
i must say this is a bit unfair because
here I'm sort of generating straight
line code for the look up in my asset
where's hospital has to deal with the
list that it has go down the list so
hospital in some sense does more work
than this one does but that's exactly
the trade-offs you can make when you're
compiling your your embedded language
you get to decide if it happens at sort
of compile time or runtime so so yes
this version does less work but it does
less work because it can get away with
doing less work well the conclusions are
I think Haskell is very good for doing
type T dsl's shallow bedding easy deep
embedding difficult but more efficient
if you generate machine code all right
thank you very much Larry any questions
well so for instance in the example John
showed he generated C code because
they're targeting some weird signal
processor that probably llvm doesn't
have a code generator for but there is a
see compiler for it so yeah not not yeah
so it's producing llvm code is not that
difficult you can produce quite crappy
llvm code and the Alabama optimizer will
do a good job on it
yeah i mean if if you're if you're happy
with writing your compiler in Haskell
mean this took an expert and generated
the machine code so if you're if you go
for you making your own compiler for
your dsl you do your posture you do or
type checking you produce an expert then
you just reuse the rest of the stuff
yeah so you could probably improve that
one quite a bit with much less effort
than it is to sort of write the llvm
code generator I mean it depends a lot
on what your language is so in the
particular example I had hair there's
not not really that much you can do in
the shallow embedding because it used
regular Haskell + 4 + and so on I mean
you can you can have different choice of
data structure for your asset that's
about the only thing you can do for this
particular example but this is not
really realistic I mean in a real
language there are many more things so
there will be more places where you
could improve things but I wouldn't say
that you should go sort of the llvm
route immediately do do it the easy way
first and if that's not good enough then
tweak that and then if all else fails
one question is it seems I go no you end
up building like a certain set of tools
when you do this and because I mean
there's the whole details about it elvia
but there's the details of the hasturs
intact right you're actually kind of
want to use as much an asshole syntax as
possible and it seems like that you
really build this out there's a lot of
duplication right and like is something
is the thing that you built I mean it's
somebody else can take it reuse which is
this great high level haskell system for
very long so I think you can redo this
to be much more usable so the the
defense part after John mentioned that
generates C code that is built on top of
a framework which is sort of very
extensible when what kind of
constructors you have and so on so if
you started from that instead and
generate llvm code from that I think you
could get something that's quite
reusable but I haven't done that we well
I mean you you can certainly make a
general-purpose language a member but it
all depends on what you're doing in your
front end thereof is yeah and that's fun
I have no idea i ran the benchmarks at
the seven a.m. this morning so i can't
say i've done extensive research</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>