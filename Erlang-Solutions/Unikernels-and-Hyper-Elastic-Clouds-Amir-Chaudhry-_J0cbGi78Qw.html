<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Unikernels and Hyper Elastic Clouds - Amir Chaudhry | Coder Coacher - Coaching Coders</title><meta content="Unikernels and Hyper Elastic Clouds - Amir Chaudhry - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Unikernels and Hyper Elastic Clouds - Amir Chaudhry</b></h2><h5 class="post__date">2015-11-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_J0cbGi78Qw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi folks the bleeding edge stuff will be
right the end so if it doesn't work I
apologize we are going to have a release
soon it will work by now so I'm going to
talk about unique kernels show of hands
who's heard of uni kernels ever or wow
it's most of the room how many of you
actually tried any of them out played
with them and those who put your hands
up I'm curious which projects you've
heard of lvm Mirage of those one at the
back garage as well okay excellent sorry
wrong colonel brilliant I love all of
those so a bit about myself so oh
another thing is I pushed a blog post
live that has a bunch of links in it and
these slides so if you want to go look
at that you can do and so you don't need
to scribble anything down and everything
all everything is already up there which
saves me from having to do it later so I
work on mirage primarily I'm also
involved a little bit in the rump stuff
and I'm learning more about Hell vm Oh
over time I generally tend to like
systems up so over the over the course
of my career I've gone from systems
neuroscience to computers computer
systems as mentioned that was previously
a physicist I've worked up companies
that are small and large and I'm
currently working in a start-up is
trying to do more around uni kernels and
so let's go straight into it let's start
with a really really obvious stuff
software is an application so it's
typically a bunch of stuff that is your
code and a bunch of a few of the
libraries that go with it and it sits on
top of something that we typically call
an operating system which provides a
bunch of other things for us so far so
obvious his race car to get different we
build it locally on a machine like this
one here or the ones you have yourselves
and the environment here is kind of
specific but nowadays we deployed
somewhere else so we push it to this
mythical thing that we call the cloud
which is far far away and is run by
other people so that there's already a
difference here in terms of how we build
and deploy software because this
environment is not the same as that
environment and yet we expect things to
run the same so we need more tools to
get there so this is containerization is
one way of trying to make sure the stuff
you work on over here ends up being the
same when you push it
over there and try and make that process
easier by providing a bunch of tooling
around it but all this together makes
things very very complex the software is
now complex even though most the
applications that we deploy up on the
cloud far far away a single purpose it's
a web server or it's a database or in my
case it's my static website which people
visit whenever I give a talk but never
otherwise and its complexity that causes
all the issues the more layers you have
the more tricky that configuring
everything is making sure it's the same
everywhere the more duplication you have
because you're taking that same stack
duplicating it all over the place in the
cloud the more inefficient is obviously
the larger those things are you pushing
around the heart of the other more
inertia there is in the system the
longer they take to boot and generally
the more stuff you have in security
terms the larger get attack surface more
things can go wrong and this is all
happened because we're building for
clouds these things far far away the
same way that we build for desktops in
principle there's no reason why we
should be doing the same it's just
happen that way it's just the natural
evolution we have these things these big
machines with user space and we did
stuff there then we just took that same
model and deployed it and use it on the
cloud why did we do that just because it
was there but there has to be a better
way so if you look at the evolution of
what's happened we've had hardware it's
typical full operating system that's the
OS and on it you put your applications
but nowadays people are thinking more
about this where you're trying to use
containers to do a bunch of work to try
and package things up and you have a
more of a minimal OS that was just
trying to do separation between the two
of them so let's just take this to his
conclusion what does this look like if
what's the third one along they're going
to look like so you want to deploy stuff
far far away and I've emitted the fact
they may or may not be a hypervisor in
here and you're getting more and more
specialized with the things you're
trying to deploy because the further
away you get there the less likely you
are to go in and have to tweak anything
you're not expecting to go in and update
some software over there because you
have a whole tool chain that means you
want to update it on your machine push a
button magic happens something gets
deployed far away that you don't
actually
touch this is the idea of immutable
infrastructure which I assume many of
you have heard of a few I hit I seen
knobs so what's at the far end I'm
probably laboring the points as you
already heard of unicorns so what do we
need to do to get there first we have to
disentangle applications from the
operating system that they said that
they're running on we have to break up
the functionality of the operation immac
czyli provides because it is it is
useful and we have to convert that into
modular libraries that can be
essentially consumed by the application
so the application only pulls in the
bits of the operating system that it
actually needs in order to do its job
and on top of that you want to be able
to target different platforms you don't
want to tie it you want to be able to
take your code and deploy it to whatever
devices whatever environments are going
to be out there in the future not just
now but in 10 years time and 20 years
time at 50 years time so this is where
you can all sit in our view it's just a
natural progression of the way things
are going anyway it's just a slight we
just got there slightly sooner it's just
a little bit more extreme than the way
we work today I assume you've heard
things like this before so unique nails
are specialized machine images the book
from modular stack they're adding adding
system libraries of configuration to
application code another way of thinking
about it is every application is
compiled into its own specialized
operating system so you're no longer
taking a standard OS you're building
your own from the components provided
and you can run that on the cloud and on
embedded devices the embedded devices
part is important because as we have
more of these little raspberry PI's and
cubby boards proliferating people want
to deploy and develop to those as well
being able to deploy your software on
there just as easy as you do on to the
cloud is going to become really
important I'm quite proud of this
because there's now a Wikipedia page
which means we're real and there are a
number of projects so when I talk I
typically tend to talk about Mirage OS
I'm starting to play more with rum
kernel and lvm but there are many other
projects out there and the most recent
one that was added to business was
include OS which is C C++ so that's not
yet released but it will be soon but the
ideas are pretty similar so a number of
these projects take different viewpoints
they have different criteria they're
trying to fulfill some of them are
trying to worry more about legacy
others are trying to essentially take
existing tool stacks existing systems
that we have and break them up so rub
kernels and is an example of that and
Mirage OS is one that's trying to take
type safety and security much more
seriously make that the primary concern
and basically forget about legacy that's
the one I'm going to talk about so when
you say you're going to forget about
legacy you can pick whatever language
you want so Mirage OS has written in a
camel and that's one of the reasons for
this is because it the camel language
has a very good module system and that's
lent itself to the the way that as well
it's interplay between the both but
we've written it in the camel and we've
now got reasons that we made a
retrospective view why we wrote it in a
camel maybe that shouldn't go on the web
so this is essentially what mirage looks
like we take that big stack that we have
we have to do a whole bunch of
engineering work to rewrite libraries
and then you compose all those libraries
and you compile your application down
into a unique Colonel so that little
thing there is the unique and all and
that's all that you have that's what
runs and you target that two different
backends the really important thing for
this is you when trying to give this to
develop is to make sure that the
development cycle is familiar and that
weight the separating the development
cycle from the deployment cycle so you
have broad deployment scenarios what
that means in practice is you develop on
typically a UNIX machine so I do we do
that on Macs and unix machines Linux and
the way you do where you write your code
your application in Mirage is you
essentially just write your code to
start off with you ignore all the OS
stuff underneath because you just use
the things that the OS already provides
you so for example this would be the
networking stack that's on on already on
my Mac so i'm not using any of those yet
and i can compile that down and you've
run it run that unique in all as you
unix process when i'm ready to i can
then pull in all the system libraries
that we've written for example the a
pure implementation of tcp in a camel
and start using those instead of using
the stack that's provided by the OS so
now everything's running in user space
so i'm running all my code everything
still is unix but it's all running
through
type zip code now but that's not how I
want to deploy it deployment is
different set so we typically deploy to
Zen which is Zen is a hypervisor that
runs on the public cloud so it runs on
Amazon ec2 and Rackspace and many other
places partly runs in cars as well I've
heard and when you deploy to these
different environments you essentially
want to be able to take the same piece
of code and deploy it to x86 so this is
the public cloud but also be able to
deploy it to embedded hardware now on
that slide over there I've put armed
hardware and Zen on top of it so we can
run as a uni colonel on cubby board
which is an arm-based device using xenon
arm but we can also run on bare metal
and I'll get to that a little bit later
so what you girls are called big deal or
so what I try and you try to use use the
example of static websites when I'm
describing this I suspect many of you
come across this before and the reason I
do this is because this is very very
easy to understand one of the issues
about trying to get your head around how
unique kernels work and the deployment
models is it so different to the way we
do things now it's not it's not
straightforward to think of what you
know now and apply that to this it's
easier to think easier to think of a
comparison between old stack and new
stack and then you realize what the
difference is so how many of you have
actually built and run your own static
website of any kind great what kind of
stacks did you use just out of curiosity
just shout out pod get her pages django
amazon s3 and for all of those what was
underneath you in terms of so ghetto
pages hosted but on s3 how much stuff
did you have to put underneath
okay okay so one of the things if you're
deploying your own static site on your
own machine you typically have to worry
about the OS then you need to put some
kind of web server on top they need to
put your pages on top of that and you
probably don't want to write raw HTML so
you're using some other kind of positive
right something in some other form and
convert it so you have you already have
this big pile of stuff so that's why you
static websites because that's a nice
way of trying to describe how unique and
also can be quite different so I'll talk
through briefly about secure services
that we can build I'll give an example
of Jekyll to uni kernel which is taking
my personal website which is a Jekyll
website and turning it into a unique
colonel using miraj OS a quick summary
of the automated deployment steps that
we have because getting it from my
machine out to somewhere else where it's
being served is also really important
that tool chain matters and also an
extra bit on how we can summon these
things on demand so they don't have to
be running all the time they can
effectively lie dormant until an
incoming request comes in and then they
woken up they serve that request and
they can go back to sleep again that's
the idea behind hyperelastic clouds
because if things are running all the
time they're using resources if they're
quiescent just quiet they can just be
bored into action when required and I
will attempt to show you something cool
about an upcoming release so these are
the examples are typically use so on the
top left will go top left is the bitcoin
pinata will start start there these are
all static websites and this is an
example of how we build secure services
using unique annals anyone heard of the
bitcoin pinata great i could spend more
time on this so the bitcoin pinata was
essentially a bounty program where we
took the tall stack and with this
includes writing a completely clean
slate implementation of TLS in a camel
that was done on the beach in northern
Africa by two guys over oh it took them
a long time and so all that was
completely rewritten and so we tested
that stack and our other networking
libraries by essentially taking some
Bitcoin compiling them into a unique
Colonel putting it on the internet and
saying take our stuff
so it's a new kind of bounty program or
essentially if you manage to break your
way in you just get to take the spoils
you don't need to tell us that you did
it we will just see the transaction in
the blockchain so probably that was a
first that hadn't been done before but
it did give us a really good way of
stress testing our stack because we put
it on the internet and said try and
break in and if you can break it and all
parts of the stack o fair game so the
networking stuff there's a weakness in
the networking stack if there's a
weakness in our TLS implementation if
there's some issue somewhere else if you
can get in the Bitcoin of yours that's
been running for quite a long time now
and it required all the the the TLS
stuff to be written which also meant
uncovering a bunch of issues and things
there for example the openssl stuff has
a bunch of legacy things like export
ciphers which are still in there which
still cause issues when you're rewriting
something you don't need to worry about
those so if this is the size of a uni
colonel running a Bitcoin pinata anyone
want to guess how much bigger the other
one is which is a traditional stack I
wish not quite that live it is about
this is about four percent the size of
that and that is running a traditional
stack and this is doing the same job
both of these things that one's the
legacy software this one is a unique
kernel version using our stack and the
really interesting thing is not just the
sizes I know you can't quite see this
here this is about 8.2 megabytes in size
that one is a roughly about 200
megabytes in size there's no extra stuff
in this that there is unnecessary
everything here is necessary it's doing
it is performing a job here be dragons
who knows what's in that stuff that's
just an ocean of code most of which you
haven't touched most of which you have
no idea what's going on and they could
be exploits everywhere but these two are
both doing the same job so we can make
things much much smaller and much more
secure one of the benefits of this is
that you when you make things this small
you can actually check
into version control so if you can
version control your entire website
including all the networking stuff that
makes it a lot easier to start deploying
it in different places so moving on to
deployments I'll talk briefly now about
example website with how we use the
Mirage website and my personal website
get taking it from static HTML and
turning it into a unique colonel using
essentially tools like travis CI the
next slide so what we want to
essentially do is develop on the machine
push things to get have things autumn s
automatically be tested and built and
then push them somewhere else this tool
chain is actually really straightforward
and we can achieve this in about 100
lines of about 100 lines of code it's
basically glue code I'm now going to
drop out of this and try and give you
some examples this is where sometimes
goes wrong
whoops oh yes that's now live there's a
blog post that has a bunch of links in
it in case you want to follow up later
so this is my website and I'm running
this is basically github pages and I
want to take the same output from github
pages and turn it into a static website
so what I do here is firstly I don't
want to write in code because I'm lazy
but what the nice folks that Mirage OS
have done is create this repository
called Mirage skeleton and that has a
whole bunch of code examples which
essentially help you get started very
very quickly so there's block devices
there's a DNS server that's console I'm
specifically interested in the one
that's called static website and there
are two files near config ml file and a
dispatch ml file like I said I'm lazy
I'm just going to copy paste these into
my code that's it I don't have to write
this because this has been pre written
and is tested and anything time anytime
something changes this gets this gets
corrected so that's essentially all I've
done here I've taken those files and
pull them into my Reaper and I've made
only a few minor changes to point to
where the site actually is and then I've
hooked this up to Travis didn't have a
tab open for Travis but
and so what essentially happens is when
I push to my repository when I pushing
your blog post what happens is these
essentially get built the Union kernels
get built automatically and travel we
have scripts setup for Travis so I
didn't have to write those either I
wrote those the first time round so if
you follow back to the jackal to uniqlo
post you'll see the post that I wrote to
explain how we write the build script
and this essentially gives you in a
camel environment so you don't need to
worry about that it does the build for
you and there's also information on how
to push an ssh key i sorry not an sht a
secure key it is a necessity in to
Travis which can then be used to deploy
your unique in all because it gives it
the right to push the built artifact
into a different repository and that
last parts quite important because you
you're taking a built artifact which
includes everything and committing that
into version control that is essentially
the entire operating system that you
need to run that website pushed in to
get and if you can do that for every one
of your my blog post i can very easily
roll back so if I've made a mistake in a
service that I pushed out it's just one
get check out to go back
do you want to see this code or not i'm
assuming using youtube it looks like
this so it does so this is essentially
Travis's dealing with the secure key
it's not very good pause in the
environment it does it build all this
happens automatically so this is Mirage
skeleton doing this and we can have to
take a quick look at a config file
itself so you can see the kind of things
that are going on in there so the thing
that I hope give us cover comes across
is that this is not that difficult to
get your head around in terms of these
options that are being set and this is
just a Cameco this isn't as a special
dsl this is a camel code that is
explaining that where you tell the unit
colonel how you want to build for
example this here this line is a choice
between what you want the the flat file
system or crunch it defaults to crunch
my personal website is too big to use
crunch anymore crunch was our own file
system where it essentially shoves
everything into a module it's fine for a
small site doesn't work when you've got
tons of images like I have so I have to
use the fat file system so that's a
configuration that I passed through at
the time of configuration and
compilation and I actually show you that
step now because if we look now at the
Mirage website itself are there any
questions at this point science ok so
the Mirage website is also a static site
but I want to build that one locally
first so now i'm going to give you here
this is not very good i should have made
this let me try this delight
that's fine that should be good looking
you that okay great can you see that
okay it's good to hear okay so this is
the Mirage websites and the code for
this website lives in this folder here
oops I've been messing with it let's
clean that up okay and so this is like
more complicated because we use this
website as we dog food everything so all
the new stuff ends up here first so
these files tend to get a little bit
more occasionally you get a little bit
more complex so we can look at the
config file if we want to apologies for
the well okay you can't look at the
confer call but what we do now is I
first want to pass some environment
variables because I want to and v yes
I'll get there I want to you use the
socket I don't want to use the other
options can you see is that all right
okay so this is the configure step and
I'm telling the mirage tool which is
Mirage that I want to run this on unix
and I want to use the docket so it will
go off and do a bunch of stuff for me
and the kind of things it's doing now is
checking whether it needs to get any
additional packages because the
configuration step tell if it's unix and
it was previously then it needs to pull
down some unix packages if I tell it
then it will try and pull down a few
extras n packages so this is configured
everything is fine it's already have
already had all the things downloaded I
now just run make which will now build
me the Uni colonel
ray that wasn't too long and now I'm
going to run that unique animal
now I'm going to go see this page
there we go so that's now running
completely locally using running through
sockets that so i can see so i can do
local development this way so it's a
static website so if i make a change to
the post i can just run that we run that
compilation see what the changes are so
if i was building application services i
can do the same here i can rebuild the
code locally see what effect the changes
have so i have a quick iterative loop
locally but now i want to deploy this so
this is all fine so now i want to make a
change and I push that change somewhere
else but I want a complete deployment
tool chain from the push all the way to
actual deployment and we do that by
putting scripts in different places
let's close this so this gets built on
Travis which we use Oh broken well let's
not look at that one then
ok
and we're testing all the different
versions but one of these is actually
the deploy version which is this one so
we can look at this show me this and
I'll just show you the extra steps that
happen in Travis okay so what's actually
what's actually happening is we've
passed a key to Travis that is that
gives it access to a special deployment
repo and what it's doing is once it's
done the build is checking that it's a
deployment build it is then pushing that
built unit Colonel back into another
repository a different repository on
github that repository is this one so in
here in this repository have a complete
history of all the builds that have been
made by Travis for this website so we
can go back in time and actually deploy
any single one of these commits if we
want to in addition in this repository
we have a bunch of additional scripts
and these are the scripts that are
picked up by our deployment machines so
we have a deployment machine that where
we've installed them and that deployment
machine essentially pulled this does it
get pull and if it sees that a change
has occurred it pulls down the new unis
kernel and then checks these scripts to
see how to deploy it so if you wanted to
change the deployment process itself we
would change these scripts so even our
deployment processes version controlled
the bit that isn't the only part that is
now outside of this tool chain is
setting up the Zen machine itself that
make sense so doing this we have a
completely end-to-end deployment from
pushing something to your application or
in my case of static website all the way
through to actually being able to deploy
it on a live server somewhere else and
that is roughly a hundred lines of code
100 lines of glue code to get from the
stuff that already exists which the
Miraj OS team are built to something
that someone like me or you can actually
use in production so let's go back now
to our slides
so that's how we get from from
development to deployment in in very
short space of time but the next wing
would thing we want to be able to do is
summon these things on demand we want to
be able to have those things lie dormant
because at the moment what happens on
our Mirage website is it's active all
the time it will be far more useful if
we could have that sit there quietly
dormant not using any CPU not using any
ram essentially in storage until someone
requested a page and when someone
requests a page magic should happen to
boot that uni Colonel very quickly and
then serve that response and this is
what I mean by being able to get to
hyperelastic clouds because if you can
achieve that you can get far more usage
out the same hardware because you can
have lots of things sitting there
essentially not doing anything until
they're required to and then basically
going to sleep again so we built
something called jitsu which essentially
does is for us unique annals already
boot very quickly they can boot in
milliseconds but one of the issues that
crops up is the latency between when
sentido de request comes in and the
slight race between how long it takes to
boot and how far away the time it
happens so jitsu actually masks that
latency so it handles that that
handshake that connection coming in and
then once the UN kennel is booted hands
it off to the Uni Colonel to complete
the connection so that makes the
infrastructure much I can make the
infrastructure your hardware from far
more efficient and we actually have a
demo of this running as well which is
so this is some unique hell that is hold
that up yes ok so this unicon is just in
a regular boot cycle so this is booted
in about 300 milliseconds and it just
gives you some information as the
manifest so this is a we essentially
want to incorporate this into our
website now so we can start dogfooding
more of our tools to say these things
work and you can use them for your own
you can roam tools there's two parts of
jitsu one of which is the Jitsu itself
which is booting on demand and the the
part that of the master latency is sin
Jitsu and there's a paper that was
presented at usenix earlier this year
which is linked in the blog post that
has a lot more information about how
this system works so if you're
particularly interested in this and that
the scalability of the system that's
what death that's definitely worth
looking at
alright so to recap what we've covered
secure services how easy these things
are to deploy and the fact that we can
summon them on demand I'm now going to
attempt to show you something very brief
about something that's coming up in a
new release in a couple of weeks time
but i first have to learn what that is I
got the incantation wrong earlier so
we're about to emerge something called
Victoria which is a new dsl from where i
show it makes it much much easier to do
things do configuration things for a
free to example you want to pass an IP
address to a service do you want to do
that you want to hard code that at the
beginning do you want to pass it in
later you want to pass something in at
runtime or security things do you want
to bake those in or pass them in once
the thing is actually configuring or
running those are all important
questions and this this helps solve that
it's not that part that I'm going to try
and show you it's something else and I'm
trying to find in here this is the blog
post that's going to go live so if you
want to see what this is about you can
read the blog post on github pain yeah
pretty diagrams I'm looking for the part
that says pretty diagrams describe
that's the class the incantation okay so
in the config file this is a bad want to
do it on let's make a new one so in the
configuration file you saw lots of
options so you can choose whether you're
going to have fat or crunch you can also
have two choices about which kind of
network stack you're going to use but
it's sometimes difficult to visualize
all that to understand what's actually
going on this tool this particular
aspect of this tool helps you do that so
that's my website there's a config file
so I'm now going to see if this works I
have not tried this yet it's not going
to work if I type it wrong Raj described
hey okay so now I have a visual a
visualization of essentially what whoops
essentially what this site looks like
it's kind of difficult to zoom in can I
pan as I said I haven't done this before
there we go so you notice that it isn't
telling me whether I have targeted Zen
or you know so that's because my
configuration file doesn't explicitly
state whether i'm talkings anyway so
both options are possible in this tree
in this squat and this gives me a much
much easier way of understanding which
different pieces work for which
different pieces are going to be part of
are the options for the configuration
things that i can change for this
particular unit colonel so this is the
additional thing that i want to show you
and i'm now also going to try it this is
probably mistake and a try on the Mirage
website itself which could go horribly
wrong because that's is quite large
let's just see what happens describe dot
look that's not so bad
okay so this is what the Mirage website
looks like so you can do this for your
own applications and start seeing which
parts of the the graph you're actually
using that are part of your config and
when they get when they get set
essentially so this I hope makes it a
lot easier to understand what's going on
in a unique onal or at least in Mirage
OS in terms of how things get built and
also this is going to be released
sometime in the next few weeks and it's
not just the pretty graphs there's a
whole bunch of other stuff behind it in
terms of making the configuration of uni
kennels much much easier ok so the and
this is a general workflow that I've
described this is not specific to
websites because essentially being able
to encode put everything into version
control makes your life much much easier
and there are live deployments now
there's actually way more than this so
these are just the ones I've picked on
that are using Roger West but there are
also deployments out there based on Hal
vm if you want to look up cyber chaff
that's something that's used being used
and I know Adam who works on how vm is
talking about tour and uni kernels in a
few weeks time so there's lots of
interesting stuff happening out there
the deployments aren't necessary all
public so people aren't talking about
them which is a bit frustrating and then
I trade office of course everything here
is written in a camel so rewrite
everything spend years in a darkened
room writing stuff however it's not the
only one only show in town as I said
there are a lot of others so my sequel
legacy software working as a unit kernel
with rum pum with rum colonel that's
very cool but not only that we're also
doing work with Mirage OS and rub
colonel so now we can get Mirage OS
running on bare metal using things fire
rub kernels so being able to make all
these different un commento projects
play nice together is going to get us
accelerators much much quicker than any
of them individually working by
themselves and that's that's going to be
really exciting of the next year or so
so you don't necessarily have to rewrite
all the things just leave that to people
in the ivory towers so very very briefly
before we move to questions I like to
remind people why I care about this
stuff so I want to empower individuals
to essentially own their own piece of
the internet and this involves building
distributed cloud
distributed personal clouds and
generally more generally resilient
scalable systems and this is because I
use all these services lots of other
people use these services and
essentially people call this cloud
computing another word for it is futile
computing because you're pledging
allegiance to someone else and hoping
that they don't pull the rug out unto
you and essentially in many cases you're
just if you can start to feel like
you're just being farmed and there are
no other alternatives and that's a
really frustrating part and things like
this happen when you start relying too
much on other services this is a tweet
from an from earlier this year and now
this is just a thermostat what about
when this happens for every device in
your house your TV your fridge not just
your thermostat your car all your little
baby mobile that's telling your baby is
healthy all those things they're all
going to come with terms of service
we're not going to read any of them you
don't know what you're signing over I
don't want to live in this future rather
I would like to try and change this
feature if I possibly can and so this is
what one of the projects i'm working on
a long-running project called my mode is
trying to do it's essentially using
unique animals as a mechanism to try and
build distributed personal clouds make
it possible for everyone to own their
own infrastructure this is going to take
a while this is not going to happen
overnight and one of the first first few
things i want to be able to replace in
my own infrastructure is mail contacts
and calendar i'm picking those three
because if i could if i don't trust this
system to run those things i don't trust
it to run anything so i'm not inserted
in just photo sharing or something else
it has to run my email and reliably it
has to be able to manage my contacts on
my schedule if you can do those things
then it can do everything else and it's
essentially about taking the same
approach i've described building
applications using libraries that can be
deployed wherever contribute not and
actually not just to the ones i've
listed any of the unique colonel
projects they're all looking for
contributors there's lots of interesting
stuff out there so if you're
particularly interested in using legacy
stuff as a eunuch i'll try rom kernels
if you're interested in the functional
programming aspects then check out
mirage OS and Hal vm and there are many
others too everyone's happy to have
people are mailing is asked questions
for mirage OS we have a bunch of pioneer
projects so if you're looking for ways
to get started that
excellent approach so just visit the
website and and or tweet me off I'd my
forgot to mention I heard my twitter
handle on the top right so if people do
want to get in touch with me and I'm
happy to give you pointers I shall stop
now to leave time for questions
you said Jitsu is booting you unique
colonel on demand yeah and then it goes
to sleep yeah presumably stays awake for
a while yes so it goes to sleep part I
kind of glossed over because we kind of
leave it running for a while until we
think it's not doing anything and then
it will go to sleep so what sort of
algorithms do you use to determine that
it's not doing anything excellent
question i'm not sure we have we've done
much work on now going to sleep part yet
so i don't think we have any algorithms
there yet but the booting on but the
making sure boots quickly and makes the
connection that part we've done i would
point you to the paper there'll be much
more details in that so if you look at
the blog post the jitsu paper is linked
now we'll definitely have far more
technical technical information I thanks
um I really love the you know that the
whole idea around unicorns one of the
concerns I have and you know we talked
about the smaller attack surface the
fact it's a very smaller a small app but
the thing which gives bothering me is
that we're starting to reimplement
things like TCB dls we're starting to
reimplement things which have got you
know 20 30 years of development going
into them which are being actively
maintained by others are there risks
there would we aware of the risks of how
we dealing with those those risks that
we're opening up a new space you know
we're opening up existing known problem
spaces as new attack vectors okay that's
a very good question there are i will
talk about by saying how long has
openssl been around and that software
that's used by a large proportion of the
internet and then Along Came heartbleed
and that affected how many people a
camel TLS is not affected by heart bleed
so this is partly a case of what how do
we want to be engineering those systems
for the long term so yes I absolutely
agree there's been a lot lot some of
these systems are battle-tested they've
been out there for a really long time I
should we really be doing them another
argument is should we not just be
looking at them as saying can we make
this better should we not just try one
of the things I didn't quite point out
about a camel TLS is that the number of
lines of code the am
out of code is much much smaller than
the other ones that are out there which
also makes it much much easier to get
into your head and understand what's
going on that's gotta help and you can
re-engineer software in a better way so
that you can make it less likely for
people to make errors so I would say yes
there are there's definitely a trade off
on this caution especially when you're
dealing with things like the rate the
security but there's definitely value in
going back to those old things and
rethinking those assumptions saying if
we built it this way what would we
change could we make it better lots of
these projects being actively maintained
because you you're implementing in some
places system functions and are they
being can you trust that they'll get
patched that they've got the same level
of active maintenance as say you know
linux that that's a longer term question
about community and that's one of the
reasons I say unicon also needs unique
annals and general need contributors
because if there are not if there isn't
an open source ecosystem around it as
there is with Linux then no I would say
it's probably not going to survive so it
needs people contributing to it fixing
their own problems by so many things
upstream trying things out so if that
happens if that cycle is taking off now
but if that's sustained over time then
yes those things will continue to get
worked on does that is that answer your
question or it doesn't mean it shows you
that was still in infancy but it's
definitely a good idea it's it's a place
well let's type yeah and there are also
other aspects i should point out for
example i'm thinking of mirage arrest
but if you look at rump kernels there
they're using net bsd so if you want a
tcp status actually been used pretty
hardcore you probably going to be more
interested in taking the rump colonel
one the one that's available i run
colonel rather than the one that Mirage
OS wrote so those options are still
available to you so you can shoot become
pick and choose which bits matter to you
those are a lot of research about
virtualizing zhan network functions like
click OS is a good example where you but
a piece of network stack inside a
different kernel and you how do you draw
the line we have the insight to tell
well this should go in my vertical stack
or this should be another device or
another Karen L insider maybe same
machine or same network
if I understood that correctly I think
that comes down to what there's a lot of
flexibility in how people can write and
build their infrastructure because now
we're talking about how the
infrastructure these components come
together not just in a single
application I think part of it the pilot
will be best practices what people end
up trying and doing and what works for
them so one example is for mirage OSI
Arthur team is there a way for me to
have the network stack somewhere else
such that I can control it and not these
random developers if I'm a knobs person
and they said isn't that a total
opposite of what we're trying to do but
I have I try to argue for a use case
there so we may we'll try that so how
these things play out over time we'll
have to see when people but people
actually do real deployments and that's
where the real answers will come I think
did that answer your question I that I'm
actual voice it okay all right last last
question hi there um I'm interested in
how a bit more about how configuration
works because I saw you were getting
configuration from environment variables
that the environment variables even
exist when you're running on Zen and do
you have to recompile the hype of the
unit Colonel to deploy it with a
different configuration or is there some
other short answer you would right now I
would recompile to do another deployment
the environment variables you can either
get them in the config and mail file so
I could I could have rewritten them in
the config ml and just said this is my
configuration but because i'm using a
what is in my view a stock one i can
then pass an environment variable
instead to change it instead of having
to change the actual file so both those
options are possible funk Toria the new
release also gives you different ways of
dealing with configuration in terms of
would you have to recompile I would say
yes if you're changing something about
the system because the configuration is
also baked into the Uni kernel as well
so if you change something about the
system you can recompile it and
compilation is actually fairly quick as
I hope you saw so recompiling it and
redeploying it isn't necessarily a big
issue did I answer ok
thank you very much a mirror I love your
vision of letting people reclaim their
place on the internet and world and i'm
not being beholden to external entities
thank you very much for work and thank
you for a great talk thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>