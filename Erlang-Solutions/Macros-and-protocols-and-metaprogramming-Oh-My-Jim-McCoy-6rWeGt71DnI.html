<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Macros, and protocols and metaprogramming! Oh My! - Jim McCoy | Coder Coacher - Coaching Coders</title><meta content="Macros, and protocols and metaprogramming! Oh My! - Jim McCoy - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Macros, and protocols and metaprogramming! Oh My! - Jim McCoy</b></h2><h5 class="post__date">2014-03-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6rWeGt71DnI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I work at Facebook basically my team
builds the security tools that are used
to protect Facebook's corporate and
production networks from hackers my job
is to basically build the tools that
keep Chinese hacking teams out of
Facebook that is really my top-line job
requirements so it involves a lot of
interesting and fun things to play with
but one of the things we've been working
on for a couple of months and what's
probably gonna become a major efforts
over the next year is a large-scale
packet capture and analytics system and
for that we're building a large chunk of
it in early notice as it makes sense and
existing tools in scale to forty to
eighty eight milliseconds traffic flows
so basically I've been playing with her
laying dabbling with for quite a while
since before there were books and have
never had an opportunity to really
produce something as a passive rather
life I experienced large-scale our
length basically when it out the
Facebook some of the news I'll tell the
story now rather than at the end early
as you might know was originally
announced aboard the chats are the
facebook messenger products we use her
leg
and over the first year soviets it
worked great that's what it always
wanted but within Facebook it was hard
to get people to join that team in
Facebook various efforts and teams sort
of recruit people and say you know come
join our team to use the chat team said
come join our team really cool stuff you
learn this great language and so people
would just basically follow that path
and then discover they've learned this
great language okay then cannot apply it
anywhere else in Facebook because there
were no other schools that did it the
user like that and so we ended up with a
situation where the decision was made to
port our chat system from her life over
to C++ and so Facebook spent fifteen to
twenty man years of efforts porting this
chat server from Erlang over to make
that respected as the implemented
version of OTA instance plus I was on
the operations team so I have helped
maintain that at the time they were
doing
basically dealing with all of these
sites and problems will cause when it
just didn't scale well or it didn't you
know it was not fault-tolerant all you
see if you think about this just works
when you're using it her mind but they
decided to move it at C++ they follow
that path for about I think it's been
about a year and then they turn around
and last week governed by could be for
nineteen billion dollars that build a
chat server in our language so this is a
movement of reached I'm praying for all
of us so it's been an interesting
interesting path so elixir basically
what is elixir elixir is a punctual meta
programming where language it runs on
the Erlang Camille so elixir code
compiles to be my code runs talks to
other related functions you call our
line with in elixir basically the way
that I've kind of described to myself
this is not really true it's it's a
combination of Ruby enclosure that runs
on the other line beyond so from Ruby
you get a very easy to understand very
friendly syntax from closure it steals a
lot of great ideas on protocols on
macros on all sorts of other higher
order functions and those sort of things
and then underneath it all it's purely
so look over a few of the things that
make elixir a little different if you
were to spin over elixir you would see
that a lot of it is a very familiar it's
just some syntax and data types are
a little bit different the most parts
have the same basic stuff lists tuples
atoms they're proceeded with : so they
look a little strange when you first see
them binaries all the other standard
data types
elixir adds a couple that's basically
are just purely from the movie side of
things raises red X are first class data
types within elixir additionally it uses
a keyword shortcuts this is actually
kind of easy to get to you easy to use
once you kind of get used to it
where you've got an atom and then some
other data type as keywords you can
basically just throw them out there as
Adam :
whatever so the strainers everything is
doing the strings I'm sure you're
probably using binaries by now but back
in the day when the string of care lists
they were pretty little elixir just
skips over that station completely there
is a string data type that is a binary
there's a string module that is built
into the standard library that has
really great Unicode supports as you'd
expect from a language created by a guy
who's got unicode data character in his
name string interpolation is probably a
little easier than it is in standard
Erlang
the syntax itself is mostly the same
obviously immutable data but it's not
single assignment basically pattern
matches quite C code at the bottom there
from the interactive shell of it it
could rebind a variable you want you can
put a carrot in front of it that
prevents it from the binding and with an
Masha's it really is early underneath
obviously you're still with single
assignment elixir uses blocks so
basically you end up with a lot of these
do ends scattered throughout your code
first time you see it it's a little
strange when you used to you know places
where you normally put in commas or
semicolons and standard or minor they
just throw them to men for most people
that makes a lot easier it took a while
for me to adjust to remembering okay
that didn't end in the back of this
those sort of things parentheses are
optional so it's the syntax uses
basically slightly different lettering
in Berlin obviously variables gonna
start the capital letter elixir those
reserved modules protocols and records
everything else is just lowercase and
very much like them but everything in
her line is available just by calling
clean underline the Erlang atom is the
gateway to the namespace that contains
all of you just quarter line functions
any underlying library within elixir I
could just call by colon module name
called dot function and get straight to
a regular line function within an elixir
elixir again it's functional lots of
anonymous functions different namespaces
sonate functions and anonymous functions
basically coexist but there are some
weird syntax that they use to
distinguish between the two it has a
little syntax the ampersand open and
close friends are used for short hands
for anonymous functions so basically as
I'm writing code I can create quick
anonymous functions
you know foo ampersands and then the
ampersand one in the inverse into are
basically saying give me the person to
second payments of whatever and pass
similarly I can create something that
depends fizzbuzz to the text that ice
pass into that bar the weird thing about
elixir comparator lying is that you have
to put a dots after the name when you're
calling an anonymous function just
basically if I create a matress function
that bind to some variable let's say foo
if I want to call it as a food dot
it's a little strange and that's
probably one of the most off-putting in
these easiest things that I end up
missing in my own code but you tend not
to use you know neighborhoods to
anonymous functions as often as I
would've thought
obviously in modules name functions of
the modules similar to the movie thing
police are keeping private and public
API is almost are basically accessed by
a death or death P so it's slightly
different way to define them as a record
title and either be a module where sighs
built-in getters and setters or the
streets Erlang
it'll decide a compile time which one
you didn't want to use using the airline
records faster using the module based
elixir records is a little bit slower
but unless you do a couple of other cool
things so if in your code you actually
use the getters and setters and the
update function it says so new job
obviously needs to use this version of
the records if you don't use that at all
it'll automatically decide I mean use
the faster lane versions of records so
why it's a little neater but why would
you want to do this why would you want
to use it as versus straight they're
like a couple of reasons the first is
looks just been able to learn a lot from
me watching the airline experience and
primarily it reduces a lot of the
boilerplate that we
every five as we're doing it it has
improved productivity it's a lot easier
to throw new people into elixir and
because of the way the Elissa community
has built up the system there are a lot
more tools that's make it very easy to
create quick and small things I do not
necessarily think that it's more
productive when you're dealing with very
large scale stuff but small - you know
medium-sized projects the lips is
probably going to offer you a lot of
productivity benefits that grows very
very cool and one of the things that
makes the lick serve definitely more
interesting I think that some of the
other languages on the Orlan vm that
have come down and then there's these
protocols which is basically ability to
attach specific behaviors to generic
data types either the existing ones
within the languages or one that you
create yourself and sometimes elixir is
actually faster than Peter aligned the
elixir compilers phase can basically
figure out a lot of things that's what
shortcuts it can make and in certain
cases some of the modules for elixir are
faster than the equivalents of our mind
so as far as the boiler reducing the
boilerplate the first thing it does is
it eliminates needless text your
standard gen server temblors okay
sorry the the code highlighting is is
pretty tragic here
but you've seen us all you know tons of
times this is it does nothing this is
just a basic here's my kind of server
everything I need to do the elixir
version much easier you don't need to do
anything that does nothing you don't
define it Just's the Ruby fashion of was
a convention instead of configuration I
can't remember what the Ruby way is but
it's basically if I don't tell the
compiler do something special here just
do what it always notice for that
particular type of code so a gem server
obviously there's a startling there's an
init there's everything there is in
every 10 server that you've ever written
you just need to keep saying that over
and over and over so you have a much
shorter code for a lot of these things
and it's also possible to use basically
a DSL okay you'll look at the the PDFs
you'll be able to see the code a little
bit better I hope but basically it X
actor is something that takes it and
here we've got three different death cat
or to death casts and a call and it will
throw in the API function as well as the
handle call and handle cast functions so
basically it'll do all that for you
because standard patterns
it just says okay I know what you want
here I'm going to throw
if you tell me something different we'll
do it differently otherwise those
patterns that you just follow over and
over when you're writing your list of
code for your line code this basically
eliminates a lot of death
the next thing as far as reduce
boilerplate is that it has this weird
little signal color pipe so it's
basically a vertical pipe and a greater
than sign and that's used for data
transformations and data pipelines and
whatever so a standard pattern you got
is I've got some data perform step a
with the data take the results perform
step B with the results take the results
perform step C and a couple of different
ways we tend to do that in our lab I
think we use a lot of ten variables you
know t1 equals output a of input t2
equals transform beyond t1 those sort of
things or else we rights reverse nested
code inner function outer outer outer
you basically stepping out the results
if you pass along with a lick sir it
basically you take some inputs and then
use the pipe and it pipes it's two
functions where it automatically assumes
that the first argument of that function
is the input takes the output from the
previous step and then pipes it back in
is part of one of the next step so
that's just functional yes it makes it
very easy to basically composed
functions and it gets rid of all these
type of variables and
a little data pipelines so for example
this is one of the bottom of the left
that's kind of hard to see is a stream
that generates an infinite number of
Fibonacci an infinite number of
community sequence and the stream module
itself is it's lazy so none of that is
evaluated until I hit the enum module
and say I wanna take cannibal and then
it pushes them all through so it also is
aware that as it's building these
pipelines it doesn't necessarily have to
evaluate everything at each step along
the path you're not gonna need the data
until you get to the final step as far
as the productivity tools the links ER
has a variety of little feature that
people are building into again coming
from that ruby side of things
we've got mix which is the standard
building project tool a lot like rake
and other groovy tools it builds your
code it compiles things you can just
create a new project and fill it out
with here's the entire templates and all
these directories here's you get in or
here's your your live directories your
application file etc basically builds a
project for you
it'll manage all your dependencies or
run your unit tests has a lot of
different functions that it can do where
it can basically pull down you can say
this dependency is this github project
with this version and it'll pull that
down and compile it and then check if
it's change those sort of things
it's got exp M which is a nice package
management system so it's a way for you
to actually share packages with other
people and make it so that within my
code I can actually pull this package
down
around time I can say go get this ESPN
package compile it and insert it here
within code as I'm running it the Alexis
standard library is still small at this
price in ten major modules but it has
gone through and is actually I think
cleaned up a lot of the somewhat crufty
API on certain airline things for
example related to the pipeline in
elixir everything all of your iterators
and all of your collections are the
first argument to something to feed into
that pipeline so they went through all
of the various functions Maps
phones everything related to pass
something around and said no matter what
it is are you the one that's the
collection or operating on similarly
certain things like file and a couple of
the other things will perform a little
simple wrappers it's basically a
simplified version of a lot of the same
Erlang libraries that you've been using
for our macros macros are the magic of
elixir so the compile time modifications
to the code basically as the code is
processed by the inner length of the
elixir compiler you can perform complete
syntax tree modifications on the fly as
you're writing it and it's very smart
about how it doesn't it's completely
home iconic so you can write elixir
within elixir and run code eval and say
go do it so you can actually meet the
code is data data is code sort of thing
that all of us people have been talking
about for years the mixer itself is
completely written
summers not completely 90% of the
electric code is macros so basically
there's a very small stuff that's used
to bootstrap up the macro system and
then everything else is looks from the
core modules to everything else that
lizard does is completely done as macros
it also enables you to extend elixir and
by proxy Erlang with application or
project specific dsls so it makes it
very easy for you to modify the syntax
to fit your problem example that I'm
doing right now is I'm building the
large-scale pack capture and analysis
system one of the things that first
really told me that Erlang was going to
be incredibly cool
was seeing that one-liner that parses
the TCP header where it's like okay
here's a binary and boom boom boom here
all your fields here's everything you're
running through there and suddenly
you've got the entire header to
deconstruct it in a single line that was
a magic but using it can be a little
hard on the Python side there's a
library called skatey that's basically
used for packet manipulation you wanted
to create a magic packets to to play
security games or if I wanted to play
you know see if something is susceptible
to our poisoning or whatever scaping
will let me build low level packets by
basically just saying I need an ICMP
packet with East we feel
flipped on on who may get that basically
the binary representation of that so
what I'm doing from my project is
building a version of CP in elixir that
lets me have a DSL for me to be letting
packets while the same time giving you
the advantage of all the Erlang goodness
of actors and OTP and everything else
entire system so for me the macros are
just one of the very very cool things
about elixir but it's a very sharp knife
macros are always one of those things
where if you go too deep into the
mattress you will end up messing up so
for the most part my experience is
mostly been I'll let other people write
the macros I tend to use a slightly
different system that they've got called
protocols rather than macros itself some
how do you do short little macros macros
and cells it's done just using a single
keyword close so quote will take some
chunk of some block of code and return
the internal representation that code so
for example here quotes and then do
obviously is the start of my block so
the representation of ten is ten the
representation of a list is a list
tuples are actually represented as a
code fragment where we have here's the
tuple and then the middle thing is
metadata and then this is the data
itself so that's the tuple one two and
then the atom Z similarly if I were to
add two and three plus is the actual
thing here and then the context is it's
calling elixir and the kernel module
with an elixir so kernel plus and then
adding
the Ark's so it's a fairly standard
fairly standard reasonably simple code
representation where you've got here's
the function that I'm applying it to the
context I'm applying that function and
then here my marks unquote is the
reverse honestly it basically injects a
code fragment so base if I said foo is
in a one two three and I quote it within
this I get this is the representation of
that code so it's a list with two atoms
and then that code fragment as a pointer
to a variable foo with an elixir
namespace and then I can unquote it
within a quote so basically this is the
code representation and then the unquote
says take whatever that code fragment
this represents is inject the code
fragment back in here cite I get my one
two three back into the quote of this
list Oh
tragic okay too bad because this is one
of the cooler examples is the way that's
this is a denim towards the guy who
threw this up on another presentation I
saw this and this was one of the things
that said to me elixir could be magic
this is something that's using an HTTP
it's a mind type module is this a valid
mime type is basically all it does it
goes out dynamically gets from the
Apache foundation of a list of all mime
types pulls out the comments and then
basically splits the string into lines
and then unquote the first part of it
the mime type so basically at compile
time builds the entire list of all valid
mime types when you at the moment that
you compile it it pulls it down and says
I'm going to create one thousand two
thousand different function
just zip them right down and create this
is valid and then we've got and if it's
not here's the the fallback is obviously
false this is how elixir does all of its
Unicode it actually goes out pulls down
the entire Unicode spec finds all the
code points and says is this Unicode
boot here you go
so it actually this is a similar thing
that it does for a lot of these sort of
cutesy things but basically quote and
unquote let you turn the code into data
and data into code another example is a
test assistant test framework but the
the basic elixir test framework is built
in macros as well
this is a macro that just says you know
I'm gonna take a describe that will
define a function macro called its that
is what we're going to apply it to and
then create something shitty what's
gonna make more sense when you see the
actual usage so I can apply a spec where
I describe using macros and then it
applies and spec and creates that
function and then it's is the macro so
quotes the passes as expected that's the
function name and then this should equal
is where it just says are these two
equal to so basically it's a kind of a
simple version of how you can build a
test framework strictly out of elixir
macros and this is how the macaronis
system within the lick sir works so it
has its own macro system or its own test
framework this is also a part of the
whole mix system protocols will be
underneath them protocols basically give
you polymorphic access and interfaces to
your data types so it lets you extend an
existing data type by adding behaviors
those there's a function within elixir
called inspect this is basically kind of
what you
I think it is you know inspect some
variable oh that's a list and here's the
value of the list and here's all the
other information I have about that
particular binding and variable inspect
itself is just built as a protocol so it
can effectively enabling you to take us
a core data type and create additional
behavior around it so what I'm using it
for with myself is I'm taking this
packets format which is just a record
type with an elixir and making it so
that I can add behavior to these records
but they're not coupled in the same way
that Oh couples code and data it's just
a set of functions that know what to do
when I pass it a particular data type
whether it's a record or a tuple or
something like that and then there is of
course a fallback oh I don't know how to
do the implementation of the data that
you sent to me therefore I'm going to
use the fall that function it uses def
protocol def protocol defines the basic
protocol where you say you know here's
the stubbed-out version of the function
that I expected everything that's
implements this protocol to do and the
implementation is we need to find
implementations for various data types
here's the implementation for a list
here's the implementation for a to point
and it's also something where it doesn't
have to be defined in the module it
defines the data type so somebody else
could define a record and I could define
a protocol based on that or if you had a
protocol for something that you are
doing I've been come in with my own data
type and I could add an implementation
of the protocol for you of your protocol
for my data type so basically I can make
my data type play within your system as
long as it means sort of it the
interface contract
faster so it can occasionally be faster
it was basically the hash dip easy much
faster than Erlang this might be a
little slower with maps maps are
something that elixir is itself going to
Adam is tracking the progress once it
actually once r17 goes out alex will
also have a map type and its own version
of maps but at the moment it's version
of hashes and disks is faster because it
can do compile time optimizations and
say we're not gonna be following that
path I can use this simpler version oh
you've got a lot of entries here so I'm
not going to use this I mean as a genie
tree it can basically be smart about how
it's doing things again macros also
enable lazy evaluation so if I have an
or function within pure light it's going
to if I pass in two arcs to the order to
evaluate both of them with the elixir
version I can actually evaluate the
first one and short-circuit out so I
don't have to use the or else or and
also basically I can just straight more
spray tans short-circuit out and I can
that's again built using the macros
because could be lazy about how it
evaluates things anyway as I mentioned
they compile time optimization is this
standard Erlang just doesn't know enough
about us as far as the right paths to
follow so why else the other reason it's
probably worth learning a little bit
about elixir is it's easier to introduce
people to I think than our life while
they're lying itself is not a difficult
language it's intimidating
it has reputation there are a couple of
things that's a little odd getting
people used to the commas and semicolons
and periods and all the rules around
those can annoy people
discover so elixir looks close enough to
Ruby
that's anybody no I think I can
understand that there's there's magic
there but it's not that scary
plus the fact that it's easy to use for
dsls means that it's easier to sneak in
an organization that way oh this is just
the DSL for doing X or doing why it
doesn't look like or like and it's also
kind of fun more basically places to get
info one thing I haven't talked about
concurrency or OTP don't do that because
it is underneath or like message sends
receive once you get into the OTP aspect
it looks completely familiar to you I
know that's because it is or like I
haven't really gotten that far to make
it and then elixir version yet so it
really is just a thin shim of syntax on
top of pure or laying for applications
and processes and all those sort of
things your supervisor fees are still
early supervisor trees they've been
spending a lot more time dealing with a
lot of the really basic stuff getting a
pretty solid in there elixir is a moving
target so things change a little bit
there have been a couple of reasonably
you know let's just saying that as it
goes from version to version is not
strictly holding the backwards
compatibility they tend to deprecated
things that sending warnings current
version is like point zero is zero point
one to point four it will probably go to
1.0 sometime this summer and
set in stone in terms of the basic
syntax but it is still at a point where
there's nots it's a fun it's an
interesting in new community lots of
people who are getting into this who
don't necessarily know neither lang side
of things but are very enthusiastic
they're happy to go out and wrap up
early modules and diplexer versions
there's lots of the information that's
kind of available on the web a couple of
books that are still all the books that
lists they're actually in the early
access programs that the babies
physically printed yet the introducing
elixir book might be printed I don't
know but otherwise it's all kind of
early access stuff the programming
elixir is definitely the book that
people who understand
Erlang should look at quite frankly if
you go to elixir Lane org there is a
crash course for lying folk this runs
you through a lot of this will get you
started yeah
yes sir first of all given that
evaluation underneath his eyes
insignificant reflection by the person's
yeah
say how about my sequences which is kind
of what a nice powerful features so
there is a version the streams module
that I sort of referenced is somewhat
lazy sequences so it is as close as you
can get there are certain limitations
that are imposed by the airline platform
there's certain things you just can't
get to certain places from where we
start but the streams module does have
lazy sequences infinite sequences
sequence generators where you can just
kick it and give you the next one
getting the next one of those sort of
things not yet
streams are themselves maybe four months
old so crufty but for the most part
again they a lot of those sort of core
things closure is that model they would
well I think I mean sorry I'm gonna
biased my to my face
but what I think to see is how about
languages have my coming so it's not the
same way that's not the same of the
listeners but it is you can you can
within your Erlang I could you know
fire up the the repple and write in a
straight you know that it bends that I
then say okay
evaluate this or manipulate the actual
parse tree so the the tool is that
represent the various miss themselves
and then it builds a lot of syntactic
sugar on that make it a little easier
it's not I don't think it's let's see it
can the macros are hygienic but you can
actually step out of there so you can do
on IJ you can grab variables and hold
them those sort of things with
inoculation yes again it is again Ruby
syntax closure guts running on early is
a good way to kind of think about it
they as much as possible I think they
still a lot of really good ideas from
closure so yes it tries as much as it
can but it's
Plus such brings me to my final question
you mentioned that music right so if you
really hate Ruby syntax how bad is that
and that I wish she said we're not
stressful to just give it another shot
well absolutely the actress no it could
be none I mean the the do the do form
I had a where's basically there's like
do and then that do and a bit
so do heads when I say it's a shorthand
for the dude DuPont it really is it's a
macro that base gruesome Oh a doom in an
end everything inside of here is a do
paren kind of thing so it does those
sort of games where it's like okay
everything we've got in here is
basically something you can go in Italy
and along the new features that are
added to exert are done in the same
fashion sentences you know I think we
should do extra wide and because it's
got macros you can do that yourself
you're not limited by what every
designer said this is how we will do it
no members you can make your own in
front of this and within that language
you can go and play and run you know any
access any other line function anywhere
any process those sort of things you
know everything you expect from an
airline system is there
have you found there any like areas
where the elixir syntax is more open to
using the other links and text for
certain things or is it just like
totally better in every respect the
whole do end stuff it's like nails on a
chalkboard to me so that great some yeah
I'm slowly giving in but that's one
example and there are a couple others
the the optional parens can kind of also
be annoying once you get used to it you
just mentally you're filling in okay
this is the argument that passing this
you see some line where it's like some
keyword binding binding something else
make weight which where does the
function which part of that is actually
harder to the function in which that is
the next thing we're passing along I
think it can get a little weird
sometimes and that can lead actually do
some problems where because of the fact
that you don't have the the prints are
optional there are certain things that
bind more tightly than they should and
that can really mess you up so that's
one of the things that also
earlier toki con suggested that I just
say this I don't know of any massively
large projects the tools at the moment
tend to be built around two or three
person stuff so there's not great tools
for maintaining this is my stuff this is
your stuff namespacing bits but guys
it's mostly because I don't know anyone
who's actually done it could be that
it's perfect for ginormous stuff as well
but languages that have macros and
sometimes get in that situation where I
write a macro you include my code
suddenly you've got my weird little
language bits stuck inside your code
what the hell is going on here where did
this keyword come from why can I use
this as a variable it's because my macro
rebounded so that's the only thing I
mean I know that people with large scale
Lisp so it can be done so for mine
that's all I'm using it primarily to
enable security analysts who are not
deep programmers or if they are they're
actually late assembly and you know
battle widow reverse engineer folks
write really short snippets of code to
describe some pattern they want this
thing to look for this tool to look for
hey I'm gonna does you know check this
resource for a list of command and
control IP addresses and tell me
everybody who hits this within you know
the past 30 days and then also sent an
empty
it's larger than size X that's something
that's reasonably easy to describe once
you've got a decent DSL for it so that's
what I'm using it for is it's something
that's I can introduce to people if not
we're not going to have the time to
really learn our way this is something
that maybe they then write their little
bits I pulled that module into my stuff
and it's talking to her like that the
lower level is doing all the package
shift so it really it's is a question of
finding the right application for it but
I think it's easier for most people to
learn and if you're doing something with
one or two or three people the
productivity gains from yeah yeah well
that legacy code that I've written but
I've used you know the web server
underneath it is
it's your using the elixir world is not
large enough that they have built their
own infrastructure versions for
everything so we tend to get us lots of
I had a rap summer leg thing in an
elixir friendly API or sometimes it's
it's now reaching the state looking
whatever meeting things in pure elixir
but a lot of the early efforts were I'll
go out in Conway to find some package
and you know eyebrows or those sort of
things those are what's actually under
the covers on a lot of these things so
they've got probably five or six
different versions of rails of course
well I believe oaks are doing this now
so everyone wants right there the
version of rails
say thanks amount of time right yes
exactly so the within the mix project
listing I think said my dependencies and
I can say this dependency here get it
from github and here's the hash of the
version we're gonna pull down under my
house yes a can go by ash waiting to say
I don't care given that the latest but
you can't lock it to a specific ash and
then say okay now let's recompile
everything and you know everything
that's changed this version cute I don't
care what version it is you know JSX or
whatever pull that in but I need a
specific version of eyebrows or some of
the functionality pull it in and molars
i but it's very its oriented towards git
and github so that's what they're using
I would not be surprised
have you mentioned as well about the -
types - like compile times tell there's
even stuff - you know I think all these
things in it doesn't seem like could be
a bit of a problem showing like Caitlyn
you know breaks I mean like is there any
I know today I mean today like a
medicine say you should be doing this
way so that everyone's kind of work on
the same version well in that particular
example that that's not how elixir
itself is though but the the unicode one
is the example where when Jose cuts new
branch
he basically hits the button that says
give me Unicode and it goes so that's
already pre done for you when your
anomaly that was just an example
something to put up there's like here's
an easy way to show what you can do with
it
it's just this one thing we grabbed a
list of mine types from an online
resource but it could also be one that's
let's say a boat with your disc so it's
not always changing it does mean you're
going to blow the code a little bit
you'll be creating you know five
thousand function yeah it's routes and
those sort of things are all yeah
there's several of them that are really
nice sugar and weather are the two big
ones at the moment that are very much
wheels like yeah routes and those sort
of things are precompiled and done as so
it is the macros are compile-time you
can do the code eval and actually play
with it at one time I dropped a slide in
there today
macros protocols and meta programming
the meta programming is a lie it really
is macros and protocols and meta
programming you just should do it is not
run time
that's all the questions</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>