<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2015 - The Timeless Way of Building Erlang Apps | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2015 - The Timeless Way of Building Erlang Apps - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2015 - The Timeless Way of Building Erlang Apps</b></h2><h5 class="post__date">2015-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UUvU8cjCIcs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you this morning for joining me
this is a great and interesting topic to
me and I want to hopefully convey this
to you in some way the talk is broken
down into three parts so I'm going to
give you a little table contents here I
want talk about software patterns today
because I think we have a context that
we approach patterns with and it's
important to start there I want to shift
over then to Alexander Christopher
Alexander and you'll see who this guy is
and and sort of the inspiration of
software patterns I want to get into
that and make a connection there and
then I want to move too early so I want
to apply this scheme that I think is
important too erlang and we'll see how
that goes sound good all right so when
you hear about software patterns today
most of you I think we'll think about
this thing or something like this thing
software patterns I use this book when I
built my first large software project or
ran and led a software part use this
book and made sure that we implemented
no less than eighty percent of the
patterns it was just like this this is
the thing this is all the smart people
have gotten together and put patterns
together and we will learn and leverage
this and it will work out great and the
irony is it didn't work out great the
irony is that in all of my years this is
easily the worst piece of software i
have ever written without a doubt and
I'm sad sorry I don't want to put the
blame but i blame this i blame the
software patterns as we'll see software
patterns actually patterns in general
the languages that we use to describe
things cause the result they are the
seed from which our flower software
Springs so depending on the language
that you use will determine what you
build if you have the wrong language
you'll build the wrong software if you
the right language you'll build the
right software I'm going to make that
point so the soft that the current kind
of goals of the software patterns
movement today this is a quote from
grinde Bhushan the forward of the the
the the book on the previous slide the
goals help developers leverage the
expertise of other skilled architects
that's reasonable we want to leverage
want to get together and and leverage
our collected
experience skill so skilled architects
to get together they put things into a
pattern manual and we then get to use
these and learn from them they provide a
recurring solution to common problems in
software design also very reasonable
right we all heard this this is good and
finally speeds up the development
process so patterns have been sold to us
as being a great thing because it makes
us smarter faster stronger we can jump
higher we can do more great things and
that's been the promise and to some
extent that may be fulfilled I think in
my personal experience it was not but
everyone has their different experience
so i wanted to say for the record I am
NOT against the previous book I'm not
against it I just have had you know bad
luck implementing it i'm also not
programming an object-oriented
methodologies anymore so consider that
these patterns are often associated with
object-oriented programming so for me
personally this has been a not-so-great
pattern experience I recently started to
read this book this is the timeless way
of building by Christopher Alexander and
I started to read this is the
inspiration for the patterns the
software movement you'll see it cited
consistently as the origination of
software patterns this is where it comes
from and as I started to read this I had
a huge disconnect because I started to
really enjoy what I was reading finding
it enlightened useful brilliant and
absolutely having nothing to do with the
experience I had with patterns
previously again I'm being a little bit
hard I am a bit jaded I have some
emotional issues about that project in
particular it didn't turn out very well
from my point of view so forgive me that
but when I approach this book I started
to see patterns from his point of view
and I want to talk about that so they're
very different so this is Alexander
patterns first of all he describes
patterns as they apply to physical
structures so is high level as regions
and towns neighborhoods houses Gardens
alko's talks about towns buildings the
construction so this is his domain so
he's not talking about software talking
about these things for Alexander he's
seeking this thing which is called the
quality without a name and it's
the book starts out a bit mystical it
kind of like it's like he's got these
sort of very terse and and the ethereal
statements about quality and things that
are hard to grasp and he spends a lot of
time trying to build up his concept of
equality without a name I think he
succeeds I think in the end e you get a
very specific impression of what he's
talking about but as I started to read
it initially I thought this is kind of
flaky but as I saw what he was doing and
what I was talking about it became for
me all truly brilliant and I think we
have a tremendous amount that we can
take from this if we apply it correctly
so one of the things that's part of sort
of endemic to his model of patterns is
that they're they're discovered they're
not prescribed I think when we look at
patterns from the software industry many
of them are sort of observed but many of
them are also prescribed I think they
think they feel to me as if they come
from a whiteboard or some sort of I
don't want to say ivory tower but on
ivory tower some sort of academic
exercise of how things should be
architected they don't feel normal to me
they feel strange I could go through
some of the patterns and read them and
read some of their descriptions and
you're free to do that and judge for
yourself I find a lot of them to be
utterly utterly confusing and bizarre so
not something discovered but very much
prescribed so he's talking about
discovering patterns and this is a this
is the other sort of tenant that he
brings forth and I'm going to talk about
this in detail is that they are informed
by human emotion and this is a surprise
this was a surprise to me and I think
you might be surprised to see how
effective this observation is when
applied to software okay so this is his
point of view here now he was asked to
write a foreword Christopher Alexander
all the patterns book and so here is
this sort of inspirational figure within
the software patterns movement please
read this book and write a foreword for
us and this was one of the quotes from
that forward he says but speaking only
about what appears in this book patterns
of software I must confess to a slight
reluctant skepticism I have not yet seen
evidence of this improvement in an
actual program taking this out of
context a little bit he's not actually
being critical here he's actually
talking about his own sort of lack of
knowledge of software in general so it's
hard for him as an
protector or builder to come and weigh
in on this software patterns industry
when he doesn't know anything about
software but he tries and he looks at
this and he says can this be applied can
my sort of Alexandrian model of patterns
be applied to software and he's
skeptical he's scratching his head
saying I don't know if it's even
possible to apply this and he says it is
it possible for a program to have sort
of this quality that you might
experience when you you nestled up to
with a book and a crackling fire because
this is the sort of thing these are the
sort of aesthetic qualities that he
talks about but he wants to create in
building structures he's like how does
this work in software how do you get the
sensation of a warm hearth right and
reading them you know from a mahogany
library and a leather chair is this
possible I'm a programmer your
programmers we've all nestled up to that
program that feels like a crackling fire
pretty much we we've all been really
turned on and excited by something it's
felt right it's felt normal felt natural
a library a function a piece of software
you can probably name a handful of them
that you really really like you've
experienced them and that's an emotional
affinity I believe that we can take his
sort of disposition his approach to
patterns and apply them pretty directly
the software and in particular or laying
so this is what I'm going to do before I
do this I want to really hammer on this
topic of emotions though so this is a
quote again from Christopher Alexander
from this timeless way of building to
find good patterns we must rely on
feelings more than intellect and that I
think is the biggest surprise for me I
think it's the biggest surprise it's the
biggest disconnect from what we've
experienced in traditional patterns and
what he talks about so let me give you
an example here when I have a dilemma
between choosing between two options
option a and option B let's say it's a
cookie and a cupcake I had this happen
recently I want I want both but I can
only have one but they're both great
what do I want I don't know what I'll do
i do I literally do this I'll take a
coin out and I'll flip it heads it's the
cup cookie tails it's the cupcake the
coin decides
and then I observe and at that moment I
am sensitive to my own emotional state
what is my emotional response at that
moment in most cases I'm actually not
neutral I have a very subtle disposition
one way or the other and I note my so
I'm either sort of happy with the result
Oh cookie great thank you coin or I'm
disappointed with the result oh I really
wanted that cookie that tells me what I
want and then I get what I want I ignore
the coin but I use the coin I used the
coin to tease out an emotional response
and this is what he's talking about
patterns made from thought without
feeling lack empirical reality entirely
and he spends a lot of time on this and
he explains that it's not about opinions
or theory or ideas or tastes it's about
visceral feeling it's a sense and for
him this is a matter of empiricism
because we can always sit around and
debate a point of view we can debate an
opinion you know whether sup hey well
with whether something is good or bad or
right or wrong but we can't debate we
cannot debate our reaction when you flip
that coin and you observe your reaction
that is something that you can't help it
happens and so he wants to seek out
patterns that are feeling motivated so
when you experience something that's
good you note that and you use that as a
signal to tease out something of
substance within that context that's
going to leak into our Lange stuff I
know it's a little philosophical here
but you'll see this is kind of cool okay
one last point about alexandra i'm going
to move move on to some to some some of
the other laying stuff hey this is a
comment about architects and builders so
patterns do not come only from the work
of architects and planners he goes on to
say they come from the work of thousands
of different people so one of the I
think underlying threads prep premises
of his of his work is that every
individual has a pattern language
everyone has their own his or her own
experience and things that we do
repetitively so he talks about building
buildings we talk about code every
person in this room has patterns that
you use you may have sort of official
pattern
that are recognized that are supported
by language features and libraries or
they may be personal patterns thing isms
that you do that you bring in and you do
them a lot and I bet you do them because
you like them there's something about
them that is good that brings a quality
to your work that you enjoy that has
this sort of what Alexander says quality
without a name so the fact of the matter
is everyone in this room every
programmer can participate in the
elaboration of patterns and what his
work is about is formally doing that it
is about defining a process in a method
of identifying a naming pattern so that
we can share them but they're very
personal we share them but their
personal and patterns that are good
collectively tend to surface and you'll
see this in towns you'll see this in
cultures in building cultures you'll see
predominating patterns of building
architectural styles different isms
associated they came from regions they
came from individuals they came from
communities that came from the soil and
this is his observation the patterns are
actually an evolutionary process and
they come up more philosophy I really
like this philosophy though my I have
lately been investing time and energy
and understanding how nature and vents
and creates things how the heck does
photosynthesis come about that's a
really really important invention and a
great invention how did that happen I'd
like to understand the processes there
it's very much an organic evolution or
natural model that Alexander proposes
and this is why I like it so I'm
attracted to it all right does that make
sense as sort of a foundation I thought
I was going to let go through code and
like you know here's my here's how you
generate a skeleton with this and here's
how this interacts and with uml diagrams
and we expecting that are you
disappointed but I'm not I'm not giving
you a uml diagrams nobody's disappointed
is it anyway single person you're
disappointed oh come on Zack you're
trolling you're trolling as usual yeah
we're not going to uml today what I want
to do is I want to develop a useful
pattern language for a line i'm not
suggesting this doesn't exist i'm not
suggesting that
working patterns in Erlang has not been
good I'm specifically interested in
working within the spirit of this model
of Alexander's model and I've taken all
of you know 12 minutes to introduce it
you can't possibly do it justice but I
want to give you a feeling for where I'm
coming from I'm jaded i have i have a
bad emotional response historically to
the traditional methods that we use in
building patterns for software I don't
like it I want to stay as far away from
that's possible but what I see Alexander
actually talking about if we're going to
take actual inspiration from him I like
that so I think we can do some
interesting things in the area of
airline I want to see this be a
community effort with completely free
and open participation this cannot be
the Gang of Four we just can't do that
that's ridiculous racial marketing it's
great to sell books and there's a lot of
great content in that but this needs to
be in my opinion something that is
completely community oriented and open
and free for everybody to participate in
with complete democracy that shouldn't
be too controversial within the Erlang
community okay methodology so just talk
about a pattern this is lifted from his
book so i'm not going to reinvent
anything i'm not going to my approach
here is to not weigh in with any
expertise here because i absolutely
don't have no idea what I'm talking
about I've known experience I'm reading
what he's writing and it's very detailed
it's very very well written you should
get a copy go to the library check out a
copy by one borrow one read it it's a
great read the thymus way of building
just for personal edification but I
really am NOT an expert here so what I'm
doing is simply stealing from him and
just putting it down right simple so he
wants us to first give a pattern name
and its really interesting he has in in
this book goes through the same process
that we go through and we name something
at least I do when I they try to name
something naming is extremely important
to me I've somewhat obsessive
immediately probably dysfunctional II
obsessive about naming things I want
these things to be completely obviously
clear at a glance
and that is an extremely difficult
process to get that right to get names
immediately obvious sort of naturally
obvious and intuitive but he has the
same point of view and he'd uses the
same thing he says sometimes we don't
know what to name something so we give
it a fake name or we give it an interim
name we say it has to do with this thing
over here and as we start to understand
what this thing is we get more and more
specific so these names are very
important and I'm going to show you some
examples of patterns that have names
that are just me pulling stuff out of
the air I don't know if they're good I
don't know if they're not we need to
participate i think together to figure
out how to name these things once we've
identified that thing that we want to
name and that's hard work but they need
a name they need a description as to why
it's good so this is the dividing line
for me i don't want a pattern language
just to model something i don't want to
see it just oh here's some mechanical
pieces i'm going to describe that and
now i'm going to let you use that as a
vocabulary I want goodness I want a
sense that we're building great software
and I think that with the right language
we can build great software more
naturally more intuitively more fluidly
and and more consistently so I want it
to be good that's a standard we don't
want bad shouldn't be controversial but
unfortunately I think a lot of these
things are are glossed over because
we're very technical we're very sort of
model focused and and and and sort of
almost machine focused and a little bit
too theoretical Alexander will ground us
to our personal experience he doesn't
let us get theoretical we can't get up
here we have to experience the things
viscerally from it from a human emotions
point of view finally we describe where
it should be used so we have a pattern
we describe why it's good you might
think of it the why it's good as the
benefit so we put things in terms of how
it benefits people or benefits you as a
programmer and then we clarify how this
would be used in practice very very
simple okay here are the acceptance
criteria so this is me now I'm this is
obviously this is not Alexander this is
me sort of stumbling through this in
thinking this might be a good idea I
think that these are good ideas I think
first of all you should be the thing
that you're naming should be used some
place something that you can point to so
we're not like constructing abstracts
abstract isms we see it we see it
working and so we can draw it out from
experience also we should see a repeat
repeated over enough time so it can
inform our experience again trying to
plug into something trying to inhabit it
it's hard to inhabit something in a
whiteboard very hard to do people do it
they think that a whiteboard pictures
are right they are often not they are
almost always not right you need to put
something out there and run it and
inhabit it and see it and observe it so
how was it too right how is it to deploy
how is it to run how is it to maintain
and you feel this you know the
difference between something that feels
you know this was a great experience we
had a bug in the system we were able to
identify it efficiently and fix it and
it was minimal downtime that feels great
have you ever encountered a situation
where you put something into production
and it takes three weeks to debug it
because you can't replicate it and you
have no tracing features in in the
system you have to constantly redeploy
debug versions of your code that feels
bad that every human being on earth will
say bad that's bad we don't like that so
something that should record oddly and
over enough time to inform experience
and finally yes it must feel good so
again human emotion all right a little
bit different it's a little bit
different but I think what we're see I'm
going to get some examples here I think
what you'll see is that this is actually
not as crazy as it sounds turn this off
smart okay so what I want to do is
Alexander breaks his patterns down I
shouldn't say breaks it generally
categorizes them but they apply to
things that are very very big like
regions towns neighborhoods all the way
down to you know how should this corner
be developed and there and the
socio-economic patterns patterns related
to neighborhood and age different types
of individuals there's lots of different
types of patterns that he uses and I
think the same general approach can
apply here has to apply here I'm going
to break down a number of pack of
categories for the patterns and we're
going to put the patterns in the
category
just kind of helped up to block these
out to say you know these are different
types so here's the most fundamental
type of pattern is the early OTP
construct so here I'm talking about the
language so a function a module a an OTP
application supervisor these are the
things that you'll see in books these
are patterns you can point to them you
can see them you can run with them you
experience in them experience them if
you're new to Erlang they are novel
supervisors right that's an OTP behavior
anybody who's built an OTP compliant
application has worked with supervisors
you have to so that's not that
interesting that's not like this
esoteric pattern but it is absolutely a
pattern in this language that we should
name describe it why it's good and where
it can be used and you'll see examples
of that another category that I think is
important is the function type a couple
years ago I gave a presentation here on
writing beautiful code in in Erlang and
in that where I broke down a number of
different function types that I've
personally seen so I'm not trying to you
know present an absolute list here but
the things that I generally run into so
accumulators initializers message
handlers different types of functions
and you can see in your own code you'll
see certain types emerging I want to
name those types I want to understand
why they're good why they provide value
put a name to them so that we can start
to use them in a shared pattern language
so we'll see some examples of those
similarly process and behavior types so
behavior of course is a callback module
but it really is defining a type of
behavior associate with a process so
it's it's taking a process and then
layering a set of functions on top of
that and that gives it a type sort of
the closest thing to know to do too I
don't know me there doesn't apply to
object-oriented subby havior but there
are types that we use and these are
these kind of drift up into business
logic and other constructs or facilities
that are interesting so I want to name
those and again I'll show you some
examples above that I see application
level facilities and some of there's
some overlap here but application level
facility would be something that
provides a facility
application broker a broker a pub sub
service of sorts pub/sub facility or
data service a facility there are
patterns that occur repeatedly there are
really good patterns that were not
naming that we should name and when we
name them we can go pluck them out and
use them and talk about them when we're
talking about how to solve a problem how
to build something I don't distribute a
facility i don't use distributor Erlang
if i have a distributed application i'll
just use networker or socket libraries
those of you who do use distributed
Erlang and build distributed
applications using this will have
patterns and i don't know what they are
I would be very interested to learn but
this is part of the ER laying ecosystem
and we need to be able to talk about
distributed patterns distributed
facility patterns and then finally i
have here principles this is a bit fuzzy
it's a little bit difficult to point to
that i'm not saying you've got a point
to something and see it working these
principles are hard to do that i don't
know if this is the right name it might
be coding conventions could be in there
but i think principles is as close to
what I'm talking about and there are
certainly some other scopes here or type
categories here that I'm missing I don't
want to be overly controlling here but I
want to give us a framework just try to
think about how to you know just think
about this so we're going to observe
things well where does this belong in
this panoply where is it you know where
do I put this thing and I think this is
helpful in that respect to me anyway
okay finally some examples before i get
into the examples any uh does this make
any sense is it completely bizarre i got
one nod and one thumbs up alright that's
represents about two percent of the room
and that's that's a good start i got to
okay but some more okay good I think
we're on out of three percent all right
well let's try to get 25 and I'll stop
there okay here's some examples and I
hope that these will bring some
something concrete to at least the stuff
I'm talking about so this is a pattern
that hopefully everyone under a nose and
if you don't you should get familiar
with this in terms of the sheer joy of
using Erlang this is most certainly
within the top two
this is a revolutionary pattern and it
feels to me awesome this fits into the
Erlang OTP scope it is a process a
supervisor is a process dedicated to
starting supervising and restarting
processes that's what these things do
maybe it seems kind of subtle but here's
what it does this is why it's good it
helps you recover from process crashes
there should be nothing nothing like
more emotional than crash right i mean
this is an emotional thing if you crash
it's generally a very strong negative
emotional response but if you can
recover from a crash that is a thing of
beauty and most languages labor to get
your code right erling i believe almost
taunts you to get it wrong you almost
want to put note you do want to put bugs
into production I just want to see this
work it's just fun to see this work
you've got oh there's there's a bug yes
it's crashing it's restarting and it's
filling up logs but you know what nobody
notices supervisors are intrinsic to
this and they spawn goodness throughout
the land so they are a very good they're
a very good pattern that we should we
should know about we want to use these
wherever we need fault tolerance if you
don't care about fault tolerance don't
worry about it okay so that's that's our
star pattern that's that should be not
that controversial this is a the next
pattern is a is a function type and I
have just a few examples here let me
make a point on that I have like seven
examples six examples there are probably
conservatively a hundred plus patterns
that we could easily get to easily this
is just a taste this is just in fact
this is just a you know a scratch on
this journey I will propose an outline
what I think this needs to go it is not
the work of an individual or a group
you'll see that so these are just
examples and only a few but it gives you
an idea of what I'm thinking about in
terms of a methodology and how these
things would materialize and be
presented okay so a function is a
message handler is a function that is
called to handle receive a received
message this is like if you write a gen
server it's hello info hello
cast hello these are hello say hello
handle I write a lot of hello world abs
every at every attribute hello world out
handle handle info handle cast these
these are message handlers if I'm ever
handling a message it's always handle
under something it's just a convention I
use and then I know that's a message
handler so what's good about these is it
simplifies handling a message as details
are handled by a dispatcher now I think
this is a little awkward here I have
found that trying to put like the
essence of something into into words to
share is unbelievably hard for me I just
I think this is close to kind of what
I'm thinking about but I think this you
could probably take a few passes here's
what I mean if you look at what's going
on with these message handlers in gen
server there's a lot of stuff that goes
on before the dispatch and after and
that stuff is valuable if you were to do
that yourself you have a lot of code
above your handler and the actual handle
block or receive block and after it
would clutter your code and would make
it hard to read and it would make it
buggy so the goodness here is that the
all of the complexity of the pre and
post dispatch functionality is
implemented here now how do you put that
in a sentence this big we try it doesn't
have to be that big but if to share this
thing it's important I think to get to
the S essential goodness of something
what makes something good quickly and to
do that you need a good name and you
need a short description and you need to
be able to get to the point the value
proposition very very quickly that's
that's what I'm trying to do here I
don't think that's perfect but I'm this
is this is the effort so this is this
pattern is something that I've observed
and in the library e to that that I
wrote this is one of the two primary
process types and in my observation a
this is the process behavior scope in
the description here is a process that
is expected to stop after performing
some task so in Erlang to do this under
supervision people typically would use a
gin server and use a trick in the in it
which returns a zero for the time out
which calls handle
info with time out and it's a way to get
out of in it into your process running
very quickly and then you can perform
your task operation that's extremely
awkward and difficult so there should be
a construct within Erlang that lets you
just run something very quickly and proc
lived at but you lose a lot of other
functionality I'm getting very technical
here but conceptually a task is
something that you start and it's
supposed to finish now elixir has this
as a first class citizen I think you two
pretty predates that I believe he might
have taken inspiration from that if not
that's fine this is a convergent
evolution it's not that complicated
systems can be broken down into
long-running operating systems demons
and and tasks and i found that what I
build software in Erlang I'm always
thinking about is it a task or is it a
service is it is this process something
that's long running and hosting some
functionality over time or something
that's performing some task so this to
me is a personally personally is a very
important pattern that I use all the
time and I really like it it's simple
and the goodness here is that handle
short-lived work autonomously so you
need to do something boom task and you
use it not surprisingly when you need to
perform short short-lived work
autonomously again it's our I don't know
it some of this language is awkward but
it's a starting point and people what I
think I'll be interesting is when people
see at least the starting point of
what's going on here to get feedback and
people hack it up and change it I'll
propose a method a contribution policy
that was very very very open and
aggressive in getting people to
contribute to this all right just a few
more tasks here are a few more patterns
as examples cleanup crew now this is
something I've not heard before so I
think this is I think this is mine I
think this is a novelty here a cleanup
crew and this goes into application
level facility so this is an example of
kind of a higher level construct usually
it's implemented as a process or
behavior but to me this is a logical
function of an application so I'm
describing that as an application level
function application level facility
cleanup crew is this it's a process that
cleans up after other
what I find developers often do it's a
little bit like error handling you you
try to write something that cleans up
after itself for example if you write a
temporary file there's a temptation
within the pin the function that uses
that temporary file to clean that thing
up after you're done so you're a good
citizen so you go camping it's a picnic
and you clean up after yourself and
everything is perfect the problem is
that you will always fail at that in
some way if the computer shuts down for
example that temporary file will be well
it gets cleaned up when it starts but
that's a incidental there's always
something that will fort that so I found
in experience in putting these systems
in production this is what I would do
you can't get it perfect so what do you
do we've got to clean up you've got to
put something into into motion that will
fix what's broken in that in those few
cases where there's a there's a where
that that fault occurred so you have to
do it in point 0 0 1 percent of the time
why not do it all the time why not
change your whole approach and just say
I'm not going to ever ever delete a
temporary file if I create it I'm not
ever going to try to fix something I'm
going to leave my picnic site as
completely messy as I want I'm going to
work on what I need to do and then you
point a cleanup crew to come by
afterward and you can run these things
you can pull them you can do all sorts
of interesting things but I found that
this is a remarkably good pattern for
building robust systems you find systems
that just start to work magically it's
like how did it noted oh that guy he was
advocating for this state cleanup crew
went in and he said I want the state to
be right and he just kept checking and
checking and checking and made it right
so for me I call this a cleanup crew
maybe there's a better name but now this
is an example the pattern that's
starting to move up the chain here into
I think some innovative ideas now
there's a lot of those out there you
have these ideas there in your code
someplace you might not even be aware of
those things there are things that you
like there's things that you put into
production or run or experience that
feel good and what I would encourage you
to do is note that try to put a name and
differentiate what is going on here that
is making me feel good about this and I
think you might have a useful pattern
there and then you can you can
contribute to this this process so why
is it good removes the burden of cleanup
from other processes and you use this
one you need to clean up tasks to be
clean clean clean up tasks hmm and clean
up test need to be performed
something's are kind of obvious once you
understand the what they do okay a
principal crash by default people people
this is similar to fail fast I think
fail fast for me is too general fail
fast is not it doesn't capture what I
want to capture here what I'm talking
about here is rather than trying to
handle exceptions by default don't
handle them and allow the process to
basically remove your error handling so
it isn't just fail fast and specific and
it comes from experiences of seeing in
my own code and others a tendency to try
to fix errors and if you if you have
exception handling in in Erlang I also
took very precise and and well
understood you probably should just
remove it I think this is an important
pattern an important principle at least
two name and understand it dramatically
simplifies code if you ever have a bunch
of exception handling logic in your code
just delete it and see what happens just
try it you'll your functions will be
reduced probably to twenty percent of
what they were if not less and you might
just find yourself being happy because
it works anyway erling is remarkable in
that respect and it gets back to that
process isolation and supervisory
goodness use it everywhere use it
everywhere this is an easy one okay so
those are some examples what I've done
here I'm going to flip over to this site
and show you this so this is live and
this is a hack this is like me going as
fast as possible to just get something
started I don't want to suggest that
what I'm doing here has really any
credence other than the goals of the
methodology the approach I think I think
there's something good here and what I'm
very interested in here I've kind of
walk you through this is getting people
to contribute to this and to contribute
their own ideas and in way in hey I
think this name could be better or I'm
not sure this is an actual pattern or
you know this could be a tweaked over
here or here's an illustration that
helps to clarify these things so what I
have currently this is a super simple
side this is all static oh this is
I do this this is all static it's lambda
pad yay or like static on to content
generator if you don't know about it and
use this you'll learn my lambda pad so
the source of this is it's all it's all
plain text i'll mark down and Erlang
terms which get compiled down into into
the website but these are the patterns i
have what i did this before will stop
take a breath and then it doesn't happen
okay so here's what i have it's like 33
or so of these things I'll just name a
you know kind of scan through acceptor
pool accumulators a function type you
know when you're building a list these
types of things a broker behavior
cleanup crew there we go connection pool
data service dispatch function that's in
the Earl ain't that's an actual function
nearly OTP construct get up arguments
you know the pattern where you say in a
function call rather than having like 15
arguments you have maybe three that are
essential and required and then the rest
are optional that's a get opt pattern
maybe you can name it something else if
you don't get off this but to me it's
that's that's getopt is a very very good
pattern and and when you apply to our
lying functions it helps to really clean
up your api is a great deal i wish they
were used more but that's in there io
list really important pattern everybody
should know about this and use it its
goodness squared rate limiter service
stats sink really quickly on that that
comes from movie gers g proc tremendous
insight there in a project that was
running you can point to it was repeated
and it's a great pattern g proc lets you
from a process poke data out into a
collector stats sink and and then others
can then see what the statistics of
processes are very seldom used jeep rock
should be in the core it's very
important pattern it's it's identified
here so you can kind of see where I'm
going with this that's early in pattern
set org there's a contribution policy
there it's all pull request is super
simple if you give me a pull request I'm
just going to merge it i'm going to use
Peter tensions model for emerging pull
requests which
is merge first ask questions later it is
controversial I don't care we're going
to be as aggressive as possible at
including everybody in every way don't
be surprised that other people modify
your your contributions but that's the
way it works it's going to be a
free-for-all of contributions and we'll
see what happens there okay so I've got
a few minutes for four questions here
but let me just quickly summarize what
this is for me is just a starting point
and it's early days I was up late just
filling in some hack descriptions just
so that have them just a brain dump
stream stream of consciousness the real
work is the community the real work is
you contributing to this I really want
to give Alexandra's model chance I'm
really going to keep an eye on personal
I want to keep an eye on is there
something good here I mean what's the
what's the emotional component to this
why does this feel good when you use it
and help people really want people to
think about truly the emotional part
this is not an academic theoretical
exercise this is a matter of translating
our joy of programming which is informed
by a wall that we are as human beings
into things that we that surface and
become patterns that we can talk about
and share and these are the patterns
when we start to formulate and
internalize them what we produce will be
good that's the theory so I don't want
to give this a chance and see what
happens it's a very very hard i found
and and i'm just interested to see
what's going to happen here so it's very
experimental so with that I think I have
a good 10 minutes here to get into some
shouting matches with people who wants
to shout ah yes
a single to probably legitimate
I never never used Jen event I think
it's a bad pattern I don't think that
Erlang uses Jen event I think it's out
there but I don't think it's actually
used I think it's stub for their handler
but I don't think it's used at the core
last I checked it wasn't used anywhere
so I wouldn't use Jen event under any it
causes problems with supervision it's
really tricky to use it in a way that's
fault tolerant I found but you know if
you so here's what I would say let's
let's bring this back to the pattern
exercise what have you seen that works
well and what have you seen that doesn't
work well and and try to collaborate
with colleagues you know find out what
your in your experience is a good thing
and then try to name that so if you have
a question about how to do something i
don't know if that fits into the
patterns work here I'm not sure I don't
know it's not obvious how that question
you know elaborates but or plugs into
this but I would say you know if you're
identifying a problem with something
let's say you see that in here and say
how does this or you know raise an issue
within this project it's all in github
so we're gonna use the issue tracker and
github some people have issues or
questions about something that they can
they can ask their yeah yeah
yeah absolutely the comment was about
these these patterns having to have a
context and that's what sort of the
where used part is in this and the where
used examples here are one line so
really they need to be you know fleshed
out in a full set of documentation I
really don't know I don't know I think
that that I would I think I didn't put
jenna van out there because i personally
don't like it that's ridiculous somebody
put it out there something to put Jenna
been out of there right now do a pull
request and i'll merge it right now so
we'll figure it out but but I'd like to
see that process emerging from this but
what I do know is we should be able to
name whatever comes out of it we should
be able to put a name to it and we
should be able to use it effectively to
build good software within the
appropriate context and understand where
the trade-offs would apply Alexander's
book is big and he covers a lot of this
and filling in the pieces that I can't
possibly i don't understand them fully
and be i couldn't i couldn't communicate
them in this short period of time so
there's that we'll use that as our Bible
for this project yeah in the back
illumination way to describe them using
our link cool yes or up describing them
import because the problem is if you
describe it Justin boards using very
high level statements then it's very
single pops up it has like different
dimensions you can just go in right yeah
i agree with that so so in in in this
hello world example of the project I
don't have any illustration I don't have
any sample code both are required i
think if you look at a pattern language
which is the follow-up to the timeless
way of building which actually contains
like 258 patterns it's an incredible
scope and it represents unbelievable
work detailed work there's almost always
an illustration a photograph or
something to help you understand
spatially what's going on in fact I
believe that's a rule for him he says
because he's dealing with the spatial
problems you must have a drawing or you
must be able to draw something with this
so I think we can apply that maybe not
say we must have source code but we must
have something to elaborate visually so
we're not just talking about a
theoretical concept without something
tangible we have to be able to put this
into practice so we have to have what
you're describing and David
yeah process dictionary the process
diction earning that's got a skull and
crossbones next to it yeah you know
that's um I I think it's interesting I
don't think it shows up in the pattern
lang in the specific patterns that
Alexander's put together and the pattern
language book but he often talks about
bad patterns in contrasting to contrasts
good patterns so I don't know how this
fits into the scheme offhand but I think
that's a good idea I think it would be
very people people say you know people
here all the time don't use a process
dictionary I don't know I've heard that
so often i'm actually tempted to go use
it all over the place just to see what
happens i mean is it really that bad I
don't know but it would be great to have
an anti pill an anti-pattern is a great
idea it's great idea this was the
forward that this is where Christopher
Alexander scratchin has had gone
Townsend software yeah it's good read
any other questions yeah
how do we owe this a good question so I
think I think yeah I don't know III
think that my immediate thought would be
it would be interesting to see a level
of consensus or agreement on whether
this is good maybe a voting I don't know
but but i think i would say that because
it is we really want to identify things
that have a universal goodness or
positive response i don't think a single
person in the room would argue that
supervisors are bad but they certainly
might argue that Jenna van is I would
make an argument I don't think Jen event
should be in this list but there's
probably a lot of people who do and
that's probably going to you know we're
going to see some yeses and noes i would
say those should be designated as
controversial in some way so maybe this
belongs over like on a wicked Wikipedia
format at some PT a-- wiki or something
that we can give us a votes and down
votes or something I just wanted to get
this going as quickly as possible but I
think that's absolutely right we need to
have some visibility into as things
evolve in this where is the consensus on
it and how are things coalescing on that
front in overtime yeah
karma and that's what they but since we
want examples anyway it could be that
you have to link to the code in a github
and all sorts github repo to show as an
example of motive it's a good pattern
may be harder to be better it could be
hey that's an idea yeah I think you
should be able to i think you should be
able to buy patterns with beer like if
you can like you just do they'll be a
currency of something i don't mean I
mean always like beer has to always be a
part of Erlang culture but i don't know
i don't i don't know i don't i here's
what I would say to that I don't think
it's a problem we have right now I think
the problem we have would be just to get
the first pull request that's where I'd
like to go and just see where it goes I
want to see a really hard I want to see
a problem emerged that's like yeah this
is a problem this is it could be we want
to have things linking to other things I
just don't know at this point I'm we'll
see yeah yeah some something like that I
think I think that would be helpful any
questions or comments anything else nope
yes
so we could have like a certification
process we could just say you're like
ninety-eight percent web like a logo
like yeah yeah yeah maybe maybe maybe I
you know I'm very very happy to see
where this goes I mean I literally mean
I think the next problem is getting one
of the contributor that's my problem
right now and we'll see where that goes
because that's really the life of a
project is people actively contributing
so I think we can hash these things out
over time as things start to to call it
to develop yeah yeah so maybe the
problem is it so that's actually the
next problem i have to go do some work
and i was really hoping that somebody
would do a pull request and just make
that happen but you're right i should i
should probably go and flush some of
these out at least in one just one just
one yeah yeah but honestly i really i
think actually i think it would be great
to just see i think people should just
pile on I don't care I mean this is just
this is totally experimental there's
zero ego here in fact it's interesting
Alexander's premises this is a
completely egoless exercise it's all
empirical it's all observation and it's
all feeling based it's wonderful okay I
have time for one more question yeah
yeah yeah yeah absolutely yeah so the
comment was the specific term that Joe
uses and others concurrency oriented
programming that's an example that I
don't know if that's a pattern or not I
mean it may be you know how do you use
it how do you apply it is it a principle
it may be a general category it's almost
like saying object-oriented programming
but are there certain concrete
executable deployable patterns within
this model that elaborate that fill this
concept in specifically so this could be
a category or something I don't know I
think so absolutely I don't I don't have
any rigid structure here I hope that's
come across I just want to get I want to
get people contributing to this the only
rigid structure i have is really i want
i want to i want to really give
Alexandra's model a fair shake here yeah
pull request I don't know did I don't
know weigh in contribute so when I say
polo request yeah well I really just
want to see some faces show up on this
this went to sleep yeah I want so right
here this is it I think this is my
standard for my next but here so we do a
refresh here I probably lost network
well project activity is really empty
they're actually there is some project
activity there's a there's some sort of
networking thing going on here it's on
its go to just go to ER laying pattern
store against all it's all linked there
yeah so I don't mean I don't mean to die
completely dodged a question I really
don't know i think if you've got some
thoughts
what do you do yeah so I think I think I
think I think there's a very terse read
me there that would hopefully point you
in the right direction if that is
ridiculously hard to follow put an issue
out I want to get you involved I don't
wanna I'm lazy and I want to i'm also
very interested to see what the comitia
go into patterns go into the pattern
subdirectory you'll see the meadow see
the markdown files in there okay so
that's a good feedback i can go ahead
and and help to make that clear but
really I want community here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>