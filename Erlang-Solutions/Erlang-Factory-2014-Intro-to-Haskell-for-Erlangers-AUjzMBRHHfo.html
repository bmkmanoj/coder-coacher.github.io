<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory 2014 -- Intro to Haskell for Erlangers | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory 2014 -- Intro to Haskell for Erlangers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Erlang Factory 2014 -- Intro to Haskell for Erlangers</b></h2><h5 class="post__date">2014-03-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AUjzMBRHHfo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm Bobby Ippolito I'm gonna be
talking a little bit about Haskell today
in the context of our lang so Who am I
well I'm not classically trained in CS
it seems like many high school
developers are because they they're
doing programming language research and
they wrote a thesis and they implement
it in Haskell but that's not me
I've been an Earling developer for some
time I started in 2006 at Moche media
where I wrote our web web server and ad
server and various other services in
airline and I've been a Haskell user
since 2012 for maybe more of an
enthusiast because I'm not really doing
anything professionally at the moment
let alone Haskell I'm currently teaching
web technologies to teenagers with a
nonprofit called mission bit basically
we teach HTML CSS JavaScript and some
back-end stuff as well we're kind of
evolving it at the moment we're less
than a year old and I'm also doing a bit
of advising on the side so why bother
learning Haskell well I learned a lot
from studying new languages I learned a
tremendous amount about functional
programming from using our lang and
really learning our lang but I've also
heard over the years that the types are
supposed to help you write better
software some of this from Java
developers but some of this also from
academics that are using languages like
ml or Haskell or even Scala or something
like that these days
and I've had a bit of a taste of that
iíve used quick check and dialyzer and I
like those tools and I've also heard
that Haskell has good support for
parallel parallelism and concurrency and
at the end of the day it will also help
me understand more CS papers because so
many academics are into this Haskell
thing and just to put it in context this
is the the RAM footprint per like unit
of concurrency so Haskell does quite
good here the minimal amount of
concurrency with Haskell where you have
a thread and an M there the M Vera is
just something that you can return a
result on sort of like a promise or a
future or a task or an RPC s async call
or something and then so it's it's about
half the size of an airline
process 64-bit to 64-bit and other
languages are much worse so we have it
good here and so how did I start out
well for four years I was intimidated by
Haskell because I at first I didn't
understand functional programming and
then you know other things like all the
words mono adaptive functor all that
stuff it scared me away but while I
briefly worked at Facebook
Brian O of Sullivan taught a class that
I could take instead of working during
the day so I did that and I learned
Haskell then and it was just the
catalyst I needed to get started and
after that I I started reading some of
the books and I just deliberately
practiced and one of the ways that I did
that was I took the Exorcism IO
curriculum and I just ported it to
Haskell and I also started reviewing
everyone else's Haskell code so I I
learned a lot about Haskell by kind of
teaching Haskell and I think I told
people the right stuff but we'll see
and so what's has schools appeal the
most interesting thing about Haskell to
me is that Haskell has all these
abstractions that you can use because
it's nice to write higher-level software
but Haskell has these ways of unraveling
it all so that they just go away so you
you you can write code that's very
abstract and very pure and elegant all
that stuff but you don't pay the cost at
runtime
you're not having all those closures
actually get created the compiler smart
enough to inline the right things and
the laziness allows the semantics to
work out such that the compiler can just
throw away all kinds of stuff and you
can write elegant code that actually
works efficiently and the the type
system makes maintenance a bit easier
because it's it essentially forces you
into dialyzer every time you compile
anything so if you want to change the
type of something over here it's going
to tell you everywhere in your whole
program where where else you need to
refactor so if you're changing an API or
something you should probably change the
type so it'll tell you all that stuff
and the syntax is pretty nice
our lang gets some complaints about its
syntax I I've grown to love it but I
find Haskell syntax even nicer and the
community is great because it's like all
these super smart people that know math
better than I do and I'm learning math
by learning Haskell and computer science
and there's just like really high
quality libraries that are very well
thought out basically the way that they
design libraries is they they write like
a PhD thesis or a master's thesis or
come up with some algebra for how this
software should work and it's very
interesting to study that stuff but
there's also very practical libraries to
web servers and and byte strings and
vectors so it's a combination of stuff
you need and stuff you can learn from
and so the name Haskell comes from from
this guy Haskell curry so Haskell
started off in the 80s a bunch of PL
researchers we're all working on like
lazy functional programming languages
and they were all doing separate
research and had to just reimplemented
to form a committee and they could make
a language by committee and they
actually did that they released the
first one on April 1st but apparently it
wasn't a joke because they've been doing
it for a very long time this this is
some of the original committee these two
phases are kind of familiar this philip
Wadler guy he wrote paper for how you
could practically bring subtyping to
Erlang that's not what we ended up with
but it was inspiration I think for specs
and types and all that stuff and we have
john hughes of quickcheck he was
actually involved with the Haskell
standard from the beginning and the
first version of quick check was
actually in Haskell and so practically
speaking Haskell more or less started
off with the Glasgow Haskell compiler
it's the one that everyone uses today it
started off a long time ago there's been
several revisions to the Haskell
standard it moves more slowly than than
air Lang syntax but GHC adds all these
extensions all over the place so you can
get cutting-edge features if you really
want them Haskell's domain it's it's
designed to be a general-purpose
language you can do anything you want in
Haskell it's not necessarily easy to do
anything you want in Haskell but you can
really do it if you
he wants you you can make it work but
because it was designed by all these
programming language researchers and the
the tasks that they do all the time is
parsing and compilation and type
inference so it's very good at that
stuff
it has great libraries for that and
almost every meaningful haskell program
is effectively a domain-specific
embedded language but i embedded i mean
it's it's in haskell syntax it's not
parsing some string to make that dsl it
actually just is Haskell but you use it
in some more abstract way but it's not
quite so crazy as Lisp because there
aren't macros it's been popular in
academia and it's becoming a little more
popular in industry so these are some of
the people that use it Facebook has some
really cool stuff that they've been
working on recently and more boring
companies use it there are some consumer
apps some of these apps have been sold
to Google or Facebook other ones are
more practical like the Baz quacks is an
RSS reader so for those of you who are
using Google's reader a lot of them have
switched over to this one there's some
commercial services like enterprise
employment scheduling and user
management the kind of stuff that
Earling is also good at and Haskell's
bread and butter is really compilers
like essentially all the Haskell
compilers are written in Haskell GHC ajh
C the g8 the Haskell to JavaScript
compilers some more research programming
languages are also implemented in
Haskell agda and idris some compile to
JavaScript languages and because Haskell
is so good at writing compilers they
even made a perl compiler the first perl
compiler in Haskell because it was
probably the only thing that they could
reasonably implement it in at the time
there's also a number of stand-alone
things
my favorite is pan dock which basically
takes some markup format and converts it
into some other markup format so I wrote
these slides in some abomination of HTML
and markdown and it made it into this
reveal Jas
presentation but it could go late Tech
or PDF or any of that stuff so
distributed revision control they have
some of that stuff not too popular these
days but they came up with a nice patch
algebra for for darks and it was popular
years ago before it get really caught on
a lot of people use this window manager
written in Haskell where you can
configure in Haskell but you don't see
like a lot of super popular software
here it's still kind of early days for
for that use case so to get Haskell you
get the Haskell platform this is
essentially like Erlang an OTP where you
have the compiler the interpreter and
robust and stable set of packages unlike
Erlang these things are all separate
they're managed separately you can
upgrade individual components all that
stuff it has a tool called cabal which
is sort of kind of like rebar but maybe
a little better and there's a central
repository for packages called hackage
and there's editor support for basically
anything you use if you don't want to
install anything there's there's FP
Haskell Center which is a web-based IDE
and cloud deployment platform for
Haskell it's kind of interesting so
Haskell syntax there's basically two big
parts there's the types and the values
just like in Erlang and so this is some
airline syntax that you're pretty
familiar with I would hope although
we're in the elixir track so maybe not
so this is the implementation of map
from lists RL you see that they're
deconstructing the list with the head in
the tail and there's this weird runtime
check for this function here just to
make sure that you get an error for
empty lists and Haskell this looks
similar not quite the same a lot less
line noise here where we check for an
empty list and if so we return an empty
list otherwise we can deconstruct a list
we use an infix colon here rather than
the pipe syntax with lists but otherwise
it's pretty familiar we have the
recursion in the tail all that stuff is
is pretty similar all pattern matching
based with multiple heads on the
function so it's not too different
it just has less syntax but once you
start adding types then our line gets a
little more unwieldy I didn't I didn't
make this up this is also from list RL
this is in OTP where you have to declare
the types for all these variables
separately and it's not inferred and
it's it's just kind of a mess if you
want to add types to everything all the
time and airline especially once you
have these functions because functions
require a lot of syntax and airline for
some reason but if you take this and you
translate it in the Haskell it's only
one more line rather than seven so all
we have to do is say that function from
A to B and functions are just an arrow
rather than fun with parentheses and all
that stuff and we take a list of a and
we return a list of B and we don't need
the runtime check for any of that stuff
because the compiler is going to
guarantee that a function is passed as
the first argument a list is the second
argument and all the types are
homogeneous and everything's good and it
gets even worse once you have even more
higher-order functions like a fold like
a write fold here kind of ugly but an
error lying it's our in Haskell it's is
relatively simple it's very easy to see
that this is a function of a a and B and
it returns a B the only weird bit here
is is down here where we have these back
ticks and that's just a way to call a
function in fix which I'll talk a little
bit more about later I didn't clean this
up this is like actually what Haskell
uses for a write fold and so declaring
types this is the error Lang syntax
where you have a sum type which you
declare several possible values error
Lang doesn't allow you to create new
types so you have to embed it in the
existing type system so these are just
atoms but in Haskell you have very
similar syntax you use data instead of
type
and you declare the name of the type and
then constructors for that type with
pipes to separate them just like an
airline and then if you want a product
type and Erlang you can't create these
but you can embed it in in tuples and
Haskell you actually create them
although you could embed it in a tuple
if you really wanted to but don't do
that and you also have record syntax and
it's almost as ugly as Airlines so it's
so this this is the record syntax it
will actually define these functions for
you but this is how you would write them
and it's almost as bad as the airline so
people hate record syntax in several
languages including Haskell and you also
have abstract data types with recursion
so this is what that looks like
in an airline if for some reason you
wanted to find your own list type so you
have either an empty list or a cons of a
value and then a list and this is what
it looks like in Haskell so basically
the same the confusing bit at first for
me was this difference between types and
constructors because in Haskell when you
define a type you're defining something
that lives in the type language on the
left side of the data here and then but
on the right side these constructors
they live in the value language so here
I've highlighted all the type names so
we have we're defining choice and
choices and we're using the choice type
with the choices constructor and of
course these type annotations are all
type language but the Constructors here
definitely possibly no way and choices
are part of the value language so you're
defining it in the type language but
then you use them in the value language
just like code so you can pattern match
on these things or you can construct
instances of those types and you can you
can annotate any expression with a type
if for some reason the inference isn't
giving you the right one you can
you can use these constructors even for
higher kind of types like for for a list
or an option type or something you're
going to have to construct it with a
value so not just the constructor itself
and you can pattern match just like in
Erlang with a case or on a function head
and this is what pattern matching looks
like in Erlang we all know this
hopefully and it looks similar in
Haskell so this is just telling us
whether the constructor is just or it's
nothing and we use the underscore two as
a wildcard to ignore the the value just
like we would in Erlang and the other
thing that I came to realize is that
Airlines pattern matching is really
quite powerful you can do things like
this you can write is equal there this a
variable is bound to more than one place
and what that's actually saying is that
these two A's are equal to each other
but you just you can't do that in
Haskell because equality isn't something
that's assumed for all types so erlangs
pattern matching is is more powerful
than Haskell because it assumes that
every type has this equality constraint
and it's built into pattern matching
whereas in Haskell you have to use
equality operators in a guard or
something to do something equivalent and
another big difference is that in
Haskell you can define your own infix or
prefix operators so the closest thing
that Airlink has is that in the airline
module you have all the operators
available as functions but it doesn't
have user-defined infix operators you
can't you can't write your own function
and use it as an infix operator but in
Haskell that happens all the time so you
can take you can take in fixed operators
like plus and you can use them in prefix
form by wrapping them in parenthesis or
you can take any arbitrary function and
then use it as infix which is commonly
used for like when it would make sense
in English like a pen door element or
something like that and not only can can
you define in fix anything anywhere
you can also define the precedence and
whether it associates to the left or the
right essentially where the parentheses
go and like before we can see all these
higher-order things are kind of a mess
in an airline because function syntax so
here we we just have two implementations
of some one of them uses an inline
lambda here and the other one uses a
reference to a function and it's kind of
heavy syntax for that and this is what a
very direct translation of that looks
like in Haskell so it's it's a little
less noisy because we don't have all of
this fun stuff anywhere we can just
reference add as a value and here the
lambda syntax is just a backslash and
then the arguments and then an arrow but
Haskell typically looks even cleaner
than that because Haskell only has
functions of one argument there are no
functions that have more than one
argument so whenever you write the type
signature of you know something that
takes an A and a B and returns to see
what you're really saying is you have a
function that takes an A and returns a
function from B to C and then when
you're applying a function like f f/a B
you're really saying F of a and and
apply B to that so you can leverage that
and so this is called edit reduction
here so when you have a variable on both
sides of an equation you can just get
rid of it because it's exactly the same
either way and so you you start doing
this and here we're gonna do a little
bit of algebra here converting that
infix to prefix which moves those
variables at the end and then so you end
up writing something much simpler in
Haskell you just say plus instead of
having to have this function of add to
two or whatever you just use the
operator wrapped in parenthesis so it it
just gets a lot shorter once you start
doing haskell ii things to it
and highschool of course also has guards
so it's kind of similar to Airlines
except you use a pipe instead of when
and Haskell has a number of built-in
types like Erlang does but of course you
can make your own popular type is unit
which is just parentheses and you use
this because you can't have functions of
no arguments so if you have some like
void return value or some void argument
you would use unit for that and you also
have a real character type not integers
and you have doubles and rationals and
and all sorts of numeric types and you
of course also have lists and tuples as
well like this is the Erlang and in
Haskell you have this this convenient
list syntax you also have the infix
operator syntax and then you can do
terrible things with mixing prefix and
in fix operators but don't do that you
can also do that with with tuples you
have like 10 comma 4 here as a tuple but
you could write that in prefix syntax as
well and so if you if you wanted to
write a function that that makes tuples
with 4 is the first element then you
could just pass this in as a function
because this is a function that takes
character and returns a tuple of four
and that character and you have strings
but strings by default are like like
Erlangen that they're just lists but
here they're lists of characters not
lists of integers and one of the most
interesting parts of Haskell is type
classes but it's hard to explain this
with an analogue to airline because
airline doesn't have anything remotely
like type classes there I mean there's
modules but that that doesn't quite
explain it and even in elixir where you
have protocols these protocols are a
global runtime registry it's not done at
compile time and it's not quite like
type classes and so this is this is like
a very stupid type class to write and
I'm going to show you
y-you don't have to do this but if you
were to define an is equal function that
would take anything that implements the
equals class and tell you whether two
instances of that class are equal or not
so we have our choice type from before
and we write all this boilerplate like
we pattern match on the definitely
constructor and if they're both that
then it's true and then all the other
cases and then if it's anything else
that it's false and then we can
implement this for lists by saying that
you know if if a is equal to B and A's
or equal to B's like the tails are equal
and then if at the end they're two empty
lists then then lists are equal but in
reality there's a built in type class
for equality of course where you use the
equals operator and you could implement
it like this but that's also stupid
because the compiler can just do this
for you so when you define a data type
and you want it to support equality you
can just say deriving EQ and and that's
it and it can also automatically derive
other type classes for you as well like
Ord to implement ordering so less than
greater than enumerations so if you
wanted to make a range of from
definitely to no way you could do that
with enumeration bounded you could say
that definitely is the minimum bound and
no way is the maximum bound and show and
read which convert to string or from
string automatically and another place
where type classes come into play is
quick check so in in quick check and
airline you have to use all these macros
to make it work so for all and this
integer thing so it's kind of like a
you're building up a dsl with these
macros but in Haskell you don't have to
write anything special because the quick
check just uses type classes so I'm just
writing a property which is just a
function from integer to boolean without
any quick check boilerplate anywhere to
be seen and it works exactly the same as
this
and I can even do this at the command
line with with a lambda or at the the
repple with a lambda so I can call quick
check with this lambda I and it takes a
list and and checks it to make sure if I
create a sequence with just that element
if that's the whole list and this this
annotation here is just I'm telling
quick check which type by one because
otherwise it would infer unit and the
other big thing huge difference between
air Lang and Haskell is side effects so
in an airline execution is strictly from
from top to bottom from inside to out
and you can sequence operations with
this comma but in Haskell you don't do
that
you you have this do syntax where you
can say you can bind variables as the
results of actions and you can just
execute actions and then at the end you
can return some value and Scala this
would be called unit and this would be a
for comprehension but this is all just
syntax sugar so if you have do and then
an action it just D sugars to that
action and then you have a your binding
a variable that it uses this bind and
then if they're just in sequence then it
uses this the then operator which is
basically if I had put a wild card there
and ignored it
so you can take things like this and
then you can reduce all of the the
boilerplate so here we have this this
bind here where we have the we're
getting the secret variable from the
read file action and if we rewrite that
with bind syntax and we just get this
which isn't too much worse and we can
get rid of the dues entirely this is
entirely d sugared here but then we have
this secret variable on both sides of
the equation and we can end up with this
where we're really just piping
the output of read file to the input of
write file so you often don't need
variables at all when you're coding
Haskell you just sort of chain things
together and this do syntax is more
general than just IO you can also do it
with lists so here here's an example of
a list comprehension in air Lang which
is an implementation of flat map and
this is what that looks like with list
comprehensions in Haskell almost the
same except one pipe intead of instead
of two basically but we can also write
that with do syntax so you can do
slightly more complicated things here
and you can spread it out nicely over
multiple lines and if we start reducing
this then we end up with with just
piping the list into the function but we
can reduce that even further if we flip
it around and then it turns out that
there's an operator just built-in that
does exactly this but you would never
find this if you're looking for flat map
you would never find this so it takes a
while to learn what these operators are
and how they work and so Haskell has a
great interactive in spirit experience
it has run Haskell which is kind of like
a script you can just evaluate any
Haskell as a script
it has a nice interactive interpreter or
you just boot it up with GHC I just like
typing RL except you can quit it with
command D it has it has nice interactive
features you can type : T and then any
expression and it will tell you what the
type of that expression is which is
awesome for for learning Haskell and
there's there's syntax called in fix
sections so I can take this plus
operator and have one on the right side
so I can make a function that adds one
to the input very simply and I can see
what the type of this is we can see it
takes anything with the num type class
given a list and returns a list and I
can even see the
the type of the bind operator here and
you can get even more information with
with Cole and I so you can get the
information for a type class I can say
okay so so I have this this num type
class here what does it do and I do : i
num and it'll tell me all of the
functions that are implemented by that
type class and it'll also tell me all of
the instances so I know
oh hey integer is a num and int is a num
and float is a num so if you're trying
to learn this stuff you just kind of
play around with it interactively to see
what all these implementations are and
of course if you import other modules
they might also implement these type
classes but these are the built-in ones
and info can also give you information
about other things and the nice thing
about it is that it'll tell you where
they're defined so if I want to go look
up the implementation of map I can just
go to to Google and search for for map
and find it in GHz base or I can search
for GHz base and just find it and it'll
also tell me the fixity of the operator
so I want to know if I need parentheses
or not it'll tell me and it will give me
information about types too so that this
is some internal garbage for what how an
integer is represented internally by the
compiler but it'll also tell me all of
the type classes that are implemented by
int so I know that InSAR bounded and I
can enumerate them and they have a
quality and they're integral and they're
ordered and all that stuff and I can
load and reload modules dynamically kind
of like you would in Erlang and I can
like execute shell functions and just do
all kinds of stuff from the G HCI
interpreter so it for a compiled
language it's actually got a really
great interactive experience and here's
another example of what IO looks like
and how you can reduce things with
Haskell so this is like an
implementation of the WC application so
I'm counting the words
in the input so here I'm just getting
all of the input and then I'm getting
the Ling
of the words and that input and then I'm
printing out this integer and then if I
get rid of the du syntax and just
convert it to bind with with a lambda
here then I get this but then I can just
compose those functions together without
any of those intermediate variables well
this couldn't it kind of looks like line
noise the first couple times but this is
all just syntax sugar so this dot is is
just composing two functions together
like if you're doing mathematics it
would be like the the circle between F
and G that's all it is and you also see
dollar signs all over the place when
you're reading high school code and the
only reason to do a dollar sign is
because you don't want to write
parentheses which seem which seems like
a ridiculous thing like why would they
write dollar signs in a set of
parentheses but that's just how they
like to do things they they're at war
with Frances parentheses and so another
weird thing about Haskell is that it's
totally pure so unlike Erlang it doesn't
just let you do random stuff all over
the place but this purity has benefits
because it means that the compiler can
just replace anything reorder operations
it doesn't imply how something has to
execute which turns out to be great for
optimizations and equational reasoning
so if I want to do like algebra on my
source code I know that algebra is
actually going to work because it's pure
and this is kind of like how GHC looks
at source code so it parses it and then
it it renames stuff so that the same
variable name isn't reused anywhere I
mean the same kind of stuff that the
airline compiler does type checks D
sugars and then it has this interesting
like optimization feedback loop here
where it can optimize the code and then
it looks at it again to see if it can
optimize it some more and it'll do that
some predefined number of times and or
until it hits a fixed point so it's able
to do all these crazy things and make it
super fast and then it'll compile down
to LLVM or one of the other backends
and so these are some of the kinds of
optimizations that it can do I'm not
going to really talk about that too much
but one of them is super cool
it's it's sort of like like a parse
transform so a rule allows a any library
so your own code you can define your own
algebra for how this library should work
so I can say for example if I map if I
map the result of a map I really want to
I really only want to traverse that list
once so I can write a rule that says
instead of mapping a map just compose
the functions together and do one map
and it turns out that that they already
wrote this rule and this is kind of why
they implemented this pragma to begin
with but it's also used for other stuff
so you have this this use case with
lists but you also have it with text and
byte string and other stuff so in in
Haskell you you don't even necessarily
need I Oh lists because you can you can
just write code that that will
automatically do the most efficient
thing with with that input and the the
nice thing about it is that it's
actually an incentive to write high
level code because if if I was trying to
optimize this by hand I might not be
able to do it because this this can
cross even module boundaries so this is
context-sensitive it's dependent on how
you use it it's not some local
optimization that the airline compiler
can do this is whole like cross program
optimization so one example is I in the
by string library a common thing to do
with strings is to split on some given
character like a newline for example so
they have this rule that says if
somebody writes code that says break and
break just takes a function so any
arbitrary function that works on given a
word aid or a chair as input and if if
it happens to be in this form where
they're using the Equality operator
then I'm going to rewrite it to this
like hand-tuned break bite function so
the user just gets to put arbitrary
functions in there and and the library
can say okay if the function looks like
this then replace it with something
faster so I don't have to have an API
that's huge with break on break on a
function or or break on exactly this
thing or break on the the range of this
thing to this thing they can just write
one of these rules so an example of that
is so if I wrote break on new lines then
this rule would eventually just turn it
into this automatically without me
having to do anything or think about
optimizations it allows all all the
optimization effort to be done in the
libraries you don't have to do it
outside in your code and Haskell is also
lazy which changes basically everything
instead of instead of like the very
strict model where you have to evaluate
everything from the inside out
Haskell evaluates everything from the
outside in which takes a while to get
used to but it's interesting because
once you're doing things lazily you
don't need special forms for a control
flow you want to write your own if just
do it it just works because you don't
have to short-circuit because there's
nothing the short-circuit because
nothing evaluates until it needs to be
evaluated it also allows you to do weird
things with infinite or cyclic data
structures you can have just infinite
lists or functions that operate on
infinite lists you don't have to even
think about terminating them because
it's context-sensitive on how that's
going to get evaluated and it can also
skip on used computation so if for
example I sort a list if I want the
minimum of a list I can sort it and get
the first element and that will execute
in linear time
and so the only thing that actually
forces evaluation is pattern matching so
here here's an example of of how haskell
would evaluate a thing so here I'm
printing I'm going to end up printing
the number two but I'm doing it in a
really weird way I'm mapping times two
to all of the integers and I'm getting
the head of that and then I'm printing
it so then if I start evaluating that
outside in so I have this print
statement or this print print action and
so print is just puts put string line of
show of the input okay so I replace that
with show and then the next thing show
needs to evaluate its argument so I have
to evaluate the head and then head needs
to evaluate its argument the map and the
map needs to evaluate its list argument
and then I have this one dot dot syntax
which just D sugars into this enum from
and then I take this enum from and I
need to evaluate that because map is
pattern matching on it to see if it's an
empty list or not so then I evaluate
that enum from is just n and then enum
from the successor of n so that so now I
have I have a list with at least one
element in it and then map evaluates
that so it takes this one and multiplies
it by two and then gets it hits its
recursive case and then I evaluate head
it pattern matches on on the list and
takes the element which just is one
times two and then eventually show needs
to evaluate that number to figure out
how to get the string representation of
it and so so it evaluates to two and
then it shows the string to it prints
that out so given like weird stupid
infinite inputs it's able to do
something sensible here in a relatively
small number of steps and you know most
of this is going to happen at compile
time due to in
lining and so these are like what the
short-circuiting stuff looks like so the
the and operator
it's just case a of true then B
otherwise false right like you don't
need special forms for any of this stuff
you can just implement them in the
language as functions pattern matching
is is really the only primitive here you
can also utilize the the laziness to
reuse results like this is actually a
relatively efficient implementation of
the Fibonacci sequence by taking the
sequence and zipping it with itself just
adding it each way and it reuses all
those computations as it goes where if I
want if I want to infinitely cycle over
some list I can just implement it as the
list appended to the recursive case and
and you can iterate like if I want to
define all of the powers of two I could
iterate with with a number of times or
with with times two and it would just
give me all the powers of two as a list
and so I can write this this elegant
code without worrying too much about
what the context it'll be used in
because it won't have to evaluate
everything just whatever the context
needs and so the the types allow you to
enforce constraints at compile time so
here I'm trying to get the head of true
which isn't a list so it's gonna tell me
okay so I'm expecting a list but you
gave me a boolean so so alright so and
then I I typed something else and and if
I type heads of true well that's not
even a function that's implemented
anywhere the compiler is actually pretty
nice to you and it says okay so there's
nothing in scope called heads but maybe
you meant reads or head it'll actually
look for like other functions of similar
type with with a short edit distance so
it's not like you know it's Scala or C++
where it'll give you like some crazy
error message all
time manukan you can do bad things in
the type system because it's
turing-complete
like you can say let x equals x and x
which which defines x in terms of itself
and that just doesn't ever finish
computing anything you can you can write
in complete pattern matches and it'll
give you exceptions for that or trying
to get the head of an empty list you can
do all sorts of stupid things that they
can't totally protect you against
yourself and these type classes there
there's a lot of built-in ones like
functor and equals which we talked about
let's see we'll skip over some of that
stuff and so like the weird words that
you hear about all the time there's
there's monoid and functor and
applicative and and monde ad so mono ads
are just anything that has an identity
and an associative operation so you
could have a a type sum which would the
the identity would be zero because if
you add 0 to anything that's the
identity and the associative operator
operation would be addition or you could
have product which which you would use
multiplication as the associative type
and a super common mono it would be
lists so the identity is is the empty
list and the associative operation is
appending lists and then there's there's
functor which is anything that can be
mapped over which lists or another
common example an applicative is
anything that can be mapped over but you
can put the function in the same thing
and Amada is is just slightly less
specific and these are what those
implementations look like i'm not going
to go into it and you can end up
utilizing all these concepts to come up
with some pretty cool libraries like
this this is an example of using auto
parsec which is a parser Combinator
library so instead of having to write a
separate grammar file you can implement
it all in Haskell syntax so this this is
a
relatively complete parser for most of
json syntax so we define a data type
with an array or an object which is key
value pairs or strings so it doesn't
support numbers and it doesn't do all
the escapes for Strings but I can say
that Jason is going to be either a
parsing text parsing an object parsing
an array I can say the string is a
double quote followed by many string
chunks and then it's going to end with a
double quote and then a string chunk is
either something that's not like
characters that are not back slashes or
a single backslash followed by something
else or a a double backslash and then
like if I'm if I'm parsing an object I'm
looking for the brace and then I'm
looking for pairs separated by comma and
so a pair is just a string and then a
colon and then some other JSON object so
it it looks like line noise at first but
once you once you get used to it
you can very quickly build these parsers
and they're all composable so if I want
to just put this in some other grammar I
can just do it which is hard to do with
with some other frameworks and it has
foreign function interface that you can
talk to see it is parallel programming
so if you're doing numerix on big arrays
you can you can just write the code and
there's efficient libraries that will
run it multi-core like this this will
rotate an image by 180 degrees by
permuting the indices of the input
matrix and it will do it
in in parallel on multiple cores and
then you also have the concurrency so
you can do that efficiently like airline
can because
it's less than two kilobytes per unit of
concurrency here and so why wouldn't use
Haskell well there-there's kind of
intimidating all this new terminology
all this stuff if you're doing things
that require a lot of mutable state that
takes you know some more effort
especially to get used to it and this
laziness is a double-edged sword so it
allows you to write very efficient code
but it also prevents you from reasoning
about it without knowing what context
it's used in and once you get used to it
these aren't really so problematic but
it's differently reasons not to use it
and this is an example of some of the
terminology it's kind of a joke but not
really my dad is just a mano eight in
the category of endo factors what's the
problem
and there's a lot of overloaded words
like return doesn't mean what you think
it means and so like this is an example
of where laziness can bite you like the
this may not actually compile to
something efficient even though it looks
like it should and then you would
rewrite that to go something like this
and I'm not going to go too much into
that but there's also a lot of nice
libraries you have all of your HTTP
servers and templating libraries all
that kind of stuff of course you can't
have just one need a whole boatload of
them these are just the popular ones
there's of course more there there are
great tools for publishing and making
documentation so haddock is kind of like
a doc except better
there's diagrams which allows you to
make vector graphics with Haskell code
Hackel which is like Jekyll where you
can like statically generate a sight pan
doc which is your markup Swiss Army
knife there's great libraries for
parsing there's good developer tools
like H lint can read your code and give
you suggestions for for like if you
should refactor something there's these
great tools Google and hi you which are
search engines you can actually search
by type so if you're looking for
something that takes takes a string and
returns a list of strings then then
it'll tell you all of those functions in
in the standard library
there's even weird things like that
will you give it a type and then it'll
automatically generate code that works
with that type I don't think that's
practical but it's fun and you there's
also weird stuff like like this tidal
thing which is a DSL for live coding
music patterns it's kind of fun if you
google for that and then you have all
these parallel distributed libraries
you've got repo which is a
high-performance numerix library that
runs multi-core you've got accelerate
which is almost the same thing except it
runs on the GPU and you have cloud
Haskell which is kind of like air lying
but not quite there yet and there's
great testing tools like quick check
obviously but also other things like
unit testing or program coverage you
know you have even some like metrics
things and you have got great
benchmarking tools they can give you
like very statistically accurate
information about timing for for your
code and if you're interested to learn
more here's a whole bunch of links but
really you should just look at the
slides because it'll be easier than
trying to write it down thank you
got seconds for questions that's a
hundred pages behind here so so the
practical consequence was that they had
to essentially start from scratch and do
it which whichever way that they wanted
to I think yeah Miranda was a commercial
product and a Turner didn't want to make
it open source they ended up with the
syntax that was very much inspired by
Miranda but they ended up coming to some
different conclusions like type classes
were something original with Haskell
that were not in Miranda but if you look
at some Miranda code it's going to look
very similar to Haskell
okay so when when would Haskell be
strategically used in enterprise so in
in the cases that I've seen it use it's
it's really sort of at the the low
platform level like either either as
like linting tools or like tools that
verify the correctness of your other
software or also just like secret sauce
platforms like trading platforms or
Facebook uses it too as a spam detection
engine that does all these like
asynchronous business rule things to
talk to all their other systems so you
know kind of sort of around the same
realms as err Lang but but not so much
the systems that run forever and don't
stop and need to be hot code loaded it's
not quite there yet but it's something
they're working on so I wouldn't
wholeheartedly recommend that you go use
it an enterprise for everything today
but it's definitely a very interesting
tool and if you're doing something like
parsing it can get you a long way
really quickly where some other language
it might have a lot more boilerplate or
a lot less flexibility
so how does Haskell's numerix benchmark
so the the benchmarking for first-rate
numerix is is quite good like with you
know sea level or better of course it
depends on which libraries you're using
like some of the libraries for for
certain kinds of code can do better than
then other languages it really depends
on the benchmark and this stuff changes
all the time these things are relatively
new to Haskell like you know last eight
years or so and they're they're just
getting to the point to where the the
benchmarks are something really
important to them so you know like any
benchmark you know on some of them
they're gonna look great in others
they're not gonna look great so the the
GPU ones in particular are looking
pretty good because you don't have to
know as much about how to write good
code for a GPU like with regard to to
you know the way that the banks work and
the addressing and like having to change
the stride and stuff like that you you
can do less of that because those rules
are built-in whereas if you were just
writing CUDA code you'd have a hell of a
time if you didn't know exactly how the
GPU worked
you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>