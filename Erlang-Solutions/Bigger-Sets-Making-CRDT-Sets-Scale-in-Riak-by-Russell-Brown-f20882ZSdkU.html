<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Big(ger) Sets: Making CRDT Sets Scale in Riak by Russell Brown | Coder Coacher - Coaching Coders</title><meta content="Big(ger) Sets: Making CRDT Sets Scale in Riak by Russell Brown - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Big(ger) Sets: Making CRDT Sets Scale in Riak by Russell Brown</b></h2><h5 class="post__date">2016-09-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/f20882ZSdkU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">well that's the first slide done I was
going to tell you who I was and where I
work so I I woke up I show as the as
Bruce s and we've been active in the
community for maybe nearly ten years
eight years I've worked a bachelor for
about five of those and I've always
wanted to come to to this conference and
I knew the conference in the past but I
sent some very capable people and
they've done lots of talks but they've
all left now so you've got me I've been
working on react for about five years
but we've recently rebranded to react kV
so it's not really a react talk there's
some react in this talk but I just
wanted to make you aware of the rebrand
this is our distributed fault tolerant
key-value database so if you if you want
to buy one of these we've got to stand
out there you can buy one part of the
rebrand is we have lots of databases now
we have this react TS database so
there's a there's a demo out there in
this if you want to try that you can
race the sky electrics and learn about
time series and I have to show this
slide as well because part of I'm going
to talk about has been funded by the
European Union a research project
costing free and there are there are
other talks here today and yesterday
from this this project okay so that sort
of marketing stuff are the way get on
the talk it's it kind of for short talks
so I'm gonna have four sections of a
talk I'm gonna do the what RC re T's so
CLE T's I've been looking on them since
about 2011 so you know we're all kind of
mired in our own context so I don't know
how much other people know so show of
hands if you've heard of what a cou
tears Wow okay
you've met you've made one oh you've
used them anyone all right okay so that
first bit I'm just going to not going to
do the whole it's a joint semi-lattice
blah blah blah and show you how to
diagram so I'm going to just explain the
problem they solve so you know where CID
T's fit into your toolkit and I'm gonna
do a walk through in section 2 of the
design of a general purpose CRE tea set
so I set that everyone can use and
you're seeing lots of places now and I'm
going to talk about how we shipped that
back in 2014 as part of react including
some shortcomings we shipped and then
finally at the end I'll get onto the new
work we're doing
those shortcomings so I get straight on
with why you know why CI duties exist
and what you've all heard of them I'm
not gonna do the cap diagram I'm not
gonna do the triangle with the CA P pick
to that kind of thing just let's say
there are a bunch of different results
that show there is a fundamental
trade-off in multi-core and distributed
computing between you know the desirable
properties low latency and availability
and the desirable property a strong
consistency you can't always have them
all I'm not going to tell you when you
should pick which which is right and
which is wrong just going to say that
there exists a trade-off and some people
have taken it for commercial reasons the
most famous being in 2007 Amazon
presented this paper
SOS P and it describes their scalable
eventually consistent fault tolerant key
value database which we kind of based
ours on so react is a fairly faithful
implementation of this dinah exists to
solve a commercial problem so it uses
lots of computer science research it
doesn't really do any new research it
just applies lots of existing theory to
solve a commercial problem I'm gonna
summarize that is you should always be
able to add something to your cart I
mean it's more complex than that but
essentially if you're shopping on Amazon
you should always be able to add
something to your cart that's what they
want you to do so Amazon's a multi node
distributed database that has multiple
replicas of key values with many clients
but we're gonna for this talk I'm going
to simplify that down and I'm just going
to use two replicas one key so doing one
data item because the key value stores
your keys and values are independent so
what matters for one matters for the
mall and a single client that's all
we're going to use to model some
concurrency show a problem and then
solve that problem we see oddities so
dynamo and react both have this a very
simple key value interface you you
assign a primary key to something so I'm
gonna gonna use shopping carts for the
first part of this talk so you assign a
primary key you know Russell's cart you
you you call a get operation to fetch
that data object the application itself
then mutates the object and stores it
back in the database with the port
operation and if you were and then the
net
database notes talk to each other with
asynchronous replication to to pass
information around and if you if you
really want to always be able to add
something to your cart even if your
database nodes can't talk to each other
you still want to be able to put things
in so if they can't communicate if
you've got a pair of replicas you wanna
be able to write to them both
independently and just you know deal
with it later when you come to checkout
maybe read from all the nodes and get it
and find out what the current value is
so here's a sequence of operations with
a single client operating in sequence in
temporal time so there's no you wouldn't
think any concurrency here but but there
is because we allow our application to
read in the past it's always allowed to
read and write because we want to be
always available to add things to our
cart so I'm shopping on Amazon I I go to
some other store probably at some point
if I keep saying their name and I search
for headphones I put them in my cart and
I store my cart on a and then I continue
searching and for some reason I don't
download my car from a I download it
from B and B hasn't yet heard about my
addition to a that shouldn't stop us
from shopping just because some message
hasn't reached some node I should still
be announcer to shop so I get an empty
car I read in the past I add something
to that car and I store it so this is
the the sort of diagram that it's in the
dynamo paper to illustrate what just
happened you've got these logical clocks
which I'm not gonna go into that capture
a relationship have happens before and
we've hit a point here where we've kind
of diverged or we forked we've got two
copies of our carts on two different
nodes and this is great because we've
got like low latency and high
availability and opportunity replication
and your business is really happy and
then you're an application developer
into your job to now write their
checkout code we read these cards and
what you do what what what you do at
this point so in the paper they've got
two different advices for you you can
use time stamp based reconciliation
which means every time you write the
cards you update some time stamp to say
you know when it was last updated and
when you come to checkout you just pick
the highest one
but that's not gonna work for us in this
case because we want to buy everything
we put in our car not just whatever's in
the last available cart you know we do
that reconciliation we only get a
hairdryer
so in the paper they suggest you can use
business logic or semantic
reconciliation which is like the
semantics of the domain so you think of
a shopping cart they say well you can
imagine a shopping cart as a set and so
if you have multiple copies of a car
it's like multiple sets and how do you
make one set from any sets well you use
set Union so if you do that then we have
the shopping cart we wanted and we can
check out we buy everything in Amazon's
happy and that's what happens here you
then hit this point and that's called
convergence so we've seen divergence and
we've seen convergence which is great
except you might change your mind about
something I'm going to take it out of
your cards so let's go back to our
diagram and walk through the same
sequence
I read my converge car from a take the
headphones out I don't want them anymore
and then I decide I want to add to
something else so I read my cart from B
so I read in the past B hasn't seen the
message from a yet that you know hasn't
seen the change and I add something and
I store that and then when we come to do
a read we've got a pair of divergent
carts again and if we run set Union this
time we've we've bought the headphones
after all because that you know Union
just takes the contents of both and
smashes them together so this isn't news
to today developers at Amazon they know
about this you know they mention it in
the paper themselves they say if you do
this there now Add to Cart operation is
ever lost so you always can buy what you
want but you might sometimes that said
when you buy something you don't want
because deleted items can resurface so
that's the problem we're looking at that
sir that's that's an encapsulation of
the problem one example of the kind of
problem which is how do you how do you
write code to to converge those
divergent replicas in a way that that's
correct
apparently it's really hard so Google
and have lots of really great engineers
and they decided it was such a hard
problem they would write a system that
didn't allow this they have a global
spanning CP system that doesn't allow
you to have these diverging replicas
because it's too hard and not worth the
performance gains so that's the kind of
challenge that we're looking at
for engineers another example of how
hard it is is from one of our customers
who said that moving from sequel to no
sequel specifically to react one of
their biggest challenges were going to
be writing code to handle this
converging-diverging replicas so that
problem is where CRTs come in so CLE
tees are data types that converge
automatically so rather than having to
do semantic or business reconciliation
logic the data types I already have that
they're abstractions that will come very
automatically for you so you can think
of them as off-the-shelf merge functions
and they are literally data types so
like I say it's not it's not business
logic it's it's abstractions you're used
to using you know like map sets integers
boolean as those kind of data types that
you have come to as an application
developer but they converge
automatically and everyone probably
knows the name by now and the joke about
the name how it's converging or
commutative or conflict-free what the C
stands for many things but they're
replicated data types so hopefully
that's enough to motivate you know why
they you need to exist because you want
to have these high available systems but
you don't want to pay the cost of
writing code to merge divergent replicas
and I'm going to then excuse me look at
how we can make a CR DT set that we
could have used for that shopping cart
that doesn't have that problem of the
reappearing delete so actually not going
to do shopping carts in this section I'm
going to use I'm going to pretend that
my friend lists or friend lists on
social networks are sets instead for a
bit so sets are interesting because we
can because they are fairly fundamental
and we can get a long way in a short
time explaining how they work but
they're also valuable for the same
customer who had trouble with the merge
function says that they can model a fair
number of their use cases in sets alone
so that you know these can save money
engineering time just by using
off-the-shelf oddities so let's look
through the design of a set so that
paper I showed you a second ago that
lists a bunch of different set
implementations they're not all valuable
only only really one of them is
generally useful but we can think of
them as steps
on the way to the generally useful set
so the first one is something called
aggro only set here's my divergent
replicas again and if we're only allowed
to add things to the set then set union
is fine we can use that to turn this
pair of sets deterministically into a
single set and that's that simple but we
can't take anything out we can't use
this for our shopping cart or we can't
use it for a social network or we might
fall out with people so the next set in
the paper is called a two-phase set and
it's made of a pair of those growingly
sets so you can add friends and put them
in the outside of the set and you can
take them out and put them in the remove
side it's like a like tombstones but
that's all you can do so if we look at
this structure we see that the only
friend I have the logical friend in my
set of friends is that if the friend who
hasn't been removed so if you're in the
ad side but not the remove sight then
then you're in the set and this is kind
of cool because the value is different
to the structure so most see oddities
are like this they have a different
structure to the actual logical value so
we can take things out now so but we
can't release this on our shopping cart
yet because you know you can't change
your mind if I if I read surely I decide
that you know actually I do like her
then it doesn't make any difference in
this set because there's a tombstone
there saying she's not in the set and
you know we take the disjoint of these
two sets they decide who's in the set so
we want a generally useful set this
isn't it yet I'm going to look at
something else in the paper called a
unique identifier set now I have no idea
of a use case for this I bought too much
beer at system Bala gate so if you want
if you can come up with a use case a
genuine use case for a unique identifier
set by the end of the talk tell me I'll
give you a beer because I can't think of
one but we do use it in a second to make
a generally useful set you know it's a
compositional element so here's a pair
of unique identifier sets they look just
like G sets except we've got I've used
integers here but these have to be
globally unique tags so in most
implementations I've seen that naive
early cod2 implementations these were
something like uu IDs great big long
strings
and so when we Union these together we
can see that this friend Shelley has
been bought has been added twice to the
set of friends because got two unique
tags so I'm not I'm not sure what value
that is on its own but we can use it to
compose something called the observe
remove set or what these I think in most
literature I've seen recently is called
the add win set so that looks like this
a pair of those unique identifier sets
and I'll just walk through how this
works and this is our first generally
useful general-purpose you can use it
for anywhere you need to use a set c OTT
set so I've got on one replica I've
added my friends and I've removed the
mauck's I don't like them anymore and on
the other replicas I've added a new
friend and I've changed my mind about
Shelley ivory added her so when I want
to merge these two together I get this
structure and the membership of the set
is any element that has a tag in the
outset that doesn't have a tag in the
remove scent so in this case it surely
has been removed at tag one but not a
tag fun Eve so she's still in a set and
this trick is called observe remove
that's why the sets called an O are set
and it means that replica a is only
allowed to remove the tags that it's
that he's got a copy of that is seen or
observed that's that's where the name
comes from and it gives us a semantics
of add wins so we see we've concurrently
added and removed this one friend but
the add has won over the remove and this
is our this is our generally useful set
that you can if you want to model
anything that you can you know if you
can pretend that shopping carts assets
you can use this if you pretend to
friend lists a set you can use this but
I mean is it good enough to ship in a
product and it's and it's not really
because you have to keep information
forever you have to keep these tags
around forever the tombstones unless you
have some kind of synchronization method
to get rid of them and so if you add a
thousand friends and remove them all the
empty set logically takes as much space
as the set with a thousand friends in so
although this is like the behavior is
good you know
like how it behaves we probably can't as
as you know engineers ship a product
with this inside it and then say to
people under your disk use fourth but
then the same academics who came up with
all those designs then come up with an
optimized version a year later in 2012
and we gave this the catchy name
observed removed set without tombstones
or or SWAT although I think more
recently literature I've seen it
referred to as the optimized add wind
set which is it's a much it better name
and considering this exists and an
optimized one isn't necessary anymore we
should just call this the add wind set
going forward so I'm going to show you
how this works and when you've seen how
this works you know as much as all the
people who are implementing CID T's now
so it's we need to know a little bit
about version vectors we're not going to
do a whole kind of version vectors
tutorial I'm just going to tell you how
version vectors help for this structure
so we had a pair of replicas we're gonna
call them a and B and in our version
vector these replicas have to be like
globally unique names so we have a and B
are their unique names forever and as
far as the structure goes the version
vector is just a list of two tuples the
first element is the the identifier of
that replica you know a and B and the
second is how many times it's added
something to the set so a added two
things B's added one thing so it's a
really compact summary of all the action
of those two actors and if we have if
our actors are globally unique and if
they generate a sequence of increasing
integers we can use that pair as a tag
as the unique tag for these you know in
the unique element set we have to tag
everything uniquely these are very
compact unique tags and we're able to
summarize them in the version vector so
we have a very compact summary so let's
see how this works
replica a had a friend and now I have a
version better at the top here as well
summarizing all the events that a has
done I send that to replicate it over to
replica B and it's version vector
summarizes everything it's seen now it's
seen this tag a one add some friends on
B they all get tagged and we have a
summary in the version back to saying
I've you know be done three actions
there's over 2a and it's version pet 2
reflects what it's seen so far nothing
exciting let's let's let's get some
divergence so it's removed film all
together and add a new friend on each
side Ana and John and the thing now is
that with this structure we can just we
can just drop the data we don't have to
keep that tag around or that information
around we just remove it and when it
comes to merging we just look at the
tags so tag a1 is in both we're going to
keep that B ones in both we're going to
keep it
B twos only on one side so how do we
decide if we keep it or throw it away we
look at the tag and we compare it to the
version vector so this version vector B
3 has definitely seen tag b2 so we know
that we mean to remove film so we just
we just drop him b3 is the same it's on
both sides then we get to tag a 2 it's
only on a is it on a because be removed
it or because B hasn't seen it and you
do the same trick we use the version
vector we see that a 1 is less than a 2
B's never seen this value so it should
be in the set and the same with John and
so we end up with a set that size-wise
is about the same size as the number of
things that are in the set and we have
this nice compact version back that
represents all the tags we've seen over
time so this is the this is the
general-purpose CR DT set that you'll
see in what's your product called yeah
so you got I think the user over my
sauce I know that Phoenix has this for
its presence sharing presence
information react ships it there's a
bunch of products that use this so this
is the general-purpose
one that people are using now I've got
the semantics of add winds via this
trick of observe remove and hopefully
after seeing that you should be able to
write your own quite easily because it's
a fairly simple implementation so we
obviously we have with react we have
customers you have that divergent
replicas problem and we've seen that the
academics are caught with this nice
solution to it so we decided that we
could we
could ship this as a as a solution for
our for our customers so you know we
could just say here's a paper you read
this paper and you can write CRT T's and
you haven't got a problem diverging
replicas anymore or we could do what I
think most people probably do and we
thought well we'll write a library we'll
take these these data types has defined
in this paper and we'll implement them
I'm wanting to talk about this one I'm
going to talk about the set only so
we've got this module you know react DT
or SWAT I wish we'd gone with a twin set
with a version vector and some entries
and all that so we take the paper away
from the customers and say here here's a
library we've solved your problem for
you you've got divergent replicas just
use this I don't that's good enough
because if we have these idea of version
if we have version vectors and actors oh
so this is the database this is a
something that one of our colleagues
Angel Sanchez made I'm going to switch
to this from now onwards it's nicer if
we have many many clients we have very
very big version vectors right so we
ended my end up with metadata greater
than our data so that's not a great idea
so maybe given the library to clients
isn't very good but worse than that is
we if we give that their clients just a
library we take something away so here I
am you know wanting to add friends to my
friend list it's currently empty and I
download it you has a client I pull the
friend list back and I generates a
unique tag the first tag for this set
client one tag one and I had a friend
but then I read in the past on B so I
get the empty set and I generate a
unique tag for my friend Bob now you see
what's wrong here right these aren't
unique tags anymore because I've read in
the past because I'm trusting a database
to remember for me I have to be able to
read my own right from the database so
I've put a consistency constraint or
requirement on the client if I give them
a CITT library and say here you just use
the library and you'll be fine well you
won't be fine you'll have to be able to
read your own rights and that's the cost
so I take the library away you can't
have that we're gonna put the library
inside our database instead so we're
gonna you know
we're not gonna say you have to use
react DT we'll say we'll put react DT
inside react and we've already got
replicas and they're called V nodes and
they're the actors in the system so
we'll use those so now we have to just
answer the question of how that how how
you use this library if it's inside
react so if you remember for a dynamo
and react early on I said the API is
really simple you do a get to get to the
value the application mutates it and
then there's a put to store it and
that's that's probably okay for
something like a shopping cart because
they're kind of small and maybe sure
lived but what about what about your
friends on a social network or my
friends that's a quite a small list but
the suck list you know looks got 78
million it keeps changing actually when
I first started this talk it was 76
movies got 78 million friends now
probably more already if it does make a
lot of sense to to you know do get
Zuke's friends bring it down to the
application add a new friend to it and
then send it back to the server that's a
very expensive operation so we thought
maybe we should give an operational API
instead so the clients can just tell the
database you know add this friend add
that friend and a database server can
take care of inserting them into the set
and replicating so that that kind of
works for abs but it doesn't really work
for removes because of this trick we
have for deciding what's safe to remove
if you if you can only remove what
you've observed then you've got to do
some kind of read and so observe
something in order to then say remove
these tags right so we're kind of
forcing you to read if you want to
remove so that's what we shipped in 2014
you know we took we wake up customs with
this problem we took the academic paper
we made a library of it and we wrapped
it with a basic operations API with this
additional context for removes we've got
V nodes or you know the react replicas
nodes as the actors so the clients act
at a distance and we have forced a
replication so we have set react is a
key value store we already have
something we store in react it's called
a react object it has a version vector3
tectum divergence so we just stuck us
inside the react object and then we take
our react object and we and we stick it
inside a key value store and this is
kind of key to what I'm talking about is
so each key maps to a set so if you've
got looks friends you've got a keys ox
friends and you've got a set an object
on disk my shopping cart you've got a
set on disk and so on so as a visual
mnemonic for this design it's kind of
like this you've got a set inside an
object inside a key value store let's
see how that behaves you tell react I
want to add her friend to looks list so
the data bus node it like coughs up
sucks friends from a storage organ there
and it pulls out the version back to
increments it to tag and get you know
tag that new element put it back in the
set serialize it swallow it back down
again send it across the network
two of the replicas who will cough up
their copy run that merge function to
get a single set and store it on disk
problem just a bit
this one key to one set mapping means
we've got you know poor write speed and
you can hopefully following through you
can see obviously where that comes from
in order to change the set we have to
read and write the whole set and that's
expensive
so rather having an intuition about it
here's a graph X is cardinality y is
time so the bigger the set is the longer
it takes to add an element and that's
not really intuitive if you've used the
set before that's not how they behave
typically so it's not really good enough
here's a benchmark you don't have to be
able to read the figures really but what
matters is that as the set grows that
green line goes down and the red lines
go up and that's not really the kind of
performance that our customers like and
there's another problem in there is a
large object databases exist for a
reason there's a difference between a
large object store on a general database
and react is a general database and it
has a kind of limit on the size of a
single object and that tends to be a
megabyte and it's gonna be hard to fit
78 million Joker bug friends in a single
Mac so
we try and catches up now we've seen a
problem we've seen an academic solution
to the problem and we've seen a attempt
to solve that by shipping an AP a
library with an API into in a database
and now we've seen the problem with that
and we know that what we shipped is
reasonably valuable because you've got
people using it and people are using and
telling us this is what's wrong so we
know what's wrong because it's because
it's valuable it's just not valuable
enough and this gives us a very very
clear sort of mandate on what to work on
next or what we're working on now you
know people are happy with the behavior
they like the high availability but they
just want to be able to they don't want
they don't want to pay the latency cost
of that every time I change a set read
it and write it and they want to store
more information in set so it's a really
clear design brief and so this is like
the kind of work we've got not much time
left but it we already need it because
it's a it's a really simple thing we've
done in order to enable to give us you
know these to solve these aims so the
name big set is terrible I think it was
originally kind of a joke but at the
moment it's stuck I'm hoping we have
product people to give it a better name
when we come to releasing it and this is
the whole trick of the design is that
rather than thinking in terms of
abstraction a library that you expose
over an API we've kind of taken what
we've learnt about CRD T's and built
them into the database thinking about
the things that matter most in a
database and that's I oh we don't want
to burn I up some stuff we don't need to
so we want to keep the the i/o down so
we're using a key value store called
level DB it's the sorted string table
key value store we're going to use the
sorted nature of it later but we have
expertise a bar show in this product so
that's one of the main reasons we use it
and what we've done essentially is take
that that module that react DT or SWAT
and break it out so whereas before we
had a key that mapped to a wiki which
described a set the map to the set now
everything that's in
set structure gets its own Qian level so
there's a version vector that gets a key
each tag for these tagged elements they
all get a key so it sounds like a bit of
a trade-off of space for time so you
know we're going to take up more space
but leveldb has great compression and it
also factors out common prefixes so we
don't even pay a great deal more for
space and if you'd all gasp now no okay
so this is what happens when you run
that same workload on big set
you know X's cardinality going why is
time and although it's it it's a lot
faster what really matters is the trend
is that we're seeing that even when the
sets grow large it doesn't cost any more
now to add and remove an element from
the set so that benchmark we run you
know run it again and this is the the
behavior we get we got that flat line
now so the latency stays constant and
the throughput stays constant even as
the set to grow and they seem
side-by-side so so how does that small
change you know reap those those
benefits if we walk through up our our
our use case again let's add a friend to
Luke's friend list so we sell react you
know actually to my friend list now what
we have to cough up from the storage
node there is the version vector and
that's it regardless of the size of the
set we just need the version vector we
increment it to get a new tag we add
that new tag to the new element and
because leveldb allows us to atomically
store multiple keys we store those two
together atomically and because of the
sorted nature of level DB that new
friend will find its way to the right
place in the set on disk and then we
take advantage of some more academic
work as I mentioned earlier the we used
full state replication before but the
same academic team come at the idea of
Delta replication where you just
replicate the changes in the CID T and
we do that for big set so we just send
over the difference this new tag this
new element and at the replicas same
thing gone the wrong way
all you have to do is is you know buff
up that version vector if you've already
seen this tag if the version vector says
you've seen it you're done there's no
more work if you haven't seen it then
you add the information and you store it
down and that's it
so that's that's all we've had to do to
get that massive performance improvement
it's a pretty easy really and pretty
nice so when I first we've got all these
complexities now so it's not that's not
really it obviously because there's time
left and I didn't go that fast so I'm
not gonna talk about each of these
because there isn't time for all of them
but these are all thick so these are all
complexes that have come up from this
design reads a more complex diversion
vectors more complex we have these
processes inside react that are much
more complex and it's all come from
breaking up mapping up from before one
key to one object now we represent an
object across many keys so before these
operations occurred on a single key
which made them simple and now they have
to go over composite the set of keys
which makes them complex and we look at
one only one part of it and look at
reads because I'm sure there must be
something in this room who as I was
explaining that design would have gone
what you're really gonna suck now
because that's that my colleague seven I
first taught in the designer said you're
really gonna suck and they were right so
this is a graph showing the green line
is reading 100 K element set off react
and the red is off big set and as a
delta it was a lot slower it was so slow
we could only get four sets a second or
five sets a second off disk so half a
million keys a second off disk so look
at why and look what we did to fix it
this is kind of logically what a big set
looks like on disk we've got a version
vector at the top you've got a set of
elements you know ordered and when we
want to read it what we do is we read
that version back to and then we iterate
over each of those elements and we
transform it into that adwin set that
you're so familiar with now from
familiar on in this in this talk and you
know it's just classic death by a
thousand cuts right where C++ is a level
DB it iterates us seeks to a key reads
it hands it to Alang Alang you know fold
accumulates it runs some logic says
thank you can have another and that will
go here have
and so we go over and over again over a
hundred thousand elements or look 78
million friends and that takes a long
time so in retrospect the obvious answer
an engineer from Bosch accord Angel
Sanchez did this work is we just buffer
up we fold over a large chunk of keys we
had to write over a chunk of keys into a
buffer and hand those over to alone and
we continue then iterating in C++ and so
we've got the next chunk ready for
Erlang when it's processed those keys
and just do it that way instead and that
save does a huge amount of time that
gave us a huge performance increase the
next major change we had to make was
just to stop encoding and decoding our
keys so we need the keys to be sorted we
want all the keys for the same set to be
together
we need the version vector for the set
to be the first thing for the set and
then we go through the elements in order
and we were using these work these are
aligned terms and we're storing them
externally sorted so we used the library
for that and again it's death by a
thousand cuts when you're when you're
deserializing millions of keys then
every time you have to deserialize it
cost you time so we just used some we
were lucky enough to have some level DB
expertise on staff and they said you
don't need to encode just use null
terminated strings as fields and it will
sort correctly and it did and got as
another huge performance increase so
reading a big set I'm going to skip
through these quite quickly you have
client asking to read the set an FSM
starts up contacts a bunch of replicas
you know in this example - and they all
stream these blocks of keys off disk and
because they're ordered we can take
block one from both replicas and they
represent an equivalent subset of the CR
DT and so we can do a merge that merge
we looked at earlier on we can perform
that on a subset so we can incremental
emerge a very large set we don't have to
read the whole set into memory we can
just read the first hundred thousand
elements merge those send them down to
the client who can start processing or
pagination and and so we go
and that got as read performance that
was very very close to saccharine react
sister
a slight penalty you stuff to pay a
little bit more to do reads this way but
you know what why are we reading the
whole set if we really have got this
massive set why are we just querying it
and the answer is because you have to do
right with react you have to do there's
no choice if you want to ask the set
anything you've got to read the whole
set so this design means you can have
queries you can have subset queries
range queries pagination that kind of
thing but look at one query that's
important and it's a membership query so
if you if you remember back this trick
we have for correctness this observe
remove trick you have to see something
in order to be able to remove it and now
it in react forces you to read the whole
set because you want to remove one
element and if you're talking about the
hooks friend list that's really wasteful
so with this design you can read a
single element you can read a single
member from the set which gives us the
cheap membership check so we can have we
can it makes it very easy for the client
to be correct and always observed before
before removing so how does that work
but if you're a client you are you say -
to the to the system you know is is Bob
a member of the set and the FSM sends
out to the replicas the question read
Bob and we just seek we read the clock
the version vector from disk and then we
just seek to the keys the tags for Bob
and because we're ordered and they'll be
they'll be co-located it's just a seek
and iterate so we've got them all and we
turn that in memory into that add wins
optimized and win set that you've you
now know how it works we have a pair of
those which we can send down to the FSM
who can merge them and because the
version vector
covers everything and we know that we're
looking at a subset only of these
elements we can do that merge correctly
on these subsets and so we can answer
the client yes Bob's in the set but with
only these tags and we can do it by only
reading a very small amount the minimum
amount of information rather than the
whole set I mean that's that's way more
efficient than reading it says 77
million here but he probably got 79 by
now million friends just to remove one
so I'm gonna stop there with the big set
stuff and that's just an intuition of
all of the kind of work we've been doing
and how how it solves a scalability
problem I'm just going to quickly talk
about what we're doing next even if any
of you went to the time series
presentation yesterday but but my
colleague Gordon mentioned that he has a
prototype of doing sequel over maps and
sets of CRD T's so our plan is to use
this design technique we use for set to
do maps maps of maps and maps of sets
and model tables basically eventually
consistent tables inside react so that's
that's not first we have to make the
maps and then we have to figure out if
we can do the joins and stuff but it's
what's what the direction we're going is
I think about there timewise right so
just to sum up CRE T's make eventual
consistency easier on developers that's
why they exist they solve one problem in
one problem Olie the divergence
divergent replica problem you've seen
there exists an optimized that Winsett
hopefully you could make your own now if
you wanted because you know it's really
quite simple if you walk through the
steps but to solve the problem for
customers it takes more than a light
takes more than a paper it takes more
than a library you have to really think
about how the properties fit in the
system you're making so see oddities in
a database are very different from
Sierra T's for present points of
presence and different kind of products
and a little engineering goes a long way
and gives you an awful lot of
opportunities so if you want to read
more we have a paper upon archive that
we presented at Papac that gives us in
more detail about how big set works and
we're hiring and pleased with it the
stand and app and I'm done so thank you
Oh questions for deleting sense or is
that just a single like operation or
like delete a whole set yeah the entire
set um okay so we haven't done that yet
but it's it's it's very very simple
because I didn't cover in this talk is
is this I do we can use level DBS
compaction to remove elements from the
set so a level DB has a process that
runs through the set and compacts or
grooms out deleted keys it's an
append-only store it doesn't ever remove
anything until compaction when it when
it writes down to lower levels so in
order to delete a set you take the
version better for the set and you copy
it into another key called tombstone and
that says that every tag in that set is
to be removed so that's logical deletion
and then compaction runs and physically
deletes all keys so unlike you know we
react we have to read the object and
deleted you just say delete it and we
copy that version back to so a
concurrent add of an element won't get
deleted because it won't be covered by
that vector anyone with a use case for a
unique identifier</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>