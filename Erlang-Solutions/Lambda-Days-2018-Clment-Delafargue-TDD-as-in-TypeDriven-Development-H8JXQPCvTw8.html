<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2018 - Clément Delafargue - TDD as in Type-Driven Development | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2018 - Clément Delafargue - TDD as in Type-Driven Development - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2018 - Clément Delafargue - TDD as in Type-Driven Development</b></h2><h5 class="post__date">2018-03-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/H8JXQPCvTw8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I will talk today about TDD which means
type driven development as you should
know I think so quickly I work at clever
cloud we do ITT automation and that just
a marketing department asked me to say
we do 80 automation what we do is we
take your application and we make them
run in production so we restart them we
build them monitoring backups every
every boring thing about apps is handled
by the platform and we support a few
languages so if you want to try it out
we can talk about it later
so I'm CTO there but I wasn't born a CTO
deep in my mind I'm a functional
programmer and I haven't been a
functional programmer all my life I used
to work a lot with PHP and I switch to
functional languages not because I want
it to sound intelligent or smart or
stuff like that
quite the contrary in fact I did that
because I'm not a smart man and I want
tools that help with dumb mistakes I do
every day that's why I switch to
functional programming ok so I will
start with a simple example of how we
can use types to improve the code so
let's say I want a simple HTTP endpoint
you pass it a number and it adds 5 or on
it
so I I can create an action so all the
examples written in scala ice normally
it's readable and not too too
complicated scalar so should be quite
easy to follow so I have an action in my
controller and I get a map string string
of query parameters it's the HTTP so
everything is a string so it's simple I
start to get the parameter called number
if it's not an empty string I try to
parse it into an int and with that int I
can return this number with five so it
should work right so yeah if I give it a
string that represents an int then it
works if I don't give it a parametric
low number then it's kind of a
nullpointerexception
and I can also give a string which is
not a number and then I have a number
from that exception because I couldn't
pass it to into an integer so one
solution is to catch all these
exceptions and as I say as I call it
it's called Pokemon driven development
you try to catch all the exceptions and
your code starts to look like this so
you get the parameter from the map you
check if it's already if it's there and
if it's a string then you try to pass it
with an int and if it's not then you
handle the number parsing exception okay
so that was simple now I will try to
make things a bit more complex let's say
I want to add two numbers and to do that
while catching all the exceptions and
ensuring you don't have any runtime
error you end up with God that looks
like that for something that takes to
two strings ourselves in two numbers and
add them and the idea is that Domon the
logic is completely hidden behind layers
of defensive programming and I don't
know you but me I don't really like that
so let's try to take a step back and try
to think with types instead
so the first insights we can get is that
I get a map I get a key and I get maybe
a value am not sure because a map is a
map does does not necessarily contain
value at the key I want
so we can have a new function which
instead of returning a string or no
returns me and maybe string and
similarly from a string I may be able to
parse an integer but not necessarily if
if the string is a string of digits and
okay but if not I don't have any
meaningful result so I could define a
maybe string and maybe int but since I'm
using a language with generates high
level features I can define an option
which is parameterized by the type it
contains so either I have no value and
it's none or I get some and I have my
value so can we write my functions with
parse in taking a straight and returning
an option of hint and a method gets on
map taking a a value a key and returning
an option of value and then if I combine
these two things I can create get int
which tries to take a value and if it
that tries to parse it and if it's okay
then I have a value else I have nothing
so by syncing with types I was able to
pipeline my operations and instead of
being in in a reactive way of
programming and not reactive in a good
way I react to errors then I think about
the transformation and I'm able to
change them so my controller now look
sizes compared to that I think it's okay
so the idea is to try to write code that
is correct by construction like you have
to do these things in a way that
creating an invalid program is not
possible and like if you're trying to to
do something that doesn't make sense
then the compiler will say no I don't
know many of you are used to programming
in like dynamic languages like Python or
stuff like that every time I talk about
it with mostly Python programmer they
say oh yeah your types are really
interesting but I have 100% test
coverage so I'm okay and my point is not
that tests are useless or you shouldn't
use them my point is that tests are
really useful too but it's not a tool
that does everything and there is a like
a profound reason for that
don't know if you you know see symbol
it's called the existential
quantification quantification and in
plain English it means there exists
there is a value such as it does that
and that's precisely what types do what
tests do there is a exist a value such
as it works or it doesn't work let's say
you have a function from integer to
integer
I'm sure you've watched Philips keynote
yesterday when he talked about
Exponential's and function being
exponential so the number of function
from int to int is it's not that it's 2
to the power of 32 to the power of 32
and it's a big number
I could try to like display it on my
computer but just displaying the digits
will take forever and if we run 64-bit
architectures and it's even more than
that and even worse let's say we try to
test a function to stray from string to
string then it
practically infinite depends on the
memory bounds of of your machine what I
want to say is that testing can give you
a proof
only if it's exhaustive and usually when
we program the types we have have a big
number of value and we can't test for
every value so what we would prefer is
to be able to prove things for all value
of of my type and turns out we can there
is an interesting result called the
hurry about the lambic correspondence
and it describes a transference between
type systems and logic
so with that correspondence a type is
equivalent to a property or CRM when you
state a type it's as if you stating
serum and corollary is that when you
create a program that is well type that
complies and has a type it's as if
you've given a proof of your serum and
the good thing with programs and
compilers is that it's done
automatically and in fact there is a
branch of of proof which allow you to
like which let people proof things with
something called the proof assistance
which is a compiler they say I want to
prove this property and then the type of
proof and the compiler verifies that the
H step is correct and that literally a
compiler and of course I'm not saying
you should all do formal methods on your
code like maybe you're working and
unworking or airplanes and in that case
please formally test your code but for
webpages it's it's not I say it's not a
good investment to formally prove your
cap picture website so the good thing is
that
when you program with by really using
types you're not writing a formal proof
but the code you write has the same
shape as a proof and we can call this
code code that is probably correct
you don't actually write a proof that
the code is shaped in a way that it
would be feasible and quite easy to
write proof and that's very good so if
we are able to have a program that
comparison it proves a property so the
next step is that yeah if my type is int
then I've proved that value is an int
and it's not that interesting so the
next step is to have an expressive type
system if you are able to have
expressive types then you have
expressive properties and more of the
types are precise and close to your
domain model the more it helps you one
thing that helps a lot in in the type
system is languages where everything is
an expression because if everything is
and expressions and everything has a
type then you can prove things about
stuff and a good example of that is that
you are able to type control structures
in languages like C or Java let's say if
a block is just a block the compiler
cannot check anything in it but in other
language is where if our expressions
then the compiler can prove things for
instance for an if burke it will check
that the two branches are imagining they
return the same type of value stuff like
that and it's the same with with list so
with that your control structures are
typed so your compiler is able to verify
what you're doing not with just data but
also control flow and it's really really
powerful and it allows you to avoid
stupid mistakes I don't know if you
remember it was and don't remember if it
was open SSL or in the apple SSL
implementation certificate verification
was bypassed
because there was a duplicated line and
it was always jumping to to the fail
label even though it shouldn't and
everybody said yeah of course they
didn't put braces on our if block huh
amateurs but the issue is not the
missing braces the issue is that the
compiler is not able to understand what
you're trying to do with this control so
that the first features that will help
you a lot in typing your programs I've
shown you may be your option it's a way
to tell the compiler that value may not
be there and it helps you avoid null
pointer exceptions which is quite good
there are lots of things non-empty list
it's a list that guaranteed to be not
empty which comes in handy really really
often so you can always take the head of
the list and it will never blow up you
can use something called validation
which contains either your value or a
list of errors so really really useful
when you were like validating forms or
user input more generally you can do
lots of thing if let's say you have a
user that needs to input an email
address and you check it once that email
address is valid then either you can
like path strings to the rest of your
programs and income and say yes this
string is an email address it must have
been checked but what if it isn't with
new-type you can create a type that is
exactly the same as a string but that
will carry out the proof that it has
been verified and the best thing with
that is it's erased at the compilation
once the compiler has proved your code
is correct then it's as if you've used a
string for one time performance so it's
really useful and those small thing I
like it's called tag types for example
there was a mushroom that crashed
because there are two teams one working
with miles and the others are working
with proper units
and it crashed because there was a
discrepancy so we stack types you can
tag a value and say it's an int
representing a value in matters and then
the compiler will will tell you if you
try to mix it up without converting so
it's really useful and as as with a new
type it's erased at compilation so it's
it's a free it's a free check at runtime
you don't pay any cost and ya know with
rusts memory management is handled by
the type system the type system will
have will make sure that you don't
double free your memory stuff like that
so you can do a lot of things with with
the type system and also resource
management is the same thing in rust you
never have to close resources when the
handle goes out of scope then it's
closed automatically and the compiler
make sure that it's closed exactly once
which is super neat and like a guarantee
you don't have currently in half scale
or Scala for example so this is all our
interesting tools but I will talk about
something a bit more profound and more
important when it comes to being type
safe and this tool is pyometra City if
you're coming from the Java world
it's called generics and you may have
seen it and discovered it as a way to
reduce duplication like to to you to
have Cod reuse but it's not the most
important characteristic of generics the
most important characteristic of
generics is that you don't make any
assumption and the types your power
might rise over you don't know anything
about it and since you don't know
anything about it you can do stupid
missed you can't do stupid mistakes it's
more example this function it takes an A
and it returns an A for all a I don't
know anything about a because it needs
to work with any type the only sensible
implementation for this function is to
return the value that was given because
I can't I don't know anything about a so
I can
creates a value of they pay out of thin
air so by looking at the type I know
there is only one sensible
implementation same thing for that I
taken function from B to C and a
function from A to B and it returns a
function from A to C the only sensible
interpretation is to is to implement it
with function composition no other
implementation makes sense so this two
example are really neat because there is
only one sensible implementation but
even though in cases where you don't
have a new one implementation in it
still helps you let's say a function
called reverse it takes a list of a and
it returns a list of a of course there
are many implementation possible it can
return always an empty lists written the
list that was given may be reverse it's
maybe do other permutations but I can
still have information that and its
behavior for instance I know that if I
call it with an empty list then I will
get an empty list back I can create
values of type a so I can create a non
empty list from an empty more generally
I'm sure that if the reverse or if the
return value contains the value I'm sure
it was in the original parameter and
that's that's really important because
it allows you to drastically reduce the
number of tests because you can prove
stuff and there is actually a paper
called she rhymes for free with written
by a guy called filling wonder maybe
you've heard of him and basically what
it does it say given a type a function
if it's parametric I will be able to
derive serums and its behavior and it's
for free I don't have to like don't show
me the source code just by looking at
the types I can guarantee you it will
work this way for instance let's say I
have a list
type with filter and map operations
by applying theorems for free I know
that if I'm mapper function and then
filter it it's it's the same result as
if I filter before mapping just by
looking at the types not working at
implementations so it's very very
powerful so it's very good but always
about you need discipline because they
are features in programming languages
which break the guidance is provided by
a pyometra city so if you use them then
you throw all this information out of
the window the first thing you need to
do is to avoid using no it's common
knowledge like using no it should be
avoided and the common reason for that
is say people say yeah if you don't use
new you can't have no point two
exceptions yes but I will try to show
you another way to think about it so
we've seen that the type is equivalent
to a property so now what is it null is
a value that can in a bit at like every
type you can put no and it will compile
so now can in a bit any type if we move
over to the logic side of the
correspondence what it means it means
null is a proof that can prove
everything and a logic system in which
you can prove everything is not really
interesting because everything is true
everything in fault it is it's not
utilize and for the same reason you
should learn huge exceptions it's the
same as returning null if you throw
things then you're not forced to return
anything okay so that living without
null and exception is really manageable
many many languages do that and it's
quite okay next one is maybe a bit
harder you don't want to use reflection
because reflection means inspecting the
type and it means breaking the princi
of ignorance let's say every function
that takes an A and returns the string
since I don't know anything about a the
only sensible implementation would be to
return always the same string regardless
and of the input because I can't do
anything with the inputs if I use
reflection then I can provide other
implementations and that's an issue
because when I see a function from a two
string I'm expecting to see a function
that returns always the same thing for
the same reason you can't use two string
equals hash code because defined for
every object so I can always go to
string on any value and that breaks
parameter ect to side effect is the same
if you do side effects for instance
reading for from the environment then it
will do bad things but there is a good
good news there is a paper called the
fast and loose reasoning is morally
correct which says that it's not too bad
if your language actually supports is
bad features as long as your team is
disciplined and restrained from using
that in practice they say I did a study
and on programming teams and it showed
that it was more or less the same as the
language not having those features like
programmers were disciplined and didn't
use features and then everything was
working well so it's a good result so
going back to type driven or type
directed development a lot of type
apologists or type evangelists saying
yeah you should use types for everything
and if you're not using types you're not
a good professional it's a bit too
extreme types they are not a silver
bullet there are other tools that
compliment types and are really useful
but they are really really really
helpful types are really powerful tool
and it's it's it's too bad if you don't
use it you can program and create
interesting programs without using types
but you're missing it and really really
important to me first thing is that it's
going it brings you confidence I can go
back and code base I haven't touched for
months ease and I go back to it
and it works because I don't have to put
everything in my head again I can change
stuff and if it compiles and the test
passes and it's okay it also allows
module our thinking because when you're
implementing a methods just looking at
its type and you forget about the
outside world
it's everything is every information is
carried in the type then you can like
forget the rest of the world and just
work on your function but that's an
issue I have with saying you should use
types because it will prevent errors
it's true of course but it's just a
little bit of what kind of what types
can do for you for me the biggest help
with types is that they help with with
structure when I create a program I've
been taught to use analysis and to break
my problem into smaller problems and
I've done that with pseudocode like
syntax that helps me write it in on a
sheet of paper but it's just me and a
sheet of paper you know tool is helping
me saying yeah this is good structure or
as this makes sense which types I can
actually do that I can rent a type of
the functions and then the compiler will
tell me when I try to assemble them if
that makes sense let's say I have a list
of input and I have a list of outputs I
can call map on it and pass it a method
that transform an input into an output
and I don't need to provide
implementation of this mapping function
right now I just say it takes an input
and returns an output
and the compiler will tell me yeah you
can you can map this function over this
place that makes sense okay and I don't
have to code everything to get
interesting results the other thing is
that type checking is just a part of
computation computation is providing a
binary from your source code type type
checking is a step usually it's a step
that bundled with other stuff but in
some languages type checking is actually
a separate step so for instance in Idris
you can just type checked type check
your code and not compile it so when
you're working it's really fast because
it just type checks and doesn't go all
the way to generating binaries and it's
really efficient to work this way and we
can do a thing called hole driven
development I think that there is a
conference maybe right now maybe later
about using holes in asshole the good
thing is that you don't need any
language supports to do that you can you
can just trick the compiler into telling
you what you want to know I create a new
type called hole it doesn't exist
you can't clash with anything and I will
try to tape a function and we I will put
this special value in in place of the
implementation and then the compiler
will tell me I expected a function from
A to C but you gave me a value of type
hole I don't know and then you you write
your code step by step and then the
compiler helps you refine the
implementation by telling yeah
what you've done is good but I still
lack an implementation of this type and
stuff and step by step in a very
mechanical way you end up with the
proper implementation and the compiler
helps you to to write it so oh you all
know test-driven development red green
refactor you write tests it doesn't pass
you make the simple scopes simplest code
that makes the test pass and then you
refactor we start
driven development its type define
refine you create a type describing what
you want to do you define your
implementation and then you refine the
types to be more precise it comes from a
book called type driven development with
Idris which I heartily recommend so type
I cool because they make communication
easy of course with machine when we
compile a program with talking with a
compiler and types is a really powerful
language to discuss with with the
compiler it's also good with tooling
because the compiler knows stuff so you
should really learn Haskell type syntax
because it's a really simple syntax
which allows you which allows you to
describe types so this is a function
from A to A for all type a this is a
function from int to int so if the type
start with the lowercase later its type
parameter if it's with an uppercase
letter it's a concrete type in Haskell
we don't have functions of multiple
arguments we have something called
curate function so you will see that
everywhere you can think of it as a
function taking an A and a B returning a
value of type a but you can also think
of it as a function taking one a and
returning a function that takes a b and
and returns an a it's called the
describing functions like that is called
carrying on shrimp inkling or fragging
and giving values one by one it's called
partial application it's very useful to
compose and create small functions on
the go another thing you need to
understand is that you can put
constraints this means for Oh a provided
that I can provide an order for a so
provided that and I can compare two
values of type a and it gives me intense
any of you know who go okay so for the
others you will be mind Blount let's say
I want a function to remove duplicates
in a list let's try to imagine its type
its type would be a list of a - a list
of a provided that I can compare two
values for equality and I can type just
that into Google and it will be it will
give me the results and it's called not
I think it means remove duplicates in
English but it's it's not an easy
function to to know I can do the same
and I have a list of maybes and I want
maybe a list like if every value is
defined and I want all the values and I
can type that into Google and the best
way is that Google we actually give me a
better type it says yeah you've asked
about about maybes but I've got this
function C it works for any monad so
it's even better so talking with
computer is cool but writing programs is
also talking with humans and form us
talking with humans and that's a very
good thing most of articles about
programming and types all the examples
are written in Haskell because the typed
language of Haskell is it's really
concise and easy to understand I said it
I say it again you can prove everything
with types there's a limit to the
expressivity of the type system it's so
that's not a problem exist this function
reverse I can prove its behavior with
types only but what I can do is to write
tests that prove it and the good thing
with those tests is that it works with
input that item
I don't provide so you still get the the
for view of thinking you think about
properties but it's not a real fall it's
not proved structurally but
the system is it's doing the hard work
for you so the library school type check
and stuff like that
a quick check sorry that'd do it for you
it's still property reasoning not for
one but still the same way of thinking
as with types and it's perfect with edge
cases or testing specifications so what
you should do
start with types trying to prove as much
as possible with types and when it
becomes an widely then you go to
property tests and then you can use unit
tests for pinning regression test stuff
like that so in practice you start by
laying out the function types that's the
most important again that's where your
business logic is the transformations of
value in your program then you rights
property based tests to assess more
properties about your transformations so
you end up with operations and lows on
these operations and if you want to
sound smart and some mathy
say yeah I got an algebra but it's just
function types with properties nothing
more and then you can start figuring out
data structures and and doing the
implementation but it's a search step
like committing to a specific type is
way late in the end of process you can
test you can unit test progressions if
you want so to recap
types there are safety feature and I
think that the main way we talk about it
right now and I think it's a shame
because the safeties are provided school
but it's very little compared to to what
they also provide for me it's a tool to
reason at a very high level to reason
about how to decompose my programs how
to analyze my my problems and the best
way that I can describe high level
things and the compiler will check them
for me which is way better than just
writing stuff on paper and hoping
everything is okay and most importantly
types are really
important communication too because it's
really concise it's really dense it
packs a lot of information in in a
really small language and you are able
to wait to talk about concepts really
complex and advents with other people
without having to read implementation
like you can just scribble out a few
types and and use it to communicate with
with your colleagues
and you don't need to to sift through
thousands of lines of implementation to
try to understand the behavior of your
system which types you can you can
specify a lot of thing so please use
them okay to conclude if you want to
learn more about types there are two
really important books so the first one
is called types and programming
languages by Benjamin Pierce so if you
want to know about type theory it's
where to start the other one is the
practical foundation for programming
languages by Bob Harper in that book use
this type theory to unify lots of things
oh these two books are it takes time and
it's it's not an easy read like you need
to commit to to it if you want maybe
more practical introduction to this kind
of programming in Scala's there is
functional programming in Scala we call
it the red book the red book with Cal on
it by renewer be honest and and
pochittona very good and very very
detailed another way to do to look at it
is functional and reactive domain
modeling by the Bosch gosh what it does
it is that it describes how to do domain
driven design which is usually
illustrated with object-oriented
concepts you can do the same with with
functional programming and if you do
that you end up doing designing or
algebra so very very good book lots of
concrete examples on how to design your
systems highly recommended
if you want to prove everything in types
you can with language with dependent
types type type driven development with
Idris it's very very good book or if you
want to discover it risk which is a very
nice little language also you can try
rusts it's it's good Russ is good
because I always thought type went
hand-in-hand with functional programming
and with rust I discovered that you can
do in imperative programming and still
have the compiler help you and that was
really a an eye-opening lesson for me
and I think there is a session about how
to use rust with for functional
programming so I encourage you to attend
this session and I'm always okay to talk
about rust if you want i'm rest of I'm
part of the rust evangelism task force
ok I think that's all so if you have
questions we can go
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>