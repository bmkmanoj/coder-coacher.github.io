<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Peer Stritzinger - Heavy Industry Erlang | Coder Coacher - Coaching Coders</title><meta content="Peer Stritzinger - Heavy Industry Erlang - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Peer Stritzinger - Heavy Industry Erlang</b></h2><h5 class="post__date">2014-07-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OA2xgKkwPTc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning I'm Pierce with singer and
my main application for Alan is music in
denervated systems and for industrial
and automotive customers and today I'm
talking about one application that we
are about to do or we are almost done
it's about plcs who knows what the plc
is okay that's not too many plc is a
programmable logic controller these are
used in industry for basically
everything everything that moves or
switches or goes on and off and controls
motors like the thing when you're when
you go into a parking garage that opens
the look at the gate and all this stuff
is done with pocs these come in
different sizes and and there are
basically the workhorse for everything
and they are programmable who knows how
a PLC is programmed Oh in someone yeah
there's there's a complete whole
separate world how pure seas are
programmed there are some standards it's
like the only if numbers the normal
standard is IC 611 31 and actually the
largest company who's selling plc's in
Europe has their own standards they are
not doing this but the rest of the world
is using to standards and inside the
standards are all kinds of ways to
program in several ways actually there
the first one is a quite old one and
there's also a new standard for
distributed plc's so you might notice
how this might be connected telling
distributed pcs mmm maybe maybe you
could contribute something because we
know how distribution works or at least
we believe
so how do we program these there the
start of PLC's the the first thing that
the first plz was like was was was
invented I think it was at Ford I don't
know I'm not very sure but it was
invented to replace like hardwired
relays who switch on and off stuff and
control each other's have time delays
and all these kinds because every time
they wanted to they needed to change the
process for the manufacturing they
needed to rewire and they bring in the
electric electrician and rewrite all the
relays so the first kind of way to
program these is derived from the relays
and it's it's this part oops it's this
this way this this is basically the the
plan how how the electrician would wire
their relays and these were encoding and
programming language and I actually
copied this out of the standard it's
like it's even like obvious all these
dashes and like which is a ski arts Ram
so what does this mean we have a wire
like running from here to here and we
can have multiple wires so a big PLC
program has thousands of wires and at
the end of your wire there's a coil is
this one that's a coil coil means a
relay the coil of a relay I mean relay
has two parts the coil or user trigger
it and the actual switches so the coil
if it gets current it switches something
and so this is related this run here is
rated to this run so if this coil gets
current it closes this switch that's a
switch so what we have here is basically
a industrial start/stop that's a the
easiest connection to like start a motor
we have a key that starts a motor but
the switch is not always on it's like
only a push button and so if somebody
and the switch is this one they start
somebody
pushes the switch and and the emergency
stop or other emergency switch is not
switched off that's an dis lashes an
inverted switch then the coil gets
energized and switches on this one which
makes the whole thing holding because it
keeps energized unless the stop switch
is being pushed so this is actually
totally concurrent I mean if I if I
build this relays its concurrent I mean
it's like everything is happening at the
same time and you can have like multiple
lines like these controlling each other
so when when I they brought it into a
controller they need to like change the
way it was running because yeah well
it's not running at everything at the
same time so and what they did is like
they run the program cyclically
everything in a PLC in a classical plc
runs in a cyclic so the program is run
every like let's say 20 milliseconds and
the size of the program in the size of
the the PLC depends gives you basically
the real time guarantee like the cycle
time if for more complicated stuff then
can be switched with race there is a
assembler like programming language
called instruction list that's but this
is this is the past so we move on okay
normal thing today skip one no so but
there's still in the standard then they
are still used especially here the relay
plan is like liked by electricians it's
how they program this there's a
different language from the assembler
language which is a little bit Pascal
like you can see it below here so it has
you have to declare variables they have
data types you have function calls like
this
and you also have like functions with
multiple inputs and outputs so multiple
return was a thing back bang already and
then you have to like like the keyword
thing so that the output the input in
one is getting the output of the of the
coziness and then put into is getting
the output of design designers and this
this is actually the output lines the
enable out gets to enable in and you can
also draw this and this is also like
sanitized in this ascii art but usually
modern tools don't use this anymore you
can use it's allowed to use real
graphics and this is basically the
diagram you see here is encoding the
same program then we see here in the
past collect language which is called
structure text by the way and the other
thing is function block diagrams I need
to show you something else with a
functional diagrams what we have here
these these function blocks they don't
have any state inside them they are
stateless they actually functional there
they are standardized to not to have
side effects that's it so usually you
want some side effects so there's
something different that's called a
function block a function block is
basically similar to a function e
there's inputs and outputs and it has a
state it has internal variables that are
kept between runs basically like the
static variables in a sea program so if
it's run cyclically it keeps this
interstate and then you can have you can
build all kinds of side effects because
the internal state might be connected to
some outputs and in the classic will
appeal c programming there are lots of
global variables also everything is
global so that's not so nice firm mass
to implement fortunately we have
something different and there's also
several ways of a higher level of
programming these this is a sequence
function chart also standardized we are
still in the first standard in the IC
611
31 what you see here is basically a
state machine actually it's a pattern it
because you can oops that's too early
what you have here is basically you have
states like this the these blocks are
states and there are transitions here
these bars here are transitions and they
are connected and it's basically the
state machine is like starting state
here and if this transition gets true
and you can have like a either condition
or you can have the output of a relay
plan if the condition gets through it
moves on this state is not no longer
active and this toad state gets active
and basically the cyclic cyclic program
is running inside the state so if this
is active this one is running cycles and
if this gets active this gets stopped
and this runs in cycles and what the
boxes on the side there the actual
actions so there is a simplified way to
specified actions and they have flex
like this is a delayed-action this is a
so to easier than the normal use cases
of the programmers and you can have
complicated plans and you can have also
like like something like this this is a
condition so if if either this or this
is true it moves either there or they're
so it's a either or and if it's a double
line it's a parallel so if this triggers
which is always does because the start
state this runs and this runs in
parallel with these concurrently and you
can also have a join when both are both
ends states act if you can try to dress
I etc etc but yeah we're not actually
using these we I think I need to talk
about the application area we are we
want to use this because what we are
doing is it what what my customers doing
is building these it's a company called
bosch rexroth german company subsidiary
of posh and they they are building
transport systems so everything that the
need that that moves the material flow
inside manufacturing so you have all
of sizes that's a the left one is a
medium sized up there you have for a
large solar panels special white ones
and there's also this is like like a
chain belt for small pieces and so all
kinds of a movement for the
manufacturing and this movement all has
all kinds of like if you want to go left
or right and stuff like this and then
you move this stuff you move in it they
think the thing over there that's
actually a belt it's always moving and
if you want to move it to another birdie
it gets lifted off and move to the other
belt and you need to control this stuff
and initially what I did for the
customers I helped them build these
which is basically rfid system which was
not called rfid back then with a
proprietary tag which has actually
picture is actually nicer than the
standard text we have now but this one
takes a much cheaper so we are doing the
standard text now the little white box
is a actual tag it's a road box and so
the pallet where the product is on it
has information in it it gets tagged and
what they had back then is what our
distribution distributed production
system where the whole product plan is
on the tag so the product knows what
needs to be done next and this is very
robust because it's just decent thread
you have no central server that breaks
and you stop production and so I like
this very much I like to do some fun
stuff so this was just an a kind of
smart rfid system and hit a cash it was
written in c back then I used the the
operating system items which is an
open-source hard real-time operating
system which will hear a little bit more
about later and so we we started out
building rfid systems so our next system
will be also our rfid system but it will
be more smart it will be written in a
long actually this already everton on
Ellen
but there will be layers for like
intelligent material flow like doing
some online planning like changing plans
if a machine breaks rerouting stuff and
also features to try to avoid reading
the whole tag all the time because if
you want to read the whole tag it so it
takes so long that you need to stop the
product for reading the tag so if you
you can read a few bites while it drives
through quickly and so if I if I want
the rest of the data I need to stop it
actually in that time is money in
production and so we want to avoid this
so what I'm doing is basically there I
catch the RFID data in the in the node
and I send it along in the network
having basically a kind of distributed
database of RFID contents so if it
already knows the content it isn't that
doesn't need to stop it it can just go
through and but the main thing is the
online planning stuff so but what we
also want to know what want to do is
like we want to make we want to avoid
having a PLC at every node that moves
all the parts because yeah if you only
need one part it's cheaper that's
selling point so we want to have a
software plc inside our node and that's
a usual approach you can buy like
ready-made firmus for software POCs but
those are written in C those have
problems with concurrency and all kinds
of stuff and they don't integrate very
well with our Allen code so we decided
that we do our own software plc and well
so we need a compiler for these
languages so I wrote on Ellen and that's
that's about the echo of the talk and
the demo is showing this so here's the
slide it's like in a research project
there's some money from the german
government flowing into it so there the
system has good funding and what we want
to achieve is
that the plc because normally I could I
could write the all the control
processes for moving the parts in Ellen
of course it would be actually much
neater but I don't want to do it I want
to use the hundreds of PLC programs that
are at the customers because they have
people who know this and they actually
know the machines better than me much
better they know how to get stuff moving
and how it works and we want to get give
them away to program our node to get the
moving parts and all the the artificial
intelligence super smart part we do our
self so with all these global variables
and and running in cycles that doesn't
sound too nice to be implemented in ere
long and i was like thinking a lot how i
can avoid running in cycles and turn
global variables in two messages and
then fortunately I've I found out about
that is a new standard the the second
one I showed in the beginning for the
disability PLC's and since they needed
to sanitize the distributor PLC's they
need a solution around this running in
circles because if you are distributed
in networked you can't like send all the
time I mean there are solutions to this
on field passes but that's not that has
no future basically so what they added
to the function blocks it has a state
inside is events and I liked it very
much because it very neatly maps to
Ellen processors so what we have here is
there the the way a function block is
drawn it has like this this this little
head in the top and the lines that go
into the top and come out of the top so
inputs are left and outputs a ride by
convention and the lines going into the
head are actually events so it's an
event which basically is not up they
they emulated that maybe you remember
their enabling enable out of the
function blocks before so they had an
enable function block for error handling
mainly so you can switch off the
function block so it does just an if
around the cycle and just jumps over
the rippln they replace this and the
events are actually instantaneously and
not at the same time being present and
in the body of the of the thing you have
to actually data inputs and outputs and
these inputs and outputs can be
connected to events bubble so this
whoops this line here that's actually
the connection to a rental so the event
wrote is combined with this data which
means the data is only valid if they
event triggers otherwise you you can't
yet you can latch the data but you can't
read it from the lines if you have
something and the output event it's the
same so this means that this data is
only valid when this event triggers on
the outgoing side so that's actually
pretty neat for mapping to Alan
processors because what i did is mapping
events plus theta2 messages i want to
show you a little bit of code or even
the time okay so this this is a actually
structure text code how this function
block it's about which is basically
doing the following if you reset if the
recent event comes it gets reset and the
output gets to zero and otherwise if the
vote event comes it does a voting
between the lay input lines and if two
or more are actually true then the
output is set to true and latched it's
kept through until this it is reset
that's a those pc programmers use stuff
like this they they were immediately
nodding whenever showing this yeah you
need something like this okay I don't
know for exactly what they are doing
that so what we have here is we have the
function block it's called it has a name
its voltar we declare the event inputs
and in the declaration we already have
this with state
where we connect the event to the data
so this means the event vote is
connected to the data inputs a B and C
so we can specify what we have in the
drawing you can specify also in the
programming language one to one and then
you have the input variables and we have
the output variable and you see the
output variable voltage is also
connected to this output variable here
so that's the declarations let's look at
the actual code what they did is they
actually included a state machine
because usually they build state
machines out of the elements so it's
very similar to the sequential function
short I showed before so they need a
state machine inside and they're
actually providing it it's basically
that gin fsm so what what you do is you
declare the states in the beginning so
there's a ready state in a voted state
it's very simple block not many states
connected to a state is an algorithm in
this case the reset algorithm and about
algorithm so that's some code that can
be run and an output event ready is is
output the mint and voltages output
prevent so when this state is triggered
the code is run and then the event is
sent and you can actually have multiple
pairs of codes like the this can be a
list of of algorithms and output events
that will be run once it's triggered and
so how is it triggered there you have a
transition diagram specified in the
transitions basically you say ready to
vote it and then you say this is this
happens when the event both happens and
you can also have conditions you can
have say ready to vote it vote when it
actually it's the same keyword I don't
have to have it in example vote when
variable a is the highest value and
etcetera etcetera so they basically have
they have actually guards on these
transitions and here we have the
algorithms which are run when they went
through
us the reset algorithm just sets the
state to zero and the motor algorithm if
the state is zero then it calculates the
actual voting and set the state and
that's it let's say all contents of this
voter thing when programmed so what we
want to do now is we want to translate
this into airline or actually into a
beam file which we can then run in our
LNG embedded system so that's what the
compiler is about compiler is looking
like this simplified of course there's
the compiler driver there thing on the
top left and which reads the actual code
the st code standard text and runs
through a scanner sweep our parser scan
is done in in in le x it's the basically
lex variant of a days did for those who
don't know does everybody know lea lexis
EE and and yak we see ya is it known
it's basically their legs and yak
implementation in ere long which which
comes with OTP so it's very convenient
you just have the tools for building a
compiler so you have the i just could
apply what but what I know about writing
compilers like very easily and then
there's one module that which is a
little bit which is actually multiple
passes it's like massaging of the
abstract syntax tree a little bit what I
implemented is like a micro passaporte
approach so I have lots of tiny process
which I can like assemble which is quite
neat and the module st core is then
actually producing coil ong co a long is
a is an intermediate language in the
airline compiler that's actually
specified so it's very very simplified I
along basically which has easiest coped
variables they have basically let the
let we don't have any along we have in
quarry along
and this is this is actually neat
because what what what we don't have
instructor text they have we have
mutable variables we don't have
immutable data so we need to emulate
these in somehow and I did it like I
just basically nested the scopes of the
variable so if it gets a new value I
just make an inner scope because then I
can set it again and it has a new value
I'm you need to be take take a liberal
care if you want to like translate and
if because you maybe you set the
variable before the if and then you'll
overwrite it in one branch and
overweight right another variable in the
other branch and at the end everything
the code that runs at the end it needs
to have get all these changes and
basically what I do is I map it to our
case and I track which variables is
alive where and I I return all variables
that is modified in any branch of the
case and I get this back as functional
result and they can set my new let
variables for the next scope so besides
of having to track the variables but I
mean you need to track some variables if
you're writing a compiler so couldn't
get around this and after I produced the
core I just call compiled from core
that's a needle there's the normal
airline compiler module has the normal
compile function where you can pass in
several forms and if I if I specify the
option from core then it basically
produces a beam file from the core this
beam file that needs to run so we need a
runtime system so we have the runtime
system we have the the actual runtime
system for the function block we map
every function block to a process so
every process runs this FB run code so
there's lots of FB run processes and the
voter beam file is actually a callback
module there are only callbacks in it
and it calls into this voter beam to
find out about the variables and stuff
like this and there won't be most calls
like a library module for ransom
for standard functions and everything so
this is a little bit more detail here we
show how these function blocks
communicate actually I'm actually both
behind I have to speed up a little bit
but that that's actually important
details away I tell you this you have
the actual runner thing that's basically
like a gen server that's a special
process it can get supervised and it
calls into the voter and if the if the
if it happens that it wants to send an
event it needs to produce a message and
needs to find out where it sends the
events because there's these this graph
where the stuff is wired and these
function blocks there's another
specification language or several again
XML and non Nick's ml and all kinds of
thing or you have a graphical tool and
from the wiring I have produced a
function that's called FB targets that
tells me which event from which instance
because that's actually there the voter
function block has an instance name vote
one which is globally registered and it
gets these information and finds the
target out one where it needs to send a
message to with the in the formatting of
the output event so it sends a message
basically it puts in the sender
information like which function block
which name it has event and it has the
data that's connected to the event to
the output on the output side but then I
need to map it back because the input
the output data is mapped to some input
variables and this is done basically
here i have a blog basically the helper
function that map's these that gets a
function block and the message air
content and the state of this process
which is basically all the variables and
it knows from its generated at the same
time like the blue one the blue ones are
generated and and gives me my new
variables my new state and and also my
input event name which I need to trigger
and then I can actually trigger the
actions and stuff moves on so let's move
on
a few tips for Corey along you can look
it up in the slides the function see I i
I'm using this year on module which is
basically syntax tools for Corey along
you can also build the ass manually but
I was recommended this and I went this
way it's basically a matter of taste
there is one function it's called zero
abstract which is actually not badly
named because it actually makes a
literal so you have any long-term and if
you shove it into abstract it makes a
literary coil on thing there's also a
the name literal but but that doesn't do
this abstract does it and the important
causes if you developing add to your
options this one which calls the coil on
length which is not normally called
because it's like not trusted really but
for debugging your own problem if it
went when you start get generating coil
on it's very important also report
errors and the next thing is copy the
file covalent from from the compiler and
uncomment everything every output that's
in it and run with this because then you
actually get more meaningful places
where you because there in the beginning
you will screw up building the right car
syntax tree and you need to find where
it is and it actually prints the actual
statement that it can't can't digest
because otherwise you get very bad error
messages so normally we have that's a
normal float event flows to the same
block with data so the event line goes
into the same block and is connected
everything easy so that's the easy way
but somehow they also specify this way
so the data goes from this blog to that
block but the event goes through another
block or a bunch of blocks well that's
actually bad for mapping to messages
because if I map this to messages then I
may need to make sure that this data
arrives before this event and just
before not some other data message
arrives in between and south
I need to synchronize it somehow and
synchronous I don't I don't want to
synchronize it actually and because even
while this goes through another block
you know it can come in out of order
because that's another day that's
another process and what I'm what I what
I do at the moment I was thinking about
use some logic clock thingy and but
there ain't good not it didn't it didn't
lead to anything and then it it'll cute
it'll cure to me that I just I just
meander the data flow graph before I
compile it because it's actually very
easy because they are in our variables
it just goes through and I just move the
data along with the events and add
virtual in out variables tool to the
blocks retina moves through and after i
did this then I I move a lot of data
around that's not needed but in the next
part you can actually remove everything
that's not needed and so that's actually
pretty lean and I don't need any
synchronization stuff I just send the
message so there would be a demo here
but I'm short on time so I think I make
one I plan to demos I make one demo I
one big demo at the end I also skip
through the slides because I've talked
about this before i ported LMK to the
atoms hard real-time operating system
and yeah that's the features of the
operating system you can read it
yourself initially I built this thing
that's a product of mine it's a flashing
system for the automotive industry but
in this system yelling runs on freebsd
and talks via USB to the gateways
running on items for the stuff we we are
doing in this product we needed
something more integrated running on
small boards so that's the new project
name crisp running along on items
hardware and having support libraries
and stuff like this there's a website
but it's very negative but when
something will be this server when
something will be shipped like about in
two months it will appear the there the
pay
that's how the system looks yes the
island code goes through the airline
runtime which uses normal drivers to
talk to the POSIX layer in the in the
actual item system where you have
networking and file system for example
goes through the network I gave also a
see application who talks to the items
in the hardware but you can have nifs
and LinkedIn drivers that actually talk
directly to the hardware because that's
the way you do it in the small embedded
systems you don't have a driver layer
you write your dry run and what I can do
now is a right to driver right as an L
on linkedin driver and it has very low
latency from Ellen to the hardware the
lowest you can get so now it's time for
demo so what I have here you can look at
it there is no time to show you the
camera I have here a small board which
is connected to my laptop by Network and
actually we have multiple boards that
are networked and Ellen distribution
works and there's an output relay board
because I'm driving this and and lamp so
basically basically a short circuit when
it when they go on and only get their
nominal current when they're on and the
the power switch is off so fast in the
of the current controlled output driver
because actually I could drive it
directly but I need to put in relays and
I also have some sound system but I yeah
you won't hear too much so let me switch
it on while I talk if you don't already
know normally it puts in three seconds
from I've showed this I've demoed this
in other conferences but somehow I was
like a little bit of a hurry by
preparing this and it was I think
there's some distribution distribute the
application stuff left over that waits
for the other note that's not there so
it takes 30 seconds now until this times
out until it boots through so this is
not normal normally it's immediately on
three seconds from power on to a long
she'll basically let me close this we
don't need this at the moment
yeah let me I'm i shorten this actually
I wanted to show you like core did the
coil encode I actually produce and run
the compiler and stuff like this I just
go to the last demo not enough time it
woke up so it's a blink the lights and
so we need demo to PF demo to that's I
start I start to sleep each day long and
I do a net admin ping which I put into
my user defaults and I get a pong so I'm
connected to the actual to to this
system we can also have a remote chillin
which is very convenient for embedded
system so but we're not actually using
this that's just for testing their
distribution that's the console I don't
need this I need to like fast forward to
that's actually a remote shall I don't
you use that would be the remote shell
yeah so I'm running this on there on the
other side and let's do away with this
lecture use this and you'd editor so
what what runs here is basically three
function block blocks one block is
implemented in the airline you can also
implement in an airline which is this
one because you have no timing in these
events so you need to produce the first
events that have timing so like
something like an event delay or a
cyclical event producer that is actually
in the runtime system and be used as
building block so what I extended the
syntax a little bit by saying that I
implemented in Ellen so I can specify
all variables but it's implemented in
the runtime lip so that produces the
events and events go to
ah the events go to this very
little no we make sure the wrong
directory and skip over to the other
directory so so this is a function but
we actually run let's go to the
beginning we have one event input that
toggle event and it's connected with all
with all outputs with state 1 to state 5
output and we have the output variables
and we have a very simple state diagram
that goes from low to high on event and
goes from high to low an event and it
sends actually a toggle event but we
don't use this and then the algorithm
set low or set high is run and you see I
set the state here here i set the state
of all the lamps 20 and here's at the
state of all the lamps 21 it's for lamps
all for blink so let's change this so i
put in in this state a few ones and I
need to make care I'm not like switching
nothing anymore and like one now that's
wrong it's actually a check exactly
wrong I need to do it like this like the
other way around ok so i change this
then i compile it i I don't have a
command line thing for compiling it no
options needed so it they're actually
the binary sees as the actual beam beam
but it also writes it on the on a beam
file and i have a small function that
does a remote load of this of the beam
file onto the notes while it's running
so i do a net load toggle so something
needs to change now yeah we changed it
so we changed the bit pattern that's
okay so let's do another demo because we
didn't do everything let's change this
to zero I I have to say the the the
fourth the fifth nah oh I'm not only
control key anything so the the honking
thing that actually is like half of the
time it makes the system crash because
it pulls too much current when it goes
on so it will probably just go on it
should actually honk on and off but half
of the time it doesn't work so let me
compile this again and load it and hope
it works would be cool if it would work
continuously now oh yeah it works
yeah so that's I relieve you of the
sound so let's move back to the slides
hello yes I'm because I want to add some
future things currently we run this the
function blocks in pin code so we don't
have hard real-time you just have a long
soft real time which is hardened a bit
by running into a hard real-time
operating system where I can actually
control how much is how much the airline
process is preempted I can actually
avoid pre-empting along or task
switching to another task by the
operating system but it's the soft
real-time garbage collections happen and
all on all the stuff but it's actually
pretty neat it's for the use case we are
doing it that would be enough but
wouldn't it be neat if we could have
hard real-time along processes i would i
would find need because I I could code
in that I could just reuse this I don't
have to like compile it to see or
compile it to assembler and then to get
hard real-time I can just get my hard
real-time things so I made a plan and
that's the plan for the future like four
in two years and the idea is basically
how do we get rid of garbage collection
I mean we have to we have we need a next
scheduler that runs on a higher
operating system priority and cam Priam
the other schedulers and we need to make
some choices that that limit what we can
do in this process is so we could be my
plan is to allow everything in there
long but if you use everything and send
huge datas you you lose your real-time
behavior so you need to take care like
but the same you need to do in see ya is
it is it hard n door one minute okay
very very quick so the method is like
this at t 0 i get a message that's
timeline then have the green part where
i do the actual processing where which
is actually the hard real-time deadline
which is the second time and I send off
some messages to another thing that's
hard real-time pikes
network these and then I have the blue
time that's a recovery time until when
I'm ready to get the next message which
basically specifies the message right
and that's a usual thing to do in hard
real-time systems to limit the message
right for a message passing hard
real-time system so if you look at this
next picture if you look at this on this
slide so we have two processes and it's
earlier state line first scheduling so
whoever assay earlier state line is it's
being scheduled gets the highest
priority so at first we we have the
highest priority because we have the
first deadline but when we are done our
recovery has this deadline which is
later than the deadline of this process
which already got a message and is
runnable so this is got run first and
then you have a shorter time to recover
where we do our garbage collection and
yeah I think you get to good then get
the gist we have fixed two-part heaps so
we don't allocate heaps any anymore you
have to say how much memory you want to
have a heap and we allocate two of them
and copy or we use the normal garbage
collector and copy over the data from
one heap to the other if you run out of
memory you crash basically you can
specify what happens like total garage
we start at the beginning we can we
start to the beginning very quickly that
might be a feature if you miss the
deadline you crash if you get too many
messages we limit the message queue size
the input size 2 1 if it feels if it
fills up if the message is not taken out
before the next one comes then we can
configure then send the crashes to
receive a crashes nobody crashes the
message has dropped new dropped I'll
drop you can configure everything and
then we see what we can build out of it
so I'm done questions
there is some there's perhaps a conflict
in building plcs so on the one hand the
industry wants very very reliable bits
of kit that will run with vibration and
diesel fumes and and not crash and not
have industrial process he sort of blow
up row cars run into walls but on the
other hand they use sort of fairly
primitive languages and you've got a
bunch of unproductive programmers we're
very depressed and not very agile so how
do you how do you reconcile that that
conflict I mean you're obviously
building systems with more parts which
can go wrong you've got you've got
regulars your garbage collectors you've
got operating systems and compilers how
do you sell this into industry and give
them guarantees that um that things
aren't going to blow up unnecessarily
yeah that's a good question how we will
sell it I just got the ideas like not
selling it did get but if we go back to
the PLC part the actual pc programming
language is actually pretty safe just
remove it if you so it's use the actual
pues si lang which is actually a safe
language you can do all kinds of thing
in a weekend why I too like summer long
supervisors that restarts them so that's
that's kind of research I want to do
next year how I can get more along
features to the language to the actual
plc developers but for example the
product that the predecessor of this
hardware which were to distributed RFID
nodes which we are reading RFID so
cyclic air is running for one year on
the table of the engineer at the
customer without interruption and it
actually talks to a PLC like you can buy
in the shop and the PLC needs to be
needed to be restarted like five times
in this time because it's actually
written in C and this is reliable so I
think there is a selling point there
because we we are more they slept our
prototype is already more reliable than
a pill see then you can buy so and
basically selling this with the hard
real-time stuff I will use this to
implement the PLC language where they
can't break out and actually they are
not very depressed they are actually
very stressed they have lots of work the
PLC programmers so if you like out the
unemployed or something like learn the
PLC languages it's very easy to get
employment with this yeah talk to me</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>