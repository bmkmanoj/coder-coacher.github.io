<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Stian Veum Møllersen   Revisting Concatenative Languages with Creative Programming - Code Mesh 2017 | Coder Coacher - Coaching Coders</title><meta content="Stian Veum Møllersen   Revisting Concatenative Languages with Creative Programming - Code Mesh 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Stian Veum Møllersen   Revisting Concatenative Languages with Creative Programming - Code Mesh 2017</b></h2><h5 class="post__date">2018-02-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/faHB4MGQIG8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so nice to see that so many of you still
have some energy left in you like it's
the last day and it's a second to last
talk and everyone's tired and overloaded
and everything so hello my name is
Christian and I'm from Norway as well
the symbol you said that's at a weird
country like across the ocean where it's
cold all the time and always dark I work
for an IT consultancy called becasue I
mentioned there I do mostly web things I
help clients out with their various web
needs that usually revolves around
removing your script and not adding more
but in my spare time I enjoy exploring
weird unusual ways of programming things
because that's fun and it teaches me
useful things to use in my day job okay
so today I am going to show you a little
bit of something called concatenative
programming here we have a blank canvas
and blank output it's pretty much every
artists worst nightmare the blank the
blankness of the canvas so we're going
to fill it with something
if you've some of you are not familiar
with the html5 canvas things that's kind
of what I'm doing here so I just melted
into a cognitive style so don't don't
worry
have
is it readable can people read this by
the way yeah it's nice good all right
we're way to the line yes lines are
useful and they're often nice to look at
but we don't want just a line we want
something more so let's start from
somewhere else here
maybe we can do
like this and maybe we do that and final
thing yes no it was queer squares nice
we can do things with square like
we can draw a square many times this is
not terribly interesting in Celtic laws
you just get ten squares on top of each
other that's what they're interesting
but if we every time a draw square we do
something fighting to where the square
is so we can pie can rotate things but
now everything just slides off the
canvas that's not very good so we have
to do some tricks
and now we rotating it around the center
it says because because normally in
Aquila graphics the zero zero point is
up in the left left left top left corner
and everything revolves around that
point so you have to translate it to the
center and rotate it and take take it
back okay so that's not terribly
interesting but there's something cool
we can do that's called
neon etiquette and for that we need some
shallow color we need some lower things
I mean need to okay this is the hardest
part in my entire talk to write this
imitation correctly yes nail it trying
to spell composite operation correctly
every time is quite hard so what we can
do is draw this in very line with
of course something broke there you now
we have this glowing neon effect that's
kind of cool so what if we also do
I don't know maybe take a random do and
we do this get some cool glow a square a
weird thing now I have something that
actually looks kind of arch artsy fartsy
and we're eating all this code and it
looks kind of strange and and it's a
backup slide and and what was that that
was strange right well that was
concatenated programming and concat what
I can capital programming that's just
it's a style of programming I'm not sure
if I'm I can use the word like paradigm
for this but I decided to go with the
safe route and call it style instead and
in this style of programming programs
are constructed by composing functions
and this comes in a composition to what
we normally do by inserting programs by
applying function to values so
concatenative and it's an alternative to
applicative this code sound sounds kind
of strange so let me explain to you
exactly what it is
so in contract programs by composing
functions I said and here's a program
made of a composition of five functions
anyone want to guess what this program
does
no okay it checks if the successor of a
number is divisible by five totally
clear right so this program here the
it's a composition of five functions and
a composition is implicit meaning that
in a concatenative program you don't
actually have to explicit about your
compositions because every time you put
two functions next to each other it's a
composition you can reintroduce the
composition operator
but since it's it's it's actually every
time there's a space there's no position
operator you don't really need it you
can aura can look at it from another
angle and you can see like pipes and now
it took kind of looks like something
with right in a command line and that's
kind of interesting but if you look a
bit closer there's something strange
going on here if you write this program
the way you would write in a C style
language perhaps with parent seasons of
you see something strange because surely
five and zero aren't really functions
their values so why are invoking five
and zero that's that's not right so the
thing is in competitive language there
are no values there are only functions
like in a functional language you can
say that they have functions as values
but here you have about those functions
that's kind of weird so that's the
secret sauce open cavity languages and
that's also why we are able to compose
like this because everything in the
language is affirmation and that every
function has the same interface so the
successor function is a function from
state the whole state to new States and
similarly with number five that's also a
function from the states to the new
state so what the function 5 actually
does its modifies the state and returns
the ATM and the world state can be
anything but usually it's a stack and
that's why these conical cognitive
languages also are often talked about as
stack based languages but it doesn't
have to be a stack it can be so that
would mean you have the kind this kind
of functions you said you take a stack
in any return a stack out and that's
that's kind of interface that for all of
all the functions it sounds kind of
weird so we're going to look at how it
operates in practice here we have the
program 5 the program 5 it puts a number
5 on the state or stack
if I did in the program 510 you have a
ten in the five minutes like I can do
the program five ten plus 15 and this
program is equivalent to this program
that's kinda neat you can do interesting
things with that so if I were to do the
took five modes zero equal thing I
always doesn't do anything because it
kind of requires some pre-existing state
to work so if I put number six on there
this program is salts in the state the
in false and what's actually happening
here is if I just take this part away
this current program it takes the
successor it takes the stack it takes
the top element of the stack it adds one
and put it back and then you run the
program five and the program five it's
five on stack if you don't do the mod
you get a remainder of the division
between the successor of six and five
then you can check that for equality
with zero I need false so I put four in
here get true because this guesser 4 is
5 + 5 is 2 5 over 5 and that's nice
so that's how you would work with this
kind of program and this is also why
many times people talk about competitive
programs being in the postfix notation
some of you might might have used one of
those old HP calculators where
everything was written in reverse polish
notation it kinda looks like this but
the thing is it's not actually an
operator in the saving sense that he
would encode later
this is a function so force function and
process function so this is just a
composition of all the functions the
posting postfix Ness it's kind of
incidental but it's nice - it helps you
think about things if you used that kind
of thinking okay so this business
doesn't seem really expressive at the
moment but we can add the specific
passivity by adding hotel coated
programs or the covert programs aren't
actually quoted programs their functions
adding quoted programs to the stack this
is this is a program that uses a quoted
program this is a filter you can filter
arrays looking for numbers that are less
than 2 or this little program which
takes the sum of all numbers and then in
a list kinda nice it's so small and it's
almost impossible to know what it does
without knowing what you can do programs
do you can also use quotations for
control structures such as if tests and
an if test will take three quotations of
the stack and run top one to produce a
boolean and use a boolean to determine
which all the other two are going to
executed and you can do the same with
recursion you can do anonymous recursion
we list this is a little program that
will calculate factorization of a number
by using a linear recursive Combinator
and Combinator's are in at least
inculcated in current concatenative
world the commuters are special kinds of
functions that operates on this kind of
coded programs so you can say that in a
capital language you have you have
functions and you have descriptions of
functions so you have both the ability
to create the description of some kind
of program and add to it and modify it
and do all kinds of crazy meta
programming stuff you want to so all
good maybe if you compare this this
program to its counterpart this is this
is written in f-sharp syntax I hope
people are able to see what it does
anyways we can see what we gain by
having this kind of style of programming
we don't have to do
composition you don't have to worry
about arity of functions here you have
to flip flipped or events of the mod
function
in order to partially apply one of the
operands and also if we didn't have auto
carrying and automatic partial
application we have to do that in depth
as well so you can see that if you want
to have this kind of point free style
programming being in this competitive
world is nicer because everything is
implicit but the thing is you have to
fit with the stack if you were to
implement this kind of mathematical
formula in the world it would look like
this that's not very nice
the good thing is that we can hide that
we don't have to worry about that thing
all the time and we want to look at how
that would how that would go about this
later
so there are obvious obviously some
there are some benefits and there's some
downsides you can wonder like why did
someone bother to make this why did
someone spend time envisioning this kind
of programming style and the thing is
this there are two very distinct ways
that this thing came about we're going
to look at it because looking at why
something exists tell us a little bit
about how you're going to use it okay so
the first thing we have is for a lot of
people have probably heard about fourth
before it's one of those languages that
gets talked about but mostly I'm like in
a historical curiosity setting and it
was invented in 1968 by this guy Charles
Moore or Chuck Moore as they usually a
go spy and the truck was really sick of
the Tower of Babel and the Tower of
Babel was name he used for they used to
describe the world of programming back
then like you had to when your program
is something on the machine you had to
think about okay you have a compiler for
a language or compiling writing in you
have some sort of an assembler you had
some sort of machinery to
users from interacting with each other
because the imagine you used time shared
machines and all this sort of things
that was keeping him away from his
precious machine I really wanted to get
back to that you want to something
simpler
so he made fourth and fourth was
supposed to be this really thin layer
between the Machine and the CPU and the
programmer and he also wanted to design
this language so that it was portable
and easy movement because back then you
had a lot of specialty machines and
machines that were custom made for
certain kinds of things and he wanted to
use this language all the time so he
just he usually carried with him a stack
of cards that had the fourth compiler
implemented on them so you can just
import them into a variant that's kind
of strange so of course the stack he
became the natural choice for the
program state because when you were
working with machine code relying on
registers it's kind of cumbersome
because registers they've changed a lot
between machines but all machines have a
stack so if you can avoid the registers
and only rely on the stack becomes way
easier to port the program from machine
to machine yeah so it was the whole
problem of register said he was able to
report this this program to at least 19
different CPUs in its time it was kind
of crazy but the thing is the
programming interface also had to be
simple because if the program interface
was really complex them the whole
compiler for language must be complex
and whole interface be complex and
everything would just be too complex to
re-implement the whole time so he used
post takes he actually used POSIX and he
used it avoided worrying about arity of
functions so if everything is post fix
you don't have to think about
parenthesis and stuff like that too to
limit your functions because in a post
in a post fixed world all the all the
operator precedence is explicit because
and all the brands are placed before the
operator so it'll tell every about that
and also he wanted it to be worth
centric so it was more natural for
humans to work in this kind of language
that's why everything is space separated
and it's also had a neat effect that
writing a compiler foreign language
became really easy because you can just
separate on space you can just read from
the input and some space doesn't you
think so implementing your own force is
because of this it's really simple and
it's a great way to learn but the thing
is optimizing for its kind simplicity
turned out to be a good thing for fourth
fourth husband is still used with great
success in a lot of embedded systems
because the compiler is teeny tiny so
this there's not a lot of overhead in in
the compiler itself you can implement it
directly on the hardware most of time
and it's even hurling through space
attached to a comet because NASA along
fourth so yeah using it all the time and
the thing it's like you can also serve
as both a low and the high level
language that's kind of strange because
you think that operating so close to the
hardware would mean you have to spend a
lot of time worrying about hardware but
as you can see later there are some
really cool mechanisms in the way that
connective language works that make it
suitable for we're here emboss a higher
in a low level okay so first we cut in
the style stems from purely practical
reasons this is another language called
joy it was made by a guy called manfred
von Thun he wrote at the University in
Melbourne I think that rope University
and he had some really strange ideas
about programming and he made his own
language to implement those ideas so joy
is a purely functional language enjoy
everything as a function kind of like
the way I describe competitive style
earlier he was really inspired by
Bacchus and his FB system from the from
his paper about Kanda programming to be
liberated from von Neumann architecture
and also commentary logic so he saw that
with this kind of system we can
eliminate variables and thus make
programming simpler so he implements
this enjoy and that's where the term
captive stems from because forth didn't
actually ever use that term forth was
just forth but when this guy had made
joy we get got this theory that we can
use to talk about this kind of problem
this kind of programs ok so he landed on
a simple syntax by wimpiness he saw that
if he turns everything into function you
can you can compose functions without
having an operator because the
composition is implicit so that's why
the syntax in his language is really
simple and also he chose the stack for
the program state because stack has
simple semantics you can only read and
write to the topple stack and everything
else is just handled so that means you
don't have to make a lot of strange
functions to modify the world state you
just have to use like open open loop and
stuff like that and you initially
started with only four kinds of special
functions and but over time anyways so
joy is taken cracking happen this style
comes from a theoretical place that's
kind of strange
you have the one practical practical
solution I want theoretical solution
both and me up in the same place there
are also some other competitive
languages out there not gonna spend a
lot of time on them and mentioning them
anyways you have PostScript which was
mentioned yesterday in marco cuz like us
talk about type that's a neat language
why they ended up with a concatenate
style I'm not really sure they don't
really say an Indonesian stuff but they
were aware a fourth because they said so
so I'm guessing that
PostScript used the same reasoning as
Chuck Moore that he wanted it to be
portable because PostScript suppose
suppose to live inside a printer so if
you can port it from printer to printer
easily it's good I guess then you have C
Python
virtual machine and the JVM or some
virtual machine that's and they also use
in their kind of intermediate language
they also use concatenative style
because working on the stack it's as it
turns out it's really easy to optimize
you can easily do pattern
pattern matching and replacing large
patterns with more and more performing
patterns and stuff like that so yeah
these virtual machines they use stack
based languages and you have a factor
which is probably the most the most
industry ready competitive language to
date it's largely based on the same
ideas and as joy and want even before he
died sadly he said that factor was a
worthy successor to joy and it's if you
want to do competitive programming in a
day job I guess factor is the most
suitable suitable program and also
there's cat and kitten and popper and
many others small toy languages that
tries to implement a type system on top
of asean and that's really exciting if
you really into types and also there are
various attempts at doing concatenative
embedded ESL's especially Chris Okazaki
wrote a paper about am adding a
connected DSL in to Haskell which also
has some really interesting discussions
about typing these kind of languages so
if you're into that I recommend checking
that out ok so like this we have two
different points of view one theoretical
and one practical and they largely ended
up with the same semantics so clearly
there's something about the semantics
that are kind of useful I hope and when
we talk about program programming
languages and programs and learning
about programming and stuff like that we
often hear this code language that does
not affect the way you think about
programming it's not worth knowing that
that was said by Alan Perlis and
especially with this kind of weird
language you would wonder like hey what
what kind of strange sorcery do you
learn from knowing this and as it turns
out someone has already written the book
about this
this book is called thinking forth it
was written by Leo Brody it was released
in 1984 and it is as a subtitle called a
language and philosophy for problem
solving problems and this this book
describes how fourth programmers use
fourth in their day jobs and how they
would approach approach problem solving
in a very 4-3 way okay so this this book
it was had at this time they interview a
lot of consultants working for clients
and I'm also a consultant so when I read
this book I was thinking ugh well that's
the same problems I am having a little
time can't decide what I want so they
have to do redo the program okay they do
that in a in a 1780s and they're doing
it now so how little have we progressed
so there are some striking similarities
to extreme programming and an agile
movement in this book they talk about
things like refactoring and and many
things that later became popularized
through these movements and sadly this
book wasn't widely read so missed
opportunity I guess and also it draws a
direct line between how fourth is
assigned and all the thought that Chuck
Moore put into it and how for
programmers end up working that's kind
of a special there's not too many books
that draws this kind of direct line
between a design language and how the
usual language used to solve problems
that's kind interesting so yeah so it
focuses on simplicity in the work
there's an actual quote from the book
here if you don't understand the problem
you don't understand problem till you
can simplify it there's a lot of focus
on simplicity all the time and this
probably stems form from the simple
simple semantics and also the that Chuck
Moore was so prolific in his search for
more simpler ways to do things and the
thing is in this book they talk about
how we will achieve simplification
through layering
and this is kind of special because I
talked about as Anna mentioned earlier
that when you that the fourth can be
used as both a high level and low level
language and this kind of layering thing
is what's enabling that to happen so
layering is achieved through something
they call factoring and factoring is a
pro continuous process or evolving
software the program the four
programmers they work in cycles mostly
most very similar to what you feel like
the agile cycle where you build
something that kind of works and you you
analyze it and you refactor it and you
move on and to factor it they identified
some kind of rules for when you should
factor things and one of them is to
clarify meaning so whenever you feel
like you need a comment or something to
describe what this is doing you can
factor it and make the make what the
program does more clear you can factor
to give something a name if particular
function represents something that is
central to your domain you can just name
it that and go about your day you factor
to avoid repetition is basically dry and
this is 1984 so it's probably like 15
years before Rubio came around and you
would factor to hide details that are
likely to change so you don't leak
configurable value stretch program I
guess and also it was factor to simplify
eighty is if you have an API especially
working in the concatenative language
you always have to worry about what's on
the stack so if you have to shuffle like
four values on a stack that's bad that's
seven hard API to work with so you can
simplify that that would be good and the
process of factoring creates a layer of
special vocabulary that supports the
next layer so if you were for instance
to
create text editor you maybe maybe start
with cursor position you can create a
special vocabulary for working with
cursors and how that actually translates
to screen stuff it's it's it's hidden
behind the API so when you have this
kind of layers to work with you can then
make something more complex without have
to having to worry about all the details
below and this sound this sounds kind of
obvious now because we have been become
better programmers you have worked with
large-scale system for the last thirty
years and learned a lot of things but
this was back in 1984 that's long time
ago that's 35 years or something so back
to creative programming the thing is I
like to explore things by making fun
things with it because that's relatively
risk-free and I don't have to worry
about not achieving the correct solution
something is I just make something more
fun and this kind of process it fits
really well with the principles of
factoring so they rather read the
thinking fourth book I was like this
sounds useful to me so usually when you
do creative things you start with
something small so instead of instead of
when you're trying to solve a real-world
problem you get something big like make
a text editor that's hard to decompose
because it's been a lot of time thinking
about what kind of parts goes into this
but in creative programming you just
turn on head you start something small
and it's easier to work a person there
then you add something you can tweak
because if you just write lots of
instructions you basically have a
painting and paintings I'm worrying
because they don't move and moving
things are more interesting so you add
tweakable parameters and then you in
randomizer interpolate those parameters
because that's because that's more
interesting why would you make art with
a computer if you can't randomize things
because there
computer can't can't make choices only
humans can so yep and then you have the
the last step which is more multiply and
iterate and the thing is like when you
compare this to the factory thing you
reach this kind of point where you start
factoring your creative program and you
make a new layer of vocabulary so that
you don't actually work with the low
level like to drawing a lines and stuff
you'd work with entries is that for
instance and that's my this make this
seem like this was a good fit so here's
the program from before I'm going to try
and factor this to make it something I
can work work with more okay so we have
the thing here which we know it draws a
square so you can take this out and we
can define a new word square and square
just this
just want to format this does that makes
it looks nicer all right so you can
stick square back in here and we have
the same program we didn't have to feel
around with parameters or anything
written because it's in captive language
we just could you can just chop out a
bit of code and name it and put a bad
name back in that's nice and also here
we have something when doing rotations
on the canvas you have to move the
center rotation to the center of the
canvas and then move it back up after
you're done the rotation this is really
cumbersome because you don't want to you
don't want to have to do this all the
time every time you want to rotate
something so we are going to take this
out now the program becomes interesting
again but we find a suitable name for it
I mean stick name back in now you have
the same kind of function and here as
well what we do here is shifting along
the x-axis and we can take that out and
do the same thing here
mistaking them again
now we have something that is easier to
see what's doing
we have hidden some details away I'm you
can read this this program more fluently
and this thing this is the thing we use
to achieve this guy on the unaffected so
you can take and take this out as well
and you make a new word hold row with
new material that thing is the thing we
have to do to achieve me an effect is to
draw something multiple times with
increasing line width so up here we have
this this part in the square definition
and this part is doesn't really belong
here so just going to take that out and
put it back here because it belongs to
this function here you can do nice this
by the program is looking better because
stammers this program now it it's more
obvious what it's actually doing so we
can do the same thing about some of the
things up here we see here that we have
a color that's repeated twice we don't
want that so it's also a color is likely
to change so maybe we take that out and
just name it
now we can just mention it here here and
I think it's these two lines they
actually belong to the at least at least
three lines actually I belong to you the
new effect don't have to use term here
they belong here
and now you can see that we have
something that this is our program now
we set the stroke style to record it to
the color we don't have to know very
about what color is you just have to
color and then we draw 20 squares that
are rotated around the center and shift
along the x-axis now we have something
that's nicer to work with you can do you
can do better you can also extract some
parameters here to play with so you can
service the drawing of the Neo effect
you can see that we here we always draw
a square they don't want to do that we
can you can draw anything really but if
we take this out and we instead pass it
as a quoted program to the drawn in
effect you can then execute the quoted
program once every loop so here we take
this function will then read the code
the program from the from the stack and
it will execute it when it needs to and
because we are finished with the program
after is drawing effect is done so you
can take it out so now we have you can
put anything in here we can draw a
triangle or a square circle so anything
you want to the same thing about
rotation we here we always rotate pie
9th and that's not you don't want do
that the whole time we take that out
because only thing that is central to
the whole rotating around the center
concept here it's the 250 and 250 things
so we are going to put that in front of
here instead
now you can play with this value if you
want to like yeah this kind of cool
effect and also here shifting along the
x-axis shifting how much I don't know
maybe you want to tweet that so here we
have a value that we can generate from a
random random sample from minus 35 to 40
35 you can just take that out and assume
that this value is present when you
invoke this program so now you can maybe
not shift at all you can do
destiny attack to kind of clean start
it's nice there are some more parameters
you can tweak and I see it I still have
time to tweet oh that's nice for
instance in the square here we have
hard-coded it to be a square that starts
at 2 100 100 in this 200 and 300 wide
that's what very interesting we want to
be able to pass pass with and the
starting point to this function so we
are going to use some cheat codes
because sometimes it's not practical to
only work with concatenate soil
sometimes you want to use name state or
variables so we have a escape hatch that
we can use so we can see that we taking
the x and y so if now in invoke square
here we say that we want it to be
centered in 250 250 it will take those
two variables and and put them into
variables here and now you can mention
those maybe want to instead of having to
duplicate the state although replace but
we also want to say something about the
size of square so you want to say that
we haven't squared as 300 wide so we're
going to save that as
w like this and now it just needs a
little here this is to construct points
so now I can do X Y point and it moves
to that point but thing is like I wanted
to pass in the center so I get something
that looks really strange that's cool
but that's not what we wanted we have to
subtract or add the width so we get to
the point where I want to be so we're
going to do something like this this
takes me to the place I need to be and
the thing is this looks really strange
and E and repeating these kind of
implications gets tiresome the thing is
you're hiding all of that inside the
square definition so you don't have to
worry about it anymore as long as you
get this part right you can use squares
all revised if you want to so let's do
if anyone's ever worked with for
instance oops that's completely wrong
and work with the WebGL or something
they kind of recognize this where you
have to tweak all the all the things
still looks quite a strange yeah that
doesn't matter
it looks cool we can just jump a little
bit because I'm gonna fix all of those
things so here we are back in with the
thing we were trying to achieve and now
we can start working with things things
that's we rotate by four maybe we want
to have like a random with all the
squares like between 10 and 100 this
looks kind of cool 200 maybe 100 but we
want more of them so now we're able to
draw futuristic-looking
square patterns because we affected
factored ourselves out of a bind and we
ended up with a vocabulary that was
easier to work with this kind of
demonstrates the power of factoring and
creative programming all right so the
factoring is both enabled and this is
stated by simplicity because you can't
if you don't factor you're gonna get
eaten alive by the need to always keep
track of the stack so you have to factor
to get around that but you also get some
powers factoring because this is the
simplicity of the semantics of a
language really makes it easy to extract
functionality and then personality and
things like that and also if it's
creative programming real world
okay so in closing thoughts everything
as a function is kind of mind-bending
that really messes with your
understanding of of mathematics as a
whole like you don't have values anymore
you'll nail functions that's weird
limitations help enforce simplicity by
making you think more because you don't
have always have values or something
about you you have to think more about
how able to approach a problem and how
we want to solve your problem before you
can actually go ahead and solve it
that's nice and also creative
programming is a really fun way to
explore and learn you don't have to
worry about not solving your problem you
don't have to worry about doing it right
you don't have to worry about are we
having fun that's nice
here are some resources I think in
fourth book is available as a creative
commons license in the internet so you
can get the PDF when we it for yourself
or you can buy from Amazon the joy
homepage contains links to papers
written by manfred von Thun and we're
going to download the joy binary stuff
like that and I would really recommend
reading the paper about a theoretical
foundation of joy because it really goes
into depth with all these values as
function values of functions and things
at that Michael focus he writes a sign
every now and then and he did one on 4th
and it's really good which me that
there's an interview with mantle on soon
very explains why I designed it so I
enjoy like this and the same kind of
interview with Chuck Moore those two are
interesting and there's a blog post
series by some guy called Daniel that's
called joy of concatenated languages
part 1 2 &amp;amp; 3 that's also really good he
also goes into a simple type system for
a kinetic language and also there's a
blog post called why cook at the
programming matters in the same style as
Y from the primary matters it's also
explains a lot of these things slice and
stuff language I used in my slides I've
implemented myself it's called white you
can find on my github if you want to
play with it also
the slides will be up on YouTube and
also live on the Internet
after representation slides are live you
can go in and try the language yourself
if Monty and all the all the organ
things is also in there thank you so
much for listening and is there any
questions in stuff just grab me
afterwards</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>