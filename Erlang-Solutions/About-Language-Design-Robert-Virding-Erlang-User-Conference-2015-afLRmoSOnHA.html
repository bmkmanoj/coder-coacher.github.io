<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>About Language Design - Robert Virding - Erlang User Conference 2015 | Coder Coacher - Coaching Coders</title><meta content="About Language Design - Robert Virding - Erlang User Conference 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>About Language Design - Robert Virding - Erlang User Conference 2015</b></h2><h5 class="post__date">2015-07-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/afLRmoSOnHA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I've just noticed something funny sorry
quick push yet my computer clock is 20
seconds after the one down here which I
find very strange thing they're both on
the net anyway so I don't know why sorry
yeah so hi I'm Robert I'm Robert Verdi
I'm hello I'm hello robert okay I think
that's the best i can say i have done
other stuff as well too yeah i'm not
going to waste time on my history okay
so these are just some thoughts i have
on language design on designing
languages if it's a philosophy or not I
don't really know you'll have to decide
that yourself but these are just some
ideas I have these are my ideas ok so
I'm not saying anyone else has the mood
in the group or whatever so it's not our
laying solutions ideas is there my ideas
and I would say a lot of these ideas i
feel that valid not just for the
languages but for building libraries of
building systems on top of that on top
of the languages itself i think a lot of
that sort of projects upwards when
you're doing these things for most of
this what this comes from the experience
I've had both in building languages
owling of course the bait a base
language as it's right language of three
levels here we've done quite a lot of
work on LFE which is implementing a lisp
on the a-line machine and the effects
that that has on the Lisp you're
implementing this you're designing right
I'm not going to go through that
specifically but that also affects the
languages are implementing I've also
done a number another other couple of
languages on top of our line so there's
lu l which is a lower implementation in
there zur log which is a prologue
implementation I think nothing gives you
the feel of what's in a language like
implementing it ok when you learn a
language you can learn more or less
selective bits if you're implementing
and you have to get everything and then
you can really see how things fit
together or don't fit together inside
the language also it's a lot on a lot of
other languages I've used so I think I'm
pretty common
like most other programmers I counted
out somewhere between 11 to 13 languages
if not more depending on how you want to
include them in how many you want to
make back together as one language now
guessing this is pretty common for most
programmers to be honest so you get a
lot of effects how do other languages do
it how do they work what you find good
about them what you find bad about the
Meseta cetera so this is a lot where
this comes from so yeah as I said some
of this will be a philosophy some will
just be some ideas I have some will just
be some guidelines advise what have you
want to put it and there are a couple
ones I find I think I've extremely
important here and that is you should
provide tools in your language for doing
stuff you should not provide solutions
right tools are what you give so people
are using your language can build things
again it's the same with your libraries
and stuff they provide tools and then
when someone is using that they can use
that to build what they want and if you
start providing solutions well two
things can happen either you can be had
to have very specific solutions to
specific problems where we can try to
start trying to build in more general
solutions which everyone can use if
you're going for specific solutions once
you start you'll keep adding more of
them someone comes up with something
you'll add a solution to that so I'm
going to come up another one you have a
solution to that etc that gets messy the
alternatives I want to make the solution
then that will become very messy because
it's going to have to handle all the
cases everyone can dream up about it so
you might end up with one function which
does about 30 different things depending
on the combination of arguments you give
this also applies to actually two
libraries so I mean if you define
library for the library with one
function in that does a lot of different
things then you will have various
options and combinations of options
doing different things for an examples
the Aria library and a line which has a
run function and what the run means
depends on all the arguments to
you could have specific ones there so
yeah both of these have to be very
careful with and I think the basic idea
is you should not put solutions into
your language you know you don't have to
solve people's problems you're out to
give them a good set of tools so they
can use to solve their own problems
they're the ones who know what the
problems are and the other ones have to
solve them you can give them the toolkit
this we also found from past experience
when we're implementing a line so when
we're doing the language a number of
times we tried to be helpful and try to
provide tools well sorry provide
solutions from what for what we thought
was a problem people had how you use it
had and generally we were wrong okay we
would make it very nice tour we would
give it to our users would ask them
could they use a solution we would ask
them could they use it now come back and
say no and what it generally happened we
have misunderstood what the problem was
so our solution wasn't helpful so back
the tools make tools instead I think
this is one of the things we actually
succeeded with in the ailing language if
you start looking back at it we managed
to do this very well for other points of
view as well to another one here is I've
got is don't be nice to users okay okay
that might sound a bit cruel but perhaps
is slightly better and say be very
careful when making change is suggested
by users to your language right we'll
see more about how this works in later
but it'd be very careful with this so
why I mean here I've got here you have
your users they come up with suggestions
and ideas why should be very careful
using those and a couple there a couple
of reasons typical one is a user comes
up with all users come up with a
suggestion they want in your language or
in your system in your library and they
often don't see the whole picture they
see what they want to do and they will
not see how this is going to interact
with other things that might that might
be in the system okay
that's very common that that's nothing
surprising so there's nothing strangers
they often don't know what they really
need I'm don't understand to not to to
knocking here but they often don't they
can't make milk they often come up with
an idea what they think they want but
they really don't and often they want
help with a solution not solving the
problem this comes up they have thought
they thought of what the system what
they think the system does then come up
with a solution to those problems what
they think the system is actually doing
and not to put a not a problem with I
know this might sound a bit cruel but
it's quite often this quite same thing
if you're doing consulting you'll find
the same thing with users here so now I
hope our like solution clients won't get
too angry about this but yes so you
don't want to help them you don't want
to give them solutions right you you
want you want to help them yes but be
very careful when they come with
suggestions and really start considering
what how it affects what you're doing
now when I was told to well when I was
doing this I was told I must include
pictures in in my presentation and those
who've seen my presentation before no I
don't have pictures right so I've
included a picture there that's the cat
right yes and this is the no cat this is
the cat that says know when you come and
ask me for something in one my language
is going to say no right this is the no
cat it's the no cat so we'll go on so
that's one thing um yeah I'm not just it
might sound very cruel but I think in
the long run for most people you have to
be very careful when you accept
suggestions so getting now again
something positive I think the most
important thing is the question here
right what problem are you trying to
solve in your language and why are you
implementing the language that of course
there are number of reasons you might be
implementing the language for fun is a
good one I like I appreciate that answer
I can see they will see the benefit of
this but typically you will you'll
there'll be a reason for implementing
your
language okay nothing strange here and I
would say the most important thing is
decide on what the what you're trying to
solve what problem you're trying to
solve with your language work that out
that's not always trivial it might be
work quite difficult to do it you might
want to end up trying to solve all the
world's problems it doesn't work but
just work out what it is and when you've
done that focus focus on that don't lose
focus from what you're trying to do and
don't get sidetracked ok so I'll stress
here again focus focus focus once you
start wandering it can be very difficult
to stop and you will find the quite a
lot of language and quite a lot of
systems you'll find that a lot of good
ideas in there but they're just
wondering you might have the original
focus but someone comes up with a good
idea so that's added someone comes with
another good idea and that's added etc
etc etc and if you look at each of these
ideas they might be perfectly fine but
the total become a mess so be very where
focus on what you're doing and stay with
that and be prepared to say no to things
that go outside you will not make a
language that they can handle everything
if anyone tries to that that they'll
fail so for example the alongside we did
not try to make a language that handle
everything we had a specific type of use
case we're after and that's the language
of a focusing on and that's what we did
very well I would say so focus focus
focus on things right ok so when you're
designing a language i would say
semantics is king that's really what
it's all about really it's the semantics
of the language which determines its
usefulness it's what it can do is
whether people can use it or not if it
does something useful then people can
use it otherwise they cannot do that is
the semantics that's the important thing
but and this is not always easy i'm not
i'm not saying
is easy I'm not saying keeping the focus
is easy i'm not saying working out the
semantics is easy but you have to do it
to decide somewhere and yeah that can be
very difficult so my next point here is
syntax and as you will see I've got some
kind of contradictions in here so yes
syntax is real irrelevant but no it
isn't so what do I mean here i would say
here going completely bonkers because
you have a syntax that doesn't look like
xxx sex is just ridiculous sorry i
cannot understand that I cannot
understand that view right you've got a
manual read the manual I mean get a life
there's a manual read it right if I want
to know what something looks like I open
the manual page looks like that bum
right fat fine why worry if i'll know
something else i'll look at this intact
it's all there mr. ah sorry i get very
worked up about this if you're going to
complain about something okay what I'm
not saying is that all sin taxes are
good I'm not saying I'm liking all sin
taxes i'm not saying all sin taxes are
good but i'm saying that if you get
coming to a language which you find for
some reason I want to learn this
language the syntax is in the manual
read it and do it you there are other
things you complain about you can
complain about the semantics you can
complain about is it doing what I'm
expecting it to do what it claims to do
is they're doing what I wanted to do or
need to do that's something else but the
syntax gone oh sorry getting back on I
know a lot of people complained about
the Allen syntax but seriously when
people start using it after about two
days they've got it it might be more
difficult understanding what they're
doing that's another problem but the
syntax usually goes over very quickly it
once is just artifact it's a different
syntax done there's des Emanuel reading
and of those 11 to 13 10 languages of
mentioning depending on how you want to
include languages they've all got
different syntaxes okay so another sense
just another syntax you do it it's fine
it's easy as I'm saying I mean I expect
most programmers have programmed a lot
of different languages and have
experienced a lot of different syntaxes
and hopefully they grasp it one reason
to learn another language for example
like Bruce Tate's book with seven
languages in same week just to get a
feel for working with other syntaxes
sorry I'm not going to go on here I'll
never get past this point if I if I
don't if I don't get passed down yeah so
syntax it's just it's just read the
manual however when you are designing a
language you should make a good syntax I
mean you should not put people through
greater suffering than they need to run
okay well they might have to pick up and
try and understand what you actually
mean you should make the syntax worse
than has to be but I don't see the
syntax as a reason not to use a language
okay there are plenty of other reasons
you can find for not using a language I
mean if we're talking our line here
they're plenty of reasons for not using
a line but I don't see syntax is one of
them but we're talking on syntax here i
should say one thing the syntax of a
language should reflect the semantics in
some way if you're doing something say a
functional language it should be very
easy clear to see what the functions are
returning what data they returning
because they're always returning
something right for example if you're
making an object-oriented language we're
working on objects and working with
modifying objects then the syntax should
clearly show that that's what you're
doing again this is this is self-evident
I would say but make sure that your
syntax if you're designing a language to
syntax reflects of what the language is
supposed to do and that gets down to the
second one here that if you're designing
a language and you want to borrow the
syntax another language to work with
fine but be careful if you're borrowing
the syntax from a language with
different semantics because hopefully
that language syntax reflects its
semantics and I've got different
semantics hopefully there shouldn't fit
together and doing that you can lead the
problem
you might end up having to manage the
syntax work weather change it or
whatever just to get it or you just get
a very it does what you hope it through
but not what people expect it through
which is very bad so these are some
points there on that gets on to it it's
okay here are some personal things on it
avoid provoked providing alternates in
taxes for the same thing don't make
things unnecessarily complex right if I
have a thing give it a syntax that
provides that thing give a one syntax
for doing it it once is enough and if
you've got many different syntaxes it
does confuse the issue because you'll
see different things doing it and people
wonder well is there a different result
from doing these two things are they
exactly the same we're aren't they
exactly the same etc etc and if you're
like me you'll say but if I've got
different syntaxes and they do the same
thing why I've got more sin taxes and
also it has a side effect it makes hard
makes it harder for newcomers to the
language to actually understand the
language okay because they've got more
syntax to worry about and yes I'm saying
syntax doesn't matter but it can make
the letter learning the languages who
are more difficult and this happens to
newcomers this an especially new program
is they're the worst people cuz they're
the ones are going to suffer the most
for this study these type of things for
it and it's all very well to say yeah
you don't have to learn all these
alternatives just use one of them that's
fine if they're writing code but when
they're reading code they're going to
see all the alternatives you just do
that so don't provide alternate sin
taxes okay and a corollary to that is of
course avoid adding it will avoid adding
syntax for special cases again you just
more syntax to learn you're not pretty
you're not providing anything new and it
just confuses the issue and yeah I know
I can give it for special syntax and
I'll save a few characters and stuff
like this but it's not worth it there
was a link was suggestion in full or one
guy in the lawless was
suggest it was last year about the year
before he had worked out in the syntax I
so if you don't know the basic structure
data type in law as a key list it sorry
it's a key value table and there's a
syntax for doing it writing down a
literal key value table and for every
key value pair you separate that either
with a comma or a semicolon again
shouldn't they shouldn't have alternates
there but they do I can survive it sort
of and he suggested that okay if he
changed the syntax like this he could
avoid having to put the comma or the
semicolon between the separate key value
pairs unfortunately wouldn't work all
the time so sometimes you'd have to use
it and doing this he could save between
two or three hundred characters in his
files right yeah don't you it's not
worth the effort it makes things harder
to read and I seriously believe yes I
don't want to don't like typing very
long things but i like to be very clear
what i'm seeing what i see what i'm
typing and i want other clear for other
people reading what's going on so yeah
we're getting on here okay whoops what
happened now sorry something popped up
on my screen will go back here we go
yeah adding features again this is
getting back to coming what you
listening to users and adding features
be very generally here whether they come
from other suggestions or from yourself
be very restrictive about adding
features to a language okay so I've got
two wonderful quotes here from Richard
O'Keefe and this is very true both of
them because there is no feature that is
not a limitation on something else so
every time you add add a feature to a
language you're going to be restricting
something else if only the possibility
of adding other features to it or
interaction between features quite
generally the more stuff you add the
grated chance you're getting you're
going to get interaction between them
and then you'll get very strange
behavior and then it comes a point where
throwing new features language is a bad
idea it's time to stop and redesign from
the beginning possibly keep leavey that
the M is backwards compatible okay
that's the ultimate right that is so
much crap to your language you just
throw it away start again and you'll see
this in
some languages I mean if you look in
common lisp the format the format
function you can basically run a whole
program as options inside a format
function I'm not saying it's readable
but you can do it right and they find
that a lot of other languages well
scholar someone was saying is over two
pages of operators in Scala I'm not
exerting about that someone said that
I've seen a long list of one's about
this long run but thank you it's a lot
more than two pages okay someone's
missed the point somewhere sorry that
means I'm going to see all these
operators somewhere and I have to learn
them all even if i don't use some other
people probably use them so yeah don't
put new features in there okay this is
not really part of any philosophy is
just as some easy advice I think here is
it's much harder to change something
once it's been released if you've ever
at least something and then come with a
backward incompatible suggestion for it
you will know this you want hindsight
before you read something okay at least
sit and wait a while if at least think
about what you're doing so do i I really
want to release this stuff is it the
right the way it is because once you've
done it you can't change it a typical
very good example of course is the
Erlang libraries and people complain
about the Erlang libraries and one thing
they complain very rightly about the
other libraries is they're inconsistent
the naming conventions inconsistent the
argument ordering is inconsistent
everything is inconsistent about them
that's correct they are and people
complain about that but when we come
back and say yes yes it's inconsistent
will change it they complain even more
because you got the stage you can't
change because people are using it and
it's one thing if you break something
someone's wrote yesterday is something
different if you break something there
are five years ago in their whole
company's depends on it so you can't do
that so think first before you least
I've take a day or two just to consider
is this interface really good do I want
put my name on it or not take things and
yeah I can't stress that we that was
something we missed okay I'll admit that
another thing we missed it was what came
up in Sean's thing about the variables
presentation why didn't we put in
variable scoping in the language I know
we discussed that backwards and forward
to a variable scope from I don't know
variable scoping we decided to keep it
like it was more or less and not change
things but I think that was a bad
decision because it makes things
difficult to understand it also is
different from most other languages
which can be a problem for people don't
have to make things more difficult than
necessary another point is if you're
making a language or a library or
something and you'll make a number of
choices in that document why things are
what they are not just what they are not
you can write a manual saying but why
have you done this why have you made
this choice selection of choices for
things right we didn't unfortunately
when we're doing alling we did not do
that and I was talking to Joe number of
years ago and I'm talking we never wrote
down why and he still thought of Ben
said yeah no we didn't did we and the
reason was well the reason we didn't do
it because we've been discussing these
things jomark a knife so long that with
we felt the more they were all
self-evident of course you do it this
way why would anyone want to do it
another way so why bother writing it
down of course other people didn't think
the way we did and it's a problem I
don't know if you looked at it if you
look at the airline concurrency model in
the error handling model everything
there is asynchronous except for certain
cases of Lincoln unlink which came later
so certain times when you call link
you'll get an error other times you'll
get an exit signal an exit message extra
signal coming back originally was always
the signal but someone I don't know who
decided that you want to be been helpful
again don't be helpful to users decided
that in some cases it would return an
error so now you've got two different
cases do that so being helpfully was
Jackie against it and the original idea
was
everything's asynchronous in the in the
concurrency on the model and we had
thought a lot about this again we never
documented why but we did well that wipe
it was like that that it was one reason
we did it was for distribution so we we
didn't implement distribution that was
crack across week's time you came late
or did the actual distribution
implementation of everything but we've
been thinking a bit about if we go
distributed or when we go distributed
how would we want it to look and then we
arrived at the thing that keeping
everything asynchronous would be better
/ distribution synchronous stuff over
network is difficult time it's bad
enough being a synchronous being
synchronous is difficult so that's that
just some examples we did actually think
of some things some things we didn't
think about and everyone's still paying
for it some things would you think about
so you another point do I have is which
i think is very important be consistent
y'all know it sounds easy and so on but
just be consistent what I mean if
something looks the same it should be it
should mean the same thing if you've got
two things we should look like this is
the same thing they should be the same
thing and if they look if it means two
things mean the same thing they should
look the same I know so very it's some
of these things when you start thinking
about are so self-evident you source
under why worry about it but they're
very easy to forget about so one thing I
can say alling like other functional
languages the path the pattern used to
match against something is exactly the
same syntax is used to build it that's
done on purpose so you can see the same
thing if i have something constructing a
topple it should be the same thing that
looks like something matching a couple
nothing tells you how to do that but
just doing it that way it makes justly
hopefully makes it easy to understand
for people what they're actually pulled
doing so be consistent work on it I
think keep it simple maybe getting old
my memory is going probably but anyway
keep it simple keep things extremely
simple avoid complexity complexity never
wins right keep things as simple as
possible keep your language simple right
often you won't need more stuff in there
and as I say you might get all the cool
features which you can get by adding
things but it will make it easier to
understand what's actually going on so
I'm a great great fan of keeping things
simple for get the simplicity simplicity
get the right things make the basic idea
is simple and leave it there don't don't
add unnecessary features and keep things
simple I also say here I think be
explicit I know this is not always in
but I say it's better to be explicit to
explicitly write down exactly what's
going to happen what's supposed to
happen what you mean rather than trying
to elicit stuff and that people try and
guess what's actually going on be
explicit about everything it makes it
easier to see what's happening yes you
might end up writing more code yes it
might be boilerplate code but you are
very explicit and someone looking at the
code can see exactly what that's
supposed to do okay and what you mean it
to do it also has the benefit that you
you yourself are in a way for student
things happening the background you
might know about you might not think
about again this is type of thing that
will hit newcomers to the language
toward your system if you know what's
going on yeah I know it's going to do
these but bump things underneath and
what's going to work if I be other to
have to worry about no because I know
right if someone else who doesn't know
this then what you might be giving them
things they have absolutely definitely
no idea what's going on and that the
unfortunate that does happen so be
explicit yes for more to write but you
can see exactly what it is and i would
say that often the boilerplate code you
might have to add is generally very
little compared to what the code that's
doing the real stuff right it's
generally very little so yeah
we're getting on point there's one thing
here you're writing your cool stuff
you're writing your fantastic
application or fantastic system but
someone has to maintain this later I'm
enjoying myself now but what happens in
a year's time or if my product or the
company i'm working on goes very well
two years time or five years time this
stuff has to be maintained and following
that I say following the previous rules
like this will make them it will make
those having to maintain your stuff
they'll love you for it because they can
take the code they can look at they can
see exactly what's going on and if you
don't do it they'll hate you for it and
I should say okay why should I worry
about maintenance isn't the most
important thing be coming up with my
stuff and building at making some cool
product not if you actually want to use
this stuff over length of time I have
one set of figures here says 70 to 75 to
80 percent of the cost of a system is
just in the maintaining my third from
other systems much higher so anything
you can do if you're thinking that in
this level anything you can do to help
make the maintaining of the system
easier will save your company money and
make your system better and keep it
going and along so definitely do this
yeah and all these things I've mentioned
I think make it easier to maintain we
had some of these goals indirectly with
Alan we had a goal to make the language
as simple as possible which it is it's
very simple we managed to get the
concurrency primitives and the error
handling primitives down to a very
simple set if you think about it there
are three or four basic ideas behind the
concurrency there's that there's your
isolated processes there's asynchronous
message passing there is a selective
receive and a registering processes
perhaps if you want include that so
those those those the basic principles
behind the concurrency mechanism that's
all there is run the same with the error
handling its links its axis signals and
strapping access that's it with that
other basic primitives that used for
building and we managed to get those
down to be very simple and i would say
that we're probably one of the best
accompanist accomplishments in designing
a line is to get these basic primitive
gallant it's a very simple set and on
top of that you build everything so
we're definitely not providing solutions
we're providing tools for building
solutions i say that's very important if
you look at OTP it takes the set of
tools and puts another set of more
complex tools on top of it behaviors and
things like this and supervision trees
and what have you but again they're
tools to allow you to build your system
and they're more complex tools another
set of tools but there's tool tools so
that idea still propagates upwards there
and if anyone's actually tried to write
a supervisor in straight our line it's
this much code to do a simple because
the tools fit together what what that's
beautiful sorry yeah so getting back
here if I mentioned this before focus
focus focus focus on what your language
what your system is supposed to be doing
and work on that and don't get led do
something else right yeah and well dsl's
dear cells are great I like implementing
languages or want something implemented
dsl for it but all the above rules to
apply if you want to do yourself or
something make a DSL that just exactly
what you want to do and implement that
if you want some another one do
something else then you make another one
and implementing dsl's can be difficult
it might force you to actually think
what you actually trying to do which can
be difficult for but all these rules
apply for that as well there's just a
language right yeah to something to be
aware of and
this is a very last one here's a very
personal point of what I think I I think
some functions and bit of lack syntax
which allows you to hide function calls
is not a DSL okay sorry I'm not I don't
think that's a deer so it might do some
work and might help do something
sensible that's not the issue but I
don't think it's a dsl and implementing
language today in most systems is not
actually difficult Sean was showing some
tools for doing it for in I respect is
there a language which doesn't have
support tool for building a syntax on
top of it has some former tokenizer
generator or parser generators most
systems have it is not difficult trust
me to do that and then you then you can
make a real dsl not try to hack
something in and maybe be cunning right
because that type of syntax will confuse
other things it will make other things
difficult to see because you're going to
use that type of syntax rather and other
places and suddenly I don't acai of
things that our function calls which
aren't that look like function calls the
other way and around I'm not
implementing a dsl and you can be
certain that if you provide this type of
syntax things for it people are going to
use it I can give one our example which
I can say is not my fault a lot of
syntax people hate is my fault sorry
okay I'm the person behind the record
syntax so yeah I like the record syntax
yes I know and people complained about
sorry quick push air people complain
about the record syntax but no one has
come up with an alternative that works
so people have come up with alternatives
that occasionally work or sometimes work
but not always work and so I'm sorry
over the easiest way to keep the
criticism quiet is just asked for
alternatives because you never get any
so yeah and that's that's not like
that's not a lacks in taxes to very
specific syntax you can you see exactly
what it is I'm working on records it's a
bit verbose yes but it's very explicit
exactly what you're doing even the
equals inside inside it so yeah yeah so
it's easy to write
the syntax of new language all the tools
are there you can find them you'll have
exactly the same set of basic same set
of tools something that uses regular
expressions generate tokens something
that uses a grammar typically la our lr
1 grammars to generate a parser good
there so yeah they're all tools there
there is no reason not to design the
language for i mean Sean showed me this
a simple example of doing that using the
more package for it that's it doing it
yourself or it's not difficult at the
end yeah so I would say my three four
things here from is the focus the focus
the focus again focus on what you're
actually trying to do and concentrate on
that and don't try and wander off the
path there are too many languages today
that try and solve all the problems and
end up being a big mess that aren't very
good at any of them run it's the jack of
all trades master of none problem become
a master one thing and do that
simplicity make it easy to understand
what's to see what's going on make it
easy to understand what's going on
consistency always and be very
explicitly okay there my dear so I could
keep talking this for quite a while but
we'll leave it here so that's that and I
can say bordelle I'm sorry but I just
had to do this okay thank you hopefully
no one last me to put to put pictures in
my talks anymore now I've done this only
that
good afternoon one simple question and
do you think that Alex you designers
followed your advice partially yes
partially no but you'll have to ask them
that okay to be honest I mean I I have
these set of rules and if you follow
English you say yes i'll follow robert's
rules here and robbers suggestions it'll
be your interpretation of them and i
would guess that they find their syntax
pretty simple okay because again what
you find is simple is where you come
from okay so yep that's my building
that's yeah that's a question I've to
take up with them but then again I don't
find I find the a-line syntax very
simple and people complain about that so
Lisp is even simpler that's that's
that's where you go okay it's maybe a
question but are older like em and lines
in taxes really necessary in airline
because you have like Dalton the coma
and semicolon and sometimes nothing and
sometimes I mix them all let's well
first handlings common semicolons and
dots think natural language okay I mean
if you look in a natural language how do
you end a sentence with a dot okay we
can add questions that might be going
with father you end it with a dot what
does semicolons to they separate
alternatives literally that's what they
do what they do in our link they
separate alternatives yes the semicolons
not a terminator commas they do
basically sequential things for and you
don't end with it I as I said yeah I
don't have problems with that I know
people are problems with the semicolon
or not ending things like they do in the
XXX or the j XXX language for group for
it we'll see i've written a lot of seed
okay I've written more actually I like
writing C so no people no complaint by
written a lot of
see I'm quite used to see syntax I
personally don't find any problem going
from the C syntax the ailing syntax I
personally find it much better that they
are very different because I then I can
see this is see this is our lang I'm not
I never get the mixed up and I don't
have any problems with the semicolons as
separators instead of being terminators
I know they've been suggestions to add
them allow them to be terminators but I
don't see the point yes I know it makes
it easier if you're going to flip flips
clauses I find that by the time I've
decided to flip a clause the actual
thing of it doing the actual work are
doing is the thing which takes the least
time line it's a time to work out if I'm
going to do it or not that there for me
takes more time so yeah I don't have
that hi Robert you said how we get into
these situations where the users are so
dependent on the rigidity of something
like the API so of the OTP libraries
have you given any thought to the
methodologies that might be able to be
done when you make you want to make a
change for the betterment event of a
library for consistency purposes and
make that user experience more of a
easier transition I a little but I don't
know if you can do that to be honest
right yeah yeah I don't know if I don't
seriously know if you can do that I
would like to make the change but I mean
you could pick a module say say lists
because list is quite partially
consistent partially inconsistent well
it's some things look the same some
things in it there are worse cases yet I
was quick pushy i mean some sometimes
you've got the thing working on the
first argument sometimes a thing working
on it's a sick last argument and
sometimes in the middle somewhere right
yes not good if you're doing some simple
things like doing a name changes or
argument ordering change you actually
quite simply write a tool that would run
through all the code to do that that
would still be a lot of problems even if
you had such a tool for many bit for
many people I mean they've got their big
system it's running there just the fact
that taking all the source code applying
these things to tools coming out with
new versions of everything building
rebuilding stuff and then installing and
again on their system is just a lot of
effort do that
you could write interface libraries but
then you get into a naming problem so we
take lists I want to modify lists I
could write lists too for example which
contains a new and improved list
interface but then i get into the
problem then i have to remember it's
lists to not lists and then you're going
to get people to mix them up and use
them both and then you lost run one
thing i am very jealous about the Alexia
communities that they've been able to do
this change I don't agree with some of
the things that don't like the idea that
been being able to go through some of
the libraries and actually try and clean
them up they've done that because
they're basically replacing the old our
lang libraries or the existing our lang
Ribery's with a new set of Alexia
libraries instead and they're using a
bit of munching of the LX of the of the
module aliases to do that they can do
that that's that's quite nice wish we
could do that wish we could do a Python
to the Python 3 change of it with a line
right well it's not quite done yet but I
mean you could do it could be done it
could be done but are you running run
into exactly the same problems he's have
with going from Python 2 to python 3 the
large proportion will take a long very
long time to convert from the altar than
you if they ever do and that that's a
serious problem with that that's why yes
I wish we could change and yes I don't
like people complaining and not allowing
us to change but I understand very well
why did it why we can't probably a lot
of things we probably should listen to
once in a while but we didn't as I said
we've got a lot of stuff right but a lot
of things we got wrong and I think a lot
of things in libraries could have been
done better if we just had a bit of
thought before we release stuff right
and I'm not saying I'm I'm probably one
of the worst people for that at least in
those days I wasn't really big I don't
really see that see the point with
library with worrying about libraries if
you want something you write it what's
the problem right so if i write a
library for something someone doesn't
like the other they'll go hack their own
so yeah but that it doesn't work yes I
know
okay thank you Robert that by the way is
Mars I showed that last year I still
don't know if our lines on there i'll
still want to get a line in space right
thank you that's it I don't know anyone
in NASA who can do this for you can put
the fight the system in their own I'll
write it if they ask me happily but no</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>