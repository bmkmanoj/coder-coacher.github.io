<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>How to Design a Software Library - Andrea Leopardi | Coder Coacher - Coaching Coders</title><meta content="How to Design a Software Library - Andrea Leopardi - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>How to Design a Software Library - Andrea Leopardi</b></h2><h5 class="post__date">2017-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KM9ESvnl4iU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">have a good posture breathe smile told
clearly do not read your notes out loud
oh wait so that was a joke
Jesus come on oh my god it's the worst
crowd so actually I download the
conference up and there were some people
signed up for my talk that are not here
so are they lying on the internet I
don't think this are being done right oh
so who used a software library showmance
good who wrote software library good
same people I think that you're just the
ones I want to race ends but who knew
that today was national puppy day oh
 sorry I forgot one joke so this I
just want to say I'm really passionate
about writing social libraries so this
is should be like the side note all of
the title signs of libraries otherwise
so who know knew that today was national
puppy day nobody today is national puppy
day just national puppy day calm so he
might talk about software libraries
turns out I'm the author of several sort
of libraries in elixir which sounds
really dumb for me to say because I for
years I thought that several meant like
a ton of stuff but it turns out
that several means like more than two
but not many that's the definition of
zero which is true like I offered more
than two but not many libraries but it's
so silly for me to say but I really love
working on libraries it's how I got
started with elixir and learning elixir
I really love to improve the ecosystem
to give back to the community and to
write stuff that I end up using anyway
so and I really want to talk about
mainly two things the first one is the
is what of software library so what are
they why do we write them
what do we do with them and the second
one is the power source elaborate so how
do you write design think about a
software library and evaluate a
philosophical but is good or bad
my point is that writing good libraries
I think is quite hard and especially if
you don't have either experience writing
them or you don't have guidelines on
writing them and you don't don't think
about this stuff so my name is Andrea
and I'm the one on the left in the
picture that's my handle on github I
work at a company called force of
football which we make a football app
with live scores and football data
soccer for us people but I don't really
care about football at all but that's
okay because the company's just a facade
for harvesting core team members of
elixir so this is the whole elixir core
team and these are the people that work
at the food products so we're just
trying to like gather all the core team
members that we can we still don't know
what we're going to do with them
but we're going to harvesting them in
the meantime and you might have seen
that my face is up there so I'm in the
mix of core team and yes they know so I
come from Italy from a town that's
called L'Aquila which should be fun for
you because it literally means the eagle
I think us people have a thing with
Eagles right yeah and we're it's a
pretty small town but we do something
really famous which is suffering so like
the proper Italian saffron comes from
where I'm from this is what I like to
call luck without the sufferer San
Francisco of Italy or justice of
Francisco
ah I'm on a roll so this thing gets
Sweden there's a map I drew ho Sweden
and I actually live here in Gothenburg
Sweden not in Italy even if I'm taking
some time off traveling right now and
doing the digital normal thing which has
been really hard because I've traveled
really is not a lot of time compared to
the time I spent in Italy because I mean
Italy's just the food and the Sun is so
hard to leave ok so just when I get to
the meat of this whole or tofu of the
talk if there are vegetarian people
around this is a thing so you're the guy
laughing is just like I've seen my heart
thanks so the first the first thing is
what our software libraries why do we
write them why do we use them and I
think the key word is abstract
abstraction right so we tend to write
software libraries to abstract itself
and we tend to use software libraries
because we want to use those
abstractions so we write libraries when
we want abstract stuff that is general
enough to be reused in multiple things
but they don't see it really in the
programming language or ecosystem where
the libraries in which library leaves
basically and from my experience I think
the we mainly abstract two things two
types of libraries so we abstract mainly
two things and the first one is we have
shot complex code right so we abstract
code that is easy to get wrong that is
full of corner cases there is not
application specific so just complex
code that we don't want to write over
and over again and we don't want to get
rights over and over again and the other
thing that we have to abstract I think
is patterns and ideas so when we
abstract part in patterns and ideas we
have struck things that give you tools
to shape solutions for problems so shape
your solutions to your problems instead
of just just drilling down and
abstracting just complex code so they
they kind of give more context to
solving problems and I think these two
obstruction to come to school and
patterns and ideas map to two main types
of types of libraries which I came up
with because I couldn't find any
literalism this may be tea but
I think this like from my experience
boils down to two types of libraries and
the first one I called let me handle
this for you so I will find better names
but let's go for with this for now but
these kind of libraries kinds of library
are basically the ones that abstract
complex code so the libraries that just
take away the complexity from your
library but keeping a very simple
surface from the library basically so I
think example can make this simpler and
a good example is database drivers so
database drivers what they do is they
obstruct away all their complex parts of
communicating with the database right so
the network interactions the protocol
the mapping of data with database but
they're usually the API of a database
driver is quite simple in that it just
Maps what you can do with the database
and imports it basically to your
programming language so and in this they
again they just abstract all the complex
interactions we have the database but
they don't do much more they don't
introduce
where concepts they just map basically
the database to your programming
language right so let me handle this for
you means that you usually just give
give them something to do and they do it
and they return something back and a
good example of this another good
example is calculation library so if you
have a library for example to do
integrals or whatever the code is tends
to be a kind of complex and you don't
want to write it over and over again but
it's really like the surface of the
library is really simple to just I
integrate this function it spits back a
number it doesn't introduce weird
concepts or new ideas basically and a
concrete example of a library that falls
into this category that I wrote is radix
which is a Redis client for elixir and I
read it's driver and so the surface of
this driver is really really simple so
it's just you can spawn a new connection
which just instantiates
disappea connection with Redis and then
you kind of issue
two rallies and as you can see just it's
really Maps kind of maps one two one two
what you can do in red is just open
radius
console and send comments and get
responses back basically but the code
that lives in the libraries more complex
than that
it handles stuff like TCP connection the
network stuff the network going down and
reconnections and it handles the
protocol for readies and then those
multiple clients want it to connect to
the two radios concurrently so the code
is much more complex but surface is
really what you would expect from just a
very dumb simple driver right so this
for first category of libraries they
abstract complex code basically without
introducing to too many new concepts but
the other category of libraries I think
the other extreme basically is here so
you handle these libraries so these are
libraries that kind of try to shape the
way you think about problems and the way
you solve problems and a good example of
this is right in our along I think it's
behaviors so behaviors tend to abstract
they're not probably libraries but they
they do abstract some patterns right so
for example in Erlang it's really common
to have a client a process that keeps
some state and that serves requests and
respond response so like a generic
server basically and we have gen server
for that and that obstructs the way it
obstructs away some complex code as well
for dealing with system messages and all
the stuff but it also absolute like it
gives you sir terms to talk about and
think about your problem basically so
when you when we say in the wrong
community when we say gen server we know
what we're talking about so we have this
abstraction that we can talk about and
another good thing another example of
this kind of libraries or frameworks or
frameworks usually tend to fall into
this category in my opinion so things
like thing like rails or Django or
Phoenix they the code is not super super
complex especially phoenixes but the
behavior basically the the concepts that
they introduce to solve the problem of
web
frameworks horrible requests is they
provide a lot of tools to do that and an
example of concrete example of a library
that I wrote that falls into this
category in my opinion is a validation
library that I recently released called
soul so this library is for validation
and confirmation of data which is a
quite common problem so validating
possibly external data and conforming it
to a given schema and the validation
itself it's really application specific
you can't really you can really abstract
away how you validate the data right but
you can abstract away the tools that you
use to validate the data and to conform
the data and the tools that you use to
talk about validate validating data so
the real value I think that this library
provides is basically ideas just ideas
so it introduces the idea of a validator
which is something that takes a value
and says if it's valid and it conforms
it or it just says it's invalid for a
given error and then it provides ways to
combine this validator so like this
one-off would combine a bunch of
evaluators and then the first one that
succeeds the whole validation succeeds
so it provides just the idea of
validators and the way ways to combine
these values but then you have to write
your own validators in this case we use
like some boolean functions what you use
in your application you're probably
gonna write your validators for your
application logic so it's kind of vary
and the code for this library is super
super simple so I think the real the
real value is just they but the API for
example it's not that small because
there's a lot of like combinators for
validators so and it provides I mean in
the value that it provides I think it's
just the ideas mostly the ideas at least
not really the complexity of the code so
these two kinds of libraries they're
there they're not there's not a hard
line between between them I think that
many times they overlap they took a
Tyra's overlap and many times the here
so you handle this category kind of
includes the let me handle this for you
category because there there's a lot of
very big libraries that introduce a lot
of ideas but I have a lot of complex
codes in them support those ideas as
well
so this is the I think the water
software libraries why we write them
the keyword is too abstract I guess but
the and the next thing that I want to
talk about is how the the more the meet
so how do we write software libraries
and think about surfing libraries and I
want to do this in terms of what makes a
software library good because if you
know what makes a software library good
in my opinion of course and if you know
what makes it soft library good you're
gonna be able to think about when
thinking about this stuff when you're
writing a soft library you're gonna be
able to evaluate software libraries when
you have to use one so if you have a dis
set of criteria to strive for or
evaluate libraries and the first
criteria I would say is that a software
library I think should be extensible so
extensibility it's a really important
quality and if you don't have
extensibility basically your library is
locked in and it only can only cover a
set of use cases that users gonna have
and either they can cover all of them by
building the library or they can cover
only a part of them and let users with
nothing to use when they need cases that
you don't support right and I think in
extensibility it's all just that so busy
you support all the cases all the use
cases that you can and then that make
sense in your library but you provide
extensibility points for when users need
to do something that is outside of
basically the the common area so they
need they need to do something specific
to their use case they can they can just
extend your library to do it instead of
just dropping the library and I think a
good rule is an 8020 rule about having
80% of your library of the common use
cases covered in your library so built
in in your library and 20% the rest the
remaining 20% be extensible so if you
have what this means means like the 80%
of the most common use cases should be
implemented in your library so that's
you you actually can as a user you can
just write a small amount of code to
achieve what you want to do in these
common cases right but the rest the
remaining 20% is for when users have
a particular use case so then they just
need to write a bit more code but they
can still take advantage of your library
basically instead of having to drop it
and a good a concrete example of this
that we have an elixir is in an electric
bill to mix which is kind of similar to
rebar so mix provides this mixed shell
behavior which is a way to basically
write backends for the mixed shell so
when you output info messages or error
messages when running mix comments you
can have them go through a custom
behaviour custom mix shell basically and
this is configurable at runtime and it
swappable and having this as a behavior
it so it's already the 20% extensibility
part right because having the 20% sorry
having the next shell configurable means
that if you have a weird use case where
you have I don't know you need to send a
lot of messages to a file or to slack or
whatever then you can write your own
back-end basically for the shell and
it's gonna be enough but since there are
more common use cases there are very
some very common use cases we provide
some of those as well so basically you
can say if you want we provide mixed
shell I owed it just prints commands to
standard output we right make the shell
process which has sends messages to the
current process so that you can use that
in tests to assert that some something
was printed on the shell and makes shell
quiet just mutual message so this these
are quite common use cases that you
would end up probably not all of them
but you would end up implementing some
of them in your application so it makes
sense we provide them so the users don't
have to write them but they're still
just part of the whole extensibility
mechanism so they're they're the most
common use case that are already covered
and just you write this line of code
that says switch to Meeks shall I oh and
you're fine and you don't have to write
any of any other code but if you have a
query this case you can just hook into
that basically and a good thing about
extensibility I think is to have
get-out-of-jail points in your library
so I read this get out of
points in a library and it's stuck in my
head because this is like well if if you
have a library it's going to probably
abstract something as we said and when
you abstract something you're gonna read
about this article that that theorized
this lo of leaky abstractions which says
something like if an abstraction is
complex enough it's gonna leak and leak
meaning that it's gonna make it's not
gonna map one-to-one to the thing that
it's obstructing on its go you're gonna
lose some features of the thing that
you're obstructing on in order to
abstract and a level above right and if
you have this get-out-of-jail points you
can try to basically feel the holes in
the abstraction because you can let
users drop down to the lower level of
the abstraction so that they can do
stuff at the lower level so they can
just talk directly to the thing that the
library is obstructing basically instead
of going through the library and a good
concrete example is I think the fragment
function that we have in actors or actor
is a database layer basically for a
lecture that suppose supports multiple
databases and it has a quite reach query
language built in elixir and this query
language provides all sort of SQL
functions basically like where select so
it probably makes it easy to build
queries out of elixir but it can cover
all the functions that you can come up
with when dealing with SQL queries right
especially because since it supports
multiple databases there are there will
be databases that don't support given
functions so again function so it will
be hard to get one size fits all query
language so if you have with this
fragment functions basically can pass
any string and integrate any string in
an SQL query and you still gonna get
like this query is going to still be
sunny sanitized it's gonna still get
some compile time features of the out of
the query language but you can drop down
basically to the lower level of
abstraction so the abstraction layer is
the over the query the SQL query
language basically but you can drop down
to the direct SQL language
just put it like piece of SQL in the in
your queries so that you abstraction
doesn't leak anymore you have a way to
like stop the leak in the abstraction so
it good stuff library has definitely has
to be extensible in my opinion and
another super important characteristic I
think is composability right so a good
software library has to be composable
compostable may be mostly composable I
was composable all right
what okay yeah not really funny but so
composability I think it's really
important when running when trying to
write a surfing library and when using a
social library so by making a library
composable basically or allowing it to
be plugged into existing systems and to
be used together with other components
of the system that are composable as
well in the same way right and to
achieve composed of business in a
library so one of the things that I try
to try the things that I try to strive
for is to use the existing language
features in the language you're writing
the library in in so if you're gonna use
existing language feeders probably there
are other other pieces of software in
the that languages that are using the
same language features and probably the
language provide tools to use these
features and so you're gonna make your
library composable with the existing
system basically by making by using the
same language features right an example
of this in elixir in stream so elixir
provides this notion of stream this
abstraction which is an abstraction over
lazily computed collections so
collections where you can compute the
next element just on demand when you
need it not eagerly and so this is part
of the elixir is part of the language
and so me and a friend of mine wrote a
Cassandra driver in elixir and basically
Cassandra provides a way to paginate
so you you can get just a subset of the
results of the query and then your issue
the query again with a different offset
to get the next subset of the query so
you didn't have to you don't have to
load the whole result set from the
database when you want to do a query
with a large result set for example and
basically if you think about this set of
pages that that form the result set of a
query you can think about it as a stream
right because it's a collection of pages
and you can compute the next one on
demand by just issuing the query again
and getting the results and so basically
we provide this function called X and
restrain pages where you provide a query
and it returns the stream of results for
this query and since this returns a
stream and a stream is something that
believes exists in the lecture we can
use the liquor tools to work with it and
one of the tools that we can use for
exact is this task sink stream function
so this function takes a stream and it
basically is a parallel map so in a Maps
the mapper function over the elements of
the input stream basically and in
parallel so it spawns across a process
for each element of the stream he runs
the function the mapper function in the
process and then it aggregates the
results and returns another stream so it
just basically processes the stream in
parallel and returns another stream and
with a bounded limited set of processes
you use a bounded set of processes
basically we don't spawn one element for
one process for each element in the
stream but you have like a window of
process that you can spawn and you
process windows of elements in the
stream basically and this if if you
provide a stream if we return a stream
from Cassandra stream pages we can use
this function to basically map over in
parallel over pages of results that we
get back from Cassandra right so you get
back each page which is going to be
processed in parallel and the result is
going to be returned in a further stream
basically and then we can use something
like a numerous to aggregate all the
results of the mapping in a single final
result and if you take this example so
three there's three lines of code and
only one we actually implemented right
the other one are just
they just available because we chose the
right abstraction and the right existing
language feature so if by returning a
stream which is and again an existing
the elixir concept we can use all the
tools that elixir provides to work with
streams so we're gonna get like a lot
out of just language and libraries that
the community could have built at work
with trained by just returning a stream
basically so using language feeders
definitely helps with composability and
our thing is to I think it helps if you
know the existing conventions so if you
know the existing conventions in the
language and in the ecosystem you're
gonna be able to use to compose your
library with libraries and tools and
code in the echo system that uses the
same conventions basically so a
convention in the Erlang world is to
return from a function that can fail is
to return ok term if the function is
successful and returned something over
error reason if the function is not
successful and aresult with again reason
and in the sole the validation library
that i mentioned earlier i basically
started out with validators being just
functions that return these right
because this is so if the validation is
successful they return okay and the
conformed term which can be the same
term and or if validation is not
successful if the term is invalid there
is an error and a reason and by doing
this I was able to start out with a with
something that already exists basically
in there like community so there's
there's a lot of functions already there
that have this signature right there
okay term when something goes right an
error term if something goes wrong but
then to further to make the library even
more composable so I thought that
predicate functions that take arguments
already are some kind of validation in
them in in itself right so for example
guards like his binary is process
they're they're validating that the
thing that you're giving them is what
exists a binary or is a process so I
thought that it would make sense to have
a leaders field so functions they can be
also function that
return a boolean instead of okay term or
error term and this would just mean true
if the data is valid and there's no need
to confirm it and false if the data is
not valid and by doing this I was able
to use a much wider range of functions
that already exist to as validators in
so basically so you
I made this so I didn't you don't have
to write wrappers around boolean
functions in order to convert them into
validators basically that's the idea so
the library became more composable by
choosing the right convention basically
so library has to be extensible as I
said has to be composable and I would
say that has to be easy to use in order
to be a good library so when you're
trying to when you're writing the
library try to strive for easiness of
use and when you're seeing a library
it's not easy to use they usually
something fishy going on but to be easy
to use I think so a library I think good
qualities to be easy to use our
consistency so consistency I mean
consistency in the API of the library
consistency in the ideas behind the
library and I think this this is summed
up I think by something called the
principle least astonishment which kind
of means
don't break the expectations of the user
so don't do something that the user that
would surprise a user in your library so
just be consistent be be coherent in
your library
another good quality to make a library
to use I think it's transparency so I
usually try to write libraries that that
probably an abstraction that is thin
enough that you can kind of see through
the obstruction right so if you write a
library there's a huge abstraction layer
basically provides their abstract so
much it's really hard to get what's
going on when you use the library right
and I think if you write more libraries
that are thinner and that have like
thinner layers of abstraction and you
can post them it's going to be easier to
both drop down to the lower level of
instruction also to understand what's
going on in general and 1.x concrete
example I think I have for this is to be
transparent in the resources that your
library uses
so for example radix the the Reddy's
client I was talking about earlier it's
pretty transparent in the resources that
he uses because it says if you spawn a
process a radix connection basically I'm
gonna use a TCP connection to connect to
Redis and that's all the resources I'm
gonna use and by doing that I basically
give control to watch resources very
news to the to the user of the library
so the user can decide if I 100 TCP
connections I just have to spawn 100
Reddy's process
Reddick's processes right so I don't
hide anything about the resource usage
and I give control to a user and this
makes I think the library more
transparent because then the user can
can basically decide what to do based on
their needs and last thing to be easy to
use I think a library has to have super
great errors so never do something like
this because never basically ignore the
the expected failing case right so if
there's something that can fail in a
library usually try to address it
libraries are generally not the best
place to have let it crash in practice
basically because you'll you really want
to you don't want people to have to dig
in the code of your library to find out
what was wrong
find out what their error was so you you
wanna you usually try to strive to
provide good error messages and possibly
even solutions suggestions on how to
solve those aramis it's all the problem
that cause error messages and actually
the last last thing that I think it's
important to have a library easy to use
base to commentation actually let me
blow this up it's really I mean this is
really super important I think and and I
never write anything without I try never
to write anything even the intern was
called at work without writing
documentation for it because when I
write something I'm the writer I'm the
author of that but like six months later
and usually a user of that I'm not I'm
not touching that anymore so it doesn't
make sense that I have to read the
source code to find out what what's
going on with my library just because I
wrote it
since I'm I'm
I'm acting as a user of it I should just
be able to look at the documentation as
any other users of user of the library
so I try to write Docs just the
condition just for myself basically
I think library without documentation is
just usually I just tend to drop it and
not use it at all because it's just too
hard I think documentation is another
level basically of it's different than
having to read the code so the
communication is is for humans code is
for computers mostly right so I bury as
I said has to be extensible composable
and I think another easy to use and I
think another good quality is focused so
this is something that plays well with
composability I think so a library that
is focused that doesn't try to do too
many things it's gonna make writing the
library and using library much easier
because if you're if you strive for
composability as well along focus
basically you're gonna have as kind of
small focus library that does one thing
but it's easy to compose with other
libraries and then you can make the
system as complex as you want but the
pieces remain as simple as possible or
as focused as possible and they
basically try to do 1h does one thing
and it does it right so we talked about
what are software libraries what why do
we write them why do we use them and the
key word is abstract as I said so we
write them too abstract complex code and
to abstract patterns and ideas so we
have on one side this let me handle this
for you libraries as I call them that
abstract complex code and on the other
side we have here's how you handle this
library I call them so libraries that
abstract provide more mostly ideas and
patterns I said of code and then it's
also about how to write a good software
library what are the criterias whether
the qualities that make a library good
and I mention extensibility I mention
composability is nests of use and focus
of the library and I hope that I've
given you some some criteria and to
- to evaluate libraries and to think
about when writing libraries so that we
can all improve the ecosystem together
as a users and writers of libraries
thanks you're plenty plenty of time for
questions right unit tests I mean should
I even mention that of course just write
unit tests for all the code that you
write that doesn't I didn't even mention
like write comments or write in then
code correctly I mean yeah yes do do all
this stuff when you write a library do
all this stuff that you do for all code
that should be done for all code in the
world and also do this stuff that was
fine
yeah yeah so I think one thing is that
this is a really good question and I
think one thing is that if you can focus
only on performance when you're writing
a library thing because it's gonna
compromise all the other things that
libraries trying to do slowly all the
abstraction I think if you're if you
need performance really bad you're
probably not gonna use you're probably
gonna roll your own solution anyways if
it's so critical to you so I usually try
not to strive it's kind of 8020 again I
mean I try to do like 80% that that I
try not to slow down things too much but
I don't like I don't destroy the library
just to make it super performance but
unusable or hard to use or hard to
understand because if you need that that
just proves first of all maybe you're
not using the right tools maybe you're
not using the right abstractions but
maybe you want to roll your own solution
anyway so I try not to strive too much
for for performance I just try to I
think was it Joe jerm song that said
right it should be should work should be
pretty should be fast in this order I
think so yeah sorry yeah yeah that
doesn't work anymore but yeah that was
the line
then code there injects code in your in
yourself I usually don't like that I
think that kind of goes against the the
transparency of of things right so I
mean so plug plug it's kind of an
exception because I think plug since
it's a very so since a very famous
famous library right and it's it's very
much in the I think in the in the here
so you handle this category so it's kind
of a library that introduces mostly
ideas right it does code as well but
it's it's introducing a lot of concept a
lot of so we talked about plugs like we
know what they are right but they're not
the thing outside of plug right so it's
introducing this concept and this
libraries and especially libraries are
like institutional for example plug is
an institution for leaks right is how
you do HTTP in elixir arguably and so
they're more I think they're kind of
allowed to do this because you like
they're super document that their users
use them a lot so you really know what's
going on underneath at like I think I
get its to some to some degree sorry
yeah yes so and basically I think that
that so this kind of libraries they're
kind of more more more allowed to do it
they're kind of they're kind of
forgivable when they do it because
they're so they're so famous and people
are f so much terms to talk about them
basically but in general I try not to do
that at all because it's just it's an
abstraction that you that it's really
hard to like injecting code is something
that is really hard to make transparent
right because how do you how do you show
the code that you injected how do you so
it's hard to document so it's kind of I
try to stay away from it but when I do
so a good example in plug for example is
if or in general when you define
functions in a module through use for
example in a mixture right you inject
functions in a mode you define functions
in a module basically in that case I
always try to define a behavior for for
those functions and when I inject the
function language
the at behavior line as well and then I
document the behavior basically so I say
like this is this is these are the
functions that are generated and Joe
Grantham has callbacks of this behavior
basically this is one one thing that
your practical thing that you can do and
I think that plug probably does this at
least for blogs I mean when like when
you in create like plug router it
defines call and I need for you and
they're done when turning the plug here</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>