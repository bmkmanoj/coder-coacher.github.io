<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>BUBBA - Benchmarking Using Browser-Based Animation: Jay Nelson | Coder Coacher - Coaching Coders</title><meta content="BUBBA - Benchmarking Using Browser-Based Animation: Jay Nelson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>BUBBA - Benchmarking Using Browser-Based Animation: Jay Nelson</b></h2><h5 class="post__date">2012-05-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/q548LHCs79Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I this is what I was wearing in my
speaker picture it's too small to really
see the story in there but my tagline
was I'm driving the monster truck of
data jaws to do dynamic browsing dynamic
benchmarking in the browser so this is a
way to take Yost run it embedded as an
included application inside your Erlang
application and then use JavaScript and
modern tools along with yours I think
there's been a big discussion recently
about all the new mochi miss Alton
cowboy Chicago boss all those they get a
lot of rep cause nobody really talks
about it used to be that you couldn't
embed it now you can so this shows a way
that you can bet it if you want to
follow along on the code I've got two
projects on my duel mark github dual
marks sort of my official products I
have a separate github for that I do
other personal development but DK y oz
is a wrapper around yas that does all
the embedding for you yours is a a web
server that's similar to Apache in its
origins and it's been around for more
than a decade so it's stable solid it's
got a lot of features that have been
added for performance reasons and it now
has modern things like web sockets and
so on but I'm showing here just using
standard old jaws in a PHP like manner
running with JavaScript so DK Yas will
let you embed into your own application
just by changing a couple config
variables if you use rebar and not have
to do anything else and now you've got
yours in your application Bubba is the
application where I'm demonstrating the
capabilities of ya's inside an erlang
application and that's showing measuring
performance of Erlang internals and
displaying the results of the benchmarks
graphically and for that I used III d3
is a really great tool
or graphically representing data so the
goal is to run a benchmark server
collect the timing results and animate
the data graphically the technique would
also apply to any other data set though
so if you've got dynamic data and you
want to feed it into a browser that a
user can interact with and display that
information then this is a great example
of how you would go about doing that
here's here's sort of what my
benchmarking tool looks like I've got a
form over here where you choose what you
want to benchmark and then you get your
graphical results in what I'm showing
here is running a benchmark which sends
back results using Jason as a set and
then I graph that set but if I were to
have a long-running benchmark I can
switch to using web sockets and stream
back the data and have the graphics
changing dynamically over the course of
hours or whatever the problem with the
approach i'm using is it a timeout in
the browser if it's a big test and so
you would want to switch to a streaming
approach but by embedding yaws you have
every option and that Yas has available
so the browser is for the user to
interact start the benchmarking and to
view the results i use yas to parse what
the user is requesting and then the
application itself is the Erlang server
that's going to run the benchmarks that
are accessible through the form and d3
has not just graphics tools but it also
has built-in tools for dealing with
arrays Jason requests different
different things like that that you
would want to do in an application so
it's a simple call with d3 to make a
Jason request to the server and get the
results back and bind it to the graph
but what it does let you do is a very
generic approach to embedding graphics
so that you can change the visualization
without affecting any of the other
it's in this system so I try to separate
everything into pieces that are
independent the interaction with the
user is happening with html5 and the d3
representations in the browser and so
you can style that independently of
anything else in the system and that's
one of the big features of d3 is that
it's declarative rather than procedural
so it came from protiv is which was
developed Mike Bostock as Stanford i
think it was developed protiv is and
that was a language sort of like
processing that let you display graphics
but you would call functions to say draw
a draw a pie chart animate this part of
it and any time a new feature was added
to the browser then you would have to
add to that functional language of
graphical symbols so he abandoned protiv
is and moved to d3 which is data-driven
documents and the idea is that data is
coming in or is going away and that
should be reflected directly on the
screen but it should be styled similarly
to the rest of the application and so it
uses CSS style and SVG or HTML
components and lets you apply the style
using style sheets or change the
visualization by changing the SVG
components that you're embedding but
it's done in a declarative mapping the
data directly to Dom objects in on the
erlang side we've got a Yas which is a
complete application standalone by
itself but I'm running it here as an
included application embedded inside my
application and then the benchmark
server which is a little test program
but you would install let's say you have
a production system that you want a
benchmark in its environment as it runs
then your server code would be here and
it would include ya's and then the
benchmark functions that you would want
to invoke get exposed out through the
HTML so that they're called via yas
here's sort of the message sequence that
happens you know you pull up the index
AWS a file which which i'm saying i'm
using the PHP style approach embedded or
laying in the HTML page Yas has a
feature to essentially write PHP using
an erlang style and that turns into an
index HTML which has the form that the
user interacts with and that gets sent
back to their browser and then they fill
out the form and submit it which goes to
d3 that's the JavaScript that's embedded
in the page and d3 then makes a Jason
call to the auth server which runs the
benchmark sends back the results as
Jason and then d3 can display the chart
in the browser and the reason I want to
do this style is because if we go back
the not only do I want to separate style
from the server but I may also want to
separate execution from the
visualization so if i'm running a ec2
server or something that may be off
somewhere else and I need to have a
remote protocol between the browser
where the user is viewing it so I wanted
to stick with Jason as sort of a
standard way of doing that but d3 makes
it really simple to do that so I'll show
that some of the code so the code i'll
be showing as a mixture of HTML and
JavaScript and Erlang but if your follow
along on github you can see all the code
so the first step is embedding yaws and
that's a DK y oz is a full rebar
application that's open source up on get
up and if you just list that as an
included application in your application
that's all you have to do you now have
yalls running in your application you
can do
any notes features directly so inside
the app source of DK yas I've got and
this doesn't show very well with the
resolution reduction here in my
application description that's used by
Erlang for the app but also the rebar
build in the included applications I've
got here crypto SSL I notes and yaws now
normally everybody that does open source
makes applications they assume their
application is the top-level application
people want to use it will just run it
and then they'll call to it nobody
really ever seems I haven't seen one yet
where they use an included application
what included application does it says
your route supervisor calls the route
supervisor of the other application and
so now that that supervisor is
supervised by you whereas if you if you
list it in the applications section
you're both at the top level if yours
goes down and your applications
dependent on it and it's not going to
work and you won't know it's down if you
make yah's a permanent application and
yaws goes down the whole node goes down
now because it's a required application
and it's down and you probably don't
want either of those sometimes you do
want the whole node to go down if like
bread us goes down and you don't have
anything then maybe you want the node to
go down but there's more graceful ways
for that to happen than just the
application master killing your node so
what I did here was put it as an
included application and then in the
supervisor initialization in DKA server
i use the snippet of code that Yas has
for embedding a Yas server in your own
application and jaws is written closer
to OTP
and a lot of the other like mochi web
servers but it's not exactly done with a
route supervisor and so you call a
function and it hands back a collection
of supervisors that the route supervisor
should launch and so then your route
supervisor has to run through that list
and launch all of them and that's the
snippet of code that they give in their
examples in their documentation and so
I've grabbed that code and put it into
my application DK yaws so that if
anybody else wants to embed it they
don't have to write that piece again
they just include you chaos and then
you're done but you can see here it's
getting the configuration information
and I I pull it actually from the
command line or the config file or I
default to what Yas has as its
application defaults and so then if you
include it you can set those parameters
in yours or just leave them to the
defaults or you can do it on the command
line and not even having to change your
config file and then here's where it it
doesn't list comprehension over the
supervisors that are returned by yours
the last step is a putting your your
config parameters and so I added
parameters for the default port default
IP and the doc route those are really
the only parameters that are necessary
to get started over time I hope if
people use D chaos and they contribute
back to it there'll be more options that
become you know reasonable defaults as
you use some of the features of ya's
that require other configuration
parameters but if you're okay with these
you know localhost 8080 chaos then it'll
just run but in your vm args if you use
a rebar which i recommend now i mean
before you use the hand roll the apps
but now rebar makes it so much easier if
you follow the rebar standard and use
something like this it's a one liner in
the rebar config to include the
dependency
and it's a one liner in the app source
to say include DK yas and now y'all's is
running so d3 if you want to see more
about d3 Mike Bostock as the author he
now works for square the credit card
iphone slide guys they have a lot of
data they monitor in real time a lot of
information they're doing some really
cool visualizations the d3 is his
generalized tool for doing charts and
graphs but he also uses it for
geographic stuff he's got Albers
projections and all kinds of things
built into it just unbelievable stuff
and Warren I maps and just a lot of
visualizations they also have a couple
new things they changed the name of it
was called tessellate or tessellation or
something recently for handling you know
millions of data points in real time in
javascript in the browser so that you
can filter and display just the parts
you want so it I I like this approach
over the procedural approaches because
you don't have to change your code it's
all loosely coupled in the data and in
the HTML or the CSS style sheets and
they're making it possible to handle
lots and lots of data in the browser but
the declarative mapping is a big
important thing it also does the
animations those are using CSS
transforms so it could translate and
rotate and do all the kind of 3d things
but if you have a graph that's a line
graph and you switch to a bar graph you
can do an animation that actually
animates that transition from one type
of graph to another graph and I haven't
gotten there yet in my demos hopefully
saturday i'll be hacking i want to do is
run a benchmark run 234 benchmarks and
it does a bar chart and then if i do
enough of them it decides to switch to a
line line graph and or scatter plot or
you know some other variant and just
does it automatically based on how I'm
using the tool and he recently posted if
you go to this Bo stocks mike dot chart
he posted a way to declare charts like
pie graphs and bar charts and so forth
and embed them so that it's an object in
JavaScript that you can just set the
width and height this is another like if
you create a pie chart and it's 300 x
400 and then you want to change it you
might have to erase it call the function
again with different and in arguments
something like that what he does he uses
a method called the function chaining so
that when you create an object it
returns that object and then you can set
the height on it and that returns the
object and now you can set the width on
it and you can chain all those together
and one command and by using his
approach to embedding the chart you
could easily switch from one chart to
another or resize it dynamically using
transforms and that's all declarative in
the HTML so basically we've got a form
layout in the browser for the user to
interact with then the Jason connection
to our lang and then Yas executing the
code and in the Yas file and it's hard
to read this the there's a form in my
case I'm I've got to pull down and I'm
offering you options to do iterations so
which is faster calling a function that
loops with tail recursion or calling a
list comprehension that iterates over
the list or calling map you know I
wanted to compare things like that and
see graphically how they compare so I
have several options like doing internal
operators doing iterations doing
function calls and you select in your
form fill out the form and then when you
hit submit
on click I do a d3 submit which is this
JavaScript function right here it it
it's on the next slide is the d3 submit
function but it it uses the function
make URL which collects all the elements
from the form that the user is filled
out and creates the URL that's going to
be used to retrieve the Jason so the
purpose of forms in HTML is to provide
an interface for a user to build a rest
endpoint and so essentially this is
exposing exactly that behavior that the
user is choosing what they want to see
and I'm constructing a rest endpoint
that goes and fetches that resource now
it turns out it's returning Jason and
displaying it in a certain way but
here's the d3 submit and here's here's
one of the features of d3 that's really
great I mean even if you don't use the
graphical display you could call d3
Jason give it a URL which is the make
URL function which constructed it from
the users input and then you give it a
JavaScript function that does whatever
you want with all the Jay Jason results
the jason has handed back to you as an
array of JavaScript objects you don't
have to deal with it mess with it or
know anything about it you just iterate
over the JSON object and so in here I I
pull out the data that I get back and
push it on to a list that's being used
to display the graph pulling out just
the attributes of the Jason that I'm
interested in and here's where I do the
chart so I create a chart object it's a
bubble time series chart I have an
example of one in the code there and
then it it sets some functions on there
that access the x and y parameters that
are going to be graphed and this is the
flexibility that d3 gives you is that
the X function so when you're when
you're accessing a point on the graph
you
I have a data element out of 100 data
elements what is the x value and the y
value that I'm going to use to chart it
with those are actually functions
closures that are attached to the data
object so so now all I have to do is
give you an array of data objects and
those functions can be swapped out at
will in the JavaScript code without
touching any of the rest of the code so
that's why I say it's declarative I
request data and the data is bound to
functions at the time it's displayed and
I can change that binding to display
them in a different way and I can do
that dynamically by another JavaScript
function that swaps out those functions
so it's a very powerful and then then
there was just the graph area I just
call that function to plot everything so
here's the Yas how does Yas here i'm
doing like a PHP the Earl / earl instead
of the question mark PHP or however they
do it and there's a function this is a
Yas function out a it takes whatever
parameters were passed in on the URL and
lets me get at them and parse apart the
path and look at the parameters and
everything and so I just used the Yas
functions to parse the query and I pull
out the elements that I'm interested in
and I pass them to this bench function
and bench is what's calling my bubba
server and it passes in the properties
that are needed for my benchmark to run
so if you have an application that
already exists and you want to test some
function points in that application you
would have this bridge that goes from
the rest URL to the functions that you
want to invoke you may have to put in a
little piece of code in your application
that receives those and then sends it
out to the right piece if you specially
if you have a distributed system and you
have one entry point behind the entry
point you're going to have to get to the
code
so that's that's pretty much everything
and how its constructed if I go back
just to remind you you know all these
elements are independent so each of
these elements you can swap out and
replace and do independently and I don't
know how this is going to display oh
that's not too bad it's not too bad so
here's my form on this side and over on
this side I've got my graph which I can
generate and I just want to run like
right now so I set up my menu with
there's a data access option where I can
test things like list n versus list head
versus accessing a binary using binary
pattern matching or using the binary
module or using tuples so right now it's
saying I'm going to test list access by
generating a list of random elements and
timing the execution of lists and
removing from the head so I I I create a
list of size 100 with random elements
and I think I just stick in integers and
the enth position is anywhere from one
to a thousand randomly so it's sometimes
it'll take the seventh element that
twenty fifth element and if I run that
benchmark 100 times well you see it got
dominated by some garbage collection or
something right there now we can see
that a hundred cases ran and there was
some variance in the cases as it warmed
up or whatever caused them the low
points over there but I'm right here I'm
plotting i don't i don't have my scales
worked out well d three takes care of
your scales you can do linear
exponential whatever you just swap a
function your declaratively and it'll
plot them I'm just not labeling this is
actually nanoseconds I think so doing
list and
is on the order of 10 nanoseconds when I
do head for a similar thing you get my
garbage collection again similar it's a
you know 66 nano seconds native binary
here i'm doing binary access by
generating a random binary and timing
the execution of skipping over a random
number of elements of pulling out 1 1
byte and so i'm using again the binary
sizes 100 integer 100 bytes and a
thousand accesses into it if garbage
collection so here now I'm seeing 200
nanoseconds so you know a lot of people
say cheese strings are lists and lists
or pain in the ass and but it's two
orders of magnitude faster or 11 one and
a half order of magnitude faster to
access a list than it is to index into a
binary even though you get that
compression the vm is optimized to work
with lists so if you got like 50
elements it's probably way faster to do
it in an analyst now using the binary
module as opposed to the native get my
garbage collection so this looks like
binary at is running faster than native
binary on my machine on my circumstance
you know it's all relative I was looking
for relative performance I want to do a
bar graph that runs all of these and
shows the spread or does a scatter plot
and shows shows how they compare two
poles actually are quite fast when the
garbage collector doesn't run
yeah yeah I know I know something
sometimes up there but anyway so that
gives you an idea I i also had operators
so i could look at plus minus and less
than and greater than just I was just
kind of enumerated through different
things and putting them in the form
iteration with function call versus
module colon function versus list
comprehension a list that's tail
recursively called with functions binary
comprehension and binary function loop I
thought you know there's there's a
spread of things you'd like to graph
that and see how they compared to each
other and then let's see I've got the
wrong menu here then I ran some tests
with the spawning processes and
messaging and right now this isn't
working properly for me so that's
Saturday hacking but on messaging when I
did run it there was receiving send
messages originally I would create a
process generate you know million
messages and then send them to another
process and see how long it took and I
thought how much difference can there be
between sending a message and receiving
a master's basically the same thing it
turns out it's 40 times slower to send a
message than it is to receive it because
when you send it you're going from one
context to another context it has to be
you have to do a context switch you have
to copy you have to potentially even
lock you know internally in the kernel
and then put the information there and
then get back to the other context when
you receive it you're in the same
context and you're grabbing something
that you don't need to lock or do
anything so I had observed before that
if you have a gin server and it gets
overrun gen server to is came about
because of this you know it gets a
really long message queue and you can't
catch up you like try and Chuck through
it you can't catch up but if you collect
100 items off of the list of messages
and then do a list comprehension across
them and then get the next hundred and
do a list comprehension you actually can
chew through it
faster and as part of it is if sending
is 40 times slower then you can process
40 receives before you get another cent
and that led me to think that if I have
a sinner that's sending that much I
could put a process in between whose
only job is to pull 40 things off and
put it in an array and then send the
array to the next process that actually
processes them and then it only has to
do one receive one received one receive
an icky it can keep up a lot faster that
way and that's actually a trick rather
than using something like jobs to
control and throttle and do all this
stuff if you can cascade at every point
you do some analysis and reduce the
number of messages you pass on to the
next step in the pipeline and even if
you do it by collecting them into a bag
and handing the bush all over you can
speed up the pipeline and get
concurrency because you're working at
multiple levels at the same time and get
improve throughput at the far end of the
pipeline and you don't have to control
what's coming in to you it just sort of
happens naturally and if things start to
slow down just insert more processes in
between slow down the pipeline length
but speed up the bulk size of it and at
some point you can spread out the
receiver and replicate what's chewing up
the messages so that if writers are
overriding you create more readers
dynamically and then you'll catch up and
then you can get rid of those readers
dynamically too so now those sorts of
things were things I was trying to
discover by benchmarking the primitives
of Erlang and having a comparative way
to say all right I've got an algorithm
it has this behavior I think this
replacements faster let me compare them
head-to-head in the same environment
running on the same circumstances maybe
on a remote machine and still be able to
view it and have it visually available
any questions
40 times yeah that's what I was saying
but you know it's on a laptop it's and I
was doing it locally not across the
network you know it's but most most of
the open source applications you see are
running locally on one machine with
multiple processes and most of the
bottlenecks and problems people complain
about being bogged down is related to
too many processes or too many messages
or too many spawns you know so just just
understanding that let I have a system
it's running fine and then all of a
sudden it gets bogged down being able to
see where that happens and how that
happens this is a tool that might give
you another way to get a peek inside a
running system there's a lot of ways to
do it and some of them are buried in OTP
manuals and people have a hard time
finding them but this is a way to give
you a hook to do quick quick and dirty
little things with code you understand
that you can reach in and fill this and
see and that the biggest thing that I
was hoping eventually to get to is I've
got an open source project somebody
sends me a pull request and says hey
this is a much better way of doing your
cue yeah prove it like here's the code
you run it I'll run a browser against
your thing and see what it looks like if
I can convince myself or I can prove it
myself as the as the the person that's
going to merge in the poll I can run it
with my code and then swap the one
function and run it again and see how it
performs or write a little adapter so I
can have both of them running at the
same time I want to testify some system
working the register for whatever
service how difficult would it be to
pull this stat 70 and then add the phone
humanities test user registration so if
you look on github the really it's just
bench server Earl is one file and it it
has two approaches one is related to
messages and one is related to looping
and basically how many times do you want
to iterate
how many things do you want to deal with
and then in messaging there's a third
parameter so it's essentially to
function signatures and then I created
modules for each of the pulldown menu
items so so basically you would look at
the bench server URL and just make a
call out to your code from there now
what I want to do is get to the point
where it's a behavior because I'm trying
to build this up and find out how many
signatures are the same of this type and
of that type then I can build a behavior
and then you can just mix in a behavior
and have it as an included app and then
it would just work so I'm like
two-thirds of the way there but but
right now it's you look at one module
and look at an example module and you it
should be straightforward what to do so
if anybody wants the hack on it or look
at it or get an explanation Saturday you
know or even catch me as why were the
yellow shirt you find me anywhere so
yeah it's now impossible for me if I
have an application using Yahoo's to
pinch markets because you're including
it in a way that's the only difference
available right so if you don't want to
include it you can just move it from
that included applications line to the
applications line and restart moving you
because because you're changing
something before it's built right it's
the apt source right right yeah the
reason why the reason why is because if
you don't have it as an included app
then you assume it's launched by
somebody else external to you either
before or after so there's no
coordination that's that's the other
reason why I have this pet peeve about
not having an included application there
is a mechanism in OTP to coordinate
multiple applications and that's called
start phases and and I don't see start
phases used either and open source
applications
yeah yeah so but with start phases if I
need that thing running but I I need to
make sure it's running before my piece
starts running then I can have a start
phase that starts it and then my face
and then I we had a discussion earlier
about start phases and include
applications that if an included
application has start phases now the
thing that includes it has to know about
those and but it doesn't have to
necessarily know anything about them and
add anything to them it can add new
phases and just start those phases first
then to its phases in between or after
so including just adds more things it
may make things a little more
complicated but they're additive in
layers not in intersection yeah right
right so the question is on included
applications how does that affect the
environment parameters or the
application parameters right well an
application is a single entity that the
application master knows about and if
you have to applications then the
application master knows about two
applications and within an application
if you ask for the application
configuration parameter you get the one
that's specified for your application
that was loaded with your application so
there's no way for me to get the
configuration information for another
application directly intentionally the
way OTP expects it if i make it included
I'm not including the application the
way it's specified is that application
should just be start and stop and start
phases and there's a route supervisor
that should be called in start and
really you should try not to do anything
else and start
that route supervisor is instead called
by my supervisor so the application
doesn't exist the route supervisor does
exist when it looks up the application
tree it gets to my application not to
the original application so i can
override any parameter that the original
application specified in my applications
configuration arguments and that's why i
said if you want to change the port
number or the IP address or the doc
route you just change it in your
application or on the command line and
that will be the context for the
application that's executing not there
the compile static context so so the
real difference between applications and
include applications is what impact do
you want on the vm if that application
goes down do you have a way to control
and restart if you don't then there's no
point in putting in yours it's just
going to take you down anyway but if you
do want that to take you down but not
take down the vm then you should make it
included application if you want that to
take down the whole vm don't make it an
included application it's really there
yeah you could do temporary or not yeah
but when I think about architecting with
OTP the first thing I think about is how
do I want it to crash everybody says
crash immediately or fail fast or
whatever I forget what the phrases that
they use a crash early crash often you
know there's no easy say a lot of
different ways but there's an implied
philosophy behind that that's crash
immediately as soon as you know that
it's a safe place to crush you don't
want like your core key process that has
every a user account in memory for speed
and performance to crash because of one
bad thing went wrong because now it's a
our restart to read it from all the
remote databases and everything and if
that's happening right I mean it when
you're developing you want it to crash
immediately so you can find the bug but
once you deploy it you only want it to
crash to protect the system from going
so you isolate things in the supervisor
hierarchy and make them crash in a
fashion that they'll restart a few times
and then they won't come back up because
if they come back up they're going to
just propagate up the supervisor tree
and take everything down so I think
early about where is it safe to crash
and where do I really not want it to
crash like getting ETS table a lot of
people use the ETS table 2 cache data so
that they can get it easily if that
process crashes and you lose that 80's
table nobody has the information so you
say okay I need this feature I'm going
to use an ETS table but I'm going to
make it inheritable and i'm going to
start it up with a process that's an ETS
supervisor and it does nothing else but
set up the ETS table and hand it off to
a to a worker and then if that worker
dies I get the ETS table back and all I
do is assign it to a different worker
and my whole job is to make sure I
always stay up I should never crash so
that I don't lose that 80 's table
because as soon as I lose that 80 's
table now I have all kinds of
contingencies that I have to worry about
and people I say well if I lose that I
got bigger problems don't start out with
that line of thinking start out with the
line of thinking that I'm going to
contain every big problem into some
small area and now it's a small problem
and I don't have to worry about it so
that's the part of applications and
included applications that never really
gets discussed and why people don't use
it they're just not aware that there's a
trade-off there that's being made and
it's easier if you've come from Pascal
or Ruby or some language that likes to
control the whole environment and be the
master then it's easy to say well my
applications running and we'll figure
out a way to get yours to run but mine
is the one that's in charge and without
EP you really need to say I'm building a
system that's engineered to be a
cooperative collection of components and
every component should be embeddable in
some other system and it should be
isolated so that I can test it and
isolate it from crashes and if you start
out with outline of thinking then you
get much more reuse out of your software
and much more control
all over a production system yep this
was from zazzle and I had that I
actually asked clack e to turn the gif
into an eps so that I could print it
bigger but it turned out the gift
actually sized up so yeah so if anybody
can a Sikh Lackey in the next week I'll
give them the hat</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>