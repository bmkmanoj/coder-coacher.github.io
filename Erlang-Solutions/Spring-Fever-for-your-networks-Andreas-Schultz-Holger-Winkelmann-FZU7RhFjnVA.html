<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Spring Fever for your networks: Andreas Schultz, Holger Winkelmann | Coder Coacher - Coaching Coders</title><meta content="Spring Fever for your networks: Andreas Schultz, Holger Winkelmann - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Spring Fever for your networks: Andreas Schultz, Holger Winkelmann</b></h2><h5 class="post__date">2012-05-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/FZU7RhFjnVA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay thank you for introduction and we
will give you an overview today what's
all about Software Defined Networking
sing and open flow which is all over the
place in networking at the moment for
about two years and it's a emerging
technology with which enables you to
program your network and what it means i
will show you in the next slides and we
have made a presentation today where we
go to the business stuff first a few
slides and but i think we are very
technical around here and we have
another another slides that which is
done by andreas about the implementation
based on Erlang of course so open flow
start in 2008 at Stanford and at this
time there was a need for slicing your
campus network into different areas
where you can make some experiments for
networking because a problem with
networking words that is it that the
devices deployed on campus networks or
enterprise networks or even carry on
networks are very very static and the
innovation it's quite slow and that for
a reason because a network device has to
be stable has to be tested and so on but
all other software industry or other
technologies like virtualization has
stepped up very very fast but networking
still or some kind of slow and
understand for team ask themself how we
can innovate the wiring closer to the
rack and two switches and after a while
they come up with is open flows in which
basically it's an technology as an API
and you can use with any programming
language and a bit later the onf was
founded basically last year
and as you can see the adoption of
OpenFlow Software Defined Networking
it's it's really really big nearly every
networking vendor have joined the onf
and quite a lot of software companies
and hardware companies as well and
there's another website on the right
hand side which is open flow hop side
where projects are listed but if you
look around and get help an example you
will see for nearly every interesting
programming languages OpenFlow activity
today so what's the different on oneself
a defined networking usually ends up and
today's networking device is all the
functionality is local to the device
regardless how big it is from the small
table top switch up to the big router
the functionality it's built into the
device and you can configure existing
tech functionality but you can't expose
the functionality or the network
functionality directly to an external
controller and that's what open flow and
sdn is promising you have your
forwarding plane relatively dump and you
expose forwarding as the concept in
networking to a controller I think we
all know some use cases how to change
network settings the configurations of
your of your network at the application
developer or as a administrator of an
application you have to ask your network
admins to do something there are some
ways of doing this automatically and
there are some ways of doing this
dynamically but you always configure
your network let's say usual the usual
admin and doing this on the command line
for cisco router an example that's
getting little bit more challenging if
you have a couple of router so they
started years ago to do some CLI
automation it's all the funny days in
the nineties where you write expect
script to tell knit into the
wise and try to do something
automatically this usually fails if the
CLI is int access change for next
firmware version and so on and but was a
very first step to automate
configuration management then we come up
with other approaches like netcom as an
MP or other element management systems
which go into the devices and configure
quite a lot of devices the problem with
SNMP worse today is only read only
thought you read metrics or something
like this but you're not really
configure the device it's my SNMP there
is already something like
software-defined networking in huge
carrier networks in a carrier network
the resource like bandwidth from A to B
needs to be requested by an application
and as a way are ready to push
configuration changes or changes of the
network behavior to the network by
protocols like radius and diameter but
this is mainly to 3G network provider or
even carry on network it's overly
complex and you have not many when was
doing that in a typical enterprise which
diameters are not available at all the
conclusion for that is even today you
always configure existing functionality
of a spiritual routine and there's no
common API to program the network
functionality because even you have a
compressive API the API always exposed
the functionality already exists on the
route or you can't change the routing
protocol you can't implement it with the
protocol is this way what openflow
promise is to have an very very basic
API about forwarding and that are three
elements here if a rule or match which
can match on all packets
in a user net frame if it matched you
have an action to do something with that
the action can be to pop and push parts
of the of the packets like the text or
then take it to the controllers with
other analyzers and so on a business
basic functionality you can do what you
want with your with your network packet
but the network packet forwarding it's
still in the hardware device and does
not send to the user land and the line
of stone on an example it's still at
wire speed so and we are running a long
based on flow controller for quite a
while now we started one a half years
ago to develop something like that and
launched this year machine-to-machine
network based on over an open flow which
boots a network above 3g networks around
the globe and make some very very
compressive policy control their virtual
groups who can group the wises together
you have a lot of nutt network address
translation functionality between
devices and all this fine granular
management is based on an open flow
controller just another project at the
moment running where we're using the
same technology which is a proof of
concept of implementation of a
controller which acts as a pppoe to em
in a drawer in a carry-on network but
not sending the traffic back to a
central highly expensive huge bureaus
box the actual PPP termination it's done
our to the edge on the switches directly
and the PPP frames are terminated quite
early and forwarded a normal IP over
Ethernet frames through the network
which is much more efficient much faster
and you eliminate the huge biraz which
is very very costly
usually and as a side effect you get a
multicast application further out to the
edge so you don't then IPTV traffic in
these examples with the whole network
back and forward you terminators very
early on the switch of the excess
network where the customer is connected
so being on The Ellen conference of
course we will present how we do it and
what we done here and that's a part of
andreas so we wrote an open flow
controller in Ireland which is modelled
like what other controllers but I think
Andrea's can talk about that much better
than me
hi yeah flowers our platform for
building a building any kind or any
number of open flow controllers in
running now it gets started with the
basic difference from a classical switch
for our business software-defined
Network er networking I've already said
a lot of things about that so let me
repeat a few things I with a classical
network switch you got a static control
path you configure the thing and then it
works the way it is supposed to be you
can you can slice your network with a
number of mechanisms like be lens
filters you can have triple-a mechanisms
allowing clients on the network or
denying them on the network but still
the decisions you can make on on the
packet are limited you can match on mac
addresses you can match a non-violent x
and quality of service attacks but
that's mostly it some three switches can
do a bit more but they still only look
at a very limited part of the packet
itself to make the forwarding a decision
and one of the major things is wonderful
what the indecision for a specific type
of flower pacific type of packet has
been made it can usually not be altered
why this flow is active so the next flow
might get a new decision but the current
flow the way it's forwarded it will stay
that way so for normally out there to
switch the processing is very very
simple basically it gets a picket coming
in through through one port and learns
the source MAC address is located on
that part so it might know where the
destination MAC address is located so
basically for wat support of the
make it through that port or if it
doesn't know where the mega dresses
locate it simply floats it on all the
ports hoping that somebody will do
something there's a packet now that
leads to a number of different
interesting questions now if a mech
address moves from port to port like if
you have a vm being migrated to a
different physical host how does a
switch learn that your mac address has
been moved that there are a number of
existing mechanisms but they all have
the drawback that the hosts have test to
be proactive he has to signal that he
has been moved they also get certain
number of delays then how can I slice
the switch in different parts for
example if I have a large distribution
network going going out to some customer
homes I might want to put different
carriers on them or they might want to
share the same two to share the same
distribution network how can I isolate
them from each other with its enormous
which I do have mechanisms like we lens
but they need to be configured they're
not dynamically and basically they
cannot be automated people have to go in
and atmosphere has to go and change the
configuration and this takes time and
effort and then especially if I have in
infrastructures like Ethernet with the
home of fiber to the home I want a
uniform infrastructure but I still want
to isolate my clients from each other
again I could use villains or PPE but
all this brings either additional
traffic and forms of headers on to the
network or again I have the confirmation
problem now with the big promise of
these software to find networkers that I
can decouple all this control plane
things from my actual forwarding but
they still need to get the decision 2002
the narrow forwarding plane and I have a
open well-defined API for that the other
thing is I can have one central instance
controlling a
network of different boxes I could have
a distribution network with a thousand
switches and still have a centralized
redundant instance controlling them all
which means that i also have a global
view on to my network which makes much
easier to actually for example move a
mac address from one pot to the other
and i cannot only move it within the
same switch it can move it wherever i
want within my network so even not
geographica deceive distances make no
difference anymore the other thing is I
can match on everything in my packet I
can take the classical things but it can
go even into the payload of the packet
if I want to and the other thing is in a
normally a true form warning thing I
cannot really alter a packet I'm I can't
might be able to do a limited amount of
nut but with a software-defined Network
I could change anything within Deepika
mostly this should more restricted be
restricted to traffic or payload headers
because altering the pale of the ticket
service can be tricky but still so when
we had the ad a monolithic switch before
that we are doing everything on its own
we now get a much more modular approach
where we have busy switch has basically
has specialized hardware for the data
path for the full boring so that can
forward at a line speed like 10 gig or
more whatever I've got a control path
thing that actually propaganda
propaganda gets the configured EDI gave
the API decisions on to the hardware and
again we have the externally excessive
by AP I which then talks to the
controller and the controller can talk
to any number of those switches again we
got the flexible matching we can learn
MAC addresses over more tubular switches
and all those things
now we already talked about a lot of
open flow what really is open flow it's
actually two things it's a protocol
specification with the last released
version of being 1.1 and it's also a
reference implementation of a
software-defined Network that the
reference implementation is currently a
line external module that is
implementing a data path in forwarding
instance but it's also a sample
implementation of an on an fpga board
where you can actually do a one gigabit
line speed forwarding on a normal PC
platform it's also the basis for several
existing commercial open for
implementations it's not quite clear
whether open floor be sweet or some some
own implementation by the windows i use
there but some have stated that they are
using old in the open pro implementation
in not normally in an open flow enabled
switch if a new flow comes in this is
what might happen you get the
notification that there's a new unknown
packet coming on coming in the open flow
controller then has to make a decision
telling the switch what to do with the
flow in form of an fluid message later
on doing why the flow is select active
it might might decide to modify the flow
to simply forward the idea the traffic
to a different port completely block it
whatever robot wants then after the flow
has been idle for a certain time
obviously the it's virtually the open
floor later peb element will notify the
controller that the flow has expired so
it can be removed from from any kind of
database there might be now another open
flow implementation is open we switch
this implementation was originally based
on the open floor reference
implementation but has since moved on
a lot like the open floor of runs
implementation it has a linux kernel
data path element it has a controller of
written in c++ and it has a
configuration database and that is
really what sets aside from the openflow
implementation that has no configuration
database there you have to manually add
on remove ports from from your
forwarding paths with open be switch
that that apart can be automated through
the database like the open open flow con
implementation can act as a controller
to an open fluorinated hardware switch
and this is used as the software
switching cell or will be in the next
version anyway before that there was a
mix of bridging and then things like
this but now we see we see new
infrastructure they will be able too
much easier move virtual machines across
physical hosts as well it also has
support for a lot of the standard
management interface you'll find
enormous which is like net flow are
spent for monitoring as also link
aggregation which is one of the major
differences to open flow and spanning
tree of course all those things you also
got some extensions over the standard on
flow protocol which gives you much more
flexible matching where you can kind of
write a mini program to actually control
the forwarding a decision not not only
have the static match but kind of loader
with just do a decision based on that
and and then have conditional jumps in
this kind of things now on to our nice
platform flower which is a play on on
flow flow and early now this is a
platform to actually build an open flow
controller based on Erlang other
controller or development environment
for other languages exists there for
examples Knox which started off with a
lot of time but since has moved on to c
and c++ there are also several java
implementations may can build your pro
control all of us now the major goal was
here that the someone who wants to
implement a controller can concentrate
on its switch and flow logic it doesn't
have to deal with with all the things
surrounding that like picket decoding
encoding protocol decoding or the other
management protocols like like spanning
tree or those kinds of things so what we
provide as a the protocol connection
data abstraction so the decoding as a
set and a number of tools and algorithms
you need usually in a typical switch so
why do it in learning well probably know
why just just a few things but of course
binary matching fault isolation
concurrency I like the fault isolation
point actually the most because so much
it's so easy to get the decoding of a
certain paper packet wrong this really
saves your life there so this is the big
overview picture what flower looks like
you're basically got your connection
obstruction which deals with talking to
the actual hardware or to the actual
software implementation of mocha knob of
an open flow switch the dispatcher that
a chrome distributes all the interesting
messages to your control room so the
controller doesn't have to deal with
everything that comes in but just the
things that he's interested in you might
have a controller that's only interested
in doing spanning tree so you can
actually reduce the only for spanning
three messages and then obviously the
all the support library functions like a
library for network information base
that
something like like for example a
routing table you would build was maclee
owning database the flow record of it
actually can decode it's not about
protocol recording but decoding a
payload packet in its lair they are free
and possibly layer for information and
then pure packet d encoder that is
sometimes your controller needs to send
or decode our packets icmp packets to
learn something about the net for
infrastructure and this part deals with
that now if you if you write a
controller based on only the flower
platform this is all the components will
work together you got your floaties
Petra which is routing the messages to
the controller the flower data path
module which is an abstraction of the
real hardware which also hides the
differences was in the hardware you have
there might implement different
capabilities now the data path element
or the flower data prev element
encapsulated set so that you don't have
a think about all the different
capabilities it just which might have
you simply can tell it that for me and
the flower datapipe element will
translate it into the right into the
right command forward and flower
connector which is basically just doing
the transport mechanism yeah this again
what a basic what I just said one thing
the controllers are chainable so once
your google controller has come to a
decision or it might send off an event
and the other controllers can react on
that so you can have again the basic
controller doing one thing of the
network and but what he has learned
another controller might extend up on
that
he did datapath element that as a set
abstract see the real open floor element
Manchester connection setup and those
things now the open protocol is defined
in terms of C struts so there's no
formal specification that tells you how
long were fielder's or whatever it just
gives you a C struct and you have to
defer that now the packet decoder more
or less translates this one to one in a
rolling structure which might look like
this which is actually a capybara which
feature exchange that for the
information base well as I said that's
used for building routing tables for
example where you have not only in a IP
address to look up at a prefix length as
well so it's not just a key value based
lookups on a but a bit more by cleaning
the bay database the the key thing is
here that some mega dresses are special
so you don't learn them or you'll learn
them in special ways and also the those
addresses to expire because a client
might simply disconnect from the network
or disappear from it work with beside
you ever knowing so you actually give
them an expiry packet decoder will
extract all the necessary and
interesting details about the package
you might have got like and they pick a
DNN code of which gives you for example
it helps you constructing ICMP and our
packets easily and without much effort
now OpenFlow deals was mattress over
here if you tell your switch years this
is the information I have the flow you
have to always to specify a match this
is what such a match would look like
that now you can construct them by hand
but it's usually a bit complexed we were
doing or setting all the values so what
flower gives you instead you give it the
flow which is basically decoded from the
incoming packet and tell it what you
want to match on which this the encode
FP match and it will construct you then
deeply complex match structure so it's a
two-stage process so greatly simplifying
the construction of those matches we
have one controller implementation that
we have included in flower which is the
flower simple switch it's a simple very
easy very simple they are to learning
switch and if you remove all the
boilerplate code it's just 50 lines of
code all the rest is covered by the
libraries and by flower itself now our
production switch which is part or the
main part of the SCG contains about a
thousand one thousand one hundred lines
of code there's a lot of boilerplate
code like like studying processes these
kind of things so the bit hard to to
count all this but this is a real layer
three switch and actually implements
something like a control matrix very
where you have all your clients that you
know in a matrix and then can can
specify exactly which client is allowed
to which other client you can change
that at runtime with triple-a always
turn a simple API call that is currently
used in a machine-to-machine
communication where you have overlap in
groupings so it's basically that you
have multiple manufacturers delivering
those machines to multiple clients but
the manufacturers still need access to
all their own sister
to the systems of booked and the clients
have systems from different
manufacturers and they want access to
all their machines they have those
overlying overlaying groupings and that
is realized through this matrix
configuration well nothing is perfect
nice flower so ipv6 support is currently
mostly missing for the current product
we didn't need it but it's coming I hope
make learning database yes that is a
rather simple implementation currently
so it doesn't scale at all the
difference between doing a make learning
and doing just for warnings about a
factor of Android at the moment so it's
really terrible but we have some ideas
how we will fix that now the network
information base needs to be extended
for v6 and then there are also some some
other features a little but like in
there so this next month should bring
this as well yeah well the last point is
mostly the most importantly
documentation if you look at the
check-ins to the project you will see
that there have been some additions in
the last days but many more are needed
so this is going to come as well no
distribution but that is an interesting
thing building a distributed controller
requires a lot of things you have to
sync state but between it you have to
distribute your incoming packets between
the controllers and even if you are if
you are not doing a distributed thing
you might want to distribute the idea
the incoming packet decisions to two
different controller instances now at
the moment this is a pure round-robin
thing and for a complete more complex
implementation that will be not enough
so there's some some work needs as well
now you can get flow on github if you
want to experiment with
define networks and contributions are
welcomed as always but that's it thank
you Christmas
you usually need specific hardware as a
native s because I've been looking to
open flow and being able to do basically
the same but using vitamin other
libraries but I got interested if you
have any specific hardware or if you are
doing it only with what our current
product is doing it all in software but
there is some thing was released a few
weeks ago HP released a commercial
version for some of the bigger switches
so you can run it on their hardware and
there's also this is one I think it's a
PCI Express board which is an FPGA on it
and to kick or 10 gig Ethernet ports and
you can can run a optimized openflow
implementation on that
are there any security considerations
given that up variability to medically
everything in the packet well you have
to trust your flow controller the
communication between the the actual the
actual data path and the controller can
be encrypted using SSL and can be
secured with certificates and everything
but as far as your payload manipulation
goes you simply have to trust it your
controller is doing the right thing and
he configures the spanking automatic
message but now you have till they are
external controller fix the forms in the
stitches and again welcome to
depending upon the sea just to repeat
yourself hope you guys whispers open
fluid served as nothing in the spec that
gives you any failover capabilities open
we switch has implemented that so you
can have primary and secondary stand
bias controllers so you can well you
have to exchange their you actually
actual switch state the beam does then
as for this which is its serve if it
loses the connection to the controller
them for all the existing products you
can either configure to close completely
or fall back to a normal switch mode but
the once once it loses the connection to
the controller you yet just just don't
have any control about it anymore well
some of these ed the implementations do
have the ability to fall back to a local
instance of the controller well actually
each each open flow controller can be a
controller anti-consumer or a client on
to it to another controller so you
actually can change them in as well and
that's actually what what's happening on
the hardware on the real switch itself
anyway you will have a small controller
there that then talks to your
centralized controller which then might
talk to the another instance and you
always have two tries to just continue
with the information you have just not
establishing new flows so you basically
keep running what you have but until you
get reconnected to your central instance
anymore
Oh
thank you very much guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>