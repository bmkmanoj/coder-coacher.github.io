<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Rob Martin - Teaching functional programming to noobs (Lambda Days 2016) | Coder Coacher - Coaching Coders</title><meta content="Rob Martin - Teaching functional programming to noobs (Lambda Days 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Rob Martin - Teaching functional programming to noobs (Lambda Days 2016)</b></h2><h5 class="post__date">2016-03-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/bmFKEewRRQg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so I feel a little bit bad this is
actually more like three talks one
working with juniors one about
functional programming and why we should
do more of it and what about mob
programming and like we're kind of not
going to do justice to any of the three
but we'll go quickly and see how far we
can get it's also kind of a sales pitch
you know like I want you to hire juniors
and work with them and I want you to do
functional programming especially I want
you to have your juniors do functional
programming and we did this mob
programming experiment it was really
cool I think it's worth trying in a lot
of places so I'm kind of pitching all
three of these things to you and one
very fast talk so first off juniors
right so even while I was preparing this
talk director of engineering at OC
Tanner was trying to build this argument
that functional programming is really
hard that you can't do it unless you're
at least this smart and that most of
even our seniors aren't smart enough to
do functional programming I think he's
wrong and even while he's trying to
build this argument you know I'm going
out and teaching juniors and new
developers how to do functional
programming successfully so but I
thought about it and I realized hey
functional programming was pretty hard
for me I actually took 10 years to learn
how to do functional programming part of
the problem was that I thought I was
actually a pretty good programmer
already it took me about five years just
to figure out I was a horrible
programmer
it took me a couple more years to fix
that and then I had to get into
functional programming
I made some odd conclusions along the
way somewhere along the way I got the
impression that Haskell didn't matter
that it wasn't actually worth learning
Haskell
it wasn't until I talked to my friend
Wil bird they he was able to tell me
concisely why it was really important
that I learned Haskell and not only did
that open the door for Haskell it made
me realize that in order to teach
functional programming I had to
understand why we want to do functional
program I had to I had to have the
context for it so I put up here the top
five reasons to hire juniors first and
foremost we just it's hard to get
seniors
it's even harder to get good seniors and
there's this weird thing it's easier to
train a junior than it is to train a
senior okay just like me ten years ago
the seniors tend to not be very
receptive to learning how to be better
but as soon as I put juniors in with the
seniors the seniors become better
programmers they are responsible for the
development of the juniors so they're
constantly teaching we're creating a
culture that expects people to learn you
put juniors in there they need to learn
and then the seniors also feel like it's
okay for them to learn we create a
culture of learning another reason why
we need the juniors is just because we
we don't have enough developers overall
but there just aren't enough people to
fill the jobs so let's look at some
stats for my hometown I live in Salt
Lake City in Utah in the western United
States and this is a little bit scary
right there's almost nobody no
developers out of work when you look at
JavaScript and Scala there is literally
nobody out of work this is not just true
in Salt Lake City it's true in other
places in the states as well you can see
we're not making enough developers we
only have about 2,000 new graduates in
Utah for 7,000 openings the amount of
money that they pay us do you see this
one it's a hundred and twenty thousand
dollar offer for developers with two
years of experience JavaScript and one
statically typed language and they only
have to have like six months of
experience with Java or C sharp
we don't have enough diversity
especially in Utah Utah is where it's
like the home state for for the Church
of the Latter day Saints a Mormon Church
and they tend to not have very many
women especially so we can't increase
our diversity we can't increase our pool
of hireable developers by hiring them
away from other companies we have to
bring new people into it new people are
juniors ultimately you know we're not
after juniors we're after you know
seniors we're after really good
developers right I think that often the
best way to get a really good senior is
to make your own so you start with a
junior then you figure out how to train
them up to a good senior level so I've
seen some talks I've read some stuff
especially lately saying 10x developers
don't don't exist
we don't have 10x developers not really
that's a myth and I got thinking about
that and I don't think it's true I think
there are developers who put out 10
times as much code okay it's crap code
is horrible and the developers are
assholes not all of them I'm sorry
present company excluded right but
really it's not code that we need it's
value um and in fact you know like I can
put out 10 times as much code all I have
to do is you know like write code that's
you know 10 times longer than it needs
to be right so we want developers who
put out 10 times as much value which is
actually you know a little bit trickier
but it's not all that much trickier
because all you need to do is make the
right decisions along the way decisions
that are just slightly better than
average but compound exponentially so in
this example let's say you've got your
average developer they make 10 average
decisions you know 1.0 to the 10th power
is 1.0 but if if that developer is
making a decision
that delivers just a little bit more
value 1.25 times as much as the average
developer and they have 10 decisions
along a project that compound well now
we've got our order of magnitude that
goes in the other direction too
you can see how disastrous it can be to
have an inexperienced developer who
can't deliver the value making all of
those decisions on the project so I
presented that formula or that example
and and I got some questions about well
you know do we actually make 10
decisions along a project that could
compound like that so I put together 10
of them these are a bunch of different
decisions that we can make that increase
the value and obviously if all of our
developers are making decisions like
this well we don't have 10x developers
we have 1x developers that are 10 times
as much value as as our 1x developers
used to be so we use the right
abstractions I just want to point out I
got this organized under simple and
correct that's my coding mantra it's
what I want my code to be that's why I
want all my developers to do write
simple correct code so simple code is is
using the right abstractions usually
that also means using the right
programming language the right language
depends on the project but I think very
often it's a functional programming
language that's why we're here right we
write code that's easy to read easy to
reason about the scales we write code
that doesn't have a lot of dependencies
those are places for things to go wrong
we write code that often one thing I
like to see is core business logic
written in the plain old language not in
not in the framework not in Express not
in rails not in Django whatever play
reduce the dependencies especially in
the core business logic for our side
effects we can have those dependencies
our code is correct when it does what
it's specified to do but only what it
specified to do I think that's really
important it was a founder of the
OpenBSD project that taught me that Theo
de Raadt the moat the easiest way to
write secure code is to write code that
does only what it's specified to do and
I suppose if we wanted to write code
that provided a buffer overflow well
that would be code that does what it's
specified to do right but if it's not
supposed to provide a buffer overflow
it's a security hole we write code
that's not weighed down by technical
debt we write code that is using the
right patterns
it's another expression of the
abstractions that we're using if we're
using a broken pattern for our problem
we can't write correct code with it and
yet so often we're using broken patterns
because we're using the wrong language
the wrong framework because it's what we
know and it's what we use where we're at
so there is clearly a trend over the
last seven or eight years in industry
moving towards more functional
programming and done well functional
programming really works for delivering
that value so when I was trying to
figure out how to be a better developer
so that I could you know even begin to
learn how to program in a functional
programming language one of the first
things I did was well I started with
John Hughes paper why functional
programming matters
I needed the CliffsNotes to go along
with it so I also read the essay by
Ragan Wald Reginald Braith wife I don't
know if anybody knows how to say his
name I don't um but he wrote an essay
called why why functional programming
matters matters ok so that got me
started I
ultimately I realized hey I needed to be
able to answer that question for myself
too I needed to have my own expression
of why why be functional you know so
that's when I settled on that coding
mantra simple and correct for that I
needed to define simplicity it's easy to
define simplicity if you start with
complexity which is you know a very
well-known enemy of software engineering
I think complexity is first and foremost
not being able to reason about our code
second not being able to test or prove
our code and finally not being able to
trust our code simplicity is just you
know the direct contrast code as simple
as if we code is simple if we can reason
about it if we can demonstrate that it's
correct and we can trust it so one of
the things I really like about
functional languages especially for new
developers is that they tend to
constrain us before that I had a really
strong appreciation for languages that
were flexible and powerful you know a
C++ Java I did 10 years as Perl
developer you know if you're looking for
a language that's flexible you start
with the one that has as its motto
there's more than one way to do it that
mentality puts a lot of control in our
hands I actually now lean more towards
pythons there should be one and only one
obvious way to do it but even with
Python you can do it badly to do it well
to do that one and only one obvious way
you still need training and discipline I
like languages that make it really
difficult to do it badly and we see that
a lot more in functional programming
language
I spent like a year trying to figure out
how to put that into words and then at
code mash I saw Phil wobblers talk the
same when he gave this morning and he
blew my mind
you know there's idea that some
languages are discovered and some
languages are invented some languages
feel like a force of nature and others
feel like they were bolted together in
the garage and and that's what I was
looking for the whole time languages
that fit together in as few abstractions
as possible and abstractions that fit
the problem that's going to be easier to
teach to new developers than a language
like Scala why be functional we've got
state right the first thing we usually
talk about when we talk about
object-oriented versus functional
programming languages as mutability and
immutability I narrow that down to
predictable mutable state especially
once we encapsulated an object and then
put an interface on it it's just not
predictable
in fact it's so unpredictable that when
we test it we often have to mock things
up so that we don't inadvertently change
our state while we're trying to test
things often we can't test things
without mocking it an object state is
also hidden it's encapsulated right so
over time as we're maintaining our code
and we get this richer understanding of
the business problem we get this richer
understanding of our objects and we
discover that hey our state isn't
actually as complex as our object is and
we keep building up that state inside of
the object where it's hidden where only
we have to see it and um
it's ugly but it's hidden and we leave
it that way because it's easier than
fixing it this is you know how so much
technical debt gets into our code often
in functional programming are states
exposed if we start to get too much
complexity in our state if we're not
modeling our state very well it's right
there as an argument to the function
every time we interface with that
function we have to deal with the
ugliness that's our state and we don't
leave that that way it's like leaving
your dirty socks on the floor somebody
is going to come along and tell you to
clean it up if you don't do it yourself
one of my favorite things about
functional programming is young
functions and functions I think are a
really strong reason to teach functional
programming to new developers functional
functions and functional programming are
referentially transparent so they're
super predictable right easy easy easy
to test simple to reason about with
functional programming we like to make
simple functions and then string them
together function composition this is
still easy to think about our state is
transformed by the different functions
in our pipelines easy to think about
super easy for a developer a new
developer to understand object-oriented
programming can't give us this just
can't a state is encapsulated and we
don't know what might change the state
we can't get referential transparency
without programming outside the model we
can't break our methods down easily into
into smaller parts and compose them
without working outside of the model of
the business logic as the methods and
testing methods is tricky because of the
way that the state can change on us
blocking down reality in object-oriented
programming is like our first step in
testing so that's why functional
programming languages are best for new
developers it might
feel counterintuitive because while in
industry we tend to not let a developer
start working in a functional
programming language in production until
they've gone a decade or more with
object-oriented programming and didn't
kill anyone but if we start new
developers with functional languages we
can get them thinking clearly from the
start
I'd much rather a new developer came
along and learned you know Ruby on Rails
after elixir or Erlang or Haskell so
that they can then question why we're
doing it that way and look at the ways
that experience has helped us do object
oriented programming butter not going to
do a lot of language advocacy and I
don't want to start any flame wars
I like elixir as a language for new
developers new developers it's mostly
functional even though it's got agents
for State and we've got message-passing
of actors which feels kind of
object-oriented even new developers can
manage complexity pretty well in elixir
and the testing story is really easy
easy to learn when I teach a new
developer a new language I feel like I
have a responsibility to make it
something that they can use and this was
really tricky for me where I'm from we
have lots of Scala jobs like in
functional programming almost all of the
jobs are in Scala
but Scala is a hybrid language and much
of the programming that happens in Scala
where I'm from is still you know pretty
much Java that's not going to help a new
developer I'm predicting that elixir is
going to end up being pretty big I think
a lot more startups are going to are
starting to use a lick sir I think in a
year or maybe two years
it's going to feel like the new Ruby on
Rails the new node Express there are a
bunch of reasons for that I'm going to
skip them everything that was true about
Alixe here I think is also true about
elm it's just the front end versus the
back end we're starting to see in Salt
Lake City the first company is switching
completely to L which maybe is premature
at this point but they're excited about
it seems to be working so really that's
what it comes down to we need to teach
developers right simple and correct code
new developers start off writing simple
and correct code all developers all of
my developers writing simple and correct
code we don't always have that choice
you know we have constraints for our
jobs we might need to be working with
this language or that language so I've
been working on this concept called
functional first development basically
it's pretty straightforward you you code
everything you can without side effects
so to start with you you only deal with
the inputs to functions and the outputs
from functions the only state is in your
tests so that includes you know reading
from standard in don't do it no
databases no HTTP no standard out no
persisting to disk don't mutate any
variables just write your functions
compose your functions and then write
your tests around that after you've done
everything you can without side effects
then you write your side effects and
this has some some neat advantages if we
do the first step right then the second
step is only side effects
our first step makes code that's easy to
test our second step is code that we
don't actually need to unit test because
it's all libraries it's all frameworks
the frameworks come with their own unit
tests this is the stuff that normally we
would mock out so if we do it this way
our core business logic is clean and
simple and it almost never depends on
any other libraries our side effect code
is almost exclusively libraries and
frameworks so we don't have to mock and
we don't have to write unit tests around
the the decide effect code our side
effect code is isolated it's modular so
if we want to change the database engine
we're using there's nothing to it
because that code is all database if we
want to add a new interface to it maybe
we're doing a web interface now but we
want to connect to a message broker
we're just adding another interface and
this code but sorry this code will scale
much like it would if we're doing
functional programming even though we're
working in a language like Java or
JavaScript or Ruby it is trickier
because the languages that we're using
aren't supporting the abstractions in
the same way so for instance python is
going to pass object references by value
if you pass a list into a function in
python and then you do something with
that list python is mutating that list
so we need to be careful when we're
programming this way to make sure that
we're only dealing with the outputs from
the functions that we're not relying on
the inputs from one function at another
point in the code this is one way that
we can help new developers get into
functional mindsets without functional
languages yet mob programming
so about a year ago I was with
will bird and he was telling me about
his team at the University in the seat
in the computer science lab and they get
together every Friday for coding and
pizza for 6 hours and they did this
because a previous version of the
project they were working on was written
by one person who only wanted to work
heads down and and the entire knowledge
about that project was locked up in her
head and a bunch of lousy code nobody
else wanted to maintain it knew how to
maintain it and they were writing in
Scala and most of the team didn't know
Scala
so they started coding it the whole
project together on Fridays sounded
really interesting to me
about the same time I was starting to
plan our women's internship program at
OC Tanner and I had planned on you know
setting it up so that the interns were
pairing 100% of the time and I was
talking with Pat Maddox some people
might know Pat from the Ruby community
and he said hey have you heard of mob
programming and he explained it to me
and I said oh yeah wills doing that at
the University that sounds really cool
so he gave me he connected me with
Woody's Zul the guy who kind of started
mob programming down in San Diego about
five years ago and and we did some
research and a bunch of talking a bunch
of thinking about it and ended up
deciding to really give it a good go so
this is this is mob programming
basically you have like five to ten
people you have one screen one computer
one keyboard everybody codes but you
have one driver on the keyboard we've
been doing this for a year now or almost
a year we do it in three environments so
my team at work mobs we don't mob full
time but we mob pretty regularly we
often attract people from other teams
because you know when we have five or
seven people talking out loud in the
middle of our workspace in front of a
big screen TV it
like fun um and it kind of is so people
from other teams come over and join us
all the time on a good day we might have
thirteen or fourteen or even fifteen
people come through a mob in one day now
that doesn't mean we have 15 people for
the entire session but over the course
of the session we might have 15
different people involved in our mob
other teams started doing it we have you
see three teams right now have mob
mobbing setups in their workspaces plus
we converted two of the conference rooms
to mopping spaces we do a weekly testing
workshop if you've got a difficult
testing problem you bring it to the
workshop and together we figure out how
to how to test it that's now a mob
programming session every week so we've
done it at least 50 mobbing session so
far and I think probably seven different
languages I also teach this workshop
called an ounce of elixir it's basically
functional programming for new
developers we don't deal with any of the
theory we don't deal even with the
vocabulary we just get in and and do
things experientially satis in Salt Lake
City and also in London and the
participants for the workshop the second
day is almost all mopping during the mob
the problem that they solve is to is to
create a shopping cart and like I said
we don't we don't focus at all in the
vocabulary but we do direct them or
guide them towards what is an event
store or an event based shopping cart
with command query responsibilities
segregation so new developers people
have never worked as a professional
developer programming in Erlang
functionally and every single mob has
built a CQRS shopping cart on their
second day
the third environment where we've done
mob programming is in the woman's
internship program so this this has been
just four women mostly people
re-entering the workforce or retraining
so people have taken years off to you
know be with their kids when they were
little or people like I had one woman in
the first one who fifteen years as a
professional electrician they they're
the only ones who have mobbed every day
five hours a day five days a week for
three months the team is actually the
four interns and two juniors and they
ran their own mobs we train our mobs on
on these guidelines this is a long list
we'll get into individual ones we
started with you know like
recommendations that would easily have
promoted and then we changed them and we
added a bunch of our own so after a year
of thinking and doing it this is what
we've currently have start with better
than having anyone in charge so that
sounds like anarchy and it is it's
actually based on classical anarchy
mutualism and i I was bothered by this
at first you know like as soon as I
started thinking about and talking with
people about mob programming one of the
first things I said was hey this is just
more Anarchy and we've already been like
introducing more and more Anarchy into
software engineering teams and it's true
with flat I don't know how it is in
Europe in the States we are constantly
trying to attract new developers and
some of the ways we do that we have flat
organizational charts everybody reports
directly to the CTO or the CEO we have
no rules around engineers you know even
if the rest of the company has a dress
code engineers can show up in
Birkenstock shorts and a t-shirt and the
t-shirt can have holes in it's fine no
problem
um your workspace you know if they'll
buy you the thousand dollar standing
desk or or even the the treadmill desk
but we don't care if you go outside and
sit in the grass and code that's fine if
you don't want to code that's fine too
you know take a nap it's fine we offer
flex time we offer unlimited personal
time off and two weeks ago I learned
about this company in Salt Lake City
that is now offering unlimited maternity
and paternity leave it's amazing we have
very engineering driven cultures at work
I have worked at a place where they
decided to hire me and then and then I
had to figure out which team I wanted to
join and then I had to figure out what
code I wanted to work on um
I know of another place in Salt Lake
City where they don't give you any
instruction on what you're going to do
what they want is for somebody else on
your team on the development team to
approve your pull requests at least once
a month if you can't get anybody else to
approve your pull request well then
maybe we need to talk about your choices
my team does improv comedy training
that's where the yes and comes from when
you look at an improv comedy team they
never say no you get up there on a stage
in front of a bunch of people and you
have to work together and if somebody
says my name is Delilah you don't say no
it's not your Rob if you go with it you
know you build on it you preserve
momentum we do the same thing in mob
programming
when we communicate in a mob when we
talk we monitor our level of abstraction
in our communication so that means in a
mob of juniors they're going to talk a
lot about what are the correct key
combinations in them and how do you do
the git command that I need to to type
seniors when they're mobbing they might
talk about patterns and architecture and
control flow or teach each other monads
but if there are juniors in the mob with
seniors they also talk about key
combinations invent the expectation in
the mob is that everyone can understand
what they feel like they need to
understand everyone can expect answers
to their questions that they can follow
okay so we're all functional programmers
we know the difference between an
imperative language and a functional
language I'm sorry an imperative
language and a declarative language the
same thing actually applies to how we
communicate with each other and I learn
this because I have an autistic child as
a parent when we talk to our kids about
80 percent of the time we use imperative
language pick that up eat your
vegetables close to the door when we
talk to other adults we tend to be very
declarative you know I I feel this or
that thing happened I'm willing to bet
that you can imagine what work would be
like if 80% of our communication with
each other at work was imperative and if
you can't imagine it try doing mob
programming without any guidelines
there's this weird thing that happens as
soon as we put someone else between us
and the keyboard while we're trying to
code we turn into control freaks type
that no don't type it that no do this
that doesn't work very well in the mobs
so we we had to
work at staying declarative saying
things like that function looks funny
I wonder if this test is going to catch
all of our edge cases there's a typo on
line 47 I just learned something new um
thinking out loud becomes really really
important
a quiet mob is just a red flag
that's a mob that's not mobbing when
we're in the mob we're talking
constantly and and the talking is like
stream-of-consciousness stuff you know
we're constantly sharing how we think
something might work and it's entirely
reasonable to expect that in the mob
it's hard to learn we don't actually
know how to communicate about our code
very well I mean even though we're
experienced developers maybe if we're
going to sit down and do a ten minute
code review we can talk about it but try
to do six hours of coding where you're
talking about it constantly it's really
tricky it's something we we had to learn
to do most developers have a hard time
thinking and talking at the same time I
don't know if you experienced this I I
know you know sometimes I just have to
stop the conversation and think it
through and then I can express it if you
add in typing thinking talking and
typing all at the same time we can't do
it it's really really hard as soon as
the driver is trying to figure out the
code that we're going to write they get
quiet and now we're not mobbing we're
coding with an audience
one person solo it's no good so nearly
every time the driver starts coding they
also stop talking and that breaks them
up and we want the driver to be fully
engaged with the mob and we want the mob
to be fully engaged with the driver and
the way we do that is we take away the
thinking
the driver only types what the the code
that the mob proposes it's hard to do be
the driver and know how to do it and
then listen to everybody else tell you a
different way our egos get in the way
hey anybody here remember their phone
numbers by dialing in space yeah I can
tell you my grandparents number when I
was five years old it's a six oh nine
six six to eight to thirty six or if I
was at my grandparents house my home
phone number
you know it was six six we learned
differently when we code we learn
kinetically we learn with our muscle
memory when we're typing we're learning
kinetically it's a really valuable way
of learning it's a different way of
learning when we're typing then when
we're coding in the mob when we're
navigating when we're not the driver
there's study done that says if you
learn to do something and in the middle
of learning it you switch how you're
learning it you change the situation we
actually can increase the speed with
which we learn a new skill to fold I
think we're seeing that in our mob
programming okay so the last and most
important guideline we give is that
learning is contributing almost every
mob we've done has had at least one
person who didn't know what was going on
and didn't want to disrupt the flow of
the mob because well everybody else knew
what was going on or so they thought
it's not a it's almost never true we
really needed to find ways to make sure
that everybody knew it was okay to stop
the mob and learn about what was
happening
toy one benefit of that as soon as you
explain your code you see the problems
with it I mean like when you're in the
flow and you're just coding along you
know it's nice you know our tests are
going to catch it later
probably beta tests in the field but
their tests are going to catch the
problems later but if you stop and
explain what you're doing someone else
who isn't keeping up and let me tell you
that someone else who's not keeping up
is very often me the most senior member
on the team as soon as you explain your
code you you start to see it differently
so to see it from somebody else's
perspective you you kind of have to
defend it and you find problems a lot
more quickly and usually if there's one
person who will stop the mob and say I
don't get it we find that there are at
least two or three other people who are
in the same boat and we're just hoping
that maybe they'd catch on and we we
have juniors who need to learn how to
code need to learn how to deliver the
value right so we have a responsibility
to them to make sure that they
understand and we have seniors who like
me often are in it aren't comfortable
admitting how much they don't understand
so it's a great time for a junior to
come along and say hey I don't get it
and then I can just sit back and you
don't learn oh I'm sorry this is our
last guideline I love this this is
straight from Woody's we'll turn up the
good if it works do it more this is like
you know it should be a life motto if it
works do more of it um I translate this
directly into do good retrospectives
which you know sounds not as fun as turn
it up but we do we actually did
retrospectives after virtually every
mobs programming session we did last
year standard questions for my team with
seniors is what went well what went
poorly what do you want to try
differently and what has you baffled the
interns like I said the interns they
they ran their own mobs so they came up
with their own questions and they went
through like three or four iterations
of different questions but what they
settled on was what should we keep doing
what should we stop doing what should we
start doing and what surprised you for
the workshops I get kind of touchy-feely
and so we go with how do you feel about
your code how do you feel about your
team how do you feel about yourself it's
really good
the retrospectives are great we're not
going to get into them I can tell but I
have a bunch of them and when I finally
get these slides online you should
totally read them okay so this gets us
into the retrospective I think there is
what like three minutes left anybody
know when are we supposed to be done
somebody stop me when I have to stop
okay so I've got a bunch of slides on
what we did wrong which is basically how
we learned the guidelines that we
learned I'm going to go to the pub um
where is it
okay so I've mopped probably a hundred
times with probably a hundred different
people in the last year and there was
always this one guy who caused problems
that guy was me more often than not I
was the problem the teams that I mob
with I'm the boss right so I'm in a
position of authority and then we come
along and we make this happy little
hippie egalitarian mob where everybody
is supposed to have you know the same
weight and determining how we do things
and I say oh but I don't want to use
Java and they say in the retrospective I
was unhappy we didn't use Java 8 and I
got a pre-emptive shutdown before I even
brought it up
I think it's different for you because
you are in a position of authority
it's taken a lot of trust to get to the
point where people would disagree with
me and a lot of that trust comes from me
not expressing any opinions anymore just
trying to listen and and watch what the
mob comes up with I don't say I don't
want to use Java anymore
I trust that they remember that comment
from before in the workshops people have
said really positive things about the
declarative versus imperative that it's
really worked for them that it's
something that they had to learn how to
do that they kept finding themselves in
situations where they wanted to say
don't do that but they needed to say it
declaratively so they say I don't think
you should do that in every mob we've
done there have been a few people who
said you know this doesn't work for me
mob feels too big I'm happier working by
myself
I want a beer okay so the interns did
their own retrospective
I didn't even read there don't tell them
I didn't even read their retrospective
until after their internship was over
um and it was really cute it was great I
loved it this was their first day their
first day you know I trained them and
said hey you're going to share a
keyboard and you're going to pass it
around and it's gonna be fun and they're
like I don't want to touch your keyboard
what if we just learned it you know and
then we can just like each use our own
computer every time we change drivers
let's change computers and they did and
they loved it it worked really well for
them after they figured things out they
they had to figure out how often to
change drivers they had to get good at
get they um they had concerns about how
long it took to push and pull they'd
forget to push their code you know I
just pulled in I thought that didn't
didn't we where's doesn't just happen to
interns okay um so we we did a lot of
things really right with our mobbing for
our team mobbing we really built the
team up we communicate really well with
each other we care about our work we
care about the work that each other's
doing we know what everybody else is
working on I mean even now we're not
even mobbing that often and my team
which is really quite small right now
we're on three different projects but we
mob on each of those projects at least
one day a week I put stuff in bold I
don't know if that sticks out for you
but as I as I slammed through these just
read the bold parts and come back for
the rest later
okay so one of the
it really helps in a lot of areas there
everyone on the team feels like they own
the code right just like you said it
helps with ownership of the code
everyone on the team knows what's going
on in the code they don't have to sit
down and you know spend half their time
trying to figure it out everyone on the
team is starting to converge on the same
basic skill level like our team is more
uniform skills than any other team in
the company um inside the mob outside
the mob we don't have people questioning
value inside the mob we did it every day
we were constantly saying you know I I'm
afraid of slowing down the team I don't
know how to do this I feel guilty for
stopping us and I feel guilty for not
being a better developer I'm going to
finish up here my slides will be online
soon the one thing that I want to point
out is that we did qualitative analysis
on this not quantitative we needed to
learn how to mom and I did not want to
go into it saying and I'm going to prove
that the value is there so we haven't
done that yet based on our experience I
want I think we can start making these
claims as hypotheses and start testing
them and that most of them are going to
be true thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>