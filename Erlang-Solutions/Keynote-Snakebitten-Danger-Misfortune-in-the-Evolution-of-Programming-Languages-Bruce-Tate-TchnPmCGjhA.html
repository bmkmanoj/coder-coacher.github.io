<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Keynote: Snakebitten - Danger &amp; Misfortune in the Evolution of Programming Languages - Bruce Tate | Coder Coacher - Coaching Coders</title><meta content="Keynote: Snakebitten - Danger &amp; Misfortune in the Evolution of Programming Languages - Bruce Tate - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Keynote: Snakebitten - Danger &amp; Misfortune in the Evolution of Programming Languages - Bruce Tate</b></h2><h5 class="post__date">2013-07-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TchnPmCGjhA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Francesco you're very kind perhaps a
little bit too kind and I'll try to do
you some justice
I want to thank you for the invitation
to come here most of the people in the
audience know more about Erlang than me
probably far more about her laying than
me so I feel honored to be invited to
close this conference and Stockholm has
been I always keep a top-five list of
places in the world that I want to go
and Stockholm was right up there and
it's a pleasure to check one off but
it's a bigger pleasure to check off a
place and then come there and find that
it meets in surpasses everything that
that I thought that it could be you have
a beautiful country
you're an amazing people and thank you
for welcoming me I want to start this
talk with a story I am a mountain biker
and this is a this is a little part of a
trail I like to climb and it's not quite
as steep as that spiral staircase there
but almost and it's a little bit wider
but if you start on the upper left and
then go around counterclockwise the
first picture is kind of looking through
this this big crack in the rock and the
next picture is of texture and so
picture yourself riding up this on a
mountain bike with with big rocks and
probably every second or third time I'll
blow the climb and then have to step off
always in the same place and that's the
third picture or I'm sorry the third
picture is looking at the crack from the
top and the fourth picture is the place
that I always put my foot when I blow my
client now on a particularly bad day I
messed up in the first couple of feet
and I was kind of mumbling and grumbling
and I was walking my bike up and then I
heard of buzz and I looked to the right
right in that place where I would
normally put my foot and there's a big
rattlesnake sitting there looking at me
and I have thought philosophically about
this moment many many times and in fact
I didn't take on mountain biking for
that kind of pain right
but it impacted me more than I thought
it was would even though I didn't get
bit at all if that makes any sense at
all in Texas we have an expression I say
snake-bitten
so I don't come across as an uneducated
hick but in Texas we call it snake beads
ain't nothing never good happened to him
he's just snake bit now normally when
people are snake bit they're snake bit
for a reason bad things don't just keep
happening to people without without a
cause normally I add I add this
extension when we're when we're dealing
with programming languages you get snake
bitten basically because you're trying
to solve a problem and you come up with
unintended consequences
so Francesco mentioned that I wrote a
book called seven languages in seven
weeks and that that also made me
philosophical it made me think there are
some really cool languages out there why
didn't these languages succeed and why
did the ones that that we've been well
kind of burdened with why did they
succeed in the mass market and that's
kind of what we're gonna look at during
this talk so we're gonna spend a lot of
time with a language tree or a language
timeline and I did some heavy research
here Wikipedia and built a rough list
and just threw down some of the ones
that I found is interesting and then I
thought about what some of the things
were that were happening at the same
time and then I thought about what are
some of the architectural models that we
settled on and then I thought about the
impact of all of those things on to the
programming paradigm because languages
don't succeed or fail in a vacuum they
succeed or fail based on what's going on
the
same time and and Joe has experienced
this quite a bit so what's going on here
is that there are a series of things
that are happening in the marketplace
that are pushing hard exerting heavy
pressure on the languages those that
fail and those that succeed too so let's
talk about the first block of languages
here really it's it's one language this
was before we had higher-level languages
it's a similar language and it's
basically it's basically tying a single
instruction tune in state to a single
block of memory and at this point at
this point in our evolution before 1955
it's important to point out you know we
tend to take computer design for granted
we have an architecture called the von
Neumann architecture and it's it's
impacted language design probably bigger
than than any other early influence but
I want to point out that von Neumann
computers were not the only kinds of
computers in fact my brother worked on a
battleship I think that this is one of
the sister ships my brother works on the
Iowa and if you look at these little the
little clusters there they're hand
cranks and the reason that that's
important is that these aren't bits and
bytes and what this what this computer
did was take into things take certain
things to account like the direction of
the chip or the motion of the waves or
you know things like that constant
inputs and it would output an elevation
or a firing solution right direction and
elevation for a firing solution this was
called the mark one computer and it was
not a von Neumann design but the von
Neumann architecture eventually won and
it had a pretty heavy pretty significant
impact on us and we'll we'll talk about
what that architecture is and what that
impact is as we move forward a little
bit which takes us to the first
collection of languages these are the
first high-level languages and you can
see that there's a cluster of languages
in there that you recognize and one that
you may or may not recognize
but if you think about it what is it
that is special about Fortran and COBOL
versus what is special about Lisp Lisp
was written gosh about 50 years ago
little more than 50 years ago what was
special about it well you know it has it
it is a far higher level language it has
a very impressive metamodel it has
functional concepts and you compare
those to the cobol's
and the fortran's of the world and when
you think about that when you think
about the reasons that drove the success
or the failure of those languages it's
easy to get pretty frustrated in the
United States we had the show did you
guys have Celebrity Deathmatch here so
it's a club claymation show it's often
pretty violent and and they might pit
Madonna against Michael Jackson and say
who win or something and that would beat
each other up and and you know pretty
crass and irreverent ways but we're
gonna have our first Liberty death match
right so think about a list for it's the
higher order functions the garbage
collections the systems the datas code
all of these very powerful ideas and you
compare that with Cobalt right you say
who's gonna win oh I know who's gonna
win but but no
how did it happen so we're we're saddled
with code basically today if you're in
the mass market now I realize that we're
in the Erlang community but if you're in
the mass market today you're probably
doing Java if you're if you're a really
smart guy in the mass market you may be
moving towards Ruby or something or a
Python or something that's a little bit
more a more modern object-oriented
language but you still have code that
looks like this and I can I can see Joe
here going booths mutable state wait a
minute those Bruce those values are
going to change over type you bound X
twice no don't do it don't do it and we
have a lot of a lot of words for this
immutable state or if you talk to the
founder of closure rich Hickey he talks
about this idea that we're binding
identity to value right so identity is
bound to value and as time changes that
binding can change and it's very
difficult to get concurrency models
right I mean you've probably heard about
this all weekend and I'm not gonna say
anything else about it
so you got the idea
so the von Neumann architecture is
really what's going on here so we
thought about we imagined the way that
languages should look because we knew
what the computers looked like
underneath we had this thing called a
program counter the program counter
would move and and different registers
or values would change over time right
and we wrote our languages to match the
von Neumann architecture now it's okay
how many of you think that I'm actually
full of it you could raise your hand
okay you you are way too polite but some
of you are thinking there is no way that
40 years later or even 20 years later
anybody would think of the von Neumann
architecture as having a great impact on
the programming languages now I was
looking at a as I was doing research for
this book I looked at a 1977 22 years
after what we're talking about here
after the creation of Fortran I looked
at a 1977 Fortran user's manual and this
was the first image in the book direct
cut-and-paste
so they were saying hey philosophically
what you should be thinking is that this
is a computer so this is what your
programming language is going to look
like and what we wind up with is a snake
bite the snake bite we call mutable
state and that one's going to stay with
us for a while it's still with this and
it's it's the one that's going to be in
our way that we have to get through if
we're going to solve if you look all the
way down there third column the very
bottom it says multi-core we've got to
solve that snake bite before we can
before we can move forward here okay so
let's talk about the next family of
languages here and this is really the
next programming paradigm which is
procedural programming and in fact a lot
of people are going to go to school
around this time frame and
in something like Pascal you know a
highly structured language and they'll
go to work and write something like see
during this during this timeframe I
actually graduated from from college or
actually started college at the
beginning of this of this period and and
finished it with with more structured
programming and the model that we'll
talk about next and in fact I did learn
Pascal and go to work and see but there
were some other very interesting things
that were happening at the same time we
weren't we are just talking about simple
procedural languages there are things
like fourth which is which is a
radically different programming paradigm
small talk it's an object-oriented
language and it's actually I think a
much better cleaner simpler language
than the object-oriented language that
we we started with and gosh what else is
interesting here VisiCalc
I think is a fascinating a fascinating
look at really another programming
language it's a spreadsheet but if you
think about it this is a programming
language that has powered are all the
financial communities across the world
in fact we have these massive programs
that everybody depends on that the Wall
Street and and European financial
systems all depend on being right
this code is written once by people who
are not programmers it is not tested and
the stuff by and large works it's a
pretty powerful programming model it's
actually more of a functional
programming model than then an
object-oriented or a procedural model
but yet we picked something else right
so the deathmatch here is between I'm so
sorry I told you the winner before
okay the deathmatch here is between a
small talk on the top and see on the
bottom between you know beauty and
verbosity but but between a more more
practical and pragmatic performance
oriented language and and kind of a a
beautiful applications language
right and see winds and if you look at
this victory it's not just a little
victory it's a victory that'll stay with
us for four decades and in fact if you
look at a site called language pop and
now I know that this isn't an accurate
measure of the popularity of a language
but just for a snapshot look at the top
one two three languages there right
those are so they are if you can't read
them they're there see Java and C++
they're the same syntax family right and
then there's Perl the world's only write
only language then there's JavaScript so
that's four out of five based on a C
syntax and then there's and then there's
Python and then there's c-sharp so
that's five out of seven of the top
languages based on a syntax for a
language that was built to write
operating systems and we're doing
everything in those languages right so
the problem is that the applications
that most of us write the business the
business applications web applications
things like that the needs are very
different from the needs of a language
that's built to build operating systems
right so if you're building operating
systems you need explicit Aliph ocation
bit level control weak flexible types
actually a lot of things that Erlang
gives you and and if you're building
more of a business application you need
cleaner garbage collection you need
stream manipulation reliability right so
if I'm a business user you would have
expected somebody completely different
to win that deathmatch maybe it's small
talk maybe it's Pascal maybe it's one of
the other high level languages because
the choice for business versus
performance is really control versus
productivity or performance versus
expressiveness and we chose wrong so we
took the more specific use of building
business applications and we said hey I
want my business alpha
cases to be fast I'm gonna write and see
and that's the way the mass market works
right so we have a snake snake bite in
this case we're saddled with a
programming paradigm that that's
imperative versus functional we're
saddled with a syntax that that is see
like that's that's good for the job but
not great for business applications
we're so we're saddled with a type
system that we're still struggling with
and trying to get right and the various
programming idioms that started with the
80 language that was not written for
what we did with it now I want to point
and point out something here one of the
reasons that small talk didn't succeed
out of the gate and out of the gate was
1970 or so but it stayed in the picture
for a long long time and never quite
broke through and one of the reasons is
that when you are when you're designing
a language that has a different paradigm
and Joe has gone through this it's very
difficult to get people to adopt a new
programming paradigm right off the bat
you have to have a bridge language that
kind of that kind of introduces some of
the new ideas and for the world when we
move from the world of procedural
programming or structured program to the
world of object-oriented programming we
had a couple of bridge languages right
the most obvious one is what from C to
C++ right did we write object-oriented
C++ code no it was all it was all
structured procedural C++ code right so
it was really like a C++ - - but the
introduction of C++ was still very
important to us because it started to
introduce the ideas of object
orientation and what they could do for
us and how they could help us better
organize code in fact there were other
bridge languages as well if you were in
the government you were probably using a
language called ADA which which
introduced the area the
the idea of encapsulating data and
behavior so which brings us to the next
family of languages but the next
programming paradigm object-oriented
languages right now if you look at this
list and being in the crowd and the
Erlang community that that you're in
you're sitting in the chair that you are
today this one probably hurts a little
bit this is probably a probably the
first time where you say hey the mass
market could have made the right
decision they made the evil decision
right look at all the cool things that
were going on at the same time I mean we
all know that Earling is is great I mean
I've come to love this language but
there's also Gus probably the best
typing model of all time the Haskell
typing model ci for the longest time I
thought that I hated static typing and I
realized that I just hated static typing
as it's done in Java and c-sharp but
look at some of the other cool things
that were going on the same same place I
think that you're gonna laugh at me for
saying this but I think that Visual
Basic was actually a very effective
effective language for delivering
business applications now that's a hard
thing to say normally I should be doing
something like do you like Visual Basic
no but my brother likes it you know or
something like that but so there are
some other things that are happening at
the same time Ruby is starting to grow a
little bit in Japan but really still
keeping a very low profile at this point
at the very end of the change you have
JavaScript that came out right on the
heels of Java and you have C sharp which
are you know basically you know C sharp
and Java are basically the same thing
and some of the things that impacted us
were you know the rest paper and the
introduction of Netscape and EJ bees and
the dot-com bubble right that wind up
bursting you can you can sense a a
pretty powerful theme here but there's
something behind the
when you see a programming paradigm
change you should always be looking
right under the surface for what the
business driver is for the new
programming paradigm right when when we
moved away from assembly language it was
because our programs were getting too
tough to keep in our head right we
needed better organization so we needed
just enough organization for the
language to be very accessible and but
but not too much - we're not more power
than our users could handle so if you
were looking at the business need
then COBOL and Fortran probably seems a
lot safer now if we're thinking back to
just before the proliferation of the
internet what's happening if you are an
IT manager this is your problem you have
tens of thousands of servers you have
hundreds of thousands of workstations
you have on that an operating system you
have a networking system you might have
a communications manager I remember for
os/2 we had the OS the operation manager
database manager and comm manager and we
had customers out there that deployed
all of those things with tennis shoes
and rollerskates and diskettes right and
if you had a bug in the operating system
it often required you to reload all of
the stack that was on top of it as well
right and IT systems were drowning it
wasn't just the deployment problem
there was also an explosion of
complexity and this is not going to end
as long as time goes forward we're going
to expect more and more and more out of
the people sitting in these chairs you
need to be able to juggle bigger ideas
and in in a tighter density right and
these are the the forces that we're
facing IT managers at the time now if
you look at this list you know who's
gonna win this next death match right
and you have to feel for the small talk
people right this is their second shot
of things right Oh C++ is finally
melting down we got him this time boom
right because it wasn't about the
elegance of the programming model it was
about deployment the Java explosion was
about deployment because you could Park
a browser on that system one time and
now you have your whole business suite
of applications and what we were sold I
know this because I was in sales support
at IBM at the time and what we sold our
customers was that you could design
applets that magically flew in from the
sky and solved your IT problems right
and eventually that that merged onto
onto servlets right which meant that we
were we were building the same batch
green screen applications that we had 30
years ago but that that's not what we
believed or what we were telling
customers at the time there were a lot
of death matches that were going on at
the same time if you were a business
user or a business manager and IT was
not keeping up your natural inclination
is to go build things for yourself right
so many of many people many of those
managers said I can get my head around
Visual Basic Visual Basic is relatively
simple right I can have this magic okay
push button and hanging off of that I
can have about 10k of code crank that
application out very quickly right but
it's not about it's not about the the
programming model it's not about
accessibility
it's about deployment boom right you
guys heard of this language the right
tool for the job right so you might be
asking yourself okay okay I believe you
it's about deployment so why can't I
just pick something that's marked for me
manager I've got this job that I can do
instantaneously and early
and your boss says Java and so you get
this troll on the left side of Joe's
slide that says band wasn't her troll
was it what was it some kind of creature
there anyway so so and you get this band
mesh in it message for from on high
because what the manager see is that
integration with C++ was so incredibly
difficult and painful that there's no
way I want to solve that solve that
problem if I invite more than one tool
into my IT shop one ring to rule them
all and in the darkness bind them
I'm so Java is maybe the best winner of
all time and we were talking about this
over lunch one of the things that
happened when Java went one was some of
it was good right there was there was
probably the biggest community the most
successful series of conferences of all
time you guys remember Java one in San
Francisco they didn't even have to go
anywhere else everybody came to them and
there were sometimes ten fifteen
thousand people with those conferences
and they were incredibly successful but
one of the other things that happened is
a lot of the other conversations around
the world dried up right and if you
think about it there are some things
that Java got right the the the
portability and and the ability to do
the things that Java eventually did in
the browser it basically saved IT IT
basically went from two years behind -
you know maybe six months behind but if
you look at some of the problems with
with Java it's it's pretty clear that
there are some some serious snake bites
now we still get to drag along all the
baggage from before right
we have mutable state only we've
multiplied mutable state because we've
said an object is philosophically
combining the ideas of state and the
behavior right so we're going to be
riding that horse even harder now we
also have we're saddled with the the C++
the idioms and also some of the typing
model but more importantly the syntax
which may be the wrong syntax for the
problems that we're trying to solve and
we have some new Snipes snakebites
like the typing model these are the
decisions that the Java team made static
and what was small talk small talk was
much more dynamic right and explicit
meaning you had to type int public
static void you had to basically
explicitly type everything and normally
not just twice but but more times
throughout the life of the program and
we had something called if you're going
to be statically typed you have a choice
you could say I can bind the type to the
name or I can bind the type to the
meaning behind the name I combined it to
the structure so these are the decisions
that Java made and these are the
decisions that a lot of people say that
they would have made instead and Joe
actually made a great point about this
in an earlier talk where where he said
that that Erlang's dynamic typing
allowed them to to express some ideas in
a smaller and more concise way and when
you combine that with Erlang's let it
crash philosophy you have all of the
safety and and all of the benefits of a
smaller cleaner typing mo so when you
think about these don't think about the
academic concerns think about the
problems that they solve for you so for
example when you think about static
typing you think when do you bind write
how tightly do you couple your software
when you bind in how tightly do you bind
when you think about explicit vs. and
fir typing you think about how much do
you type do you want strong typing with
your strong typing and when you think
about and when you think about what's
the last concern nominal versus
structural it's what do you mean what
does this piece of code really mean is
it really wrapped up in the name it's
probably not
so and then if you look at if you look
at the binding problem the binding
problem was particularly egregious ii
mean in the java world you might say
okay tightly coupled software that's
just an academic concern early binding
no problem until you look at all the
frameworks in java that have tried to
solve that problem how many of you have
have used java and actually coded in the
java space at one time in your life okay
so i'm gonna throw some buzzwords at you
that are related to the binding right
first there's the idea of component
models right and java objects weren't
enough why because they were too tightly
coupled so my tools needed to use these
things called java beans but the job of
beans weren't really enough because I
couldn't graft on the behaviors that I
wanted because Java beans were too
tightly coupled so I created this thing
called ejbs right I probably didn't get
that right the first time the second
time will be better EJB to Vinnie jb3
right and then finally we had we had an
acronym called a POJO a four-letter
acronym for the same object that we
started with in the first place plain
ordinary Java object right you can sense
that there was a lot of a lot of
consternation about this snake bite and
then if you look at containers we had
the same problem we had a jb's one two
and three and then we finally said no we
don't want a container
we'll have spring which lets us load
pojos and we'll graft on things by
what's called reflection and then that
was too slow so we actually said okay I
think it's probably a good idea to take
the bike codes and then so compile the
code and then that's still too tightly
coupled so I'll manipulate the bike
codes and shove behaviors in there right
we really did that and that was called
the the Spring Framework and then and
then there's the idea of of specialized
containers because you don't just have
this problem for ordinary Java beans you
have it for your database right you give
said EJB
hi Renee JD oh right we're writing we're
trying to solve this problem and we're
suffering over these problems but the
problem isn't in the database layer the
problem is in the language right and
then we did the same thing with
networking layers we did the same thing
with remote procedure calls and so if we
want to if we want to really harp on on
typing now I know that there are clean
ways to do static typing now in fact I
think that Haskell probably has the
object model that or the typing model
that most of us wish that we had but if
you're doing typing with an
object-oriented program I think that the
extra complexity and the binding
concerns make dynamic typing almost
necessary I wouldn't swear to this but I
think I think that I'm probably right so
one of the things that I particularly
like about Ruby is you know there's this
annoying thing that that when you have
an empty string or it might also be nil
I have to check for something is for
something that's nil or the empty string
right not to do this over and over well
in Ruby what I can do is open up the nil
class and say hey I'm gonna I'm gonna
give you a method called blank and and
from nil I want that to be false for a
string I want to I want to return true
if the self is the empty string and for
object I want it to return true for
everything that it's that it's not false
on for a raise I want to return true if
the array is empty right so then I could
say for any object in Ruby I could say
are you blank and it knows what I'm
talking about even though they're
disparate types they support the method
blank so I can treat them the same
ok so Java kind of started multiplying
the snake by defect it carried along the
snake bite for mutable state it grafted
on the snake bite of that the snake
bites that we brought along for C and
then we added the type the type snake
bites and then we added
all of the threading currency
concurrency and process-oriented
snakebites and no Jabez java turned out
to be not such a great a great language
to be building everything in right
there's some things that Java did for us
very well but if we look back at some of
the at what could have been oh my I mean
I think that we picked the pick pretty
wrongly right so here we are and look at
that list of languages look at the
languages on that list that are
workarounds for things in Java that suck
that's absolutely amazing to me right
and look at the challenges or look at
the inventions of the last of the last I
don't know what's that about 15 years
and the one on the bottom has me pretty
scared right multi-core the people in
this room aren't scared I'm building a
ruby application right
I chose Ruby knowing that it was going
to enhance my productivity out of the
gate but knowing that like Twitter the
second from the bottom there they
succeeded in Ruby enough to have have a
scale failure but their success bought
them the freedom to rewrite that's my
model that's my model right but I know
that I'm going to that I am NOT going to
in five years be writing solving the
concurrency problem with threads and
locks right we all know this so have a
couple of observations the first one is
on this language list you start to see
some bridging happening right the most
obvious one is is the scholar language
it has the object-oriented concepts and
it's trying
to build on top the functional concepts
that particular pairing scares me to
death because it's it's actually
graphing on it's carrying along some of
the same old snakebites right the
biggest one being immutable state I
think that we have to get away from from
that problem and I think the only way to
get away is with a more dramatic break I
might be wrong here this is the business
problem that is going to drive us into a
new programming paradigm it's gonna
happen it's gonna happen so right now
we're talking about four cores eight
cores and you can make Java programs
work by accident and eight cores that
only crash occasionally when we get in
hey I'm not immune in Ruby what I've
done to say is said hey one core is
enough I'm gonna run everything in its
own process and its own thread right and
so what's happened is that Moore's law
that the law that says we're gonna
double in speed every year in football
we have this play called a punt right
we're the office it has the ball and
they can't go any further and so they
kick the ball right and they give it to
the other offense and they trade sides
with the defense so they say defense you
got this you got this right I failed you
got this so what has happened is that
the hardware guys have said hey that
physics is that physics thing is kind of
tough and you know they're three atoms
thick we did the best we could we can't
make them any smaller right so we're
gonna snap stack chips up now and you
have to solve the problem the people in
this room have to solve the problem or
what happens is that our computer
economy that the the premises that all
these companies that are based on that
we're gonna double in speed every seven
years that can still happen but you have
to make it happen right so people have
been talking about the emergence of
functional languages because they're
better and cleaner and cool that's not
going to do it what's going to do it is
we're going to move
two functional languages because we have
two we don't have a choice
so this will be the next programming
paradigm you might say well hey what if
something else emerges and and my point
is that things cannot merge emerge
quickly enough they need to already be
on a radar we need to have already had
some experience with the bridging
languages and not just things like Scala
but in Ruby I've been exposed to
closures and and I've taught people to
use to code that way we're starting to
to think in terms in functional terms
even in the object-oriented space okay
and I want to point out something else
that's particularly encouraging to me we
talked about the one true ring to rule
them all and in the darkness bind them
right there are some integration
technologies first that the thing are
very effective I can partition in a
system with rest and some of the
technologies that you built in Erlang or
they're similar technologies and in the
closure space I can partition a
functional program much more simply than
I can partition a an object-oriented
program that gives me hope that maybe
the next winner won't necessarily be a
single dominant winner I'm not making
that prediction I still think that
there's going to be one language that
that has that Garner's more sure than
than the other ones I think that that's
just the way the world works but but
that's that's just a guess I do see a
little bit of a ray of hope
and in this place I like more of a
polyglot world where we can choose the
languages that that are best for solving
the job because I think that that type
of diversity Spurs all kinds of
invention and and it's also competition
makes makes a much more effective
marketplace so I have a couple of
lessons and I hope that this will help
us wrap up the the conference
why do languages emerge why do great
languages emerge first you guys think
that Erlang is a great language clap for
yes or silent for now yeah I actually
agree with you
wide great languages emerge Joe do they
emerge because of great languages and
because they're cool no no they they
emerge because you solve a critical
business problem and it's no accident
that Erlang was developed in Ericsson
labs to solve a critical business
problem it just so happens that the
whole industry is catching up with you
in the business problem we realized that
we're gonna have to be building
distributed concurrent applications
there's no choice now
right languages in Merve because they
solve a problem not a bunch of critical
problems but there is one big problem
that creeps up on the world that that
has to be knocked down right the second
question is why do we get snakebites how
do we wind up in the place that we are
where most of the industry is still
riding in a C syntax and the language of
those built for an operating system we
chose that as the language for our
business applications we're still using
it what thirty something years later
almost forty years later I think that
what happens is that we apply a specific
solution right C is fast to more general
problems right we don't do the critical
thinking for ourselves so the third
question I met online conference and
you're gonna say hey Bruce what's the
winner write or let me let me change let
me change the word the wording around
rather than asking yourself what is the
winner gonna be you should be asking
yourself another question what can we do
to make Erlang the winner right
what can we do to make early in the
winter or if there's no to ring to rule
them all what can we do to make Erlang
more relevant so there will be a bigger
more helpful community there will be
more opportunity for Erlang jobs there
will be more Erlang employers there will
be a bigger ecosystem so I don't have to
write as much myself right that's what
we want I have three charges for you
some of them if you're if you're from
Sweden or from cultures like the culture
here they might be more difficult some
of them are going to feel very natural
for you the hard one first so right
people need to know about how
spectacular this framework is when you
have a success you need to tell
something about it you need to you need
to do your lightning talks you need to
speak at conferences you need to blog
you need to tweet write anything that
you can do to tell people about success
you're not bragging about yourself
you're trying to share the wealth the
things that Erlang is giving you so my
first challenge to you is to become a
Salesman the second one is embrace you
know there are communities out there
that when they start to have tension
part of the community takes their ball
and goes home one of the reasons that
we're not talking about Lisp is that I
can fairly ask you which one right there
there have been so many fights within
the Lisp community and so many splits
and divisions that that for a while that
was unrecognizable now Lisp has another
shot with the with the closure with the
closure community that's that's pretty
much consolidating around a a single
strong vision right but there are some
things that are going to be happening in
the Erlang space that are really
important one of the things that Erlang
does very well is
jvm another thing there does very well
is OTP I'm sorry the beam huh oh that's
a bad slip snake bite snake bite snake
bite
you're like the JV Oh No so there's
there's the so one of the things that
airline does well is the beam and
another thing is OTP one thing that I
found myself missing I would be coding
in Erlang today if the Erlang metamodel
was stronger inter elixir right maybe it
doesn't have everything but this is part
of the ecosystem that can really have a
big impact on Erlang and hope and help
the whole ecosystem grow right the last
one's going to seem a little bit weird
it's a really important one that when
you have a community that you help other
people also embrace the new technology
right one of the things that I loved
about the Ruby community is the founder
of the Ruby community his name is matt
sand and a famous expression in the
community is matt's is nice so we are
nice and he's a close friend and that
rings true to me so what you had was
basically a language that was very
successful at doing what it did so so
ruby wasn't built to be a commercially
successful language it was a language
that was built to make programmers happy
right to be easy on the eyes to do the
things that that the programmers of the
time wanted it to do and Ruby didn't
Ruby didn't get very successful right
off the bat it took the rails framework
and showing people how to use this meta
programming which is really why why I
moved into the Ruby space and still that
wasn't enough for success when all those
rails people said hey that's cool they
had this great Ruby community waiting on
them with open arms they were they were
very inviting they were a very friendly
community and they made embracing Ruby
fun and so my three challenges to you
are not to be afraid to sell to embrace
the interesting stuff that's going on
and to love so that's what I have to say
today and do you have any questions
thank you are there questions oh that's
wrong yes I don't think that there's
ever a next business critical thing I
think that there's one driver and I
think that you know if you look back at
all the emerging paradigms we knew that
assembler language assembly language
wasn't going to last too long because
you just can't put that much stuff and
stuff in your head so the first business
challenge was complexity the second one
was was procedural language let's see
actually the second change the second
challenge was probably also complexity
because at the time that C was emerging
you also had networking a database
coming in into play and so you had to
write much more complex code faster and
then the next programming paradigm
object-oriented paradigm was deployment
we were thinking basically there's
there's always an undercurrent that the
current programming paradigm is running
out of gas right there's just more more
that I have to keep in my head then then
I can organize with with this particular
language which is which is just a tool
right it's an organization tool but then
there's a catalyst and when I talk about
the business problem I'm not talking
about the underlying you know the
inadequacy the mounting inadequacy I'm
talking about the catalyst that sets it
off and and with Java it was very
clearly deployment and I think now it's
very clear that the problem is is
concurrent programming not just on mole
the core but also in distributed
applications right so the next business
problem is probably 20 years out if you
look at you know 1955 Fortran 1975 ish C
1996 Java I mean we've had pretty
regular changes and I think that Java
put off the inevitable a little bit by
changing the programming model with
aspect oriented programming so really
job it with a o P is more like Java plus
plus right and it's just heading off the
inevitable you can see it starting to
mount and starting to happen because all
of these languages that are workarounds
for problems in Java right but
multi-core is it I'm very confident of
this fact yes missile programming I
don't think I don't think I even have to
answer that I mean you said job with
pictures okay so I was working with we
actually talked about a company called
oti which was object technology
international that built a very
successful small talk virtual machine
and then IBM button then they said hey
we should do programming with pictures
so we added visual age which you could
do the user interface but you could also
do ands and ORS and stuff with arrows
and you didn't have to write a lot of
code you can do business applications
with only this much more scripting right
and the problem is that there's always
the idea is that you can express with
today's visual programming techniques
aren't rich enough to express the
business rules with the density that you
need so what happens is that you are
meant the visual programming model with
code and and we just can't we can't keep
in our heads anymore it's not an
object-oriented model or
so model anymore it's the visual model
plus the functional code and we can't
keep that straight we can't refactor it
we can it breaks down so yeah job with
pictures is a pretty good description um
now I know that I'm coming across this
as a Java basher i'm really not that i
think that java did some great things
for the time but when you look at the
language list up there goddammit it's a
little unfortunate right more questions
yes that's Colin let's go see so the
question is what about functional
extensions in Java what if the next
thing really is j + + but it's a real j
+ + a functional java ok so i see for
real contenders let me first answer what
what you asked and that's do you know
where do you see a functional job i
think that there are significant
problems in the community first because
they expect backward compatibility and
if they can't get something like
closures built inside of gosh would it
take 10 years almost then they don't
have a prayer at more radical change and
i have this on the word of you know
somebody very high in in the oracle
organization that you know i can't use
this name on stage but but there are
some significant barriers to real change
without backwards compatibility in java
so there are also challenges with the
JVM there are state problems there are
it's it's basically a virtual machine
that was built to support the job of
processing model the Java threading
model the Java memory model and the Java
stateful behavior so let me let me put
that fear out of your mind you don't
have to have that nightmare tonight
right the contenders see now I'm going
to put that fear back I'm gonna give you
that nightmare it's kala I think it's a
real contender bridge languages are
important I think that Scala probably is
not a clean enough break with the past
and we might have the J plus plus minus
minus that's that's that's a real fear
but counterbalancing that we have to get
multi-core right you know and and I
think that that means that one of the
more pure functional alternatives will
win and those are most likely Erlang or
some derivative like elixir or some
combination thereof more likely a
combination thereof Haskell which may
not be accessible enough this might be
the list versus COBOL of 2013 right
we're more likely 2015 or gosh what am I
missing
closer closure I think what you have is
essentially a unified list that's on the
virtual machine that has a very
significant install base and the
founders of closure most specifically
rich Hickey
he's theoretically brilliant and he gets
a whole lot of the stuff right so and
then I'm gonna I'm gonna offer a photo a
fifth alternative really the there are
three major ones that I mentioned I
don't really think that scholar will win
because I don't think it's a big clean
enough break with the past I don't think
that Haskell will win because it's not
accessible enough to two programmers
today and I don't see how it can get
there soon enough but I think that we
really have a shot this time of the
right tool for the job
which would be a welcome improvement I
mean I think that there's a natural
there's there's a natural
benefit to all the languages involved
when there are competing languages and
when there are great synergistic ideas
that can that can emerge between them so
those I didn't pick a winner I'm not
going to pick a winner I wrote seven
languages in seven weeks mainly because
I was afraid I couldn't pick a winner
and I thought there are a lot of people
like me that need to be learning how to
compare languages by by doing something
non-trivial in them so that's that store
my heads up more questions
f-sharp I kind of put AZ in in the
Haskell umbrella much like up at C sharp
and the java umbrella but it's an
excellent language and Simon paint and
Jones is is gosh he's brilliant and it
has absolutely fabulous leadership in
the Microsoft organization yep yep so
that's that's a that's a flavor of
that's that's when when you look at
Haskell that's that's a derivative of
Haskell that's that's got to be in that
mix
yes so there was a comment I didn't
catch at all but there was a strong
preference for something like a language
conference as a language conference and
and the idea that that languages can can
change the world which I wholeheartedly
agree with yeah I'm not hearing you very
well so but thank you so much for the
invitation I think it's an honor and
I've really enjoyed my stay here
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>