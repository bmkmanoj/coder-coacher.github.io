<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Patterns, Open Debate - Erlang User Conference 2015 | Coder Coacher - Coaching Coders</title><meta content="Erlang Patterns, Open Debate - Erlang User Conference 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Patterns, Open Debate - Erlang User Conference 2015</b></h2><h5 class="post__date">2015-08-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RsAopNEW2K4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so what what i did i'm skipping
throughout this is not a presentation on
this I actually want to get some folks
involved here I want to give you some
examples so what I've done here is
created a website we just quickly jump
over to that hopefully it's still
running oh so here Erlang patterns for
the win all right okay so this is really
what I like to get at that that all
right f alone okay so I want to apply
this someone experimentally to Erlang
and it's really like any other patterns
elaboration but I would like us to be
challenged by Alexander's vision of it
being informed by emotions so what I've
done is stub something out I really want
this to be very much a community process
it's not a matter of one person
prescribing a bunch of patterns right
just the opposite we want to discover
that we want to experience software that
we love observe that and then try to put
a name on why is it that we love
something and so codify that here and
this is not just fuzzy crazy stuff there
are actual patterns here and I have
stubbed out quite a bit there have been
a number of people who have added their
own the state of this is very very very
early it's very raw this is almost brain
dump state and there is no kind of you
know this is the right way and this is
the wrong way I expect this to be a
matter of sort of weight you know
allowing things to kind of come up and
see what happens and and and and see
where this goes so it's very much
dependent on community and contributions
so let me throw one out here I'm just
going to pick one at random so the
flipping over to this I might have
extended my go on past here so each
pattern is organized into categories and
these are the this is the first set of
categories that I've just thought of
here it starts with as low a low-level
language constructs because these are
patterns we still want to capture so a
function is a
we can say we know what's useful about a
function that's actually really
interesting especially for somebody
coming from oh oh land who might be
interested in looking at software only
through the lens of classes and objects
you know how is it that a function in a
functional programming world or
JavaScript role we learn this morning as
a functional language didn't know that
you know how is that a function can be
used to you know along with data
structure to do anything so something as
low level as that all the way down to
pro high level principles fail fast you
know it's not really codified in any one
particular language construct but it's a
philosophy and it's a pattern that we
can apply so we have everything in
between so types of functions behavior
types process types and these are
specific to airline so we're not trying
to capture all languages here but this
is just airline application level
facility and a distributor facility so
as an example oh here's a great one io
list I mean that's a fairly low level
that would probably come down into it's
not it's it's sort of a pattern and
language but what's a nihilist well it's
a list of things that eventually can you
know be you know channel through i/o
channel so integers but they can be
captured as in in binary snippets and
other lists as single integers so if
you've ever if you've ever worked with
io list in Erlang I you you you
hopefully SAT back and said wow you know
as soon as you relax your brain a little
bit and just allow io to be a you know
arbitrarily nested list of integers and
it's very freeing and it's actually
extremely performance so that sense of
you know you know how did this thing
work why is it good we want to capture
that and I think I alyssa is one of
those things in Erlang that people
should talk about and use and think
about really quickly if you've ever seen
on the list somebody says well how do i
create a string from this you know how
do i represent that as a string in every
other language that i know of you tend
to have to construct strings all the
time in this is i'll list in erling you
don't worry about that you just capture
things as you go and most of the i/o
related functions deal with iOS very
well so I think knowing about that as a
pattern is certainly very important as
an erlang programmer but it also
features something in the language think
it's useful that's an example and we
have everything from that too
you owe somebody somebody had a chain so
I think I had something similar to that
but like we have a pipeline of
functionality and you say okay I have
found that in encode when my code
becomes excessively sequential so do
this and then this and then this and
then this and then this I find that that
becomes sort of a bad feeling for me I
often will look at that and say well you
know what's going on here is actually a
pipeline of different you know
independent functions that are
communicating sort of as a pipe so
elixir has codified pipes there's a very
common pattern to use so I want to name
that so rather than saying having a big
sequential list of comma delivered comma
delimited statements it's really
treating her laying as it as a as an
imperative language almost at that point
let's declare what's going on here and
represent this as a pipeline or a chain
of functions again another pattern I was
talking to Joe earlier and he was
talking about some patterns related to
data access wanting to create locality
and colocation between functionality and
data that's a very powerful pattern it
also involves replication so there's
some things in there that he's
experiencing enjoying you know I think
you're enjoying this process here but I
want to bring the emotional element into
this he's excited about I could tell I
don't mean to embarrass you here but
this is another example I think of an
important discovery process you might
not want to name it right away but you
say oh this is really this is very
useful and very important but when you
name it now you have ability to
communicate it and share it and now
other people have the ability to use it
and you say oh blah blah blah pattern oh
that's that fits into this thing and it
becomes part of our vocabulary and
alexander is going to say that once we
have a pattern language we can start to
build things with that and these things
will have a certain character so when
our pattern language is good our results
will be good they'll be inhabitable
they'll be enjoyable they'll be fun
they'll work well and he would then push
that further and say these are things
that will take on this quality that has
no name it's a very very good read of
you if you have some sometime timeless
way of building by Christopher Alexander
all that said what I'd like to do is
spend a little bit of time just kind of
with improv here if somebody has so
here's so I'm going to make this up as I
go
who is it a keeping track the time
because I'm not what is it supposed to
end when so just shout out five minutes
when we have five minutes and then I'll
know what to do okay so here's the idea
we've got a couple of microphones here
and i have no idea this is going to work
or not but let's try it why not i'd like
to capture some good content here we
have a number of patterns here
established but i don't care i would
like somebody here folks here to think
about a positive experience you had with
early i will really want this to be
emotionally driven think about something
that made you happy like seriously you
got happy it wasn't oh this is
intellectually an amazing construct
that's academic that's fine there's room
for that but I want this to be visceral
I want this to be very human emotional
because we are human programmers this is
primarily a an exercise for human beings
we write software for ourselves to do
things for the human species this is
great maybe some other species but this
is human I want to be emotional so think
of something that you've really felt
good about and then talk about it and
maybe there's a pattern that comes out
of that and there's a couple microphones
and let's just say you know a few
minutes five minutes or something to
talk about this and see what happens is
that insane did you did you know that
you were going to be asked to do that
you thought was just going to sit that
sit back and get great this is not now
this is not one of those things this is
want to ask something here so is I have
a first of all the first volunteer is
always the hardest so maybe I should
just pick somebody is there an actual
volunteer Josie so why don't you come up
here introduce yourself and then have at
it so this is yours yep
I like the concepts of the group leader
in Erlang I think the first time when I
set up two nodes and I was able to get
the other node to do something and I saw
that all the i/o came back to the
original know that start the request and
when someone explained to me all the way
it works because each process has the
concept of group leader and when you do
any kind of i/o the i/o message goes to
the group leader which in this case can
route between machines that was like
really mind-blowing and it's still up to
this day one of my favorite things about
our link and designs in OTP ok repeat
that group leader hang on let me get
this here ok sometime i am not i'm
actually not kidding i didn't listen to
that any of that stuff ok so Greipel
group leader is what is this this is a i
don't care what that is will fill this
in later so this is the the scope is the
general category ok just what you just
said in like a sentence that I can type
ok so so mean I'm sorry yeah so I guess
the group leader encapsulates the the
i/o interactions in the system so are
there is I've never used it before so
what felt good so so you said this is
amazing what was that well tell me about
that tell me how you felt there how is
that what was it so to me it was you
know when I when I use it and look at it
I was just like this is a brilliant
design decision and it's very simple
implemented the idea that every process
has a group leader assigned to it and
all the i/o goes through this group
leader which allows a process to do I
owe like regularly but the runtime knows
how to route this aisle to the proper
know to the proper machine to the proper
anywhere ok so it's like I Oh
distribution yeah joe I don't know how
this world ever used you agree with this
I'm here Joe Joe giri's no no there is
no said this is the V this is the beauty
of this that you cannot debate your
emotion and every single positive
emotion is going to have some validity
to it and so it's a really great process
of saying good why is it good see if we
can capture this is a pattern unless
it's a really unless you kind of have a
twisted mind and then good might be
terrible if you're a Java programmer
just kidding you know I'm not really
sure how to describe this so it's sort
of because I don't know the
functionality I've never used it so it
you know so you can you can represent I
oh and distribute it across processes
trivially yeah we can we can tweak that
so you can come you can do a pull
request i'm going to i'm going to
introduce a bug to this and then you fix
it represent io generically and and let
the facility deal with distribution of
it across processes notes and processes
all right great group leader ok it's
progress so I mean I've never used this
thing so maybe I'm gonna start to use it
huh so my favorite pattern is called
middle Joe you've got to introduce
yourself I'm Joe I'm Johnson if anybody
use a middle man to go to middle man is
it's in my book is anybody ready I mean
I'm going to keep happy to sign it so
you might have read it there's this
thing called a middle man it's it's
something that sits between a real
protocol and airline because I the
airline model of the world is everything
is an ailing process that's that's how I
view the world every single thing is an
hour long process and of course things
are the real world aren't telling
processes and they send protocols
messages to be that aren't airline terms
so the first time I thought this was
really powerful is when i wrote a
middleman for HTTP so I you just write a
single process the on one side of it in
comes an HTTP GET request which is all
this stuff in the RFC right and out of
it comes an hour long term which is
which just says get coma
in its an airline term and then the
response just says response 401 it's now
long term when it goes into that and
it's turned into the actual message ok
so the middleman turns everything it
tells everything in the outside world to
airline messages now the advantage of
that is that if you have n things that
you wanted to connect there n squared or
at naught n square this n n times n
minus 1 over 2 different ways of doing
that so if you've got I RC coming in and
you want HTTP going out or you've got
Jason coming in and you want XML out
you've got to write approximately n
squared different programs to get any
possible combination but if you want our
lank to act as a big switch between XML
and JSON and HTTP and IRC and the ftp
and HTTP and whatever you want you've
got to write n middlemen and in this
world in the middle they're all talking
the same language and that's the same as
you know the effect you get when you
have a group of people if we had n
different languages we've got Swedes and
French and German and Spanish and things
to talk to everybody you would either
need n squared combinations or everybody
can decide to talk English or Esperanto
or something it's this common language
that makes things very easy so I'd
really in all my designs I'm always
setting up these middlemen so if it's
not airline to turn it into airline you
do that on input and on output when you
come into you know when you enter the
room and you're talking French you know
once you're in the room you have to talk
English and then when you leave again
you can talk French ok so that's what
the middleman pattern is and it really
makes you feel warm and cozy inside this
is what we want yeah this is good who's
next
good in this quick introduction of your
name hi I'm Rob version 2 beta and I
feel kind of new to Erlang so it not too
much in detail but when I was in high
school as an independent study I got to
read Danny Hollis's PhD dissertation
he's the guy who created the thinking
machine 65,000 processors and once I got
the idea of mailboxes on his processors
it was really really fascinating the way
that each processor communicated with
each other processor and then when I
came to Erlang and understood a little
bit about how the mailboxes work in
Erlang it just connected really well it
was old home and kind of old school
almost for early parallel programming so
I really liked I like that pattern and
make me feel more comfortable with
erling quickly okay so let's so the so
that i'm going to call this mailbox yeah
what about it let's forget letter lang
when you first read that and saw that
what struck you is being awesome that
it's how things work in the real world
okay so maps to your inbox and you can
kind of reason about something landing
processing and taking out of the any
kind of message passed any kind of you
know like just the opportunity to
communicate between two disparate
entities between two people between
whatever so one step down from the
middleman familiar pattern for
processing messages specifically for
communicating between despair identities
turret or arat hang on emacs hmm close
enough I always rely on e maxence always
right nobody's espera entities so oh
that well that's what do you max said so
disparate I don't know that right this
one all right Google now is we'll get
there all right yeah again pull request
mr. Billings pull request okay yeah so I
mean a lot of this stuff for me is I
mean I find a lot of it because again i
don't know i have a bent on programming
as being completely human centric i
really don't care how fast things going
you'll fact I'll tomorrow I'm have a
talk on that I mean it's important for
things to be fast when they need to be
fast whatever that means but really this
is a human endeavor so I'm always
looking for ways to map what I'm doing
in code to the brain human brains very
specific my brain specific years but
generally we think a certain way we
liked in you know we have certain
experiences and like to deal with
certain abstractions when weird things
are pushed on me like some of the
patterns in the patterns book that were
the one I showed the what's the Gang of
Four book some of those are so bizarre I
literally have no idea what they're
talking about and so those are not
related to my experience like they're
not intuitive or not something that
gives me a good feeling that make me
feel stupid and they may be brilliant
that may be something important to use
but i guess i'd have somebody we have to
sit down and show me how and maybe then
i get it but about it so who else any
more more we have time I know you so so
here this is the exercise you got
excited about something recently in
Erlang right it was small you sit down
you did something and you got excited
about it remember what that was take it
just a moment to think I see it happens
erling is one of those languages where
there's a lot all right well a quick
introduction here my name is Alberto I
work for radium Q and recently in
RabbitMQ is full of records with nested
records inside with more Rico
inside and I had to extract data very
deep inside the record so I came up with
the idea of having a list with gather
gathers for each field in the records
that i wanted to get into and then I
pass this list to a fault and i managed
to fold an alarm record which when you
apply this with functions and the fall
and so on gets very near to the M word
of functional programming the in monett
I don't want to go there but for me it
was really cool to have this deep nested
record I have a gather on the top record
that gets to the next one to the next
one to the next one okay I fold over
those gathers cool go deep and extract
what I wanted or shortcut if anything in
between bus on the fine so you'd use
functions than to pull data out and then
apply those to the to the rep to the
laker the accumulator was the first
entry to the fold was the top-level
record and the default accumulator was
whatever they get there was able to pull
for a few so let's say from a delivery
in n QP to a message from the message to
the content from the content to the body
I wanted to get the body out yet so with
the falls plus it's like you're running
a query into your little queries a
little yeah yeah ok it's ok so I'm going
to be honest here that scares me a
little bit but it is what this is an
exercise so let's treat this as an
exercise because I want to see how this
goes i have no idea i'm not pushing back
or anything but when i hear that like
I'm writing like a sort of a how big are
these now are these like really enormous
because it now I'm almost thinking like
the record is like a database almost
then you sort of querying it which for
simple data structure starts to feel a
little weird for me was it why so why
not break us out in a separate why not
why just avoid net the sea I would do I
would avoid nested records and maybe
this will help me to use necessary how
difficulty that's the protocol is ok I
see ok this is very interesting ok it's
not that I accept this I get it now i
get i know we can have a theoretical
sure sure sure sure sure ok this is
almost like like Joe's like you're
almost reading
here's an external system and you're
writing a middleman a little function to
kind of take that beast and normalize it
and it's some sort of accessible so what
do we want to call this thing we can't
use the M word does that all make sense
so what is this called awesome getters
yeah I don't know what to call this
what's the name we have to give it a
name deepa Gators nested get nested
record Gator no one's going to want to
use that man difficult nest nested
record Gator ok let's we'll do a pull
request later nested yeah nesta director
together oh man that's fine no no no
it's good this is good nested record get
her it's fine nested okay so let me let
me pop the stack a little bit here why
you know why would we do this i'm just
going to reiterate i think so some of
these some of these are going to have
residents and some of these will get
adopted and others won't that's fine i
mean but i think the ones that are
adopted if we articulate them well well
we get used more people will know okay
that's the this pattern in Erlang and
what what the theory is the bet here is
that because we're doing this from a
very honest place nobody is trying to
sell a book here no one's trying to like
go do seminars and training and make you
know an organization feel inadequate
because they don't have all this pattern
knowledge you know it's a grassroots
groundswell of this works well we like
this stuff so let's just use more of it
and to do that we just need to codify it
a little bit so you know yeah I've seen
nasty nested records before so I'd like
to use this so scope I'm not sure where
it is we'll fill us in later ok deal
with nasty ol full request nested using
what folds
all right okay we have time we can't be
keep going here it's good just think of
the excitement and then go from there
it's easy yes yes anti-patterns are that
our feature enhancement of the website
so yeah let's talk about that what not
to do yeah oh you don't know any okay I
was really excited but ok so let's throw
anti-patterns there in the mix but you
have to come up here to talk about it
it's not that bad it's fine if nothing
else just say what you liked you know
will slap a name on there and and and
then you know work with it this is
there's there's no rules to the game
here yeah are you leaving no
alright well let's talk about some some
of the things that we have here that
might not be obvious because that I
think will be let's see I think I have
some examples you know so Chandler these
are some basic things so I mean one of
the things so the supervisor how many
people here are brand new to Erlang and
have never really written any airline
code okay how many people have on the
other side have code running in
production right now written in Erlang
ok and then how many folks are kind of
in the middle who you know I mean that's
that's a high bar I guess running in
production is kind of lofty sounding
running apps so and then and then in
between you've used it you've written
some non-trivial programs but you're not
really doing it at your day job okay so
most most folks are you seem to be using
this in a regular basis part of the
problems in it last year you know I gave
a talk on on on adopting our like some
of the challenges in that and I believe
it only has so many amazing features
that go sort of untalkative out because
it's a lot of energy on teaching the
fundamentals of the language OTP some
some some patterns etc and I think some
of the some of the magic of this gets
escape we're used to supervisors but
again that experience that I had of
putting something out there that had
bugs in it i'm actually of the opinion
that i know the sounds sounds flippin
cavalier but i actually like to put bugs
into production i know that sounds
terrible but here's why you're never
going to get away from bugs and being
sort of like I don't really care so much
i'm not you know if we test everything
yeah you're never going to catch
everything so at some point you're going
to need to deal with bugs and production
the reason that i can i can sit back and
say that with all confidence that it's
really not going to tank the system is
process isolation and four and then the
Supervisory pattern that sits on top of
that so that message could go out to the
world and you could say well we can
implement that in other languages you
actually can't until you actually have
proper popper isolation so process
isolation is another thing here that we
can talk about what
it's not just as this is not just a
matter of internal use it's also a
matter of talking communicating and
getting folks to you know who what's
wrong with working with more people who
like and use this language we're
discovering more companies out there who
are using this language to solve
difficult problems I think we need a lot
more of those so having a language that
we can use that we collaborate on that
we say okay here's the essence of this
we're gonna make an argument about this
let's make it really really good and
sound and leverage all of the wisdom of
our community that's useful in sharing
this thing so people come to this thing
perhaps and say wow this is you know
some of these patterns are really make
this language compelling more I know
they're out there somebody so sir
anti-pattern putting stuff in a database
when you're suspending and then pulling
it out of a database later is not
concurrency so so so setting up putting
things in it well did was I can I ask
people you know especially the beginners
to ask really stupid questions on the
airline mailing list because it gives
some of us the opportunity to give
extremely long answers to why you're
thinking the way you are thinking and
then and then that's all indexed in
Google and then you'll be able to read
it later so there was a a guy and he
wrote this wonderful mail and he said
for every new programming language he
implemented a game and that was his
proof of concept to see if the
programming language worked and he said
well I've found my database using MySQL
and i found the interface between
erlangen maya school and I got my state
game you know and the event comes in and
I fetch my stuff from the database and I
do my game logic and I store it back in
the database and I've got my game
running so elings okay and I've I've put
it on the github things then would
people post comments on would they give
me a critique of how I'd written it the
first male camera you don't need a
database and then it came back but in
every other language I'd done it that
way and see I done it that way and C++
I'd done it that way in Java I'd done
that way and go either because there
wasn't concurrency so it took a long
time to explain that you don't need a
database the state is in the process so
that's the anti-pattern putting stuff in
a database to cause a suspension and
then taking it out of the database later
is not concurrency the people think it
is so the suspension here is a matter
you just talking about managing state in
general long low so what if it needs to
persist across the life of your Erlang
vm whether it has to persist yeah yeah
okay so using a database for a femoral
state yeah okay
well imagine the temptation of that is
going to be four languages that don't
you can't just go ahead and create a
thousand processes easily to manage
state your you've been influenced by
Erlang I think here okay so yeah yeah
thank you DB see persistent oh this is
good this is definitely good okay
persistent ephemeral state is a bad idea
scope anti-pattern okay someone else we
have five minutes and i'm not going away
until there's another one you aren't
either somebody's got to come up
anti-pattern description use a process
yes everyone owes you are yeah yeah i'm
david i have been to university for two
years and i have a1 coursing airline and
that's all I know about it so yeah I
find one thing that I'm doing repeatedly
is to just create more and more modules
in one folder and then I asked to have a
lot of modules and I have I'm wondering
if anyone knows how to organize like
airline code in a good way in like a
folder hierarchy or something ok this is
this is a challenge this is good all
right so we I think we have time I think
we might have time for that so let me
let me see if I can map that over here
you are feeling bad about having too
many modules ok so there's you have a
folder and you've got a lot of files in
there and you're starting to think this
is getting too big ok ok and you're
wondering is a way to not have is there
how do you manage that that ok so I'm
not going to answer that who's going to
answer that no Joe ok Joe yeah cuz I I'm
afraid what I said is completely right
put all it I mean it
if you've got directories you have to
the decision problem which bloody
directory should I put it in and if
you've got tens of thousands of
directories on your machine it makes the
problem worse I try and put all my files
in one directory it's much easier so
you're doing exactly right but he feels
bad about that and then you should
probably put all your functions in one
module and then he won't have to decide
which module to put it in well Joe keep
in mind that Joe did propose a global a
global registry of functions yes so
there'd be actually no modules you would
write it you have a little sympathy code
and then it would all be it like there
be a github repo of functions and then
you'd run on I like this idea yeah well
I mean I mean so this okay so I'm gonna
close with this observation is that I
think when it does come to to you know
there are it's like you know you and
well a building some people have a
preference for one type of thing versus
another so there are definitely
differences of opinion here there is no
one pattern language that's one thing
that Alexander's clear about it is very
very personal but there is there's still
the ability to collaborate on on color a
collaborate and then converge on some
patterns that we generally agree on the
Erlang community generally agrees that
that that nested is bad flat as better
flat is better than nest so python is
kind of in that camp as well so that's
actually one of ten Peters is tenants
and what's the you know the Zen of the
Zen of Python so there's that out there
I think if you're in in sort of the the
mindset of needing to hierarchically
categorize things the flatness is going
to be uncomfortable now I mean the exact
opposite path I've I feel uncomfortable
when there's hierarchy so how do you
resolve that well I don't know erlang is
that you know that's the way or laying
works so i would suggest in that
particular case give it a try the
problem is Joe observe here is you get
to trade off so it may be more difficult
to reason about a flat flat list but if
you if you get into a well so he's
disagreeing that's okay though if you
get into a hierarchy I mean if you have
you have you ever if you work with job I
have you ever navigated a class
hierarchy before have you looked calm
dot company dot blah blah blah blah blah
blah blah blah blah you go look into a
source tree i mended to see that the
other day there
like two classes it was a very very
small program and I had to navigate this
I think personally and I'm about being a
little bit rude here perhaps absolutely
stupid hierarchy of folders just to get
to these files so that felt terrible for
me I just became you know anyway enough
of that but I mean that's kind of
highlights I think that this is it's
still human we can still disagree we
don't have to get bent out of shape I
would suggest that you know in the
codification of patterns let's come up
with some really you know let's now
focus this on the merit of something and
they're ours going to be controversy
this gonna be trade-offs going to be
personality differences let's set those
aside because there's more than enough
stuff in the Middle where we can agree
on but let's get that work done first
and then they'll let some of these side
issues you know pop up as they as they
need to okay with that I'm going to wrap
up unless there is somebody really
wishes they had that one last
opportunity here yeah yeah so it's a
matter of like what is a module what's
the scope of a module how do you decide
when to start moving it I mean you know
I would just give you a quick answer for
my point of view your module should be a
concern it should be very specific i
think is area for debate but just using
it as a container for code is not a good
reason saying there are too many
functions in here so let's split it up
probably not a good reason it should be
based on functionality and there are
different types of modules that you tend
to see in Erlang so if it doesn't fit in
one of those categories and I think
actually we're starting to codify these
so like a util module there's a BBB hey
or behavioral module and behavior that's
very specific a data structure module
the module dedicated to managing a
particular type of data so your modules
tend to fall out in these categories and
if they don't if it's like catch-all I
don't know what to call this thing then
you know maybe you've got an issue there
but otherwise it should be for what that
module is designed to do and there
should be you know it generally maps to
a fairly concrete type of module and
then you can reason about what belongs
in there what doesn't
oh yeah okay so the other question and
we'll wrap up with that let's say you
have a module that you know is
independent of an application so it's
not specific to that application should
it be broken out into what a separate
module or separate separate app separate
application yeah so yeah do you create a
library as you start to see things I
would say do it only on demand if an
application you know needs that just put
it in there if you have a pain point at
some point and say wow it really be nice
to get to take that out then do that but
don't do it academically let an actual
other app drive the extraction of that
otherwise you just go crazy you know
forecasting the future and I personally
think that's a bad idea now somebody
else might be like well you should
absolutely always you know never ever
reuse the same line of code twice and it
always be I don't believe that copy
liberally you know hackett get it to
work and then make your change based on
an actual pain point not speculative ok
so that was some religion there I didn't
mean to get into that sorry about that
all right well thank you very much for
joining us</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>