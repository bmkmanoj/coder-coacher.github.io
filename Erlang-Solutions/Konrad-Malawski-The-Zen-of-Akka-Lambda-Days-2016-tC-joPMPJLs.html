<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Konrad Malawski - The Zen of Akka (Lambda Days 2016) | Coder Coacher - Coaching Coders</title><meta content="Konrad Malawski - The Zen of Akka (Lambda Days 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Konrad Malawski - The Zen of Akka (Lambda Days 2016)</b></h2><h5 class="post__date">2016-03-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tC-joPMPJLs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome to the a
no son talk version of occur
historically prepared
for a Japanese conference and I figured
it's gonna be fun
if I leave Japanese subtitles so you can
learn a bit Japanese as well but enough
about that so I work at typesafe which
is actually in the middle of having a
rename a rebrand so on Monday there's
gonna be an announcement so we're gonna
have a new name you can make lots of
jokes about the new name but so I work
on the akka team there and I also did a
bunch of stuff about the reactive
streams initiative so if you hear
anything about reactive streams or we
want to talk about it I'm here and
available so a bunch of stuff that I
also either host or organize I'm also
program committee at JavaOne
in San Francisco and in Cracow most
notably the geek on conference and some
community things okay so that's enough
about me that's some customers some
example projects using akka and yeah so
I just want a quick show of hands who is
using occur or eating okay so you're in
the right talk I think because the talk
is structured as I top where 14 or so
tips of what I see people doing wrong
and maybe this talk will help you not to
do the wrong things so the talk again is
titled slightly after the tower of
programming so there's another one
called version of programming if you've
seen the books it's like a short story
about the Zen master trying to teach his
student about programming so it's kind
of hilarious mutable quote would be
without the wind for grass does not move
without software hardware is useless so
quotes like that so I thought let's try
to do it in the same vibe so what is the
arc or landscape for those of you who
have no idea what a car is etc occur is
a toolkit so if it's one important thing
and I have
never thought about it later but it's
not a framework sometimes people say
 off rainwork I tend to disagree
because you really can't just pick small
pieces of waka and when you just pick
this one small piece it's more like a
toolbox and you pick for one specific
tool you pick the hammer or your Pig the
screwdriver and our terms this means you
pick for example architecture so with a
concurrency and distribution module or
i/o which is for talking TCP UDP those
kinds of things and then the other
modules are layered on top of it so of
course the cluster is basically
distributed actors and then the other
modules like persistence and typed so
first rule is that one actor is no actor
so if you're trying to implement
something in idiomatic actor style and
you have one actor it's kind of missing
the point because one actor by its
surface seemingly single-threaded right
it's not just a single thread it's
jumping across threads but mentally
speaking it's as if someone would be
processing something one fret so what
can it do with a message so it can reply
to a message it can drop the message so
we ignore it or it can schedule another
message to itself if the other behaviors
actors can expose our change its
behavior right and spawn child actors
and that's the complete API and model of
what an actress so when you have one
actor you're not really using the
parallelism of a concurrency that actors
give you so usually you have more actors
so for example you have yellow
specialist Bob and if you have yellow
messages you can ask for yellow
specialists to do the yellow fangs and
already here were starts to be some
interesting interaction because the
yellow specialist and your actor can run
in parallel right so you start getting
some parallelism out of your system
but then you can have a worker pool at
such cetera and suddenly some patterns
don't start to emerge from
from you know the design and
interactions of actors so once you have
more than one actor you know you can do
interesting stuff with actors for
example instead of replying all the way
like from this guy to this guy to this
guy to the original sender you can use a
pattern called direct reply right
this isn't really nothing groundbreaking
but once you think about it explicitly
but hey I could send some save some
message sense if I only were to reply
directly well it's gonna be a better
system okay so actors are meant to work
together and when you model a system
using actors you basically can think
about human interactions so if I should
be replying to someone I should be first
introduced to that person right so in
both terms it means I should get a
reference to it actor right I should not
be using active selection so actor
selection is something that just by the
path and the name of actor we can find a
reference to it but this is more or less
like knowing someone's address and
breaking into their house right you
shouldn't be doing that most of the time
you should get introduced to the person
and then use for reference to
communicate with it so avoid active
selection that's your first step
okay so structuring actors so when you
first try to design something using
actors it sometimes looks like this it's
a huge mess of multi-coloured by color
I mean classes here right types and they
kind of communicate all together with
each other and it's a bit of a mess so
instead what you should be doing when
designing anything with actors really is
to have a hierarchy and by higher here
here mean for example the arrow here
indicating that it's a parent-child
relationship so this could be just
simply that if a blue guys have some
worker pools and they don't really do
the work themselves
they just delegated to the green guys
and if it's some heavy computation
there's going to be maybe another one at
the bottom handling we have
computation so encode this is simply a
difference of instead of system X or off
so system X roof does this nice so
everybody is on the top level but when
you use context X roof it introduces a
child's relationship so prefer always to
do context texture off to have a nice
hierarchy and of course fun new patterns
emerge so it could be a pool that is
dynamically scaling but concept is the
same but it's structured ok so once you
have more actors you probably should
name them and if you don't name them
this is how it looks so if you just say
context X roof some props this is
default names that are generated so
dollar a dollar B etc and algorithm we
use for that one is basically just
base64 of a sequence number of a
sequence number of a number of child's
children of a given process right so you
see a is 1 B is 2 etc so what do we use
that for one thing it's really fast to
generate names like that right and by
default the default name can't really
have information about the domain right
because we are just the tool and we have
some names but we're not useful to you
as someone designing a system so here's
what you should be doing instead so each
actor can have a name and it should have
a proper name right so it's very easy in
the API you just say instead of just
props you also pass in a name afterwards
and here's one pattern that sometimes is
useful so you can basically have a
incremental range of names right so if
it's some kind of fetch worker verse for
first one verse for second one and at
least van when looking at logs or trying
to analyze for system need some
printouts then you see ok it's the same
type of actor it's some fetch worker
right
so um we actually have a utility for
that but we're trying to not expose it
to anyone for reasons well you can write
it yourself it's free lines and the rest
is just sugar but the other reason is
because we don't really want to
encourage fat pattern because it's not
that useful it's already better than no
names right it's better than an
anonymous actors but what you really
should be doing is try to name them in a
way that makes sense in your domain
right so for example if if my actor is
responsible of fetching videos from
YouTube or Vimeo then it could be
encoded in the name and only for the
reason of debugging and understanding
versus it doesn't really change
semantics in any way right it's just a
name but it really helps in a reader
system when things blow up and when you
can see in verlox even when you forgot
to make a proper log statement about it
then at least you know over go fetching
this video blew up or was something like
word so this is why we don't really
encourage just numbers in the names you
really should be thinking about what can
be a good name okay
another place where this is actually
visible is in supervision so supervision
is fourth mechanism if a child actor
blows up so it throws an exception for
example of a parent so the supervisor
gets this message it says what exception
it was and when you can for example log
or do some side effecting fingies and
here the sender of that error is that
extra bit failed right so you can have
the name again and have a nice error
message if you want to okay small derail
here so there's two ways you can do
interpolation in in log statements so
first for bad way which is verse caller
way service caller way is to use the
string interpolator and when you can
just say dollar and a variable name
right so it's pretty cool and nice but
it always will generate a string right
and it will always cut concatenate a
string etc however if you use this
pattern of having the placeholders then
it won't even billed for string if
you're you know if you don't have debug
enabled and we like everybody knows
about it on the JVM but this is better
but sometimes people when they start
writing Scala code they notice over the
string interpreter and we want to use it
everywhere well you don't really want to
use it everywhere just in the places
where it makes sense not I'm knocking
okay the fourth point is the matrix of
mutability you may have seen that one if
you've seen any of Jamie Aaron Stokes
with a colleague from typesafe and he
has this nice way of explaining which
references and which datatypes you
should be using and which not I thought
that it's important enough to give it a
nice visualization so if you have a
value right and it's immutable that's
basically the best thing that can happen
because nothing can really change but
it's also not very useful because you
can't mutate it at all right so it's a
fact it can be for example something
that never changes a fact so when we
other way is to have a variable with a
immutable data structure and that's
actually why you want to be most of the
time because even if you leak or leak
sends that object to someone else
someone cannot mutate it right because
it's a immutable data structure and if
you want to change values inside the
list for example you just get a new list
that is again safe to propagate to other
fret so that's fine it really shouldn't
be doing the other way around
so have a value with a with a mutable
data structure for reasons I just
explained but just the opposite because
if you accidentally leak that in a
message to someone else then what
someone else could start mutating the
list and you really probably don't want
that right you want to give out
immutable views of your data structure
and when was the last one which please
don't use it anywhere so it's both
immutable collection in a mutable
reference so it doesn't make any sense
because which way you wanna mutate it do
you want to swap the data structure each
time you update it like a variable kind
of indicates but at the same time it's
mutable so someone could be poking in it
so please don't use muta birds with very
very encode it's very simple to find it
so it's a far and versum youtube or
something so if you see this anywhere in
the codebase just decide if you want to
be on this side or if you want to be on
this side right easy enough and you'll
be surprised how many code bases I see
with this mix so it's a real problem
sadly okay
so next topic is blocking so many of you
you raise your hand for you were using
okay when you probably know the slogan
or motto of never block right we kind of
tell it to everyone
and we kind of mean it but not in the
sense that you may think we do so this
is a slide from last year's talk about
the need for async and this is the last
first and last reused slide from another
talk but I wanted to use it to highlight
what blocking really is blocking is if
you're basically wasting everyone's time
because you did a core and you're
waiting for it to return instead you
could be just doing something here
during that great time line but you're
not so if it's blocking so blocking is
bad because instead of doing something
useful you do nothing so let's not do it
so sometimes people write code like this
because we want to benchmark our code
for example we want to benchmark our
HTTP in this case so we write I sleep in
a future in a HTTP route in this example
and when the question is blocking in a
future blocks for server
well yes blocking blocks but it's not
really a bad question because the guy
just wanted to benchmark something that
yeah I'm doing something in my code so
just simulate it by putting a sweep
inside fur so it's not really a very bad
question it's just some a bad way to
simulate trying to do any work so the
problem here is that in a code like that
and with default system dispatch used by
the future here this is how the threads
look like so this bluish film turquoise
I think is Fred sleeping and the orange
thing orange state is four frets just
waiting and doing nothing and if you
didn't notice this is where the
application is actually doing something
right here so great benchmark it's
mostly sleeping and then doing something
in one second or so so I can of course
thirty of a guy world you're blocking
you're stupid but that's not very
helpful so let's try to see what I have
four helpful answer is in this case so
whenever we say I never block we
actually don't mean that
we only mean try not to block and really
if you have to then do this instead
right so don't just arbitrarily randomly
block everywhere just isolated so in the
docs we have a section about blocking
needs go from management if you need
more details about it go to the docks
but this is what we mean so instead of
blocking arbitrarily on the default
dispatcher which everybody uses you can
have a dispatcher that is backed by a
thread pool and backed by a thread pool
of sixteen frets so this means we
pre-allocate sixteen France and they
will be used for the blocking operations
so the only difference you need to do to
the code base to start using that
dispatch roof of a blocking operations
instead of a default one is instead of
saying system dispatcher you say system
dispatchers look
and by name right so this takes work it
from the configuration and then via the
implicit value it's gets used by the
future here and this is how the frets
behave then so you see here we have an
i/o dispatcher here but that's unrelated
to the ones we configured right that's
one always spinning and reading from the
TCP socket right we just see it here
because of a screen shot and here we see
the default dispatcher and it's doing a
little bit of work sometimes the little
bit of work in this code example is
actually the routing infrastructure so
request comes in and we need to decide
ok which part of part of route it should
be dispatched to so we're still on the
default dispatch and here we have am i
blocking this patrol and you see all the
sleeping is happening on this one not on
the default one so you're not killing
the entire system you're just killing
the wherever blocking dispatcher which
is fine
so whenever block mantra sounds cool
because it's a never block but it's not
very helpful actually helpful mantra is
blocking each go from management right
so whenever you have any kind of
blocking or i/o operations trying to
write to a file inside an actor always
apply this pattern otherwise you're
going to suffer from performance
problems ok
here's a similar one about a waiting
right so a wait is actually a bit
smarter than just blocking it uses
something but cold
that's called managed blocking so manage
blocking is something in Scala when you
use the blocking word it actually uses a
again dedicated this petrol to do
whatever blocking but it's still bad if
you can do something better just do
something better and not the blocking
thing so and this sometimes appears when
people for the first time try to write
something with futures in Scala and then
they think okay yeah I get this value
back I get the things back so I need to
wait for the result and when
once I get four result I can do
something with it right usable
sequential step by step code so that's
not very good because well each time
we're blocking and awaiting here right
oh it's too small okay so I'll be
zooming invent yeah so that's bad
because you're awaiting all the time
again right what you can do better of
course not very not very I mean
everybody should know that it's monadic
composition of futures right so this is
just sugar but it basically each time
you see the left arrow that's a flat map
right so just once the future completes
I will be doing this other thing and
this doesn't await it just you know
schedules something to be executed if
the future complete and when you get
this cascade of the futures completing
the thing so verse one difference in
these two Coatesville because here on
the upper one we had this upper limit of
how much we're gonna wait otherwise
where we just failed right and the below
one was no time out at all we just said
well if it completes when it completes
do the thing so in order to get the same
semantics out of that code base is we
kind of need to fail after octave after
the three seconds right to get more or
less for same semantics as we above one
here we had it in two places right
first awaiting three seconds and
valuating three seconds so at the max
you could be waiting almost almost six
in total almost big because just before
the time of triggers but let's do just
for three seconds in total for the
entire pipeline so naka we have a
pattern that basically does wet so it's
called a capital after and it says after
three seconds do this code block and the
code block takes a future and it
basically after three seconds will
return that future in this case it's a
failed one so we simulated a timeout
exception here and when in order to kind
of blind it together with happy path we
future first completed off right and
completed also includes failed so if it
fails first when we got the time out
instead of happy puffs the usual
question I get about futures is why can
we not cancel futures because JVM I'm
sorry okay serialization service' total
if you don't get for hint when yes it's
really slow
specifically Java serialization is
really slow and the problem with the
Java serialization is that we still have
it as a default we will actually remove
that default in a future version
probably akka free but for now it still
is for default so why did we ever decide
that this may have been a good idea so
sadly it's very convenient right it just
works you just give it any object and it
usually most of the time just does the
right thing and she realizes it and does
it very slow and very bloated but it
does it and the other ones for example
cryo or protobuf actually require more
work from the user to do the
serialization it's not you know you say
well now I'm gonna use protobuf and that
solves a problem if we need to do some
coding so that's not a nice default to
force everyone into doing a lot of
coding to write a hello world example so
what was our reasoning to have a
deferred Java civilization now the
problem is people don't change the
default once we go to production and
then we claim you okay so slow well it's
not a covetous slow it's like 90% of
your time is being spent in Java
serialization that is slow so where does
this actually appear so this utilization
impact in the ping pong' case so ping
pong case is when you have two actors
and they send each other the same
message back and forth right so this
doesn't happen when you're in the same
process in the same JVM right we don't
utilize film there because why would we
but once you hit the network so you have
two nodes communicating was going to be
virtualization overhead
so where's my work there's gonna be
bigger Layton sees so is gonna be
decreased throughput so you want to have
first serialization as fast as possible
once you go you know in a real
deployment that has multiple nodes this
is how it looks with javis utilization
so the table is extending a lot and the
board takes longer to go to the other
end often of the network and like I said
it's slow and footprint heavy so since
I've got about four we actually log a
warning now people at least know that
you're doing something wrong you don't
notice that there is no magical like
just do this instead in the warning
well that's because sometimes you want
to take a little bit more development
overhead for example protobuf and
sometimes you don't
so for example with cryo it's relatively
easy to set it up but it's always a
decision of how much pain am I willing
to get more fruit right so I don't have
the answer for you we would have to talk
well how much pain are you able to
swallow so here's a very naive not very
knife semi naive ping-pong benchmark
with the Java serialization and without
so without the civilization a ping pong
goes back and forth below a microsecond
right with visualization enabled around
25 right so that's pretty painful and
but let's see how we can do actually how
do I put this let's do something that's
already good it's not the best thing we
can do but it's already pretty simple to
set up and I mean the cryo civilization
so crier is pretty good because it comes
well at least for this library so aqua
cryo civilization comes with a bunch of
presets for scholar collections right
because that's what you're going to be
sending around and configuring it as as
simple as well you get for plug in your
register it is an extension and when you
just say which types should be
serialized using
krile serialization instead of a javis
utilization and you could even disable
for Java one so it blows up if someone
tries to use Java civilization and I'd
actually recommend that okay so as
simple as saying serialization bindings
class names and which serializer can I
have a quick poll who knew about
serialize a configuration okay that's
that's exactly why I do this talk not
that many people raised for hands so
we'll see it's really that simple and
what's also a benchmark now well it's
five times slower than those utilization
but not 25 times slower right very good
and if you really want to can go faster
but it will require more coding from you
so why is it actually that slow in this
Java civilization thing so if you have
this case closed called order has a
bunch of fields and if we try to
serialize it using Java serialization
this is what you get out of so whenever
versa - it means a non printable
character so it's just a blob but I
printed out
well James Southerland printed out and
this is how it looks quite a bit and it
also includes all the full class names
of everything and the field names and
everything right very full of
information and this is how it looks in
XML so actually even serializing to XML
would be less bloaty than the binary
Java serialization right think about it
scary Jason would be even smaller boots
well not that smaller and this is how it
looks in trial so as you can see because
it doesn't include the names of the
fields but it does include the names of
types it tries to shorten them a little
bit but you see it's somewhere in the
middle it includes some information
about the object but not all of it from
type wise approach okay so and it's even
worse if you try to use Java C
with any kind of system that needs to
get back to his object in five years
time so any kind of persistent systems
right because that means that you will
try to evolve a schema and evolving a
schema is not very pleasant with Java
civilization you can go around it versus
serial version UID fields but it's not
very pleasant so if you are trying to do
any kind of persistence with binary
formats then please do this side IVA for
protobuf or for EFT something that has
built-in scheme evolution and yeah it's
gonna be a bit more painful than just
click and it works but you kind of pay
up front a little bit of pain and when
you have zero pain once you evolve a
schema with Java you would have first
zero pain and then a word of pain right
so it's a trade-off when you pay the
price and the usual trust no one
slide because I showed a benchmark never
believed in anyone's benchmark right you
should always benchmark yourself and
verify that I'm not completely lying to
you if you're benchmarking anything in
scarlove and please do use for SBT jmh
plugin and jmh s vis benchmarking tool
from the Oracle guys that were used
benchmark collections etc so it's a very
good benchmarking - and when profilers
and if you want to go really hard Cove
and go with perf and look at the actual
assembly that's being printed
but again trade-off of how much pain
you're willing to take to get a good
benchmark okay
so different topic about letting it
crash right vets both along and Okimoto
we just say let it crash and it will
recover but verse one fine and detail
about it but sometimes people forget or
they use maybe the words failure and
error intent terribly or us we don't
think it's the same thing actually so an
error is something what's expected and
you know the
happens and I can react to it and when
versa failure which which is basically
well I didn't completely expect that
something is really blowing up in this
system so to make it maybe more
exemplified so let's say you have a
vending machine and inside versus some
hierarchy of actors trying to handle it
your request to get some drink out of a
vending machine and money comes in and
then verse actor is responsible for each
row of kinds or something let's just
imagine it is by God probably isn't but
now an error is if there's some
validation and it sees oh well if it's
not enough cash for the product you
wanted to buy right so that's an error
at least in our terminology and the
error goes back to the end-user right
because they can react to it favor
insert more money and then they'll get
to drink however if okay if the
validation passed we try to get a denial
coke out of the vending machine and
actually this fetcher arm finger blows
up or doesn't react or something
so that's actually a failure and where
is the difference so the difference is
in where we were poetess right so an
error we report it to the end-user we
say well you can't get this kind of coke
because something but the actual like
internal error message failure message
we send it back to whoever supervising
that machine right because they can
actually repair the machine and the end
user count right so it's the difference
of who can do something about the
problem
so about heylia's operators can do
something about it supervisors can do
something about it but not the end user
all right
a little bit fuzzy but I hope for
example is helping we have question
right yeah yeah that's a good example so
everything completely blows up but what
does the user get well usually this at
least there should be in many operations
like that there should be some timeouts
right and a timeout then reports back
with a generic error message to the use
of it I don't know something went wrong
even if you have no idea what went wrong
and you don't want to tell the user that
you know the mechanical arm 50 years
it's broken or something this you want
to know in your supervision hierarchy
and maybe notify you know in in a very
real life case you would maybe shoot a
notification to a monitoring system etc
but it's not the same information you
give back to the user
I hope this addresses yeah yeah exactly
because you do want to tell something to
use this but usually it will be then
something not very useful like well
error sorry maybe just print an error
message if it says oh I'm sorry we will
fix it okay so back of supervision that
plays again into the same topic so you
have supervision and supervision takes
care of for example restarting an actor
or if it fails right but back of
supervision is something we recently
discovered during working on our
capacitance and the case is that you
need to give a little bit more breathing
time to a system before you recover
otherwise you will be basically ddosing
your own system so here's an example so
yeah we want to let things crash but it
doesn't mean let them crash and what
then let them crush even harder right we
want to let them crashing recover right
first of a second part of the idea so
here's the problem case you have some
kind of database does
matter what and you try to possess some
kind of messages to it because it's a
persistent actor so very persistent
actors work is they can store events in
a data store and then once they fail and
recover they go to the data store and
recover first state from the past events
that favor persisted so the current
model we have is if a data store is
unavailable we always stop factor so it
doesn't restart automatically like any
other actor would normally do so here's
why we don't do that
so this is not what happens but this is
what was happening at somewhere at some
version why we were developing this in
to Godfrey so the normal actor behavior
is if it fails it restarts right right
away and here's the problem with that if
the data store is unavailable we fail we
restart we want to replay replay fails
so we fail so we restored we try to hit
for database and it bounces back and
forth all the time so if this is one
actor of this maybe wouldn't be such a
bad thing because we try to recover as
fast as we can but it doesn't happen
with one actor it's in your entire
cluster we're heading for example
Cassandra cluster with his recovery
mechanism and then the entire bigger
cluster is trying to hit the data
storage cluster with all these recovery
messages and maybe the data store is
still not up or trying to get up and
we're basically ddosing it causing the
system to have even more trouble than
not so this is why we do for stopping
independently of you know if we could
just replay because we don't know and
when we have someone called for backup
supervisor so the back of supervisor is
basically someone on the outside of the
supervision hierarchy but kind of doing
the same thing with the difference that
each reset of actor
is basically time' based right so we try
to restart after immediately when we'd
when if it failed we try to restart
after a second if it failed again and we
try to restart after three seconds at
such research we give it more and more
breathing space to get to a recovered
state and then we'll recover and that's
something we've implemented for you and
then just configure it so you just need
to be aware that such a thing exists and
that you may be sometimes being eating
it and it's not only about some database
feeding it could be also maybe you're
hitting some exceeding some SLS and
hitting some external services you could
do the same thing just let it crash and
then let for supervision the back of
supervision kick in so you get back
after a short while okay that's a funny
one so when you start designing using
actors you basically translate every
method what would have been a method to
a message and when you have a very long
list of messages like that so this is
not yet long long would be maybe 10 15
messages depends on your code right but
this basically is the same problem as
JavaScript people have with this
parameter of doom only that we don't
have a pyrometer of doom because
everything is a message so it looks flat
but effectively it's the same problem
right everything is a message everything
comes back to the receive block so when
you think about it and try to model it
more explicitly for example the receive
first is awaiting for instructions okay
so what is a waiting for instructions
its termination handling or one or two
cases doing something right and then
once you get some kind of message you
transition to another part of a protocol
which is making things okay what is
making things and you see you start
modeling it as a finite state machine
and it reads much nicer and maybe you
can even test
independently etc so basically you're
gonna get some kind of finite state
machine if you really want to worse adsl
fat hopes writing finite state machines
so here you say in what state and what
should be happening and it can include
data so here the second thing is actual
data so you don't need to resource the
mutable value variables in vector you
can just pass it along in the second
parameter if you won't do okay
so let's fill our topic and cluster
convergence
so before I start who has been using the
cluster who knows what convergences yeah
I don't mean to say that's bad that you
don't know but it's probably not as well
exposed in the documentation as it
should be so people don't realize what
it is so in order to have any kind of
leadership not leadership a membership
change we have to have convergence in
the cluster and convergence basically
means that everybody agrees but we see
the same state of a cluster so here's
how it looks in a state diagram but
here's how it looks on a party so you
have some seed nodes so seed notes over
notes to which you go to the party to
join the cluster right you know vero
dresses and the guy with a funny hat
that's the current leader right so
leadership it's not a very special node
it's just that yeah we have some leader
and if it goes down the leader becomes
the second oldest in the cluster so we
have a node called cut it tries to join
then even nodes and now if you see the K
here so everybody gets the notification
but Kurt wants to join and once
everybody knows about this node we move
it to up right so the idea is that
everybody knows about something and when
we make a decision on it okay
so now he's part of a cluster service
vet was convergence basic
but now if you have a situation where
Curtiss unreachable so we can't
communicate with footnote and someone
else tries to join we don't have
convergence because convergence means
everybody knows where we can't tell with
unreachable note so not everybody knows
and we can't make this up decision so
verse improvement in the cluster what
you can enable and visalo weekly up
members and that allows actually new
notes to join even if someone
unreachable right so if you have
situations like valve during a cluster
partition because that's a cluster
petition basically you need to add new
notes you do want to enable weekly up
members and that's when both allows for
member to join as a weekly up member and
once the unreachable note comes back it
will be the new one will be moved to a
proper upstate so we still follow the
same protocol it's just we allow notes
join earlier okay and here's the
opposite of leaving a cluster so you
have a party that's Bill having a
birthday party and he says I'm gonna go
home basically calling cluster leave
self right but and then you kill the
Trivium right away
next line system exit now the problem is
because quitting is also a a synchronous
operation if you code for JVM before
anybody heard the message then no one
heard you saying goodbye and they'll
start worrying like world spirit and
failure detection triggers etc were you
meant it as a proper nice leaf but it
wasn't a nice leaf because no one heard
you leaving so when failure detection
triggers and they move for notes to
unreachable right so and from
unreachable someone can decide to call
it down and worse ways to configure how
downing works but basically once a node
is down and it comes back we will refuse
talking to it so you're ready that I
will not talk to you even if it's
from your perspective as an operator
you're looking at this cluster the note
came back and should be fine but it
isn't because the cluster already
decided which I noticed that dead and it
could have some inconsistent state right
and we don't allow members to come back
one if you actually don't care about
consistency in that sense maybe you
shouldn't be using stuff that requires a
single right the principle so what cap
assistance requires a single writer
principle but for example I could
distributed data doesn't so verse ways
around that if you don't care about
consistency in in that sense but it
changes your veil ability model okay
we're running out of time so occur the
toolkit I talked about it you can pick
and choose small things from it and also
you should be using the least powerful
abstraction that does the job for you
right sometimes the future is enough and
but not always right because futures
don't do distribution so we have less
power but very easier to work with right
and if you go with actors you get a lot
of power with the distribution with your
failure recovery etc but they are a bit
harder to work with
right so it's this opposite and here you
have power here you have constraints and
they're always pointing in opposing
directions so think about what you're
trying to use a nice middle ground is
actually akka streams so if you haven't
seen our stream see it give it a look
because it's a statically typed way to
kind of explain a processing pipeline
but it's static right actors can be very
dynamic in their lifetime and streams
are very static in how the data flows
through a system so again is a trade-off
okay okay happy hacking this is where
you can reach out to us for random
chatter or just feedback and of course
we do take contributions and if you want
to help out the best way to get started
is to look for other community
trip of a small ticket and just ping the
ticket for hey I want to work on it and
I'm happy to help out you contributing
us and verse also chatrooms
so the acha acha is for actually using
akka if you're writing an app and want
to know something how to do something
with akka and the akka / def you in
church room is for actually developing
our code if you are trying to contribute
a feature or something like that okay
here's some better
well commercial offering if you want to
have a look this is what keeps us alive
basically and that's my last slide which
is again from the same of programming so
thank you very much we have time for two
or three questions we have one here is
it possible all will be possible to use
distributed our costumes yes so with
Akkad streams we have two layers and one
is Vidya Solon the DSL is actually
lifted representation it's basically
like ASD and when we have a second step
which is actually materializing the
thing so making it run and the echo
streams implementation on akka is not
really targeting of a distributed case
what we are targeting is basically doing
a high performance back pressure to HTTP
server so that's our use case but
because it's lifted and basically the
guys at Intel who we are working with
our focused on the distributed mirror
we're alike processing framework clean
so what they do is we take our DSL and
they basically just change one line
which is for use for a gear pump
materializer instead of archive streams
materializer and then it is basically
distributed stream processing so with
the same de-esser just a swapped engine
you get what you want
so if you want to google that upwards
until gear pump one more question so
would it be possible to integrate back
pressure supervision with existing
supervision structure you know because
for example right now if we have back of
supervisor there is and there are some
problems when it comes to keeping up and
actor mailbox and things like that and
and they plan some kind of you know
composing this feature there isn't one
back pressure with feedback of
supervisor because back pressure is
different sorry I don't back fashion
backup supervisor but standard actor
supervision and back of version mmm no
it has to be separate because the way
supervision works is always immediate
but really built into the model so if
you need the back of supervisor the way
you structure things is different it was
going on the outside doing the timers
and everything so we won't be really
able to change existing supervision to
do backup supervision but the good thing
is you can just edit transparently it
doesn't impact the outside structure of
your actors so that's what makes good
and bad I think okay okay let's thank
our speaker was again thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>