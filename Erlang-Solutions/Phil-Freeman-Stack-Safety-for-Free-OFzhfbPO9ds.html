<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Phil Freeman - Stack Safety for Free | Coder Coacher - Coaching Coders</title><meta content="Phil Freeman - Stack Safety for Free - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Phil Freeman - Stack Safety for Free</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/OFzhfbPO9ds" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right yeah thanks very much to the
organizers for asking me to speak so
yeah I'm Phil I work on the PR script
compiler in my spare time now work on
Haskell for a living so you know if any
of those two things are interesting to
you come consulted me about them if you
want to see the slides for this talk you
can go to github it has the code I'm
gonna show and it has you know all the
markdown for the slides and stuff so
that's my username code mesh 2016 and I
have the same user name on Twitter and
github and you can meet me on pure
script IRC most of the same as well okay
so let's talk a little bit about the
problem we want to solve and the problem
I want to solve is a specific version of
try and support some interesting
techniques from Haskell to peer scripts
and gain over the problems that you
encounter along the way okay so consider
this this Haskell function okay so
common function it's in the base library
it's called replicate em cuz it's
working there we go okay so it's called
replicate amp and it works for any monad
so I'm gonna see him a little bit of
Haskell knowledge in this talk but
hopefully that's okay so it works for
any mana dam and it takes two function
arguments okay it takes an integer which
is the number of times I want to repeat
an action so in action might be well it
can be in any monad okay so it could be
I just want to log something to the
console or it could be generate a random
number or it could be something in like
the maybe monad for example right I want
to replicate that end times discarding
the results so that'll give me an N
returning unit okay so a result with
essentially where we discarding the
we're only considering the effects and
we're just guarding the result type okay
so it's just defined recursively if we
say if the number of times we want to
replicate the action is zero then we
don't care what the where the action is
just return you know return nothing
essentially but if it's anything other
than zero so not negative though then
just perform the action what
so X is the action here performing
action ones and then so this is the bind
operator from Hospital replicate n minus
one times okay so this is totally fine
in haskell so this is totally fine in
haskell and we can test it using GHC or
JC i okay so we can say replicate ten
ten million hundred million something
like that number of times this just
action so you know maybe as a monad and
just as an action that you know it's
essentially the reaction that does
nothing in the maybe monad so we can
replicate that a bunch of times and
print the result
and we can run that to compile that with
optimizations and run it on the command
line with this runtime option HS and see
what the runtime does right so it says
okay well this is the answer which is
what we expected the only only allocated
this small amount of memory on the heap
right this is actually a pretty short of
the minimum required by the runtime so
set various things up but didn't
allocate anything else even though we
sort of looked even though we were doing
whatever 100 million actions right this
basically could just got compiled into a
very tight loop if you if you actually
dump the core from JC you can see that
it basically just compiled it right into
a while loop okay so this is really good
and you can see various stats right so
the mutator thread took up 98% of the
time that was spent by the runtime and
there was no garbage collection because
they didn't need to garbage collect
because it's just a loop okay nothing
was allocated okay so if you like me and
you work in Haskell but for one reason
or another you want to work in a strict
language on some target like JavaScript
like you would in pure scripts then you
might ask well can I put this you know
can I put this function so pure
scripting is it safe to do so
right so not really going to talk all
that much rapier scripts in this talk
the code will be in pure scripts but if
you're not familiar with the pure
scripts then it's a strict language it's
based on Haskell the compiler is written
in Haskell a lot of the techniques that
we use are inspired by Haskell
techniques and for the purposes of this
talk traditionally it has type classes
and it has higher kind of polymorphism
right so those are the only two things
that you'll need to actually use the
techniques from this talk so you could
use pure script and compiled
javascript so you could compile to one
of the other backends so we have a C++
back-end we have an airline back-end and
a couple of other sub experimental ones
or you could use Scala or address all
strict languages with these features
right I'm not sure if there's any others
but if you have these features then you
can use these techniques Wayne if you're
interested in pure scripts then there's
a page on pure script or got has a list
of resources and all the stuff you need
to learn about it okay so pier script
looks a lot like Haskell right this is
if they look quite hard to figure out
the differences here but this is
basically the the function that we just
had naively pointed to peer scripts okay
so there's not much in the way
differences you have to explicitly
quantify type variables here and then
this operator changes slightly because
it comes from applicative it doesn't
come from monad anymore
I think and unit has a name it's not
built in simple but apart from that you
know it's pretty much exactly the same
but it doesn't behave the same right so
if you run this with you know 100
million or something then you get this
problem immediately pretty much you just
get a stack overflow which you saw what
we don't expect right the the language
is straight if we think about the
evaluation and you should always sort of
think when you write in pure script what
would the corresponding JavaScript look
like so essentially this just
corresponds to a function application
this operator becomes a function
application to the recursive call of
replicate an okay so we're just building
up this this big so func essentially by
by recursion so we run into a stack
overflow okay so we can see that just
give a little demo is it this way okay
there we go this is the font size okay
the back yep cool all right so this is
try PR scripts if you want to I can't
really read that but if you want to test
out local code samples this can be
really easy or it comes with all the
core libraries built in so you can just
have to change stuff here in it you know
recompile on the server and send back
some JavaScript and run it okay so we
can I've got some code samples here
right so here's replicate that's the
good version so let's hide that
so his replicate and it's pretty much
exactly what I just wrote a except for I
used to do notation at the bottom
right so we can do something like say
replicates em ten times replicate with
an e should work okay let me get ten at
the same string okay so that's fine so
it just went to a top stack depth of ten
so we wouldn't expect that to stack
overflow but if we do something like
this okay
then it'll think for a little while
because the way trip' or script works it
basically just treats the console like a
big string in memory so it's okay for a
while all right and then we get to the
bottom and we get that the error that we
expected but there's a way to fix this
so I need to make sure I don't crash my
browser yeah I'm pretty sure this will
fail as well see you are not cheating
okay good
if we take this safe version at the
bottom which I'm going to walk through
in a second now we should start working
okay yes it'll think for a little bit
because it's building this sub big
string representing the console in
memory eventually when it's done
actually hope I tested this with a
hundred thousand oh the feeling am I've
done it with ten thousand but okay cool
right so it gets to the end it takes a
little while and things because it's so
building this massive string but now
this new version is safe right so let's
let's go over why that's safe okay so
you might think if you've I've done
functional programming in strict
languages before well you know it's
obvious right you didn't make your
function tail-recursive so to a certain
extent that's true right so if you're
not familiar with the term tail
recursion means that your function is
recursive but it's only recursive in
places it's only basically it only makes
the recursive calls the last the very
last thing it does in the function body
okay so a tail recursive function can
either at the end of a tail recursive
function you can do one of two things
you can return the value or you can loop
and if you leave then you can modify
some function arguments and this is a
little bit like changing states in a
wild loop or something so the compiler
can recognize these cases and it just
turns the it turns a function like that
into a wild Libre if you look at the
generated code it actually just becomes
a while loop okay so for example we
could take replicate M and modify it so
there uses a loop right so here's here's
my loop and I start with pure units and
I pass along as an accumulator the
number of sort of replications of the
actions I haven't that I still need to
do okay so here's my accumulator and if
it's zero I just returned the
accumulator if it's nonzero then I'll
loop but I changed my function argument
here so that I tack on another instance
of the action okay and I changed my
other argument to be n minus 1 and this
behaves the same ok so this works in
some cases so if you have them honored
like maybe we're you know evaluating a
monadic bind is you know essentially
doesn't have any additional cost you're
not so deferring any cost and this is
fine right so you can you can say this
and you get an answer back very quickly
but it fails for other monitors we have
this morn ID called F which is basically
like our i/o monad
and it's sort of not immediately obvious
white would fail 4f but we do get stack
overflow and the reason is that while we
can sort of build up this sort of big
effect for action
in arm honored with a big while loop the
actual evaluation of the while loop
sorry the actual evaluation of the
action when we're done is still
basically a big stack of actions very is
still essentially a big nested function
call so in this case we actually do
still get a stack overflow so I want to
find my demonstrate a technique that
allows us to do things like this for a
certain class of monads without any of
these issues okay so I said earlier that
tail recursive function has two options
when it when it's about to finish it can
either return the value or it can change
some function arguments and loop okay so
we can just reapply those constraints
right those two options we can just turn
them into a data structure and say that
a step in a tail recursive action so
this is basically either right but we
used to use either and we changed the
names of the constructors because we
could we always forgot which one was
which but you're either done and you
have a return type of B or you can loop
and you have an argument which you might
change of type a okay so those are the
only two options that you have in a tail
recursive function okay and then once we
have that data type we can write a
general purpose tail recursive function
that basically generalizes every tail
recursive function of one argument okay
it's called tail rec we say okay so for
all types a and B is going to be your
input type of your function he's gonna
be the return type I can build you a
function from A to B that's tail
recursive if you can give me a function
that for every state a gives me one of
these two options that says you can
either loop or you can say I'm finished
okay and once you have the version for
one argument it's easy to solve build
versions for multiple arguments so you
can say things like you have two inputs
a and B and you want to return type of C
and you can give me a function from an A
and a B to a step that returns another a
and a B or finishes with a C then I can
give you a function of two arguments
that's tail recursive so we have various
versions of these things and then once
you have that you know it's a little bit
noisier but this is a safe version of
safe version of sorry not quite okay we
can write replicate em like this we can
say is the tail recursive function of
two arguments defined in terms of this
function loop that starts with pure unit
which is this computation that does
nothing and the number of times I want
to replicate and it loops a bunch of
times
decrementing the count and adding on to
the number of action you're modifying
the actions right on one more occurrence
and then finally it's done when we get
to zero it just returns the accumulator
right so this is just another way of
expressing the tail recursion that
builds up that big action but it doesn't
actually fix the problem that the action
itself is going to run into a stack
overflow okay okay so now the next the
the soft trick is that we want to
generalize this tail rect function to
what what we call monadic tail recursion
okay so we take take this tail right
function that we had and we build it
into a type class that's a subclass of
the monotype class actually in scala zi
i think they actually move this into the
monad class i think the cuts the cuts
library implementation certainly does it
that way but essentially we have this
function called tail rec am from an
addict sale rack okay and it's exactly
the same as tail rec except for that
we're building a monadic function rather
closely arrow so it takes an input a and
it returns a being some monad that's one
of these mono tracks in order to build
it you have to give me a function that
for every step takes a state and gives
me back one of these step things that
tells me whether I want to loop or
finish okay but it can it can have a
monadic actions at every step right so I
have some states and I can step one to
perform some monadic actions as my
things on perform some anodic actions
and tell you whether I want to carry on
or finish
this function will stop put all those
things into one big monadic action and
hopefully safely okay so we can ask what
the laws for a class like this should be
right type classes usually come with
laws well a sensible law for this class
is that it should be equivalent was
observational equivalent to this so
default implementation to tell reckoned
that we could just provide
given them honored them on our instance
alright so if you have a mono at
instance that isn't going to blow the
stack let's say then maybe you do this
like this you take the function you just
run run one step and then case on the
result and if you had done you'd finish
with pure and if you weren't done then
you'd make a recursive call okay but the
idea with this class is that hopefully
we can come up with a more efficient
implementation right and for a large
class of monads and mono transform as we
come okay so ideally in fact we do
without using without using any
recursion in the tail wreckin
implemented whatsoever and then we can
we can say that the laws allow was to
solve reason by this by you know saying
well it uses tail recomm so I know that
this won't grow the stack more than F
itself will grow the stack so it's a
nice little way to solve reason about
the stack usage of our functions okay so
I don't expect to understand this at
this pure script code but there's just
sort of one interesting thing about this
so this is the this is the
implementation for except T which is an
error mono transformer from the pure
script core libraries and this instance
says that if the mono that you're
transforming M is a mono track then the
transform owner that also tracks errors
is also a monad wreck okay and it's just
defined in terms of TELRIC M for the
underlying monad so if we start trying
to bootstrap this this concept then we
hope that the the monad inside the
transformer is not using recursion to
implement tell reckon so this one isn't
isn't either right so if you look at
this we use Taylor I can but we don't
actually do any recursion in here
there's no call to tell rec M itself we
just start plumbing through the lesson
rights from the either that's wrapped up
inside the xmt okay so there's basically
amounted to sort of doing tail recursion
with the option of bailing outs at any
point with an error okay we can do this
for a bunch of other molnÃ¡r transformers
for it so we have this sort of rich
class of these
monads for which we can implement tail
recursive functions without growing the
stack and we can build a big mono
transformer stack
and if we know that we have mono dreck
instances for all the pieces of our
stack then we know that overall we're
not going to grow the stack more than
our seed function that performs one
little step at our tail recursion okay
so we can do monadic tail recursion for
the identity because the identity you
know it just wraps up the type the type
argument so essentially tail recommends
tail rec we can do monadic recursion for
the state mana transformer so this
basically amounts to self adding an
additional accumulator parameter if you
like we can even do it for writer so
this is a little bit like if you
familiar with the idea of tail call
modulo cons it solve a little bit like a
generalization of that it's like we're
allowed to relate to detail recursion
but we're also allowed to sort of append
something onto a monoidal accumulates a
value in the return only return value
before we do the loop okay reader it's
not very interesting but it's handy to
have this instance so I already said F
is our arm honored from Pier script
that's a little bit like Haskell's IO
and you can give an instance for this so
this sort of makes sense because you
know you expect that you should be able
to solve interleave native actions from
the JavaScript runtime inside your
inside your tail recursive function and
this last one's kind of interesting so
this is a library in the Pio scripts
ecosystem that essentially implements
like promises or futures or something
like that so it's like an asynchronous
effect Amanat and this is really handy
so I'll get into an application of this
later but yeah essentially you can think
of this as like a monad for solving sort
of callback hell type problems right
like a promise or a future monad okay
okay so now that we have this classroom
have this idea of what tail-recursive
monad is then we can change replicate em
and we can write it in terms of monad
rack okay so now it's just a simple
application tale recap well you know we
just pull all the logic before from
before into this loop function here
right so loop says if you're on 0 is
your accumulator then I'm done it or if
you're on n then perform X ones and then
a loop and change my
state to n minus one okay so this is
this is pretty simple
the trade off we've made is that instead
of doing this for an arbitrary monad now
we have to do it for am on a trek so
only one of those things in the
classroom before but that class is
pretty big right so it's not too much of
a trade off but the big winners know
that for all of those monads and there
we can do replicate em and not worry
about the stack okay so this is stack
safe that said here for any law-abiding
mono Drac instance and you can go
through the same steps with functions
like map mo traverse or fall down and
and so I've build up this library of
simple functions that you can implement
as tail-recursive okay so that's nice
and now we have this sort of simple
library of functions inspired by haskell
that we know i'm going to grow the stack
okay even though they work over an
arbitrary monit so I already covered
this but it's nice to have this sort of
dictionary of mappings from some mono
transformers to sort of an intuition
about what style of recursion we're
doing right so like said state T sort of
corresponds to adding an additional
accumulator like an additional parameter
like a no sorry an additional argument
to our tail recursive function right the
T is this sort of barians on tell-tell
called modulo cons and except he is just
like a tail call but where you can
essentially throw an exception in the
middle of the tip in the middle of the
tail recursion all right so that's
that's the type class and the theory of
the type class out of the way right so
let's see some some places where we can
apply this okay so the first application
is to free monads okay so if you're
familiar with Scala and Scala Z at all
then you might be familiar with the
solution that they have there for making
free more node computation safe and
stack safe okay so this is a slightly
different take on that and as I
understand it I think this sort of
generalizes to more and more monads but
might be possible to get around up by
trampolining so I'm not understand sure
this is the first application okay so
the free monad
is defined in hospital like this okay
it's defined in layers and a layer can
either be a pure value that says I'm
finished this is the this is a return
value I want to return or it's impure
and the Fremont has parametrized over
some some base functor okay it's free
it's defined in terms of this functor
and then an impure computation is a
functor full of more computations to do
next okay and you can so I'm not going
to go into too much detail on this if
you but if you're familiar with Freeman
arts then hopefully this should make
sense and you can define an instance
that says if you have a functor for F
then you can make free app into a monad
okay for any function and you can you
have an action that says if you have a
functor you can also lift a value inside
that functor into a value in the Monod
and then you can use do notation to
plumb these things together right and
it's just defined like this so you can
say I have one impure layer that does
some effects and then and then the next
layer down is pure essentially just
returning the value given by the functor
okay as I said it represents sequences
of instructions and the instructions are
defined by the base functor so what what
sort of functors are we sort of thinking
of here so something like this database
F right which track which we might use
to track things like inserting and
selecting values out of a database okay
so this is a functor and it has it so it
has a type argument right and the type
argument represents what to do next
after the after this first step in the
computation okay so if we do an insert
then we need a key and a value to insert
into the database and then we need a
thing to do next and if we're doing this
alight then we need a key to select and
I only figure out what to do next once
the database returns and gives me the
maybe value that corresponds to that key
it so have a function that says is the
value now tell me what to do next so we
can give a functor instance for that
that's fine
and then just derive the Manar instance
with the instance we had before right
using using free and we can use lift
free to insert and we can use the free
to select by lifting these two actions
from the functor that's fine
and then this is how we this is the
solve general Eric function from running
a computation in a free Mona right so
the implementation isn't particularly
important or the type actually but just
notice that this is monadic
tail-recursive right run free is the
last thing we do before we loop okay so
we might hope that we could actually
write this in terms of mono dreck and
not worry about the stack okay okay so
just a little bit of motivation on three
more nodes briefly so one nice thing is
that you can use them for testing you
can give multiple interpretations you
might have one interpretation that goes
for the database and actually run some
sequel or you might want to use it for
testing right and then I could use I
could interpret interpret my free monad
using run free inside some statement
that basically just tracks a map from
keys to values in a state monitor and
I've got an example here of a function
where we can take one of these database
computations in my free Mon art and turn
it into the state monad just by using
run free okay so we just have to say
what we do on each of the actions when
we want to insert something and we do an
insert on our map modify the state and
state monads and then do the next thing
and if we want to select something then
we do a get on the states and then we do
the next thing okay so see how we're
passing the value that we got back from
get into the continuation here and then
that gives us what to do next so they're
really handy for testing as I just
explained the problem is that run free
users monadic recursion right so in most
cases unless your mana that you're
interpreting again is stack safe for
some other reason you go in to have
problems when using run free with deep
computations or infinite computations
okay so there's this rough risk of
blowing the stack instead we can just
again trade-off the Monad constraint for
him on a direct constraint and now we
can interpret Freeman arts in any manner
that has a law-abiding one
constraint which as we said is quite a
large class of monads okay and then
again we know that if we have a
law-abiding sailrite sorry mono Drac
instance then run free is always going
to use a constant amount of stack and I
don't know if you've used trampolining
sorts of solutions before but personally
I find them sort of quite tricky to
figure out exactly when the trampoline
is going to sort of make things safe
when it's not because you're sort of
worried about where the monadic binds
exactly happening but it's relatively
easy to sort of look at the
implementation of run free in these
terms and just think about it in terms
of tail rockin and figure out that it's
always gonna be safe for any tail reckon
you know that has that's law-abiding
okay so we can go on step further right
so this is something that as I
understand that you previously couldn't
do with the trampoline based solutions
is got from the free mana to the freedom
owner transformer okay so what's a free
monad transformer well it's just like
the free monad so you bathe everything
sort of layer based okay so we have
constructor it wraps up either a pure
layer which returns a value or a functor
full of next steps essentially except
for now we have some base mana that we
want to transform and every layer we can
have some monadic effects from this base
mode okay so this is quite nice because
it allows you to sort of separate the
effects that you're interested in into
two classes the one I want the ones that
I want to perform now so that's the ones
in EM and the ones that I want to
interpret later and have multiple
interpretations for and those are the
ones that I'm going to build the Fremen
out part a tour from Earth okay okay and
I won't go into the details the
applications are sought more interesting
essentially the techniques exactly the
same okay so we just say well instead of
working over an arbitrary monad I'm
going to work over a mono track and the
implementation is monadic tail-recursive
okay so we can just use tail wrecking
and it all works out so like I won't go
into the details of this bit it's a bit
more involved but the paper which is
links from the repo so it goes into all
the details on this
okay so because because this works for
any F that we're building a free mono
transform rate of while so we can pick
any act right and in particular we can
pick the identity again identity functor
so we can we can build this type synonym
safety that's the free mana transformer
for the identity function over some base
mana and if you solve just expand step
eight this corresponds to safety being
safety of an essentially being either in
it so there's some anodic effects from
em and inside you have either an A or
another safety so if you went to Edwin's
talked the admins Idris talked you
mentioned a type called in fire and it's
not very similar to this type it's
basically just a big Tower of monadic
actions what expressed sort of one step
at a time okay
the only difference is in this case we
have we actually track the final return
type because we're interested in
potentially infinite actions not just
always infinite actions but it's the
same sort of idea okay so the idea now
is that since we can build this safety
on a transformer and we know that free
tea is stack safe for any functor and
for any monad well now if we want to
perform some monadic computation that's
recursive but not necessarily
tail-recursive well maybe we can't do it
in M but safety M is certainly safe okay
so we can just lift everything up
because safety is Amon our transformer
every time we see an action in our
recursive definition that uses M we can
just lift it up into safety
okay and we also have this function
called lower that uses run free tea and
which takes a safety in some mana dreck
and lowers it down to an MA we can
retract this back down on to n okay so
that means as a worst case scenario if I
have them on a trek maybe I can't write
my function as tail-recursive but I can
always just lift it up to safety so
essentially get this notion of stack
safety for free okay so get them on a
trek not just the tail-recursive monadic
functions but actually all of the
recursive method
this can be made safe so if we're
feeling lazy you know we don't even have
to use tale reckon we can just write
this out naive replicate an by lowering
down a computation from safety but every
time we see a computation that's that
we're given an M or we have to lift it
up into safety
but this this is stack safe by virtue of
free TV and stack safe okay so this is a
nice little trick if you you know you
don't want to try and figure out exactly
how to make something tell recursive or
maybe it can't be okay and the nice
thing is you know safety has induced
instances things like Monod state monad
error they all get lifted up so you can
sort of always just shift over to this
safe team honored and get stack safety
for free okay last applications
coroutines okay so in the Fremont I
talked earlier somebody asked you know
all these abstractions are nice but
they're any applications were you don't
need to understand the actual sort of
free machinery in order to get the
benefits and core routines are a nice
example of that so what's a core routine
okay so curry teen is like well I mean
the implementation is exactly the free
mono transformer okay it's something
where we compute in steps and every step
we we do some work so those are going to
be effects tracked by our base monad and
then we suspend and what we do at the
suspension depends on the funk that
we're using to build our frame on our
transformer okay so we might do things
like emitter value so we might if we
want to build something that's a little
bit like an asynchronous generator you
know I forget what the things called in
JavaScript the called generators right
now I forget but if you want to build
something like Python generators that
can be asynchronous and have
asynchronous effects then you can do
that using this producer type synonym
okay that's just a free mono transformer
over some base monad and we're fixing
the function to be this init bump and we
track this the type of the things that
we want to emit okay so the myth is just
it only has one action and we said that
a was going to track what to do next so
every suspension we emit to know and
then we have something to do now
okay so I'll give a demo with this
really quickly but this can be is useful
for you know talking about a wide
variety of asynchronous generates is in
a nice way
so the jolt produces is the Joule - a
producer is a consumer and if we want to
do something like handling HTTP
responses from a web server in the
chunks way then we might want to we
might want to do in terms of consumer
which is this this idea of an
asynchronous enumerator of data okay and
this is just exactly Joule - to
oh this is wrong I'm sorry this should
say a weight not consumer but it's
defined in terms of this a weight
functor okay and we again we tracked
with type of things that we want to
await and at every step we wait for an
input and then we have a continuation
that tells us given that input what is
the next thing to do okay so that's just
a model of a numerating values
asynchronously from a server or
something like that okay and then
details on this slide aren't terribly
important but the idea is that we can
take a producer and a consumer and just
that zip them together right the
producer is gonna a synchronously
generate something's going to perform
some actions and then emit an an item
and a consumer is going to perform some
actions and then wait for a value okay
so we can just zip those two things
together and every time the producer
produces something the consumer can
consume it and have its effect and then
we go on to the next step and run these
two core routines in lockstep okay and
the details here aren't terribly
important but the implementation of this
fuse function is monadic tail-recursive
right so we can we can actually give an
implementation of this that works for
deep free mana transformer computations
I call routines that run for a longer
infinite time so this is a really handy
way of coming up with a library for
producers consumers various types of
core routines and stop stitching them
together in nice ways so we can do
various types of fusion and they're all
safe we confuse two producers and we can
get a producer of tuples or we can fuse
together to consumers and we can
consumer of tuples are we confused
together a producer and a consumer and
get something that you know doesn't do
anything when it suspends it just it's a
essentially one of these in file
computations right that just has some
effects every step and then we can just
run that to completion so why is this
useful well so it's useful because
producers and consumers model a great
variety of the sorts of effects that we
want to track in languages like pure
scripts on the web so we often deal with
asynchronous things so in particular
we'd like to be able to do asynchronous
file i/o in JavaScript and it can be
tricky after so I'll deal with the
callbacks everywhere but the core
routine machinery sup hides all that way
and you'd have to worry about it you
basically just say here's my producer
maybe it comes from file i/o and here's
my consumer maybe it comes from a web
service and I want to take every chunk
as its generated and just push it into
the web service and there's there's all
sorts of nice things you can build with
this so you can do you can build
coroutines for WebSocket so you can
build coroutines for ajax both upstream
and downstream and have a quick demo but
I see I'm down time five minutes all
right yeah should be okay all right
okay so I have a little snippet of code
that's I've already written here so that
what's going on so essentially what I
need to put here is a core routine that
I want to run the core routine that I
want to run that's going to from example
I'm basically going to read a file in
chunks and print it to the screen and
then we can show how we can do things
like write a cat's program that will
read multiple files but the important
all right
the key thing here is that we're reading
in chunks
all right well it's that 50% of the time
right so it's okay okay all right so the
key thing is we're reading in chunks and
not using more stack than any of the
pieces any of the building blocks are we
using to build this all right so let's
say we want to read a file well I've got
helper function in my helpers module
here and this is one of my core routines
it's a producer okay and I have to give
it a file encoding that I want oh I have
to give a file in coding and the file
path that I want to read and the size of
the chunk that I want to read in this is
no good
all right you know I'm nearly at time
anyway so let me just go through the
slides anyway suffice it to say you can
just write something basically that says
build a read file coroutine that's going
to be my producer and fuse it with a
printer core routine which is just going
to print these things to the screen as a
consumer and the machinery just takes
care of sort of all the plumbing and and
it's of you can run forever if you
wanted to you can give the very large
files without using too much stack so
you have this library of you have this
library of coroutines you can just glue
them together nice ways okay I'm going
to skip the demo all right so I can wrap
up very quickly okay so what's the
conclusion
so monad Rack is this nice type class it
extends monad and it can it can take a
variety of tasks based on things we do
in Haskell and make them possible in
pure scripts where it's a nice way to
sort of port for ideas from high school
it's a pure script Oh Scala or other
languages with those features that I
mentioned so crucially it doesn't work
for every Mon that it only works for
mono rec instances right so we always
trade-off the ability to do things for
arbitrary monads for this so slightly
smaller subset which is still quite
expressive but on the other hand we can
always reason about our stack now we
always know it's safe so if you want to
use these ideas you know it's available
in the pure script standard library
scholar Z implemented them the cats
library implemented them as well and I
think
an implementation in the Fantasyland
JavaScript's repository as well and if
you want to see some of the details and
there's plenty of examples of
co-routines and things there as well
then there's a paper on my website which
is from toriel comm stack safety for
free
so yeah you can check that out I'll come
and talk to me afterwards and I can show
the demo as well hopefully so that's it
thanks very much and
yeah so find me on Twitter and etc yeah
3 1 we have do you want a fight no right
I'm just gonna get the closest one
because we really do that 1 minute so
you again do what this reminded me of
Haskell's pipes library is there a
shared lineage there yeah so if you look
at the implementation of pipes it's
essentially or as I understand it it's
essentially just a Co routine so then
obviously there's a lot of operators for
connecting pipes together and and the
interesting stuff is all the nice you
know rich class of ways to connect these
things together but the implementation I
think is just coroutine with various
types of things you can do a suspension
like read from the client push to the
server write to the client all these
types of things yeah but of course in
high school you so don't need to worry
about the stack safety bit yes oh well
there's different worries I suppose but
yeah if I'm thank you thank you for all
right</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>