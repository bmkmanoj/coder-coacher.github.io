<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Flexible Elixir - Claudio Ortolina | Coder Coacher - Coaching Coders</title><meta content="Flexible Elixir - Claudio Ortolina - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Flexible Elixir - Claudio Ortolina</b></h2><h5 class="post__date">2017-03-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/D3IftRUQgqc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so lots of people in the room so
that's gonna be let's go just just as a
for me to understand how many people are
here and they're never attended this
conference before or any or long
conference for the matter okay how many
people have never written a line of
we're like okay how many of you I have
never eaten a line of Alexia how many
people have written a significant amount
of Perl yeah I see at least one okay
okay so this talk which is was
originally called idiomatic elixir and I
as I was walking through it just changed
the name because it it felt like I was
gonna go in anywhere with this so
actually what ended up being more
interesting for me to talk about is the
area of flexible alexia so as you would
expect let's stuff for the definition of
flexible so flexible is something that
can change depending on the situation
and in the case of a piece of software
or a programming language we could think
about requirements or pretty much things
that we didn't know about the problem
we're trying to solve the just surface
as we walk through it but doing that
means being able to do that without
breaking so more off than not we find
ourselves in the situation that we start
to build software we have all the best
intentions and we really want to make it
easy for this software to change over
time but as we try to do that things
just explode and the complexity just
grows and it becomes very difficult to
be able to maintain their flexibility so
you know maintenance grows iteration
speed goes very high so in the end all
of this becomes a big problem so the
idea with this stop when it will do it
through code examples is to navigate
through three basic ways of using the
language and there's gonna be a lot of
overlap with things you can do with with
Erlang as well so it is elixir specific
but there's things that you can use in
Erlang as well to see how we can
maintain their flexibility now if
few are at the beginning of your
learning process with Alisha
Erlang there may things that like may be
useful for you if you are a very
experienced developer I would recommend
to look at these things from the
perspective of someone of helping out
someone who's learning all these
examples come from the fact of talking
to people that are learning the language
and things they gave sometimes they get
stuck into so it may be useful just to
see how you can help out these people to
unblock over time so just keeping a
maybe couple of perspectives at the same
time so the first use case is handling
volatile data so any volatile data which
is a very generic term in our case means
working on a cash tone now this is quite
an icky value cash store is one of the
like textbook examples of things that
people build with along an elixir as
they go through it particularly when
they start to talk about processes
because they're fairly contained API and
it's fairly straightforward to
understand so our key value store in the
example is very simple it just has get
and set and it doesn't have expiry it
doesn't have to tiel's and essentially
you can put anything into it so we're
not going to worry too much about what
actually goes into it but important bit
to remember is that it will be backed by
a process so we will start to introduce
the idea of using processes to build
something like this that's why you can
you can start it now and in the electric
world it does a lot of emphasis on using
agents for these kind of things that
then if you if you just like make like a
very simple research on the web on how
people build this type of key value
stores agent comes to mind first so an
agent is effectively an abstraction on
top of a giant service so an agent is a
process that in a completely sequential
fashion so one message at a time has an
API to hold a certain piece of state the
shape of the state is
completely arbitrary you can just use
whatever you like and then he offers
primitives to get set and update it so
money used to store state that doesn't
need to be accessed with a extremely
high frequency because it is one process
so by definition it is a bottleneck so
to use it as you can see like the API is
is very straightforward very short you
you basically use callback functions for
everything so in terms of implementation
it has the benefit of being clear and if
it's I mean just because the slides have
to be like the font has to be big but
this is just a less than 40 lines of
code so it's simple because you can keep
it in your head it's also strictly
consistent because it does one thing at
a time even when you want to update and
read it offers an API to make sure that
that happens in the right order but that
becomes also the drawback in our example
of a cache store having one process that
does that doesn't it's not going to end
up well under a low test scenario
because you will have a message queue
that grows until basically the entire
node explodes and as it's in memory data
in that process if it crashes the data
is lost now the recommendation is not to
do much in the functions you pass to it
so it's very unlikely to break but in
the end the risk is still there so when
people investigate improvements over
this they end up working on a
combination of djenne server and it yes
so J server is a primitive - it should
say behavior more than a primitive to
model a client-server relationship so as
a process that interacts with another
process I'm a client the other process
is a server I can send messages to the
other process that conform to a certain
grammar to a cinder MPI and I can
basically either execute commands and
get results or simply execute
side-effects on the other process it's
so generic that you can use it to model
pretty much anything and use it as a
building block to model all sorts of
other things
and the server defines how these
mutations and this data works but it's
also the base of implementing agents so
effectively you're going from a
specialized implementation with an agent
to a more generic one with the gen
server where you can do more things it
yes which is the other idea that we're
gonna bring into places our long-term
storage is effectively a key value store
built in in the standard library that
can be used with different properties in
terms of uniqueness and performance or
in Access of the data it can hold very
large very large data the long terms so
it doesn't have a su you don't serialize
data in and out of it adjusting all just
the data you put into it any office like
interesting properties like constant
time access so it makes it ideal for a
scenario where you were to build a cache
store because you can it does have the
property of being very fast in looking
up the information in so if we start
replacing the agent deployment ation
with an ETS table that we can start to
optimize around the use case of
performance particularly so if we if we
put our table as a table that can be
read by any other process with a public
access and we optimize it for for
reading so we we basically we twist some
knobs in the table configuration so that
long burst of reading operations become
remain really fast compared to writing
which is most likely the scenario
bacastow like you don't write that much
but you read way more often then we can
sum it completely reverse the
perspective in terms of how we end up
the pressure on this cache door because
while we still write going through the
gen server and you may or may not do
that but this way you just write that
basically as sort of like a predictable
pace one message at a time but then when
you read you read directly from the
table so instead of going to the gen
server and we use essentially keep that
gen server pieces you
move the reading operation to the
calling process so that that gives you
the back pressure you need and hopefully
you will not suffer too much for it
but you basically optimized so that more
processes can read at the same time
without the problem of having to wait
for the gen server to be free and take
charge of the request so you get good
properly concurrent writes and reads you
introduce a style you you're switching
from strict consistency to eventual
consistency because if writes are queued
and then if the Jessel is busy and is
still waiting to write and you read you
may read something that will be outdated
by the time you reach the last message
in the gen server but as it's a cached
or it may not be a huge problem but
depending on the use case this may be a
deal-breaker again we have the same
problem as the table is owned by the gen
server if pageant's of a crash is the
data is gone so to solve this last
problem we can think about the data from
the point of view of the application so
we move we expose and appear in the
caster's to create that table and we
move that operation to the top level
application now it may not it doesn't
need to be necessarily the top level
application but that just means that we
are making the explicit choice of saying
that data it is volatile but I don't
want it to go away and this way it would
go away only if the entire node crashes
which in comparison seems like a much
bigger problem to worry about so at that
point I guess the cache data is not that
important so you basically have only one
possible event that can cause that data
to disappear and the reason why this may
matter is because while the data itself
may not be important the cached or the
computation needed to repopulate the
cache may be extremely heavy depending
on the use case so in the case of a for
example a recovery after a crash or a
sort of like disaster in the app a
influx of
computation that has to repopulate the
cache may actually be a worse problem
than the crash itself
so this way we somewhere like try to
avoid that so the second use case is
around expensive operations now this is
again it starts from the idea of a study
from a basic use of Gen Server which
we're gonna use to implement some sort
of bucket like a bucket represents a
process that we can use to save data to
a remote location so the expensive
operation we are going to focus on in
save data to a remote location which is
network and all of the problems that it
can imply so adjust our implementation
and this is like code sometimes you like
you you definitely see is we want to
save the data remotely but we also want
to know that DEP operation that has been
has been done but the code written like
this has one specific problem which is
you are basically waiting for the
operation to finish to return to return
essentially the color is blocked until
this happens but it it's a bit of a red
herring because actually what you can
see for the code is that you don't
really care to you don't really care
about the ADI it seems that you care
about the return value of that operation
because your pattern match gone okay but
the result of that doesn't really matter
because you're returning a static value
so what happens under the hood and that
when you talk to people about this is
that what they actually sometimes they
care about is not the fact that the
operation is successful at this point in
time but rather that the operation has
started so this works but the bucket is
blocked when it well is saving the color
is blocked pretty much everyone is
waiting and if you fail to sync the
bucket itself dies because that pattern
match clause will cause the bucket to
crash so we can start to work around the
first problem which is how do you our
knowledge the work being done while not
blocking the caller
first thing you can do is that if you
just really care about a confirmation
you can definitely still use it handle
calls you can definitely block by reply
straight away to the client saying I
know what I'm doing this this work will
be done and then after that you start to
do to work with them with the remote
source so this way the caller isn't
blocked and you have the guarantee that
you know that by the time this call
returns you know that the work will be
executed it's in the process of being
executed so the caller is unblocked and
he has the same guarantees meaning if
you just care about that you have that
you know that that's going to happen now
so yeah this doesn't have anything to do
but what's the problem with that is that
now for that operation which is a
one-off operation we are blocking the
gen server for no specific reason so and
this is where you may you may have
different solutions but at that point as
you are free to do that computation
somewhere else you can decide to move
that computation from the gen server to
another to another place and that could
be anything from spawning a process or
using a sort of like a bound amount of
processes like a control a control pool
like any there are different techniques
for that but in the end there's no
specific reason why that computation
should happen there the only thing you
care about is that if it fails you just
know about it so the bucket is unblocked
and that way we just we just get a nice
compromise now the third use case is
about what I call essentially functional
pipelines now this is elixir specific
the two first use cases you can
definitely do the same thing in Herman
but functional pipelines is a specific
thing that elixir provides compared to
compelled the constructs available in
airlock so if you want to digest user
input let's say you haven't something
data you want a whitelist the data you
wanna vote do some validations and save
it each step along these lines may fail
meaning each step can return an error
and you care about that but at the end
of it you want to have a value you want
to return the value that represents
either the success of all of this
pipeline or any error halfway through
like a pure pipeline which is like what
you one of the things that you see
normally when you look at a lot of
examples uses a pipeline that uses the
pipe operator and the assumption that
this code makes is that each step
returns a value that can be piped
straight into the following function
because the pipeline operator is just
it's a it's an operator it's just an
operator that takes the return value of
the previous function and passes it as a
first argument in the subsequent
function so you can just use it to
basically unroll a nested function call
but there are a few problems with this
because what if you don't return a value
you return an error at that point you've
got an argument error because there's no
pattern matching between the two
functions and everything crashes
miserably and the only option you have
at that point especially if you're doing
this and it's wrapped by for example a
in this case is a hypothetical
controller but if you think about it in
a request process the only thing to do
is put like a massive catch-all around
it
rescue any type of exception or error
and return possibly a 500 to the user
which may not be ideal so what you want
in this case the work could be more
desirable is making sure that yes we
want to something that works for the
golden pad but we don't want anything
that fails with argument errors because
it's just difficult to manage so you can
try and you can try to use a trynna
rescue which is a slightly different try
rescue handles specifically exceptions
in a lecture where you have the ability
to try a computation
and rescue a specific exceptions do you
pattern match on the exception being
thrown and if you rescue it then you can
return a value anything else
we'll just keep we'll just keep erroring
so the process will crash but it's like
a I mean it's a bit of a shotgun
approach like you just like shoot a
massive like you just put a massive net
underneath and then you just hide any
air into it now it could be useful to
protect the entirety of a request cycle
but it may not be useful to actually
understand what's happening and more
more than that you're asking we're
rescuing the fool you're hiding poor
potential errors so all failures in this
in this approach are treated the same
way there zero difference between them
there's something that is better there
is just a much better approach with this
which is the usage of a with macro now
the with macro is act is like a
supercharged version of a combination of
between a pattern matching and the pipe
operator but the way you read that
statement width is you start from the
top right and if the computation on the
right return something that matches on
the left you go to the subsequent line
on the right and do the same thing so
you just keep going zig zagging right to
left right to left if at any point the
pattern matching Clause doesn't match
you will drop directly into the else
branch when you're gonna get the value
that didn't match you can pattern match
on it a return whatever you need so this
means that as long as we have some sort
of consistent way to return values from
those functions which doesn't need to be
okay an arrow that's completely
arbitrary you can pattern much any way
you like on the left hand side but you
you still get the benefit of a list of
steps that you can read from top to
bottom with the knowledge that at any
point in time you can just shortcut if
there's an error and underneath and
handle that with a specificity that you
may need so you Express
the intent is very clear you clearly
expressed what can fail and you
definitely have a fine-grained level of
control over all of the failure cases
because Indian exceptions are different
from errors some exceptions represents
things that really the best thing you
can do is just like back off and crash
and that's kind of like the basic
approach in terms of error handling that
we have in there in a community but that
doesn't always apply because sometimes
you want to know why what that error is
because you need to give something back
to the user or to the more external like
layer that wraps this computation yeah
you do need to start if not if it's not
possible to tag some of the return
values simple because if you just have
for example an integer that comes back
it may be easier to wrap it into a tuple
to make sure that you express the fact
that it's a positive result so this was
like a sort of like a ride in three use
cases but the idea the idea was around
flexibility so the flexibility mean we
we went through different use cases
where we gradually increase the
complexity of the code we increase the
number of moving parts in some cases
because we ended up taking requirements
one by one until we reach to a solution
that is still manageable but it has
sometimes completely different
properties from the initial one but the
amount of code needed to do this was
very was very small so we can do this
incrementally without having to
necessarily impact that much all of the
other parts of the code that work
together with the one that we are
working with think so or like ideas that
can come out of this is that first of
all all the things you've seen are in
the standard library for elixir along so
taking some time to look at the standard
library it may be useful there's
definitely a lot of modules that you may
end up never using but some of them are
particularly powerful and
the rest is just about making choices
this is more for something when you're
at the beginning of your of your
learning is it's very easy to forget
that learn an elixir have have a lot of
put a lot of emphasis into taking
decisions about for example who owns the
data the example of the ETH table was
particularly related to this because the
process responds the table owns the
table and you can definitely there are
definitely things you can do about that
but it it wouldn't be necessarily
obvious unless you know that there's
that relationship but it's important to
remember about that so who owns the data
may determine particularly scenarios of
failure and recovery in the application
and also making explicit choices about
who runs functions particularly in web
applications where we have a request
stack sometimes there's a tendency of
doing everything into the request
process even if you split it down to
multiple files but at the end of the day
it's still happening inside the request
process and they may not be desirable
because it it just means they may be
you're doing more computation than
needed inside inside that single process
and finally it's important to just to
start by saying just let's just let's
just write the basic use case and let
everything crash but after that make an
explicit choices about what kind of
failures you wanna you want to have in
your code may be very beneficial and
that's something that can be done over
time you don't necessarily I mean it
doesn't make a lot of sense trying to
predict everything that can go wrong
that's out that's exactly the opposite
scenario that we want to go for
but sometimes paying a bit more
attention around how failure happens may
actually lead to like more usable api's
and easier integration with the other
layers of our system so thank you and if
if you I mean definitely take questions
now but if you have any other question
or anything like that you want to reach
me afterwards these are my coordinates
which I hope they are visible at the end
of the room yeah okay I get positive
yeah all right thank you yeah but they
may they I mean
if it's being written yeah yeah yeah he
does that doesn't block that's the point
that's the point like reads and writes
happen correctly let me think about it
I I think by default you make I'm you
may get a stale copy you may get a stale
copy it depends on how how fast that
operation happens if you see a prima you
may get a stale copy but I think these
kind of things that you can tweak them
for example in this in this case we were
we were basically working with like the
cash there was some sort of single turn
right you've got one of these with the
name in the entirety of the application
what if if you had for example they said
you do you do many things oh I don't
know let's say you're making a game I'm
just like throwing it out there and then
you want to keep a specific state for
each person who's playing the game and
that state is only accessed by that
person and the amount of reads and
writes that that person can do is
limited then you could potentially do
that but realistically it is normally
used to hold some configuration there
are some specific some specific pieces
of data they don't have a very high
frequency of operations because
otherwise it's just it becomes just a
bottom line if there is a place for it
but the moment you get over a certain
level of complexity you may end up
swapping it for a gen server it depends
on how complex it gets
yeah yeah yeah yeah so I'll just like
show it because it's it's actually a
very good so just get in there get in
there
yeah so what Brujo is referring to is
the public flag that makes the table it
gives so it makes it possible for the
table to be accessed by any other
process so that means that it's it's
also potentially something that you need
to think about if you have data that you
don't want it to be accessible from
other places in the application
so
yeah
it's more it's more about what about
just not having to write to function
hats for each function like so for
example let's assume that the white list
function returns okay with the params
and arrow reason that means that if you
did it just with a pipe you will need to
write a version of validate that accepts
okay a value a reason and that that that
becomes a pain after a while because it
forces you to have like ad hoc shapes
for each function and it makes it
difficult to compose effectively after
after a while like if it's like four or
five or six steps is but it gets
unwieldy so this way you just I
you basically just write one version of
the function and then return just that
so basically every every key-value yeah
I mean if a DTS tape will get over a
certain size which is like it depends
how you use it but it can be a variable
number then at that point you may need
to change that table from with something
else like there are different options
around that particularly you can I mean
you can shut the table there's actually
like this there's a project is it is it
Carlos that does the the shots the
shells project I forgot yeah so it's a
it's what like it's basically there are
implementations that you can use for
example to take this text data and split
it into different tables in order to get
back basically by partitioning you get
back performance but really you just
want to profile that first before before
it's a problem but yeah it most of the
times you just memory bound and that
could be that could be the case but
there is a ya know I mean that's mostly
the case yeah
ah I think so
I think so yeah yeah please remember
that when you rate the talk remember
that you're going to lunch earlier
because of the talk</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>