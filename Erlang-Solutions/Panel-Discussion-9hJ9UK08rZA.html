<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Panel Discussion | Coder Coacher - Coaching Coders</title><meta content="Panel Discussion - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Panel Discussion</b></h2><h5 class="post__date">2015-11-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9hJ9UK08rZA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay we're reaching the beginning of the
end here and well we decided to wrap up
the conference with a panel discussion
and I think a bit of foot went into the
panel discussion and we kind of having
going backwards and forwards we decided
to start focusing on correctness they
are so finding and spotting errors in in
languages so you know looking at errors
which is part a compile-time at runtime
and and beyond so before doing that
though I mean sir anthony horror which
we're very lucky in order to have today
will you know start with as quick
overview over some of the constructs
he's been working with and from there
will then pass on to brew state who will
moderate the panel so yeah well thank
you very much it's really a great
privilege and a pleasure to be talking
to the code mesh conference again
especially since I've attended at least
a day's worth of sessions and been very
delighted at what I've heard both from
the keynote speakers and from
miscellaneous selections of London rooms
and very grateful for this chance to
address you at five o'clock on Friday
afternoon thank you all for being here
but maybe it was partly due to the
little bottles that I see in some of
your hands will be plenty of chance for
that afterwards and during of course I'm
delighted to welcome the bottles to the
one of the features of the keynote
address is and indeed quite a lot of the
more up-to-date presentations was that
they were quite keen on talking about
history and that of course he's also
very pleasing to me since well I'm
already edging towards a bit of history
myself but I also want to talk about
history I'd like to talk to you about
the very first programming language
proposal that I put forward in 1964 it
was at the time I was a member of the
Algol working group of the I fit
organization and we were engaged in
developing the language Algol developing
and improving it over a period of some
eight years and the first proposal that
I put forward was called the case
expressions and we used to publish our
proposals in a little mimeographed
bulletin called the algal bulletin and
here I have copied out the first
paragraph of my article because the ACM
didn't allow me to give a screenshot
widely held that the switch mechanism of
out of Algol 60 which was one of its
less successful features being both in
elegant and inefficient in
implementation at the same time the
general agreement and how I thought
there was general agreement I hadn't
spoken to anybody about it before
the conditional expression and the
conditional statement which only had
just two two alternatives were among
those attractive features of the
language contributing greatly to the
perspective programs written in algal as
compared with SE for track which was the
great rival of our Algol in those days
the okay the article continues with an
example in which it gives a case
expression where the kata that were the
numerical value of the expression to be
discriminated on was followed by a list
of alternatives in this case three
alternatives of statements the first of
which will be executed if the number was
one and the third if the number was
three and of course you've got a
subscript overflow if the value of the
case expression differ was outside the
range 1 2 3 and this is implemented by a
little jump table and an index jump in
the same way as it is in many languages
in order to explain this to you more
clearly I've given recoded this example
in the C programming language or what I
was told at least with the C programming
language because I don't see either the
example is written as a switch with the
cases numbered also in a less it's not a
bad notation a little bit cumbersome
compared with the conditional notation
but this is funny feature of this break
at
end of every case statement the which is
required in order to make sure that you
don't accidentally start to execute code
belong to the next case I think they put
this in because they they felt that it
would that the moving on to the next
case was I didn't think they could have
thought it was a more common alternative
but at least if it did occur it was more
efficient to allow control to just pass
through to the next case until you
reached the break so what happened of
course as I think what might have
foreseen was that it on one application
of the language to a switching system
somebody forgot to do a break fell
through the neck to the next case I'm
caused untold an outage in the telephone
system in the eastern United States
which I would say was probably will at
least a few million dollars of loss to
the company and to its clients and I
feel the programming language designers
should be willing to accept this as a
reasonable criticism of the quality of
their design well at the time of this
proposal the alternative that people
were discussing was the general
generalize a switch construct that was
already in our goal 60 in which was
organized as an array of labels declared
as a switch sort of it's a constant
array initialized to certain labels and
people thought that was rather irregular
if you're going to have an array of
labels why can't we
assigned to them if we want to and make
our own arrays or labels and other
languages have similar facilities of
assigning labels two variables assigned
go to in Fortran and in COBOL they had
something even more clever was called
alter statement if there was a jump or a
go-to statement already in the language
you could alter the destination of the
gump of the go-to statement so that you
know on all future occasions that the
jump is taken the it leads to a
different place in your program this was
provided that the component number of
your program was I think between 0 and
50 but if your program is numbered above
50 then it wouldn't happen because it
would be stored on backing store at the
time you wanted to change it well I
remember reading a very nice article in
data mation which was entitled to come
from statement does anybody know it was
wonderful it did point out that since
what you're trying to do is to code in a
linear textual form what is much better
expressed as a flowchart then it's a
entirely a matter of choice whether you
label the place that you want to come
from and the writer come from statement
in the place where you would otherwise
have put a label and they gave a number
of examples and and proposed this as an
excellent well the disadvantage what
what the assignment of labels does to an
array and the jumping to an unknown
labor
all ensures at least a certain parity of
confusion that the label statement which
receives the jump in the used to be able
to at least look back and find all the
places in the code that they could have
been jumped from and the come from
statement similarly it enabled you to
trace lexicographically the places that
you might be going to the assigned go to
of course gives you neither of these
advantages you don't know where you've
come from or where you're going to well
sometimes sometimes I feel that way
myself
right well my next programming language
design was published very shortly
afterwards it was called record handling
and it made a proposal that one should
include into the next I'll go language
something which is now known as object
orientation it begins a method is
proposed for the representation in a
computer or a complex structured objects
and for their manipulation by program
furthermore arbitrarily complex networks
of relationships holding between the
objects can be represented and
manipulated by the program I never used
the word pointer because what I felt I
was doing was modeling something which
had an inherent meaning that of a
relationship between objects that we
understand very well in real life of
course I knew about everybody knew that
this would be represented by a pointer
variable each record in the computer
must belong to one of a limited number
of disjoint record classes declared by
the programmer in order to represent the
relationships as well as properties an
entirely new type of value is introduced
it is called a reference not a pointer
you may recall it is natural to
associate with a reference field or
component of a record the name of the
class to which all records referred to
by it will belong this is done on the
occasion of the Declaration of the
reference field itself now of course
this is a very familiar idea but the
design that I proposed it it was quite
novel simular 65 which had pointers did
not include any type checking simular 67
did
the first language which adopted type
checking of pointers I references was
one design by Nicholas Viet which was
called Algol 65 or our goal w w after
after wit of s
here's my billion dollar mistake which
you may have heard last time as a
previous code mesh conference in order
to enable references to represent
partial functions functional
relationships a special reference value
null is introduced hmmm well of course I
have no reason to suppose it was a
billion dollars I have occasionally
consulted people who know more about the
field than I do and suggested the figure
of a billion and and and they come back
and say something like what do you mean
only a billion per year which is very
consoling and most but most people at
the last code mesh conference thought
that I was accusing myself unnecessarily
severely and they wish to relieve me of
the guilt of doing this terrible deed by
pointing out that everybody did it
anyway or something like that and here's
a reference to the language description
of the language it included record
classes references and garbage
collection of course and those those
those things I thoroughly approve of the
or I'll forget forget about there's
dangling races I think I'll wait and see
if there are any questions
I think that we are very fortunate here
how you guys can come on over I think
that we're very fortunate here at cope
mesh and you I came from Austin Texas
and it doesn't feel like a long trip
because this is such an excellent
conference I'd like to try something how
many of you in the audience stand up if
you have invented to the language or
been on a language core team I just want
to get it good you guys all count and
the is so check out this density give
these guys a round of applause so we
just have a small smattering of the
language creators here I've gotta gotta
say I'm a little bit luckier I'm here
the density up here is eighty percent so
but I'd like to introduce you Joe
Armstrong creator of her laying Joss I'm
greater I'm sorry done Don's time
creator for the f sharp and and Josh
watzmann creator of a language called
hack and I'd like for them to teach tell
you the story of why they created their
language we'll keep this this first
question to about a minute this work um
why did what I didn't know I was doing
it I think that was the best answer it's
a kind of after the hand condemning
there wasn't the project to make a new
programming language we found ways of
programming that became a programming
language and the main problem i was
interested in was was actually how to
build fault or insistence so so airline
was not a goal in its own right the goal
was to make fault tolerant system the
problem that was being addressed was
having a fault on systems and ailing was
one of the answers to the problem it's
not a complete answer but it's a it's a
partial answer to how you make fault on
systems yeah I started the F sharp
language because I wanted the strongly
typed functional programming paradigm as
represented initially by o camel and
also experienced
from other variations of ml and Haskell
I wanted that to be available to me in
the context of dotnet development and in
the context of Microsoft development
where I was at Microsoft Research I
wanted to make sure I had a language
that I could use myself and be happy and
programming in and and then it sort of
went on from there yeah but it was
really I think that's the best way the
best motivation for making any tool is
to create something you want to use your
yourself you and your peers John um for
a hack at Facebook first I want to say
that I was one of several people that
contributed to the early forms of
language I'm not in any means the least
sole inventor of it Facebook realized
that you know our web front end is
written in PHP it's very dynamically
typed you can have as much discipline as
you want in a dynamically typed language
and that will certainly help you get a
long way but having a real type system
we thought would help reduce the Disco
covel lot of bugs that we were finding
would help our developers write code
more efficiently and be able to
understand that the code base via the
type errors and via the the code
intelligence that you can get that comes
with having a type system and the
knowledge of your code base like that so
you had a pretty pretty large PHP user
base you had a project that that may be
escaped from the lab a little bit and
and blew up and and you had a customer
base that that that was was really
intensely dependent on PHP and so this
was the attempt to inject a little bit
of type sanity to PHP yeah I mean we we
had at the time you know facebook com
tens of millions of lines of code with
probably half a billion to a billion
users or something like that everyone
knows the scale of Facebook and yeah we
can't as much as we might like to have
said you know Mark Zuckerberg should
have picked a different language where
were you know in a state where we can't
we can't rewrite all of that code where
our revenues dependent on it are the
people using Facebook or dependent on it
we can't stop development we can't take
down the site for three years well we
use a different language I'm uh sighs
is just extraordinary both for funding
that but also to be in the position
where you have 10 million lines of code
and you can write a new language you can
afford to write a new language for it
it's really remarkable and wonderful to
be in that position also that they did
it in that and you mentioned actually
injecting type safety as something as a
feature that you very much wanted to
work with and yet you were working in
the early stages strictly with the clr
so was that yeah I thought that that's
right we the first major project I did
at microsoft research was to inject
generics into the design of the dotnet
common language runtime and aware well
actually that it stemmed from an
interesting project at the start of the
dotnet days called Project 7 which was
about bringing many different languages
to the.net common language runtime and
they engaged Microsoft Research early in
that process and I think that was
allowed us to think well what are the
foundations we need at the runtime layer
to support an interesting and the
programming paradigms that we want to
see available broadly yes so it's it's a
type system is a very difficult problem
in IBM we were trying to solve something
with with something called the system
object model with very much less success
I might say but can you talk about some
of the challenges of working with the
types in the clr that restrict what you
wanted to do with what that sharp well
the key things that restricted us which
is the lack of efficient generics in the
need to box far too much we fixed
through the process of adding generics
222 to.net so I didn't really experience
the clr as a restriction when we fixed
it to be what we knew we needed it to be
I think that that said there's a the aim
of the initial dotnet design was to be
sufficient runtime system for a very
broad class of languages in reality what
we've seen is dotnet in some sense
narrow in tavira with have one dominant
language called which is C sharp a skin
a clone of that language which is called
visual basic it's a saying effectively
the same language in a different syntax
at a different culture and then F sharp
and then some other languages but we I
think we have seen in many ways a
narrowing of that field there were for
instance attempts to bring JavaScript
onto the dotnet into the and into the
multi-language ecosystem and they didn't
stick javascript has it's all the
JavaScript runtime use other
implementations so so which leaves open
this big question which is what is the
common language what is a common type
system what is a common API
representation schemers and like that
you know that we use to interoperate you
know and we see things like swagger for
instance to do to faux fur API
description and to give some schema to
the the world of rest api is which is
sort of overtaking as a common language
i still think it's it is longer
recurring theme in language designs how
do all these languages talk to each
other and do that correctly without
falling into this lowest common
denominator trap yeah I mean where's
that going to head over the next five or
ten years is a big question and joe i
remember at code match it was probably
three years ago you had a conversation
with a believe dr. Turner Miranda and so
I was I was just a fly on the wall
listening and kind of you know trying to
pick my jaw up off the floor after you
know meeting some of my heroes and in
dr. Turner looked at you and he said
you'll have spent my whole life working
with with type systems and strong types
I never would have thought that anyone
would be able to create such a reliable
system with dynamic typing I think you
missed the start of the conversation
because he said it were the first
languages with dynamic types
I asked him you know if he had a
preference for one of them they said no
good work with that they had their
advantages and disadvantage but I I
might take on everything was slightly
different I i was looking at entire
system so to me and to robert building
and my williams who would work with we
were asking the question what happens if
the entire machine crashes so i wasn't
so concerned about the software inside
one particular machine i was i was
worried about what happens for the
entire system and and i was intended to
build this for the world's telecom
system so we're talking about systems
are intrinsically distributed and i just
didn't believe i mean i didn't care if
you've proved the program to be correct
or anything like that because I'm
worried about the entire machine
crashing getting hit by lightning or
something like that so so so those are
the sort of errors that though types as
you know type just it's not going to
stop you being hit by lightning so
outside addressing it so I'm looking
it's kind of architectural problems how
how you build complete systems out of
components that can fail and then to me
you know dividing by zero was with
pretty much like being hit by lightning
so so I was thinking I didn't I didn't
want a different programming model for
building very small systems and from
building very big systems so as I wanted
I didn't want the way you program to
change in the way reason about errors to
change because because you've changed
the scale and you've changed the nature
of the error I was also thinking about
systems which weren't started and
stopped I was thinking about systems
that are in operation forever and which
evolved so the start point was
completely different and the goal was to
was to build fault tolerant things and
to me I don't really mind if it's
strongly typed or dynamically typed or
already I think we need all these things
to address different parts of the
problem and of course if we can prove it
to be create that's wonderful but we
can't prove it won't be hit by lightning
step
I'd like to ask a question so all of you
were around in the very early stages of
your languages what in what area did you
pay specific attention to you know I
want to make this right before I want to
make it fast or small or whatever you're
going for what particular features
contribute to making this a platform for
more correct programs and we'll start
with you Josh I mean just the existence
of a type system in PHP was kind of a
bizarre idea at the time um but but for
the most part for facebook we were
actually attending to be on the side of
the trade off of we need our engineers
to use this so if it's ten percent
correct but that's what we have to do in
order to work like that's ten percent
better than we had before um I think we
did significantly better than than ten
percent but we pretty consistently made
trade-offs for performance for
compatibility so that or our engineers
would be able to convert to it such that
it was backwards compatible with PHP
such as we could maintain since it was a
project that was sort of off the side of
the main compiler one of our main
constraints was we can't touch the
compiler um the only thing we can do is
add new syntax that the compiler drops
on the floor so there are a bunch of PHP
isms that we arm that I won't go into
examples but if you're familiar with PHP
there's bunch of edge cases and stuff
that we like sort of tried to deal with
an type system and some of them required
compiler changes and so we just didn't
um so so we tended to make the trade off
for correctness when we could arm but we
we wanted the performance and then the
usability of it that was that was the
goal we had to make it work for facebook
and for the engineering culture at
Facebook and same question to you I mean
the initial and the initial call was
very much guided by this core o camel
call sort of camel light programming
model the call strongly-typed functional
programming model and doing that and in
the middle of type inference recursion
tuples expressions functions as values
pattern matching and so on and every
thing we did
in f-sharp has been since then it's been
very important to us to preserve that
that call and your ability to just
program away in with correct code in
that call for and you can always
everything else is kind of optional and
it sends its additive augmentative to
that core experience and yeah I think
that that so we're just enhancing that
call strongly-typed functional
programming model with interoperability
with objects with asynchronous
programming with you know or it is with
extra typing features with type
providers for F sharp and so on just
just keeping that core productivity in
the zone evert in the zone I think and
Joe absolutely i mean fault tolerance
and having no errors in the system
absolutely central in the first two and
most important things were were the
first one with alternate said the second
one was continuous operation that if we
did detect that there was an error in
the system that we should be able to
carry on without stopping it so we
should just be able to continuously
rolling new software and and that was
because the products we wanted to
replace had those behaviors and we
wanted to make something better than
that so it's absolutely central and it
was it was right in the beginning and it
led to this realization that you know if
they if the entire machine can crash you
you need two machines or three machines
and that led to the realization well
they're going to operate concurrently
operate in parallel so so in order to do
this you have to start looking at
distributed programming so that was
really very very early that it had to be
for writing distributed programs
they were going to be concurrent and
that was the only way to do fault
tolerance because if the entire machine
crashed you have to take over and
another machine so intrinsically
distributed in concurrent know so I read
your book want to make something like
that Anton you you've had the pleasure
of working at Microsoft with just some
some fabulously gifted researchers and
teachers one of them is Sami Peyton
Jones and one of his favorite examples
is of a side effect is that you know you
can't unlock the missiles right so we
always as a launch the missile as you're
aware when you are when you release a
programming language you are launching a
missile and there are some side effects
and there are some things that you've
done that you can't take back so I'm
putting on the spot a little bit but is
there are there some features that you
wish you could take back actually I
didn't have a prepared answer that
question there are some there are some
corner case features that aren't worth
the cost of the of the implementation
complexity they introduced in retrospect
I mean one would be structural
comparison so in allowing you to when
you define a record type they or a
triple type you you can compare them for
less than greater than an ordering and
that's just not not worth it in there in
there in terms of the complexity that
introduces into the F sharp
implementation but we won't remove it
now i minused and that works the I did
wrote jot down some places where there
are unsound this is not so much in the F
sharp language but in the F sharp
experience which I kind of so one thing
I've learned over time is for instance
that your package management management
your library management software can
easily introduce unsoundness a--'s into
or the experience of using your language
you know if your package management and
dependency management system doesn't
tell you that you're not shipping a lot
a library that your application depends
on and you get you're relying of being a
particular version being installed on a
target machine or or isn't tracking
version dependencies correctly then it's
an unsound that's a big gaping I think I
unsoundness now we because we did have
sharp in a particular context initially
which was you know dotnet development
initially but as it was 2003 or
something 2005 when we started we picked
up unsoundness from the ecosystem of
anna tooling ecosystem around and it's
very frustrating to put a huge amount of
effort into helping people write correct
code on the system and then find the
ecosystem you're in is kind of a kind of
a rotten Empire where things bad things
happen because the tooling is not done
right okay now fortunately I think
things like that have been there's
certainly been fixed in there you have
sharp ecosystem there great package
managers now and dependency managers but
it's more than the language is the whole
process of software construction has to
be sound and we perhaps don't talk about
that enough those additional processes
that about delivering correct reliable
software yes we're seeing very much the
same experience in in a language I'm
involved with the elixir language in and
getting the package management right and
that means getting dependency resolution
right and where are the right places to
have exceptions and yeah there are a lot
of a lot of places to make a mistake I
need to go home to her I can't tell them
it's okay it won't be a 1 billion dollar
mistake right okay right and and the
same question to you Josh so there's
nothing that I would say like
unequivocally we shouldn't have done
that and take that back there's a bunch
of places where we did things for
backwards compatibility with PHP where
there um the type system is gradually
typed meaning the programmer can
explicitly omit types and have holes in
the type system and that's fine and you
can have a switch that says like
seriously there need to be types
everywhere this needs to be needs to be
sound but other than those there's a
bunch of corner cases where the type
system has holes that you wouldn't
necessarily expect that makes sense if
you're trying to convert existing PHP
code but I wish that we had done a more
thorough evaluation but all of those
places were before we open source the
project one of the ones I can think of
right now is that if you're if you're
using a PHP array structure and it's a
heterogeneous in certain ways then the
type checker just gives up and it
doesn't say anything it just gives up
and that made sense at the time but
we're now like it doesn't anymore we're
having to unwind that and it's much more
difficult when your project is open
source and there if there are people
using it so I wouldn't say that I wish
we could take that back but I wish we
would have thought whether we should
have done that beforehand because i'm
not sure if that was the right decision
so there are trade-offs right and and
sometimes decisions so every decision is
a compromise and sometimes conditions
change and yeah exactly and like the
project had been in use of Facebook for
in some form for a year to a year and a
half quite a while and so a lot of the
decisions that were made in the early
stages of the project were the right
decision then aren't necessarily the
right decision for facebook when we
released it and for the people we were
releasing it to and we we should have
thought some of those things through
again and we didn't sure and Jose so
you've got one of the toughest positions
on the stage because Erling has been
around a long long time right and
there's there's a lot to second guess
but what are some some places were you
might have made a compromise that he
might make differently there's notes of
places to start with the the a lot of
the implementation was dictated by the
pragmatics the machines at the time they
had small amount of memory it had about
eight megabytes of memory and they
systems then weren't intrinsically
distributed I mean the notion of two
computers being easily able to talk to
each other is impossible so so from the
mid-90s onwards communications become
your bit
we've got hundred megabit links between
computers so distributed programs
suddenly appeared as a ubiquitous thing
there wasn't the case when we did a line
we didn't have much memory so will you
do things very differently now if we've
been redesigned and then in the language
I think there are i would like protocols
to be first class objects in the
language we reason about protocols so
the protocol is now you know today is
something as a on a sheet of paper
outside the language it's not bolted
into the language and the it's it's a
programmer who makes a connection there
isn't a formal connection between the
protocol and the implementation and i
would like much more formal checking of
contracts on boundaries and things
because nowadays we connect large
numbers of things together in Chains and
if any of them fail it's very important
that we know and i'd like to make things
of very small components a talk to each
other and do well defined jobs and if
they fail we know that that thing is
failed we tend to make very big
components and they tend to pass their
errors on to somebody else and we don't
know where they failed so it's i would
like to see architectural changes oh and
i'd like to make I'd like to make the
number of objects we could address much
larger I mean we talk about processes or
the an ailing node can have maybe four
or five million processes I would like
it to address all the processes in every
computer on the world I'd like it to
address trillions of processes I mean
things like email and things should be
as simple as a sending a message to a
named process and the system should just
handle it because then a lot of problems
to just vanish so at this point I'd like
to ask an opening question to the panel
is is there something that you see in
another language that that you think
really contributes to correctness that
you wish that you've done in your
language or that you really respect and
Tony you could answer this one as well
if you'd like
and certainly yeah yeah I'm thinking I'm
sure there are just thanking so I let me
let me go ahead and get and get this one
started there's a when when I worked on
seven more languages in seven weeks and
by the way after writing that book I
really wish that I picked f-sharp I I
became a big convert after going to
conference in Norway really really love
that language but we picked a language
called Idris which did dependent typing
and and I thought as I was coding in
this language I thought this is really
changing the way that I think about
productivity and correctness and and it
really it sharpened the focus of the
tooling it sharpened the focus of up
working with a model and really helped
me think about you know why dole was a
bad thing so I really enjoyed my
experience and Idris yeah I it's a
difficult question to answer because as
a language design I guess I you become
very sensitive to the fact that adding a
new feature to the language pushes some
programmers out okay some people can't
use it anymore cuz I can't learn that
feature it changes the the way that
language is used in communica munity
talking and communicating of code makes
they may code more inaccessible less
accessible to certain programmers so
you're aware that everything's a
trade-off everything's a distortion so
you can't just say I'd like that because
you go oh yeah but if I out of that and
you know something else something you're
distorting the whole equilibrium of
where the language is that is that and
if it's not all about features you know
the value of what we focus on a sharp at
the moment enormously is cross platform
and open source and making that a
reality for the the language and that's
yeah there's something you see in other
languages and we've worked very very
hard
last 33 years to make that real thrift
shop so I guess that's the sort of thing
where when we grew up in the windows
ecosystem where we looked across when we
thought yeah okay we got to do this we
got to do it well and focus on that and
so I guess that's where I feel the and I
sorry so it's not even it's also about
like you know scalable data systems you
know spark in Scala wonderful system
yeah and we want we want we want some of
that you know what we answer where we
are we're doing that we're doing the
work to make that real in the f-sharp
ecosystem but it's yeah date so I don't
feel the jealousy of the length aah chak
transferring language features by
jealousy that's just it is the best way
to do tech transfer at Microsoft
Research the way the best way to get to
have influence on a product team is to
make them jealous of some feature it's
been great with C sharp it's been
awesome yeah just saying load the demos
and I see that all that I shall I want
that so you said one thing you said
community and I think that one very
important thing to consider to making
programs right is having the right
programs on the project and one of the
things that you've done very effectively
is moved f sharp beyond the stewardship
of Microsoft so that you've really
expanded that community could you talk a
little bit about what that process was
like and the impact that you've had on
the language that way yeah I put out a
blog post recently which was saying look
when you use a word f sharply when
you're referring to what Microsoft do
with fer please use the product terms
visual F sharp or the f sharp tools for
visual studio Microsoft contribute a
huge amount to F sharp but we've
liberated it to him to be incensed a
broader initiative it's very lots and
lots of community driven stuff there's
lots of cross-platform stuff there's
lots of open open source working people
are taking F sharp in all sorts of
places and so the word f sharp now
should be like every single good
industry language is should be
considered a free term you know the same
sense of closure
is a free term or scholars are sort of
free free term a free in the sense of
not having such strong mental
associations with microsoft visual
studio or whatever and and that's the
right thing because it's actually the
right thing from microsoft because we're
becoming if you look at our product
directions with azure and the cloud
platform where we're open all sorts of
things it says hey you do go come and do
it on as you do linux do it on as you do
you do what everything coming yeah we're
much more open kind of company than we
were before so it's right from Microsoft
it's really right for F sharp it's right
for the F sharp ecosystem and now the
process of getting there has been a
strange one because I actually always
been a researcher I always wanted the
head in that direction and then suddenly
the whole of Microsoft came following
right we were taking what we were making
sure that f-sharp worked had a great
cross-platform existence and then
Microsoft came following in a herd to to
also do very similar things with C sharp
and a lot of our tooling and every and
yeah so that it's been unexpectedly led
Microsoft but we didn't I mean they went
there because of this sort of cloud
dynamic in the industry the the whole
cloud thing the cloud and devices thing
moves towards much more open
technologies open open source itself as
an incredibly strong economic dynamic
and it's as great that our shift in that
direction f F sharp in that community
also correspond to you know the whole
world going in that way so anybody else
want to take a shot at that question and
the question is are there things that
you've seen in other languages that you
respect and maybe you want to implement
it maybe you don't but that really
contribute to correctness um so not
necessarily correctness but it in
general like things that I wish we had
launched with what you were talking
about tooling like or our installation
process on day one was terrible we
didn't really have any tooling around
the language the bits we had at Facebook
we hadn't gotten to open source yet so
as far as like bringing the correctness
to other people like I can't understate
or sorry overstate
how important it is to think about the
tooling and then did the general
ecosystem around your language the
language features that you have the
shiny correctness things is secondary if
nobody's using it yeah I think things
like John O'Mara talk about a quick
check of quick checking hardware very
promising and I'd be very interested in
reproducible builds and being able to
describe the state of systems accurately
because I mean at the moment you don't
know what state the operating systems in
and so if you report an error so well I
did this on my computer in it crashed
and somebody else has will do this it
doesn't beg the same way so I mean if we
had things like a small talk image and
you had the sha-1 check some of it and
you say well you know we started in the
same state at least you have some chance
of finding where errors were so I think
things like reproducibility of builds in
systems I don't really like them being
outside the net you know I don't like
things being in get and being sort of
distinct from the language I'd like to
see much more integration with the
languages so I'd like to refer to more
do with by their sha objects arm or
something like that so I know exactly
what it was it said there's a sort of
spectrum of precision naming things
basic like to do away with names totally
because the transcendence their content
can change Antonio do you want to take a
shot at this one you offered me before I
said I would all right do you want me to
question right since I'm not a designer
of the programming language and never
have been I haven't really had the
opportunity look jealously at other
languages one thing that is really
impressed me recently is is the
separation logic concepts that were
introduced by Peter O'Hearn in his
concurrent of separation logic language
which seemed to seem to be a potential
solution to the problem of race
conditions in a shared memory computer
system so I would look forward to that
being
recognized and implemented in tools as a
means of solving a problem that is
probably of the order of billion dollars
quite easily i would like to also
support the view that it's the tools
where the action is not the languages
the compiler is only one among a whole
battery of tools that are now essential
to work successfully together in the
development design specification coding
testing delivery certification analysis
of all the all the programs that we use
today and in particular more connor i
would like to have concentrated more on
the evolution of programs after first
delivery when i was an academic my model
was that you sat down with a piece of
paper and you wrote a program from
scratch and it wasn't thought still in
oxford we started teaching professional
programmers from IBM in hursley that we
discovered that none of them had ever in
their career started off to design a new
program it was all maintenance and I
think that's even more so today so as a
theoretician what can I do to help in
the development of these integrated
development systems well I think my
contribution I would like to be to see
the need for an unifying theory on which
all the tools can be based a theory that
would apply to many different languages
and a theory which could be specialized
to the needs of the individual tools
which are applied to those languages so
more languages yes certainly but they
all need tooling are they all going to
have their
own separate tool sets no they are not
therefore we must make our tools not
only agree with each other but also make
them adaptable to the needs of many
different programming languages so this
is overall a project about equivalent to
the original ideas of compiler compiler
which would enable you to generate
compilers automatically it's much more
in much more adventurous and ambitious
than that and that of course is
something that has never happened anyway
so I hope you will be good news in the
future at the moment we have a problem
of tooling for a multiple language
system that's a great way to wrap up let
me let me point out that that there are
people that aren't on the stage you know
with with elm and julia and haskell and
in pony and Scala and I'm sure that I've
left a bunch of them out but thank you
for all your contributions to the
conference thank you so much to the
language creators and early contributors
that are on the stage and I'd like to
invite Francesco up to wrap up the
conference
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>