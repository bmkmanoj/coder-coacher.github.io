<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2015 - Brett Cameron - Porting Erlang OTP to Exotic Platforms | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2015 - Brett Cameron - Porting Erlang OTP to Exotic Platforms - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2015 - Brett Cameron - Porting Erlang OTP to Exotic Platforms</b></h2><h5 class="post__date">2015-03-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WprZD_sP3lk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">today's talk porting Erlang OTP to
exotic platforms what it's really all
about is world domination world
domination for early so for various
reasons over the past oh I don't know
six seven or eight years I found myself
in situations where I've had to build
Erlang on platforms other than those on
which one would normally find it so you
know most of us are used to downloading
the Erlang kits from elling solutions or
wherever and installing them on our
linux boxes or on imax or on our pcs as
it's the case with me from time to time
but for various reasons I've had
situations where customers have wanted
to use air like Erlang on other
platforms or possibly friends or
colleagues have wanted some help to get
some sort of airline based application
going on another platform so if a bit of
better or worse I found myself learning
possibly a little bit more than I really
want to know about some of the inner
workings have been and how to get that
going on some possibly quite exotic
platforms so contrary to what Francesco
said this morning we're not necessarily
talking about mainframes here although
possibly in the future that will be you
know that the final bit and the world
domination for Erlang thing but some
exotic slightly different unix platforms
HP's legacy openvms operating system
platform and things like that so what
I'm going to talk about is my
experiences of doing those sorts of
ports the sorts of things you've got to
watch out for the sorts of things you
encounter various clergy Hecky
workarounds so on and so forth so that's
nicely summarized the abstract a little
bit about me I've worked in the software
industry now for 22 23 years vast
majority of that time has actually been
with HP hewlett-packard and I just left
them late last year to go and work for a
little startup which as I come to
shortly has managed to license the whole
pile of intellectual property from HP
and we're looking at taking that forward
enhancing it adding more good stuff to
it including airline and having all
sorts of fun
okay so introduction the company I work
for these days is called VMs software
inc and the intellectual property that
we've gotten off of HP is an operating
system called openvms that was
originally developed in 1977 by what was
the in digital equipment corporation
affectionately known as dick now deck
were bought in the late 90s by compaq
and compact was suddenly bought by
hewlett-packard if you know your your IT
industry history HP a couple of years
back actually on my birthday in 2013
decided basically that they were going
to pull the plug on the openvms
operating system that caused the number
of ructions and my boss the smaller guy
in the photo of here Eddie worked
tirelessly to convince HP that you know
he could set up a company and we could
take over the ongoing maintenance and
support and development evolution of the
openvms operating system so Eddie
succeeded in that desire and to date
we've we set up the company 31st of july
two thousand fourteen and today we've
got about 35 staff and we're probably
not going to grow to any more than about
a hundred looking to double in size this
year ok so open VMS anyone here ever
used open VMI's oh good to see ok right
so as I said open VMS originally
developed 1977 it's a totally non
unix-like operating system it would look
like an alien world to anyone who is
familiar with UNIX and not with anything
else so totally proprietary key things
about openvms were sort of philly
unmatched reliability stability and so
forth there is actually an interesting
email discussion going on a bunch
amongst some of the old VMS brigade just
before I the talk here talking about
some of the up times they've got and I
mean there are systems i recalls the
system somewhere in the netherlands it
might be at police station or something
that hasn't been rebooted for close on
20 years and in terms of security which
is another big feature of the operating
system so only 38 vulnerabilities
reported within thirty seven years now
you compare that to the likes of windows
or you
X or whatever how many vulnerabilities
reported every week so we're talking
about an operating system it's had 38
significant vulnerabilities reported in
37 years there's a lot of users out
there so this the size of this business
is not really enough for a company like
HP to be too concerned with but from our
perspective with our new company via
software incorporated there's more than
enough business for us out there even
with the existing customer base and we
hope to grow that and develop it further
operating systems used across the board
or all the major industry sectors so
just very very quickly brief timeline as
i said the operating system originally
developed around 1977 by digital
purchased in 1998 by compaq who in turn
purchased by HP and as i said on my
birthday fifth of jun 2013 HP
effectively announced the end of life of
the operating system thankfully we've
now got the new company to take it
forward and there's a lot of happy
customers because of that okay so enough
history and on to summerlin related
stuff so first up what i want to do is
just talk a little bit about existing
implementations and and maybe not so
exotic ports of vierling then maybe just
a quick refresher course how many people
here have built Erlang from sources okay
cool so I'll go through that but very
quickly in that case so just just a
refresher course on how to build Erlang
from sources and then we'll start
talking in more detail about some of the
issues you face if you're going to try
and port that code to work on some alien
platform okay so existing
implementations and and reasonably well
known ports of Erlang obviously you can
go to Ln solutions and download latest
release of Erlang for your favorite
linux platform or whatever my costs and
windows over the years there have also
been a number of other ports of course
to various platforms I mean FreeBSD as I
recall whatsapp run earlier on on
FreeBSD tru64 that was another UNIX
operating system that was effectively
stopped by HP that came from digital
equipment corporation very good
operating system actually and a few
other bits and pieces are a few other
ports
over the years overlaying to various
operating systems and real-time
operating systems and now much less
fashionable versions of UNIX such as i
RX some of the ports that I've been
involved with there's a few that I won't
list there only like to list my
successes as opposed to my failures and
these range as i said earlier from
anything we're friends or colleagues
needed some help getting in Erlang going
on some other platform where where it
wasn't currently available as was the
case with AIX we needed to get RabbitMQ
working on AIX to a proof-of-concept it
was relatively easy I mean the bottom
line is really as long as you've got you
know the canoe c compiler can you make
auto comp and other bits and pieces you
probably can just about builder lag on
anything that's got those things on it
so it's not quite that simple and i'll
come to that later on but you know
you're essentially going to get probably
seventy five eighty percent of the way
if you've got those going to tools at
your disposal so we did a quick and
dirty port of AIX as i say for a proof
of concept it was enough for the proof
of concept that still had some rough
edges hp-ux Itanium and my time with HP
the HP printer group wanted to use
RabbitMQ again for a number of projects
that they were working on so we did a
fairly good port a fairly complete port
overlaying to hp-ux on itanium itanium
being an intel processor type that that
really only HP developed servers for
tru64 well that was easy i was bored one
evening and just wondered how hard it
would be and it was pretty darn straight
forward the big one from my perspective
over the years has been getting early
and working on on openvms the first port
i did that took me a little while and
probably caused me some serious liver
damage subsequent ports really don't
take very long at all it's just a case
obviously of replicating the changes and
longer-term i guess what we want to do
is look at trying to get some of those
changes pushed back into the main code
essentially that started again i wanted
to get an advanced message queuing
implementation working on openvms and
and
the guys at RabbitMQ so the logical
choice except for the fact that it was
written in Erlang so as a bit sad and
depressed about that for a while and
then a good friend of mine basically
dared me to try porting in la into
openvms so that was like you know game
on and I'm happy to say we got there an
en quite a few challenges that I'll
discuss shortly okay so a quick
refresher for those who may not have
built Erlang on Linux or whatever
essentially the you know half a dozen or
so commands that I type there and you
could obviously combine the G unzip and
the tar xvf you could combine them into
one command so you could chop one of
them out but essentially that's kind of
it assuming you've got a reasonably well
set up linux system so we're going to do
an install of all the new tools we need
with the apt-get install build-essential
we're going to use our favorite tool to
download the sources unpack them type
configure type make go and get a cup of
coffee or something and come back and
magic will have happened and it will
have built and we go into a make install
and then we can go and do cool stuff
with early all seems pretty easy the key
thing here is you know the holga new
make thing where you run some configure
script and it generates make files that
generates header file that deals with
platform dependent things and so on and
so forth now when you run that configure
script as I say it's going to generate
for you a series of make files that are
needed to build all the bits of Erlang
and OTP it's going to generate for you
header file which helps to try and deal
with all the platform dependencies
little subtle differences between C
runtime libraries across unix and
windows and and wherever but at the
highest level what it does is it
basically has a bit of a look at what
you've got installed on your linux
system and if you don't supply any
options to the configure script it's
probably going to come back to you and
say well you don't appear to have some
of these things installed i'm not going
to build those so i have no particular
interest in java so my linux server
didn't have java installed i obviously
didn't have unixodbc installed and i
don't really like wxwidgets i'm a bit
like mike when it comes to that sort of
thing
and so the configure script didn't find
those things I hadn't installed them so
it's just telling me here i'm not going
to build Erlang with this stuff in it
and I'm not going to generate the
documents because you ever got the right
stuff for that but that's okay because I
never read the documents anyway okay at
a high level that's what configure is
going to do but if you actually have a
bit of a look at the configure script in
more detail it provides a heck of a lot
more flexibility than that it you have
huge control over how early it's going
to get compiled how it's going to get
built what features are going to be
included what features are going to get
excluded I'm not going to click on the
link there but take my word for it if
you type you know dot slash configure
minus minus help you get like two or
three pages of output of all the
different options you can conspectus
PESA Phi to the configure command all
the environment variables you can define
before you run the configure and these
things will control various various
attributes of how early ends up getting
built for you in your environment if you
don't want to build Erlang with ssl
support you can tell the configure
script to leave that out for example
okay so like I said one of the things
that gets generated by the configure
step is a conflict dot H file this is
standard goo new build stuff and that
config file basically just contains a
whole pile of C preprocessor directives
you know a shift if this Linux platform
then include these headers define this
macro cell and so forth not exactly
rocket science but that's quite a key
component when you're coming to try and
port Erlang to another platform because
chances are you're going to have to
either manually create one of those or
take one that's being generated and
tweak it slightly for your platform for
your target platform as I've said here
config dot H is designed to deal with
many of the platform depended bits and
pieces header file differences
differences in C runtime library so on
and so forth but you know as I say on
the Linux box few commands you can a
little bit of time you can build Ln
really easily so now we want to go and
pour la to a new platform some alien
world open
miss mainframe whatever I'll talk mostly
I guess in VMs teams doesn't matter the
approach that I described probably
largely the same and what will help you
to solve the problem on whatever
platform you like so let's look at the
scale of the problem I think this is
like a bridge over the hoover dam or
something which is probably a fairly big
problem erlang it's an appreciable
codebase right you've got roughly half a
million lines of c code so there's a lot
of C code and beam there are other other
bits of C code for other programs that
make up the entire application suite in
addition to that there's about 2.3
million lines depending on what version
of Erling you're looking at about 2.3
million lines of ln code and that's
including bits and pieces like test
suites and so forth which are all that
relevant I guess at runtime but the
bottom line is there's there's you know
it's a lot of code the main challenge
when you're looking to build Erlang on a
new platform is obviously going to be
that C code but as I'll point out and in
a few slides from now there are also
things that you potentially have to deal
with in some of the Earl and code as
well so the main components that need to
be ported from a C code perspective I've
listed here obviously beam obviously we
need the virtual machine without that
we're not going to get very far at all
there are other executables in the kit
as well there's the endpoint map of
demon is the airline compiler a script
and a few other bits and pieces you know
we pretty much need to build all of
these guys also depending on the options
you chose when you ran that configure
script for example you probably also
have to build a few shareable images so
if you're including openssl for example
support for SSL in your LAN build you're
going to find the way the Erlang library
for SSL works as it's doing calls into
into the openssl api's and so forth so
there'll be a few shareable images that
get built and as I put there in blue I
mean you know it's probably no huge
surprise to anybody but beam is going to
be the most challenging piece of code to
port because it's got all the Harry bits
and pieces in it around
it simply support and threads for the
scheduler and you know all the sort of
nonsense so it's going to be the most
challenging one good news and bad news
this is me doing my my hearing
absolutely no good with a jackhammer
breaking up concrete the good news in
this particular case was the concrete
was actually fairly easy to break up but
there's good news and bad news in the
thing about the early encode as it's
been around for a while now and it's
actually pretty darn portable C code so
as long as you've got a fairly standards
compliant c compiler and you'll see
runtime library is you know fairly
standards compliant chances are you're
going to be able to compile beam and
those other bits and pieces right it
uses standard new tools as we've seen
for doing the build well that's great if
I'm running on Linux or some or UNIX
where I can use those those tools but
what if I'm in some sort of environment
where I like openvms or a mainframe were
I just can't do any of that okay so
that's kind of bad news good news is the
code is portable bad news is some of
these alien environments don't have
stuff that you can use to build the code
and like I say there are also issues
that you need to consider in the OTP
libraries themselves typical sorts of
things that you need to think about
issues and challenges what options
should I use so I'm going to pour
telling to my my new alien world and
everything is going to be good and
ultimately will achieve world domination
what options should I use when I do that
configure step in terms of the C code
sorts of things that invariably cause
challenges threads metric
multiprocessing a few other bits and
pieces it's also interesting when you do
these ports that you sometimes find a la
have to admit I've only found one
anomalies otherwise known as bugs in the
LAN code and as I say you've also got to
watch out in the OTP code and I was
talking to Robert about this earlier
where if you actually do a group through
the OTP library code you'll find quite a
large number of OS type and os CMD calls
okay so these are situations and I've
got some on subsequent slides where
people and the OTP libraries to be some
sort of case stay
if the operating system is such-and-such
then do this command if the operating
system is such-and-such then do this
command you know that's if you're the
importing to a new platform you
potentially have to go and change that
early encode to include the appropriate
case statement for your platform so back
to our configure script just wanted to
list here some of the more important
options you know when you're actually
thinking about porting Erlang to some
exotic alien environment some of the
more important ones and why they're
important is because they either add or
subtract complexity right you can kind
of figure without really thinking about
it too hard that disabling threads is
going to equate to simplification
disabling SMP support equates to
simplification so why I quite often will
approach these problems is in the first
instance at least I'll try and keep
things as simple as possible and leave
out all that stuff that I know is going
to cause me great pain and suffering and
further liver damage so you know you
might like to do a build with disabled
three it's disabled it's in these
support things like that if you know as
well for example that like openvms
doesn't support colonel polling be
absolutely no point in in you know
running configure assuming I could run
it with with Colonel poll enabled it's
just not going to work these tend to be
the ones as I say that are most relevant
when it comes to adding or subtracting
complexity from your build and what I'll
tend to do is try and build something
simple first get it working that's a big
confidence boost big party everybody's
happy then I'll look at adding in some
of the more complex bits so just some
examples of configure commands that I've
used with those some of those projects
that i referred to earlier AIX fairly
simple i want as i say i wanted to keep
it simple so i didn't didn't enable SMP
support even left out SSL which is maybe
a little bit naughty things like that
but for the most part just kept it
fairly simple openvms well like I said
before openvms definitely doesn't
support colonel
bowling and it doesn't support the sctp
protocol and I don't even want to think
about hype that's just that's just going
to be nasty so the initial configure
though in this case because like I say
openvms doesn't know anything about a
bash script so it can't run the
configure script so i'll talk more about
put what you do there but essentially
the approach i take is to run the
configure on another server and then
take across a modified version of the
config chand and modified build
procedures and so forth SSL is actually
very easy to add it later SMP support
and and thread support is a little bit
harder to add in later for the record I
just thought just out of interest you
know like I said the airline code base
the C code and so forth has been around
for a long time it has been ported over
the years to quite some number of
unix-like platforms and so forth and as
a consequence of that if you do a search
through the code looking at various
preprocessor directives in the C code
there I found that there are a total of
about 900 plus different c preprocessor
directives in that ln c code you know
these will be things about for a
particular platform or whatever or a way
to build the code in a certain way and
so forth there's a lot of macros there's
a lot of flexibility that you can
specify on something like that conflict
at H file about how Erlang gets built
right and the reason for the picture of
the beer is that there's a lot of
choices when I go shopping so let's just
look at some examples of some of the
stuff that I'm talking about so for
example SMP in CPU topology now on most
self-respecting unix platforms for
example you can do a call to the sis
comp function to find out how many CPUs
that there are on the on the system how
many of those CPUs are active and things
like that what you find however when you
go to port to hp-ux is that you don't
have a siscon function alright well this
is this is one UNIX implement even via
miss has a sis conch function but hp-ux
it seems does not so this particular
function here its CPU info
update which which determines you know a
bit of the CPU topology how many CPUs
are on and how many are configured and
so forth you need to go and add some
code on hp-ux using assorted
preprocessor directives you need to go
and add some hp-ux specific code to
determine that information not a big
deal but you know it's it's these are
the sorts of things you have to contend
with threads I always get a little bit
confused and Erlang about how threads
work so I thought I'd steal some words
from a talk that Robert did a couple of
years ago on that I mean I think the key
thing from my perspective is you know
the asynchronous thread pool is good
because it helps us with with making I
owe more efficient and things like that
so we really want this stuff built into
our Erlang port to make it go beat up
but threads are evil nasty things
fortunately however from a portability
perspective most good operating systems
have fairly complete and decent p
threads libraries and what you tend to
find there be a couple of areas where
you may face some challenges here with
threads missing functions and thread
stack size missing functions usually
equates to this guy here to be honest
pthread sigmax pthread sigmax is
basically the thread safe equivalent of
the standard c runtime function sig proc
Mac mask I should say not max mask if
you read the main pages for these
functions it kind of almost infers that
on most platforms this guy is
thread-safe so if you don't have the P
thread function just use this one so on
VMS that's what i did and i put an
appropriate comment that I've crossing
my fingers and toes that nothing bad
happens per thread stack size so by
default operating systems set some limit
you can control it via our limit on on
Linux or UNIX or whatever but by default
there will be some limit imposed on the
stack size
default limit imposed on the stack size
or default value on the stack size for
each thread so when I was feeling quite
happy with myself that I'd you know
managed to compile and Link her laying
on openvms with supposedly with this MP
support and everything was great and I
was feeling very pleased it wouldn't
even run I fired up beam and it
complained that it was out of stack
space so I thought well that's kind of
interesting so I did a little bit of
digging and in the end I wrote a little
piece of code to tell me well so what is
the default sec sighs here and on VMS it
was telling me that you know it was
basically allocating 40k about 40k of
memory for the stack size was being
allocated I thought well that's
interesting what happens if I run that
on Windows under cygwin what happens if
i run it on ubuntu who much larger
numbers so the conclusion was that by
default on openvms the amount of space
that stack space that's being allowed
for each thread is way too small of
course the guys that wrote early and
pretty smart guys and when I actually
then went and had looked through the
code I discovered that they had provided
a way to deal with this and all I needed
to do was modify the function that I've
highlighted up there and the e3d module
I should point out actually that all
this early and cut the C code that you
know with the knurling is very nicely
modularized and it's actually quite easy
to find stuff that that you might need
to change but as I say that the
developers obviously encountered this
problem before maybe they are running
you know ported air link to some device
that was memory constrained or whatever
and it provided facilities for you via
macro which I've specified there to
actually say what what stack size should
be used when you spin up a thread so
after I discovered that and put it
appropriate entry in conflict dot H and
rebuilt everything was happy mostly
rather ironically it turned out that
that 40 k value wasn't too far off the
mark and I could quite happily get by
with just 64 K polling well the
interesting thing here is that you know
if you're using developing any sort of
network application using an erlang or
if using rabbitmq react or things like
that which i commonly do use
sockets are quite often toggled from
blocking to non blocking and there are
two ways you can do that either using
the FC well they're actually more than
two ways but two fairly common ways the
FCN TLC runtime function and ioctl and
you need to be a little bit careful
because on some platforms the F cntl
function does absolutely nothing it will
not change the behavior of the socket at
all so you need to be aware of what your
platform does and doesn't do in terms of
whether one or other of these functions
works and you need to make sure you
probably have to include more
preprocessor directives to make sure
that these macros set blocking and
setting on blocking get defined
appropriately to make sure that you get
the expected behavior on your sockets
with in erlang polling can occur on
socket pipes whatever you know various
types of Io descriptor on openvms
functions like select and pole that you
use for polling sockets and so forth
only work on sockets so as a consequence
of that porting Erlang to open VMS i
basically had to implement my own
versions of functions like select and
pole to deal with the polling of those
other types of descriptor and that's far
from ideal because that basically means
that brett has to sit down and write
some grubby hack that probably isn't
going to perform well because he's
grumpy that he had to do it in the first
place and it will be some really rough
and ready implementation but now since I
work for the company that has total
control over the openvms operating
system I'm going to see about getting
that behavior changed and then we can
throw away my grubby hack okay now like
I said earlier just dealing with the C
code itself which is certainly the big
bigger part of the problem it's not the
only thing you have to worry about you
also have to think about the Erlang OTP
library code and in particular OS type
and os command calls in the library code
luckily they're easy to find and
generally speaking they're pretty darn
easy to fix so case in point here so
what's the module we're looking at here
okay so
initializing memory monitoring as you
can see is a case statement we're doing
an OS type call in the case statement
you know if it's unit to Darwin then
we're going to return false and blah
blah blah so very easy to add in an
entry for unix comer hp-ux for example
not problem i just made a note that in
that particular file there are a few
more instances of this sort of thing but
you know you're porting Erling to a new
operating system be aware that you may
need to do this sort of stuff so for
example I don't think I realized this at
first and I was I was trying to run
react and it was mostly working and then
it was falling over in a screaming heap
when it tried to kick out some of his
monitoring stuff and that was kind of
one of those you know Homer Simpson girl
moments and I suddenly realized exactly
what the problem was another example of
this sort of thing in this case disk
disk space monitoring you know this is
kind of quite interesting that
illustrates here as well again easy to
go and put an entry in for hp-ux it's
not a problem but what's kind of
intriguing here is that you know you
suddenly have this realization that even
things like the output of a DF command
or the syntax of a DF command or even
you know the path you use for the DF
command can vary from one unix / linux
implementation to another okay and you
know one thought that occurred to me for
some of these more common things like in
you know disk monitoring or memory
monitoring maybe it would actually be
easier to build something into early in
itself that you could just call instead
of having something that you know really
is a little bit clergy also just note
there that on Windows this is actually
done using a port program as opposed to
running a command and another point to
note there also on on unix starting up a
subprocess to do something like this is
generally a silly lightweight operation
on openvms creating a subprocess is
actually very time-consuming so as part
of my openvms port i'm always looking at
these sorts of things saying do I really
want to do this because it's going to
actually take time
operating system flavor so you noticed
on those two or three previous slides we
are in the case statement I'd added UNIX
hp-ux the way in which Erlang figures
out at runtime what the platform is
there's a little function called OS
flavor lurking down and the bowels of
the code somewhere in a file name called
sissy that calls the sea runtime library
you name function and converts that to
lowercase or something or other like
that and that's basically that hp-ux
thing but there's a catch here and I
lied on some of those previous slides on
hp-ux you name returns HP hyphen u X now
if you recall from that Erlang OTP code
it's expecting it's expecting the flavor
to be represented as an atom and atoms
cannot contain hyphens yes you can go do
me see things like stick quotes around
them but that would have resulted in
ugly code so in my HP you export I
basically did something really a little
bit dirty which is what's highlighted
there I said basically if I know I'm on
hp-ux and i'm just going to return the
flavor as hp-ux you know why even bother
doing the day and call I know what I'm
running on because that's what I was
compiled on so that was that was a
little quirk that actually took a wee
while to figure out you know what's the
deal this this hyphen thingy seems to be
causing grief all over the show like I
said before porting the code porting any
application sometimes uncovers bugs that
had not been noticed previously in this
particular case it's an incredibly minor
one but it's kind of another one of
those little quirks about how things
have mutated and changed with the sea
runtime libraries over the years on most
unix platforms you will have either map
anonymous defined or map a non defined
and on some platforms you'll have both
but on some platforms you will only have
one these things are all to do with
memory mapped files and things like that
so what this code is doing is figuring
out basically how it's going to do
memory mapping of files and so forth so
basically this is a bug when I was
poured into hp-ux
the code this code would not compile
because in hp-ux the map underscore a
non macro is not defined and as you
could see that actually been
inconsistent in the code so you know
totally trivial defects so bouncing
around a little bit and back to openvms
feeling really really happy with myself
went out and bought a dozen beers to
celebrate flings appeared to be working
really really well on openvms SMP
support you know all call good stuff but
what I was noticing was when I went to
fire up the Erlang shell it seemed to
take some disproportionately long time
to actually you know give me the little
ill prompt well that's interesting don't
really think too much of it typed a few
commands and it seemed to do sensible
stuff so I was happy and then just just
for no particular reason I don't know
why I went and monitor the CPU ooh you
know there's one process running on this
machine and it's chewing up a hundred
percent of one cpu well that can't
possibly be good you know I know there
are little things spinning around and
early and doing stuff but seriously a
hundred percent CPU I don't think so so
trying to debug this stuff with some
sort of symbolic debugger is a bit of a
pain but thankfully on VMS what i could
do was profile the code and what that
told me was that i was spending like 99
plus percent of my time sitting in that
function near it's this main thread well
that's interesting and i had a look at
that function it's fairly short doesn't
many do much it's quite a tight loop
that just kind of starts up a pile of
other stuff and then it goes into a loop
twiddles its thumbs waiting for some
sort of interrupt or whatever to be
received the way at which it trouble
twiddles its thumbs is it basically does
a select call with zero or null for all
arguments so people are familiar with c
or c runtime library select call like
that essentially as a way of sleeping in
an interrupt abour fashion okay problem
i discovered was that that particular
select call an openvms just returns
immediately it doesn't like having the
last argument in particular it doesn't
like having that null which on unix
basically means sleep forever unless you
are interrupted on VMS that says i don't
like the look of this and returns
immediately and the net result was my
process was just spinning around
around and around with in that loop so
again easy to fix but you know there are
just these subtle little platform
differences that that come out and bite
you few other things not all operating
systems support a unix-like fork
function thankfully fork is not terribly
important within the Erlang code and in
those situations where fork is used it's
kind of optional and you can compile to
you servi fork function which does sort
of a little bit less you can compile to
use that instead file system differences
can actually be the real nasty big
problem to deal with to be honest so if
you actually have a look at my VMS port
most of the work I've done would have
been in the file driver as opposed to
anywhere else not all file systems
created equal if you you know I'm
talking here about what what characters
are actually allowed in filenames how
long can file names potentially be what
de Paz separators look like is the file
system hierarchical or not all of these
sorts of things this can be a real
nightmare area to have to deal with the
saving grace for me with regards to open
VMS is that modern versions of openvms
allow you in the sea runtime library to
specify path names and things using a
unix-like syntax if I couldn't do that I
would still be working on the port today
most likely it would be hellishly
complicated and just thinking of that if
I think about it with Windows I think
this there's there's some code and there
to deal with these things on Windows but
as I recall linux on windows is built
primarily and under cygwin and that
helps you get around a lot of these
sorts of issues as well hype so I was
interesting hearing the talk this
morning and I think it was Joe saying
that just-in-time compiler thrilling
isn't too far away so hype i guess was
kind of the forerunner of that and there
was a lot of work done at Upsala
university over the years since the late
90s on hype so basically allowing you to
compile on the fly at runtime compiled
your your ln code and to into native
instructions and so forth porting that
is non-trivial
if you're porting to a platform where
it's one of the supported processor
types you might be lucky otherwise
you're probably going to have to learn
some assembly code and get very
frustrated good thing is you don't need
hope it's not all that widely used it'll
be interesting to see how the
just-in-time compiler goes down I'll be
quite interested to see that there's
some good papers on this stuff by the
way as well the end links don't panic
yeah so this slide basically illustrates
the general approach that I take if I'm
building earlier in an alien environment
and by an alien environment I mean an
environment that's not necessarily
particularly POSIX like in terms of bash
shell GCC auto can't make all of that
sort of nonsense assuming I haven't got
any of those things this is basically
the approach I will take ok so what I
will normally do is I will build Erlang
on another platform that is supported it
12 linux tends to be my favorite but you
know just pick whatever works for you
doesn't really matter carefully examine
the conflict h make any changes to it
that may be appropriate to the platform
i'm trying to port to you know maybe the
platform i'm porting to doesn't have a
specific header file maybe to see
runtime library doesn't support some
function or another so make those
changes to the conflict at H file when
you do the build capture a log of all
the output all all the complier commands
that are executed and so forth and you
can incremental e convert that back into
something that will actually compile the
code on your target platform and then
incremental e go through resolving
compiler errors linkers problem linker
problems so on and so forth that would
be another possibility for sure if you
if you had that opportunity that would
work yeah this may sound a little bit
tedious but it actually doesn't end up
being that bad you know and also sort of
once you've done it once you've got all
the all the machinery there and it's
it's not so bad second time around but
yeah this there's no reason why you
couldn't do that and you know of course
the the the compiler line code those
bean files are of course portable right
there's not no issue
you look cross your fingers test and
rework so just just very very quickly
because we've run out of time but but
really you know I do a lot of work with
things like RabbitMQ and react and and a
few others porting those guys to be
honest in some ways you've got to deal
with the same issues particularly say
something like react where it's not 100
seen early okay so if you look at
something like rabbit to start with
rabbit is one hundred percent Erlang but
it suffers from those those those always
type OS command situations where within
the rabbit early encode the guys are
going off and running operating system
commands so we've got earlene working
happily on openvms we know what i want
run rabbit we potentially need to go and
do something like i've highlighted and
read here for some of this stuff again
as i say it would be nicer feeling
actually provided the functions that
were just you know callable and do that
another example in in RabbitMQ in this
particular case i'm executing 20 s
commands which is just to prove a point
like i mentioned before creating sub
processes on openvms is not very
efficient so this is you know not going
to be a particularly perform an
operation by any stretch of the
imagination react is certainly not a
hundred percent Erlang you've got the
spider monkey javascript engine which up
until recently was actually quite an
easy piece of c code to port from one
platform to another now they seem to
have gone and changed all those C's dot
CPP s which you know terrifies the heck
out of me they've also got the level DV
in bit cast back ends but casket is is
quite portable there are some quirky but
senere but generally it's not too bad
leveldb it's it's you know my archenemy
it's an evil pile of highly optimized
C++ code with just about every
optimization you can think of atomic
operations inline assembly code platform
specific use of built-in functions and
so on and so forth if there's a way that
code can be optimized it's pretty much
being done
porting that can be really quite
frustrating there's not too much use of
OS type and os command and react but
again you know something to watch out
for so just very very quickly some
results so my main focus has been around
the openvms operating system and
generally speaking I'm pretty happy with
what we can do there you know we can run
up some pretty major apps that
stabilities reasonable performance is
reasonable cut yours forever 10-q react
I've had most of CouchDB and things like
that working as well as I mentioned
earlier you know there are some some
clutches that I've had to do around
functions like poll and select and also
the current implementation of the tcp/ip
driver on openvms isn't as crash hot as
it could be a little bit slow at times
so there's some work to do not just at
the Erlang level but also the operating
system level to make life better so if
you're familiar with reberty and queue
for example you know the sorts of
numbers I'm talking about here 19,000
20,000 messages per second on a
reasonably capable piece of hardware I
mean I'm probably going to be able to
pull at least twice that on my on my
laptop for example okay so performance
yeah average it's I'm happy I'm happy
with where things are at could be better
no problems with clustering this stuff
just worked out of the box in Asia
clustering all worked out of the box no
problem creating on openvms a multi-node
RabbitMQ cluster react cluster whatever
actually the biggest problem was you
know that there are shell scripts in
react or whatever to control
administering the cluster was just
converting them into something that I
could use on VMI's summary conclusions
you've got a big pile of standard C code
that you need to port together laying
across to some alien world that code is
well written it's nice and portable code
if you've got a half-decent c compiler
and c runtime library you're not going
to have too much a problem if you've got
ganute tools for doing the build then
your success rate or your chances of
success are going to be very very high
indeed
don't forget that you might have to make
changes in the Erlang OTP code as well
as in the C code hype try to avoid it
and as I say many of the same
considerations deporting Erlang itself
pertain to porting large and complex
early applications particularly those
that have you know bits and pieces in C
code and so forth future plans from my
perspective will obviously tidy up all
the rough edges around the work that
I've done to date one of my key roles
within vme Software Inc is sorting out
our open source strategy and you know
I'm very very keen to see Erlang as
being a significant part of that open
source strategy and I think that Erlang
an openvms are kind of a natural match
in some ways when you look around the
sort of you know similar to design
principles around fault tolerance
reliability availability and so forth
already and whoa questions
on
okay Sophie ms runs on 3 architecture
types of Acts alpha and itanium okay so
vax you won't find terribly much vax
around anymore and I to be honest that
the c compiler would not do it you would
it would not work alpha and itanium yes
I've done so the current version of
openvms is 8.4 which is available on
both itanium and alpha and the compilers
are comparable so you know basically if
the bill works on one it's a fair bit
that it's going to work on the other and
it does okay so i have run Erlang on
both alpha and itanium but not vax I
don't even want to think about that yes
sir
yeah yep so it's a bit of a mixed bag
there so in some cases that matters in
other cases it doesn't but like I said
before that the newer versions of VMs
when you initialize the file system you
have a choice about essentially what the
file system supports in terms of file
naming conventions how long file names
can be all of the sort of stuff mixed
case whatever but more importantly than
that is that the newer versions of the
openvms c runtime library are quite
happy to accept unix style file names
and there are also a number of settings
that you can specify on openvms the
control behavior like whether there will
only be one version of that file and
things like that okay so we can't
control it to that level I mean this you
know what I've talked about here is kind
of there's a lot of detail in there that
I've skimmed through yeah with the
native compiler so at the moment there
is no GCC on openvms there's like an old
version that runs on alpha but you could
that would be an interesting experiment
it would be my guess would be that the
native compiler is probably going to be
better I am I am for sure yeah
interestingly there the the best code
you get the best code you get on VMS is
actually out of the c++ compiler because
the back in for that on Itanium is from
intel and i'm not even allowed to look
at it basically but but that will do the
best possible optimization for itanium
yeah yeah
not off the top of my head no and you
might you might be better off checking
with with one of the Erickson guys for
that I mean it's been done that there's
probably a whole lot of stuff out there
and in the field that you know maybe
someone tweeted about or you know just
never told anyone about but I talked to
the Erickson guys yeah
okay that just depends on how lazy I'm
feeling to be honest Erlang itself has a
very comprehensive test suite so that's
one approach similarly you know most
good open source packages so if I look
at something like rabbit or if i look at
react they also have test suites as well
so you know you can you can give them a
spin and see how you shape up I mean I I
haven't achieved perfection by any
stretch of the imagination but yet
there's plenty of stuff you can use for
testing it anymore yeah that is lake
pukaki in New Zealand so I'm from New
Zealand so it's like what four hours
drive from home and that's Mount Cook in
the background yeah cool alrighty thank
you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>