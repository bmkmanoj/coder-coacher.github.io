<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Embedded - Concurrent Blinkenlights and More!: Omer Kilic | Coder Coacher - Coaching Coders</title><meta content="Erlang Embedded - Concurrent Blinkenlights and More!: Omer Kilic - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Embedded - Concurrent Blinkenlights and More!: Omer Kilic</b></h2><h5 class="post__date">2012-06-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/RwIDJGYobRY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you hello everyone my name is Omer
I'm really excited to be here my first
EUC so as wolf mentioned I am part of a
knowledge transfer partnership between
Erlang solutions and university of kent
today I'm going to talk a bit about her
lying embedded you might have seen our
videos already featuring blinking lights
but today I'm going to talk a bit more
about well slightly more important stuff
than blinking lights so we're going to
have a look at what the KTP project is
what are the objectives within set
within the project challenges in modern
embedded systems how we can tackle them
using air lying of course current state
of our lying in the embedded domain what
people are doing with it and our plans
for lying embedded at ESL and finally
we'll have some time for questions so
the knowledge transfer partnership you
might have seen this at all slides at
the EUC last year so the person he
mentioned is me I'm the KTP guy at the
ESL it's a government-funded scheme
where a company and the university or an
educational institute is paired up so
that there's a flow of state knowledge
from you know both entities and sorry
yeah so and the main objective is of the
KTP is to look at how we can get Erlang
accepted as one of the languages are
considered or used in the embedded
projects so well it clearly states the
aim it over there is to bring the
benefits of concurrent systems
development using your line to the field
of embedded systems through
investigation analysis software
development and evaluation and that's
exactly what I'm doing so let's have a
look at the challenges and better
systems I'm pretty sure you're all aware
of this but just a recap of what we're
dealing with so we have larger and
ridiculously complex systems course or
these days you get many many cores and
with many many cores and multi-core you
have the pleasure of well dealing with
the horrible standard development tools
you can't really try to you know watch
your variables over jtag if you have 16
course that's not fun so people quite
use it quite often resort to using some
sort of framework on top of the metal
bare metal to be able to utilize the
full potential of the course available
within the system so gone are the days
where you can simply do some register
twiddling to get stuff done so we also
have increasingly higher degrees of
heterogeneity we have hardware
acceleration in the form of GPUs
coprocessors you can now get mobile
phones with four cores plus a GPU bolted
on it it's quite fascinating really we
also have different kinds of
interconnects the way these communicate
these different processes communicate
and also the memory of hierarchies are
different as well we also have the
limitation that these devices need to
run on batteries they have to be mobile
sometimes and it's nice being able to
run you know 16 cores at the same time
but how much power is that going to
consume and they also need to be always
connected which requires the tools
you're using to be aware of the network
and all the communication primitives
that are provided to you in the system
and we also have this wonderful thing
called the Internet of Things I'm sure
you've heard of this as well and
embedded systems do play a key part in
this there's a company who is planting
census on cattle and monitoring them so
internet or cows and here we may not
necessarily run a line on a cow but we
can use our line too well collect data
from
cow and process it so these next two
slides are mainly for the benefit of the
people who are watching at home it seems
almost criminal to talk about a line in
the room of people invented online so
our line is declarative therefore you
can create nicely structured very
concise and readable programs with it it
almost I'm from a hardware background so
it almost reminds me of hardware
description languages somewhat it does
give you concurrency and parallelism on
multi-core embedded processes you quite
often run a line on Linux with SMP
support so you can utilize the SMP
features or the SMP support of our lying
around time as well so you can take full
advantage of the multi-course available
in your embedded system its robust we've
heard some strategies on dealing with a
recovery and stuff in the previous talk
and it's also a portable Ennis
distributed you can run it on a variety
of different platforms so you can pretty
much run well not the same distribution
of course but you can run the same
version of Erlang on your server and on
your mobile application as well so it's
much easier to manage than having to
maintain different versions of your
tools and in an embedded system required
to often have to interface external
devices to your system and erlang
provides nifs and ports or different
port futures to be able to do that you
can quite easily interface senses or
actuators into your system I will talk a
bit more about it when I get to the
buggy it has soft real-time features it
unfortunately on the standard
distribution does not have hard
real-time but I'll get to that in a
minute as well it had a zapper process
garbage collection and it's it's
generally fast i mean the response time
isn't that bad even
without fine-tuning it so these were the
advantages of our line oh of course I
and there's support for hot code loading
which gives you the luxury of providing
or doing dynamic reconfiguration without
having to restart your system or stop
the system and then load the new code in
it so there are some limitations to
relying as well unfortunately the first
one being that in the standard Erlang
distribution running on a standard Linux
distribution you don't have hard
real-time I know there are people
working on it and I think there will be
a lightning talk in the evening about it
as well looking forward to hearing about
it and you also need a number like well
you need an operating system like Linux
to run it so it does not grown on bare
metal so you have some memory
requirements and space requirements to
fulfill just so that you can get our
line up and running and also we don't
have they lack of well we don't have a
unified hardware or a peripheral
abstraction library this this is I find
this a bit strange because Erlang was
designed for embedded applications
embedded systems yet the message seems
to have got gotten lost along the way
it's a great tool for building massively
scalable systems now but I think it's
time we look into the origins of Erlang
as in how can we get back to running
you're lying on these plentiful and
cheap hardware that is available for us
so with all those features and
limitations I think it's fair to say
that fer line can be the orchestrator of
things or the maestro of the system and
this is generally what have been done
than what people have been doing in the
embedded space so how do we actually run
a line in embedded devices you can
simply cross compile it or if you have a
tool chain up and running on your little
bored you can just compile it that you
have to this the special disable certain
features sorry but
generally everything compiles fine and
you can also try running it on bare
metal I think this is uncharted
territories and yeah if you're
interested in this let's find me that's
how that said let's have a chat after
this we we have companies utilizing our
lying in their embedded products already
we're going to hear more about four laps
later today I think and we have travel
ping utilizing your line in the sort of
offerings we have community interest as
well so we have frankenmuth who has
created a build route configuration for
beaglebone which lets you run a line
quite easily so you had some tweets I
scoured of Twitter we have make plus
running while using your line to
communicate with it is Lego Mindstorms
we also have a quite recent addition of
an open wrt recipe of the airline
packages so well embedded hardware today
is cheap and plentiful and for a very
small amount of money you can get a very
powerful processing board so we have on
this picture we have gumstix bigger
bones Raspberry Pi some Arduino is
thrown in for good measure and one of
these gets a special mention in these
slides and that's the Raspberry Pi so
you must have heard this platform that
has taken the world by storm it's
essentially a credit card sized computer
with a 700 megahertz processor net and
256 megabytes of RAM gives the ethernet
USB HDMI and all that for thirty five
dollars it's quite remarkable I mean the
entry barrier to start playing with
embedded stuff is pretty much shattered
you can easily justify spending thirty
five dollars on a small computer an
interesting thing about the raspberry pi
is the actual foundation the raspberry
pi foundation is a charity and their
mission statement is to promote the
study of computer science
and this is very exciting because if we
can create fun applications or fun
little demos we can get young people
interested in Erlang and you might
become future airline hackers may be so
for that reason I have created this tiny
robot platform called the old buggy it's
in its current configuration it's just a
line follower robot I will be adding
more stuff on it at later stages but I
created this because I wanted to
demonstrate how nicely you can abstract
away hardware peripherals or components
within your system nicely into little
Erlang modules so the Earl buggy has
motors and sensors and the way I
implemented the control logic is that I
have a motor controller that
communicates with those motors as well
they are separate processes and then i
also have an if that talks to the pulse
width modulation controller in hardware
that sets the speed of the motor and
also i have senses that send their
values to the brain constantly and the
brain essentially makes a decision
whether to move left or right and it
also adjust speed so you can see that
you can these are the peripherals of the
system of the robot we have sensors
actuators motors and you can very nicely
map those into Erlang processes so this
is a nice way of well using processes as
compositional units within your system
is an exciting thing I think so how do
we control our motor quite simply set by
sending messages to it this could be any
peripheral I mean motor is just a very
simple example that's why I've chosen
this but yeah I mean this discs
demonstrates how we can abstract things
into their own little modules so ok this
was just an example but can we actually
provide a generic abstraction to
that's weak that can be applied or that
can be mapped to other embedded
peripherals well we can follow a layered
model where we will have a component API
that will be specific to a component in
the previous case it was a motor for
instance and we can have a lot lower
layer peripheral API that maps to
hardware resources so again it was just
gpio pins general-purpose i/o pins and
these these could be and also underneath
that we have a platform specific or
hardware-specific peripheral
implementation so the blue bits the
component API in the peripheral API can
be universal in other words we can use
those in different boards without having
to change them and if we follow this
layered architecture and the yellow bits
the actual implementation can be
platform specific so if we look at an
example let's say we have a nice I squid
sea temperature sensor we can quite
simply have a little sensor API this is
a temperature sensor so we'll probably
have get temperature reading calibrate a
few functions like that that can
communicate with the I squared Z bus
driver again these are generic
components and you can choose to use the
ice cream module in the Sisyphus or if
you're on bsd you can use this control
or you can just memory map the registers
and do some crazy stuff with them so
regardless of the underlying primitive
layer you can choose to have the same
API for your peripherals and your
components we're going to be exploring
this in the future and I've already
published some code for the Raspberry Pi
and I'll do a major revamp of those and
push them to get up so you can have a
play with it on the air pi as well so
what are at the SL we're really excited
about embedded stuff and we've said a
few goals and one of them or the first
and foremost is to establish a user
community following
sting successful models I'll talk a bit
more about it in the next slide but we'd
like to bring everyone together who uses
embedded Erlang because at the moment
everyone's doing sort of this disjointed
efforts which sometimes overlap
massively so if we can bring everyone
together I think you know you can see
some great results out of that coming
out of that we also will look at how we
can design a generic framework that will
allow allow Erlang programmers to
interface the platform that they're
using to a range of embedded peripherals
or devices and will also develop tools
and libraries that will make life easier
for people who are just getting started
with embedded development or season the
medic developers who are just getting
started with our line so to help those
okay I'll talk about the community
approach first have you heard of a
project called Arduino it's it's
extremely popular I think it could be
called as the poster child for the open
hardware movement Arduino seriously is a
combination of three things so you have
this cheap hardware platform
self-contained you don't need external
programmers for it just plug a printer
cable to it USB cable to it and you have
the programmer and your actual
microcontroller ready there's a nice IDE
with all the software libraries and
programming tools and everything
integrated and there was also a very
useful community that is willing to
answer any question that you might have
so I mean of course we can't map roline
embedded directly onto this but I think
this is a great model and we're nearly
there I mean we have the hardware
platforms you can have a Raspberry Pi
for thirty-five dollars or if you don't
want to wait you can get a bigger bone
for well not much more money than that
slightly more expensive we are trying to
establish a community of our line
embedded hackers together so that we can
start exploring things together and also
we're going to work on creating a nice
and simple set of software libraries
that will make life easier for the early
adopters and then fella preserve that
also we've started publishing these of
little video tutorials well I'll be
doing more of that when I get back to
London but the idea here is to just pick
a very simple example so in the second
one for instance we just blinked a few
LEDs together demonstrating concurrency
on the third one we decided to see how
many processes we could spawn on the
Raspberry Pi and the answer is 136,000
per line processes so episode 4 might be
Earl buggy or episode 5 might be driving
an LCD screen so if you have any ideas
about these please let us know we will
keep publishing these just to show that
Erlang is actually a very nice tool to
play with embedded we also have a lying
in bed calm this is our temporary
website at the moment we're waiting for
the larger community site to go online I
don't think I can talk much about it but
once it goes live the Erlang embedded
community will be moving there oops and
along the way we have some great
projects and great tools that we are
using so we're truly standing on the
shoulders of giants so we have
openembedded buildroot dr. Langstrom in
the software side of things these are
sort of linux distribution frameworks
perhaps that lets you create really sort
of fine-tuned little images for your
systems so I mean you can for instance
on the PI you can just download a debian
image or a fedora image where you can
choose to really fine-tune what you
include into your image and ready to
reduce the size down and perhaps other
tweaks as well and on the hardware front
we have beagle boards beagle bones
Raspberry Pi gumstix and many other
arm-based devices that that is available
for us
so feature explorations this is quite
exciting because this is a new device
from xilinx that they announced a couple
months ago as I lynx is an FPGA company
so their business is well creating field
programmable gate arrays but in this
processor processing platform or the
extensible processing problem they call
it the arm core the there's a dual core
arm processor in there and that actually
is the primary processing device in
there so what I mean by that is when the
device boot I think if I remember
correctly the arm core takes control and
then uses the FPGA logic as a
coprocessor in the past this was the
opposite so in vertex series of you had
PowerPC hard IP blocks in there or hard
core processor in there but you had to
utilize logic resources or a small soft
core processor to you to initialize it
and so on the point is we have a dual
core arm processor on it that can run
our line quite easily because it runs
linux and we have direct access to
programmable logic blocks in there or
high-speed train series in there so what
this means is we can actually control
hardware true truly custom defined
hardware from our lying in this
computing fabric these devices are not
out yet or unless you're very big
companies I links doesn't want to talk
to you so once we can get our hands on a
development board will start looking
into how we can utilize it or is it
feasible to utilize it so please get
involved if you'd like to learn more
about allowing embedded or if you're
already using our line indium in your
embedded projects and in conclusion I
think Erlang embedded is a very exciting
proposal we already have done some
exploratory work in terms of getting
it's running on or interacting with true
it peripherals and components will be
doing more of that and we are really
interested in hearing your comments and
suggestions so thank you very much for
listening
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>