<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Python &amp; Erlang -  a match made in heaven by Johan Sommerfeld/s2hc | Coder Coacher - Coaching Coders</title><meta content="Python &amp; Erlang -  a match made in heaven by Johan Sommerfeld/s2hc - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Python &amp; Erlang -  a match made in heaven by Johan Sommerfeld/s2hc</b></h2><h5 class="post__date">2017-09-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/s1zB1YFobLI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">Amy yep perfect so my name is Jones on
the field today I'll be talking about
Python in Erlang and how we can combine
those so quiz question how many people
know Erlang in here and how many people
do know Python nice and how many people
use Python and Erlang yeah a few and
come the last question concurrently yeah
awesome
I'm special so why Python I started
using Python in 2008 I worked as with
operation as a sysadmin and I needed I
needed automation I like automation and
when my script catalog filled with more
than 150 shell scripts it was time for
change and when that was done and I was
supposed to lead the development of our
automation all to deploy to because in
2008 we didn't have ansible and puppets
and chefs and things like that and with
that we used django which doesn't have
on the homepage now but then it had like
the perfect slogan for perfect
perfectionist with deadlines I love that
one
so python is quite generic it allows you
to develop in both object and origin
oriented way or you can do it functional
although I think it's quite biased
towards object oriented we have the pep
20 the sin of Python the ones that know
Python most likely knows this one and
although it's the sin of Python I
generally think it's it holds true to
quite a lot of development beautiful is
better than ugly explicitly there's an
implicit simple as wedding complex it's
after sir and this is actually not all
of them you have some more but
this I think is the basis for a good
design so even even though I had not
always in Python programming
I generally adhere to the Sun of Python
the community of Python is is really big
and it's been around for quite some time
not as long as our line but it has seen
an significant amount of adoption we
have Google Facebook Instagram Dropbox
if you look on pipe peepee the like de
facto standard for package installation
you have over a hundred and seventeen
thousand packages but that wasn't enough
so how come I I ended up with Erlang and
that wasn't like in the eighties when it
was developed it was just a few years
ago and so we were a Python shop and we
were developing this huge system and
Python really doesn't do that good in
its own so you have cool libraries built
on top of that one of the most
significant ones is celery which by
default wants to use RabbitMQ as the
messaging queue to generate or fake
distribution within Python you do this
by some decorators and some other
functions that you build on top on your
Python code so it gets distributed it
works quite good but when you start
poking in it and you want to start
fiddle really really much with the
queuing systems I get with bit dense and
then we started to work with react and
with that you start going into Erlang
and when you start looking at that you
could you can see that it there's a lot
of things that are really similar
between the two languages they adhere to
- like concepts that are quite alike
even though the languages are really
really different and also I needed to
build a custom FTP server for an IOT
company and that's very very much better
in Erlang rather than doing it in Python
I assure you I did both - just so back
in the eighties
when the good people at every song
needed something else they had that they
had these challenges they wanted actions
to be performed within reasonable time
system that could be distributed over
several computers systems that you
should be always on when they needed
continuous delivery maintenance during
our time that sort of thing they wanted
to handle the fact that hardware and
software will fail and that system will
become extremely large and complex and I
think this is quite impressive because
this was done because it wasn't a
language like it so they built airline
and this was in the eighties and quite a
lot of these are hype words today that
we're trying to solve in other languages
which was done in eighties so that's a
penny for thought something like that so
what came out of our when our line came
so we have this magic that the buzz word
is probably you hear most when you're
early in the nine nines and I think was
a base system if I'm not mistaken that
has nine nine 99.99% of availability
over several years and that's like
milliseconds of our downtime over a big
period of time it's really productive
once you get used to the syntax it
really helps you build distributed
systems and with some of the things that
you have within our line such as nan and
immutability and things like that and
you have tail-recursive building and
once you get used to it it really really
helps you build put a system really
really fast or prototypes really really
fast so some of the limitations of our
line most of them actually I think you
are quite subjective and after it
debates so generates soft real-time so
you can end up with tight loops that
doesn't perform as well as other
languages this was a limitation that was
known already when the design was made
that's why
is so easy to implement with other
languages it's really a huge amount of
allowance to fork out into other parts
are the code code bases or if you want
you can build C functions within Erlang
and with the new release I think it was
20 you have dirty schedulers as well so
this is even more robust today you have
quite a lot of boilerplate code when
you're doing gen servers and things like
that and although I think that's hands
up for quite readable code so honestly I
don't think that's a bad thing then we
have security with our line generally
being a distributed system the
communication in between is quite open
and you don't have and that many levels
of security but that only then again if
you have too much security and something
fails you'd only have a hard time going
in and fixing it so I would argue that
traceability would be preferable rather
than limiting things in distribution
later but some undercover enterprises
that uses our line it's Erik song of
course I made it
Khurana which were today bet365 is quite
a big thing what's up you have that
point before and if you look at the
community you have 4900 packages on X
which is like the up-and-coming package
manager of Erlang which is a bit short
of 170,000 I think so we've got a bit
some way to go
so we were a Python shop and started
using our line quite soon eyes I started
seeing quite a lot of similarities there
was no really there wasn't that hard
jumping in between Python and our line
although I have a lot of dots at the end
of my Python code that shouldn't be
there now but yeah development speed is
quite rapid you can get things up and
running quite fast both with Python and
our line don't do premature optimization
it's a bit with the soft real-time thing
you you you respect the concepts more
than trying to build something really
really really fast and being him because
generally it's not going to be where you
think the problem is that's not where
it's gonna be so tight loops generally
ends up somewhere else than you thought
and both Erlang and Python gives you
tremendous possibility to trace and
profile your code and then you can go in
and fix the problem where it actually is
when it when it shows up both Erlang and
Python have tremendous interactive
shells to work with for example a Python
which is the one I'm using when
developing Python has me so I also don't
know how to debug Python and I'm um I'm
up into a decade of Python programming
now and that's generally because it's so
transparent so when you're developing
you came you can just step through and
you can look it hides nothing so you can
always get a get an update and you can
look at the state to add it and you can
try to figure out what's what you've
been doing and doing wrong and when
you're done developing and you deploy to
production that sounds though because
then then it's harder to maintain so you
I generally have tons of logging that I
can tune for when I have problems in
production and that's where our line the
Erlang shall really really shines
because you develop and you have the
Erling shell and you look at it and you
have all this information you look at
the state you look at things you make
calls so you can get you can look at the
the queue lengths and things like that
and then when you put it in production
it's still there since it's a
synchronous you can jump in with our
remote shell and you actually
in the production system you can look
and you can trace actual flow of the
running system without really needing to
restart or anything and and for me that
was like yeah I got goose bumps when I
understand what I would be able to do
with that as an ops guy and and with dev
ops being so so in the hype right now
like every other tech thing you get on
LinkedIn so yeah dev ops awesome and our
line is really really really good for
that sense if you're developing
something you know the code right and
being able to have the same
instrumentation that you have locally in
the production system is is really
really helpful for finding things when
it's burning and it will burn interest
us so enter pure line so as I said I'm
actually using in a few projects Python
and our line coherently there exists in
Sterling is so good at interacting with
other one it's actually not that hard to
get something up and running and
actually using Python underlying at the
same time but it was some boilerplate
code and I didn't like the ones the
version I wrote was way too biased
towards the problem the specific problem
I was solving at a time and that was
that was when I got in touch with erlang
solutions so I pitched my idea and
fortunately I said something right
because they liked it so they helped
build a first version of pure line which
is a name pending because we we sat down
and we talked about it we helped Peter
Lang and he switched that's really
really funny with the small range thing
that never dies you can put it out
things like that then we had a lot of
other than without yeah I don't know it
already exists so that was a bit of a
bummer although it is that's a bit a bit
stale so we have the working name pure
line although that is a bit misleading
because what we are trying to solve with
pure line isn't a new language we don't
want to take any shortcuts we want you
to merge the community
we want to be able to use our language
science and we want to use Python which
shines and generally that union becomes
a really really big set so if you have
Erlang Empire then you can do really
really cool stuff but we don't want to
take shortcuts so we don't want to write
Erlang in Python syntax and we don't
write Python within Erlang syntax
generally I think the people made that
made Python and Erlang are really really
smart people because they're both
tremendous languages and the syntax that
it shows adhere to the problems that
you're trying to solve in that language
so it's it's it's great with it with all
these meta programming things that come
up yeah you can write Python in in rube
or you can write it in Python they exist
something that is actually quite close
to Python but that that's something else
what we're trying to do is just use the
libraries that exist because I think
that is just because we're afraid of
going out of a comfort zone if you
actually give the time if you know
Python and you give it time to learn
look at early and see of the the
problems that you can solve with that
you're gonna see that this thing that
actually works really well with the
problems that you're solving in Erlang
and the same goes the other way around
when looking at numeric analysis and
machine learning and string manipulation
things that pythons in like works really
really well for that so try going out of
the comfort zone looking at them and
after a while it's gonna be really I for
me actually was really really easy
because I think the syntax works really
well for the problems that you're
solving and with a pure line we want to
lessen the glue code so we want to make
the boilerplate so that you can you have
our line you have Python period the core
part of peeling is actually just a
library in in Python and then you should
be up and running so the as I said the
core of pure line is right now a Python
library the reason for that is because
and as we've said sometimes earning is
really really good at interacting with
other languages and then it has a really
solid foundation for building a
distributed system so what we didn't in
the core of pure lying is we implement
the distributed air line within Python
so we implemented a Python object which
behaves as an Erlang process with the
messaging box and stuff like that and
then we implemented the Erlang external
term format so that that's the binary
format that our line uses when it a it
suffers later between the notes we have
the distributed our line part with the
EPMD connection links or links over
distribution and such and within Python
we're currently currently using the
event for the event loop because it
needs to we need to give EPMD and things
like that some some working time so it
can interact with with distributed our
line the reason for using event is that
we we haven't decided we're gonna go for
Python 3 and python 2 yet but using
event we have that option so this is
just my crazy ideas that's coming we
haven't implemented this yet so when you
want to call in in in Erling if you want
to call in and execute a function on a
different note it's create quite
straightforward you have the RPC and you
make a call and you define the note that
you want to make the call on you have
the model data function and then you
have the argument since our line is
using just argument and positional
arguments and Python being quite generic
and you can use function programming
it's not that hard to me to do similar
calling and within Python if you want to
call in Erlang note it's quite
straightforward me and Dima we're
debating if this fits for Python as well
I don't think so
he thinks so so generally what I want to
do is I want to lift
because I think that looking at an
object path towards Python is is better
than using module function because we
have nested namespaces and we have
methods in closed methods and just pure
functions and in Python everything is an
object so a function is just just an
object that's callable a class method is
just a fun an object on an object which
has which is callable so having no
object path arguments and then keyword
arguments I think adhere better to the
way that you're calling Python functions
and still think this is quite quite in
the terms of Erlang some days although
we're moving a bit towards the the
Python design of it and another problem
is that we're gonna have when we start
using Python code we're gonna have
native Python object which is hard to
make into an Erlang and an early object
and what we could do then is we could
pickle it or we could pack it or we
could just something with that but
general what we're doing is if you have
a Python object you're not gonna be able
to use that within the Erlang node we
just want to be able to reference it so
we can call other parts of Python and
use it so with that I have the idea that
we're gonna have which is gonna act like
a process on low-level but you'll be
able to generate a context and when you
do that context you can then call Python
instead of using a node you use the
context and then you have the object
path the arguments and keyword and were
you getting back then is you're getting
back a reference of a Python object or a
variable or something which still lives
within the Python node so it hasn't left
the context so this context light lives
now on one Python node and all variables
are still there we just get back a
reference and then you can use that
reference to call other Python functions
within the same context and we're gonna
we're gonna then fetch the Python object
within within the Python node when
you're calling it so what what did you
say
code is document self-documenting right
for example the daytime object that's a
Python native object that you don't have
much use of that in the in the Erlang
node so the in this one it's it's
relatively simple and you create a
context on the first row and then you
import the daytime module that's with
this import so now we're a bed now we're
both in in Erlang syntax but Python
specific parts so that's the path and
this is the argument that you push in so
you want to import the daytime module
and it we get that reference back as DT
we assign it to D the reference we
assign that to DT and now I want now one
so we used the port here which which
becomes a less than first we have DT
which is then daytime and then we have
the binary which is daytime which is the
object and now which is the class method
method that exists on the object daytime
no arguments no keyword arguments and
now we get now one back which is also
referenced so now we have now one
manifested within the Python node and
now we call now - and we do it a bit
different just to showcase that we could
build the path from different parts so
it's DT and then we had to add some date
time and then the binary now so now
we're now one and now - and for those
that doesn't know if you don't want to
do now - now - - now one you can do now
- dot underscore underscore sub I'm
scoring score and then now one has
argument which works exactly the same as
doing a subtraction and we get the
results and then we finish off by
getting the total seconds thank you and
that is just a float:right which we can
turn into an airline format so at that
point we just returned the float value
another interesting idea is lazy
evaluation so we could do these parts
without the context so we do the DT
import we do now one announcer - these
are just references of things to do we
haven't done anything we haven't left
the Erlang node yet we have just built
something that needs to be done and then
we create three contexts three context
c1 to c3 and then we do a list
comprehension calling all the contactors
with the result and this will then make
all the commands run on each context if
I would have more time I could have done
that a synchronous video it would have
run concurrently as well so that is for
the the glue code and future projects
and one of the most interesting things I
see which is probably most likely one of
the things I'm gonna use it's a VST I
server or gateway with web - Oh coming
up more and more and having long polling
sessions open you can do that but as I
said we have given ten things like that
but that's not as native and as pretty
as a synchronous things works in Erlang
so having a web server which can handle
tons of connections open and then just
fire into Python for example if you have
a Django project you can have a
thousands of connections towards our
line and then when something actually
happens then you fall off and you call
one of your pools of Django servers that
are available machine learning
distributed machine learning or I should
distributed anything if you look at
tensorflow for example it has some form
of distribution built into it but it's
the same thing again you're building
distribution on top of Python and
January Python it's not that good had a
distribution and multi-processing
instead I would see this I would think
it would be really cool anything will
work really really well having a core
system of of our line which handles all
the all the polling all the
version of work and then having Python
notes doing the number crunching and
what else that's up to you
so the unicorn with Python and our line
maybe we could get build system with
tremendous uptime and ready for big data
being distributed and DevOps and Unicode
and protocol making and math machine
learning and a huge community and yeah
I'm running out of buzzwords but with
the communities together I think it it
could really benefit both communities
and if we give it time I don't think
it's the the speed bump won't be that
much because the the the feel of the
communities and and the things that
matter to the communities I actually
think are quite similar it's just that
the same text and things like that are a
bit different so questions I speed it
through a bit because I'm hoping for
lots of lots of questions who has the
cube and I first thank you very much you
want thank you Robert do you have it I
have the first question all the way down
here a boring first of all thank you for
talk and I have already checked the code
some time ago and the whole idea seems
really nice especially comparing to
something like our own interface or AI
which was like yeah but I've got a
question so what use cases did you did
you have in mind when I was developing
this application because well from my
point of view there are not so many
cases when you want something to be
pretending as a relying node I mean you
you already have a possibility to
interact with Python code you just have
a
note you just communicate with ports or
you do whatever stuff you need like I
don't know rest and phrases other
protocols so like what is the reasoning
behind of implement of having Python as
our link node behaving as another this
is the main idea is tithing loop
generally so so the project that I made
where I implemented this was a huge data
analysis to where we should report tons
and tons like you several gigabytes of
data and we have this and where where
you see we have data within react and
putting it out and so what we what we
solid to be able to do huge aggregations
we wanted to be able to take small parts
of data out fold it and and then throw
it away so we would be result bound
rather than input bound that was like
the main application where I started
doing this and I actually implemented it
slowly within Python and the big issue
being that I was really really unstable
so having five six seven processes and
trying to coordinate them within Python
it's it's a hassle so it's yeah that's
really really hard and and then are you
looking you could do or something but
that that's quite a lot of glue code to
actually get it up and running well and
it wasn't that that fast I thought in a
way and then I find what I found by
shows with bash of time series they
developed the binary term format which
was pure Python I think which was really
really so and then we I love found I
think is or less stay care anyway it's a
it's a binary format with in in Python
which compiles into see so it's siphon
or something I think they've written it
in
so with then I created so I had Erlang
notes which stand called straight down
towards standard out or what it uses
when you're using a report but with that
it was still a bit of a hassle I think
with that of course it worked and that's
the that's the impressive part right it
still works quite well but you have
those three four hundred lines of code
to get that up and running and you have
that you need to do some things in
Python and some things in Erlang and for
every project you need to do that over
and over again so my idea with Peter is
that we and that's why we did from
scratch so Dima has done has tremendous
knowledge about the distribution this
builder line and with that we could then
do a slim functionality within Python
and then now we're looking at
implementing that this term format
within C so so it's really really fast
I made some looks and up to par with
JSON packing with it so it's really
really fast and wit and then you can you
can lesson so you can actually call
Python functions really really fast from
with the with in Erlang and I would say
on the other end you have when you get
that possibility you have tons of
projects within Python that you could
use when in our line so honestly I think
the biggest benefit would be when you
have Erlang and you want to talk to
things within Python and if Python line
can speak or line that would probably
lessen the glue code that you need just
if pairing thinks the Python things err
like it could send it really big and
nasty complicated airline data straps a
huge big numbs in and all kind of things
so do you have to be a little bit
careful that you you don't confuse the
Python notes by sending them things they
don't really understand or do they
understand big numbers in everything
if I send a megabyte bignum in a
cryptosystem from airline tip Python
only what would happen I'm not sure
because I think you might get a kind of
mismatch that you have to do an awful
lot of data conversion yeah but the good
thing with if you make it behave like
Erlang failure is an option right so you
just implement it every airline doesn't
fail when you add two numbers together
but no no but vitam would have to say
the call the call would fail so if we
implement it right so we know that the
RK so this is a rogue file occurring we
can implement that really really early
within the call and we can just fail
because I mean you sort of asked that
question I was kind of thing you know
because you could send JSON over HTTP or
something and it's just done in ten
minutes and it's easy both in Erlang and
in Python so but if so how come so few B
I was the only one using both at the
same time and I think that they are
tremendous together some I believe is
that it is actually a problem otherwise
more people would do it I think it's
well I don't know but it's probably
because people don't program in both
Python and air like they knew both
languages I mean you've got sockets and
we've got Erlang and you've got Python
and if they speak sockets use XML or
JSON or whatever you feel like it
doesn't really matter it's just data
yeah
but said yeah you add more complexity
with it between them so and that's the
point that if you're losing yeah it
sucked but then you need every time you
need to do this let say okay so let's
build a REST API but why when you could
with a few lines of code just have where
is all that set up oh no because because
you've got all the code working and also
people have heavily optimized all that
Jason and HTTP stuff is sometimes done
in hardware without you even knowing and
it's heavily optimized so so you're
trying to beat that can be very
difficult sometimes
TCP stacks and things like that orange
done in the chips in them in the
hardware interfaces and all sorts of
magic happens if you if you send these
things but disturb you darling is
sockets right yeah but
yeah I'll be using sockets anyway though
you don't know it I mean anybody else
have a question okay can you go back to
your code slides I have I'm desperately
curious so what is the last parameter
there that you press when you do the
call back one yeah that's so it's a
keyword argument so in Python you don't
have just positional arguments you have
both positional arguments and named
arguments and generally when programming
python you you you have if you're doing
Metro and you have an array which is the
positional arguments and then you have a
dictionary which is almost identical to
a map within our line so that's why I
used to use a map so so in that you
could call if you're using date/time
purely you could have here month day
named here instead of having them in a
specific position in the arguments list
yeah guitar playing sorry that was my
bad oh no in case of course I'm in fight
mode as well so but you have the link
there in a way right more questions okay
thank you you want the discussion has
begun and we can continue the discussion
out have a break have some more drinks
I think they've brought harder drinks
than soft drinks now if not now they'll
be coming later
so we'll be come back in 10-15 minutes
okay thanks moe</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>