<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>David Christiansen - A Little Taste of Types - Code Mesh 2017 | Coder Coacher - Coaching Coders</title><meta content="David Christiansen - A Little Taste of Types - Code Mesh 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>David Christiansen - A Little Taste of Types - Code Mesh 2017</b></h2><h5 class="post__date">2017-12-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/3z9nISI4ppw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so my title here is a little taste of
types we've had a couple of talks
already which used address and I saw
much boasting on Twitter that hitters
had gone mainstream because there were
multiple talks that used it but this is
not a talk about address two anyway
there's no advanced features there's
nothing about how we can use dependent
types to encode state machines and do
cool stuff
there's nothing about how to use an
impractical software development instead
I want to give you a little taste of the
ideas that lie behind dependent type
theory and the ideas that you might need
to know eventually if you want to
understand the inner workings of a
language based on dividend types and why
would you care about a language based on
dependent types I mean as I said address
is now mainstream according to poodle on
Twitter but but there's not just
interest right I mean agda is also a
wonderful system that's really fun to
work with and has lots of advantages and
is that the sort of the forefront of new
developments in type theory and Kok is
the you know the 800-pound gorilla that
doesn't get talked about enough where
they've actually managed to make a fully
formally verified C compiler that
doesn't introduce any bugs in its
optimizations that's super cool and and
many of you are also using the big
mainstream language haskell in which the
siren song of dependent types has proved
to be a bit too much and it's slowly
drifting toward those rocks so you
should be prepared to swim but dependent
types go back much further than talk
actually really there's there's a few
momentous events in history which which
led to us being able to use them when
programming and it I think it's
important for us to know a little bit
about our history this all goes back to
Brower who's a I'm sure I'm saying his
name wrong because I can't pronounce the
Dutch at all sorry I don't think it's
bad
[Laughter]
in any case so he had this this notion
of what mathematical objects are and
brower's notion of mathematical objects
are one in which humans are important
right like if you kill everyone who
knows math there's no more math because
mathematical objects exist in our minds
their their mental constructions it's
not some sort of arbitrary game played
with symbols or some eternal and
accessible truth and and this this sort
of philosophical approach gave rise to
what they call this the school of
intuition ISM eventually and there
remained for a while skipping over
various other momentous events that
unfortunately I didn't have space for
here and in the 1970s
Pat Martin live develops not to live
type theory then in various different
versions starting in the early 70s and
all the way up sort of the 80s where it
began to take its modern form and Martin
Luther he is sort of at the core of
everything that we're doing with
dependently type programming today and
meanwhile in France we got the calculus
of constructions and there's been a lot
of cross fertilization between the
calculus constructions and Martinov type
theory which culminated in the type
theory behind a system called Lego which
was utt which I believe was short for
universal type theory although I forgot
to look it up and and that's the system
that actually was behind very powerful
things like epigram and Agda and even
interests like these are all
implementations of utt behind the scenes
and and work continues we have cubicle
type theory homotopy type theory all
these wonderful things but we also have
pi so as buddha said dan and I are
working on this book on dependent type
theory and these big systems they think
they get out of your way they automate a
lot of things for you and systems with a
lot of automation are great for getting
a lot of work done but they don't
necessarily expose you to actually
what's going on and they can make it a
little harder to learn it so we made a
little language for a little book where
you can have all of this front and
center and it's pie like the dessert so
let's
let's take a little taste of pie inside
of pie we have programs so one of these
programs is the number 5 and when I type
in the number 5 I get a little green
checkmark down in the corner and I think
it looks black on the screen here but it
is green and the the little checkmark
means everything's all right with that
program it's a nice program I understand
what it means and down at the bottom we
can see what the machines understanding
of the program is which is that 5 is the
result of the program 5 but it's also
the kind of thing that we call NAT so
NAT describes five and that is short for
unnatural numbers we're sort through
natural numbers because any number of
lessons ears unnatural but we have other
programs than just five we can also
write programmed like biscuits if I can
type and biscuits is a kind of program
called an atom which is old-fashioned
Lisp lingo in some in some parts of the
world for what we call symbols usually
today and the syntax that it's putting
out where it's saying what kind of thing
my program and its result were I can use
that myself so I can say the NAT 5 or I
can say the atom gravy and we get back
the same answer if I were to say the
atom 5 we've got a problem right it
expected an atom but it got a net that's
no good
likewise Adam and NAT are themselves
programs so I can type in that and we
see what kind of program is that well
that's a type because it's the kind of
program that describes other programs we
have more interesting types than just an
add an atom however so I could say the
pair NAT atom and then I say cons five
four five five and now we see once again
that we get our green checkmark and
everything's a-okay and I could even say
something like the pair atom atom and
this is of course not correct
and I can come back and say biscuits and
gravy and this means something very
different in the United States than it
means in the UK by the way I highly
encourage you to check it out at some
point in time not only do I have access
to pears I also have access to functions
I can say the arrow gnat gnat lambda X X
and now I've gotten back that lambda X X
is a function that I can give it an at
and it'll get me back a net and I could
say the arrow gnat Adam and then say
here food but types are more than just
things that collect programs into boxes
types also tell us which of their
programs are the same as the other
programs that are in the box so if I say
check same I'm asking PI to tell me are
for and for the same with respect to
Nats notion of sameness and indeed they
are whereas if I had said four and five
then I would find out that the
expressions four and five are not the
same that and I might also want to say
check the same pair NAT Adam cons for
for cons for four so all of our types
tell us what it means for them to be the
same and this isn't just the trivial
thing that it may look like because I
could also write plus two to here and it
still works so in other words running
programs is part of what it means for
them to be the same it's not all of it
but it's a big part of it so I'm using
plus here but I haven't actually shown
you what plus means so if I want to
define plus the first step in pi is to
say what kind of thing it is and I do
that with this form called claim so I
say I'm going to
that plus is going to be an arrow NAT
NAT NAT which is to say that I give it
to Nats and it gives me back a net which
i think is a reasonable specification
for plus and now I can say define plus
and put in a little placeholder and a
little yellow question mark box down
here in the corner means your program
might be okay but it's not done yet
and if I want to look at my place holder
I can see that I need to make something
which is an arrow NAT NAT NAT I do that
with lambda so I could say lambda J K
and if I were a schemer I might read
something like if 0 huh J okay otherwise
plus of sub 1 J K and then remember to
wrap this in an add 1 but unfortunately
we find out that if is an unknown
variable so I can't use my technique
from scheme in pi and that's because we
don't have billions actually but if I
want to rewrite this I do have an
operator which lets me check which nad
I've got so I can say which NAT J and
what which NAT means is I give it a NAT
and then if that Matt is 0 then it will
give me back this operator or this
operand otherwise I give it a function
and tell it what to do with one less
than J so I can say here lambda J minus
1 for the for the non lispers in the
room you're allowed to include things
like dashes inside of names and then I'm
going to say add one of plus J minus 1
okay and this ought to do the trick
except for the fact that plus is not a
known variable yet how could that be
well it turns out that in pi recursion
is just not an option
hey Dan why isn't recursion an option
yeah but why isn't it an option but put
ye is recursion not an option I think
you all get my point if we want to use
our programming language as a logic if
you want to encode reasoning as well as
just computation then we need to rule
out infinite loops because you can put
an infinite loop in any old type and
that leads to big problems eventually
and I'll point out some of those as we
approach them so instead we have safe
forms of recursion ones that always do
work right because plus isn't actually
going to be an infinite loop it goes
down by one until it hits zero and then
it's got an answer and that form of
recursion is captured by something
called rec net and rec net takes not
only a smaller net in the case of add
one as an argument but it also takes the
result of doing the whole recursion on
the next smaller net so we'll call that
sum so far and now we say add one of sum
so far and I get a green check mark but
a green check mark is not enough I want
to add some numbers so I'll say a plus
two two and we see that it is indeed
four as we had hoped and note that I
never used this J minus one here so
we've actually got one more convenience
form built into PI where we can omit it
and that's called inter net we've
defined addition but types are much more
than things like just atoms and pairs of
atoms and Nats and functions types can
also represent statements and then the
programs that are classified by that
type are evidence that the statement is
actually true
it's those it's the computer version of
those mental constructions that Brauer
was talking about sometimes I think he'd
be spinning in his grave when if he ever
found out that his intuitionistic
mathematics which put humanity in the
center and mental constructions was
running on computers it's kind of fun
but in order to in order to provide
evidence that two plus two equals four I
use another kind of program here
and that program is called same because
the reason why they are equal is that
they are at the same so I can say same
for and because 2+2 4 &amp;amp; 4 are all the
same net this is suitable evidence that
they are equal if I were to put a 1 here
then this would no longer be evidence
that they are equal but note that this
program here the type it's perfectly
okay I mean it's okay to say you know 1
equals a million we're just never gonna
be able to provide any evidence that
that claim actually is the case and
likewise I could come here and say plus
2 1 and down here 3 and I need a
parenthesis and then this also works
because computation is fundamentally a
part of sameness when we're dealing with
type theory but that's not a very
interesting statement yet we want to do
is be able to take our small statements
and combine them into bigger ones so
what is evidence like if we have if we
know what evidence for a is and we know
what evidence for B is what's evidence
for a and B well we've got evidence for
a and we've got evidence for B so we're
gonna make that with our old friend cons
what if we want evidence for a or B well
a or B is the case if a is the case or
if B is the case so we have either
evidence frei or evidence for B and I'll
show you how that looks in PI a little
bit later what if we want evidence that
a implies B well that's a function it's
a function that takes any old evidence
of a and turns it into evidence for B
and it's important that it takes any
evidence for a write because let's say I
had I wanted to say that if 2 equals 2
or a billion equals 0 then a billion
equals zero
I need to be able to deal with either
one of those cases finally we have
equality which we've seen where the
evidence that x equals y in some type a
is this constructor same when x and y
are in fact the same a and otherwise we
don't have that evidence and more
generally what is the evidence for the
statement false there is none whatsoever
and if we could write infinite loops in
any type then we would have evidence
that false is the evidence of falseness
and that would make the whole thing
morally bankrupt but we have a few more
ways of making statements as well so for
example if I want to say that there
exists something then I do that with a
special kind of type former called Sigma
and what Sigma says is it's actually a
fancier version of pear so here I'm
giving the type of the car or the first
thing in the pair and then I'm giving it
a name and I'm able to refer to that
name in the type of the cooter which is
to say the second thing in the pair so
now what I'm saying is that evidence for
there exists some Adam called fruit such
that this Adam fruit is equal to orange
is going to consist of a pair of an atom
and evidence that said Adam is equal to
orange so I might want to define this
and say define orange exists and so it's
Sigma so I'm gonna say cons cuz I want
to make a pair once more and then I'll
say cons apple because I'm feeling
adventurous and same Apple but I get a
little I get a little red X down here
something's gone wrong and what's gone
wrong is that I tried to say same Apple
has evidence that apples and oranges are
the same you know we can't do that with
apples and oranges so instead I'm gonna
come back and say okay well it's gotta
be orange but it's still not right
because Apple is not the same
as orange so I've got a right orange
here so we're seeing is there's a
connection between the value of the car
of the pair and the type of the cooter
of the pair and that's how we talk about
there exists something such that because
in order to buy it evidence of that you
got to give the thing that has the
property and evidence of that it has the
property and we can put these together
keeping in mind that all these types are
programs to talk about what it would
mean to have evidence that some number
is odd so in this definition we say that
odd is a program where we give it a nat
and it returns a type and that type is a
specification of what it would consist
of evidence for the fact that the the
very number we gave it was in fact odd
so the way we do that say that if a
number is odd then there is another
number which is almost half of it and
almost half we write HAF so and what
does it mean to be almost half well it
means of that if we double the almost
half and add one and we've got the
number we're looking for and so if I
want to say that seven is odd but almost
half of seven is three so I could say
the odd seven and now I need to say cons
three same seven and now we get our
green checkmark whereas if I tried to
claim that almost half of seven was four
then it doesn't work as we would expect
and so evidence of evenness how might we
construct that in order to get evidence
for even this we just drop the almost
from the almost half so we can save that
for some number end to be even then we
have Sigma H al F because it's actually
half in that such that equal net n plus
half half
and if I want to say now that six is
even I can say the even six cons three
same six and we see that indeed it is
and now we can solve the age-old mystery
of whether or not zero is an even number
and I will prove to you that zero is an
even number I will provide evidence for
the statement zero is even which is to
say even zero and that evidence consists
of half a zero which is to say zero and
evidence of that adding zero to itself
gets zero so that's same zero and zero
is indeed even at least given our
definition of evenness and not only do
we are we able to talk about evidence
that something exists we can also talk
about evidence that holds for a whole
class of things in other words we can
say for all and the way we say for all
is with PI just as Sigma is a fancier
version of pear in which you can name
the car pi is a fancier version of arrow
in which you can name the argument and
then the result type can refer back to
the actual argument that is provided to
the function so in this case I'm going
to claim that adding one to any even
number gets me an odd number so I'm
saying PI and in that which means I'm
writing a function whose argument should
be in that I'm going to call that an at
M then we're going to reserve receive a
further argument which is evidence of
that that very end we passed in is even
and having discovered that that very end
we passed in was even we will produce
evidence of it adding one to it gets us
an odd number and this is using the
version of implies that we had on the
evidence slide before right where it's a
function and so PI Curry's all the
functions so I can write one lambda with
two arguments here and fulfill the
specification up there
and then what I'm gonna do is I'm gonna
take n which is my natural number and
I'm gonna take n is e which is the
evidence that n was even and having done
that I need to construct evidence that
ad 1 of n is odd so almost half of AD 1
of n is the same number as half of n so
I can just take that car and put it
right here and we see that that's an ad
and then I can and then I need to
construct evidence that this number is
almost half of AD one event and I do
that using an operation called Kong Kong
is going to take evidence that two
things are equal and a function and it
happens to be the case that if you apply
a function to both sides of an equality
then you get back another equality so
it's a way of manufacturing evidence of
one of one equality out of evidence for
another equality so in this case we are
taking the evidence that the car of n is
even is half of N and we're constructing
evidence that it's almost half of AD one
of N by adding one on each side and that
gets us our ad ones and so plus one
keeping in mind the currying is our
addition function that's only adding one
thing and this is evident right now so
we've written more of a proof right it
says now we know that no matter what
even number we get one greater than it
is going to be odd and this we can do a
similar thing to go from odd to even if
we want but now we've got the tools we
need to construct something a little bit
fancier and we're going to say is that
every single number is either even or it
is odd so how do we do that so it's got
a pie at the top which means it's a
function so I'm going to say define even
or odd lambda N and now I'm gonna use my
reckon at my good old friend reckon ad
so I say reckon at N and now I'm kind of
stuck here a little bit what do I type
here let's put in some placeholders see
what happens
and it all goes it all goes wrong and
the problem here is that rec net isn't
powerful enough to do the job so instead
we need the the final strongest most
powerful way of using a net and that is
called Internet and in that is just like
rec net except it takes one more
argument and that argument is called the
motive and the motive explains why we're
doing a recursion and pi is smart enough
to figure that out if the type doesn't
depend on the target which is to say the
natural number that we are doing a
kurzon on but in this case the type does
because if we look here we see that
whatever n were passing in I need to
return evidence that that n is even or
that that n is odd one or the other but
it's got to be that very end so how do
we make that connection that connection
is made using the motive and then this
either type here in is given by we can
make it in two ways
so I'll comment that out for a moment so
if I want to say the either gnat atom
one way I can make it is using left and
if I say left then I need to give it a
net so I might say 17 and we get back
that that is and either not atom but if
I were to say right here then it wanted
an atom because right picks out the
other type so I could say instead right
of banana and then it also works out
so my motive is going to be a function
which takes a natural number as an
argument and returns a type and that
type it returns is going to be the type
of the entire recursion because it's
explaining the relationship between the
number that I'm doing recursion on and
the type of the value that I'm going to
be producing in the end so I'll say here
that my motive is lambda K either even K
odd K and applying that function to n
gets us the type that we want for that
very end and now what's our base case
the type of the base case which is
returned when n is 0 is the motive
applied to 0 because when n is 0 then
evidence that it's even or odd is
evidence that 0 is even or the zero is
odd happily we actually know the answer
we can say left because 0 is indeed even
and the evidence is 0 is even which we
defined earlier and the thing that's
remaining now is to do this step here
and as you saw from that mad scrolling
the type of it gets a little bit big so
I've rewritten it in a form that's
easier to read so if I want to define a
step for even or odd rather than taking
the next smallest natural number and the
result of recursion as an argument now
we need to take the next smallest number
and the type for the result of the
recursion is the motive applied to that
very number and because we're
constructing the result for add one of
that smaller number then we need to
apply the motive to add one of that
smaller number in order to find the
return type of the function so what we
see down here is that we're taking PI of
n minus 1 in that so n minus 1 is saying
you know 1 1 smaller than n and then
we're taking evidence that it's either
even or odd because applying the motive
to n minus 1 gets us this expression
here and applying the motive to add one
of n minus 1 gets us this expression
here in other
words if it's even or if it's odd then
we need to construct evidence that the
one greater number is either even or odd
so stepping forward one more in order to
define that we use lambda because we
indeed have a PI and an arrow and both
of those are for functions so we're
taking an N minus one and we're taking
in whether or not n minus one is even or
odd so we know which one it is and we
have the evidence and then we can use an
operator called in either where in
either is a lot like in that in that it
takes something of type either and it
takes a motive explaining the
relationship between that thing of type
either that we are using and the type
that we're trying to create something
inside of and so that's a or o of n
minus one is taking that evidence which
is going to be an either and then our
motive actually ignores the target
because in this case we are only need to
go you know we only need to know about
add about n minus 1 here and so we can
ignore it and then it takes two
functions one of them is going to take
as its argument what's inside of left if
the thing we're doing the case split on
has the left constructor at the top and
that would be evidence that n minus 1 is
even and in that case we need to
construe use our brain a little bit and
think if n minus 1 is even then add 1 of
n minus 1 is odd and furthermore we have
evidence for that which was this add 1
even odd that was defined earlier using
Kong so I can wrap that in right because
right means odd which was this sub
expression of the type here similarly if
n minus 1 is odd then our result is
going to have left at the top because
add 1 of n minus 1 is odd when or is
even when n minus 1 is odd and this was
the one that I omitted that I explained
earlier now all of these parts can be
put together and we get our friendly
green check box we can see that we're
doing in that
and the motive is that we want to
discover whether n is even or n is odd
and our base case is that all 0 is
clearly even and then we have that step
which looks just like induction steps
that you might have had in math class so
that's great we've constructed evidence
that every number is either even or odd
but we've done more than that actually
let's take a look at what we've done
what if I say even or odd of two we get
we find out that the answer is left cons
one same two in other words it's telling
us whether it's even or odd by its
choice of the left or the right
constructor and furthermore the evidence
inside of that left or right constructor
is telling us what half of it is or what
almost half of it is what if I say even
or odd of 45 then we can see that we get
right of cons 22 same 45 because 22 is
indeed almost half of 45 what if I'm not
entirely sure about 137 that's a pretty
big number I can't keep it in my head is
that even or odd I can ask and I find
out that that number precisely 137 it's
odd and almost half of it is 68 yes so
we wrote a proof obviously thought we
are writing a proof we were
reconstructing evidence that every
number was either even or it was odd but
at the same time we wrote a program that
divides by 2 and tells us whether it was
even or odd proofs arguments reasoning
these have computational content if we
want them to I think this is super cool
by the way this was chapter 13 of the
book so please don't feel intimidated
yes 13 out of 15 the other little books
all have 10 this one ended up being more
of a medium-sized book but thank you
very much for listening and if you want
to get a hold of me and ask a question
about something like this then you can
contact me or Dan
and you could read our book when it
comes out Thanks you finished Ernie yeah
so we've got about 10 minutes for
questions if you want to have a go at
him
well a quick one you had ad - one is
that like a constructor for the NAT type
or how is that defined yes so inside of
Pi I'll go back to a slides that I have
something to type in we have two ways of
making Matt's sort of behind the scenes
one of them is to say zero and the other
is to say add one of some other NAT like
zero for instance and then we put a
little helper on top of it I should have
a line break here the bug in the slides
but uh right so so and then behind the
scenes if I write 137 it's actually
making up a 137 element linked list
essentially it could I define that the
structure or myself you know if I know
okay
pi is a very small language
well I guess we take a break okay let's
give David so the question was can we
play with pine now and the answer is not
now but very soon by the book that's
published when is it published we don't
know for sure yet
yes yeah so the question was is it
reasonable to think of the motive as a
type signature and the motive is present
in order to give us enough information
to reconstruct what all of the types
need to be for the entire recursion so
in that sense it's kind of like a type
signature yeah it but really it's
telling us why are we doing recursion on
this mat like what's what's the reason
what's the motive for it sir what's the
relationship between pi and logic
programming this Laura looks like
logical statements you're writing so
logic programming is a paradigm of
programming based on doing a large
search and that's not what we're doing
here here instead we are providing the
ability to construct evidence and then
have the computer say thumbs up or
thumbs down to that purported evidence
okay
it could be fruitful to combine the two
potentially in order to have the search
problem go out and construct that
checkable evidence that's true I guess
the underlying question is through curry
Howard there are connections between
logics and types and yes all this so
what it was the logic that underlies PI
I mean I asked to that way higher-order
intuitionistic logic okay
so why don't you have a search to guide
your PI because that would undermine the
point of making it which is to enable
people to learn how these things work by
having a bare-bones one that is
nevertheless as convenient as can be
within that ok so what you understand it
you can add it can you add your I sure
hope so
okay cool yeah okay thank you okay
Oh No ah great maybe it's slightly dumb
a version of the last question wait
please don't disparage oh I know how to
write a program that divides numbers by
two oh and we'll calculate the remainder
is it possible to use a technique like
that to use PI to show where the numbers
are even or odd so you can use lots of
different algorithms to implement
division but you've got to be able to
phrase them in a way where they're using
these safe recursion operators this one
is the easiest one to do which is why
we're using it and I think by the time
you get to doing that sort of thing you
probably want a fancier tool like caulk
or AG door address where there's a
little more automation to take care of
the fine details once you understand
them but yes it can be done so so
basically to do it in PI you do want to
be providing evidence of knowing what
the number that's half or almost half is
yeah yeah so the issue is that the
normal way in employment division
actually if assuming that your hardware
doesn't have it which is kind of a
ridiculous assumption but what you'd
want to do is like is subtract something
until you can't subtract it anymore but
that doesn't really follow the
one-at-a-time
structure of the recursion operators
that for the natural numbers and so you
end up having to construct a relation
that captures that iterated subtraction
property and then write recursive
functions over that relation and it
becomes a little bit hairy
how does the motive ensure that the
recursion is finite so the motive
doesn't ensure that the recursion is
finite what ensures that the recursion
is finite is that every operator in the
language sort of preserves the
finiteness and preserves the totality
and the way that recursion on natural
numbers does that is that it it observes
that our natural numbers assuming that
the rest of the language didn't make
some sort of weird infinite crashing
structure instead of at where that was
expected we know that it's going to be a
finite number of add 1 constructors
followed by 0 at the end and the
recursion operator if well if it was
zero then we have an answer which we get
by the fact that all the arguments were
total and if it's add 1 of something
then we are using the step function
which we know is a total function by the
fact that we've assumed it for the rest
of the language and we're showing it
sort of one piece at a time and that
total function is going to be applied at
most as many times as our add ones which
are finite yeah thank you yeah
well you're not gonna throw the
microphone yeah it's too much too much
leaning so your your notion of sameness
involves evaluation is the is the
runtime calculus of Pi strongly
normalizing we sure hope so
as I was gonna say I mean you have
induction and you have presumably a way
of representing a stack by way of pairs
of pairs right so you should at least
have pushdown automata which would imply
that II like even if it's strongly
normalizing your sameness is not
decidable so we do actually have so
that's so the sameness that you're gonna
get is gonna is going to be the one you
inherit from the particular
representation that you pick for your
data you don't get to make your own here
unfortunately so we'll just end up being
incomplete basically yeah okay so I I'm
infer that pi is not really designed for
use in production but obviously if we're
not trying to do real calculations with
numbers representing integers as linked
lists is not going to be very performant
not even integers we don't even have the
negative number sorry
high is a very positive language is
there a safe way to take your logic
based on natural numbers and then use
machine integers with it under the hood
so machine integers are probably not
what you want because they are bounded
they can't represent all the natural
numbers as the truth but Agda and idris
both have a compilation scheme where
they use GMP and set run time for
natural numbers so that's yes yeah
okay that's the way I heard it from
Buddha not only is it just mainstream it
is production-ready please don't email
us for support
you can email at Witten it's fun for you
I had one alone anyway that's all let's
give it a round of applause</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>