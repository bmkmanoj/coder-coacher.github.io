<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2015 - Michael Nitschinger - (...) A Survival Guide to Resilient Reactive Applications | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2015 - Michael Nitschinger - (...) A Survival Guide to Resilient Reactive Applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2015 - Michael Nitschinger - (...) A Survival Guide to Resilient Reactive Applications</b></h2><h5 class="post__date">2015-03-31</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/txjKo93EOZs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright then let's get started I hope
you all enjoyed lunch they've been
probably go here and I was a little bit
afraid because maybe it's kind of a
niche niche thing here today at this
conference which is kind of special let
me let me first ask some questions how
many of you are writing software which
is deployed in production actually used
to make money in your company and
businesses okay quite view boom how many
of you are maintaining such applications
on a day-to-day basis okay and how many
are doing both okay great so especially
if you're doing both I think this talk
will have a lot of information for you
in contrast a lots of other
presentations yesterday and today this
one is purely coming out of practically
feedback and knowledge from people who
are building resilient distributed
systems if you are using airline for
example you will find a lot of
mechanisms in this talk and the deal
also have an erlang but all of the
patterns I'm showing you today are
completely applicable to any type of
language I intentionally tried to keep
it abstract so you can take home as much
as you you can from this and then you
can apply to your specific languages so
I work for couchbase and we make
document oriented databases and I'm
maintaining our JVM driver and as part
of that I'm also working with a lot of
our users and customers trying to help
them build resilient applications and
there was my main motivation actually
because I saw so many user code out
there which was so bad in terms of
resiliency and and reacting to failure
that I figured let's let's let's do a
talk daren't and step back a bit from
the actual implementation try to get
specifics specific architecture and
patterns in place first that you can
then apply it to implicate so let's get
started the most important thing in my
opinion is that you need to get into the
right mindset when you're building fault
tolerant applications I don't care what
language you're using but you need to
make sure that you are getting into the
right mindset you need to get into fault
tolerant mindset okay so the US Marines
election military there is a
quite common saying they say the more
you sweat in peace the less you bleed in
war and if we if we think about that in
terms of sorts of development of course
thankfully not many of us need to
actually go to war but you actually you
end up in the same situation if you do
not take care about a resilient in
applications during development it's
going to hunt hunt you in production and
you don't you don't want to get the
wake-up call it 3m in the morning that
you're the reproductive system is down
or they put it in the words of DevOps
board ninety percent of DevOps are
failed simply interview question of what
is most critical piece of infrastructure
is outgoing mail on our server so you
definitely do not want to end up in such
a situation that you actually depending
on your naga service any GUI image and
they do implement fault tolerance
steadily so joking aside what I see out
there most of the time is what I'd call
sunny weather coding people are
developing the applications and they
they don't because it's wet it's hard
it's hard to think about fault tolerance
and resiliency because you need to not
only apply a timeout here and there you
need to actually have a holistic
approach if you want to take it really
seriously now what I also seized a lot
of people are saying I'm doing unit
testing I have hundred percent unit test
coverage so I'm safe I'm safe and I say
not so fast mr. fancy tests because the
problem is that as you probably all know
that with unit tests you can only
approve that the specific bug is not
there anymore but there will be
obviously backs which means there will
always be false in your system so we
need to accept the fact that there will
always be false and in this talk
actually i'm going to show you what you
can do when a fault gets active and an
error happens in your system and then
what you can do with those errors so
always ask you sir what can go wrong in
any kind of situation when you're
building a new new system when you're
building a new feature really take the
time and sit down and say okay this is
the basic requirement ok I got it all
nailed and then I'm sending requests to
this service and I'm getting a response
what happens if no message comes back
from from the response what happens if
two messages come back or what happens
if the the response that you get from
this service is actually not what you're
expecting who of you has actual
I talked to arrest HTTP web service and
and you expected chase and do compact
but what actually came back was HTML
formatted response because you were
hitting a server bug or something there
are quite a few so so and this is also
one type of failure most of the time
when I talk to people about failure day
they basically think of failure is the
system is down but there is so many
different variations of failure and this
is all cover done basically under fault
tolerance so let's take a step back and
try to get the wedding in place first so
there is there is there are specific
terms that when you talk about fault
tolerance which makes sense to get on
the same page so when we talk about the
fort f or it is a latent defect in a
system and when it's activated it can
cause an error this is your typical bug
you have a bug in your system you don't
know that it's there and then a specific
condition like a method call triggers
the back the latent defect gets
activated and gets promoted into an
error now since we just agreed on that
Ford's are always there errors can
always been our system so what we
actually need to do to get resilient in
our system is to handle errors and what
we what we need to accept is that those
errors are the manifestations of Ford's
and when we fail to prevent errors from
from spreading and so forth when we do
not contain them and we do not mitigate
them then they get data basically get
moved over and what we call a failure
and the failure is nothing more than a
failure to comply with our
specifications to our system now a
specification can be anything you can
say when I do this request I expect this
response that's that's basically a
specification but there are a lot of
other subtle things like what response
times do I play one from the system are
I want five milliseconds on 99
percentile for example what happens if I
have to wait 10 milliseconds and so
forth so and this implies nothing you
actually need to think about your
specification because when you don't
specify upfront what you're expecting
it's very hard to determine what failure
conditions can be in your system
so up front when you're designing a
feature make sure to also have
specifications in place so you can
actually measure I'm the deviation from
your specification which is also quite
important so errors are inevitable and
what we need to do is our main goal in
doing this talk and what you should also
do is you have those errors in the
system and make sure you detect them
recover from them and potentially
mitigate them before they become
failures because when it's not a failure
it's an error has is happening in your
system the system can still work right
there can be different different things
like for example your system is not
responding anymore a hundred percent two
hundred percent of the load only two
ninety percent and so forth so but as
long as you can control arm your errors
you can you can put them basically in
the spot and you can recover from those
errors before they become failures
you're safe and this is this is the
ultimate goal of offer tolerance and
resiliency now what is reliability
because reliability and availability are
very often confused terms so when we
talk about reliability we mean the
probability that the system is
performing failure free for a given
amount of time okay and there were two
two metrics to that which is the mean
time to failure and the mean time to
repair now for example let's take a
different example um let's think about
the mass robot okay the NASA probably
wants the mean time to failure for this
thing very very high because when they
deploy the master or what they want to
do all the missions end and they don't
want the the master able to fail before
all the missions are completed probably
they don't care so much about the mean
time to repair because it's quite
expensive to send a crew over to the
Mars to fix the Mars rover now let's
take another one aviation and and
airplanes so the mean time to failure
should be of course longer than your
flight duration because you do not want
to have the GPS system failing during
your flight right but those are quite
important metrics to figure out also in
your software system and if we think
about airlines in the mean time to
repair they also want to reduce the mean
time to repair so they can put their
plans back into service very quickly
right
but if the gps systems fails on the
ground and the stuff can fix it and so
forth so those are those are very
important metrics to think about in your
application scope especially in terms of
of SLA s and so forth that you meet
those requirements because when we talk
about availability which is the
percentage of time the system is able to
perform its function so this is the most
of the time the most of you will
probably notice the number of nines that
you commonly talked about when you talk
about availability and how can you
calculate availability well you did you
take the mean time to failure and divide
it by the mean time to failure plus the
mean time to repair which means that if
you if your system would take no time to
repair you would have found a percent
availability but yet it's not going to
work out and typically in applications
out there the mean time to repair is
quite high because I mean you can of
course you can restart the service but
if you have another type of bug then you
need to fix the error and redeploy an
application and so forth so I'm reducing
reducing the mean time to repair and
actually increasing the mean time to
failure is what we are looking for here
so talking about availability this is
what the common expressions are when you
talk about availability so for example
if we we say we want to have three nines
of uptime per year thats basically five
hundred thirty minutes of downtime per
year which yeah seems quite quite okay
now four nines is like one hour of
downtime per year and most of the of the
companies are today actually cheat when
they have such tables because they say
oh we have five nines of of uptime but
we do not count maintenance right which
yeah i mean the system is done when
you're maintaining it anyway so you
really need to count it into but believe
you are using let's say services online
and you're really looking for bailey
pletely make sure they do not include or
they do not explicitly exclude our
maintenance and then we have 59 and 69
and you can see in this area this is
already very very tricky to get right
especially in distributed systems five
minutes of thumb tempe is nothing
right so so in that era you will
commonly find on telco equipment for
example with a highly redundant
components and so forth I'm they come
they most of the time play in this area
and this is an important implication as
we see in a bit so let's do a quick quiz
let's say we have an H service and our
edge service strictly depends on the
user service station store and theta
waves for example a request comes in and
then we need to check is the user
actually are registered with our system
and then we check the CFS asia- and then
we also grab some data out of a data
warehouse so what we want for each
service is our 190 Vale ability which is
around 1 hour of downtime so what do you
think each of those services are needs
to have in terms of number of nine
sexually guarantee our availability over
here any ideas who is 449 hmm exactly
and and actually you yeah yeah okay I'll
try to okay it it's not for nights
because you are actually you need to
combine the availability 0 for all of
those so it's it's somewhere between
four and five nines I didn't actually
calculate the exact number but the thing
is I mean number of nines doesn't really
sound like much but if you compare for
nine to five nines or even 24 9 10 25
it's actually you go from one out of
town time to whatever 10 minutes or
something or I would be like 30 minutes
or 25 minutes something like that and a
lot there is this bus with microservices
right everyone is deploying
microservices right now and if you take
this picture even further here we're
just talking about three services but if
you deploy micro servers and subtle you
have 50 services in your application
landscape and they all depend on each
other and what if one if one of them
goes down the whole thing actually can
collapse which is what happened to
Netflix for example they there a lot of
talks online from a bank resistance and
then each engineer from netflix and
which is a really great guy and he talks
about originally they had RPC
architectures and all the specific
things in place that we also talking
about today and if one of the services
failure was like because there are
thousands of requests per second they
couldn't even react the whole thing was
actually swamped
then they couldn't do anything anymore
right because even let's see you using
threat posed with hundreds of threads if
you have thousands of requests per
second and each of those calls blocks on
the service that is not available
anymore your thread pool is also blocked
and then you're dependent service is
also down so if you do not take care you
can very quickly spread spread issues
across the across your system so any
questions so far all right let's keep
moving so now we agreed that we need to
think about fault tolerance and so forth
so let's now talk about how can I
architect my application to befall
torrent so the first thing and and now
I'm going to talk about patterns so the
first pattern which is i would say
required for all of the things that's
coming now is the unit of mitigation and
the unit of mitigation that is that you
have a specific unit which you can use
as a basic container for error
containment and recovery so i can't tell
you for your application what this unit
of mitigation looks like but the only
guidance i can give you is that it
should be large enough that you can
potentially fix errors that are coming
up in this unit on your own it shouldn't
be so small that you cannot even air
handling but also of course it shouldn't
be a whole application so especially if
you're doing domain driven design and so
forth picking domain objects and
actually grouping them to get a is a is
a nice rule of thumb so pick picaroons
of mitigation that you can and we'll see
in a minute how those patents look likes
it so you get a better feeling of how
large the unit of mitigation should be
for your application but if you do not
have those defined in your application
it's very very hard to do things like um
I redundancy for example because what
components do you pick to be redundant
you don't know right if you do not pick
units of mitigation or if you have
failure of any application what parts of
my system to available so this is that
the basis for all of your vacation and
there's another term I think they headed
in the old directive manifesto which is
called bulk heading so they had this
picture where you have a ship and the
ship s compartment so if one some of the
compartments fill up that the
compartments actually prevented from
filling up the whole ship right so you
want to make sure that the units of
media
gation can potentially recover on its
own and do not take the whole thing down
now when you are not able to recover
inside the unit of mitigation what you
want is you have you want to have a
clear escalation path so if your
recovery is not possible inside unit you
need to escalate it to someone else
because I'm you don't want to fail or
the whole thing very often the parent
scope has more information and can do
much much more intelligent failure
handling then you your single unit
because the the more information you
have available the higher the chance
that you can actually recover from an
error now to give you a concrete example
this is from our java java sdk and if
you're so quick one minute intro into
couchbase so you have a cluster and you
have a class of notes and each node in
the class there specific services like
you value query and you can do secondary
nixing and whatnot now what when we
architects the SDK we thought let's
let's use the same terminology end up
and then you can apply those units of
mitigation and escalation pass very
easily so our end point here is like a
socket okay so it's a wrap around the
socket and we can do basic error
handling here we can say if the socket
is down and then we probably retry with
a increment to beg off or so far and we
can do that and and maybe it turns out
here we it doesn't work right the error
comes up over and over again what we can
then do is we can escalate it to the
service level because the service level
probably has more than one endpoint here
so it can it can infer for example this
service maintains three endpoints of
three sockets and only one of the socket
is down it can probably infernal the
remote services is still backups I keep
retrying this one but if the service is
that all of the endpoints at the same
time disconnected there is probably
something wrong with the node on the
other side of the network so it doesn't
make sense to keep retrying immediately
maybe it's caters a retry with a longer
baker for it even not know device a
different component which takes a new
configuration from the server to see if
the node is actually part of the class
anymore because it has been failover
something like that now if this and
there oh and then it goes on and on if
the service has no clue what to do it
propagates it to the node layer because
the node knows about all of the services
in the class
and and this and this active very simple
example we had so a service of course
talks to specific port on the node for
example there is a 1891 for HTTP
communication and 11 to 10 for key value
binary operations now what can happen is
that not every user uses all types of
operations at the same time against the
cluster so someone is only using key
value type operations someone is only
using vuze now what we had in common
setups is that they had five words
in-between it the firewalls silently
shut down connections they've been
effective so if you're only using
q-value traffic and not indexing traffic
this service would be completely would
be closed because the ferry will close
all the connections after let's say a
few minutes so you you know that you
don't know that at the service level but
you probably can infer that the node
level and then you have more scope and
you can better you have more information
available to guide your error recovery
mechanisms and then finally if if we
have an area that complete note be
propagated to the cluster level so the
cluster knows all the nodes and can then
determine what to do most of the time at
the class level when when a node goes
completely down we grab a new
configuration from the server and see if
it's actually still part of the class
anymore because someone could have
removed it or it could be forcefully
removed because the node has been failed
or something like that so let's talk
about redundancy most people I think
about redundancy only in terms of
hardware redundancy but you can you can
build redundant components and software
as well of course so and and there is
your your trade offs here are cost and
time to recover so if you do and this is
true for both soft and hard work on
redundancy if you do active active
redundancy of course the cost is high
because you need to have all your done
in service is running at the same time
so they can immediately take over but
I'm the time to recover is very low
because they can immediately take over
another approach would be active standby
so the coast is still high because you
need to keep your nose running but
probably they have warm-up time so if
you use active standby components you
stand by component probably's is powered
up but it doesn't get all the traffic
all the time so
it needs some time to maybe warm up some
state or so forth actually be able to to
serve traffic now and then there is n
plus n plus 1 or n plus M how do you
want to call it active passive
redundancy which means you have standby
components and if you're active
component goes down then you power up on
the other component and then and then it
takes up of course this takes the
longest time but it also reduces costs
because you don't need to run all the
services at the same time so depending
on your requirements you need to pick
the right way of redundancy now one
thing that that is very important is and
I think this is this is a concept that
not many people proactively do in the
applications is what it's called The
Fault observer so what you want is you
want to have a centralized observer
which receives system and air event and
in turn it can get an orchestrate
detection recovery because imagine you
have lots and lots of those units of
mitigation in your system and they all
get errors now they could be in
different places and they only have
their own scope so if they all send the
errors to observer The Observer has the
knowledge of all the errors going on
your system and then can do a much more
informed way to guide your error
detection and recovery right and another
very great thing about this observe is
that you can actually add listeners to
your system so if i have this observe
and i'm already taking the data i can
very well let users of mess use them I'm
subscribe to the service so they get a
notified of errors in the system for
example they can they can listen to this
observer and then push it into graphite
or an oculus or the monitoring system to
do proper monitoring right and because
otherwise they would never have this
information available most systems are
they just log but logging doesn't allow
you to do Proactiv I recovery because
someone needs to parse the logs and then
do something it's too late at that point
you really want immediate feedback to
guide error recovery because you know
you don't want to have the worst thing
you can do is have users as part of your
recovery process right never do that
what you want is you want to minimize
human human interaction while you're
doing every covery but you want to make
them as human participation
because at some point someone needs to
fix the error that happen right and this
user needs lots of information available
to make an educated guess what actually
happened right so error recovery quick
and fast make sure the system keeps
online and doesn't fail but then at some
point you also need to put make this
information this this probably a
boatload of data available to users to
fix it at some point so one application
I want one example from our SDK the
specifics are not important so you
connect to to the class and this is just
regular Java code and then we expose an
event bus and in this event bus I'm so
for example we will oh we lock connected
to node a example but we also push this
information to the event bus if no one
subscribed well no one cares but you can
you can subscribe to this event doesn't
get those information immediately and
you can push it to your monitoring
system for example if a note goes down
and so forth and then you can you can do
something with it because all of this
information might be very available to
your system because if you see notes are
coming down and then we again we at this
escalation path because you're
monitoring system off of your whole
network and application landscape has
more knowledge than each individual
application container because and then
you have a system administrator sitting
guessing oh actually this course which
went down this is the reason why this is
happening and then he can make it much
more better educated guess how to
quickly recover from the arrow right so
it's all about escalation and and and
aggregating 10 latches you push push it
up to the next boundary so that's the
basic point of architecture and tears of
course lots more to talk about that but
we only have 45 minutes today so what we
now want we want to detect errors as
quickly as possible and and I really
like this is this thing a silent system
is a dead system if even if your system
is working perfectly but no one actually
knows that it's working perfectly you
could assume that it's dead so if make
sure that when you are building in
applications you don't know it pushes
information to a monitoring system I'm
it's pushing metrics somewhere so you
can actually get inside and confidence
that your system is working properly
which also has a feedback loop so if
you're pushing out a new feature
making performance enhancements you want
to have a dashboard with metrics to see
if the fix actually made it worse or
better and so forth so even when it's
it's humming along nicely and there is
no further going on make sure to push
data somewhere that you can actually do
something with it now what do you want
to have with some form of a system
monitor right which takes all this data
and presented to you in a nice fashion
it shouldn't be as elaborate this
Mission Control in Houston which is
actually very nice place and this system
only the really helps you to study
behavior and make sure its operating and
specify it's not if something goes wrong
but also during regular operations one
example here is a project from Netflix
called to urban and who strikes which if
we have time I can show you in real life
as well and what they do is basically
they have this dashboard and you can see
there are circuit breakers will talk
about circuit breakers in a bit and they
provide you per second real-time
feedback of your whole fleet of service
so they have thousands of machines
running and they want to get immediate
feedback so this turbine is actually
aggregating all of those circuit breaker
information and they can see at second
precision for every let's say type of
operation they are doing for example
here they are fetching some some titles
and fear day they take some social
status and iTunes client looking with
received and talking and so forth and
you can immediately see how much traffic
is going through are there any errors
you see the percentile so actually
looking at this dashboard gives you a
lot of information and what do you what
you can also see very quickly is that if
something goes wrong this thing goes
from green to red so if you have a
system administrator sitting there and
it is basically this one is red and this
one is red this one is red it can
probably because it knows the context of
your application oh those three are down
and then it's likely that this isn't
this happened right so the more
information you make available to users
they're much better because you don't
guide error recovery now one other very
important thing is periodic checking so
the there are two things which I'd like
to cover the first one is heartbeat so
you can use heartbeats to monitor tasks
or remote services and initiate recovery
so you probably all know how to
you have a system you send and heartbeat
and if no heartbeat comes back then
probably something is wrong now it's in
practice it's a little more complicated
than that because it could happen that
the response comes back after later
amount of time because the other system
is just overwhelm of work so you need to
you need to find the right the right
scaling foyer for your things because
let's say you miss one heart beat you
you do not want to immediately trigger a
recovery and whatnot maybe you want to
wait a few heartbeats to actually make
sure how to increase the percentage that
they actually that the monitor system is
actually done now another thing our
routine exercises and and this is less
common than than heartbeats but I think
it's very important you need when you
have components in your system maybe
standby components or just components
that are not unutilized on a regular
basis you need to make sure to give them
some work to do to prevent unit
starvation and also to surface
malfunctions so for example and the
example I brought to you earlier with
the firewall that's exactly the same
thing we can prevent it because if the
sister the user is not is not not doing
Covelli operations we can every every
few seconds we can just send an
operation like a ping to the server so
hey everything is fine and this will
prevent the fireworks from closing the
connection so by applying those patterns
consistently you can actually mitigate a
lot of those side effects that you'd get
up front and what you can also do with
those root the nexus and heartbeats is
not only checking that a response comes
back but you can actually pick it back
on top of that and you can see I'm
actually measuring the latency and then
you can take this this average latency
did you get for your pings and then
store this metric somewhere and then for
example if if you suddenly see that the
response time for the heartbeat oops is
longer and longer you can actually alert
that as well because then then there's
probably something going on in the
network or some of the servers are
overloaded then you can add new nodes to
the class then what not actually
mitigate the situation so and and this
is what what we are doing in in the Java
SDK so has anyone heard of Nettie then
at the i/o library Oh quite a few that's
great so
we are using that under the covers and
it has something very nice which is
called the pipeline so when you're doing
network traffic you do not want to care
about all the event loops it's going on
we actually want to transform your data
from raw bytes into an informant so this
is what we do you do you basically
define encoders so we take a request and
then we encoded into some bite bite
format know we we send it to Nate the
engineer i Taylor when the response
comes back and we pass it through it
decoded chain now what we can do here is
we can actually put in here a handler
Annette it's called idle idle time at
angel or something like that so after
specific amount of time if no traffic
went through it's sending a message up
here saying hey there's no traffic going
on and then you can proactively send
another request and this is what we're
using actually to do those are pings on
a regular interval with very minimum and
not very much things you actually need
to do that's that's kinda if you are
working on the Trivium and you need an
i/o library usenet the Chamber's black
but it's actually evaluated all of the
i/o frameworks on the JVM net these
hands down the best one so yeah I can
just recommend you that oops there
wasn't one yes yes so actually in Nettie
I'm tropical a little bit of topic just
to cover it quickly so in Eddie what do
you have is you have event loops and
what do you actually do is you schedule
tasks on the event loops such a task
could be right this request down to the
socket or it could also be like like you
have a scheduled event executor I mean
schedule executing Java which you said
in a task and say execute this after
specific amount of time so it actually
does this every time you write something
it resets this this content when it
tires then you know nothing happened in
that period then it sends up a message
so it's it's it's quite quite easy and
reasonable to use if you are putting in
that handler what it does is you just
get at you they call it are you
defiant message so intelligent you can
react to it so the next thing is our
writing / transient so very often when
you're dealing with recovery and you
implementing those mechanisms you should
not fall into the trap to for every
single bleep to this occurring in your
system react immediately this is a very
fine line between waiting and also
waiting too long and not waiting too
long so what do you want so so Robert
hanmer which wrote a great book which
I'll have reference later on on those
patterns is as patience is a virtue to
allow the true signature of an error to
show itself so sometimes when you wait a
little longer and it's still in your SLA
period probably you can you can infer a
specific I'll put if you wait a bit long
and you accumulate those errors that
come up you can identify specific
patterns that you probably couldn't if
only one error of them came out right so
this is very i would say specific to to
their ahead leg in application but just
keep in mind that sometimes you want to
wait a little longer especially if you
can't afford then you have more scope or
more context available to guide your
recovery than just doing it immediately
and one way to do it is that the leaky
bucket the leaky bucket is a pet on
which you can implement and you can
think of it that way so you have a
pocket and let's take requests and
responses a simple example so when you
do a request you put data into the
bucket and when a response comes back
you basically have a hole in the bucket
and water drains out so um if we do if
our bucket is designed to make handle
requests per second with have handle
requests go in and hound request go out
and our bucket is fine now what imagine
we are doing more traffic but we cannot
really handle it our bucket with
overflow and then the drain rate is too
slow for thing and that everything would
just overflowed so you can use the same
pattern for error recovery you can say I
allow five errors per second on this
specific application or the specific
unit of mitigation of the specific tasks
that I'm doing so you are accounting
those errors in the bucket and then you
have the drain rate of say two
who are two events per minute because
what you do not want to do is you have a
count any application which counts the
errors and the logic says if more than
five errors happen trigger error
recovery but what happens if one error
comes after one hour after 30 another
comes and suddenly after one day you had
five errors in hours distance and subtly
you trick every recovery you don't want
to do that because at some point you
want to reset those counters because
there is a high chance that the system
already stabilized so you want to define
a terrain rate which is like the normal
rate of your system and then so you can
it's also called the sliding window so
you can implement sliding windows in
those specific errors are error handling
time time frames so and there is much
more so I can't go into detail of all of
those but there is four for error
detection you want to do very rigid
parameter checking so make sure
everything that comes into your scope is
properly checked and you make sure that
everything is fine before you move on
you can use watch dogs watch dogs are
now like heartbeats but they basically
sit in between and they they watch the
traffic going through and if something
goes wrong they basically they yell and
until I or something is going on there's
and then you can react it you can apply
voting so for example if you need to
make sure that the result is correct and
you probably fetch data from specific
for more than one source you can let's
see you get back three responses then
you can apply voting mechanisms and you
can pick the majority configuration I
can give you a quick example of that so
when someone connects to couch bisque
last of course it needs to give us a
nappy address so we can establish a
initial connection to the gloucester now
what happens if it gives us three
addresses and one of those addresses
actually points to another class that
just because he messed up there p
addresses now if we would just pick the
first one we would never know that we
actually connected to a completely
different cluster now if it gives us
three or four of those IP addresses we
can grab configurations from all of
those nodes and then apply majority
voting to make sure we actually connect
to the cluster where most of the
configurations agree on it's not an
abyss and foolproof but it's something
that that allows us to
be more intelligent and help to use a
probability to figure out the user area
that he made it at configuration time
check sums are very commonly known and
also routine audit so see you depending
on the type of application you're doing
you sometimes want to have routine jobs
which peek into for example data
structures especially in in systems like
sea environment where you kind of
thinking pointers you want to have some
audits that actually looks into let's
say a linked list to make sure that all
the links are still still in place and
so forth depending on on your type of
your vacation but this is more this is
very specific to your language in Byron
most of the time okay we detected errors
some other questions on on error
detection okay I'll just move on this
one is obvious right yeah okay timeouts
let's get to it so you don't want to
wait forever and and and Club the
resource so it turns out everyone I
think does everyone agree that time I
saw a good thing to have okay yeah
hopefully now the thing is and i really
say this by heart do this on everything
add timeouts the boundaries of your
system not only edit to a specific
network hall but also edit to let's say
you're using a database library you want
to have a time out there because i can
tell you that database travels half
bucks each a vm or your runtime
environment his box if you ever check
the openjdk JIRA issue repository i
don't know how many thousands of bucks
open there so do not trust your
libraries do not trust the operating
system of course it's more likely to
have a bug in your application but there
is a very good chance that something
else is also messing up your system and
having timeouts is really your last
resort right when a time up happens
there is already something going on that
you don't want to happen unless you set
the threshold very low but always in
your system boundaries use timers all
the time they are really your last
resort of defense they are and here
here's the the great reference back to
the walking dead so who is seen the
walking dead only a few it's about
zombies right
you have netflix in in in Poland nah
okay oh yeah yeah okay so it basically
it's a serious about zombies and when
they buy to you also turn into something
so forth and this is paid this is really
the my only analogy that I could come up
with because I first a thought I let's
put zombie pictures in there but finding
somewhere pictures which are not not
looking too nice and also educating at
the same time it's a hard task so I just
thought oh me too all of them but again
really your timer this is your last line
of defense that when you're dependent
system or resource is not available or
it doesn't respond you can make hundred
percent sure that you can still keep
going right even if you of course you
didn't get the response you wanted to
but you can at least take another
request it came in and try again or try
fail a fallback mechanism and so forth
if you don't have time what you just
keep waiting and waiting you're waiting
your thread pools get get also filled up
but then you go down the same way yes
oh I think it needs to be chosen behind
most of the time but yours the
application developed by you you need to
because what you normally you know your
average response times right in then you
yeah add a little bit of gate to account
for network latency blips and so forth
and this is your timer and what it can
also this you can set very slow time
outs but then implement more on a retry
functionality basically so you're
expecting timeouts on a larger scale but
then on the other hand you have better
retry mechanisms in place to trigger
those so are you not agreeing with that
or
I see so yeah yeah no that it totally
makes sense i mean if you have varying
response times i think in if you are in
doubt use a higher timeout but use one
even if it's very high let's see if you
build it but then you can be sure at
some point you pick out right of course
in your case you probably then want to
have more elaborate mechanisms like
shorter time outs and then better retry
functionality so you know on average I
get this response time sometimes I have
these outliers I just stopped but then
we try again right so that that makes
sense but in general having a high time
earth is always better than having no
time at all right it's really your last
line of defense is that the stead answer
the question
you can I mean if you want to get really
fancy you can also set our automatic
timeouts based on on your traffic for
example if you have this if you know
that on average your response times are
500 milliseconds then you add some time
so you're measuring that basically like
a heartbeat you're measuring your
latency of the heartbeat then based on
that you set a time out with with of
course some some more gap that your
accounting for lipsy you can also do
that but most of the time it's fine if
you said I start dick timeout because
very often you you know your average
response times you know your network
latency and then you can you can figure
it out because it's really at this point
in time something already is not this
working is expected so it's not so much
more about giving the user perfect
experience it's read about getting back
into a non error state so we had the
redundancy stuff here and if we're
talking about redundancy we also need to
talk about failover so what you want
with fadeaways you want to basically to
fail over to the render redundant
component and in hardware also if you
give you service with multiple power
units and so forth this is done for you
and software you can do the same in
software what's going to help most of
the time is that you'd have time bound
redundancy because most of them you make
a request it doesn't work you failure
with another component and then you make
a request to failover shares or
something like that so you can do that
but of course buddy what you can also do
is on like egg defective but that's
getting probably really expensive
depending on use case because you would
need to make requests to might be the
Serbs all the time if you do that
because it's so precious then you can
use approaches like voting to actually
get more out of your redundant our
internet request retrying that's another
favorite topic so while true and
retrying or the functional equivalent
whatever is not a good idea because
without waiting you're quickly
overwhelming the target system and it
since the target system is already in a
bad shape you just overwhelming the
system so what do you want to do is you
want to wait until you retry and there
are three common ways to retry the first
one is with a fixed delay like two
seconds and then you wait two seconds in
two seconds two seconds but I
not a fan of that approach but it's the
easiest one and then we have we can do a
linear time out but we can also the
exponential timers actually I'm a really
big fan of exponential timeouts
especially when you do socket retries
because you the first few times you want
to retry very quickly because it could
be there something what going on on the
network which is already gone gone away
and then you can retry to the service
which is already up but then if you see
after few times it's not coming back
then you really want to very quickly
wait longer and longer because it could
be that your service restarting and
whatnot and don't forget with all of
those other than the fixed one apply the
ceiling you always want to have a
ceiling for wintertime it's because
otherwise especially when you use the
exponential one after a few ones you're
already waiting five and ten minutes and
whatnot and then the service comes back
online and you're thinking my
application doesn't work well this
thread is still sleeping because it's
waiting for for the ritual oh okay so
always have realistic thresholds and
boundaries and then this is your last
resort right you can always restart the
system but the trailer for restarting is
really you're losing state and you're
losing time I mean the time one is
obvious but also state is quite
important especially if you have a
system like a cache and you you're
restarting the system you're coming on
with a cold cash and then you need to
spend the time actually warming up the
cash before I can use the system so this
is why it's so important to actually
make error recovery and their education
have running in an online system and of
course you're reducing your availability
and reliability with your starting in
one other option and this thing comes
back with with fail always that of
course if you have parallel services and
you have intelligent feedback mechanisms
and your load balancer for example you
can when you know you need to restart
the system you can instruct your load
balancer to redirect to other
application servers then you restart
that you wait until it warms up and then
you put it back into your cluster so of
course there are ways to reduce the time
but restarting is always I your worst
case scenario another important thing
and now we are coming into mitigation in
the first place is you want to fail fast
you you want to load and give let's
again take requests and responses
because it's easiest to reason about you
want to give partial of uses a great
experience and said all of them a bad
one so the classic example of this is
bonded Q's right you have an umpire that
cute data comes in and you keep you keep
working it through now the Q gets long
and long and long and everyone who is
waiting there will never actually make
it through because let's say they are
running a timer now what they actually
want is you want to shed load you want
to say on your boundary I have a fixed
fixed ask you or I have a ring buffer
with a fixed size and whatever fits in
that fixed size is fine I'll take it and
whatever comes afterwards get rejected
now if you do that if you reject it
immediately it's a good thing because
then your call i get to chance to decide
what he wants to do does he also wants
to beg pressure the error I'm to someone
else or does he want to implement retry
logic but if you let him in your
queue and then you reject them 10
seconds later this is the ten-second
lost where your caller could actually do
something else in the meantime yes no
because the retry part is on your caller
side but this part is on the receiving
side right and if you do that you it's
actually it's working perfect together
because if you have fast timeouts and
you have failed fast on the other side
you have very quick information exchange
and you can make very educated guesses
on your caller side to retry or to back
off not I mean that's this one one way
but also let's let's take the java sdk
for example also again you are using a
method called you're saying give me this
this document and whatnot and inside of
course we need to do a lot of magic so
what we have on the outer boundary is a
ring buffer now when we when we are
overwhelmed taking data out of the ring
bar fans heading to the servers and
getting the responses it winds up and up
and up because maybe you're just pushing
too hard at one point when the ring
buffer is full we are it's basic like a
future and we will immediately counsel
your future saying back pressure
exception something is going on here
then it's up to you to decide but we are
still in the same jvm right it's not
talking to another service you can use
the same approach and this is where
things like message passing coming so
nice because when you're doing message
passing exclusive in your application
you can apply the same mechanisms to a
service that is
running on another machine maybe it's
running in the same jvm you don't care
you can apply the same mechanisms and
you're much more pushed towards writing
resilient applications and this way a
language is like Ellen also nice because
they are kicking your directly in the
direction to to do this for things like
Java and so forth you need to do much
more manual stuff to get it get there
but of course you can do it in any
language so this is how we're doing back
pressure it's it's not so quite
important and now they affect and I
quickly want to cover this if you're
using bonded cues or ring buffers and
you can use it for to reduce the
contention and this is on your IO
devices so imagine um you have let's say
I'm producer threads so so your
application threads are asking for data
they're sending requests into our tower
client for example now if they all talk
to the same io device or event loops we
would get a lot of contention on those
but what we can do is we're putting this
ring buffer in the middle and not only
we can do very quick back pressure but
we can also do is we have this one
patching thread which is taking data out
of the ring buffer and sending to the IO
now what it can do is when the subscribe
is slower than the publishers the ring
buffer gets full and full and when the
subscriber comes back it can take more
and more data at the same time put
Mohamed Atta at the same time down to
the i/o device and in turn we get nice
effects like a TCP bitching
characteristics and so forth so these
are ways to basically eat by picking the
right data structures you can mitigate
lots of errors in the first place and
you can make sure you're basically
you're building intelligent applications
that even they cannot really remove the
arrows completely but they can help you
to get also out of an error condition
much more quickly right and you're
preventing things like contention
installation in the first place but
don't need like this a quick thing like
a case study history history since the
library develop a netflix to actually
build resilient distributed systems now
what they do is they they have something
called a command then it wraps your data
now what it has it has a circuit break
at the circuit breaker and works like
this when data goes through and
everything is fine the circuit is closed
and it
just humming along nicely now there is a
feedback loop into the circuit breaker
which which tracks latency response
times and so forth so it actually has
metrics to work with now let's say the
request failed for some reason the
circuit breaker will open so the circuit
will open and all traffic that's going
through will be rejected immediately
they were again with failing fast
because if this if we get a better
response and you kind of choose you can
tweak those threshold saying after
specific amount requests failed I want
to open it and so forth now if it's
rejected we fail our our command
immediately and then it's up to the
users what to do it you can define
fallbacks you can probably do another
command and so forth and then after some
time the circuit breaker lets one
operation go through and see estas it
come back if not we keep failing and
then we basically if this one operation
succeeds then we can put one more on it
and then the circuit breaker will work
again so it's really a very intelligent
way to to fail fast when you have an
error and you get the matrix feedback
loop at the same time and if you for
example use hystrix then you
automatically have the dashboard they'd
you've seen before because it's exposing
these metrics and then you can aggregate
them so you basically you you solve more
problems at the same time you have to
fail fast and then they were heading
characteristics you have to fall back
mechanisms built in so you can do fixed
for bags you can you can fall back to a
blocking coil you can fall back to an
asynchronous course you can come you can
compose them and and then you also get
the matrix now there is much more we can
also talk about there is recovery so you
when you're doing a recovery you can
roll back roll forward checkpoints you
can you can do checkpoints in your code
to make sure you don't have to roll back
to all of the points you can reset your
data for data mitigation I quickly
already talked about bond queuing so you
want to bond accuse you can do expansive
controls so you can dynamically scale
your systems if you need more or more
resources and you can shrink them down
to make sure not everything starves you
can mark data is corrupted sometimes it
makes sense to not trigger a recovery
immediately but also to mark
quest as in valley just market and then
move it over because the atmosphere this
is probably intelligent enough to work
with it right and you can use
error-correcting codes which is more and
whatever kind of thing so I recommended
reading I have two books which I
recommend for you the first one is
patterns for falter and software by
Robert Helmer if if you like those
patterns and and the kind of things to
work with this book is really the way to
go it it's it's not super dry but of
course it's more Peyton focused and then
there is a book called release it by
Michael new guard which talks about the
same things but in a more I'm
conversational style he includes war
stories from from him working with
Alliance and so forth what happened
failure and and so forth so this is I
think if you want to get a get a nice
start start with it and then move over
to patterns if you're ready into the
topic you probably want to check out the
other person the other one is really
more reference also to go look because
you read it once and then you see over
there is this pay tonight look it up and
then I implemented it any questions yes
so yeah the question was talking about
costs between resilient and non
resilient systems so that I I didn't
include this topic because it's it's a
whole topic on itself but of course the
cost is for doing resilient systems that
they cost is development costs right but
you're very strictly need to compare it
to what actually does it cost my my
business when the thing is down right
and if you make those if you make those
calculations very often the argument is
towards building resilient systems right
because there is not only cost at the
stake but there's also reputation and so
forth now I would I would one thing I
would suggest is also you don't have to
when you do this fault tolerant checks
and what can go wrong you don't have to
fix all of those right you can do 8020
rule I can't most of the time I can fix
eighty percent of my failures my errors
before they become failures at a
reasonable amount of course and then the
other twenty percent if I know them then
I can quantify them and see if this
maybe this event is not going to happen
want in five months not worth fixing it
someone will restart the server because
fixing it will take like seven weeks of
work and no one is going to do that
right so sorry it's hard to quantify but
of course that the main cost is during
development you need to spend effort
architect in Eden a resilient where you
need to implement those patterns if
you're picking a language we tell some
of those you can reduce the cost but of
course it's there my experience is that
if you start really with with these with
these things and and you already baked
it into your architecture from a green
field approach the cost is much lower
then if you actually bake in these
things in a full-blown application which
is already out there if you do that i
would recommend starting with things
like make sure on your boundaries you
have timeouts and then you define your
units of mitigation then you see all
those parts in my system are the most
important ones then you start with those
and every everything you can apply from
those patterns to make it more resilient
is a good thing right
okay then just talk to me afterwards</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>