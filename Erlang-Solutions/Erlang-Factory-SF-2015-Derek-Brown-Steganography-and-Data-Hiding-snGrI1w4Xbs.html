<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2015 - Derek Brown - Steganography and Data Hiding | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2015 - Derek Brown - Steganography and Data Hiding - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2015 - Derek Brown - Steganography and Data Hiding</b></h2><h5 class="post__date">2015-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/snGrI1w4Xbs" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right so my name is Derrick brown
we'll be talking about
steganography with her line so feel free
anytime to butt in with any questions of
Q&amp;amp;A at the end but feel free anytime
so overview we just unlocked
steganography concealing a message in
another file or medium we'll talk more
about that in a moment
we'll go over some general ideas two
types of steganography within images and
within a network ICMP packets and code
samples and some demos and all the code
looking at will be on well it is on
github - and a link at the end as well
for the slides as well so examples of
techniques we can use the low order bits
of image files that we're going to look
at feels and network packets as well the
echo in sound files manipulate the echo
digitally and pull information from
there
whitespace trailing whitespace on a line
within words you can interpret that to
be you know zero or one XML whether you
close a tag or have two separate tags
all that kind of thing can be used to
infer you know a binary zero one or
bytes to read some uses watermarking for
copyright purposes babies communication
when might be monitored or prohibited
from communicating from within
yes certain states say or whistleblowers
that kind of thing or just were fine
they're just going to do this kind of
stuff um so I had a lot of fun writing
this code stack analysis detecting
messages hidden with these techniques
very simply if you could compare the
source file to the you know the suspect
file that'd be easy way to detect it
statistical analysis some you know
techniques to walk and look at but um it
could you know revealed anomalies in the
characteristics of the file and so I
should say that you know this code is
really approve of concepts and it's
functional no pun intended and it works
but I don't make any claims that its
ability to withstand any kind of big
analysis so I'm just it works it's fun
but I just keep in mind
so first out in betting data in the low
order bits of unaged take the bits of
the source file and bet them in the
image just in the low order bit of each
byte very simple procedure the lower
door bit of each byte embed one bit from
the source extracting it just to reverse
take the lower door bit pull it out
every eight bits is a bite
you can we can reconstruct it and I said
that way we'll be using evan Miller's
Earle image library for the basic
reading and writing up the PNG so so
we'll do a little demo first let's just
see this in action
we've lost the display again
okay great so let's say we have this
file an oculus file looks like a you
know some kind of you know regular photo
let's see what's what's in here
so you just large enough to to make out
okay so okay so they start up the app
that we've written and which is on
github I'll load it first just so I can
do it tap completion
so read and write the message so we're
reading the message from in innocuous
and let's write it out - I wouldn't know
this is it's a mystery out okay great so
now we have this file it any any binary
data it could be encoded in in here so
we don't necessarily know what it is so
we have this final we've extracted okay
we can use the file utility it's a good
idea what it is okay so this is there's
a PNG so let's move it to a PNG okay so
gets tracked to this file what is it
I'll look what was there alright cool
like a cool message great okay there's a
little demo of extracting no but look at
some how to how to do the embed in the
first place
great okay so we're reading the
low-order bytes of lower bits of bytes
in this message when do you stop how do
you know when to stop you can't read to
the end you don't necessarily need to be
to the end of a you know your source
file and because it's going to be hard
to stop some point so what we can do we
can include a two byte header in the the
output doesn't representing how many
bytes are encoded in here using two
bytes were limited to number of you know
source bytes we can use that's an
implementation detail back here this
header could be expanded to allow
greater source new source files so what
your message is too big and there's not
enough bytes in this you know your your
image to to fit your to fit your message
okay so instead of just a one low order
byte include Norton you know and low
order bytes in each to include your
message you can fit more data that way
but the more you know you alter your
image the more it should be visually
apparent so some trade-offs okay so we
don't look all these numbers so another
demo so we can look at how how upping
this bits per byte can affect things so
let's say we have a 300 300 image which
i created with gimp 90,000 pixels it's a
three bytes per pixel that's you know
right large number of bytes minus 40 for
the header I say well we'll get into
that in a moment what else is gonna be
in our header so ultimately we calculate
we have 33,000 max size that we can
embed in here so let's we'll do
something like this there's a dummy data
file which I created our all-black
source file and I'll put it into this
demo to PNG as well see in a minute
though this demo to that debt is too big
so it'll fail so we'll have to do is use
this bits per byte option so let's try
this and then we'll see how the image
changes as we increase this
okay so so as I said this data file is
just arbitrary binary data it could be
anything and let's see so our source
file which will embed in is this all
black so again
so here we have an ad message from a
file the file routing from is demo2
we're embedding it into this all-black
file and outputting it into demo 2 dot
PNG and so as we saw we got this error
it's in 15 sufficient image size because
this dit input files too large so as we
saw we can just include an option to
increase the number of bits that world
that we'll be replacing its so let's say
we just too great okay so we would place
the too low order bits probably don't
expect that to change the image too much
so again it looks pretty pretty black
still and since we're sorry on the top
of the image that's what we would expect
to see any any changes okay so just for
instructional purposes that's up this
let's see the low order for bits still
can't really see any changes order five
bits okay so I'm starting to see some
changes here
I think that's six will would be a lot
more visible so you can see as you can
code more data it's really affecting the
image a lot more and we'll see this with
a real image a little bit later on too
okay so and then we have more options
that we'll see how to maybe minimize the
dividual impact terrible we'll get to
shortly
right so as I said we can increase the
mr. right and I'd say like visually
effects things okay so another concept
here what if the top of the image like
this of the bill that we hadn't in the
beginning what at the top of the image
is you know not very noisy and it would
be very apparent if changes have been
made there okay so we'll just move down
the bitch that were altering just don't
start the beginning start a little
further down that could be useful also
we'll see as we saw at the top of the
image was changed if it's a very dense
densely packed section you know section
of thing had just been changed it's a
little more visible way to get around
that just space the bytes out and their
destination bytes so they're not all
there your modified bytes or not
consecutive but they're just spaced up
to the to the imager might make things a
little bit a little bit uh not as
visible okay so I'll see some examples
of that and a bit so some of the code
will be using two entry level entry
points to encode for a file which we did
just a minute ago or you could just have
this message variable in memory and just
encode from there and so I said we're
using the Earle image library just
distant background here's some basic
basically it works um loaded image from
a path it happens to return this Earle
image record it contains Earle pixmap
record
we'll see what are the contents of that
in a moment and it's really a list of
lists of vyse pixels and so for our
purposes we'll break that out and it
will maintain the state as we walk
through the image replacing bits well
walk through this list of pixels so when
we have the bits from the message your
own code your encoding what we want to
do we want to take each bit and consider
it destined for some destination byte
and then bit number that's where it
wants to go so we want to take the
source and create a list of these tuples
consisting of you know destination byte
number the bits going to go in and then
you're coding there so then given that
you just apply it to the source file and
replace the given bits any questions
about this so far or approach okay so I
definitely header before we have yeah
I'm sorry yes right yeah so I use P&amp;amp;G
because there was a simple library to
use but you could do the same thing with
bitmaps or other other formats right
right yeah so yeah you can take take the
same techniques with just different
formats and it might be work better
perhaps but and the general ideas were
probably I'll apply right so the header
we mentioned we're gonna have to encode
in this header to be used by the the
receiver side number of bytes right
we're pulling out the offset how you
know where an image is gonna be how far
they're spaced apart and at how many
bits per byte and so this will be a
total of 40 40 bytes and taking all this
information we'll just encode it in the
low order bit of each for each first of
the 40 bytes so for example the first 16
bits will be a length as we saw followed
by the offset percent so that goes in
the 16 through the 23rd byte we're just
using the low order byte the zero
thought is there a fit for these headers
and this is a low little-endian so one
zero one will be a five so that gets
that's what gets inserted in the
destination
so we'll do a similar similar concept
for the message itself create a list of
the bits from the message first step
then given the options that you want to
use create the same kind of list of
destination bite and bit if I like
combine the two and then once you have
combined this recipe then you can walk
through your source image and set them
as desired so a little bit of code
taking the message bits from your source
as we use the list comprehension over
well okay for a given byte consider it
eight bits long pull out each bit one by
one and result in a eight eight list of
length 8 so that's one byte we're gonna
do for the whole message so we'll just
map over the entire message using the
same list comprehension to pull out all
the bits
the integers are big endian there but
we're using a little and little endian
everywhere it's for simplicity so we'll
flip you know do a list reverse here and
finally if that's a list of lists then
we flatten into one lists then we have a
list of the bits of the entire source
message here any questions on those
procedures okay so that was the bits now
the second step is I was saying we want
to decide what's the destination where
these bits gonna go so we want to create
here is a list of byte number bit numb
destinations the byte numb it goes on
starts at the offset after the header
each byte will be will use bits per byte
times 1 bit per byte each byte gets one
bit it's - yes - and then after each
byte you move on by the spacing to the
next byte later that you're setting the
value for ok great
so for example let's say in our options
we specified offset of - meaning it
comes to after to 2% from or in this
case it's 2 by 2 by 2 bytes from this
start of the data - spacings - apart and
2 bits per byte so if 40 is the first
byte 42 it's offset of 2 and then the 0
and 1 indicate the 0th and the first but
bit move on to 44 46 48 the same way and
that represents the options that we have
you been there so given those two lists
of the bits and of the locations we want
to combine then into this combined
output list so our o-line question any
thoughts of how take these first two
rows and get the third standard library
yeah okay zip it up so given the
locations in the bits we're taking the
tuple in the bit and just combine them
it's pretty straightforward so once we
have that then we can just do it apply
that to the input pixels and I was
mentioning the oral image library has
you know this pics Matt yeah records
containing the pixels the format is a
solicit of row num binary bytes tuple so
this is the first row 0 and then that's
a binary of the the contents of the row
so okay really just do it
so the first tuple walk in your your
source image to down to the byte number
you want to set so we have this it now
this is a a binary as we saw of the
bytes want to pull out what comes before
the destination bite the bite itself
that we're gonna be setting and then
what comes after it so we did that and
then on the byte you pulled out set the
desired bit okay so don't really just do
it so for each tuple oh oh yeah
so then given prefix in the byte you
just set in the postfix recreate the the
the row that you pulled out of the image
just a binary that didn't binary
notation okay great so that was writing
an image embedding in an image so now we
can move on to pulling out from that so
similarly will prepare aspect of what
bytes and bits were pulling from well
this is an header so I'll pull up the
header which specil would know how to
how to interpret the the bytes of the
message weight this create this
specification read the bits then convert
each bit list of bits into an inch using
a binary comprehension here so since
we're using everything little-endian we
need a ripper to be big endian you know
for our output int
take one day at a time and it results in
it bit into value Calvin it so we pulled
that out from the header so given that
we can create a recipe for the source
bytes in the bits we want to extract
from read those bits and convert this
list of bits into groups of eight bytes
which is our output okay so another demo
will use this real an image of a
building might be a little more
interesting
so we'll vary the space and the offset
as well as the bits per byte and see how
this affects with how the output looks
and after we finished this we'll move on
to the the ICMP network network part of
the program alright so we'll use this
arbitrary input binary file again and
will be embedding it into this this is
the source source image that's not not
been tampered with yet so okay let's see
who do this
so another arbitrary binary files could
be anything demo 3 it's going into this
building and source and it will the up
will be demo 3 PNG and we want to change
some of these options so bits per byte
let's try 6 see how things look alright
so we outputs demo 3 PNG let's take a
look okay so that's that's very visible
cuz we use 6 bits we alter 6 bits of
each byte so it's very visible we could
you know lower that state of four and
might see some difference alright not
quite as visible well let's say our
input was still large we really had to
alter so many bits of a byte we can use
some of the other options to try to just
make that a little less a little less
visible so our one option was space them
out a little bit so say we space them
every six apart
all right so everybody spread out the
altered bits here now it's still visible
because we're using altering so many
bits but I just spread it out a little
bit
similarly we could just shift it down
let's say the lower part of the image
was a little more noisy let's say let's
go down 30% okay so we just see the
altered part and shift it down and that
may be useful if the image just annoys
or somewhere else so that's some of the
things you can do with altering you know
bits of an image before we move on to
the ICMP network stuff any questions on
this image manipulation I are using them
separately here you could use both yeah
yeah I'm just just four yeah you could
have the offset how the spacing just
provide all together right yeah no no
I've only only was on the PNG here but
yeah that's that's a separate concern of
whether it's lossy or not yeah yeah no I
have not but yeah just repeating jeez
but yeah I'm sure right yeah so that
question was have I tried it with JPEGs
which are lossy but no in the other
question was how about we didn't
complete and combine the options offset
and spacing but you could combine them
all together okay so that's one
straightforward way of embedding data
our next thing we're gonna look at it's
very cool embedding in ICMP echo packets
ICMP is the internet control message
protocol sits on top of and as part of
the IP packets what we're doing here was
motivated by an article by Craig Rowland
which goes over some of these concepts I
don't think at the end so ICMP is used
by devices for communicating status and
information such as destination
unreachable redirects or test reach
ability with an echo which we will be
using here which often help ping the
ping command is implanted as well so the
specification of an echo request
eight bits for the type which is defined
for requests needs to be 8
the code must be as defined this must be
zero the checksum depending on the data
then we have an arbitrary identifier
arbitrary sequence number and arbitrary
payload so we'll use some of these
values to see where we can stick data so
first let's take a look at what what up
you know what a echo packet looks like
then we can use TCP dump to watch the
traffic coming over from a ping as we
execute it so let's try that and that
will be useful for what we're gonna do
and so I'm doing this all locally I'm
put a simpler but this could easily be
done just across the internet 20 C 2
instance or anywhere else you see - for
example you know by default blocks i
sync the traffic so if you're doing that
you would need to manually open manually
allow it tell out these attackers to go
through so let's see we'd so how'd this
command I had run before I'm on TCP dump
need a run at sudo - X affects the
output the interface is they'll look
back and then we can filter here on the
ICMP type of an echo request so pseudo
consort okay so now we're listening for
incoming echo requests
okay so let's just we won't use articled
yet we'll just do a standard ping and
see see what yeah yeah it looks like so
let's say just well that means one
packet and so we can see what the
payload looks like we can set the
payload to anything they want so I'll
set it to all ones okay so here's the
result so we'll see how the FS that's
the payload and we won't and break it
down but everything before that is the
header of the attacker great so we'll be
a TCP dump running so we'll see when we
send our own packets across how they
look
all right so given this definition of a
packet and the initial thoughts on how
are we gonna shove data to send it
across for retrieval on the other side
some of these fields are required type
can change code can't change checksum is
required have some other options they
yet possible right yeah so any of these
last three would be possible identify
our sequence
I think payload would be the most the
easiest first guess just so arbitrary
data it can be of any length so let's
take a look at that first payload okay
so let's do a little demo
well we roll on what the one window will
start our receive server specifying to
use the payload technique which we which
we defined in our code then we'll send
send the message across also saying
embedded in the payload and we'll see
how we receive it then we'll move on to
two other techniques that are maybe a
little bit not quite as obvious as as
payload alright
okay so start off our half and
okay it says started receive using this
pelo technique okay so now that's using
the gen I see ICMP package underneath to
loosen listen almost the network and I
will send the message across
okay send it to ourselves using pelo
technique and let's send it a little
cool message sure being forever okay so
we saw up in the top window here we
received the message from the payload
and then you dump output we can see
pretty clearly what we just received so
it went across on the packet but you
know there it is so what can we do about
that right so it's pretty visible some
other options so as I said we're using
this gen ICMP package abusing gen UDP
for great good I'm only very slightly
paraphrasing the author of this package
- Michael Santos he's he's not phrase
but uh he's using the OTP gen UDP under
the under the hood to do this as well as
some of his other libraries like pocket
and pkt to create the packets we using
it for echo request it can be used for
any other of the ICMP message attached
as well so under the hood what we're
doing using this package we open a
socket from it create a packet an echo
packet which is by specifying the family
I net the ID sequence number tin payload
we'd looked at ID sequence number and
payload as possible options for where we
can fish up stuff then just call a send
and if you have more data
repeat receive very similar open hollow
receive on the library and returns a
packet to you so what we're doing in the
payload here the ideal that we'll be
using is just random for a given message
often like in UNIX the ID might be the
pit of the sending process doesn't the
receiver doesn't care about it
sequence number will increase starting
from zero for each packet we send we'll
just increased from zero which is
standard and the payload is the data
receive will be using another of
michaeles packages at peak 82
break the part the received packet into
the headers and the payload and the
payloads all we care about here and then
just convert its return binary it into a
list okay so that's relatively
straightforward but as we saw it's too
visible with some other options someone
mentioned ID and that's yes what I
looked at myself so instead of the
payload let's make it a little less
visible what we're sending over I put it
in this two byte identifier field so to
send these two bytes of the message
since we have a two by two identifiers
field
stick it in there by if we have two
bytes just do some bit manipulation here
shift left the first then or it with the
second Stevens number will be zero and
the payload doesn't matter so it can be
arbitrary received very similar D
capsulate the packet pull out from the
16-bit ID and then n the two bytes of
what we were looking for so well let's
look at an example of this as well we'll
start there start the receive server
specify use identify and send a message
over so I won't be quite as visible as
the payload but may not be ideal
oh and so I also have a notion of the
receiver doesn't know how much data is
coming across so we can you know you can
get one packet later on another packet
and you want to see what has come across
so far okay and that's what we've
received so far but for this next test
you can just throw that out and clear
that state and we had also been
listening on that network on the network
we want to stop it since we'll be
spawning another process to listen I'm
using other technique and we don't want
to have two processes listening for the
same for the same data so so now I'll
tell our code here look for the
identifier okay and all we need to
change is on the receiver side just
specify the technique as well and let's
watch it in the TCP dump okay so we see
it going across two bytes at a time and
we received two bytes at a time and then
TCP dump we can see that data as well
right here be e and for e VA and the
payload here is arbitrary ABC has two
payload so anyone looking at you know
this network traffic is not quite a
visible but still we're literally
sending the data across that way so we
can do better from that
right it's still visible just less so
other options can we communicate the
data without directly sending the bits
of the message across any thoughts on
how we can communicate data without
literally sending it yes Joe I'm sorry
timing that's great idea right right yes
yep yep
so you said then you can infer infer
this right yep you can infer the zero
the one from from something like that
right right okay so one comment was
changing or the okay yeah changing yeah
changing the the expected order of
things that could be interpreted as
indicating a byte or Joe suggested
changing the sequence sequence number oh
yeah or the check zone right all right
yeah yeah changing the
the encoding table although the data
were sending needs to be communicated
within this packet structure right so we
have like the payload we can use or
identify or we died just to be more
relevant to the image file
Yeah right by tending the encoding table
okay I want to think about what it's
given the bits of the message had
communicate that across so away some
techniques that timing checksum I
thought of a few of these things instead
what I coded up here was using the
parody of the length of the payload even
length in consider out to be a 0 bit odd
length considered to be one I'm sorry
right yeah yes yeah so
all right right yeah yeah so the
payloads arbitrary him so it could be
you know length one or length two only
three four five but all the parity even
this are on this is all that matters for
what we're gonna do here so therefore
it's a lot slower it takes a package to
send each byte but it's much much less
visible so the payload is arbitrary
yeah the IP packet has a header I think
yeah right yeah yeah the ICMP header
sits on top of Earth on top of the IP
header right yeah so I'm working with
ICMP header here okay so this is fine
I'll take eight packets to send each
byte people see any problems with this
technique given that this is not not a
reliable protocol IP packets right it's
unreliable so packets can be dropped
rerouted if you drop the packet
everything else after that is skewed so
you can no longer consider each eight
bytes it bits to be a bite if you lost
something so we need to know when we're
at a byte boundary so well think about
how to do that so two cents here for the
ID just random doesn't matter sequence
number again increasing room zero the
payload is random but modified the
parody of it to represent the bit you're
sending so under the covers we'll use
some of the same stuff at this end okay
so they receive okay receive we need
information from the header and the
payload here so we get that from the
packet we want the sequence number for
one thing we'll look at in a moment and
we want the payload sequence number we
can use to determine whether or not this
is the first bit of a bite so if we the
sender starts at zero every eight it'll
repeat so if the sequence number is
evenly divisible by 8 it's the first the
first bit of a bite
have the payload and then the bit we
infer from the length of the payload so
then we can use this new bite in the bit
somehow so we need to keep track now
with eight eight packets for each buy
you need to keep track of what's going
on the bits we've got so far as well as
what by Iran and so here we'll use a gen
FSM including an OTP finite state
machine so I'll take a slight aside to
look at a finite state machine it's a
system in one of n states an event
transitions it to some other possibly
the same state for example I say digital
keypad lock and say the state is locked
the event is a crack code entered
transition unlocked locks incorrect code
transferred transition to locked and
similar for other states so use the same
notion of transitioning states to a keep
track of our bits and our the bytes are
building up so for our FSM we'll start
in the state awaiting little bit so I'm
waiting for a little bit to come in
let's say event yeah we were see the
event is to receive a packet and we
determined that it's the low order bit
of the byte because the sequence numbers
evenly divisible by 8 so what we do the
current byte we're building up is just
going to be equal to the bit and then we
increment the bit numb so now we know
we're on the next Vietnam in transition
to the next await higher bit State so
let's say now we're in this way higher
bit State and a higher order bit comes
because not peopling divisible by 8 so
the current byte is now what we had
already or with the current bit shifted
to the right position so we're building
it up slowly over time it's not the 8th
bit command bit number we're on the next
one now otherwise we set it and then the
byte you just built up over eight
packets to return it to the caller for
use this transition either stay and
they'll wait higher bit state or go back
to the wait a little bit if you're if
you're done with a byte just these
concepts stay machining the state
transition make sense any questions
No okay so that's if everything goes
well you receive the package in expected
order what if you're in their way a
little bit state and a higher order bit
comes well you can't do anything if
you've lost packets below it before it
so we just have to ignore it and wait
for the next low order bit to come in so
you you've lost data and your message is
you know corrupted but there's really no
no no choice other situation you're
waiting for a higher bit but I'll order
bit King and somehow PACs were lost so
you can't do anything really again
except it's reset things and handle it
as if you had been waiting for this
lowered a bit in the first place and
then just continue on to wait for a
higher bits so the air conditioners need
to handle because of this unreliable
traffic but and you might lose data but
it's not much way around it so this is a
much slower technique but we'll see us
not well not obvious in that the date
you never literally going to see the
data coming across
okay so again stop and now we'll start
again
using our other technique payload then
okay and let's watch the traffic come
across and now this is going to be a lot
slower it's gonna take a packet Servite
and I'm using this that typical like 1
second delay between between pings echo
requests so let's shorten this just a
little bit and we're using our payload
length technique and send it so we can
see in our receiver it's receiving one
bit at a time until receives 8 and we
got a B then we see on the other side ok
then we also see what we're sending the
payload we're sending just is this a
random random bytes whose length is even
or odd depending on what we're sending
and then if we seen the TCP dump we can
see we match over the payload we see it
over there
so we receive de a ok so now we don't
know on the receiver side if more is
gonna come but we can see what's come so
far oh we didn't clear from the last
shot we had the beam forever from the
last run as well as beam from this run
and then over here you know payload is
just arbitrary we need to know ourselves
how to interpret this to pull out yeah
and this message and yeah
questions or thoughts on that yes
if you would use one of the earlier
techniques working the payload and just
send if you send a PG be encrypted
message was there question yeah so yeah
well we did we descend the message in
the clear and so we have see it in the
payload or the identifier yes you could
certainly encrypt the data so it
wouldn't visually be the obvious but
that would still leave open the
possibility of anyone looking at the
traffic noticing that there's some
cryptic messages here which maybe they
couldn't decrypt but it might set off
you know set off you know alarms that
something untoward is going on here so
that's true yeah you could try to mask
the you would add renovate at the
payload as well as the encrypted message
just to try to mask it a little bit yeah
you could right yeah there's many many
ways you can go about this right or you
could you know encrypt the data and then
use this last technique and send one bit
at a time very very slow but if you ever
fairly reliable network and you don't
worry about losing packets it would
still you know that would still work
okay so that was two techniques with
time for some questions if any questions
about what we looked at
some questions what is like what really
is the purpose will be the point of
doing the second network technique I
mean for someone well not watermarking
obviously but using hiding data like
this could be if in either case could be
used for you know for good for anyone
like in a summer press state and used to
communicate on the outside whistleblower
or somehow you know it could be used for
that as well is anything good but and I
guess there's some plausible deniability
here maybe someones say the receivers
somewhere in the world listening for
someone else to be sending this ICMP
traffic across there just receiving the
message you know and they can interpret
it as they want without emailing the
file or you know communicating some file
which is a more direct communication
this will more indirect I think is the
idea is I mean yeah yeah
Yeah right yeah right so yeah like so
you're saying someone's watching it
wouldn't necessarily mean anything but
if both sides know how it's being
communicated then it can be we
reinterpret right yeah so yes the that's
that's true yeah so the comment is you
would stay in the second situation
you're still the two sides that still
need to know about each other and you
would still be sending a message from
one side to the receiver so it's not
right
that's area so it's not entirely you
know transparent but and so l so in this
technique the receiver and the sender
need to be synched up on the technique
whether you're sending on the pillow is
sending it via the parity is you know so
I think you know what when it's being
sent you know you know what the end
point is so it's there's still some
communication that needs to be done
out-of-band somehow but if the two sides
know how they're communicating then that
would that would still work that answer
your thought okay yeah so it's not
entirely transparent but right yeah
thanks yeah and so the reference is
talked about a lot of the stuff the
this first article here gave me a lot of
ideas about can getting data open also
I'll put this on it well it's on github
now so you'll see all this give me a lot
of ideas about um encoding and network
headers and whatnot some really
interesting stuff so take a look so it's
all good hub now I'll put up the slides
there as well and write it on the
conference page as well alright oh and I
support the first here is my a repo I'm
Derek went to one github it'll be on the
calendar conference page any final
thoughts okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>