<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2016 - Point Of No Local Return  The Continuing Story Of Erlang Type Systems | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2016 - Point Of No Local Return  The Continuing Story Of Erlang Type Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2016 - Point Of No Local Return  The Continuing Story Of Erlang Type Systems</b></h2><h5 class="post__date">2016-03-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-8jLRThHuFQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody how's it going today you
guys hear me okay i'm usually nothing to
be super loud so yeah it's great okay so
i will be talking about continuing story
burling type systems there'll be
obviously a lot of discussion about
dialyzer in here there'll be discussion
some stuff free dialyzer they'll be some
discussion stuff kind of going forward
things that we can look at in the future
for type systems and to be upfront about
this there's so much to cover i could
have covered like when you think of like
here's an early paper on type systems
Erlang it also means there's like a
hundred other papers that it takes from
that we just can't cover all but maybe
if you want to stay after lunch we can
we can just go through the entire
history of types which this is will not
cover but that will be focusing on
various airlines type systems again I'm
zeeshan I created with a couple other
people papers we love which is now
become like a really kind of crazy
phenomenon I guess and we run the New
York one as well and this talk is kind
of models the papers we love talk I
don't get to do papers you love talks
was I organize them so I get to actually
give one so it's pretty neat I also work
at bosch o technologies I work currently
on the crdt team and we're doing some
cool work there won't be talking much
about that so yeah and the preface here
I argue don't know very much in general
I've been doing Erlang for about a year
and you're in change my previous
background was in systems like closure
and Lisp I never actually got to do
everyday work with a real type system
and I have my backgrounds and I have a
music music masters degree and a film
bachelor degree so programming has been
it's a new world for me still so as I
say in this talk if you have thoughts
and things we can make it a little
interactive papers who love talks you
tend to be this way so if you if you
have a couple things you know chime in
totally do it there's nothing like just
me here all the time so I don't know
anything but there's a lot of people
around our line type systems who do
costumes that gave a great talk
yesterday John Hughes who gave a great
talk to
morning George of course Tobias who's on
a lot of the the early types of some
papers Maria who's done a lot of the
cool race detection stuff that's gone on
in the mid-2000s to 2010 and joe devivo
you might have heard of him the title
the title of the talk actually comes
from his post and you know he is he's a
good fan of type systems as well
Marion's a lot of other people so I was
a preparing this talk you to listen to
music like one song over and over and
over again and this one was the saw the
first half of good people there so
that's a long tune your move is the
first single on that and it has these
lyrics that I think some people say
they're about through the looking eye
gouge for the looking glass some people
say it's about drugs and chess it's kind
of also about modeling inter-process
communication and relationships right
don't surround yourself with yourself
move on back to squares send something
send some karma don't surround yourself
time and time and time so you know I was
like it's a good song it kind of gets
you in the mood all right so my first
experience I took a class in Coursera
and programming languages with Dan
Grossman how you recommended and we
either do ml it might that was my first
experience with a strong static type
system if you look at this here and if
you're familiar with the Erlang dialyzer
which I am going off that most people
are to some degree this kind of looks
like things that you would do in
dialyzer with some of your own types the
one interesting thing of note though is
even though we have that underscore
value in NM + ml and this is like a
variation that I ran on standard ml New
Jersey that underscore doesn't mean
anything that underscore means it has to
be something of rank but we don't care
about it here in this pattern match so
something to keep your mind on because
things we can do in Erlang of course
that that underscore could really be
anything and then we know in our lying
that it's a dynamically strong type
language where we can't do things like
this we obviously have these runtime
checks those things we know so you know
it's it's pretty
typical for these things obviously we're
not talking about things like duck
typing stuff like that you would see in
Ruby and whatnot and people love talking
about types and fighting about types and
the wars on types and here's this like a
handful of things I pulled from Twitter
people are hope the Jaden Smith coding
one's my favorite I hope Erlang wins an
Oscar for Best type system I don't know
how that got generated it's a great
Markov generator that's this amazing but
people have been asking for a long time
actually what the sad thing is actually
if you read through these tweets and you
shouldn't is that people complain they
Lobby still think like that early has no
type system at all that you know people
don't know dialyzer exists or as someone
said I don't know if I I think I didn't
put that one on here but someone said it
just helps you out a little bit which is
you know it could actually do a lot more
but interesting things as well VP
unpopular things says I would argue
Erlang and dodge superior to goes type
systems that's I think a really
interesting tidbit and at the end here j
lewis talks about idea of the
non-trivial problem of multi-party
session typing and will actually talk
about that in this talk so it's like hit
at the future so if anyone knows Bob
Harper Bob Harper is a big person behind
ml and the SML spec for many years
hardcore type theorists he says dynamic
typing is but a special case of static
typing basically that there's that
dynamic typing is just one big type the
whole program when it runs in runtime
one that limits rather than liberate one
that shuts down opportunities rather
than opening up new ones if you hang I
have had the pleasure to have a class
with Bob he's a hardcore type theorists
I saw him at a talk at poeple and
academic language thing was a whole
track on gradual typing he was sitting
in and someone asked so what are your
thoughts and gradual typing Bob and Bob
goes oh what I wasn't paying attention
so you know he you know you are going to
have these wars of people on people who
feel certain things and hear from from
when it costs us his papers actually
it's just great quote all's fair in love
and more even trying to add a static
type system to a dynamically typed
programming language so it is always
going to be a war but now we've moved
into this world where we have gradual
typing is kind of a normal thing lots
and lots of languages even JavaScript
has concepts of type system
and actually flow is pretty great it's a
great paper in itself but the term
gradual typing actually didn't was not
going to 2006 and the flow of like is
dialyzer itself a gradual type language
it is but there are actually some
caveats to what gradual typing the
definition has meant to overtime we
won't talk about too much in the stock
but you can see that there that it gives
the programmer the ability to control
which region of the code are dynamic
static Lear dynamic type and enables a
gradual evolution of code between
through typing disciplines okay so
here's an example actually just a
general gradual typing and one of my
other favorite languages which is racket
but racket is probably the most known
gradually type variation type racket is
that's around it can do all kinds of
types it's very expressive it's
composable and you still can write Lisp
and you in racket you have this great
module system where I can have a module
within the rack the type drackett
language or my regular code that's not
and we'll talk about something toward
the end about how there's some cool
things that we can think about 44 Erlang
type systems and simplest of the racket
does with contracts but here is the
basic example I have that distance
function i put in a the wrong type foo
like things I get my type checker my
type mismatch and we're getting
obviously is airline programmers
hopefully use dialyzer we're pretty used
to this for other people especially
people who probably who were programming
a list and program scheme for many days
this is really amazing that we have this
ability to do this in a list language so
let's talk about the past here's a
couple just some brief variables you
might see them throughout I'm not doing
any proofs we're not going to do any
elimination rules we're not going to
know maybe later that stuff's fun but
you have e it's a basic expression
meaning its components fit together
properly according to the rules and you
have your towel which is basically what
this type is once evaluation occurs
you'll see towel a lot so we talked
about the beginnings of the history here
we talked about typing until a soft
typing I mean dialyzer itself and the
contract system everything built and
dialyzer is a well not the kind of
system but dialyzer yourself is a soft
type system in
sense that we try to do use inference to
apply it to the side Emily type
languages so there's a lot of like a
really amazing work in the past car
right in fig and soft typing Aiken and
win MERS inclusion of constraints and
type inferences so the idea is that you
know in soft you know soft typing you're
removing the associated runtime
dispatching that's death doesn't exist
and your focus is on statically catching
type errors that's pretty obvious and
the overall approach of them is that you
normally want types to describe the form
of the data supplied to it and produced
by the program's the association of
types to programs is done by a set of
inference rules these are pretty much
things if you've any types of some of
these things apply as well but in a soft
typing approach I give you my program
the entire program is now susceptible to
inference and that's the the softness of
it in the work that will get to when we
talked about success types principle
typing was actually a huge huge
influence on the work that cost us and
others have done which is this idea of
finding a way to represent all Little
Miss Prather all possible typing's for a
term which this sounds like success
typing right and actually it was this
early work in it as well you know which
is pretty amazing that you see success
by being even talked about things in the
80s not only as a principal type
associate associated environment the
type signature only holds the argument
the application are subtypes of the
arguments of the signature so in some
sense right the environment is exported
from the function to the call site so it
can it can it can basically look you
know when it does when it goes through
its inference it basic and say I can
look at all the points where we call
call these functions these call sites
and we can use that information to help
figure out what is this topmost type
what is this principle type which is a
lot like what happens in dialyzer okay
so the first like Erlang centric type
paper that i found was this master's
thesis in it's a truly a master's thesis
in all its glory a kid in bed by anders
lindgren
where he was trying to prototype a soft
type system for Erlang this is 1996
which is pretty crazy that this was
happening at the time and it doesn't get
too many references mostly because it
doesn't work and I'll talk about that in
a second but you look at these things
are pretty normal like we have foo here
we have a cons they actually had a cons
type this is their application to
thinking of Erlang for those not
familiar cons yeah you see there you're
basically tossing on a list that comes
from the days of Lisp so you have this
concept these things are pretty normal
the sad part like you look at the paper
it has these examples of where i found
type defects and they're pretty much
examples like we can't add true plus one
which is like okay I mean you have to do
that to have a paper I imagine and and
and though there's some interesting
things in here they have this idea of
data types that represent they have the
entire collection of data types even
mapping of all the types to all the type
values that could exist and then you
have these terms which will come back to
actually meet and joint operation you
think of sets you have your upper bounds
and lower bounds basically and you know
the problem they ran into him a little
bit here they use this previous papers
from we talked about win MERS in it and
akin earlier they use a previous
constraint solver called Illyria Greek
mythology and basically like you know
the blame in the paper that Andrews
comes out with is like this prototype
does not work because the constraint
solver could not do these things and
they cannot do simple things like I
can't have a type that's an atom a
specific Adam like if I haven't Adam
that's foo and I want to match on that
as a type that could not happen there
constraint solver could not handle that
and things like it shows here like so
you know it Union flow this is the idea
of a union type we'll talk more about
that we understand that these are the
sets that that's a set of all numbers
but it couldn't do things where you had
a set of all numbers with the union of
another ends its kind of overlapping it
couldn't handle that so one thing really
cool about the paper though is that it
actually models send and receive those
are really large proof rules in the
paper I would not showcasing those but
you'll see
actually that's the thing will kind of
get you in the theme that you'll kind of
see is I was actually really surprised
they were you know trying to do static
time interprocess inter-process types a
lot of the other papers that come
afterward in the air at just I've waited
all together because they think you're
lying processes are hard that's defined
types for so they don't have an
annotation system that's a big
difference they actually reference will
talk about the next of the wobbler the
while their Marlowe paper on types they
actually reference it but they say look
we're not trying to do annotations
there's no specs however though they
tried really hard to extend the Henley
Milner unification based system for
types they tried to add all kinds of
types you have intersection types union
types function types constructor types
and yet it couldn't actually work for a
lot of for a lot for a lot of these but
the ideas were there I imagine at the
end here is the kind of thing of first
systems actually joe armstrong with
thomas arts worked on the system that
debt deck actually took took an
annotation language to generate wet to
generate HTML generate web spec related
stuff i could not find that paper though
and read it but it gets reference in a
couple places okay so this is the paper
that kind of everyone talked about if
you still go on twitter and people who
are haskell people and people from these
other strong seller type languages
they'll be like oh then a Marlo and
Wilder try to do a types isn't for early
I guess they failed it's never going to
we're never going to have a type system
her lying even though they don't know
the actual history and Marvel and
Wohlers work is actually it's pretty
amazing this is a June 97 at ICF p when
they released it and yeah a little bit
the history historian and Joe's history
of relying paper is like Waller had a
year sabbatical he's like I'm going to
add types of airline Joe don't worry
about it and they based it on some of
the same work that we saw in the
previous paper and it has this it has
supportive recursive types and disjoint
unions which we'll talk about in the
next slide it had a type annotation
system which looks kind of like dialyzer
like we know it as today and it had it
brought about the idea of subtyping so
the ideas and my next slide actually
show the different p sub typing and you
but subtyping is what we know is a big
part of dialyzer in this paper does
bring that about and then they have
these constraints where they you know
the whole point of what they do is that
they want to reject code and we'll
should i'll show you some examples so
subtyping as is basically a way to solve
sets of constraints in this form and
you'll see this throughout this
basically like a subset and i have an
image of what subtyping is and if you
know java you know you have a cat you
have an animal you know something about
subtyping so unification is what the
hell milner type systems are really
about where everything has to match in
the entire in the entire spec which is
very different from what's up the
subtyping needs so unification based
systems they they are obviously less
straight they're obviously more strict
than subtyping subtyping is much more
generalized so the example above is a
really simple idea that we know of as a
sub types or example like in Ruby
everything is a subtype of the object
and you can basically have subtypes of
subtypes of subtypes and the bottom here
is actually the subtype system for
dialyzer where you have your any which
is your most upper bound and you have
none which is your least upper bound if
you hit none and dialyzer in and
actually in wilder system as well if you
hit none then you have a type conflict
you have an error but obviously and
while there and marlow's paper they're
more akin to some like old-school ideas
they want to change the way you write
code they're going to reject your
programs unlike something we get instant
success typing so one part I wanted to
bring back is at the end there this is
actually from Jose Armstrong's history
of Erlang they had disappointing results
from from Wilders work so a couple the
key things was it only work on a subset
of Erlang and probably the biggest thing
is that they completely miss anything to
do with send receive and processes they
complete say it's trivial probably later
we're not going to deal with it which
obviously not very feel okay there's
obviously yeah so
so some things we tie would just to get
some of the the vocabulary right so
unification is the process of looking at
each of the constraint and trying to
find a single type that satisfies all of
them so like to unify to type
expressions to find substitutions for
all those variables and make them
identical and in a lot of the work that
like one of the other influences again
papers upon papers upon papers is this
right cart like a thing where they
actually tried to apply an early version
of South typing for scheme it was until
we had things like type racket and the
work they did for dr. scheme later that
actually became type system that we see
now but they were trying to do the same
thing where they were trying to do
subtyping with union types okay so in
the wobbler paper this is actually like
I think the great example this is like
the example that tends to be used on
where it kind of doesn't follow through
hey Costas how's it going you see so at
the top there that's pretty much like
what this spec would look like in the
dialyzer in Erlang the bottom one there
is from the wilder paper where it's just
the idea of this variable X that could
be any type now in the weather paper
they again have subtypes in they have
they come out when they run this they
have the any type and false it gets
their thing and i'll show how they do
that because they basically they you
know they didn't use listen like we're
lying they had their own they have their
own representation that they went to
wear pattern matches became case
statements the sea and a henley miller
system this would be bull comma bull to
bull right that it has to be has to be a
boolean value otherwise we're going to
reject the program while there and marlo
like you'll see a lot in the practical
stuff and Kostas work they did they did
say in the beginning of the paper we
want to make it where it's not hard for
Erlang programmers to move to the system
but when you look at that you look at
and any and false being your type here
when you actually don't when actually
you probably mean maybe the programmer
probably doesn't want this but in your
end you might want to allow a float to
be on the right hand side because that's
a general variable this seems weird and
for them even in the paper they say this
seems really weird so this is an example
of how that end case finds false as the
second one it's mostly due to its
basically specific to that case
statement of why there and how it
figures out the variables okay but this
is like me running it in type or this is
the spec that we imagine which goes to
the least upper bound of this which the
there underscore just means any this
means in any dilator type this is what
we know so that's a pretty it's a pretty
different idea there when you have to
have that false in the in the second
value ok so right kind of before
dialyzer hitch is around the same time
2002 2003 in terms of papers kind of
being worked on the same time Nystrom
had a soft typing system for Erlang this
is yeah 2003 yearling workshop he used
this concept of data flow analysis to
compute for each variable and sub
expression in the program it did you
know like most systems a generated type
expression tried to match against his
expressions with solver it had concepts
for probably morphism it had type
specifications around abstract types
public types unsafe types obviously Java
and things were like influential at the
time he wanted that showcase people that
we have these ideas especially the
public type but like they say and this
is like a common theme for a while it
turns out that specifying the
interaction of an erlang process is
rather difficult so they just skip it
again we're just there it's not worry
about it and I said it has it but one
thing it does in compared as we get to
the dollar so if it has a tons of noise
because you have to annotate at the
specific interface points especially if
you're using something like a public the
public type or whatnot so you have to
annotate those things and as we get into
one more paper before we get the
dialyzer but as dialyzer comes in your
you know that the initial scope of it
before we had contracts it was basically
like we're going to completely use
inference for the whole thing it's
completely soft type you don't have to
worry about annotations no one really
ended up every using this
some and that's what also the dialogic
paper says I haven't found and he use
cases of the system in action and
obviously it's not in use now so around
the same time or two thousand two
actually is this a kind of prototype
idea by john hughes &amp;amp; Co here called
typing Erlang I kind of randomly came
across it toward the end but it asked
this question how do we ensure that the
receive expressions in a process body
expect messages of the correct type so
here's the beginning where though again
the lingering paper actually does try to
model send and receive it and really ask
too many questions about it but here you
have john hughes and typing or like
talking about it and this idea of i have
an expression i have a type and I have
this mu that's what am I what is it
receiving what is the effect of the
method of the type of the message i'm
receiving so results and message types
are associated and they modeled it under
this idea of existential types which are
types that represent modules and records
and they talk about in the paper the
idea of using a unique identifier with
make ref with a unique process which
comes back later when we talk about
session typing actually as you see there
yeah so the towels now so you have two
thousand four you have this paper the
war story the base of the beginning of
dialyzer here and actually it's really
great i mean some of the other papers
you're kind of going in and about round
about now see a lot of relationships to
work in scheme types and whatnot but as
the dialyzer papers come through and I
was telling cosmesis last night it as
they come through there's kind of a
lineage of the work that's happening is
you get the the first paper you get the
experience papers you go into contracts
you go into detecting race condition the
kind of keeps keeps building on each
other so you know these are probably in
the initial paper wasn't using it wasn't
you know doing anything with quarter
lying at the time and actually have this
I code bytecode translation with the
control flow graph it did have the idea
of local analysis versus a persistent
lookup table which is what we still know
of that dash PLT right
it adapted and it was a big thing its
practical adapts the airline code style
it never generates false alarms false
positives which is a key thing and it
sound for defect detection you know
people in type systems will fight over
what sound this is in this case it is
truly sound for defective for defect
detection okay so here is the sum of the
an image of from the paper with the
control flow graph where you have the
airline code on the left you have this
without optimization one and because
they can figure out that we don't need
to hit all these points in the graph we
can we can collapse things we have the
moment with optimization there okay so
kind of in this like trajectory of
papers you have the kind of more
academic like paper on the system the
static analysis themselves and then you
know constant a lot of work where um
team of these experience papers so here
here's one of the first ones and is a
great quote that comes out of it I think
that I got out of it I love that so in
talking about dynamic programming and
why dialyzers modeled to a be backwards
compatible with all that erlang code
again and to not may not change the
characteristics of the programmer it
that program which is right with dynamic
types have this lays a fair style of
programming which i think is you know I
like I hope to consider myself that kind
of person so I think it's pretty good
but what it really relates to with a
policy of letting things take their own
course not intervening with your work
and it's up to you how much you want to
go okay so 2005 we get typer so type
work has the ability to that to actually
give aspects and I'll show have an
example here yeah so you know these are
some simple files you know we never at
bash show for example unfortunately we
never we still have so many things so
many modules lacking types but for some
reason we never use typer and actually
just inject the types in I don't know
why we don't do that I'm thinking about
doing it now it might be scary i don't
know but it's hyper
are you know obviously it comes about
the importance of what dialyzers main
main work is with static analysis is
this idea of disjoint unions which is
what we know of most of time is what
we're what we do work and dialyzer with
when we move right specs or let the
system infer it itself so what that
means the type is the greatest lower
bound of a subtype constraints so we saw
that graph earlier we had any at the top
of the lattice and you had none at the
bottom of the lattice right none again
is when you actually have a type
conflict so the lower bound of the
subtype constraints but then when you
solve this disjunction so in this case
here i have the tao of x which is the
value 42 and an output of true and i
have a disjunction here without in false
so i know that my output is going to be
a boolean value because in these in this
disjunction i can either i can either
have an output of true or false but my
input can be 42 or in the case of the
other one it could be something else so
the way dialyzer works on this is that
again it has all these these destructive
unions where you solve the types the
types within the sub type constraints
first with a lower bound and then when
you do the comparison this is going to
be a bull is this going to be a number
or a value or something else then you
then you do you basically use this
disjunction and find the least upper
bound so in this case here in these
types it could be 42 or any and then
bull right okay so this is if the ideas
of like upper bounds in a set is like
set theory stuff the least upper bound
within the constraints themselves and
will show more examples of actual code
to to make that specific yeah so in the
type of papers a lot of talk about again
never rejecting programs accepted by
beam that type inference is
compositional this is a big difference
between the wobbler Marlowe work as well
and then in this paper is the first time
that the term success typing's really
gets use and there's a whole paper on it
will show show that next so you find the
most general success tape typing's under
constraints use the data flow analysis
to find more refined types so this is
what this is like the 0 if you have to
export a function in the case in the top
one
there I have the export with tag being
that I export main there and I call them
the tag I can have a more refined spec
than in the bottom case where I have
when I'm using fun tag because that
could be that could be used anywhere
okay and again bottom types none or in
really the case no return is what you
should use and according to
documentation that's if you don't if you
want to let something pass you using our
return but in the case of when the
infant and the Emperor runs through if
it hits none or hits no return that's
when you know you have no solutions in
the solver okay so this is like the big
paper i think that brings up the term
success Taipings that the previous one
does it but it's like the one this is p
v DP 2006 so in cases here you know the
whole idea is that i think the quote
from the paper is never trying to
outsmart the programmer and in this case
this is a good example is that we think
length it's the length of a list it has
to be a list it has to be a list type
but not in this case because i can pass
three i can pass pie into n and i gotta
let that go there's a you know some
people find that scary but there's a
beauty to it and obviously the more you
add specs the more you add types the
more refined they be the better the
better annotations to get better type
system you get and this is the paper
where they talk about the move to core
Erlang as well which allows which allows
obviously more integration with the
Erlang ecosystem and then they can do
things with you using actually let rec
and let which gets which is like the
core part of coraline to see here in the
I are you know if anyone's ever done
stuff with quarreling before it's pretty
fun this favorite or length for example
runs in the core airline before it gets
down to beam but it just an immediate
representation that has very specific
things there's no pattern matching just
fits in the cases as well and you have
these idea of letting that wreck where
you can actually specify scope scoping
rules this way okay and from that paper
is this great quote we are instead
interested in capturing the biggest set
of terms for which we can be sure that
type clashes will definitely occur
instead of keeping track of the set we
will design an algorithm that infers is
complement a function success typing
success typing the type signature that
over approximates a set of tight
for what the function can evaluate so
this idea of over approximation is the
key okay so and then that's kind of like
always a thing again it's not going to
outsmart you yeah and the idea the
constraint solver in the papers really
interesting because the idea is to solve
all constraints in the conjunction to
either a fixed point is reached or two
you hit the type class when you hit none
like I talked about before again if you
use dialyzer you might have seen this
but underneath the hood it basically
create it has constraint generation and
the solver and so if the solver does
okay in this paper it brings about some
stuff how to deal with termination so
for example if I as I go as it's
interesting and it tries to figure out
in the traversal of like I have maybe
many many many kinds of Union types
there's a limit to how far you go and
this is oddity of the depth k which is
you know you have a fixed point for you
can't grow larger than any K otherwise
abstract with any types there's a point
where as it goes through that you think
is like some of the recursive types you
can imagine where you need to say stop
because that you want the program to
terminate yeah this isn't determinate so
and infer success items of the functions
by analyzing its nodes which are called
strongly connected components and there
to talk in the paper about types which
were mentioned back in the 96 paper they
were trying to do conditional types of
intersection types but these were not
done at the time and here's just an
example of where things where you start
getting where you use guards and what
not to then have to have these these
types as well and these are the things
that we've seen the bottom is just the
formula the formula logic for it where
you say for every alpha if I have an
integer with a subset of another integer
and Adam where I have this guard so you
basically the guards can just act as
subtyping rules as well ok so in 2007 is
when you get to actually having the
ability for the user to add specs and
this is like I could have just done the
whole talk with this right like I
thought it would've been really great so
you have what success typing is this
kind of restrictive idea you have
dynamic typing which is what we know
that the and success typing because even
an over approximate of that it's like
over approximation dynamic
typing which is like pretty amazing so
the idea this fast typing domain is
using upper bound of the argument types
of at the call site right it's the most
it's the most upper bound that you can
get of these so kind of actually go into
this paper is really interesting as well
because you get some some things that
have changed that the specs look a
little different than they do now that
we're used to but here i have the is
subtype logic which is actually a
deprecated now you're supposed to use
the colon colon which is why i have at
the top but you see here you can even
specify with subtypes like this so in
this purposely error code that I wrote
for an increment for an increment of a
number type I say but give X input of X
oh yeah it's a parametric parametric
vector x type X returns X but that X
should be a subtype of Adam obviously
that's not true in the actual code this
is running it through typer and type or
gives me the inferred signature a number
to a number so contracts which is what
it called and you know I think it's
pretty great because I I've always
thought of it as I came into Erlang we
specs annotations but contracts
themselves is a huge thing and obviously
in the in the scheme in racket world
that's everything is called contracts
but a lot of the work they're doing is
around contracts there's a lot of new
work on contracts but here is actually
the paper where we have the ability to
have we have function types we have
polymorphic contracts you know I always
thought this one and the Erlang docks is
really great where you have the ID of X
returns and X returns whatever this
returns the same X with that X is at
uppal which means it has to return the
same couple it's a dummy example but I
always think it's kind of fun that these
things do I mean it's actually really
sex that was going through this talk and
you know a bachelor we have a lot of
Erlang and not only do we maybe lacked
some spit you know we lacked some specs
we lack you know we we throw away third
party dependencies all the time because
we don't want to work with those and we
are even some of our own sub libraries
but actually I think modeling these
polymorphic contracts would be really
really great and we should do more of
that I don't see that a much earlier
Kodak
is actually pretty powerful so in the
same idea we have a contract overloading
right so you can do things there we
again those guards match but I can my
contract and take these multiple types
and you can you can either make that you
can obviously make that pretty pretty
refined but this allowed for probably
more refining and then you have another
experience report on the work on
Wrangler but here you tested real
objects exposing their type information
and working to the process right so the
same thing you should do is you go
through your airline code you should
start you have you know you have
dialyzer it's going to do the inference
for you but you also should then start
adding guards where you can add guards
export you know be good about your
exporting what you want to export so
that to the help the data flow analysis
but then in this paper as the constants
does he works through the adding type
declaration and contracts they get the
most refined version of the Wrangler co
that they can so in the Evans talk at
the keynote this is like a paper that I
was kind of I didn't I came by was kind
of surprised by and now going a little
bit out of order cause of the some cool
stuff with the rates condition detection
that comes that comes before this paper
but I think in order it makes more sense
to showcase it like this so we saw Evan
stock where this height and they has a
great post called compilers of
assistance so you know there's a thought
of why can't type systems also happy
assistance as well I'm Peter Norvig is
talked about this bunch there's this
paper which is not which is like you is
not used it's not used as my main part
of that you know that when you download
dialyzer now there is a version of it
that you can download this is the idea
of program slicing to give you example
first and i'll define it but we see we
have this function here which is going
to have an error but so dialyzer if you
look at the top part so it says the
pattern one can never match the variable
Y can never match those things I
dialyzer will normally give you but when
they were working with program slicing
it's still like kind of a prototype on
stuff but you have this ability to get
the lineage of where the erring would
have
went wrong and program slicing is a
thing I don't even know much about it
till I win through this for this talk
and I'm like I really want to do a lot
more research on it's really interesting
and what it was like from wikipedia it's
a the computation a set of program to
statements the program slice that may
affect the value of some point of
interest and we they call it the slicing
criterion and usually program slicing is
used for debugging which makes complete
sense why you might want to use in
something like it's like dialyzer so the
next graph shows the the system they
built for it in that paper but basically
you have to label all the parts of the
function and they have this labeling
done as a kind of version of a labeled
quarter lang so this is the the entire
compilation process to surround this
paper is it there's a pretty dense paper
by the way it was actually all of my
thing one of the densest but also I
didn't have much knowledge before hand
on this but Earl and quarreling you have
that labeling component which which is
on core Erlang you have the you know
haggar generation is all typical stuff
that we see in dialyzer but except for
this part after the constraint solving
where you have these slices and then you
refine these slices because if once you
have an error so that's like the third
phase right the the parameterised
program slicing once you have a set of
errors you don't want to throw it you
don't want to give back the entire
lineage of all the all the all the code
that would have been within that area
you want to add a refined type of only
the lines of code that affect the the
air the air type conflict which again in
this case here it's not every line of
code from here that we get back we get
we get back only those that were labeled
and specific to the type clash okay so
in a lot of in a lot of these papers and
I think the really interesting theme
that kind of came about for me was that
we were moving yeah there's some suffer
rents them receive and process these
types across processes you again you see
some of the papers the earlier papers
kind of just go it's too hard it's too
difficult so then you start getting some
work where even the casus in team and
maria here had a lot of great work where
they're trying to do trying to detect
things around race conditions this is in
2011 and there is this option right with
race conditions that you can have on
I was surprised to look at bachelor code
where we actually removed that from her
entire build system of a build system
with dialyzer but race conditions was
gone for actually react CS and the
reason was I looked yeah I was like oh
archaeology here look at some history
and the reason was it took too long
which before I explain what it does i
mean i think it's basically if you look
in the docks it has this which is
include warnings for possible race
conditions note that the analysis that
finds data races performs
interprocedural data phone apps that can
sometimes explode in time enable it at
your own risk to you know now you know
right so um but it dealt with things
because when you think of how to type
especially in there trying to this and
static statically how to type things
around send and receives and and and the
paper specifically focuses on this idea
of receives with no messages receives
with the wrong kind receives with
unnecessary pattern so that's why she's
not that harmful right like a receive
where you have a we have a pattern a
pattern match that doesn't do anything i
mean it doesn't really hurt you it's a
kind of bad programming practice and the
send nor receive where you you know that
the pit is no longer there it might not
money no longer be there so collect
pairs of programs points possibly
evolved in a race condition and it
basically does this context this graph
traversal and and and does this extra
work and what probably also takes some
of the performance down is that there
are some clauses some weird things where
like in this case with this receive
we're at actually in the initial version
of the program before filtering found
that this is a found that is received my
block there therefore it might be a race
condition when it actually isn't so it
does extra work to filter out these
false alarms because the overall premise
of everything you have to filter out the
false alarms and therefore you have this
extra work which it does increase
performance issues as well okay so we
have these thoughts there's a lot of
other work around testing concur which
is also out of Kostas group and Maria's
work as well model checking tools we
have we have poles for random scheduling
we're thinking about concurrency so the
last
I'll go over here the last 45 minutes is
this a real idea around session typing
so they were desiring the idea of like
the PI calculus it's a whole talk in
itself how that works but pythoness was
created by was created by Milner in 92
and coined that way as a calculus of
mobile processes when I brought it up to
a friend of mine they were like no
there's no way you're talking about
mobile technology they're not my mobile
technology to talk about the idea of
like anything that's a mobile process
though they're there were thinking this
far ahead of now we look at the work
that Chris was talking about let's say
with we're focusing at the edge so the
idea of session type see links between
process can be sent between processes so
you have this they're basically
protocols that determine how nodes
communicate to each other and they based
on these concepts around linear logic
which is i can send the channel at most
one time exactly one time because i send
it again i break I break things and and
basically in the system will talk about
inner lying they reject things like that
from occurring there are two papers on
it there was one called session typing
for a featherweight Erlang and again the
seven times there's a lot of things on
session types by the way the whole talk
in itself but these are the focus on the
airline ones and featherweight or
aligning had this idea of correlation
sets and they need of unique references
and I'll show you as we talk about
quickly how the how communication gets
processed but the ideas of I have a and
i have b and i want to create a session
for those things that they can only
communicate with certain messages to
each other you need a unique identifier
to make sure that if node C comes my way
and I'm participating with being a
specific communication process see comes
in I want to make sure that I know where
that problems come from b or c i am only
i'm only working with be I'm not working
with see they tried they use the idea of
having a make represent identifier which
goes all the way back to John Hughes's
discussion of using make represent
identifier and his like types idea which
is really interesting problem with this
paper it only deals with binary session
so only a to be only be to see but not
but in Erlang as we model processes many
many nodes can talk to each other we
think in react for example nodes falters
fallbacks there's primaries things come
in and out we have to you know how do
you deal with that so this paper thesis
actually by Simon Fowler edinboro is
really really great
around session types and he actually
created this kind of dialect of airline
called monitored session or lying it's
on github of recommend playing with it
it basically has this idea that monitors
are first-class that we can we can view
processes in the run time using monitors
and basically the the main key for this
is that monitor networks are rejection
based if i get a message i'm not
supposed to get i just rejected from
getting in the mailbox okay and he
answers this question in the pit and the
feast is really great which is e
reliance communication patterns as
beautiful as they are and as open as
they are in formally defined how can we
do a logic to do that so they use a
system called scribble this is actually
back we're bringing back Phillip Wilder
comes back and a big big team and
they're doing they have this thing
called ABCD it's a work with people
companies people in academia and they're
working they have this thing called
scribble as one of the things that
they're working on where you can have
this dsl configuration system for inter
process communication you know
configuration so here's a simple ping
pong example I have paying for me to be
punkin betta a this is my global
protocol for how the how the two nose
will work and then each local node gets
a ping has their own it's only going to
ping to beat and pong from be right and
the same thing goes for for the local
protocol here okay here's like a larger
protocol these actually look like finite
state machines or actually called
communication finite state machines and
as you see here this is a much a bigger
example the buyer-seller example is that
you can have choices so a node can say
when I talk to snowed in a session if I
get this have this choice do this or do
this or do this otherwise terminate or
otherwise continue in this session that
I'm working off the paper itself goes
into the stuff where how they do the
unique identification again they
couldn't just use make ref for example
so they have this three tupple that is
the reference the process ID and the
role so nodes can play roles so again
the one that i didn't mention we looked
at binary session types but this is
actually multi-party session types so a
and b
see but these can have different roles
in different sessions so if I'm a node
that is only there to process Jason
let's say and I can be in a session when
those a B and C to do that work in
parallel and how how to communicate that
that but I can also be a no that's
participating in the sort of form of
anti entropy that's a different session
and we can model these things at
different sessions and any time we hit a
failure especially in the case of
monitored session or lying it's not
we're not going to break the system
we're not going to fall down we're just
going to reject the things that don't
fit the protocol and this is kind of the
really awesome thing about session types
and that's just how like the initiator
process the papers really gets very long
130 pages but highly recommend it so to
conclude here so what patterns do we see
we started with we want type systems
people were like well at the same time
everybody was trying to get soft type
systems around dynamically typed
languages Erlang came around to then you
had you know actually really good work
by obviously Causton team to actually
make that you know the biggest thing is
why people use dialyzer compared to
these other systems they integrated in
the system they made it work and it's
easy when people can just go wait can I
just try it it works of course and
that's user interfaces at 101 right but
you see that the through-line kind of
goes we get type inference as the main
thing we get specs then we start looking
at obviously opening the types as well
then we started looking at concurrency
how to process those things and
everybody was kind of trying to model
that stuff way back when then some of
the work kind of went toward model
checking and test for concurrency and
doing this work which is really great
work as well but it's interesting now
that we're moving to the idea of how to
how to use types to to model processes
types that we think of types in it which
is different than model checking and
tests so basically the session types you
can imagine for things that they Chris
talked about in selective hearing if I
of it i have this epidemic broadcast
protocol this gossip but i want to make
sure that when certain nodes come up
they don't participate in something we
can reject those notes from even
initiating a session sequence so things
can play roles this is really really
interesting work and I really recommend
dollars work it's really amazing the
other thing I want to think about is
that we move into this thing so racket
has this really amazing thing between
types and contracts where if I am in a
module that I right specs for but and
I'm really sure about my type that I
bring in a library like the maybe like
rackets document library as they have I
bring in this third party which has no
specs on and no contracts associated
with it and it and this is optional
typing right so we might not even have
inference on for that but if I call one
of those functions from that third party
in my my Mac racket module and it fails
racket will do this thing where even if
I'm tight instead of getting a tight
there because the other the module
doesn't have it it will give it will
give a contractor so one of the things I
see in dollars that we don't do very
well like we try to not work with other
dependencies we skip them or we only
work with the ones that we trust because
the type errors can be everywhere but
they have a really good system where it
can tell you where the contract rates in
the specific in that specific instance
and that third-party modules so certain
something we could actually work on as
well so between that and the session
typing I think it'd be work out really
well so that's everything the history of
relying type systems I think up to now
and some really interesting things going
forward mean Simon Fowler's work is like
2015 he just put it in for for candidacy
and he's doing a PhD starting up I'll
put the slides available there were many
many links on here I did not forget
anybody a pretty sure any question yeah
yeah we have a few minutes of lunch
English yes yeah yeah and they get
mentioned in the early soft typing
papers yeah they get kind of randomly
referencing like I think in the theses
and stuff they get mentioned but yeah it
I think I mean there's a big thing with
not publishing right and white papers we
love exists for example having an
argument the good friend of mine David
knowing about I went to talk at I cfp
about this idea of like monotonic trans
have change from from a separate memory
process to a shared memory one for
performance gains they were doing in
Haskell and you know closure for
examples had this in a long time after
Phil Bagwell contributed some work for
them to reticular out of paper I mean
baggles paper is on there with that
ideal hash free stuff but there's not
too much in it because it's the other
transients enclosure if you ever use
them they're really great but there's no
discussion about these things that's
just that's that's the hard part
sometimes at the same time a lot of
people industry are not reading papers
per se and they use it in these systems
and they people are not kind of always
following up and you know a functional
programming conferences in academia a
lot of it's about what happened in
Haskell now but actually Haskell for all
its amazing things in amazing language
it's not always the freshest on every
idea right so anyone else
you
yeah does which does the letter Yeah
Yeah right
I mean you could like I mean something
like a runtime system like session types
you could actually write that spec out
yeah like something like that you could
do it because again it's completely
about monitoring the runtime for example
that's because that's not it's not you
know I think there's a thing that we
want all the static types of some stuff
which is true but actually you can do
you can have type systems in the runtime
newer type systems in the runtime well I
mean yeah but and the work on the race
condition stuff is really good I think
it's a really cool payment but obviously
the work and concur is it kind of went
to a different direction and but does
the model check in which is really great
but session typing is probably the
closest thing I've seen two doing types
around around the idea of inter-process
communication at least that I've seen I
mean it seems to be like a lot of the
focus</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>