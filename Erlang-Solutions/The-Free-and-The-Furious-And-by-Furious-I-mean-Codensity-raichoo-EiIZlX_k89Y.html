<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Free and The Furious: And by 'Furious' I mean Codensity. - raichoo | Coder Coacher - Coaching Coders</title><meta content="The Free and The Furious: And by 'Furious' I mean Codensity. - raichoo - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>The Free and The Furious: And by 'Furious' I mean Codensity. - raichoo</b></h2><h5 class="post__date">2015-11-19</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/EiIZlX_k89Y" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">oh hi everyone welcome to the free and
the furious so as bodom mentioned this
is talk about co density and free monads
so as the title implies this talk is a
lot about performance making things fast
but a little trivia first when I had to
well prepare a new talk I didn't really
know what to talk about so they're
functional programming is like this deep
and wide rabbit hole there's so much
stuff to talk about and obviously
identity was on my list but I wasn't
sure if this is a good talk for for a
conference like this or yeah so I wasn't
sure but then I came across this nice
post on reddit there's been a lot of
these posts about functional programming
languages like which is the better
language and I have to be honest I don't
like I don't like threats like these but
anyway I there was this one comment that
I found pretty interesting and the
author states that Haskell's are you
Native crazy if you don't know what your
Naida is it's it's a lemma from
elementary category theory that is not
that important but yeah so well in this
in this comment the other states I know
Haskell and I'm some category theory but
I'm highly skeptical that teaching the
United limit to C++ programmers is
actually useful in a way I'm worried
that we may have a backlash at some
point when you know people realize that
unless your initials r EK you're wasting
your time thinking about the cadenza T
transformation so I thought wouldn't be
nice if I were to travel across Europe
and waste the collective time of
conference to think about the good
Anthony transformation I'm doing and
doing this the second time so I've
wasted a lot of people's hours here but
let's be honest um all jokes aside I
think that cadenza t is a very very
useful tool to have when you're working
with free monads and I think it's kind
of sad that people don't talk about this
is very much because to me is this kind
of a jewel that that is lying on the
floor and nobody nobody wants to pick it
up so why not talk about it
and well to convince you that that Co
density is actually a very interesting
topic I prepared this little appetizer
for you so by the end of this talk we
will implement a very simple programming
language that is called teletype it
doesn't do a lot of stuff it just
consumes input and writes output so
nothing too exciting bound and we will
use Fremont's to do that and the good
thing about free monads is that can
separate syntax from semantics so we can
have a lot of different interpreters arm
running our programs so in this example
I'm using a pure interpreter that is not
doing any side effects and stuff like
that so we can we can do testing it is
pretty neat so no side effects going on
here on the interpreter is called rom
pure and we've got this little program
called ref echo and it doesn't do
anything exciting all it does is
consumes input waits for space to happen
and then it prints out everything in
Reverse that is consumed until that
point so nothing really exciting going
on here we've got input input is like
our input stream obviously so it prints
10,000 characters then a space and then
it just goes on and on and on so yeah as
you can see this program takes a lot of
time so this takes 70 seconds to
complete and it takes a lot of memory so
we're just reversing 10,000 characters
it shouldn't be it shouldn't be that
long and shouldn't take that much memory
so something's gone wrong here arm and
we're going to solve that using Co
density and the neat thing about cadenza
T is that it gives me this nice little
Combinator which is calling proof it's
somewhat magical you just have this
little Combinator and suddenly things
will get better so when I have a little
suspense here imagine how much faster
we'll get this that is the only thing
that I've changed there's nothing much
going on here and I was just take
seminar mid-sentence in fact it even it
was even faster when I ran that at the
conference last time so I was kind of
surprised um so this is the only thing
that change
and now I've got a significant
performance increase so here like this
is quadratic runtime and suddenly it
goes to linear time so obviously
something deeply magical is going on and
by the end of to talk you will know
what's happening so this doesn't
convince you that condense it E is a
great tool to have I don't know what
does so so yeah um what I'm going to do
today is first of all I'm going to talk
about list mr lights why list semana
lights well I want to reconstruct the
problem that we just saw in terms of
something that everybody in the room
knows so I assume that everyone knows
what lists are I don't assume that you
know what Amon itís i'm going to
explain that but we are going to use
these devices to to watch things happen
so and after that we after we rep result
this problem by using something that is
called a Z list and uh well the person I
think who wrote a paper on d lists is
actually sitting in the audience so John
Hughes's over there so I'm not a tad
nervous so now I'm fine so d lists are
basically an alternative representation
of the list so we're going to use that
to to solve the problems the problem
that we just saw with lists after that
I'm going to recap what free minutes are
if you don't know what they are i'm
going to give you a very very shallow
overview um so everyone will probably
know what the next slides are about so
hopefully this is going to be enough to
to really understand what's going on and
after that I'm going to do something
strange I'm going to rebuild the notion
of a list using the free monarch
instruction well why am i doing that
well basically I want to solve the
problem that our self with d lists but I
want to solve it in general for
Fremont's that's the plan here so once
we have that we have a general tool to
increase the performance or two to
change the asymptotics of our other
Freeman our programs for this class of
problem
we're going to see and as you might have
guessed that is co density so and after
that I'm going to implement the teletype
programming language using free and then
we're going to improve that so that's
the outline so a little bit of a warning
i'm going to show you a lot of code and
it's not good haskell code I think it's
good code to show what the problem is
but I wouldn't do that in real life so
this is just example code so i think
everyone can can see what's going on and
see the the colors are a little bit well
yeah they're not that good so i hope you
can read that otherwise just ask my
question so what this program is doing
it is basically counting down from
20,000 and every time we were counting
down we're writing a number into a walk
and our lock here is basically just the
list of strings so yeah this is a stupid
way to do that but bear with me so once
we had zero we just returned the lock
and then we just take the last entry
which would hopefully be one so let's
take a look how long this takes this
takes a lot of time this takes 18
seconds and once again a lot of memory
so obviously something is going wrong
here and the high school folks in the
audience will probably realize that I'm
doing something something odd here so if
you don't see that that's plus plus
that's thus I'm a pending lists here but
the only thing I'm doing here I'm
impending a singleton list to the lock
so if you know how append is defined it
recursive on the left hand side until it
reaches the empty list and then it
offends the other one so yeah that in
this case this this is really bad
because with every iteration we have to
traverse the log over and over and over
again so we're doing a lot of work here
so you might say well here's a different
data structure yeah that will probably
be a wise idea but let's look at the
problem a little bit deeper so imagine
you're free lists you have access you
wise and you have sets or disease
pronounced like you want so when you
want to append them we can put our
parentheses here then what will happen
is first we are going to traverse access
and then we're going to pend wise now we
wanted to append these but now we have
to traverse access again that that's
that's bad we doing a lot of work that
we we don't want to have so wouldn't it
be cool good switch the parentheses to
the other side because what's happening
now we say hey we have to traverse
access once then we traverse wise and
everything just went better just by
switching the parentheses another
question that is important is this the
same program as before and you will say
the of course that's a list we're just
depending list of course it will yield
the same result but we want to have a
more general solution we want to be able
to talk about this this operation in a
more general way and to do that I'm
going to introduce my lights and we have
this little knee type class in Haskell
to describe all tomorrow night is so it
has two methods one is called mem t it's
a sort of like a neutral element and the
one other one is called map end we have
weird names in haskell sometimes and in
case you don't see that what my pen does
it takes two elements a it sort of
multiplies them together and we get out
another a and this neutral element well
it has to obey certain laws because we
to really form a mano we have to obey
laws laws are important if you don't
obey these laws then it's not a mano
sorry so imagine you have this element
access and you multiply it with empty
the result should be access so it
shouldn't be suitably modified and it
doesn't matter if you multiply from the
left or from the right so that that's
the first law when you satisfy that now
imagine you have three elements of
access why is it and it doesn't matter
how with
the parentheses it should yield the same
result so that's the second law it's
associativity law and conveniently
enough let's give rise tomorrow it so
the neutral element is the empty list
and the multiplication here is plus plus
which is the append function so
wonderful now we've got now we now we
know that we can just shift the
parentheses to the right and everything
works out just fine so how are we going
to do that by introducing the notion of
a d-list said before it's an alternative
representation of a list and what we're
doing here is essentially it's a
function from list of a to list of a so
what's the argument for that function
well it's the end of the list what we're
doing here is some sort of continuation
passing style transformation so when we
want to get a list leg out we just feed
in our unusual element or empty list and
we get the result back out so with this
construction we can build some utility
functions here we can use we can build
the empty function which just gives them
an empty d-list and that's just the
identity function we feed in the empty
list we get out the empty list wonderful
and the singleton function which just
can construct the d-list with one
element that is you don't see that that
maybe that's a colon so maybe it's just
ex-cons and then the argument which is
the end of the list once again and then
we've got a pent and I think appends
really interesting because that is just
function composition that's pretty cool
now you might notice that all of these
operations work in constant time even
appending to delist is constant time now
so that that's but pretty cool that's
very nice feature so now we want to get
our list back out as I said before we
just feed in the empty list got this
empty list here we got access and it
constructs our list so by using this
continuation passing style we we ensure
that everything gets associated to the
right now we statically ensure that and
neat thing is that deal is also give
rise to them or not so of course neutral
element is empty and multiplication is
the append function I just introduced so
let's play around with this so I'm going
to change the program that we just saw
and i'm going to use d lists here so i'm
using the overloaded lists our language
extension so i can use this nice little
list centex um now our lock is obviously
idealist it isn't a list anymore there
is a package on hackage a call p list so
you don't have to implement this
yourself you can use other people's work
which is pretty neat so the only thing
that I changed here is that I inserted
this d list to list function to get our
lease back out and I use the more
general operation down there I use the
pen function which is just like this
these two angle brackets just in case
you don't see that so let's run that and
that's the lot faster remember the the
program before was taking 18 seconds to
complete now we got the same program and
its completes in 20 milliseconds and it
also takes a lot of memory so that's
pretty cool so so much for d lists now
let's recap free mountains so I want to
talk a little bit about the notion of
freeness um because you hear a lot of
free free free everywhere in category
theory and some people associate this is
like free as in beer or whatever and so
I showed you this this interesting
little mano at this list my light and as
a very interesting property because it's
it's the so-called free mono it so what
makes this thing special take you can
take any arbitrary type a you can feed
it into lists and you get whoa a monarch
for free it doesn't care about what a is
that's a pretty interesting feature so
basically you can think let I got to do
a little dance here so I'm sorry I don't
have a whiteboard something
like that so imagine you have mana
lights up here and we forget we will
pick them on and we should get that it's
amanha we just look at the set that's
underneath so we basically here as a
mall I'd we go down there and now we end
up in the world of sets so this process
of forgetting is well we use something
that's called a forgetful functor which
is called you obviously forgetful
functor you mathematicians also so now
we're down there in the world sets can
we go back up there can we go back into
the world of mono it's yes we can I told
you how to do that we can just take this
take the set put it into a list and we
can't go back out there so now we've got
two functors working together to build
something that we call in the junction
so the the right functor was the
forgetful functor um am i doing this
right yeah so the right functor was the
forgetful functor which we denote by you
the left bunker is called the free
FUNKER and we don't want to confuse it
with a forgetful functor so we say it's
f mathematicians again so yeah we call
that an injunction in category theory
it's it's it's it's and these junctions
they pop out everywhere it's amazing and
basically this free functors the left
edge joined so it's not free as in beer
it's free as in left a droid so what
does this have to do it's not my joke so
I stole that from from I think a coal
pumpkin so high so what has does this
have to do with free monads well it's
basically the same thing we got the
monads up here we forget that it's the
Monad now it's just a FUNKER now we can
take an arbitrary functor f we can feed
it into that kind of construction and we
get it back out as a monad once again
that's nice that's pretty cool so how
can we think about this thing I want to
give you some some basic intuition if
you don't know what free manas are like
you can sort of lie and think it's some
sort of AST some sort of tree
and this functor f is like giving some
sort of shape to the notes that we have
so this is what's going on you and as I
said before you can take an arbitrary
from to F and what you get out is a Mona
once again so I will not go into depth
of this implementation I use type holes
right a type holes to write this this
stuff so the types basically force you
into the right direction was a pretty
neat so yeah the important function
right right here is lift F so we can
take some f a where f is a functor and
we can lift that thing up into our free
Mona so what this thing does it just
this F map just think about it peels off
the f puts pure on there we put on the f
again and that we slap a free in front
of it and now that thing is where we
want it so we're going to generalize
this function later this is going to be
important say oh so much about freeness
okay now let's recover the notion of a
list as I said before this this free
thing is you can think of it as some
kind of tree and we want to build a list
using that thing as I said before we we
want to reconstruct that problem once
again and solve it in it in a general
way so we can do that for all three
minutes so how do we build a list with
free what functor should we use and
maybe you would say well maybe a list
function ah no it's that that's a little
bit weird to get used to but as I said
before the founder gives shape to the
nodes so the functor i'm going to use
here is this well this this this product
FUNKER thing so you got a tuple and
you've got one element here and one
element there and the function f when we
f map is acting on this the second the
second element of the topple so that are
we going to that's what we're going to
use you because we're going to use the
topple the first component is going to
be
had and the the other one is going to be
the tail of the list so that's what
we're going to do after that we want to
get obviously we want to get a list back
out so we want a pattern match on that
thing so oh what what I didn't say we're
using on the reusing unit to denote the
empty list so pure unit is going to be
the empty list arm which is not very
clear because I just wrote on the score
here just fill in a unit in there if
that makes you feel better so that is
just the empty list so when we got a
free case here as I said before that is
the hat that is to tail so we're going
to put X in front of access and we're
going to run access once again on it
we're going to build our list
recursively so yeah now we're going to
build the functions that we need our
pure unit is the empty list singleton is
just we put X in front of a list this is
this denotes the empty list when we lift
f it and this is pretty nice a pending
to list that we construct it that way
that is just monadic bind that's cool if
you don't believe me that's a pretty
good homework exercise to just figure
that out it's pretty and it's pretty
pretty cool I found that funny so yeah
let's give this a shot so once again the
only thing that I changed here is we
have a different law so that's good we
got around that program and yeah I
didn't use the overload of this thing
here because I didn't define and is is
list instance and now we got that thing
so it's once again the same program and
we're using a different data structure
so let's run that and things got worse I
mean really that that takes over two
minutes what the heck and look at the
memory oh my god this is great scott
what have we done so something is going
wrong here it's going something is going
even more wrong than with
first example we made everything more
complicated and now we have the worst
result that we could possibly think of
great work so obviously once again we
ran into that problem that the
parentheses are not at the right side so
yeah now we got to traverse that thing
twice again okay we won't have that so
now we got to think about me can we do
that is that really possible but first
of all let me explain what's going
what's the other thing that's going
wrong here and to realize what's going
wrong and we have to think about
magnetic mind and how magnetic bind is
defined what is actually doing and
basically monadic bind is substitution
and normalization so take n ma now we
want to substitute every a and put an M
be there so the result that we get is an
MMB that's not what we want we want an
MB so we did the substitution and now we
have to normalize that thing we have an
MMB and we're going to M be out there so
we are squashing together arm those
those ms to get the result so now let's
take a look how how this this joint
function that we're using here to
normalize would work for the free ma not
so we have an mm here Mme here which is
free f3f and yeah we just in the pure
case we just peel off the pure and we're
having and in the free case what we're
doing here we f mapping and we have
nothing join over access but look at
that it's not really getting smaller
isn't it so it's it we're not really
changing the size of a thing if that if
that join was working on lists then join
would just become cat we had a list of
lists of a and we will just append them
all together and obviously the structure
will get a little bit smaller here but
it it doesn't happen here so magnetic
bind in in the case of a free monit is
only
find in terms of substitution here so
now we got an even better reason to not
have our parentheses on the left-hand
side that and now we got to find out how
to do that and so sadly bodle is not not
wearing her t-shirt today yeah it's kind
of a bummer but there is a sentence this
dreaded sentence that of the
stereotypical haskell programmer just
froze that everyone who asks what is a
monad and it's and we usually answer in
a pathway well it's just the monitor
system online in the category of any
Funkers if you don't know where that
means that perfectly okay but there's
some part of the sentence that should
resonate with you now amana is a mono it
hmm we know what to do with my lines we
saw that we could shift the parentheses
to the right-hand side and I think
everything's worked out fine so maybe
this is helpful now let's look at the
moment laws so we've got return and we
can use monadic bind here and as you can
see return somehow acts like a neutral
element here it doesn't really change
things so have this F and we basically
just apply our function f 2 a and that
works on both sides that kind of
resembles that that that law that we saw
the with the neutral element and this
law looks a little bit like oh well it's
apart from viaggi lambda over here looks
a little bit like the associativity law
so for all the categories heavy people
in the room that is not the
multiplication that is something
different that is called the extension
multiplication for its monitors join so
it's not important but I don't want
people to laugh at me at home on their
screens so yeah so this thing basically
says oh we get em will get f1 get g well
we can just shift the parentheses to the
good right hand side which is basically
what we wanted to have to increase our
ass I'm talking to improve our
asymptotics here
so yeah the thing that we're going to
use here is covered entity and this
looks a little bit scary but it's
basically the same thing that we did
with the d-list just from if you look at
these two things from like 20,000 feet
above you will realize that are that
these two things are the same so here
I'm using a language extension that that
is called rang n types and if you don't
know what that means that basically just
give me gives me some sort of higher
order polymorphism so that thing is
polymorphic and B that is what's
happening here and this is once again
this this continuation passing style
transformation that I did before with
the d-list remember I fed in this this
neutral element as an argument and
remember that i called return like the
neutral element of that mono we're now
working in so yeah this this type sakura
looks looks like a pretty good candidate
to to swallow i'll return so yeah and
this basically what we're doing here so
when remember we have this to list
function and it basically just just took
our function and fed in the neutral i
mean that's the same thing that we're
doing here we're doing the same thing as
we did with the d-list but this is now a
little bit more general so this K
density construction is kind of
interesting and it's also a monad that
that's pretty cool so there's maybe you
you recognize these these weird
functions here maybe not if you don't
recognize them that's perfectly okay but
these things these implementations are
basically stolen from the continuation T
instances those are the same same things
so the only thing that we're changing
here is that we we don't want to have
stuff like whole CC so that shouldn't be
happening so we just restrict this type
enough do you don't allow call Cece so
this K is just like the continuation
just
ah San through and once again I'm using
typed holes to write these things the
cool thing about the types once again is
they direct you into the right direction
it's it's very very awesome and another
very interesting property if this co
density monett is that it doesn't really
care what F is so f doesn't have to be a
functor interesting property I've never
done anything useful with it right now
but yeah it's something something cool
maybe can exploit that so this is
probably the hardest slide so we now
need to generalize a little bit of our
machinery and I'm using a lot of
language extensions here that I didn't
write down one of them is undecidable
inclusive I'm sorry but Edward camed is
using them as well so we should be fine
what could possibly go wrong so what i'm
doing here is i'm abstracting away arm
this free construct so I want to have a
more general notion of packing things up
into something moneda free-ish here so
I'm using a type class to do that so
with this functional dependency I say ok
if I've got this mon at em then it
basically picks the DF so this is
uniquely the f is uniquely determined ym
it's not super important but just that
you recognize what this indexing means
so for 43 f this is basically just free
so as i said i want to i want to
generalize this kind of thing and now if
we have some mon at free FM yeah we can
we can we get that that could density
wrapper for free somehow it's like we
write that thing down and now we can
package up every Monette free in a
cadenza t wrapper and everything works
out fine so now we got to generalize
that thing maybe you remember that that
rap was uppercase free and that was
uppercase pure so now we've got a more
gin
Machinery going on here and you will see
why this is useful on the next slide so
let's go back to this horrible
implementation of d list that we did and
I just changed one thing here the only
thing that changed is our type synonym
here we just slap your density in front
of it that's the only thing that I
changed everything else is just the same
as before so now let's change the other
program and of course we like whether
with the d-list we have to run that
thing so we like passing in the neutral
element to get our free Mona back out
then we run that and then we look at the
result so let's really run that let's
look how fastest with 1 80 milliseconds
this is still slower than the d list of
course because the list is like really
it's it's doing just that so this is
like a way too complicated way to
express the d list so you should use
that continuation passing stuff that I
did before but now this is pretty cool
now we have generalized that idea for
for our our free mods so now we can
really put that thing to use and when we
see that problem we can we can tackle it
so now let's implement teletype and
that's praise as as I said it's a very
very very simple program it just can't
put characters and it can read
characters from from some input source
so yeah this K is once again it's the
continuation next step of our program
that we are that that's going to happen
and that thing is a funk if you don't
believe me once again homework exercise
but i'm just using the derived functor
language text engineer because even the
compiler can figure out this is a
functor which is pretty cool um so I'm I
don't have to write a lot of boilerplate
here so to construct our free mon app
the only thing i'm going to do here is I
wanted to say free feed on our functor
and we're done we we now have white our
programming lounge we have to build a
few of our of our commands now but I'm
going to do that later this is the way
we usually do it but I'm going to do a
little bit differently so i want to make
the magic happen so i have to be a
little bit more general here so i'm
going to do this so what i'm doing here
is i'm here i'm stating look I don't
really care what this ms I don't really
care what instance of Mona free i'm
going to use its the call site can
decide what instance i'm going to pick
this this is very very vital idea so now
let's implement the rest of the
programming language and it's not
terribly exciting so if you ever work
with free mail nets this is just the way
you do it you lift if all those
constructors photos commands and thinks
is what I've found so this is this is
the the bat the thing that that that
went wrong in my in the first example so
this is the thing that took like hs2
really complete so what I'm going to do
what i'm doing here is i'm reading a
character from our input source for
whatever that is then i'm going to
compare it to space so when is when this
is not space i'm just going to call that
thing recursively and as you can see
here if you substitute ref echo in there
then you're going to see that the
parentheses are going to nest to the
left hand side so yeah this is very good
candidate for that kind of problem that
we just saw so good entity is not like
that magical thing where you can put
everything in there and hope things will
get faster it just solves a very very
specific problem so now there's one
ingredients missing that magical
improved function that has to be pretty
complicated because it changed the
complete complete asymptotics of a
program so what is this possibly going
to do so let's dispense here let's now
that's disappointing it's just lower
core density that's everything we need
and we've got this wacky type signature
over there which says okay you give me
any of these these things where I have
amount of free instance and i'm just
going to lower the identity thing and
everything works so let me demonstrate
that to you oh boy I can't even see my
cursor doesn't like hit and miss ya
awesome so yeah first let's let's let's
do the bad case this is just like it
prints the operations that that is going
to do at the moment so it's not really
doing i order it takes time and I could
stand here for maybe a minute so I'm
just going to stop that because just a
tree tree for you to eat so now let's
let's do oops it's kind of hard to type
with the string to your back and now
ladies and gentlemen I cannot hit enter
so and it's done let me let me what is
this plus s all set sighs again
yeah it's faster e its presentation
effect so this is nice just takes now it
500 milliseconds to do the same program
and this generates the same output it's
not something completely different I'm
not cheating on you so we could do that
within equals n but I hope you believe
me that this is basically the same thing
hey I can do it this way a lot better so
k where to go from here arm if you if
you find this stuff interesting I
encourage you to look at a few packages
on hackage first of all obviously the
d-list package which is yeah a very
useful tool I use it a lot to be honest
yeah the free packet would give this
gives you all the good free mon that
stuff that you want and then this can
extensions okay this is a really weird
notion from from category theory but
they are scary but they are also
everywhere arm but this contains stuff
like like houyan Ada and co density and
very very useful tools will scary names
again mathematicians are great at naming
things not but anyway so if you're more
into Haskell while I prepare to stalk I
i wrote a a library which is
inappropriately called it was free which
does all the things that um that I
showed you today just for for a dress
and the funny thing when I started
preparing this talk is that this
wouldn't compile with Idris so you I
couldn't make that work because the type
checker was complaining even though the
program is white but yeah Edwin
thankfully fixed that so gay now you can
have all cadenza t goodness in it is as
well so the canonical paper on this
topic is by an Oakland are called
asymptotic improvement of computations
over free bonus which is a mouthful but
I encourage you to read it it's very
accessible it's very very good and it's
also the paper were still the ref echo
example from so all credit goes to
Hannah's folk blender if you're more
into reading blog posts than I i can
recommend are the series moments for
less by effort met um if you
just interested in the co density stuff
then you just have to read the first
post the other one gets on with
children's coatings and stuff like that
yeah it's not important if you just want
to understand this Co density thing this
is covered in the first book so with
that I'm going to say thank you for your
attention and are there any questions so
after the the property of being really
bad answering questions on stage so I
hope this going to work out yeah exactly
so the question was it I just have to
change the type definition of my of my
free mon at and I just have to slap
improve their it only solves that kind
of problem it doesn't magically make
everything just go fast so you have to
be careful what you're trying to solve
there what will you use three mullets
arm I use them for a lot of things um
it's basically a good way to implement a
domain-specific language and the good
thing about Freemount as I said right at
the beginning you use separate subjects
from semantics so if you wrote a
domain-specific language with that might
communicate through the database and
stuff like that when you test that you
don't necessarily have in your tests
like a connection to the database you
just want to test if you're free monit
is doing what you expect that what
you're going to do is you're going to
write our interpreter for that and it
will do everything just with this run
cure thing and in a pure way so you can
test your language your programs that
you just wrote and it's a pretty nice
way to
that but you can also use it to to
change the complete behavior of your
domain specific language I saw a very
very cool example where someone was
building a game with tanks shooting each
other and you could use different
interpreters to basically simulate
different behaviors so that was a very
that was a freedom interpreter where the
tanks would just roll around and no want
not a little shooting and there was a
very aggressive interpreter which just
shooting all the time and and that's
pretty cool because now you can can can
build up an AST and later you can think
about what what what our semantics of my
program that's that's pretty cool some
some people call that dependency
injection I think yeah it's you can use
that is a very good question arm
basically you can do that with every
notion of computation you can express in
terms of a monoid so applicator so also
a mano it in the category final functors
we just choose a different tensor like
this weird thing called a convolution
which has nothing to do with day but
it's just part of a name wisely yeah
what supplies the oh it's just a name so
use that and then you can build you can
do the same trick for applicative you
can do the same trick for arrows as well
because they're just a mano in the
category of I think pro functors
something like that so you can do that
as well that that is a very very general
trick so screen and one cool thing about
this is that this this is basically an
instance of caylee's representation
theorem which which you might hurt at
university that is like a theorem that
is 150 years old and we're using that to
optimize dsl's and a computer today and
a functional programming language so
programming is math
don't tell me otherwise I'm not going to
believe you so yeah thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>