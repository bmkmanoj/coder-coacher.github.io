<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF Bay 2015 - Mark Allen - Building on top of riak core | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF Bay 2015 - Mark Allen - Building on top of riak core - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF Bay 2015 - Mark Allen - Building on top of riak core</b></h2><h5 class="post__date">2015-03-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LKsNbYf9mLw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good morning and excited to be here with
everyone and this is my second Erlang
factory in a row and it's a was a lot of
fun last year so I'm glad I could come
back this year so my name is Mark Allen
I do work at bash oh I have a slide
later that talks about about me a little
bit so I guess I'll just skip to that
now I've been developing software for 20
years or so I work at bash oh I think I
mentioned that a few times
I've been writing Erlang for three years
now more or less and one of the reasons
that I decided to work at bash oh and
was interested in working at Basha was
because I really like distributed
systems and basho is kind of focused on
that as a company and so today what I'm
gonna talk about is building distributed
applications on top of a library that
that basho wrote called react or how
many people in the room have used react
core like as a library okay so you know
about ten or fifteen how many of you
have used react the the database okay
good so I'm gonna talk about some
concepts and some some foundational
things about react and the sort of
terminology that's baked into react so
you know if that if that's something
that you're already familiar with you
know just sort of bear with me a little
bit but but react or is a really
interesting project and a really
interesting library about four maybe
five years ago
Basho kind of extracted react core from
Cavey and so now those things are
independent from each other forgive me
for using like you know nerdy Cavey
terms and stuff but K V stands for key
value and it used to just all be one
giant unified blob and now it's a little
more modular if you look at the react
project and github you'll see that
there's actually like 20 different
projects or something that actually
composed the product of react but react
core is really the foundation for a lot
of the distributed systems not all of it
but a lot of the distributed systems
functionality in react comes from react
core and so it's a really nice
foundation for other people who you know
don't necessarily work at bash o to be
able to build distributed applications
on top of the the key thing is that you
really want to focus on your business
problem and not really building a
distributed system if you like
distributed systems you know react core
kind of dips your toe into it and still
leaves a lot of the you know yucky
plumbing and TCP handling and all sorts
of other things that you may might not
want to deal with you know just pushes
it away from you so really it's a nice
way for you to to provide distributed
functionality to to a business problem
that you might be dealing with so here's
one of the key concepts that's in react
and also in react or it's really
foundational this idea of a consistent
hash and what that is is it's not a
cryptographic hash you know like there's
one way hashes where you throw in a
piece of data and you get out this sort
of summary that's supposed to uniquely
identify that particular piece of data a
consistent hash is not like that so what
a consistent hash will do is it takes a
piece of data and you run it through
this function and if you want to see the
function it's actually in react core and
it just reshuffles the keys around so
that you have this nice distribution
property where let's say you have a
piece of data that's called a and even
other data that called B and you run
those through your hash and what you're
gonna see is is that they're gonna get
distributed across a bunch of different
partitions we're going to talk about
partitions in just a second but but
react or uses this consistent hashing
function to take a piece of data and
decide where what partition it should
live in so we also have this ring a lot
of you've probably seen a ring slide
before sorry
it's a Bachelor talk we have to have a
ring slide it's actually part of my
employment contract so what this idea is
is that this is the partition space
right here it turns out that the the
consistent hash that we use actually has
160 bits in it so the size of the entire
ring is actually two to one hundred and
sixtieth that's a very enormous ly large
number as I'm sure you can understand so
what we do is we try to segment that
very very large key space across all the
physical nodes that are actually part of
a cluster and so you can see that like
we have these little green squiggles
those go to node zero and we have a
little orange squiggle and that goes to
node one and so on and so on and we
actually go all the way around this
thing and down here at the bottom I know
I'm not supposed to move towards the
screen but if you look at the bottom
down here it says it says there's a hash
and it's an artist and an RV and REM so
if you if you look at that real closely
what you're going to see is a bucket
name and a key and that actually says oh
well that's on the page
node 3 and it lives you know on that
part of the ring so that's the partition
where it belongs
alright so another piece of terminology
that's pretty common that you'll see in
react core a lot is a V node V node
stands for virtual node and really you
can just think of a virtual node as kind
of a process that represents a slice of
that hash space so it's responsible for
managing all the things that that get
written to disk for that particular
piece of hash space and it also is
responsible for among other things like
maintaining data replicas taking handoff
information helping to compute coverage
information all sorts of things like
that so V nodes are really important and
actually V nodes are the are the
foundational part of what you as a
developer are going to implement to
build a react core application so I'm
going to get Emma we're gonna do a deep
dive into V nodes today I'm going to
show you a lot of implementation code
that I've written for this particular
application that I want to talk about
today let's see here so this is some
things that you get out-of-the-box first
you get the physical cluster state
management so for example you can say
okay I have these three servers right
and I'm gonna put Erlang V ends on all
three of those servers and then you can
join all those three servers together
with distributed Erlang react or
provides gossip protocol it provides V
node placement it revised V node
replication it has the consistent
hashing functions I talked about it has
all the handoff plumbing so sending data
back and forth between V nodes when
there's a failure or when the ring
resizes or when you add nodes or take
nodes out it also can help you compute
covering sets like if you have
computations that where you want to you
know go out to all your replicas and say
hey all you replicas tell me all the
values that you have stored for this
particular thing you can get all that
information back and do computations
with that there are callbacks in the in
the V node that let you compute that and
deal with that so you really get a lot
of stuff kind of for free if you will
that you don't have to worry about so if
you build your application on react or
you're gonna end up you know kind of
being further along than if you were try
to do this all from scratch and that
kind of speaks to the next slide I want
to contrast it with a minute for just a
minute on
you know some when I've done this talk
in the past at some local meetups and
stuff where I live you know people said
well you know can't you just build all
this stuff what's distributed Erlang and
my answer is absolutely yes you can if
you want to you know have at certainly
be my guest but the thing to remember is
that distributed Erlang kind of sits at
that lower level right it provides all
the primitives that you need to have to
build something like react core but it
doesn't provide necessarily all of the
things that you want to have in
particular things like gossip things
like cluster management you know things
like handoffs right those are all things
that you would have to implement
yourself from scratch and that's
definitely not an easy thing to do there
are a lot of as any as any database
engineer can tell you there's a lot of a
lot of things that you wouldn't think
are problems that actually turn out to
be problems so you know the obvious ones
are like placement up placement updates
so like if you have a veena that lives
on node one and all the sudden it's
living on node 2 how do you manage like
how do you manage to forward that
information from where it used to live
to where it lives now you know that's
something that react or does for you
automatically node failure another good
example this nodes offline I'm sending
queries to it you know nothing's
happening why can't someone else respond
to that a fallback ok so that's just
just kind of a difference between you
know the low-level distributed Erlang
and what react core provides so one
other thing that I wanted to talk about
was also is react core good fit for your
particular problem space because this
has come up in some questions I've had
with it with other talks too so react
core makes certain assumptions about
your application and about the kind of
application that you might want to build
on top of it so good fits for react core
applications are things that have sort
of a key value ish type you know problem
solution and also things where you have
computation that you want to distribute
across a large number of workers those
are both things that react core is
really really good at if you have things
that don't fit into that mold
necessarily then react core may not be a
great place for you to work
and the main reason for that is because
of these assumptions that I've talked
about you can turn it kind of sort of
work around them and I'm going to talk
about some of the ways that I've worked
around those assumptions in this
particular application but for the most
part if you don't have something that's
sort of key-value ish or you don't have
a lot of work that you want to kind of
throw around to a whole bunch of workers
you know maybe maybe something else is
is not going to maybe react or is not
going to be a good fit for you in that
particular case so the reason that you
need a key that I pointed out in the
slide is it because we use keys for the
consistent hashing so your key value
actually determines what Vinodh all of
the data is going to sit on top of and
if you don't have that kind of
relationship between this key and a
value then using react core is gonna be
really kind of tough not to say you
can't but you know it's certainly not
going to be an out of the out of the box
you know slam dunk and I guess the last
point is that you know presumably you
want behavior that's different from just
a key value store because if that's all
you want then you know you can just use
cavey and hopefully be happy with that
and you won't have to you won't have to
write anything you could just use it so
there's that before I continue are there
any questions that have come up yet
about any of the terminology or anything
else that I've talked about so far okay
good so there's also some gaps there's
some flaws or things about react or that
I wanted to make really clear to
everyone that's considering using it and
you know I'm very fond of it and I think
it's a really neat library but it's
certainly not you know a silver bullet
and there's trade-offs with it like
anything else you know I think most
Erling programmers appreciate that more
than most people but there are some gaps
and definitely want you to know about
them so first of all react or the
cluster membership is controlled
completely by human so react or does
have a failure detector and it will
usually accurately detect when a note is
dead but it's still part of them it's
still part of the node membership
there's no automatic removal of dead
nodes or anything like that an operator
or some human has to intervene
in that case and say hey this notes dead
take it out of the ring and once you
decide that and once a human says to
react to react or to do that then it
does what it needs to do quite well but
there is no automatic dead node removal
also Vino distribution around the ring
is sometimes suboptimal and that's just
the nature of consistent hashing the
sort of example that I have here is that
let's say that you have two keys that
are super popular and they just happen
to live on the same V node there's
really not a good way to adjust that
very easily without using completely
different hashing structure if you do
that then all of the old data that you
have in your ring is going to be
basically inaccessible because react
won't know where to find it so it is
possible that you can have keys that are
really hot actually in and up on the
same Vino and so you should just be
aware of that right like it doesn't
happen super commonly but it does happen
from time to time and it is something
that that that you should know about and
then the final point is we've done a lot
of work in the last month specifically
and I think Chris Nichol John is
probably the ringleader on this but the
batch oh ship sits oh no TP distribution
and we test on that so react core has
the most testing with batch ozone OTP
distribution now the application that I
wrote today runs on just plain old stock
vanilla OTP 17.4 or whatever but you
know your mileage may vary if it breaks
you keep both pieces all the standard
sort of open source disclaimers apply so
you know if you want you can use batch
of the OTP
there's no harm in doing that you know
it's not like different or whatever it
just basically has some patches that
we've applied to it for various things
most of those get fed back into OTP
but sometimes we ship products without
the you know official Ericsson
distribution so you should probably be
aware of that as well alright so my
example application I've mentioned a few
times I wrote this application called
udon' because I really like tasty noodle
soup and it's it's a distributed static
file server
it's a static web server and you're like
well why would you want to have that
well the reason I wrote it was because I
thought it was a really interesting
problem number one but number two is the
the purpose or the use case or the
business thing that we're trying to
solve here is I have all these static
files I had like JPEGs and I have CSS
files and I have maybe web fonts and I
have all kinds of other things that I'm
serving out that don't change very
frequently and I need to be able to
replicate those and I want it to be
masterless right so you know when a
client hits my service I just want
whatever hit whatever grabs it to
respond to the request and serve it
correctly and I don't want to have to
try to like set up load balancing or
anything like that so that's what I
wrote in this case the key that I talked
about is going to be this kind of you're
alike path that you know is the path to
a static file so if you were to hit like
you know example.com slash you know
assets slash you know example dot CSS or
whatever you would put the assets
examples CSS into Adhan and it'd be able
to serve it out of that so the data
would be the actual contents of that
file right that makes sense I hope so
that's kind of the application that I've
wrote and I just wanted to show you like
one of the things that's really nice
about rebar that maybe a lot of people
don't know and don't get me wrong like
again rebar has a lot of flaws and
things and I'm very well aware of them
but one of the nice things that it can
do is this neat templating functionality
Basho actually has a rebar react core
template of repo on github and all you
have to do to install it is well first
you have to have rebar installed on your
computer but after that all you have to
do is clone the repo and go into it and
do the make install and that will
actually install it into the right place
for you and then you can just make your
own directory right like foo and then
you just say rebar create template react
core and you call your app ID whatever
it is like in this case I called it foo
and it will actually create this nice
you know sort of skeletal project for
you with all of the sort of necessary
files and it actually starts up you can
compile it and start it and it will run
and you can do queries against it it's
actually pretty cool and you don't have
to do any work all you have to do is
install this
github repo and and install it alright
any questions yet cool all right so this
is what the this is what the templates
look like on disk if you just do what I
told you this is actually what you're
gonna end up with you get your make file
and you read me and rebar and all that
good stuff
your really release files and then down
here is the source files those are the
most important ones and the thing that
this is most important is all the way at
the bottom of the screen which in this
case is called boot on V node we're
gonna take a deep dive at that just a
second the other file that's really
important here is the udon oral file
that's kind of like the the application
developer interface to your application
so for example like I have this API for
Don right and it has these functions in
it right now so right now has ping write
which just basically says hey are you
alive and it says pong if it is you get
that one for free that's the that's the
one that comes in the skeleton template
so you don't have to implement that it's
already implemented for you hooray and
the next one is store right and it takes
a path and some data in this case a path
is a string data is some binary it's
arbitrary binary fetch takes a path
there's redirect which I have not
implemented yet but I will and it takes
an old path and a new path basically
kind of does what you think it does and
then one of the things that you Don has
that I that I think is kind of neat is
that it versions the files that you
upload to it so for example if you if
you store a file at test just as an
example and then you store another file
at test it actually stores both copies
across all the replicas and there's a
metadata file that it has that keeps
track of what version the file is right
now and this not implemented yet but
this will let you set it back to a
previous version if you want to and that
might be nice for things like rolling
upgrades or you know there's all sorts
of use cases for that like oh my gosh we
you know we screwed up the graphic so
let's go back to the old one so you can
do that really quickly with this system
alright so how does this even work right
how does this thing even work so this is
a sort of very high level implementation
plan for the API that I just showed you
so this API how do we implement that
well first of all we're going to take
the path that we get from the the query
we're gonna hash it using md5 now md5 is
this like really horrible cryptographic
signature that no one should use but
actually don't care that it's not
cryptographically insecure because I'm
not using it for that purpose I'm just
using it because it's you know 16 bytes
and it's really convenient and so I
don't really it doesn't really matter
what the hash function is per se but
excuse me I chose md5 because why not
it's fast and everyone understands what
it is we make some metadata so we take
the path and we take the data blob that
we're gonna store we compute some
metadata on it includes a file hash
checksum again not cryptographically
secure that's not the purpose the
purpose is to make sure that we don't
have file corruption so then the object
names fed into this consistent hash
function that way I would talked about
and that decides what V node gets placed
on right inside the V node we're gonna
update the metadata in this case the
metadata that we're updating is the
version number so if we've already
stored a version of this file before
we're gonna check to see is this thing
on disk if it is we're gonna increment
the version number and then we're gonna
store the new data so then we store the
metadata object and we store the version
so it's object I version and object off
meta and that's kind of what it looks
like and then so this is the on disk
layout this is what it looks like
excuse me in this case 0 is a V node
number so V node start at 0 and go all
the way to 2 to the hundred and sixtieth
you i've elided several of them there's
actually there will be as many
directories as you have rings partitions
so I didn't talk about this earlier but
the the if you think about the ring
graphic that I showed you earlier it's
chopped up into all those little pieces
all of those little pieces are called
partitions and the number of partitions
is governed by this thing that we call
the ring size and out of the box you get
64 so you can increment that or
decrement that as you wish but 64 is a
pretty good number to start with so
that's what I left it at in any case
these are all partitions so zeros a
partition and one zero zero four seven
that's a partition and then you can see
inside of the partition I actually have
all the files so for example I have this
0 9 8 f6 blah blah blah
that's actually an early record that's
been serialized to disk and then I have
this zero nine eight f6b dot one thing
that's the actual file contents of that
particular file path for the moment okay
and then I just basically have that for
every single partition in this
particular case I have a ring a cluster
size of one excuse me you know and as
you grow those as you grow your cluster
what react core does is it automatically
partitions and moves all of the data
from where it was like on ring on
cluster one to node 2 to node 3 and a 4
and a 5 etc so that all of those ring
changes happen automatically before you
don't have to do anything I mean you
have to implement the handoff code but
once you do that then it will
automatically manage all that for you ok
so here's an implementation of fetch and
this is the this is from AOL so this is
how you would call like as an
application developer when you hook this
up to web machine which is what I have
in the the project this is what it calls
it calls we Don fetch with the path and
the way that it does the the path is
exactly what I just described to you
first of all we take this path the hash
I didn't show that but basically it
competes in in d5 we throw that to the
the C hash function that's the react or
utility hash key I had this little macro
because this particular C hash key
function expects a bucket and I don't
really have buckets what I do is I just
have a static bucket called udon' as my
bucket name you can do whatever you want
there you can make it a binary or if you
have a bucket relationship then you can
use it in this particular case I don't
so i anyway it was a little ugly because
it's a topple and I just thought it'd be
easier to have a macro so I'm kind of
hiding that a little bit but that's what
it is in this particular case I'm only
getting it from one I'm making this call
to react core APL and I'm saying get
primary and I'm throwing at the index
the index is of course what partition
I'm trying to talk to and then the
number there the number one is how many
of these do I want and then Adonis
you know this library I'm sorry the
module name where I'm making the call
from and then down here at the bottom
I'm dispatching this thing called
react cor Vinod masters sinks spawn
command and then i say node which came
from above right that does help me what
node to go to and then I'm saying fetch
and here's the hash that I care about
and there's the module that you should
call the thing from so you know dispatch
this thing - Oh Don vena master and get
this data for me and what actually
happens is it hits the V node master it
says oh hey you need to talk to this
particularly V node and in that
particular V node has this particular
thing inside of it you know you'll
notice that the form of this looks very
much like a gen server and that's very
much on purpose so these V nodes have
handle commands and they have all kinds
of different handle underscore things
just like gen service do just like gen
FSM gen event and all those other sort
of jeno TP things so if you're used to
writing gen events or gen FS Em's or
whatever then this should feel you know
pretty familiar to you and right at home
you know in this case we're just
matching on the command in this case
it's fetch all right we have a sender we
have a state this is all pretty standard
OTP stuff what we're doing in this case
is we're gonna build this this metadata
path we're gonna use the state in the
hash to do that and then I'm gonna check
to see does this file exist if it does
hey I'm gonna grab the metadata and then
I'm gonna get the data and returns okay
data so that's the happy path that's
what usually happens if that particular
metadata file does not exist then I say
hey I don't know what that file is I
don't have it so I say not found and I
return that and then at the bottom I
basically return the results which is
either OK in the data or not found and
then I return the path so that's
actually in this particular case it's
bouton underscore data and the partition
ID and the object with just whatever the
md5 hash is in the state so there's that
that's how you do fetches it's pretty
straightforward right any questions
about how to do fetches or about this
implementation at all yeah it returns
both it returns the file data and also a
path
well I mean the data comes back to you
is part of the this part of the response
so you don't really have to go fetch it
right it's yeah you're giving the
contents of the file in the return this
is really just sort of a hey this is
where I got it from so if you want to go
look on its really debugging aid for me
so I can go look on disk and make sure
that the file actually exists there so
if you want to take that out that's fine
with me in it in the particular web
machine implementation I have I
basically just underscore that and I say
ignore it because we don't do anything
with it it's completely informational so
you know that res right there has the
actual data inside of it it's either a
couple of okay data or it's the not
found atom and you know you respond
appropriately right you send back a four
or four if you can't find it otherwise
it's like 200 okay here's your data
extreme boom done
pretty straightforward okay so we also
have this store thing and this is going
to get into a little bit more a little
bit more deep in the weeds so in this
particular case we have this store
operation and I've sort of hard-coded
this to say okay I want you to write
three replicas of this data and I want
you to talk to three different nodes and
I'm gonna have a five-second timeout and
I'm just gonna do the same thing in this
particular case I have this this file
record here that's my metadata that I
write to disk so that's how I populate
it when I get the the data blob from the
function head I calculate the the Adler
32 checksum for it make sure we don't
have like corruption and then I just
dispatch it to this OP FSM I've alighted
the opt FSM from this talk but it is in
the project if you want to go look at it
because it's mostly boilerplate but but
its job is essentially to dispatch this
to those V nodes the three different V
nodes that we talked about and say okay
I want you to execute this thing I want
you to execute this thing and I want you
to execute this thing and it does it in
serial order so it says okay replica one
you do yours repla two you do your
replica three you do yours and then when
it has all those things that sends back
the entire response that's basically
what it does and that's what this wait
for rec ID thing is here excuse me
so that's what the FSM does and so I
it's not terribly interesting it's
actually very mechanical
and so I didn't I didn't put it in this
talk but if you want to look at the code
it's on github and you certainly can
inspect it it's a it's really really
short it's probably like 20 lines of
Erlang so it's you know very
comprehensible this is what the V node
gets so that FSM gets the says okay V
node here's the here's the file hash
here's the here's the data record and
here's the contents and I need you to
store this and reply if you have and
tell me if you're successful or not so
that's exactly what this does same thing
as before we're calculating the new
version you can see that with the case
statement there in the middle if we
already have a version we're gonna
increment it store it and then at the
bottom we get back these results the
meta result the data result in the
location again the location is
completely diagnostic not very useful
but the meta result and the data results
say okay okay or they say err in some
reason so you can monitor that and make
sure that you know your data did get
stored successfully on all the replicas
that you asked it to okay all right so
uh that's that's fetching store which is
really like you know sort of the guts of
what you would need to have to build a
system and I don't think there's a whole
bunch of magic there I mean let me just
ask like it does anyone yeah question go
yeah
yeah well so the deal the deal with the
N and the W and all of that that that
comes straight out of the lineage of kV
where all of those parameters are
completely tunable so people that really
want lots of replicas of their data can
say hey you need to talk to all of the
nodes to store this and you need to
store it on five different V nodes or
whatever so you know if you have a five
node cluster saying n is 3 and W is 3 is
probably a really good idea you know
because then you're gonna have it on
quote a majority of your replicas and
that that is a good way to ensure that
you have survivability in case of
failure but as far as like being able to
tune that stuff you can make it tunable
or not tunable in this case it's not
tunable but if you want you could easily
make it tunable you could have that as
part of the function head and pass it in
as part of the call or you could
hard-code it or yeah because you know if
yeah in this particular case it is a
setting per request so it's a per per
piece of data it you can decide how many
replicas you want to store is as far as
is that wise
so the question all right so the
question was is it wise to have non
tunable parameters for how many replicas
you're gonna have and the answer to that
question is it depends which is very
easily but I really can't advise you any
other way
in this particular case because it's
kind of a demonstration and whatever
I think hard-coding it's fine but if
this were an actual production system
then yeah I would probably make it
tunable and I would probably make it
default to three because usually you
have five note clusters at least that's
that's the official operating
recommendation and I don't see any
reason to change that five five is a
really good replica sorry five nodes is
a really good amount of nodes to have
for failure scenarios and having three
replicas a crock across five nodes as as
I said part of the majority so in in
almost all cases you know knock on
whatever MDF this is you're going to end
up with a replica that has the data that
you need so yeah yeah good question
thank you all right are there any other
questions before I move on to hand offs
because hand offs are actually the least
documented and the most mysterious
magical part of of what react core gives
you so I have quite a few slides to talk
about hand offs so let me just make sure
there's no other questions before we dig
into that okay all right cool let's move
on so in react core there's four
different kinds of hand offs there's
ownership hand offs there's hinted hand
offs there's repair hand offs and
there's resize hand offs you're like oh
my gosh there's so many hand offs how do
I know what I'm doing
well basically 90% of the time you're
gonna see either ownership hand offs or
hinted hand offs you have repair hand
offs in your own react core applications
I would say not very often and resize it
only happens when you change the ring
size so in react core you can't actually
change the ring size from an old value
to a new value
and that does cause more partitions and
it does cause handoffs when those
handoffs occur those are resize handoffs
so that's a very rare event and it does
not happen that often I also would
encourage you that if you want to build
an application on top of react core that
before you put it in production you
experiment with the ring size so you do
not need to do resize handoffs in
production because they can be very
expensive and take a very long time so
so that's that's my - two bits of advice
their ownership handoffs happen when
basically there's a when it when a
primary goes offline and data gets
written to a fallback and then the
primary comes back online and says hey I
think you wrote some data to Aveeno that
I own and I really want you to send that
to me because I'm the owner of it so
that's an ownership handoff I hinted
handoff happens when you have things
like cluster joins or cluster leaves so
that would be like I'm gonna do a demo
and probably about 10 minutes or 15
minutes and I'm gonna show right so Sean
says I got this backwards so don't yes
no it's a good advice so a hint it is is
is is exactly what I said the opposite
hinted handoff is is when you have a
fallback that's written data and an
ownership the owner comes back online
and it says hey I have this data for you
and the ownership thing is when you have
cluster joins and leaves alright sorry I
did get that backwards so those are the
four different kinds of handoffs that
you can have and I am gonna do a live
demo and you are gonna be able to see
all of this happen right before your
very eyes
so again knock on wood because it's live
demos are perilous and things happen but
anyway those are the four kinds of
handoffs so how do you actually
implement handoffs in react core again
it's sort of mysterious we have all of
this weird stuff going on around
handoffs yeah sure so the question was
what are handoffs
in in the context of react core and
that's a really great question
a handoff is essentially where a V node
needs to transfer the data that it owns
to some other V node temporarily or
perhaps permanently but basically it's a
data handoff from one node to another
node at a very very super-high level
that's exactly what it is note
has data and nobody needs the data so a
sends the data to be that's basically
what it is so it's like handoff okay
yeah great question okay so how do we
you implement those so again I want to
do this at a very high level without
showing you any code at all what are the
goals of handoff how do you write a
handoff function really what you're
trying to do Purvi node you want to get
all the objects that are associated with
that V node so if you're storing them on
disk you want to go out to your disk and
say hey disk what objects do you have
stored for me here if you're storing
them in a net stable or you're storing
them in a cache or some other thing if
you're storing them in Redis if you're
storing them some other way you need to
go to that data store and say hey data
store tell me all the objects that you
have stored for this particular V node
so you want to get all of the objects a
big list of them however many there are
and then per object you need to find or
compute the data that you want to send
from the old node to the new node so in
other words you want to collect all the
information that you need to send from A
to B and then you want to serialize that
and then send it and at the receiving
end you need to have something that can
take the serialized data D serialize it
and then store it in some way that's
compatible with the old way so that's
very very high level what handoffs all
about I know I'm using my hands I'm
sorry I can't help it
I've tried really hard are there any
questions about the high-level stuff
before we dig into the sort of low-level
nitty-gritty here all right so I'm going
to try to take this really slow step by
step again sorry if this is maybe too
elementary for you but but really what
we're trying to do here is Purvi node
get all the objects so again remember if
you remember about 15 slides ago I
talked about how we store things on disk
so we have these partition IDs and then
underneath that we have all these sort
of objects right and they have all these
meta files so what we're gonna do here
to collect all the objects that we have
is we're going to go to the base path
that we get from our state we're gonna
collect all the in from all the files
that are in din meta that's what file
file Lib wildcard does and then we're
gonna do that in a list comprehension so
every time we have a new one it's going
to go to this thing called F
and then it's gonna go to this function
called strip meta which does what it
shops the dot meta off the end of the
name of the object and then we get back
a nice list of strings that are just the
object and no dot meta dot one or
anything like that so remember the base
path is food on data and then partition
ID which could be 0 all the way up to
some ridiculously large number excuse me
alright so then once we have all that
big long giant list of numbers our sorry
the big long giant list of objects what
are we supposed to do well what we're
gonna do is we're gonna fold over that
okay and then for every time that we get
a new object we're gonna find the data
for that object we're gonna serialize it
and we're gonna send it across the wire
to the new node and so that's what this
function does I've cleverly called it do
because I'm really lazy it probably
should have a much better name if Shawn
was code reviewing this I'm sure he
would tell me that but right now it's
this thing called do and you know it's
just a standard accumulator right this
is standard fold there's like no magic
here if you you know if you've written
any Earling at all I'm sure you've
written fold functions but that's
exactly what this is so we're gonna get
this metadata path we're gonna take the
object name we're gonna stick dot meta
on the end of it alright we're gonna go
get the metadata file to do get all file
versions because right now you get the
latest one not all of them you only get
the latest one and we're gonna get the
latest file data right by using the
metadata information and then we have
this thing called visit fun is it fun
where did that come from what is that
thing we're gonna talk about visit fun
in a second visit phone comes from react
core and I have a whole slide about it
so so I'll just defer that for right now
but you can see here I have this key
macro thing again remember that's my
sort of consistent hashing abstraction
and then we have meta and latest file
that's the data I care about and want to
serialize right it's in the tupple and
then I have this accumulator right I'm
saying okay here's your accumulator and
then visit fun actually returns an
accumulator to and the accumulator in
just in case you were wondering is
actually part of the it holds the state
for handoffs so from a global state
level it has all the information about
handoffs that you're doing for that
particular V node so what we do is we
fold over all the all of the the objects
per
Purvi node and we send them visit fun
actually sends them yeah so I walk
through all this usually I have previews
of what's coming up but anyway so yeah
I'm just kind of going through this line
by line and I already done all that so
now we're going to sort of get to the
the nitty-gritty here this is the whole
function here it's called handle handoff
command you can have multiple handoff
commands but in this particular case we
just have one because this is a very
simple application that we don't need to
do a lot with so that's where the
visitor fund comes from it comes from
this weird fold record or sorry fold
request macro that we have that's
actually it's defined as a record if you
look it up it's in react Corvino dot
hurl the hrl file that's where it's
defined at there are multiple the reason
that that it's set up like that is not
to be mysterious it's because someone
decided that we should have versioned
we should have version handoff requests
which is probably a good idea so that's
how that's how it's that's that's why
it's like that it's not because we're
trying to be obtuse although I can
understand why you might think that so
this is the super high level function
we're gonna get all our objects we're
gonna make a base directory we're gonna
call our silly function called do and
then at the bottom here we're gonna fold
over that list right we're gonna fold
over the list of all the objects we're
gonna call do on every single one of
them we're gonna pass in our initial
accumulator and we're going to get back
the final accumulator and we're gonna
throw that back we're gonna throw back
the final accumulator to the the handoff
manager and say hey I'm done here's my
final state you should report that to
someone who cares yeah maybe the user
and that's that's what you have to do so
that's really that's really all there is
to doing handoffs and like I said the
mysterious visit fun where does it come
from it comes from react or handoff
sender there's a function in there
called visit item again this is all open
source so if you want to read the
implementation you're more than welcome
to but what it does is it calls your
serialization function for you there's a
in your V node there has to be a
callback called encode handoff item
which takes two parameters which is a
get key and a value and then it sends
that serialized data to the receiver so
it actually opens a socket for you and
you can do if you want you can do SSL
over that connection and all sorts of
other nice things but it sends the
serialized data to the remote node and
and and and handles it for you so then
on the other side the receiving side
right you also have to have a receiver
there and it takes it gets this callback
called handle handoff data which is the
receiving function it gets to parameters
which is the data that it received in
the state in this particular case we're
gonna deserialize it right we have this
meta and a blob meta remember as a
record so in this case I'm going to
check the checksum from the record and
make sure that it matches the blob right
and if it does I'm going to store it on
disk and if it doesn't I'm gonna say hey
the files checksum differs so I can't do
anything with this as an error and it
just replies with that and that's all
you have to do pretty simple all right
okay so um that's kind of like the nuts
and bolts of how you write an
application
I've lighted some details but not very
many there's been some really nice
recent react core resources that have
come out there's a really really nice
talk that was done in Berlin in December
by a guy named Mariana Guara I think I'm
saying that right
and he did this react course small bites
course and he wrote an application
that's sort of like Twitter clone a
little bit but basically has the same
principles and ideas and it also has a
nice open source this Flavio DB sort of
toy project or whatever and then his
slide decks is the top URL there if you
want to if you want to go through that
it's it's quite nice
and also the talk is on YouTube I forgot
to put that on here but I will do that
before I upload the slides so all of
those things are available and then my
project here is also on github and so
some of you may have been looking at
resources and like from the old days of
react or like when it was really super
new and stuff those are useful
conceptually but I think from a sort of
running code
perspective they haven't aged well
unfortunately and a lot of the code
doesn't really work correctly or leaves
you down the wrong path which is
unfortunate so I would say the older
resources are super valuable from a
conceptual point of view but maybe you
want to focus on the more recent talks
and and projects and stuff to help guide
you on you know how you want to
implement your react core application
okay
so demo time right is everyone ready for
a live demo I know I am okay so here I
have a I have this node yet so so um we
have a lot of beam error messages this
is what happens when you put react to
sleep and wake it back up good it really
does not like that very much but it's
fine right like it it's it's fine
so so I have a I've put in some data
here I'll just put in a few more pieces
of data because why not it's demo time
call this okay so so I just stored this
thing called test3 and I had this piece
of data called hug and then over here I
get my response just like what Zach
asked earlier why are you sending this
back to me
I don't know cuz I can't I guess but you
can see that basically we have okay in
this list right and there's three
there's three things here because we're
doing three replicas we have okay okay
and then you know the path
okay okay path okay okay path right so
we have all those things and then if I
want to do a fetch like just to show you
that it actually does work probably oh
that's because I did not change this see
live demos are perilous all right
so I have this piece of data called test
right and it the value for that is
quacks which again and you probably
can't see all right so there you go
it's quacks and it's you know in this
really long thing over here so over on
this place over here I have another node
I have no - and it's just empty right
now there's no data in this at all and
then over on this screen I have actually
decided to
join cluster 1 so I'm gonna say cluster
2 your joining with cluster 1 and then
to do that you have to say cluster plan
because that's how react redistributes
all the v nodes it decides what nodes to
place them on and it says hey this is
going to result in a cluster transition
and it's gonna say ok right now
node 1 has 100% of the ring and after
you do this transition then you're each
gonna have 50% of the ring which is
exactly what I want to have right and
then the bottom which you may not be
able to read oops sorry about that at
the bottom which you okay so it's a
little bit higher now it says that
there's gonna be 32 transfers right so
there's 32 V nodes because I have 64
total the 32 are gonna move from node 1
to node 2 right some of them are empty
right so we're not going to transfer the
empty ones we're only gonna do the ones
that have data in them so let's go ahead
and do that and to do that we say
cluster commit and say cluster change is
committed and we're gonna get a message
over here knock on wood and it's going
to say okay hey no two's joined you and
stuff is gonna start happening so you
can see over on node 2 it said it said
that we change from joined a valid and
then you can see the data that's coming
in from node 1 again it's down here at
the bottom sorry about that but this is
data that's coming over from node 1
using the handoff implementation I just
showed you guys yeah yes it does there's
tunable parameters that you can set then
you can actually tell react how much
concurrency you're willing to tolerate
and you can throttle that mostly by
connection number but there is a lot of
metrics that are collected as well so if
you want to do it by like object size or
object count you certainly can code that
if you want to but the the the primary
driver right now is how many how many
how many handoff processes are you
willing to spawn so that's a number that
you said right and I think that out of
the box you get 2 or 4 I can't remember
I think it's - yeah - so you out of the
box you get 2 are there any other
questions yeah
oh sure so the question was what are
some example react core applications
that are not like kV things well off the
top of my head I can think of a couple
one is Chris Michael John's talked about
last he's going to talk about last I
think next right yeah so if you stay
here you can hear about last but it's
written on top of react core there's
another project that's called Project
FIFO that does like system management
for solaris Mart OS 4 smart OS images
and it's it's kind of like a management
orchestration system for smart OS
systems it's all written on top of react
core there's a there's been a number of
other applications that have been at
like conferences and like recon and
stuff like that where people have
written distributed work processing
Chris was just telling me about this
company that did like a whole like
Heroku kind of clone thing on top of
react core which is sounded pretty neat
so there's just a lot of different
possibilities for what you can do with
this technology oh yeah yeah yeah in
Cape in kbase yeah yeah I forgot about
that
so one more yeah
last year at Erlang factory I talked
about dtrace so I would I would I would
probably reach for that and if you if
you have the ability in in you know to
go in and insert yourself a red bug is a
really nice tool that you can use to do
that from a rebel I don't know if you're
familiar with red bug like Fred and the
team of Heroku we're at this really neat
yeah okay yeah it's it's neat so so
that's yeah so and you know and there is
also logger debug stuff too if you you
know want to do that so alright so thank
you very much for your time and
attention today I really appreciate you
coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>