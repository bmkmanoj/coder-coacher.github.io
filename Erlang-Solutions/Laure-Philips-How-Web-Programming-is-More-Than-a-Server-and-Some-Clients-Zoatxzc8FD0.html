<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Laure Philips - How Web Programming is More Than a Server and Some Clients | Coder Coacher - Coaching Coders</title><meta content="Laure Philips - How Web Programming is More Than a Server and Some Clients - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Laure Philips - How Web Programming is More Than a Server and Some Clients</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Zoatxzc8FD0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">largely talk about my PhD but don't
worry only the fun parts so I'm come
from Belgium Brussels and I work at the
software languages lab so that's a lab
where we try to solve different kinds of
problems in programming either by making
a new language tools or middleware so
I'm funded by the Flemish government I
have to say this and my research is also
part of a bigger project where we try to
see how we can incorporate my research
with Belgian companies so that's the
tearless project also funded by the
Flemish government so let us start from
the beginning that programming in the
90s so we saw the first web pages like
this really static HTML in what we call
HTML age so the clients were actually
just the user interface HTML pages with
no logic in there so all the logic was
on the server side if you even had logic
for your website and you had like a lot
of HTML pages and you could browse
through them by just following the links
also people really like to use horrible
color schemes and animations back then
so we moved on we did better and we went
into the lamp age so lamp H stands for
the technology stack that was often
Houston lamp
Linux Apache my sequel and PHP Perl so
it's around 2000 and we see we have now
more dynamic web applications so Ajax
was introduced in 2004 I believe of 2006
and thanks to Ajax we could make a
synchronous calls to the server side and
load content dynamically so our pages
are becoming less static we also need to
have less pages overall we have thanks
to JavaScript we can now also I would
try to program more logic on the client
side as well typical examples are like
the first web shops personal blog page
and so on but now actually we are in the
JavaScript age so we have these home
page apps rec entities added removed
updated dynamically so they are not
static
at all and we now also program a lot of
program logic on the client side as well
so you have like Google Docs is really
collaborative for web applications so
these applications I'm talking about we
call them rich Internet application so
you have a really rich stick client that
contains part of program logic so in
JavaScript you have this one page apps
where every content is updated
reactively
and then you also this offline
availability of your data on the client
side so thanks to html5 and offline
storage you can now store part of your
data offline as well and thanks to that
you also have this part here program
logic on the client side actually parts
of your application even work when
you're offline we have no connection and
most of the time this rich Internet
application also combined lots of other
services from other servers in a mashup
kind of way like integrating Twitter
feed and so on so how do you implement
such a rich Internet application so you
have to choose a technology for your
three different tiers so your database
tier server tier and client here so for
your database you can choose a
relational database for your server side
you pick a language that seems fit for
the job to about PHP sang with a
language you like so no judgement there
and on the client side of course you're
stuck with JavaScript HTML CSS and then
you can add lots of JavaScript libraries
on top of there to get this really
reactive rich internet applications of
course if you don't rely on a web
framework and you choose your own
technology for every tier you have to
write a lot of glue codes to make all
these technologies work together
actually you can take another approach
so thanks to no GS we can now write
JavaScript on the server side as well so
your technology stack then becomes like
you choose a JSON based database on your
database tier no GS on the server side
it may be a server-side framework on top
of it and then on your client side also
it is JavaScript and so this idea of
having the same language on your
different tiers is what we call
tearless programming so it's often
called single tier multi tier isomorphic
programming as well it's just all the
same it means that you have a single
language and you actually develop your
web application in a single language
three different tiers and actually it
seems now more like your writing and
desktop application instead of a
distributed web application and we see
that you have three different approaches
to this tearless program you have a
dealer's frameworks rewriting tools and
languages so I will now discuss these
three approaches so Telus frameworks two
famous ones Google web toolkit and
meteor they allow you to write your web
application in one single language so
Java for Google web toolkit JavaScript
for meteor and the frameworks themself
provide a lot of libraries of packages
for example talk to a database
communication to the client and server
making your user interface and so let's
take a look at a hello world example for
web application so a chat this is a chat
for the meteor framework so this is
JavaScript and this is one single file
and that's all that it takes so this is
your chat application so it's all file
and you have to check at run time
whether this file has been executed on
the server side or on the client side so
we have these two if checks on line 3
and 12 to see where it is running if
it's running on the client site and I
install an event listener that will be
called when I click the send button and
there I make a message and I insert it
into a collection on the server side I
simply say ok you cannot put empty
messages in this collection and that's
all it takes and all the magic actually
happens in this meteor collection
package on line one I make this
collection called messages and this is
actually very communicate with the
client and the server and we broadcast
to other clients so we simply insert new
messages in there so on the client side
the collection package will make sure
that the collection on the client side
will send this to the collection that's
also lives on the server side and on the
server will broadcast it to every client
now the nice thing about this collection
that is they also automatically get
persisted so on the server side to
MongoDB database and on the client side
meteor has what I call a mini Mongo
database that persists persist to
offline
which things to html5 as well and that's
all it takes so you have this collection
I guess you use it it handles your
database and your communication between
client and server so that's the
JavaScript port you also have your HTML
part of course of your application so
this is the HTML and I use an HTML
template insist 'm and the nice thing is
that in here you can refer to your
variables from your javascript file so
on line 4 I loop over my messages
collection and I simply display every
message and that's all it takes
so this HTML will be updated reactively
every time a new message is inserted so
really you can just take this code run
it in meteor and that's your bat so you
don't have a lot of glue code everything
is handled by the framework for you
so Teela's frameworks they allow you to
program in a mainstream language so Java
JavaScript they have this extensive set
of libraries to handle like all kinds of
concerns and it's easy to reuse
JavaScript libraries so in meteor
because it's in JavaScript itself in
Google web toolkit is in Java but they
allow you to integrate JavaScript
snippets in your java code now until the
TLS rewriting tools so the idea here is
that you have you also program in a
mainstream language and you give some
developer hints to the TLS rewriting
tool so it seems like you're just making
a local program then you add these
developer hints can be annotations and
then a tool will rewrite your local
synchronous program into a distributed
one so examples for examples G
orchestrated takes Java bytecode of a
local program you provide a distribution
planets in XML file where you say this
class must be on the server this clause
must be on the client and so you do this
for every class and then they will
actually do this rewriting and make a
distributed web application for you
now actually it's not a web application
it's just distributed applications in
general so they don't focus on web
applications
now volta is a tool that does this so
it's from Microsoft Research and they
take C sharp code where you annotate in
the code where classes should be and
then they rewrite your file that seems
like a local file
into a distributed web application and
the Ripley is another tool built on top
of Volta also by Microsoft Research and
they focus on safety so they added
safety layer on top of falta and they
replicate that will replicate that
execution so meaning that if a client
does an action they will replay this on
the server side as well and then compare
the results so I wanted to give a chat
application example for this rewriting
tools as well but the orchestra is not
from a publication and Volta is actually
at that project so there's like one
paper about it that's it no
documentation so I couldn't play around
with it so I just took the example from
the one paper that is out there so this
is a distributed Fibonacci so I have two
snippets a server snippet and a client
snippet and in the first as I make a
class main that has a method Fibonacci
which is just the recursive definition
of Fibonacci and then I say on line one
this main class must run at the server
then in my second snippet the client
snippet I want to call this Fibonacci
method so I have to provide like an
external interface for it so I say that
it's an external method and it's going
to be on a synchronous method because of
course I'm doing communication between
client and server in a non-blocking a
synchronous way so my interface on the
client side now as a next extra
parameter namely a continuation so
that's a callback function that will be
called when I retrieve the result from
the server side and then I call the
function on the client side and I
provide this continuation saying that
when I retrieve the result I will simply
display it so that all it takes and the
rewriting so tools of Volta will make
this application distributed so the
Fibonacci method from the server side
will become a remote a synchronous
method so you don't have to write it
yourself the tool will do this for you
so tearless rewriting tools i also allow
you to program in a mainstream language
you have to provide these developer
hints or developer annotation and then
based on this they'll make an actual
distributed application out of it
but it's harder to integrate javascript
libraries in there so the 1g orchestra
doesn't focus our web application so no
JavaScript there and in Volta it's not
clear I think it's just not
to do this so you can't intergate like
libraries like react to have this really
rich Internet application so until the
teyla's languages so they make a totally
new language and most of them are
actually from academia so we like to
make new languages so here they are so
they provide a totally new syntax and
was actually funny most of them tried to
have like JavaScript like syntax so the
links paper actually says it's not
because we like JavaScript it's just
because programmers web programmers seem
familiar with it so we took like parts
of it and integrated in our new syntax
then in these languages you have some
kind of way of saying that this must be
at the server side this must be at the
client side this is communication
between them for example in the hub
language you have this tilde and dollar
sign and I think the tilde is for saying
this expression should be on the server
side and with dollar you switch to the
client side and first so you have this
deal as languages now you don't have
your server and client anymore so most
of the time you structure your program I
had a Model View controller pattern so
this is what OPA is example here does so
oh by the typed language so for my chat
messages I first have to make a type
message which just contains the string
for my message then I make my model
and I can broadcast to all the clients
then in my model on line 8 I make an
exposed function so a function that will
be called by the client side that lives
on the server side and it will simply
broadcast the message on the network I
just declared and then I also have a
function to register a callback so
that's the client who can register a
callback that will be called when a new
message is retrieved from the server
side now the controller is not that
interesting here just like two lines so
this is the view part and as you can see
we have a function chat HTML which has
like HTML like syntax in there so that's
a nice thing about these new languages
because they are making new syntax they
can do stuff like this so I just create
an HTML snippet in this function that
will be returned and displayed and in
there I say on line 4
when it has been loaded I want to
register a callback that will be called
when I retrieve a message from the
server so that's the user update
function on line 15 if you look at this
function is just a normal function which
takes a message and will update the HTML
then in the chat HTML function of course
I want to I want to say when I click the
button then I want to contact the server
to say here is a new message broadcast
it to all the other clients so that's on
line 7 I have this function there my
event listener for the button and I say
I call the broadcast function which is
defined on line 11 and in there I call
the actual broadcast function from
before that lives on the server side so
the broadcast from my model so that's
it's actually a distorted application in
open so deles languages they provided
totally new language so you can program
in a mainstream language each of these
languages try to solve a particular
concern of web applications and because
I provide this new syntax you have this
integrated and user interface and
database a templating that you can
integrate in a nice way in your
application now we have seen these three
different approaches we can now compare
them to some criteria so the first is do
they have to support can you reuse your
favorite IDE quality tool unit testing
and so on second today allow me to
program in a mainstream language or do
you have to learn their new syntax
thirdly can you integrate you have
escaped libraries in there so can you go
full fledged on the client site with all
these JavaScript libraries out there
fourthly do they allow you to focus on
this non-functional concerns such as
offline availability of your application
latency security and so on and then the
last did I have this integrated user
interface and database templating syntax
so teyla's frameworks they perform
really well on the first three criteria
because they allow you to program in a
mainstream language so you can reuse
your favorite IDE and so on you can
integrate JavaScript libraries in there
as well but they do not allow you to
focus on non-functional concerns so if
you want to do this you will have to
know how the framework works you will
have to write an extension yourself and
so on so it's not easy to do this then
the tearless to also the rewriting tools
they also allow you to program in a
mainstream language but you have these
annotations in there so it can't reuse
your favorite tools because of course
they are not aware of these annotations
and it's also harder to integrate
JavaScript in there none of these tools
we have looked at allow you to focus on
non-functional concerns as well so they
don't perform really well on that
criteria and some of them have an
integrated use interface templating
system but not as languages so the
languages actually perform only pretty
well on the last requirements because
they have this new syntax to express
your user interface make queries to your
database and so on so if you look at
this we decided we can do better and so
this is where my research comes in so my
research is about tear splitting
approach in a mainstream language so
what is this tier splitting approach so
the idea is that you start from dealers
JavaScript code where you have some
annotations in there so why JavaScript
because the reason I said before all web
developers are familiar with it there we
prefer code analysis on it that will
help us to do the actual tear splitting
so we have our tear
javascript code that seems like a local
file then we want to split the
server-side part from the client side
part and then make an actual distributed
application of it so the tier splitting
will split these two parts and then the
refactoring will just rewrite a call at
the code into a real distributed
application so this still has javascript
code how does this look like so you can
imagine you have one single file with
blocks of code and these blocks of
thought you annotate them to be either
they are on the client side or at the
server side so an example here I have
two blocks of codes on line 2 and 10 and
the first one I say this must be at the
server and second one must be at the
client in the server side I make a
function so it's just a local normal
JavaScript function broadcast takes a
message and we'll call another function
with that message now on the client side
I first define a client ID then I make a
local definition that display message
function that will use jQuery to update
my HTML with a new message I received
and then it calls the broadcast function
with my client ID and says hello so
initial message now the good thing about
this is you see you don't have to write
remote procedures stuff like that it's
just local functions and local function
calls to advantages of this approach of
taking this deal as JavaScript approach
you can reuse all JavaScript libraries
that are out there to do to take yes for
tea you can use jQuery so as I shown
here you can use graph libraries to draw
nice graphs and so on secondly these
annotations as you can see they are made
inside comments so all of tools ignore
them you can reuse your favorite tools
but we of course we use them to you for
this tear splitting process now it's of
course it's JavaScript with annotations
so we have roughly four categories of
annotations so the first one you'll
ready solve for placement so you can say
this is B at the server side at the
client side you also have a shared
annotation so to say I don't care where
this will be it just must be on the
teeth where it is used we also have in
user interface annotations so we also
support HTML templating in there
then we have communication annotations
data sharing annotations and failure
handling annotations but I will show you
this with examples so in here I have a
little program and on the server side I
will have a collection of users scores
for the game for example so I define
this collection online for it's just a
JavaScript array and then I have a
function at score that takes user and
the score makes a new object out of it
and pushes this into a collection there
are my client side so the block starts
on line 13 I create a user ID I at an
initial score to on the server side to
the collection so by just calling the
add score function with my user ID and a
default value 0 and then I want to loop
over the score collection and display
all the other users their score now two
things to note here so I have this score
collection that will live on the server
side but I annotated this to be at
observable so that means it will be
replicated to every client and every
client will receive updates but I cannot
change it themselves otherwise you can
change the scores of other users or
yourself so you want to have you don't
want to have that behavior but you want
the client to be able to have that
collection because on line 17 we want to
display it so you just define it on the
server side you say at observable and
our tool will make sure that this
collection is available on every client
side then I have the add score function
and that's actually a function that will
be called by the client side so I say
with an annotation on top of it this is
actually a remote function then when I
call it from the client side on line 16
I have to say this is a remote call of
course you don't want to do this for
every function and I will show you how
we can solve this first and other
examples so here I have a function on
the server side online for share on
Twitter so I want to share an article on
Twitter so this is of course simplified
example you will call the Twitter API
there and so on but I didn't include
this here but then the function wants to
say okay I share it on Twitter I want to
display something on the client side
saying it is shared on Twitter of course
I don't want to do this on every client
I also I only want to do this on the
client that called this function so
that's why I have this a trip
lie on top of the call to display pop
over on line seven so that means I will
only call this function on the client
that call dysfunction and I will not
broadcast it to every client and then of
course the display pop over function is
a remote function on the client side now
another thing to note here so this is
like normal JavaScript local function
calls but we are going to make a
distributed application out of it of
course a lot of things can go wrong a
distributed setting there will be errors
that are not that won't happen in this
local program so that's why we have the
use handler annotations on line one we
say on the server side when something
goes wrong my sending messages to the
client first I want you to retry two
times if that fails I want you to start
buffering calls for that client so when
he reconnects all the calls will be
flushed to the client and then I also
want to lock every error so this is
default so we I provide these failure
handlers for you but you can write your
own failure handlers as well but these
are we looked at that we research this
we have other ones we came up with a set
that we think is convenient for most
programmers so back to this annotation
so we have JavaScript with all these
annotations so we saw the placement
annotations and you put these on a block
level so you say this block must be
there or there then communication
annotations you put them on top of a
function or a call to a function data
sharing annotations you put them on top
of a declaration so you say this
declaration this variable must be
observable or I want it to be just
copied I want it to me remain local on
this tier and so on then the failure
handling annotations you put them on top
of a block so you say everything on the
server side use these handlers or you
can also put them on individual calls
now of course I already set it you don't
want to put all this remote call at
remote function on every function and
call so that's why we use a program
analysis so for our program analysis we
look at every statement in the program
and we see whether there happens to be a
call in there or a data reference and
then the program analysis will tell us
it's a call to a server side
or client-side function or it's a call
it's a data reference to something that
is well secured on the server-side are
on the client-side so for those of you
interested we use and static analysis
that uses abstract interpretation but
that doesn't matter it works so before
we had without the analysis we had to
really explicitly say this is a remote
function this is a remote call with the
analysis you don't have to do that so
now you can simply omit those
annotations and we do this actually for
every statement and then we can come up
with something which we call a program
dependency graph so it's like an
abstract syntax tree but with extra
information so for every statement we
remember it's a server-side statement or
a client-side statement or its shared so
I don't care about this then we also
make call and data dependencies between
these nodes and then we also remember
it's a remote call or a remote data
reference or a local call or a local
reference and then we perform actual
tear splitting on this so we want to
have all the nodes in the program that
are needed to execute the server-side
and all the nodes that are needed to
execute the client-side for that we use
a technique that is called program
slicing it's very old it was introduced
in 1981 so it's even older than me but
it has been proven useful in the Bergin
testing and so on so we extended this
program slicing with notions of a tear
so client-side server-side we also made
it incorporate remote call and remote
data dependencies so the still splitting
now we end up with two sets of nodes
that should be on the server side and on
the client side of course now we have to
make our distributed program so that's
why we do the code transformation so we
take these two sets of nodes and we make
notes we make a program out of it and
there before on the server side we had a
local broadcast functioning now we now
make a remote function out of it so for
this we use an RPC library that we wrote
ourselves but you can rewrite it to any
framework you like so now we make a
remote function out of it so online for
your seed has an extra
parameters or callback function so we
make synchronous function functions a
synchronous for you so this callback
hell that you have it no GS we write it
for you you don't have to write it
yourself when we make a call so on line
5 to the displaymessage function now
this is a remote call so an RPC to a
client-side function and then of course
on the client side code my display
message function now becomes a remote
function so the server can call it and
on line 19 when I call the broadcast
function it has to be a remote call as
well so this is a code we generate for
you now how well do we perform now it
still spitting approach for JavaScript
so you have this tool support you can
reuse favorite tools because it's
annotations are made inside comments
it's a mainstream language it's
JavaScript so you can even reuse every
JavaScript library that is out there and
incorporated into your TLS JavaScript
code now for non-functional concerns I
haven't talked about this and so we
perform not that good but we will solve
this and we have this interpreted use
interface templating we have this at
user interface annotation that the
moment we are kind of ignoring the
database layer but that's of course
future work now we want to do better on
the fourth requirement so you want to
easily Express non-functional concerns
like offline availability of your
application latency security and so on
so that's why we introduced web slices
so web sizes are units of code which
will annotate with a name so for example
in my web application I can have a data
slice which contains all my declarations
I can have a display slice which will
contain every function that will display
this data and so on so you have these
small units of code slices and you want
to experiment with them you would like
to say if I put this slice on the client
side how does this affect my application
so you have to provide a website
configuration so now we have an ad slice
annotation you give a name it's in the
code and then you had an F at config
annotation so there you map these names
of these slices to your actual tier so
you say the data slides must be on the
server for example now the story is
as before of course in between these
slices you can have local calls
functions state local function
definitions and so on so this is an
example of a chat message so I omitted
the bodies of the function just to make
it smaller so I have four slices the
first one defines a collection of users
two functions to add a user to this
collection and generate a new ID for a
new client then my messages slice
contains a collection of messages and I
can add messages to this but I have a
listener slides that will install event
listeners on the buttons of my HTML and
then I have a display slice that just
will have a function to display all
these messages and then I have to
provide configuration saying the users
slice must be on the server and so on
and then the story is the same as before
you have this placement of these slices
then we can perform the tear splitting
and the code transformation for you now
of course if you have a big project with
lot of slices maybe there are slices
that you don't really care about so
that's where placement strategies come
in so if you have slices that you don't
care about you just don't give them a
placement and then you choose a
placement strategy so you can have a
placement strategy that focuses on
offline availability that will try to
place these slices you don't care about
in such a way that you maximize your
offline availability of your application
you can have a placement strategy that
tries to minimize the latency of your
application or maximize the security or
you can write on yourself that is a
combination of other concerns of course
and then you have like this new
development developer process actually
so a given initial configuration you
choose a placement strategy and then the
tool will try to place all these slices
in the correct tier and it reports back
to you with this configuration you have
like 80% of an availability to happy
with it you transform the code into the
distributed application if you're not
happy with it you have like this export
experience where you can experiment and
say maybe I want lastly it and see more
flying availability please try to
reconfigure this and then the tool will
report back to you so it is small
moveable web slices we can now actually
Express
every non-functional concern so in my
PhD our focus isn't focusing on offline
availability of your data but of course
you can rewrite you can write
displacement strategies yourself and
focus on any concern you like so we've
implemented this but of course it's
research in progress it's only me that's
working on this so you can try it out
but there could be bugs in there so you
have you input your dealers JavaScript
code with these annotations in the left
side that you can try ask the tool to
transform it for you you get this
offline report back that says like 75%
of your slices are now on the client
side 25% I put on the server side then
this is put on the client side you have
like 30 T 30% outgoing calls to the
server and so on so this is the
dashboard actually now of course I've
been talking about web programming but
it slices call them web slices that
actually you can use them in a
distributed setting as well so imagine
you have a smart home with smart devices
so smart coffee machine smart smart cat
and a smart cat feeder and a smart
fridge and you want these devices to be
able to order stuff coffee cat food
human food but of course if you have a
smart cat you don't trust these devices
you want to confirm your order every
evening because otherwise you end up
ordering get food every day for example
so in your mobile phone you want at 8
o'clock every evening for example you
want to confirm your orders maybe add
one remove orders and so on so how could
we implement the city slices so this is
just like pseudocode so I can have two
slices so a shopping slice it was actual
shopping and it keeps a collection of
orders so it will place the order in
your favorite web shop and then I have
the place order slice that will actually
put a new order in this collection and
so the orders collection and make it
replicated meaning that every device
will have a local copy it can make
changes to it and then change will be
propagated to every device and your
phone as well and then of course in my
configuration and now say shopping I
only want to be able to do this on my
phone of course not only smart devices
and the placing of the order so adding
an order must be on the fridge the cat
feeder coffee machine and on my phone as
well and then actually you can have your
distributed tool be writing tool that
makes an actual distributed application
out of it for you so I've been talking
about how a program is more than program
ingest your server and your client with
this notion of web slices so now I can
also explain why it's actually totally
not clear but why I use this image it's
an image with a cracked earth so a tier
split earth my advisor didn't get this
so he said you just really tell these
good people so I will put my slides
online just take a look at the victor so
I've talked about dealers approaches so
the Steelers framework to Tillis
rewriting tools and the tearless
languages and how well they perform and
concerning to several criteria for rich
internet applications then I've
introduced our approach tear splitting
for JavaScript and how we extend this
with this notion of these small moveable
web slices and together with
displacement strategies and how this
allow you to focus on non-functional
concerns such as offline availability so
you can always contact me about this
there will be like a big book my PhD
dissertation in like all fear if you're
really interested in this but you can
also test it out online and play around
with it so thank you for your attention
this is really loud intensely we have
time for some questions
so I was I was seeing when you had the
color everything in one file would it be
possible to kind of take that file
instead of splitting it up into you know
client and server transform into
something where you could kind of run
effectively like integrated tests that
kind of test the coordination between
the client and the server
but without you know kind of actually
having to have a web browser to know it
so you mean just not just client process
for example or yeah something that we're
kind of like tester but this thing that
I paid on the price we really focus on
this browser client and single server
instance but we are working on tools
that are aware of the transformation
that happens so you will have known unit
testing framework as we provide a known
debugger that actually knows like
something is happening in here with this
distributed call but actually that was
that local call from in your original
code so it will map back to your
original code so it is rewriting tools
so this is also rewriting too you have
to provide your own transformation aware
doing so that's definitely what we are
working at everybody else
so I think you said maybe this is future
work but with replicating data that's
supposed to be stored on the server is
it just like how is that replication
happening to the clients to ensure that
like it gets there and is there any kind
of ordering guarantees that happen yeah
so at the moment I've written my own
library that uses proxies to make sure
that on the client site when you do an
update it gets propagated and so on and
underneath it it uses our own RPC
framework so this annotation buffer
retry it also works on your data
replication of course if you have like
your own library for replicated data you
could rewrite the tools such that it
gives output for this as well but at the
moment we have our own small library
it's lost writer winds at the moment
that it implements that you could extend
it of course any other questions
I'll ask one question I never get to ask
questions I have a question about the
retries so you say retried twice but how
do you know it's safe to retry the
operation like for instance that the
response was dropped and so when you
retry it perform this operation twice
and it's not important that we retry so
if you get an exception and we also take
into account side-effects
so they only will be executed once so
when it succeeds if you retry it's not
like you're going to write twice to
database or so for example so it's only
on a network exception the ordering yeah
it's just on top of sockets so it's just
ordering a which you did them but we
don't give any guarantees there any
further questions okay let's thank the
speaker again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>