<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bruce Tate - Things that Matter (Lambda Days 2016 ) | Coder Coacher - Coaching Coders</title><meta content="Bruce Tate - Things that Matter (Lambda Days 2016 ) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bruce Tate - Things that Matter (Lambda Days 2016 )</b></h2><h5 class="post__date">2016-03-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/YjoVc5KFjaQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's humbling and a little bit
terrifying to be sharing the stage
many of my heroes it's a scary thing to
be following John Hughes and and Joe say
and Philip and all these people that I I
respect so very much a little bit
terrifying I'm not gonna lie so we want
to talk to you a little bit about things
that matter not from brew state's
perspective the first thing that should
matter to you listening to this talk is
that
in 2010 I got scared and that's
important to you because when when I'm
afraid I write and it turns out that the
books that I write when I'm afraid and
people like to read and I don't know why
that's true if I'm overconfident or
excited about something that's probably
the first sign that it's gonna crash but
when I'm when I'm scared good things can
happen from a publishing perspective
anyway and so when I got scared in 2010
I wrote this book called seven languages
in seven weeks what an absolutely stupid
title sure everybody can learn a
language a week and you can do it for
seven weeks running and you can do
something actually that's productive
with that experience but it turns out
that other people were scared too and my
fear was resonating with with many other
people we were seeing the same things
that the industry was changing that the
demands on programmers time were
changing that the old tools and the old
techniques weren't going to cut it
anymore and there were functional
programming conferences back then they
weren't as as busy as as interesting as
as well polished most of us were doing
object-oriented languages at the time
and it turns out that enough people
followed me through this
did the journey with with this book that
I was blessed to have a sequel to the
book that I wrote with with a couple of
a couple of good friends and and even
some other people that I look up to you
tremendously and so what I would like to
do is take not things that matter to me
but things to matter that matter to some
of those people and roll them up into
four principles that then maybe you can
take with you in your day to day job or
life or whatever so the first thing that
I want to talk about is the incubator
the idea that the problem that you're
trying to solve
when you build a language in the first
place it's very very important it's
actually critically important got a
question that I don't want you to answer
out loud
how many of you technically have a lot
of technical respect for a ruby so there
are a couple hands going up there I've
gotta admit that there are some things
that I really like about Ruby but most
of them don't have a lot to do with the
technology what I like about Ruby is the
community and the feeling that that Ruby
fostered Matz Matz the creator of root
Ruby was actually the first language
creator that I ever met face to face and
it was a near religious experience to me
and you know it every time that I
encounter that I encounter Matz at a at
a conference or or something like that
it's the experience is the same he's
he's such a humble kind and caring man
he doesn't strike me as the the kind of
bold aggressive person that you would
associate with creating the language
but his principles are so focused and so
true that it's hard not to get excited
with him so Matt's said this is
important now the primary motivation was
to amuse myself so wow he just wanted to
to play he just wanted to to crack open
his computer and and write a language
that that he could just have a little
bit more fun writing so when you hear
quotes from Matt's they always have
words like fun and enjoyment and passion
all those things are the things that are
respect about Ruby when I wrote seven
languages in seven weeks it's it's only
an interesting book if it's a journey
right it's it's not interesting if
there's seven disjoint little essays but
if they take you from nought to Tori
into place and to prototyping languages
into things that are more that are I
guess less step-by-step and more more
and the functional and the functional
realm it's a more interesting journey
but you have to come from somewhere and
Ruby was the place that I decided to
come from so it was almost like I was
pushing my little brother and in my
confession here is that I really love my
little brother
I still use Ruby day-to-day I like it a
lot
I'm very productive in it and and this
premise this idea of Matz's really shown
through to me
so what's fascinating to me it's a match
had tremendous focus that really shines
through in the language itself so
another language that is also
interesting to me is language called Lua
has anybody ever coded in Lua oh wow a
lot of you so in seven languages in
seven weeks one
so the reason of the way that I paid for
the seven languages was we asked the we
asked the audience we asked the other
people other readers of the pragmatic
bookshelf with my publisher of their
books and they picked nine languages and
I struck two of them rise struck struck
three of them and one of the ones that I
struck was JavaScript
you know I like JavaScript to have a lot
of respect for it but can you imagine
teaching all the principles in
JavaScript in a single chapter it's
nearly impossible because it's a little
bit chaotic not just with the
programming model itself but in how how
many places the programming model bleeds
into something that's a little bit
different but there were two languages
that I picked one for the first book and
one for the second book that I picked is
explicitly to help bring the reader from
object-oriented concepts to more
functional concepts through prototyping
languages one of those prototyping
languages was the i/o language in the
second prototyping language was Lua
now Lua I encountered actually building
some configuration software for for a
home automation system and it was
interesting to me when I interviewed
Roberto and he said that that's
precisely what the language was designed
to do it's fascinating how many of you
have had some experience with Alton so
by applause how many of you kind of
liked the experience so far so I think
that Elm is going to be a huge mover in
the next couple of years and the reason
that I say so is that Evan evidence
oblique he has a maniacal focus on
exactly what he wants alfe to be and
he's not missing the mark at all take a
look at the tag line the best of
functional programming in your browser
right and when I interviewed Evan I said
what are the things that you really want
him to be and what are the things that
you don't want it to be and he took
those two questions that were actually
in an email and he answered both of them
in this way I'll let you guys can you
guys read that so many functional folks
have way of saying extremely interesting
and useful things in a totally
inaccessible impractical way does that
resonate with anybody and I wanted to
fix this so with those two sentences you
know exactly where Evan is aiming with
this programming language so he says
that Elm is not about being
theoretically better it's about being
demonstrable demonstrably better so
Haskell was the language that evoked the
most fear in me with seven languages in
seven weeks I wasn't a functional
programmer at all it was not cheat
oriented programmer and a ruby one at
that so I was used to simple and I was
used to not really having a lot of
theoretical background and so Haskell
was a bit of a beast for me and it
wasn't until many years later that I
came to start to appreciate the
complexity of Haskell and it wasn't
until this past summer or actually about
a year ago when John Hughes and I had
the pleasure of sharing an expert panel
and that I got to appreciate the history
of Haskell and where it came from and
some of the compromises that were made
so when I asked John what what what was
kind of the catalyst for Haskell he said
well you know there was a language for
lazy programming at the time called
Miranda it was created by a guy named
David Turner and we approached David to
ask him could could we establish Miranda
as as the as the akka
lazy de facto standard for academic lazy
functional programming languages and
John said on the lazy side of FB you had
as many programming languages as you had
researchers and if he david turner had
said yes haskell would not exist so they
had a bogey that they wanted haskell to
be academic and free let a thousand
flowers bloom they wanted it to be
strict they wanted it to be pure they
wanted it to be lazy now this is
interesting to me because this is a very
successful and an aesthetically
beautiful language but it's also one
that's created in a committee and that
explicitly prefers academic to practical
it kind of seems a little incongruous to
me
but i think that the thing that made
Haskell successful was to focus on
exactly what what they wanted Haskell to
be enclosure are you getting a theme
here right successful languages have
focus rich Hickey said I wanted to lisp
for functional programming symbiotic
with the existing platform and designed
explicitly for concurrency over and over
and over you see that the successful
functional programming languages have a
maniacal focus they knew they knew
exactly what they wanted to be so I
thought I would take this test and I
would apply it to another to another
language so did some research on went
way back and I found
Java's original marketing tagline has
anybody ever seen it before
can anybody recite it okay it's a trap
don't don't go there your origin shape
you right so that's the first of the
principles I don't want to leave with
you today your origin shape you
okay the second of the principles is
that you should know your community and
let me let me preface this with with a
statement that your community the needs
of your community are going to change as
the things that matter to your community
or going to change as your community
matures right let me say that another
way so let's think back to the first
commercially successful higher level
languages you could argue that there
that these are two the first ones you
could probably pick a different point in
time if you wanted to but the point is
that there are three elements that are
pretty important here right the first
one is that the populations especially
relative to now are relatively small
right and those populations were
actually a captive audience because the
information was pretty tightly
controlled was proprietary and so you
really had to profit centers for a
programming language there was the there
was the language itself and then there
was the support all rolled up into one
and often this was bound to the
computing system that it was delivered
on as well so it was worth it to make a
huge investment in a programming
language and this was the model that
that we carried forward for many years
in the adoption of programming languages
that the formula was was pretty concrete
right you it you get a company tied to
some hardware platform you invest a
whole lot of money and then you build a
successful language and this it happened
this way for 20 to 30 years from you
know in the 50s with with in the 50s and
60s with COBOL and Fortran
and some of the earlier young languages
too you know was starting to roll into
the 70s with C++ and and into the into
the 90s with with Java and with with
small talk and ER laying kind of
following the same model but we started
to see the population increase but it
was still there were many different
languages but we cut those language we
cut those languages and in a couple of
we cut those populations and and some
very discrete chunks so it was tough to
get a critical mass but when the
internet happened the world got smaller
and the support changed from being a
profit center to a cost center because
the companies recognized that once you
captured the community that that big
things could happen for your language
and you could have more than than just a
an asset for a computing platform the
language itself could be a profit Center
for the whole company and they could
layer on on services and products on top
of that so so you still had large
investments creating proton dove
tailored around programming languages in
driving programming languages but for
different reasons now the large
investment was starting to drive
programming languages as profit centers
for four companies and a couple of
companies did this very well but as the
world got smaller the game changed
open-source has changed everything and
if you think about it just about every
language on this list has an element of
a very small group of people starting
the language itself right these aren't
large companies anymore that are that
that are driving the programming
languages the populations the
populations that we're talking about are
large
but more importantly it's easy to build
a critical mass so to give you an
example Java was developed primarily in
a programming lab if you look at the
languages that I'm interested in now the
elixir programming language was
developed by Jose a who's from Brazil
lives in Poland was discovered by a guy
named Dave Thomas and we were hard we
were having a tough time getting
critical mass for the web server the web
server at the time josÃ©e initially built
a web server called was a dynamo
I think his Dynamo and and we got
together I had a company that wanted to
invest in an elixir I really liked some
of the founding principles of elixir and
we recognized that it's too difficult
for one person to establish everything
that they need everything they need to
establish to build both the language and
a web server it's kind of lunacy right
so what we decided to do was to build a
Lego kit for web servers that's easy
right so we built the Lego kit for web
servers so we're taking our bait we put
it on the fishing hook we chunked it out
there and it wasn't two months later
till Christmas court found it and
started building the Phoenix framework
right so a guy from Brazil lives in
Poland
wrote a language that was discovered by
a guy in Dallas Texas right as when
after Dave Thomas wrote about it I
learned about it went to London to meet
with Joe's a to kind of see him at a
conference we kind of conducted and you
know we had this this mutual fanboy
moment where I was kind of nervous and I
said Joe Zee's nice to meet you I'm a
big fan he said well yes idiot your book
is one of the things that inspired
elixir in the first place and so we had
this mutual fanboy moment and we talked
about how to make elixir succeed and we
put another
in the water and we found this guy that
was in Miami Ohio and that guy wound up
building the so he wanted to building
the the web server that that we know
that is kind of helping elixir explode
today so think about what that means
that what that says about a community so
what that means is that it's it's
relatively easy for a small team to
establish a relatively big community but
that's a double-edged sword right
because that community is it can now be
more fickle because there are more
programming languages to choose from so
approachability really really matters
right
think about Elm the ohm language is
built around accessibility in fact the
first thing that you notice as you pick
up Elm it's probably something that
looks like this right how many people
found the Elm ripple in their first
visit to the Elm website it's crazy
right and without doing any work at all
probably in the first two or three
minutes of seeing the language you're
actually changing things and seeing how
the screen responds right you're running
the whole cycle you're pressing a button
to compile things you're seeing how
things work you're seeing how things
break you're seeing how things interact
on the screen you also are starting to
build an intuition about how the signals
flow and about and say hey wait a minute
that's different so so a mouse position
isn't really something that that changes
from time to time a mouse position is
really a signal a constant signal that
that map's X Y and a time that's just a
function right or think about the Ruby
experience how many of you have coded
Ruby how many people know this acronym
what does it mean
gnats is nice so we are nice so a lot of
people attribute ruby on rails to being
able to to the marketing strategy of
taking the biggest guy out in the room
and poking him in the eye right to me
that's not where Ruby on Rails started
to me Ruby on Rails started right here
Matz is nice so we are nice and what
this did is this attracted to people one
is a publisher named Dave Thomas who
wrote the pickaxe book that was really
what most people that learned Ruby
actually picked up to learn the language
in the first place the second person
that it attracted was a guy named Jim
Warwick and Jim Warwick gave don't get
excited that's polish not polish so Jim
Waris actually he built the things that
made Ruby approachable in the first
place he built the package management
system he built rake the build system so
it was very easy to to ramp up and get
started with with Ruby on Rails and then
once all that foundation was laid then
the marketing firm called 37signals
said okay what we need is is now a
marketing strategy that we could layer
on the very top of this iceberg to
actually birthed the surface and that's
in fact what happened okay I have
another weird story for you
erlang solutions sorry about this in
advance so I got to teach a workshop at
Ericsson Systems this is actually the
home of of Erlang or I guess I guess the
birthplace of Erlang now and the thing
my first impression of Ericsson and
teaching the workshop was the door so
you only think that this is a joke
the real door is actually much worse so
so as an instructor I'm already
terrified I mean I'm in Sweden I don't
know my way around I'm Dyslexic anyway
so I can't I can't read any of the
street names I don't know where I'm
going you know I I show up late to the
class and so this is all in kind of kind
of a hurried speech as she's just kind
of shuffling me to the classroom she
says okay everybody has one of these
badges just put this on okay here's the
door you see the door there's this big
green sign that says open me don't press
that if you do the alarm will sound okay
so what you do is you take you don't
take your badge if you if you swipe your
badge the alarm will sound you take this
one that's propped up on the door you
swipe it through there and then you walk
through make sure that not too many
people follow you through because of too
many people follow you through the alarm
will sound right and then close the door
the doors closed and then my class is in
front of me and I have to get started
okay I can't get through the door right
I can't get out of the door but then I
had a different experience I got into I
got into the room and I'm gonna try to
say this without getting myself in
trouble I don't know if I'll be able to
do it or not in Texas we have an issue
with with just disparate lines at men's
and women's restrooms whether you're at
a sporting sporting event or whether
you're in the office in erikson they
didn't have this problem at all they had
this problem solved they had kind of an
area where there's a common you know
hand washing area and everything and
then there were these individual stalls
that were mixed gender I said wow this
is concurrency for the restroom I was so
excited about this I was going to be
rich because I'm also going to take this
idea back to Texas and I was going to
stop coding and you know gosh I I would
have solved all the problems and in any
Texas football game which would make me
famous right but to experience all that
concurrency you had to get through the
door
right so Erlang is a beautiful language
that hasn't been traditionally a very
approachable language right but what
we're seeing is the ideas in Erlang are
getting a second chance because of the
language called elixir now I'm not
saying don't please please don't say
that Bruce said that elixir is Ruby for
Erlang it's not right I'm saying that
some of the approachability lessons from
Ruby are being brought to Erlang and
it's making a huge difference mix it's
like rake the package management hex is
like gems the documentation all of these
things are are starting to tell and the
overall ability of the elixir
programming language to attract an
audience because elixir knows the
community knows how to make approachable
technologies okay so now we're gonna get
a little bit more aggressive a good
programming language has to make a stand
you've got to be willing to make
somebody mad here are some of the things
that I mean so syntax we're not going to
spend an hour talking about syntax but I
do want to mention that there are a
number of stands that you could take as
there were latest syntax for example you
might say that syntax has a profound
impact on productivity right in fact
matt said that sugar makes believed that
sugar made programmers more productive
he says languages are enhancers for your
mind they shaped the way that you attack
programming another stand that you can
take is that syntax must be simple
in fact two of the of my favorite
languages in terms of exploring theory
embrace this concept small talk has one
of the most beautiful simple simplest
syntaxes of its time as does the closure
programming language you could carry
this you could carry this to another
extreme say syntax has a profound impact
on program design right like Lisp you
could say that syntax has to be
profoundly simple in uniform right and
Lisp data is code they're the same thing
in IO this is a prototype language a lot
like the Lua programming language that
has Gus you could read the syntax the
syntax form in you probably four or five
lines right or you could say you can
build macros the same way that they're
built in Lisp and you don't have to
marry yourself to data as code you can
marry you could say the syntax tree is
data right you see the difference
and that's the approach taken by lick
sir so elixir gives you says that we
want rich syntax but we want the program
of both syntax tree you could take
another stand you could say that syntax
has a profound impact on market share in
fact you almost feel sorry for small
talk because small talk is the language
that lost twice you think about it when
when C was around small talk was kind of
sitting back in the background was
slowly gaining gaining momentum in the
academics in the academic field and IBM
was starting to experience some success
with with a with the product that
eventually became visual age and it kind
of stalled right and the thing that
stalled it was that gosh we started with
this thing called C we said well wait a
minute if you want to do object-oriented
code why don't you stay within the C
community and in right and C++
now with C++ really object-oriented code
of course not most people wrote C code
in C++ right they wrote procedural code
in C++ so it's really like a C++ - -
right but what really happened is they
were able to start to move move the
program community to new their program
community - new paradigm and the same
thing happened a second time with the
same syntax family right when it was
clear that C++ was not object-oriented
and was really never going to be
palatable by the typical programmer you
know you can you can imagine the award
ceremony and and you know small talk
sitting back here reading this tape to
step forward and and the winner is Java
right
and Java basically made the argument
that we that if you want to ride out to
Tori any code you could stay within the
same syntax family right and even though
it wasn't wasn't really it wasn't really
that the best of arguments from from a
theory standpoint it was still it had a
profound effect on the market share you
can see stands you can see aggressive
stance taken by almost all programming
languages any language any successful
language today takes at least one
aggressive saying haskell takes a bunch
of them will be lazy will be pure will
be strict and static right early there
was a great conversation that i heard
between joe armstrong create over of
Erlang and and david turner the creator
of miranda and you know david was it was
a big advocate of static typing and and
strict lazy programming languages and so
david sincerely looks at at joe and he
says you know i never expected a
language that was so dynamic to be as to
be as reliable as Erlang has become
right and the reason is that Erlang was
built to be reliable from the ground up
first things are concurrent or built
concurrently from from the ground up and
second things were built with the
supervision structure how many you saw
shows a stalk yesterday so the
supervision structure basically means
that when something breaks we can
restore it to the last known good state
right that's the shirt when in doubt or
keep calling letter crafts I had to read
my own shirt that's great
but basically basically if you're going
to succeed you have to take a stand with
with elm there were a couple of stands
the first one is that you have to be
approachable we've talked about that one
the second one is that callbacks tink
right so what are the principles we've
talked about so far what was the first
one yes where you come from the
incubator what's the second one know
your community and the third one make a
stand right so the last one is adapter
die right what to think like us to think
for a moment about the great inventions
and the reason that we think that the
great inventions are great the wheel
that's a multiplier of leverage the gear
the printing press it's really a
multiplier of mental leverage right
electricity the transistor and I'd like
to think about programming in the same
way efficient programming design is
about the multiplication of leverage so
it's about taking ideas and representing
them in idioms and if you think about it
the language that can roll up the idioms
into larger idioms so that you need
fewer idioms to represent an idea it's
going to be the winner right and that's
the language with the right set of
abstractions so when you talk about
extensions and here I'm really talking
about taking the language and extending
it beyond its its intended its an
intended space
you're talking about things like in
Erlang the parse transform in Java it's
aspect oriented programming and
inspection in Ruby it's the open class
that looks something like this right so
here I have a string and and no class
and an object and I have I declare the
method blank question mark right and
this lets me represent this lets me call
any object and say are you blank right
so efficient program design takes the
same principles you can take the same
principles and apply them to efficient
language design so as I approach the
languages in the in both seven languages
in seven weeks books I recognize
something the languages that kid that
were bootstrapped
were the more effective were the
languages that moved the most quickly so
that adaptation really became so when
language could adapt itself rapidly you
could actually only then could you get
to the place where you could extend the
language with on things like dsls that
that make a language so much more
productive and now we're kind of getting
to the the mature content of this
presentation okay don't hit me I'm going
to say the word macros let me talk a
little bit about about what I mean so if
you haven't seen a macro before
basically this is a list program it
means take take this function and add
one to two right the thing that's
interesting about that is that this is
data and this is also code right this is
a program that's going to be executed
and this is a program that's not going
to be executed this quote transfers
transforms the function
to string right and then I can reason
about this program in the same way that
I could reason about any other data and
then I can extend the language in the
language itself right so let me give you
an example of a place that this could
make a difference and the Erlang
language this is a code this is some
code that's going to that's going to
take a reference spawn a process and
then a way to result right so it's
basically it's going to allow me to do
some intermediate work while spin spin a
second process this is what the same
program looks like in the elixir
language I create a task do something
else and await the task
okay now doubtlessly I could create
something that looks a little bit closer
to this and Erlang with the parse
transforms and other tools but in the
elixir language since I'm coding at
basically a lower level or at a higher
level of abstraction I have the the
language creators themselves are working
in bigger idioms and then the
programmers can work in larger idioms so
that so that I'm working with tasks
instead of saying this repeated pattern
right another example this is a pipe
operator
it's like composition in Haskell and I
want to talk about combining this
operator with a couple of tools
the first one is def macro and that's
basically the technique that we just
talked about we're not going to write a
macro but I want to show you kind of
what what the end results would be the
DEF macro allows me to treat code is
right and I want to talk about deaf
protocol deaf protocol takes an abstract
type and allows me to bind common
behaviors to that abstract type okay so
let's say I have some widgets and I want
to filter them and map them and then and
then say take the first five right it
should be a pretty common functional
type program and you can see that the
pipe works a lot like a UNIX pipe where
I take the output of the thing on the
left and a Probab light to the thing on
the right and the nice thing about this
is that I can represent things as an
assembly line but with protocols this
becomes a little bit more powerful and
valuable right so a stream is exactly
what you think it is it is a it can be
something that doesn't have a defined
end point right so streams are lazy
enumerables are eager right and I could
take the same program and I can run
through run streams through them instead
of running running enumerables through
them so I can also now we're going to
apply the concept of macros right let's
say that these couple of tasks are
really expensive so maybe I want to run
on these these parts of the programs in
different processes well I just call a
macro and the macro can inspect this
syntax tree and and take this apart
basically fire a process and pass the
results on to another process right or
maybe I want to use a process farm
instead right or maybe I want it to be a
distributed farm
or maybe I recognize that this model has
too much marshalling and a better model
would be to have the distributed form on
the outside right so the idea is that I
can take this these two common common
ideas def macro and def protocol
these are idioms and I can layer them on
top of each other and get a multiplied
effect okay so other examples of
extension like this we have type classes
in Haskell that are tremendous
multipliers of leverage or the idea that
elm supports raps io in something called
signals so you have this idea that
rather than exposing monads to my end
user I wrap them up as language features
or that in Giulia the idea that I can
take macros and I can represent flat
data structures as distributed data
structures so I could have I could have
scientific programming languages that
that can distribute that can manage
concurrency much better than then the
existing alternatives or you have the
interest programming language that can
that can start to introduce programs
into the type specifications so that if
I have a if I want to add two lists
together well rather than just saying a
list of a list plus the list gives you
another list I can say a list of size M
and a list of size n add it together or
give you a list of M plus n so
adaptation is very important so what are
the four principles we talked about
what's the first one the incubator right
your origins shape you the second one
your community ya know your customer the
third one make a stand the
fourth one adapter died right any
questions thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>