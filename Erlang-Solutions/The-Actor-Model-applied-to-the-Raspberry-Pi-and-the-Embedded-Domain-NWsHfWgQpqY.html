<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Actor Model applied to the Raspberry Pi and the Embedded Domain | Coder Coacher - Coaching Coders</title><meta content="The Actor Model applied to the Raspberry Pi and the Embedded Domain - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Actor Model applied to the Raspberry Pi and the Embedded Domain</b></h2><h5 class="post__date">2012-11-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NWsHfWgQpqY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone my name is boomer and I'm
an embedded systems engineer here at
their own solutions to tell you in games
talk a bit about the action model apply
to Raspberry Pi in the embedded domain
the stuff I'm going to talk about Jeremy
orange raspberry pi specific you can
apply to any other very boards and in
the agenda we have the current state of
embedded systems what are you dealing
with at the moment what are the tools
what kinds of those these we follow and
then we'll talk about the actor model
they are going to much maths and then
I'll talk you through the airline
embedded projects that we have been
working over the past couple months and
then we'll look at how we can develop an
icee model method systems using your leg
and i'll mention a few our experiments
with the Raspberry Pi and after that
we'll talk about the future and some
questions and answers if you have any
before I start can I get a show of hands
or a hope of you who have worked with
embedded systems before this is what we
drop one Raspberry Pi does count good
and how many of you are familiar with
the ER lying in actor model in general
that is quite well depends i might skip
through those concepts quite quickly
since it's a family audience um ok so
what is it a metal system careful so an
embedded system on for quell the
terminology embedded system is quite
muddled unfortunately so we don't have a
clear-cut definition but the infinite
wisdom of Wikipedia states that an
embedded system is a
computer system designed to the won't
ask specifically often with real time
constraints unfortunately your phone
because of the architecture it uses
could be an embedded system but it is
not because it's you can do pretty much
everything yet but you can grow stuff on
it and email so the sort of a meta
systems are going to look at our the
sort of embedded arm class devices that
can run linux and any other operating
system so before I get to that C is
still the front Califia better world
just to sort of make the point that most
of the amid engineers are not functional
programmers and I us so after we have a
look at that the different ways of
dealing with a minute systems the first
one is the bare metal bezel Ozzie you
don't have an operating system or any
high-level abstractions that you have
with say Linux generally this type of
coding implies that you deal with
registered little operations on
peripherals um the second class of and
then the architectures using these sort
of setups are a 10 v 8 or 16 bit devices
um you then have the real-time operating
system driven systems these are
generally used for mission-critical
systems or medical equipment they do
provide you with certain guarantees such
as scheduling guarantees and jitter
guarantees and so on and then we have
the embedded Linux rule which is
essentially a slimmed down version of
the desktop linux that we use but the
main difference being that you have
hardware interfaces you have to deal
with we're going to focus on the artists
and the embedded Linux kind of devices
and not worry about it bare metal for
this for the sake of this prison
asian so real-time operating systems to
give you the notion of tasks and these
are your compositional units that you
used to break down your largest systems
into you can group them together /
functionality and then create sub
systems etc and the messaging between
these sort of task these tasks happened
wire and operating system surprised
interprocess messaging which usually
happens where shared memory and you have
to use mutexes and forth looks to access
hardware peripherals otherwise nasty
things might happen for instance if you
have many tasks trying to access say one
GPIO pin then that can potentially be
very dangerous so in the software world
if something crashes the chances are the
consequences are not fatal but say if
you have a robot controlling a sort of
safety equipment or something like that
if it crashes or if the pin gets out of
control then potentially you might kill
someone with so security oh yeah yeah
well yeah and you also have different
types of scheduling in wheels on
operating systems the most common ones
are either pre-emptive scheduling one
are we setting an event-driven
programming or you can have a simpler
round-robin kind of structure where your
tasks are processed no time multiplex
basis so embedded Linux is not a new
concept it's been around for quite some
time now but it's becoming more and more
popular due to the abundant supply of
cheap hardware that we have today so
some examples so that would be raspberry
pi legal board beaglebone gumstix and
also the flurry of boards inspired by
the Raspberry Pi and yeah I mean getting
started with a minute lyrics today
doesn't
much money whereas a few years ago but
in the distant past you would spend
Huntley to be hundreds of pounds and get
started with Saudi sort of development
it is a familiar set of tools for
software developers so since it's Linux
you can use your favorite scripting
language or compiler or tool chain but
it is actually quite a different
territory for embedded engineers who are
used to say rtos concepts so you can't
directly translate an arduous
application to the Linux world without
having to rewrite majority so you can of
course use threads or other stuff to
emulate the tasks but that means you
have to change the way your
communication works etc and the device
driver framework is pretty horrible so
in order to do hardware interfacing you
need to dive down into kernel modules
quite often because the documentation is
horrible and it doesn't quite work the
same weight same way on all the
platforms um so what sort of challenge
is revealing within the embedded world
at the moment we're our applications are
getting more and more complex and to
serve those needs we are getting more
and more complicated system on chip
platforms that have millions of things
embedded into them I have a slide on
this later but the complexity of the
chips is just ridiculous and we now have
this thing called the Internet of Things
which means that all our embedded
systems are becoming connected and
distributed we didn't have to deal with
these sort of issues back in the days we
were simply employing RT
is to do things and it's 2012 so x and
market is a big issue so learning new
tools or adopting a new tool chain is
quite dangerous when you're fighting to
get your product into the market so we
have to find ways to reduce the gap
between the methodologies you're used to
and the new methodologies are going to
adapt in your products and you also have
the multicolor and heterogeneous devices
that needs there are different
methodologies to your single essentially
for loop it interrupts um so they add
some sense everyone in the room is quite
familiar with the actor move along
quickly skim through these fights but
the actor model is again not a new
concept it's been proposed in the
nineteen seventy three it has roots in a
distributed systems and funny enough
artificial intelligence so actors are
specified as the universe Universal
primitives of concurrent computation and
they're essentially building books are
distributed in modular systems that you
can build upon they are in their essence
of point self-contained in atomic they
have no side effects and they're gonna
have shared state so and they're also
implemented memorizing programming
languages today I'm going to talk about
early but you can get them in Java and
Ruby and even steeples pasta and the
interest if you want if you want to know
Jesus or guess the import the
interesting bits that deserves its own
slide is the communication happening
between these actives so they use a
synchronous message passing to
communicate and they have a notion of a
mailbox and messages are processed in
the order that they received in and
because they're all individually
separated
isolated he can partition your system in
a way that if one part of your system
goes down it won't hurt the others that
will talk more about that in a few more
slides so the operation of the actives
are quite limited and well defined so
they can only do three actions they can
either do local decisions in their
process or change their internal state
they can spawn new actors to deal with
the data coming in or if they want to do
other operations that they can't
accomplish in their own States and they
can also send messages to other actors
letting them know that something has
happened or if they want them to process
something so a simple example would be
to have say partner night sir that
performs some calculation it perceives a
message with a set of values that it
needs to calculate and then it may
decide to respond or create new actors
to deal with subsets of this data and
once these new act is owned by the sort
of main actor to their calculations they
can then return their results back and
the main process can then collate and
collect those results back and send it
to the original requester now if you
paid attention you might have seen that
that was not in sequence there is no
guarantee that the messages will arrive
in the sequence which is one of the
downsides of the model unfortunately so
one of the main limitations of the model
itself is that there is no notion of
inheritance or general higher of
hierarchy mentioned in the system so
you're pretty much on your own to create
your system hierarchy and languages and
libraries do implement their own
versions of this hierarchy structures
the surface message passing can be
problematic for so
applications so you can because of the
ordering of the messages are like
guarantee then you can't apply this
enforcing to all the applications of
instead of I can't think of many
applications that will be affected by
this in the embedded world and another
problem is that the abstract because the
definition is quite abstract it might be
to inconsistency in larger systems so
you can choose the treats say every
integer in your system as an actor or
you can choose to use say a larger
process collection or saner line process
to be an actor and then structure your
system around that so fine grain coarse
grain arguments does play a part in this
system um so the Erlang embedded project
has been going on for a couple months
now and it's it's a partnership between
the University of Kent and airline
solutions and we're investigating using
online as part of concurrent embedded
systems and we have been playing around
with different platforms Raspberry Pi
has been one of our main platforms and
and we're developing a set of tools and
methodologies and creating sample
examples sort of use cases and sample
applications to hopefully convince
people that are lying does work in the
new sort of challenges that be faced in
the embedded systems world if you want
more information you can go to the
landing medicom or we have it
as well is it just me I'm melting just
you watch thanks thank you just
experienced a girl turn over so again I
will totally slice quite quickly since
we all love and user line but why we
chose our line well since the talk is
about the axle model a line doesn't
remember yep tomorrow rather well it's
also been used of many companies and in
fact it was originally designed for
embedded systems so Ericsson used her
life in the telephony exchanges or
telephone switches which by their nature
or embedded systems they also it also
has support for concurrency in
distributed systems out of the box you
don't have to do anything extra with it
to create different nodes and different
networks and communicate with them and
it also has certain features like super
white linked links between processes and
supermorgy hierarchies etc that lets you
create robust systems very easily there
are other features but I'm pretty sure
we're all aware of them Starsky so
Erlang has simple and consistent
Airacobra interpreters in Iraq is that
can
or structure systems in a way that
failure and subsystems don't cause a
massive crash postal system this partly
is a feature of the actor model because
all the actors are isolated in their own
sort of level environments and another
interesting feature that is quite in
relevance embedded systems is a dynamic
reconfiguration aspect I eat a hot
loving and you can link processes
together in the event of a failure they
can let me children know that something
as fail again going back to the topic of
safety in embedded systems this is quite
important so if you have a GPIO
controller or a supervisor you should
know about individual GPIO pins or gpio
controllers failing so that you don't
write to them or you don't try to read
from them and get that values so in this
sort of scenario that I've mentioned
your gpio controller will be trapping
exits from all these external control is
that you might be employing in your
system also we all know that let it fail
is our mantra or ideology in the airline
world this has the added benefit of not
having fluff in your application code so
you can get rid of that and abstracted
away into modules that's ending with the
supervision of the system which needs to
clear a code then ultimately better
testability
english wheels let's go sorry let's go
let's go because I fit study done by
Henry the fourth of a similar system
plus plus so it's less code which is
good get on take off let's not talk
about C++ we having such a good yeah it
also provides supervision hierarchies
and in the embedded world we have this
notion of watch dogs which are on their
certain primitive form there are times
and if your system doesn't respond to in
sort of it in a fixed period of time
they kick start the system and reset it
to a known state and you resume
operation from a safe known point so by
employing the boat ebisu provision
hierarchies you can essentially create
many subsystems with supervisors that
act as their watch them and if they
don't behave can we start those
processes and then hopefully continue
the operation of the embedded system
from a loan and save points so this is a
very simple example of how you might
have
multiple supervisors and multiple worker
knows very abstract example must limit
and finally Erlang does have a very good
support for implementing external
interfaces for talking to the external
interfaces c is here to stay there's no
disputing that you can't convince all
embedded engineer stitch see entirely
some of the hardware drivers or even
some of the interfacing bits will be
written in C and that that is ok because
that's one of the main features Berlin
was designed around i think when we were
designing these original systems they
had to interface to external seeker so
we have the notion of native implemented
functions and ports for drivers to link
external bits of code into the Erlang
morante fast efficient sure how I'm
running on Linux like an hourly
implemented these deposits in face
insider la when you from Russia PR I
mean you can be bought some subjects and
files and data means yeah you can use I
mean if you're just talking over sockets
etc it can use gen tcp and UDP and don't
really talk with them or you can wrap
them around nif an if file essentially
and then you can directly call your code
from within Erlang without having to
resort to using sockets and so on I have
some examples I can show you later so
all things considered erlang we believe
that the line could be the maestro or
the orchestrator is connected and
distributed embedded systems let's talk
about raspberry raspberry pi is a very
interesting project and
sure you're all very with some of us
still have our own pies and robots which
is pretty cool so in essence it's a
small computer system with a 700
megahertz processor in 256 megabytes of
RAM that's not the important bit the
important bit is that you can buy this
for thirty-five dollars or 20 or couch
and the fact that it's so cheap means
that I think up to this point they have
sold somewhere in the region of 400,000
forms and they were talking about
setting up to a million units until
Christmas it is very exciting because
it's an embedded Linux board that will
end up in some enthusiastic hackers
hands and the possibilities are truly
ends and we have a robot from our simon
friend Samuel over there and a lot of
people are doing some extremely cool
stuff it and that is exciting and we've
been playing around with the Raspberry
Pi this is a very basic buggy that's
been have been playing around with
developing
the hardware modules etc and most
importantly the raspberry pi foundation
is a nonprofit well it's a registered
charity and the mission statement is to
get this board into the hands of school
children now if we can provide a useful
set of tools that explores this tool
actor model in concurrent programming
and hardware interface in using the site
level constructs that means that these
kids who are future engineers and
programmers will learn these concepts
now and when they get to become
programmers they can say oh I've read
this thing called the optimal water line
then hopefully I mean since where you're
heading in that direction we need to
teach people how to do more conquers and
vandalism that might come in handy we
are hoping go you got the early
acceptance on the birthday party not yet
now do know but yeah sorry so yeah we
have our Raspberry Pi package by the way
if you have a pie and if you don't want
to pile it on your own or if you think
that the version that beam has is quite
old you can go to erlanger solutions of
home and download the raspbian package
we will be creating a slightly leaner
and smaller version of our packages in
the near future and we're hoping that
might get including the default
distribution but nothing set in stone
yet so if you look at the Raspberry Pi
as an embedded platform to experiment
with you have the general set of
peripherals
in any other embedded linux board you
have gpio 0 yards I sprayed CSP iOS if
you want to do audio codec and other
applications and also a PWM as well so
that's not going to look at an example
on how we can abstract the hardware
interfacing into actors and how we can
implement them in our line let's say we
have a process called process 8 and we
have a physical t here in in 17 we can
implement these processes so that we can
directly talk to the pin and initialize
it so let's say we want to dispose it as
an output and bring it to blink of you
led step or lengthy le livre and we can
send messages downwards and that might
talk to and if to actually physically
set the registers and so on but the
problem with this approach is the
typical problem that you have in
embedded systems access control and
mutual exclusion what happens if you
have many other processes writing to it
at the same time now because the actor
model does have a mailbox this sort of
registered twiddling won't happen real
time but that means that if he send it
sort of different stage messages the pin
might be toggled on and off or lower
high quite quickly for an LED that might
not be a problem but if you have a motor
or a device that didn't like being
toggled really quickly that might cause
a real problem so the way to get around
this problem is to create a yep so this
might be quite dangerous the way to get
around this problem is to create these
proxies hardware proxies
so this is ed io but you can think in
the same terms for other protocols as
well i squared CSPI so so you can send a
message to the GPIO controllers we
initialize a pin say 17 as output and
that can spawn a new actor or a new
process process so now instead of having
direct access to the pinion potentially
causing problems you can talk over this
proxy process and then set this date and
so on but this means is you not have
someone in charge enforcing certain
security criteria or safety criteria to
the actual hardware access so we can
have other processes sending messages to
it and since we have some sort of
functionality in the GPIO proxy to take
care of these hopefully this will cause
a problem in our system so the GPIO
proxy concept replaces the looks that we
have in the traditional sense of
embedded design it does provide you with
access control and mutual exclusion it
can be used to implement safety
constraints so the problem I was talking
about earlier the toggling rate of a pin
for instance you can create some sets of
rules within the proxy so that you won't
damage the external hardware that your
control so again this further simplifies
the application code because you're
taking away those safety criteria etc
and putting them into a central unit so
you're reducing the number of lines on
your
individual gpio access modules are and
in effect that makes testing easier and
since you probably can use the GPIO
module elsewhere in another application
with using gpio you can reuse that bit
of code instead of having to dig it out
of the existing application modules you
can abstract it into its own actor and
that's okay we can do that on the
Raspberry Pi just out of interest and I
we were able to create up to 136,000 our
line processes so a few extra processes
won't hurt you can do that so we can
further abstract this of this notion of
proxies and hardware access modules and
create a platform agnostic high level
API is that can be used in other words
as well so so far we've been talking
about raspberry pi specifically but say
if we had a let's talk about the GPIO
module so we have a certain set of
operations that we condone the GPIO pins
so we can initialize have been as an
alternate in put you can write to it we
can read from it and perhaps we can use
the interrupt capabilities of the pin so
this is our component API and even if
you go to a completely different
architecture let's say you go from an
arm or collector to emitter the chances
are you still will be using these
primitive sort of operations on the gpo
events so in essence this is a platform
agnostic bit of your application so and
you also have for gpio you directly
control hardware registers but say if
you had a temperature sensor that
connected to say an I squared Z boss now
you have another layer of abstraction
that you have
through before you access our grief and
that is your I square C boss again the
ice curtsy bus will give you a primitive
set of operations and they won't change
between platforms so this again is a
platform agnostic layer that you can use
in your applications finally this is
unfortunately platform-specific the
actual bit of code that's hydrated
twiddles registers or set certain memory
addresses to certain values this will be
hardware-specific but what if you follow
this layered model what that means is
majority of your applications could be
ported across different architectures
quite easily since the platform specific
bit is only the very bottom layer that
does nothing then set registers
especially so the temperature sensor
example I've given you earlier if you're
in Linux we can just use a scissor fest
and on top of that villar i squared c
bus driver and the sensor api if they
were in bsd we could jump to use this
control or if you're on say a mix
platform that doesn't have Sisyphus or
sysctl drivers we can map memory and
take little bits directly we can do some
register voodoo so what's coming here is
the blue box is that they don't need to
change when you're moving from boards
aboard so this gives you quite a
platform agnostic way of creating your
applications so that was just a very
simple example defeat the GPIO this this
is a real block diagram i got from Texas
Instruments website when you're dealing
with this many modules these are all
different hardware modules by the way
you sort of really can use this model of
abstraction in your complex applications
and yeah only when you get
deal with a sort of complexity that you
truly appreciate how this model can
employ your assistant and if you're in a
better chance that you will have to deal
with these sort of big things in the
very near future because this is the
quare this is where we're heading these
sort of complex system on chip devices
are the future unfortunately
unfortunately because they're quite
exciting they have multi-core processors
and DSPs and all sorts of stuff we are
also working on an interesting bit of
project called you're lying embedded
training stuff so this is a complete
package for people who are interested in
developing these connected distributed
embedded systems using Erlang
essentially which gives you all these
high level features that you can use in
your systems but we're coupling that
with the low level stuff so like the
linux device driver frameworks for
direct our door access and linux and so
on and we're all we're working on come
on hardware platforms which is also
included in this training course that
you can take away and develop more
implications on so this is just in the
idea face at the moment if you're
interested now I'm talk to me or torment
and we'll be happy to hear your comments
on this so I think that's about it from
me thank you very much for listening and
if you have any questions I'll be happy
to hopefully answer them thanks
novelties know-how and networking in
every so feel free to tops off to some
more beer all the all the little goodies
are out there please feel free to have a
look we've got t-shirts we've got laptop
bags football beanie hats we've got
loads of so feel free just help yourself
21 and if there's anybody within the
room that you feel might be able to help
you a question or answer feel free
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>