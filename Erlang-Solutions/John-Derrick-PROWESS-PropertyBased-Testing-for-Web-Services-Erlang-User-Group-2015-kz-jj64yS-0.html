<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>John Derrick - PROWESS: Property-Based Testing for Web Services - Erlang User Group 2015 | Coder Coacher - Coaching Coders</title><meta content="John Derrick - PROWESS: Property-Based Testing for Web Services - Erlang User Group 2015 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>John Derrick - PROWESS: Property-Based Testing for Web Services - Erlang User Group 2015</b></h2><h5 class="post__date">2015-07-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kz-jj64yS-0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you so I'm going to commit several
cardinal sins that the first one is this
talk is neither technical lord geeky so
you can all those who want a technical
and geeky talk this is not the place
I'll also have lots of pointers in it so
that's even worse heretical I explain
those later on um so but think of this
talkers going back to to Simon's
comments this morning think of this as
talking about a Hut it's a Hut not in a
pioneer museum but a heartful of
interesting tools that you might find
useful and my job here is just explain a
bit about some of the tools you might
find in our Hut and our Hut is called
prowess and that stands for property
based testing for web services so it is
an EU project and it's an interesting EU
project so that's there's a double
whammy as we say in the UK what's what's
its aim will its aim is to improve
testing particular for web services
through up taking use of property based
testing and we'll say a bit bit more
about that later and it's I'll talk
quite also about an ecosystem that
inning since that's the spine of the hub
of the hut that we're living in and
that's a tool quick check you put you
probably all know about poverty based
testing so that allows us to test
systems and services in different
languages Allen Java Sea and so forth
but the the system models and properties
if you want an airline grounded they're
all written in elling okay so there's a
bunch of us have been involved for the
for the last three years or so I'm from
the University of Sheffield as Henry
said my name is John Derek and this is a
consortium and the product these slides
why didn't put my name on the front
there very much a product of the whole
consortiums efforts and in fact many of
the pictures have been developed by by
Simon at the at the backs of credit
credit cares where where that should lie
so this is an air an airline ecosystem
that we were trying to further and
develop we had some existing parts of
the era of the ecosystem in place
already so the tool quick check wrangler
refactoring tool megaload
but for load testing in essence one of
the things we're trying to do was to
expand that hair care system so move
them from that picture to this sort of
picture ok so we're populating the space
some of we're populating the airline
space with with tools which are
specifically designed fair Lang some for
Jarvis I'm even working on C and some
focused primarily about web services ok
so there's lots of this that the
majority of this talk is just pictures
so that's the level that so I will
attempt to explain via pictures how all
of these things fit together one part of
it which lists the sorts of things that
we've been doing is this picture at the
center is quick check and where the
space of property based testing in
essence it uses that and tries to
augment it with those other things how
to link tests and properties how to
estimate complexity developing cloud
testing framework and so forth and they
sit around this ecosystem and allow you
want to do interesting things or useful
things that you might wish to do ok so
the next part of this I'm going to try
and illustrate what we've done by our
series of simple pictures that puts
together in a sensor a system
development says what what you need to
do what you want to do so imagine we're
starting off we got an implementation
you want to test that and you get some
test results well we've been interested
in using quick chek you i'm sure you all
know that the tool that allows random
test generation to generate the tests
for this implementation how does that
work well you write properties you
express properties in air Lang and on
the basis of that there's some random
test generation
so in a sense it's it's a bit like
model-based testing but you're not
writing a full model uniting particular
axioms that you want to hold that's
that's all very well but sometimes these
properties are hard to understand hard
to reason about and so forth so one
thing we've done is develop some tools
to help us reason about properties so
here's the first tool so these slides
will go through and illustrate with
little pictures some of the tools that
we've been developing and the pointers I
talked about in fact will be pointers to
organizational people where you can find
out more information okay so one of the
tools we developed is read spec and that
allows you to understand properties and
models as natural language so it takes a
property expressed in airline and then
translates it to a QQ coma-like form of
natural language to express the express
the poppet property so that's one way
that you can help understand to help
people understand what a property is the
other way I mean property is a very
abstract there perhaps mathematical the
other way you can help people is by
representing a property as examples
examples of wonderful ways of actually
illustrating what's going on so we have
a tool called good examples which helps
you understand a property by generating
some representative examples of it so
it's the incense it illustrates nicely
the property this is again another way
in which one might help an atan I've
user of quick check or somebody new to
airline to understand what's what's
going on okay feel free to stop and
comments or questions as you as you wish
so you might have a properties you
you've expressed in number of wise you
understood those from from a property
sometimes you want a specification and
sometimes you want to understand how
existing tests fit into that and so
we've developed a number of tools which
use inference about the underlying
system of the test to do further testing
and to illustrate what's what's going on
so one of these is called sign amps and
that helps you visualize a system as a
finite state machine so it takes the
underlying system looks at what's going
on looks at the events allow it may be
on the basis of testing and then
visualizes that as a finite state
machine where you can see the states and
the transitions between that another
tool target particular towards web
services is James which again and is an
inference tool it's allowing you to
infer models from from particular
particular web services and I'll sell us
a bit more about these later then we've
got some tools specifically targeted
towards the the web services domain so
Jason Jen for generator builds quick
quick check generators from the JSON
JSON data we've got wsdl which helps you
express wsdl types as quick generators
so it automatically translates some of
the things to take out some of the the
tedious burden of writing all writing
these wrappers and finally on the web
services domain there's WS toolkit which
helps generate an airline interface to
the underlying web service and actually
in combination with a tool wrangler
allows us to do some automatic
generation of the refactoring scripts
we've got a an airline implementation of
webdriver further user interface testing
of different modes of running a web
service
so all of those in a sense living on the
the web surfaces space okay so let's
let's go back again to thatthat original
picture cuz I'm going develop this
picture in a number of number of
different dimensions you've got quick
check you've got properties you're
testing implementation concurrent
implementations are often particularly
hard to test looking for data races and
bugs which are to do with the inherent
scheduling of the events so we've
developed a tool called pulse which
provides additional support for
concurrency scheduling by providing a
deterministic scheduler as part of how
the test should be generated we've got a
support for fault injection by fault
check which combines fault injection and
property based testing to elect to see
how you can support robustly some of the
faults that might occur now this fault
injection is getting on to looting the
space of how to look to see how robust
your testing process is and there are
two tools that we've developed along
these lines the first one is Mewtwo
which supports mutation testing which
looks to see how good your test suite is
by mutating the code in checking whether
you've caught any of these new errors
and smother which helps measure test
coverage so its support for a particular
type of coverage mcdc coverage which is
more powerful than lying coverage which
is currently provided by by cover so
these both of these lasts two or three
tools about looking to see how good is
your test suite is it likely to cover
everything one as you'd like you to
catch errors if you make small
perturbations
in the code complexity check looks to
try and identify some scalability issues
in code by trying to generate some
worst-case behavior in terms of its
counter examples here you can spot where
you're likely to get worst-case runtime
behavior and also generate empirically
an estimation of the actual complexity
of the code without actually having to
do some complexity analysis ok going
going back to this this picture this is
very nice and simple you've got
properties you've got an implementation
and tests but of course real life isn't
isn't like this you don't have one
implementation you don't have two
implications in fact you have several
implementations how do you compare those
how do you measure their differences how
do you rank them well as one of the
things we've been looking at is how to
measure that empirically in
quantitatively and developed a tool
called ranker which compares different
implementations judging whether they've
passed the same tests passed a subset of
their tests and whether there's a
counter example which demonstrates their
their difference and this can visualize
a tree of implementations to a
particular model you need a quick chek
model to to measure that against you can
see where they lie here in comparison to
each other and see which one's the top
if there is a top which ones are lying
further down in terms of the tests tests
passed okay and finally megaload is is
our support for cloud-based testing
allows you to run a number of phases
with user profiles in to look at how an
implementation before performs under
higher load than just one use
in a lab base scenario okay so that
that's a run-through of incense the
space that we've been trying to inhabit
the tools that are lying in there in the
hut and as a representative sort of
sample of the sorts of systems that one
might be interested we takin a number of
case studies here's one that we've
looked at some detail so it's a vodka TV
which is a it's the sort of setup you
get in a hotel room you enter the hotel
room you get a screen displaying your
name and you get a number of options you
can watch TV you can play again you can
plug into the internet and so forth the
there's a number of systems involved in
that you've got a set-top box you've got
components you might have various
tablets or pcs people have bought in and
they've got to work together so you get
architectures which look a bit like this
what's the take home message from this
whale or take our messages you got a
number of components so components are
going to be issuing that communicating
over api's via different protocols and
different means okay so you've got Java
you would HTTP you got airline you got
JSON or XML and so forth how on earth do
you test something like that well part
of the tools we've been developing have
been tested on this this actual system
this is a system in in production we've
used this to try and work out what's
needed and refine some of that some of
the tools so that setup you typically
get you get parts of the Middle where
implemented an air lang other parts
usually as I said you can gauge HTML and
JavaScript and very specific maybe
in-house protocols okay you've got
different types of interactions and
these innocents are typical for things
which are developed in the inner web
services like manner so what the how do
the tools work on something like that
what's the toolset we've developed so
just a little more a slider piece with
some text on about each each of those
tools okay so the first ones you can
play spot the pointer on this one so
here's a clue the pointers down at the
bottom so my pointers are just pointers
to people on the companies or
organizations if you want further
details about anything we developed do
do getting in contact so as I said
before couple of times quick jacks are
the center of our ecosystem and it
allows sort of controlled random test
generation it's not just random test
generation but you can control the
weights about the distribution of the
data that's taken in testing and it does
this from properties of interest this is
why we call it property based testing so
what does it provide you've got
Combinator's to divine properties you
can observe the distribution of test
data and you can define means to
generate test data in appropriate ways
okay so one of the things I said we've
done is to look at using WS toolkit so
how to combine that there's an example
of what we've done how to combine WS
toolkit with Wrangler well thats support
for refactoring in erlangen and haskell
before that to support evolution so
evolution of systems is any any real
system is going to never be static in
that sense so for example what can you
do using ringing Wrangler you can infer
changes between your wsdl descriptions
and use these automatically generate
refactorings scripts okay for how to
change one model in tier then as she is
based upon calculating a specific
distance between the debate
specifications okay so the idea of this
is trying to support model evolution
automatically as much as possible do
much as the routine work behind the
scenes
megaload is our load testing tool so it
does it's as a cloud-based hold as low
testing a system and it allows you to
generate some profiles to find some
phases and users in to look at the load
and then also use the shrinking
mechanism there's a shrinking mechanism
in in quick check that takes a very long
counterexample to some property you want
and shrinks it down to the minimum so
that's again a nice way of illustrating
the hard part of what has got wrong and
you can use this in mega mega load to a
PI shrinking to look at the minimal
counter-examples in an effective way
okay so sign apps sign apps and and
James are two ways that sign ups and
James are living in that space up there
you've got some existing tests what are
you going to do with them can you use
those existing tasks in a sense the
existing understanding the behavior of
the system to infer anything sensible or
anything interesting from from them and
both sign ups and James allow you to
infer models of some sort so it from the
models you can then generate properties
you can get an understanding of the
system but you can also use the models
to generate further tests from them so
both working slightly different ways
James in furs models from unit tests
written in j unit sign up in furs finite
state machines and i'll list illustrate
one of these in it in a bit and uses
that to visualize a difference between
some of these models so there's a point
to that it's what the point at the
bottom so Jenny unit tests essentially
your instrument what's going on to track
the combination sort of control flow
plus data and extract that information
to build up a representative model of
your web service and again drive
tests from that that's that's the
architecture then that architecture
generates a model you can visualize that
and then translate this modeling to
quick check and then once you got a
quick check model you can traverse it in
all sorts of different ways allowing you
to generate new tests okay so in a sense
both of these tools work from
representative data generalize them in a
way but you can both visualize them and
use it to drive more more tests than you
would have then you had originally so
another example of this is a sign apps
that synapse is actually an interface to
it an existing model inference tool
called state sure that's actually a
grammar inference tool and it does two
there's two types of of inference you
can do here so passive in front as the
name implies you just you sit and watch
what happens and then you just take that
data and you try and build a model from
seeing that active inference then has a
sort of control loop back in and allows
you to say from this initial node of
initialize what happens if I do that and
you find out a bit more by interrogating
the system slightly and from this
interrogation you build up a picture of
how the system behaves which in this
case you illustrate has a finite state
machine which is well I'll show you a
picture on on the next slide once you've
got that you you can do two things one
is you can just build a picture of the
system so you can see what's going on
but also you can apply some differencing
algorithm some model differencing
algorithms to try and understand the
difference between systems as they as
they evolve and using the visualization
you can actually visualize that
difference so if I probably best
explained if I show you this this
picture so this picture is showing a
number of things firstly it shown you a
finite state machine so a finite state
machine consists of state a finite
number of them look at the clues in the
name I
transitions again a finite number of
those between the states which represent
events in the system so here's here's
something from a frequency server
example you can see transitions to stop
allocate and deallocate frequencies are
happening down here so that's what a
finite state machine looks like overall
and you can visualize that just you get
an understanding the system and then the
model differencing allows you to say
take one system another might be a
different implementation of that are the
same standard the same same API and look
at the differences and we code that in
different colors here so you've got
green and red telling you what a new
parts for the system in green and which
parts of the system now no longer a part
of it to the beta part in Redis has now
disappeared and so this is a only one of
a number of ways we've used
visualizations in the project to help
people get an understanding of what the
system is doing underneath ok so in fact
sign apps and James as well they're
there about inference but they're also
about understanding properties and
models so as I said before one of the
tasks we're trying to do is make
property based testing accessible to
users to smooth down the learning ramp
if you like for when you're faced with
these new tools in the hut so I'm apps
is one tool and the others that I
mentioned earlier so Reed spec and good
examples are tools to help you
understand properties so respec helps
you understand the models by taking the
specification in airline and translating
it into a natural language format and
good examples
is is properties by example if you like
so here's a little example with the
bottom simply QC contains property to
test a delete operation of the list
module so you might have something like
that in that in the blue in the top a
simple property for all I over a list is
it not the case that bubble ass you're
testing to see whether the delete
operations successfully occurred and you
can translate that automatically into
cucumber like operation that in a sense
demystifies some of what's embedded in
mathematically in the property trivial
if you understand the property in what's
going on if you're new to it it's a way
to get a bit of an English grasp natural
language grasp of what's going on okay
so that's one way translating the
English I can help you understand a
property the other way it's by viewing a
property as a set of unit tests so you
know there's there's a there's a slight
tension going on on here properties a
great very their general powerful that's
really what I want to like want to write
down but unit tests are much easier to
understand so we're trying to traverse
that axis if you like so you take it
take one property you generalize it to
table take a property's you get one test
case how to they take that example
generalize it and generate a number of
different test case based upon that to
help people illustrate different aspects
of it and of course that doesn't measure
the whole space of the property other
what you want have needed a property to
start with if it was just a set of
examples but it's about illustrating
things and illustrating and
understanding okay then as I mentioned
before there's specific support for web
services for taking web services written
in different formats generating
components needed by quick check
in order to do the testing so Jason Jen
takes a library generating quick check
generators from json data from written
in jason schemers and then actually
using that with a model to actually
automatically explore the web service
we've got a domain-specific language
which allows you to to reuse the syntax
to to techna sense to take out some of
the burden of writing out the wst times
by automatically generating them the
quick check your generators so those are
where those sit in terms of the pictures
just slip through that so going back to
that overall system we've got a number
of different tools and they're trying to
attack different parts of the innocence
of problem space so part of what we've
got is about scaling so we saw in the
original picture the vodka TV there's
actually not one system that you want to
test their there's a whole load of
components now it would be really nice
not to have to write one property which
expresses everything there's all the
calls between the sound forth partly
because that property be too complex to
write down and secondly you get it wrong
so what we've tried to do is offer some
support for scaling property based
testing based upon the division of other
system into components so we're using
components instead of a single model and
a way to combine properties written in
individual components using abstract
descriptions of call outs into a single
model there's a library for mocking the
behavior so you don't have to write out
the behavior of that underlying thing
there you just write a mock of what it
might do give some representative values
to return for the data and these can
then sort of be clustered together to
get an overall system you can check by
property based testing without doing the
the individual ones
as part of the scaling we've developed a
neat tool called more bugs so quick
check is great it's great in the small
scale if you you run it you find a bug
you've got a counterexample they'll even
give you about the smallest
counterexample so what you go do while
you go where you fix it okay fix the bug
and then you test again you find another
bug and you go back and do that again
now that kind of gets laborious and
sometimes you get into a bit of a a
self-defeating loop there what would be
really nice is if you can find
essentially all the bugs at once partly
because there might be about roundabout
the same problem partly because you want
an overview what's gone wrong and then
go and fix it well there's a tool called
more bugs which does that so it allows
you to find all and all in inverted
commas because it's it's almost all at
once what it does it finds a bugs it
generalizes that bug to try and cap more
capture more the other similar bugs and
then modifies the generator in quick
check to avoid that particular book in
the first place and that allows you to
find more initially than you then you
would otherwise so that allows you to
scale up the process of using quick
check one thing we find using quick
check your you're writing these these
properties specifications if you're
writing them just in a lying again
there's a there's a there's a learning
barrier about about using that and
sometimes pictures provide a much better
understanding of visualization of what's
gone on and so we provided support for
not just graphical representation of the
underlying system but for graphical
editing of the quickcheck models so here
here's an example of that you might
start off with this a very simple
specification
that you're trying to generate tests
from that's what that's the one on the
left hand side well it really is a bit
simple there's just one node in it and
you loop background and you realize
quickly that actually your system isn't
that simple instead of going back and
rewriting some airline you'd be nice to
bow to edit that graphically well you
can now there's now a front end that
allows you to pull off that in it node
from another one started add the two
transitions where they are to the
picture on the right and it
automatically in the back generates the
underlying quick check model that
represents that so you can do this all
in in in in a nice editor now okay so
that's that you would set you up nicely
you've generated some terse you can
graphically edits you've got probably a
component based testing dividing the
components you've got lots of test
Suites and you want to know how good
those test suites are so we've provided
some tools for mutation testing and
coverage which help you in a sense of
validate the quality of your your test
suite so smothers a tool that's used to
assess mcdc coverage so mcdc coverage is
a coverage that checks not just every
line is covered in your code but every
combination of values of decision points
you might make in your code is also
covered there's a there's a screenshot
on on the right hand side of how that
works the issues come because you can
cover every line without actually
covered all the combination of things
you should do and that's represented by
different you can see the top they're
different colors of green and an orange
and red telling you how much you've
covered of the portion of your of your
decision tree and giving you a
percentage of whether you've how much
you've matched it or not and so that can
be that can be using it in the same way
as as coverage cover does and gives you
slightly more information what
a lot more information about what you've
what you've covered so that's one way to
look at how good your test suite is you
clearly want a decent coverage of your
code the other thing you can do in the
in the testing domain is do something
called mutation testing so mutation
testing says well I've got some tests
I've got a clear a whole test suite here
supposing I make some very small changes
to my code have your existing tests
within these changes by definition
errors have your existing tests can
actually capture the fact that your code
is changed okay and that's that's the
subject known as mutation testing you
perform small mutants on your code base
on your code and there's we have a tool
to do that that's what the tool does and
you can automate that to do it randomly
or you can pick ones you might want to
mutate specifically yourself and then
you can measure whether you exist is
existing test suite kills mutants as
that's the terminology and that tells
you whether it's stable under small
changes okay and then then finally on to
fault injection there's a tool fault
injection fault check for C code which
combines fault injection and property
based testing using quick check quick
check to drive it okay so all of those
are thin incense in things which sit
round quick check cubic has also
developed support for continuous
integration so the issue there is you
got some test suite you got some code
you might want some repository where
your code is is stored you might want to
check in your code what would be really
nice is if your tool your tests until
then runs the same tests again in the
background automatically and tells you
which have those are passed or not and
that's known as continuous integration
so there's a specific product quick
check see I which does this now it's a
server that runs q quick check
on a project an open source developers
can use this is free free for use and it
runs a full version of quick check but
it ends in the background as long as
it's logged for for open source okay so
that's that's that's really nice so how
do these all fit in in terms of what
we've tried there's lots of different
tools what are the different themes in
my in my Hut well one of the things is
about scalability and I said we're
trying to give you specific support for
components and mocking there's other
support for accessibility trying to help
people understand properties my examples
bye-bye illustration there's been
sophistic support for web services and
support for if you like discovering
properties or discovering tests from
existing one tools like James and sign
apps and also support for improving your
testing checking the quality of your
testing suite and finally support for
evolution through ranker WS tool keaton
and wrangler okay so that was it that
was a brief prowess on speed as if you
who want your afternoon drug so
acknowledgments it really is a
combination of all our efforts and
support from EU framework 7 is
gratefully acknowledged and that's it
Henry doesn't have to go 10 and 5 and a
safe actually win tone but oh so we've
got plenty of time for questions well I
just wanted to ask if is it all right
product iced is it is it a kind of
product I may download somewhere and
read and read me and our world examples
or is it
Mike research project and I'm supposed
to assemble it myself from a couple of
detached project some of them commercial
some of them research projects it's a
continuum of tools some of which are
commercial and some of which most it at
the research hand it's not one overall
package we didn't believe in providing
one overall property development
framework that you have to use but
rather there's a lightweight integration
command line where you can where you can
call it all from they are standalone
some of them use the others in the
background but their stand alone so you
can go to the website look at the tools
download the specific ones some are free
and open source and some are commercial
I don't if that answers the question so
that there's a there's a gradation like
all of these things between and where
they sit some commercially develop used
by he's around the world and some are a
new any more questions can you be so do
it more under your technologies used
what's behind those tools there's that I
mean there's a variety of different
things quick checks a commercial tool
bicubic other tools have been a written
in Erlang as open source so there's a
whole variety of the whole variety of
thing some use other components so the
new mutation testing uses the Wrangler
in it in the background but there's a
whole whole variety in many of them
written from from from scratch within
the project
well then I suggest we thank young</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>