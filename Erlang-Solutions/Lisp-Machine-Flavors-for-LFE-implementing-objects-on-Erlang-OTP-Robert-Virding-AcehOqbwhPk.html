<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lisp Machine Flavors for LFE implementing objects on Erlang OTP - Robert Virding | Coder Coacher - Coaching Coders</title><meta content="Lisp Machine Flavors for LFE implementing objects on Erlang OTP - Robert Virding - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lisp Machine Flavors for LFE implementing objects on Erlang OTP - Robert Virding</b></h2><h5 class="post__date">2017-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/AcehOqbwhPk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">on top of LFE and just look at some ways
of implementing them as I'm a fixer of
them right so yeah
bit about so be a bit about LFE have
been about lisp machine flavors
implementing the flavors and also
implementing flavor instances the actual
objects themselves we all that work all
that way downline yes
so LF e stands for this flavor tower
lang
it's a lisp running on the a line system
it's a real lisp with real lisp syntax
you can see it with real lift macros I
mean macros done correctly right
that they should be but to run
efficiently on the beam it's been tuned
to run on the beam so it might look
common lisp alike but it isn't common
lisp so it has the standard our line
data types to be mailing date type
sustain be mailing handling of modules
there's no way to get around that if you
want to make an efficient system a few
other things as well for example all
date is immutable I mean there's nothing
strange so just a new bit of example
code it looks very list beep so this is
actually real code to be honest is that
not just made up for this one so I'm
again you can see recognize a lot here
I'm defining a module virus here I'm
exporting to functions started 0
arguments and start of one argument then
I'm defining the function start here
with no arguments and start with one
argument right typically or defund like
like you get in Common Lisp or this
actually works it starts a virus
so what haft you started this and you
know that connects to this node will now
become an effective with the virus yeah
it works as well too and it breaks
through everything where you're running
distributed le the codes about half of
half as you get as much so I mean this
is just basic basic hat looks like I've
got it I've worked my spawn process here
I have a case where I'm checking today I
use and doing pattern matching
so pattern matching has been built into
the language
things like this for as well and I can
do my other things I've got I've got a
access of course to all the bits and
stuff like this so I can call register
here so I'm registering the module what
my process under that name I'm calling
that kernel here to monitor nodes I'm
writing out you've been infested and I
go into a loop and basically what the
loop does every time the connector kn'l
tells me no it's been connected I will
do some RPC calls and stall code into
that module and then call that and
infest at night it's about half a page
more of code form and surprisingly
enough it works yeah so this is just a
bit of a bit of a bit of LFE just to see
what it's like for so it is a very it is
a really very lispy syntax for the
language for and as with most lisps a
lot of things here are macros so both
define and def module for example
they're just macros okay so that that's
that's the straight bit there for the
next interesting thing is getting into I
think getting into lists machine flavors
so this was an object-oriented system
running on the original MIT list
machines it's from the late 70s so it's
a very old system for and there was no
real final version of this it just kept
developing as time went so if you look
at the documentation every year there'd
be new features in it right and
eventually it was enormous that was just
basically throwing everything they could
think of for we're doing things here we
just can look at a few bits of it right
yeah it was a precursor to the Common
Lisp object system but I think it's much
more fun how it was designed how they
were thinking and things like this for
as well to the close the the close one
was where is it's more standard very big
but I think this one personally I think
these this one are much more fun right
and yeah so you could define a flavor so
this is pretty much the standard syntax
from the list machines except I've added
one thing at the end in flavor you're
saying when it ended so I could define a
flavor with a Flay
I can define instance variables we had
components we'll see more what these are
and within for that flavor I could
define methods for it and I could also
to make local function definitions I
could call within the method there's
nothing really strange at this level for
it so I could give in instance variables
not give default values for instance
variables and these values the
expressions you gave for the values were
then evaluated when you created the
instant not at the time I was defining
the flavor or compiling or whatever
these were done when them when the
instance was created you had a bunch of
options so I implemented some of the
options some of them were very specific
to the machine that some of them weren't
so the first bunch here gettable
settable inimitable instance variables
that just to find which of the instance
variables i've specified up there
the system will auto-generate func
access the methods for ID so will we get
able instance variables they'll
automatically have a get method define
florida's the set the balls would have
both gifts and sets and in in in edible
ones they were the ones are allowed to
initialize give values for when i
created an instance otherwise you
weren't allowed to do that right by
default so they're pretty
straightforward the next set are
required here that says ok I'm making
this flavor I'm connecting deal with
components but for this flavor to be
usable I require that some some other
flavor I'm mixing it with provides a set
of instance variables or provides a set
of methods or actually requires as extra
flavors as components it's just saying
for my flavor to work to be happy I need
these extra things someone else has to
fix them for me that's what that that's
what that set says right there are other
things as well you could give
initialization values EQ default
initialization lists and things like
this for as well to the abstract flavor
is slightly different that
that this flavor can only be used as a
mix in two other flavors I cannot create
an instance of this flavor by itself now
this gets back to how things were
combined how things were components were
used they did they didn't call them
classes they these were flavors and I
didn't have super classes I had
components of mixing and there were
other flavors this just says this flavor
can only be used together with something
else I cannot create an incident this
one so yeah methods well you can define
callable methods they're a couple of
different ways of defining methods we're
going to see two of them or three of
them depending on when it counted the
default ways I do I do a def method of a
name here with a definition for it and
that's called a primary method that just
defines a method for this and the
definition would be this would just be
standard Lisp LFE definition would which
include the arguments and song for so
again seeing we're running on top we're
running on top of LF e running on top of
our line
I have methods of the same name and
different number of arguments that
they're they're just different methods
right I didn't mention it here well
indirectly when you're running at their
feet it's the same as hairline you can
have functions of the same name and
different number of arguments they're
different functions there's nothing
strange from the Aling point you it's
nothing strange and yes I could just
define methods here and these these will
call primary reasons to call primary
methods there are other methods as well
we'll see some one these are primary
methods yeah and you can define local
functions that only exist within this
flavor
we're only accessible from other
functions or methods from within that
flavor so it's it's quite in that sense
it's quite I think so far it's quite a
standard package of your 200 package one
now we get into the components now we're
going to combine these things right and
so with a flavor you can give it a list
of components that was if we step back a
couple of things here here I can give a
list of components
this one said they can be empty and this
is an ordered list of flavors that this
flavor has as components it will
incorporate things from these components
okay and the important thing there it's
an ordered list for what the ordering is
I give I've given this sequence of
components they of course can have
components if for themselves and nested
things like this for it and from my
point of view this flavors point of view
the list of components is the flattened
tree of all the components and this tree
can be is actually an Acer cyclical
graph so you can have components that
have other components which you can
incorporate them as well too so I can
have circular list of components here
and this whole thing is just flattened
out in a nice way they're predefined way
for this allows me to mix in flavors so
here with these aren't really like
classes or super classes we're mixing in
I don't know I
- think of more like cooking right I'm
gonna make a pot of something so so I
want to I want to meet flavor I'll Chuck
into my pot and I'll have some I'll have
some salt flavor and maybe some onions
and maybe some things mixing in it's
much more mixing in and these flavors of
course they can have other flavors as
components I can mix in quite complex
things right in for example I can mixing
for making it courage - I can mix in a
curry flavor which is actually composed
of a lot a lot of other spice flavors as
well - for but not quite as classes in
that sense I can view them as classes if
I want to but they're not they're much
more general this is what I think was a
fun bit about it to be honest so what is
a component flavor do well it defines
instance variables so component flavor
can have its own instance variables and
what I will see in my flavor is just see
the union of all the instance variables
from all the components there's nothing
strange there I will defines which
methods exist for a flavor so for my
flavor so I'll incorporate all the
methods the union of all the methods
from all the components but now we run
into a slight problem
so what happens if I incorporate the
method the same method from multiple
components for multiple flavors so I
might have defined it as a mom I can't
component small to define it this is
where the ordering comes in so are my
flavors assumed to be the first one in
my list of components but you will step
down that ordered list and for each
flavor if it occurs multiple times take
the first one in that order
so if you're cured by default if it
occurs multiple times you take the first
one that's the one that's used yeah that
means that if I define a method in a
flavor
I have no guarantees that if this
methods called my version of the methods
one that's going to be called so in Mike
in my food in my food flavor here I can
define a bar method there's no guarantee
that this is the one that's actually
going to be used oh I might be a
component of another flavor which
defines its own bar which means it's
it's what's going to be used not mine
right so I know difficult to have no
guarantees that what is actually going
to be used and which ones are going to
be used
now that causes problems okay of course
but we have help with demons to get
around this so here is a simple example
using composition so I'm defining two
flavors here I'm defining a flavor shape
up here which has got two instance
variables x and y now I've said that x
and y are settable that means that
they're automatically going to define
method for setting and accessing these
instance variables there's going to be a
set X and a and a set Y and an x and y
meth is automatically defined here
that's nothing strange here I define a
method here moved to which takes a new X
a new Y and I set the values for this in
this instance the x and y values this
instance it UX a new why this return
okay so I have a set form here for
setting their values of instance
variables
I have a relative move to here which
takes Delta X and Delta Y and bumps up
so we have a get forgetting the values
and I've just bumped those up and set X
to that one and the same thing with Y
you know okay and down here I have a
draw method which just writes out some
information when I call it just drawing
shape at where it is where the values
are nothing strange about that okay so
this is this is one base flavor here and
I can define a circle flavor which uses
shape as a component so it's going to
get all the stuff from components get
it's going to get the x and y variables
and things like this and the x the x and
y methods and so on it's going to
inherit move to and rail move to get
those as well but it defines its own
draw so when I create an instance of
circle and call draw I'm gonna get this
draw I'm not going to get that drawn we
also have our own instance variable
radius here so here we're just two two
flavors a base flavor and one
incorporating that okay so far nothing
strange right but here we even see now
that this drawer is not called because
I'm using it inside a circle which has
its own draw so how do we get around
this problem how can i how can I be
certain that for a method something I
want to be done with that method is
always done so far we seen a cut I mean
we saw we saw the draw here this draw
will only be used if no if no flavor
using me as a component or is in a
component list of someone else before me
which is define its own draw and of
course there was a solution to this
problem well there is one it's called
Beeman's so I can define demon flavors
whatsoever sorry demon methods yeah so
the sequence of choleric may over
override and slide method right so we
have a foo method but someone earlier in
the component lists a flavor in a
component list also has a food method I
can't do much about that so I have no
idea how much where how my flavor is
going to be used
so we can have demons do that and I can
create before and after demons for each
method I want to so I can define a
method here as fool - before demon
here's a safe fool and after the emit
again with definitions same number of
arguments etc etc now what happens when
I define demons is so if we have an
example here we'll go there first thing
go back yeah so what when you when
you're creating the flavor you you are
correct you look for each method you're
create what's called a combined method
which contains the primary method which
is the first one in the list of
components and before and after demons
so what happens is when I call that
method I'm first going to evaluate all
the before demons for that method then
the primary method and then the after
demons define for that method and then
for demons will be in this in the list
of ordered list of components and the
after demons will be in the reverse
order so I can always plug something in
here I might be able to plug in the
method but I can plug in a demon to make
sure that that so I can get access when
things happen and that's what this
example here was so I'm defining a
moving object flavor here
with the instance variables X Y X
velocity and Y velocity and default
values those just zero they're all
gettable so I'm gonna get get get get
methods I'm gonna get set methods and
I'm just saying these are inedible yeah
I can't set the X and y there's no set
function there's no set method defined
for x and y and they're not edible as
well either now I can define a move to
method here which just set text to a new
x and y to a new y and i can do a set
velocity method here which takes a new X
velocity a new Y velocity and set to x
and y well to those that's that's why
moving object flavor so but now I'm
going to define a snail
it's nail flavor here and the thing with
a snail is it moves very slowly so what
I want to make sure that what I want to
do is if someone sets the velocity I
want to make sure that the velocity
isn't too fast for my snail
okay I don't want it's now going 100
kilometres an hour for example that's
slightly above so for my snail flavor
I've got two instance variables max X
velocity and max Y velocity that just
says this is the maximum velocity for
this flight this snail that's what I'm
thinking about and it's a moving object
very well Interpol so I can set these
when I create them I don't do that here
the trouble is I want to get into the
set velocity I want to make sure that
the velocity is not too fast right now
if I were to define a set velocity
method there's no guarantee that mine's
going to be called I might be my snail
might be so to the other with a moving
object or something else which has a set
velocity which overrides my set velocity
so how can I get in well I can define an
after daemon so I know that if set
velocity method is called my after demon
will always be called so now I can go
and say yeah well are the new I've got
the new X velocity and you what Y
velocity I'll just ignore those for the
time being I don't need those but I know
that somewhere there is a set velocity
method which should set the X velocity
and the Y velocity instance variables so
now I'll just check I just make sure
they're not too big if they so the X
velocity is bigger than max X well I'll
just set it to that I'll just hit the
minimum of them so now now this after
daemon this will always be called and I
know that I will do that after the main
the main methods been called now I hope
no one else goes does another after and
does something different so why not do
it as this missus before well I don't
know what the main method does here so I
can call this an afterlife and I can
have before demons or I can multiple
before before demons you have long
sequences of things going on here before
the actual method comes in and this is
what this is a way to allow me my flavor
always to get in there and do things if
I want to be real say for example I
could do both before demon air and and
after demon but I don't need that here
and the combined method well that was
actually called when you when you call
the method is a combination of did
before demons the primary method and the
after
is this is built up by the system when I
do it my so this is great
if I had this mechanism I can do things
something's a lot more there were a lot
more other features as well that came in
for example you could have there were
ways of combining the primary methods so
I could make a version where I said I
want to call all the primary methods it
may be how to do a sequencer and on them
so if they were true I would keep
calling them otherwise I would stop and
things like this so a lot of ways of
combining methods you could define your
own combinations as well too but I think
this was enough at least for this anyway
so yeah so now how am I going to
implement this now we aren't interesting
with the implementation so there were a
couple of things that they had here as
requirements which I think fit very well
for example there was no requirement for
the order of defining and compiling
flavors so if we go back and look at
look at my my snail in my moving object
just because snail used moving object as
a component there was no requirement
that that that moving object should be
compiled before snail okay now stir the
same thing with the shapes every what
the shape and the circle there's no
requirement that shape the shape is
compiled before circle and again this
fits very well into normally howling
modules work there's generally no
requirement in which order the modules
are compiled just as long as they're
there one that one actually want to use
the mind there's a pretty
straightforward here you could for every
flavor build a set of set a set of
methods and compilations for every
flavor using the combined methods it has
it is difficult to do because you get
circular paths around the methods you
have to resolve those I mean how they
were resolved is very straightforward
very standard but you have to resolve
that so it can be very difficult to do
that for every flavor and then you also
have these abstract flavors we should
only be used as mix in which you can't
use as base flavors and that would mean
yeah so it'd be difficult keeping track
of the component order
it also means okay I'll do my snail so I
compiled my snail and compiling and make
something then someone else uses snail
as a component which means they have to
go compiling in things and suddenly
things change right my after team is now
caught not not callable I expected to be
was going to call some other time
for example so that was very it's not a
good way of doing it you could do it but
just be it's better to be cunning we can
do round things here and now we now
we're getting to interesting bit so what
we can do is if we look at the
definition of a flavor we can see two we
can split up in two parts well logically
split up into two parts so I can define
I call a static module I haven't got a
good name for it
I can compile all the things all the
information that's in this flavor I can
compile all the methods both before and
after demons and the primary methods I
can get a lot of information about
what's going on in the flavor I can do
that without having to know anything
else so I can compile my primary method
without knowing how it's going to be
call if it's going to be calling the
same with the demons so I can do that
for every flavor I can compiler
separately for every flavor I mean that
I'll keep track of the instance
variables which options it has because
they're used when you can when you're
building stuff will get it later I can
look at the methods I can look at local
functions I can build up this one module
containing all the static stuff frame
and information and information as well
and then I can make a dent dynamic
module of the component of all this
combined data which I actually use what
I want to make an instance so when I
make an instance I then have to work out
an instance this flavor what do I
actually need from all the other flavors
and then I can build stuff and then I
can build with all the instance
variables and all the combined methods
and then I can resolve how the hell all
the methods and demons are going to be
called for that instance or that well
for that base flavor and that I don't
have to do all the time right this is
where the cunning bit goes in so I can
the static flavor is only flavor
specific data it has no interdependence
at all between anyone
I can make that split to make sure that
it's just purely local stuff like an
a-line modules is purely local so there
no inter flavor module dependencies I
can create that and save that at compile
time I can compile up this module make
it beam follow up and just leave it
there and all the methods demons all
local functions are in this module okay
and then what I call the dynamic one
that contains the things that are
specific for that flavor when I create
when I look at that flavor it contains
all the combined methods
it contains yeah so it contains all the
combined methods a bit of data but that
I can create at runtime okay so that is
that's created at runtime I don't have
to save the beam file for because it's
created at runtime so I'll dynamically
build that build that module compile it
and just load the beam straight in I
don't I don't actually create any be
involved for it and that I do the first
time yeah so it's not saved and that all
the code it calls all the might all the
things that do things there in the
static compiled ones so the combined
methods here call things in the static
modules it's just putting them all
together just bunching them together
right I can do that afterwards and that
I push I delay compiling that until the
first instance is created for it so I
create the first instance for a flavor
then I go in and I build a dynamic
module for and compile that loaded in ok
and that is very nice because this
allows me to compile all the static
module so when I'm building a release
and having that code as the standard
beam files in the release and then it
dynamically I'll build the other stuff
when I need it
it also means I'm only going to build
the do the dynamic modules for the
flavors which actually are creating
instances of not anyone else for one so
I can compile all the static flavors I
could put all that in it all that in the
in a bean file in a release and I'll do
the other stuff
when I'm running yes it needs the
compiler to be there but not too
difficult so how does this look it's
very straightforward this is one of the
benefits of using lists by the way it's
so easy to generate code so if you take
all the square braces and make square
brackets out of them you've got out
you've got our line our line lists right
that's literally all is right so yeah I
can show you the code afterwards it's
extremely straightforward so from for
example my moving object I will define a
function call movie object flavor core
which is a static one and here export a
lot of functions there are a lot of
functions that give information about
the flavor
I'm only including a couple of them here
so there's a name function there's a
list of components which case with zero
here we have primary methods well there
are two primary methods defined here
there's a set velocity and move to
velocity of two arguments there no
before demons and I'm running out of
space as now after demons as well and
there's information about the the
options so I can see which is settable
which are get a bullet cetera and from
that I can generate methods I generate
one function here I call primary method
and this contains all the primary
methods so that there's there's a clause
for each one or multiple depending on
how define the function so here's a set
velocity it's called it's going to be
called here with three arguments which
is the the name of the of the method
itself which is the reference to me and
a topple containing the arguments to the
court and then I go through and here's
the code for it and I'll do this for
every method and here for example are
some of the here's acceptable the set of
all for set X it's set X itself is
topple value and things like that does
that so define all the primary methods
here and here's just a general error
saying this primary method didn't exist
if you happen to call it wrongly and you
do exactly the same thing for the before
demons and the after demons so a
function with one function containing
Clause has fallen before demons one play
afterimage
and this I can do a compile time this is
straightforward and for the snail
the snail flavor of course exactly the
same thing it's a snail has moving
objects as components we see there no
primary methods know before demons
there's one after demon and here is the
after demon function for defining after
demons right there's a basically all
contain Jack there are more more info
more information functions here for
getting information out of it so this I
can compile up at compile time and then
when I'm when I'm making my instance
then I can define the the dynamic module
so this is the dynamic snail module the
snail flavor module here and the exports
a name exports instance variables any
keywords few other things component
sequence this is the sequence of
components for this flavor worked out
for all its components and things like
flattened out through that and here we
have the combined methods we have and
then here we have the combined method
function so here we we've got name about
instance variables we've got the
component sequence it just contains the
name of the flavor and the function of
the module that flavoring static is in
there for each one each one of the
flavors there's a predefined vanilla
flavor which comes the end which adds a
few extra methods mainly just for
printing stuff out default printing
stuff for him
and here we have the combined method
combined methods function again for each
of the methods here were just defining
which ones exist so this saying yes
there were topple here say we have a set
velocity of two arguments its defined in
the moving object method or sorry flavor
there are no before demons and there's
one after demon in snail so just step
through for all these here these are all
empty here so here we see some coming
from vanilla and here's an init to start
up in a term right when you kill a
killer method just add as well to and
then there's a combined method function
here for all the combined methods so
here for example we start this on we
have the move to which has no before
demons and that just it knows it would
look in here and see that the move to is
in moving objects so recall moving
objects the primary method with move to
that should be self and args there much
tukya the set velocity that has a demon
so in there no before demons so we're
going to call a primary method and then
we're going to call the after demon and
the prog one just means we just throw
away the value return value of the after
demon here so this could mean in
sequence be a number of the four methods
before before before primary after after
after that just builds that up at
runtime to do that and then there's
narrow saying there was I'll try to call
this with method doesn't exist I just an
undefined earlier so this is the code I
generate when I create the first
instance and I'll just run this straight
into the compiler it generates the
binary I never write it out the Beame
file I just load that binary into the
system and now I have it defined in here
that's how it works so it's great it
works for the next problem you just
gonna look at is okay so now I can
compile up all my flavors I can get all
the combinations right I can I can there
are more options I can add more options
as well to it but now when you look at
the next problem how am I going to
implement a an object instance for so
what's a good way of doing this in an
a-line system or a bad way processes are
one way but if you look at the crystal
characteristics of an instance the
number of things how are they handled
what's the weight of it how much it
costs to have an instance how do I
access it is it shareable or not right
persistence does it go away by itself
there's a garbage collector will they go
away by themselves and what happens if I
get an error in it etc and if you look
at the data looking at this definition
of the code in the modules all you
actually need in the flavor instance is
the link to saying what flavor what
flavor it is where the flavor module is
and the instance variables that's all
that's all really an instance has to be
because everything else is in the
modules the actions the modules and
we're gonna look at three alternatives
for and the first one well it's a
process
that would one way be your standard way
of doing it it's a process it's very
straightforward its shareable the
reference is just the pillar I can share
that and anyone can access it
it's very more classic or instance like
and it's handled by reference sock just
pass this thing around for this is what
I actually use in the current
implementation
however it's not automatically reclaimed
it doesn't behave like data you pays
like a process which means I have to
kill it to get rid of it explicitly kill
it won't go away by itself which is not
quite what you expect by objects if
objects are data right it's heavier than
classic oo instances most object iron
systems assume very lightweight objects
I might be wrong here but they I think
they do and it's very difficult with
recursive access so if I do a send which
is a synchronous send to a instance and
it sends to another size send to
instance a and it sends a request to
instance B which sends a back a request
to instance a the system hangs because
they're in deadlock sitting what they're
synchronous they're waiting for applies
to each other now you can make you can
make it simple to make a hack so if I
call myself I will not send messages to
myself that's easy but I have no way of
getting around this it's very difficult
to get around this fact that I can get
blocking consistent blocking and
unfortunately it can be very difficult
to detect this so if I'm using someone
else's flavor with someone else's method
so I have no idea what they're going to
do right it sounds very difficult that's
definitely a problem again this is
nothing specific here's very specific as
soon as you have a long process and you
get this problem so yeah so this is what
I didn't each instance is just a process
it's a gen server nothing strange about
this we're using the there's an init and
terminate method so we're using the gen
servers in terminate callbacks to
implement those that straightforward
instance variables I just keep those in
a map and I'll put them in the process
dictionary this process is just doing
one in one instance there's no problems
there and what I decided here was well
to make it look like I'm doing something
locally if an error occurs in the in the
instance process the air is sent back to
the caller and he get an error that the
caller I don't know if that's good or
not but it was fun to do it so you get
functions look something like this so
I'm getting so I'm going it going in
doing a line get of instance variables
to get the date and I'm just doing a map
on that which also means I'll get an
error if it doesn't exist and here in
the set I do it I do get the update I
get the map and I'll do a map update
which means if the instance variable
doesn't exist I'll get an error which is
good now just set it and return the
value so that's why we're doing a second
way of course is to use data structures
I could use a data structure for it's
very straightforward it's just well map
or something like this it's very
lightweight it's automatically claimed
because the garbage clicked all clicked
when I get back it's the same ideas our
line records and Lexia structs it's at
like having a alexia it's like having
records and structs on super steroids
right so i'm not just giving you a
function to access the fields i can you
can do things with them but
unfortunately is not sharable i have
this thing right i can't give it to
someone else well I can but with they do
things with it I'll never see the
results for it's just data's just now on
data structure I have to manage
explicitly by the caller the call has to
pass it in to the method call that's no
problem but when it gets back from the
method call it's going to get both
return value of the method and the
update instance so I think I have to
carry these things around with me
there's not very classical instance like
right but it's easy to do it so you just
make a map again you make a map of these
things you put all the date instance
variables in there and some information
about the modules and stuff like this I
could do a transformation if I if I if I
have set and get if I leave the get and
set methods for accessing the instance
variables I could do a transformation of
the code which automatically paths
change the self through the code and
updates it and passes out their value at
the end it's not too difficult to make
that transformation so I do so but the
caller must explicitly handle this
they must do send send ref do it 42 and
they're gonna get back a value and the
new reference which they then have to
take care of and pass the new reference
down again this is just straight
Ellingham in your data structures the
set they get in the set well get is just
a maps get and the set is a topple will
return the value which is definition of
the return value and we've updated this
the map that's fine but none of them
seem really nice right so we would like
something shareable lightweight like oh
oh handled by reference we have one but
it's not automatically reclaimed but you
have to be very I think here we're
getting overly cunning but you can do it
you can do it and how do we do it
it's tables we have a shared X table
which is perfectly feasible to do this
over share that table and each do this
for now how do I handle a share its
table so that it's table doesn't go away
when something crashes well you just
make you just make the any process
process you're the unroll it inherits it
that process if that process dies whole
system dies that doesn't make any
difference
I've done this it works so so how do you
implement it well you store instance
variables in a global it's table flavors
instances and eat the table is a bag
where the key is there is a reference to
the instance and each element has a form
the instance the reference the instance
the variable name and the value for that
and then gift is just goes doesn't match
on this and doesn't match on that with
the self the var and the dollar 0 it
gets back that value and it returns that
value if the value is not there this is
going to fail so you're getting in there
you're not going to get back at the nth
one element list and the set just puts
that it puts that thing back in and it's
a bag so it's good if it's already there
it's gonna overwrite it right so this
works
it doesn't delete herself she left
delete it but it's quite flat I don't
know this might be too cunning I have no
idea
it was perfectly doable you do the
exactly the same transformations for the
code for example do things so yeah that
was basically it so yet I just want to
say yes you can't you can do these
things if you want object-orientation
that's a complete different question but
there are a number of ways of doing it
reasonably well and getting the desired
reasonably nice handling of it as well
too and I think the handling of the
classes or the flavors in this case is
very nice way of doing things for no no
ok I know that if you're going to start
doing things like that it's going to
affect everything else right okay that
okay no the litter ating the Lisp code
is very straightforward and generating
them as an hour Lang structure is
basically building the lists so what I
mean is in the compiler it's very easy
to build this code the list the list
syntax is much simpler you can do it
with Alexi you could do with using
quotes and on quotes but it suddenly
becomes much more complex you could do
it with the Allen ast as well too if you
wanted to I just thought this was easier
which is I'll show I can show you the
code afterwards if you want to and by
the way it works which is even nicer
watching
okay yeah you can get on guitar by the
way as usual</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>