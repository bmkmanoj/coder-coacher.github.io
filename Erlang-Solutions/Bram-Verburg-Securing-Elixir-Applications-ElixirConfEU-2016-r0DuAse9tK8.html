<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bram Verburg - Securing Elixir Applications (ElixirConfEU 2016) | Coder Coacher - Coaching Coders</title><meta content="Bram Verburg - Securing Elixir Applications (ElixirConfEU 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bram Verburg - Securing Elixir Applications (ElixirConfEU 2016)</b></h2><h5 class="post__date">2016-05-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/r0DuAse9tK8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so I'm going to try and do a
45-minute a lightning talk because I've
got way too much material and so I'll
see what I can do and now this is
basically already the radio edit anyone
interested later on in the extended
disco version so talk to me I'll see
what I can do so the the title maybe I
hope I'm not setting the wrong
expectations here I'm not going to give
you a checklist that you can take home
apply to your application and then your
application will be vulnerability free
hacker proof guaranteed by Cisco because
that's not how it works obviously the
one of the things I'm not going to talk
about is all the common attack patterns
like cross-site scripting cross-site
request forgery injection attacks I
assume you're familiar with those from
whichever platform you came from you
know how to apply the mitigations you
know how to find them in the Phoenix
flag documentation all those things are
covered there instead I'm going to be
talking mostly about things that might
surprise you coming from another
platform because the airline virtual
machine is a bit different from I know
what you might be used to so maybe the
talk title should have had airline in
the title rather than elixir but again
I'm I imagine a lot of people in this
room will have come to elixir from other
languages so one other word of warning
i'm being paid to be paranoid so you'll
find out through this throughout this
presentation that i'm considering all
the possible angles and you know that's
a good thing usually in security there's
no harm in spending a little bit of time
looking at the possible weakness in your
application or in your stack and then
later to decide that you can probably
live with the residual risk because
there might be other protections in
front like a firewall or other
protections that the attacker would have
to get through first before being able
to attack this particular part of your
application but you know my
recommendation is in any case track it
if you if you come across something over
if I mentioned something here that you
might say is a bit
you know out there still added to your
backlog because you know requirements
change things change if you move your
application to another deployment
environment where suddenly your
application is behind the same firewall
as somebody else's application you build
that application is it secure we don't
know so or another example your smart
home application moves beyond just
controlling light bulbs and now it's
going to control also the alarm system
or the looks in a house so obviously
you're raising the stakes you want to
revisit your threat model and see if
maybe you need to implement some
additional protections so with that out
of the way let's get started I want to
start with the front door of airline and
I had some slides about backdoors buffer
overflows and maybe even Trojans in your
dependencies that somehow sneak into a
github repository and you know those are
all valid concerns but airline has this
massive front door which is in a really
cool you have we've seen a Sandra talk
about that the other day it's gives you
basically remote access to all the power
of the airline virtual machine and we
know it's very powerful we have a great
standard library but also very powerful
introspection features tracing debugging
tools and that's all very cool but you
probably don't want that to fall in the
wrong hands on that power now of course
it's intended for clustering but I am in
a minute I'll talk also about another
use case first a little recap just to so
we're on the same page so when an
airline know they started in distributed
mode so the virtual machine ok it's an
ephemeral port for that particular node
it registers that port with EPMD the
port Knepper demon which if it's not
already running will be launched as a
separate process by the virtual machine
so that's port napper demon runs on a
run on
board and that's how other nodes can
discover the note that you just register
and node registration support both short
names and long names so a name is an
application name at the hostname or the
fully-qualified domain or IP address of
your of your server but it's worth
pointing out that EP MD is not aware of
short names or long names it just cares
about the parts before the SI so you
can't you know don't consider short
names the security feature just because
the name might not resolve remotely
doesn't mean an attacker can still get
into that that virtual machine the
shortname longname separation is
artificial separation in the transport
protocol between the virtual machines or
and and an attacker could bypass those
if they if they wanted to just little
side note but anyway like I said I want
to talk not first of all before i talk
about clusters i want to talk about a
common use case for distributed airline
and that's the remote access to a
running node and it's already been
mentioned a few times today the ability
to to basically ssh into a server where
you have a node running and and seeing
your server there in this case this
server has a phoenix application running
an application and node called phoenix
and using an SSH tunnel I can actually
connect to that node from my local
machine for for troubleshooting purposes
so if you're not familiar with this
technique the plataforma tech blog just
posted a nice explanation of this of
this ssh tunneling and i think just the
other day so you can sure I'm sure you
can find it there some more information
about how this works but once it's in
place you can let me create a remote
shell IEX session on your running server
or you can start observer locally on
your machine as Gary just said and
and then once you open observer the
river will have these nodes menu where
you see the remote node you can connect
wait see all the graphs seal the
supervision hierarchy and everything so
that's that's all very cool and very
convenient very powerful but again you
have to be careful with powerful feature
so let's look under the hood to make
sure we understand what is what's going
on here so forget the Phoenix we're on
our on our server here I'm just starting
an IX session with a short name and EPMD
CLI shows me that the the server is
actually the note exactly registered and
now let's look what what netstat tells
me about the ports that the virtual
machine and EPMD are running on the
first couple of lines show EPMD and you
can see the listening port 443 69
they're bound to the wild card interface
they're not bound to any particular IP
address so even though I specified
localhost as the host name it can be
actually reachable from any network
interface the same thing with the
virtual machine so that's you know maybe
depending on your environment it may be
acceptable but you know from where I'm
coming from i would say i'm only
intending to use this distributed
airline functionality over the loopback
interface when I'm SSH into this into
the server I don't want to expose these
servers outside my server because it's
such a powerful interface I mean that's
the one of the first rules of linux
server hardening if you don't expose
services that you don't need so let's
see if we can tighten this up a bit it
turns out that if you look at the EPMD
documentation and the kernel module
documentation of airline there are ways
to tighten that up just a public service
announcement if you're looking for this
kind of information just check out our
aryl dash man and then the name of your
that the binary or the module that
you're interested in it gives you like
quick access to that kind of
documentation so with that information I
actually pass in some parameters an
environment variable that specifies the
address that the EPMD demon should bind
to and the reason I'm passing it as an
environment variable is because I'm not
starting EPMD explicitly in this case
I'm relying on the air long beam to
start the EPMD process for me so that
environment variable needs to be set so
that that process can pick it up if I
start EPMD explicitly myself then
there's a dish address parameter that I
can pass and the other parameter
therefore the kernel module specifies
the interface that the virtual machine
itself should place in on so with that
in place my EPMD output is pretty much
the same but next up now tells me that
both EPMD and the virtual machine are
bound to the log to the loopback
interface so anyone who maybe has access
to the local network where my server is
running will not be able to access these
interfaces so that's one hardening
option that you have using a distributed
airline if you're not actually building
a cluster now what if you are building a
cluster and you want to actually expose
your disability airline on the local
network so one thing you could do is if
you're if you control the servers or if
you're on a virtual private cloud where
you can define virtual network
interfaces you can allocate a subnet
specifically for communication between
the between the nodes so you have a the
front-end network which is facing the
internet and your load balancers but
another network interface with another
subnet where you connect only the nodes
of your airline cluster and then you can
use this same technique to make sure
that the disputed airlock is only
available over that interface and not
over the Internet facing interface if
that's not an option and if you're
running distributed airline in an
environment that you can't fully trust
for example if you're running
elixir on and raspberry pi using a nerve
project so who knows which network you
are going to connect to you might want
to secure your distributed airline
properly so cookies are not really a
security feature I mean yes they will
stop a casual passerby and let's say
from from connecting to your node or two
nodes that shouldn't really be talking
to each other and accidentally ending up
talking to each other but the one of the
issues is that the authentication
mechanism does have doesn't have any
kind of rate limiting so you can
basically brute force your way into a
server it will take some time but is so
if you really want to harden your
distributed airline installation there's
a TLS distribution module which you can
swap out swap in instead of the standard
tcp distribution model and not only does
that give you the option to have
increased security by using for example
client certificates or psk based
authentication mutual authentication
between the client and the server you
also get very important confidentiality
of the data because the standard tcp
module all the data that's being
exchanged between the nodes just it's
just this Alan terms serialized into a
binary stream it's any sensitive data is
right there unless you take care of that
somewhere in your application layer now
maybe even more important than all this
is to know when not to use our gang
distribution it is very powerful and
it's very attractive sometimes you just
say okay I can do anything within the
airline virtual machine I don't need to
bring in an external database an
external caching server external web
server I'm just going to run off just
virtual machines everywhere the beams
everywhere I am going to have a front
empty on the back end here but they will
all be talking over the airline protocol
that you're no longer building an
application with multiple tiers because
you know if we are front and tier which
is exposed to the Internet once an
attacker gets in they will have
unlimited access across all your cluster
include
the backend servers where your database
resize so if you want if you're building
a multi-tiered application for security
reasons to not store sensitive data on
the servers that are exposed to the
Internet so don't use airline
distribution between the front end
servers and the backend servers stick to
the application specific protocol the
database protocol that is much more
restricted and that if your front end
server is compromised will still limit
the damage that an attacker can do on
the on the back end server and obviously
you shouldn't be using air long
distribution over one connections over
the Internet not just for security
reasons but simply because it wasn't
designed to support the kind of latency
and error rates if you will you'll get
instruction environment ok so I already
mentioned as a TLS so I want to talk a
little bit more about TLS and SSL and
some of this is generic it applies to
any kind of language that you're using
some of it is specific to to to airline
and I'll try to use TLS to refer to the
protocol and SSL to refer to the module
in the air long standard library but i
might get mixed up but it there one
thing to know is that the ssl module in
airline is a bit different from your
standard TLS implementation in other
languages because everyone uses openssl
but their long implementation uses
openssl only to do crip so it doesn't
use the TLS handshake the x.509
certificate processing the crl handling
all those things are implemented by the
SSL module rather than delegated down to
to openssl at this in recent versions of
airline and that could potentially have
some some implications we'll see in the
next slide so the question is should you
use airline SSL or should you use the
reverse proxy in front of your web
server for example and
let the server or the load balancer
terminate the TLS connection in front of
your application running into airline vm
and now some application may need the
reverse proxy but although that's less
likely for an airline application for a
Phoenix application than it is for a
ruby on rails application in ruby on
rails for example you would run multiple
copies of your application in order to
leverage the whatever number of cores
and cpus you have on your server and
then engine X for example would reverse
proxy in front of those application
instances and that's not needed in
Phoenix because Phoenix out of the box
takes uses all the available course
anyway so maybe you don't need a reverse
proxy maybe you need a load balancer if
you have multiple servers maybe you
don't need a lot better answer if you do
need a load balancer and probably the
load balancer will terminate TLS because
you'll want to load balancer to be
session aware for session stickiness if
you don't have a load balancer and the
TLS again can be terminated by their own
virtual machine and another
consideration is do you do you need to
offload to get less for performance
reasons and the airline see less
implementation is pretty good but you
can't beat dedicated hardware that
actually delegates much of the crypto
processing to two specialized chipsets
but the from a security perspective the
most interesting one is the last one is
do do I trust the TLS implementation of
the airline SSL module because now what
happens if the vulnerability is found in
openssl how do you know if air lung is
affected and is it susceptible to the
heartbleed attack to the beast attack
many of those attacks actually a target
the handshake or the packet processing
they don't target the crypto the
underlying crypto itself but that
doesn't mean that the SSL module is
immune to similar attacks now you're all
waiting to hear my recommendation I I
don't know i'm using the ssl
implementation I think you know it's
hell on SSL as it's not being used
nearly as much of course is open SSL
and therefore the it will attract fewer
attackers there will be less to be
gained by so for someone to find a
weakness in their long ssl module
compared to finding a weakness in
openssl but that's security through
obscurity and there's never really a
good idea so anyway for the purpose of
this talk let's say you are going to use
their long ssl module now and i'm going
to talk for a moment about web servers
but basically this applies to any server
because all the ssl configuration
parameters are exactly the same no
matter whether you're using phoenix or
plug or any other kind of TLS
application but for a web server in
particular there is a cool tool called
ssl labs com by Qualys that will test
your web server and what you want of
course is a A+ rating that's the best
and out of the box I think Phoenix
because of the way airline configures
the ssl module out of out of the box
gets I think a B or C mostly because it
includes the desk cipher which you
really don't need so you will want to
tune your SSL parameters a bit in order
to achieve this a plus rating and i'll
show you how to do that so this is the
config file of an of a phoenix
application apart from the standard
stuff that you need any way you want to
add custom diffie-hellman parameters and
diffie-hellman parameters are used to in
the key exchange at the start of the TLS
handshake and they make sure that you
get perfect forward secrecy which is a
good thing and I won't have time to talk
about it now but the thing is that out
of if you don't specify this parameter
ssl module will use standard
diffie-hellman parameters which are well
known everyone is using them and it
allows an attacker to do some pre
calculations that allows them to attack
your your handshake so with this this is
a file that you can generate with a
simple openssl CLI command and it will
provide increased protection against
it attacks against the diffie-hellman
exchange secure renegotiate should be
true these days it just falls by default
in SSL module but I don't see why you
would need I don't think any clients out
there really will break if you leave
this to false on our cipher order so
this gives us the control over which
cipher gets selected and that's the next
section it defines which divers were
willing to accept but it also defines
the order in which the server will pick
between what the client supports and
what we prefer so this next section this
these six cipher Suites should be enough
for to support basically all modern
browsers or other clients that you might
want to support and in the next slide
I'll show you a few backup options that
will give you a slightly more client
compatibility but for most intensive
purposes this should be in us now um
some things to look at this is you want
the elliptic curve diffie-hellman key
exchange at the top the below that i
will have the traditional diffie-hellman
exchange which is more expensive one
other thing is if you're watching this
from the future on youtube so that there
is a new cipher coming out all the
chacha 20 and it's already supported in
in airline version 18 and later but it's
it requires openssl one dot one which is
still in better but soon it will be out
and catch a 20 is a stream cipher which
provides pretty much the same security
as AES but at a lower computational cost
so it's just more efficient so if if and
when that comes out and you support it
on your server you'll want to top put
those at the top now like I said I there
couple of other options you might want
to add for backward compatibility so
open SSL 098 doesn't support elliptic
curve cryptography including the
elliptic curve DC Hellman so these six
are basically the copy of the ones we
saw on the first page and but
with traditional difficult for
compatibility with openssl 098 which
they are still quite a few applications
out there that are based on open SSL 098
unfortunately and and then Triple DES at
the bottom now Triple DES is secure
there's no security risk in doing Triple
DES but it's it's very slow so it's just
inefficient on your server to to end up
picking Triple DES when another option
is available so you need it for Android
before version for you need it for
windows XP and you need it for java 6 so
if those are important clients for you
to leave the Triple DES options there
there's one more thing we need to do to
get at A+ rating from ssl labs and that
is the plug dot ssl plug which you add
to your phoenix endpoint and that will
give you HTTP strict Transport Security
so it will tell browsers to never accept
a plane to HTTP connection to the server
once they've connected to this server
they will never fall back to plain HTTP
so that prevents downgraded text where
an attacker tries to trick you into
loading the page over HTTP and then they
will they will you know I'll take a
launch a mini middle attack and rely on
the faculty the user will not notice the
fact that this little padlock thing is
missing okay so that's with these
options i get an A+ from for ssl labs
which is cool now another thing with ssl
labs report i didn't show it in my
screenshot but it will also give you a
list of all the common clients like
browsers and mobile platforms and it
will tell you which if whether or not
they will succeed to negotiate an ssl
session with rtls session with your
server and which cipher they will choose
so if you just want to verify that you
can actually support an old browser
version it's all there in the report so
this is servers and again I will remind
you that all those settings apply to any
TLS server not just web servers let's
talk about clients and again i'm talking
about i'm going to talk
but HTTP clients because we're doing a
lot of HTTP of course but the same
applies to other TLS clients and as an
example think your think about an API
client you're talking to the Amazon API
or Facebook API and of course those you
access those API so via HTTPS because
you're sending a sort of API key in your
request and you wouldn't want someone
harvesting those API keys so how
difficult can it be to make HTTPS
request well let's try airline comes
with an HTTP client out of the box all I
have to do is start the inet s
application and ssl application and then
i can make an HTTP request to an HTTPS
URL and boom I get a 200 ok cool so that
wasn't so hard was it it wasn't and
that's a bit suspicious actually my
browser doesn't agree my browser will
not let me talk to the server and that's
because this server has a self-signed
certificate now you shouldn't trust
self-signed certificates unless you
yourself generated them so why did HTTP
see not warn me about this it's because
I didn't tell HTTP see whom to trust and
whom not to trust so it trusts everyone
and that's because the htpc just
implements the TLS specification but it
doesn't the telus specification doesn't
define who is trusted and who is not
trusted your browser knows with trusts
you're at your operating system knows
who entrust but ere long doesn't come
with the kind of trust store that these
applications and systems have you have
to bring your own so we can fix that we
can get the Mozilla trust store which
the curl project has conveniently
converted to pen format which is the
format that ssl module likes to get it
in so we download the trust trust store
we launch IEX again with the inet s and
application start that we make now we
call set options on HTTP see which
basically gives you some options that
will apply for any requests
made by the HTTP client and we specify
the socket options verify here and we
pass the name of the certificate trusts
or okay that's right again boom now we
get an error because fatal error bad
certificates that's what we wanted
unfortunately we are not there yet so
let's now talk to another URL which
doesn't have a valid certificate issued
by a valid trusted CA and it works 200
okay but my browser again boom why is it
complaining now because the identity in
the certificate doesn't match the URL
that I entered in the address bar of the
browser I connected to API that vault
on.net but the domain of the server
certificate was issued to vote on dope
net in this case it's the same top-level
domain but it could be any certificate
HTTP see will be happy with a
certificate issued to bed hacker adopt
org so obviously this could still be a
man in the middle trying to snoop my IP
API credentials now again this goes back
to the the TLS specification that
doesn't say it says how to do the TLS
handshake and how to verify that the
server actually has the private key
associated with a certificate that if
presented it knows about expiry of
certificate Sandra vocation of
certificates but it doesn't specify how
you should how you compare the
certificate that the server presented to
you against the identity that you were
expecting to see there is another RFC in
this case 6125 which describes for the
HTTP protocol how to do that but
unfortunately HTTP see doesn't come with
a hook to that implements is RFC now
this issue exists in many HTTP clients
so I'm showing it now with HTTP see I'm
the same happens with eyebrows which is
also an airline library and with HTTP
ocean which is an elixir wrapper around
eyebrows and it happens on lots of other
platforms too and this is
one of the most common implementation
mistakes when using SSL or TLS now
luckily the most popular HTTP client on
next OPM is technique and also the
wrapper that around a hackney which is
HTTP HTTP awesome I don't know if that
means it's the most often used because I
can't see how many people use HTTP see
but luckily techne takes care of this
out of the box so that's because it has
the dependencies certify which is
basically the trust store and the ssl
verified fun which implements that RFC i
mentioned and and checks that the server
certificate actually is the the server
you intended to talk to and you can you
can use those dependencies directly and
pass the right parameters into and to
http see so if you don't wanna use acne
if you want to use a CD pouch HTTP ocean
just make sure you pull in those
dependencies and apply it pass those
parameters also the hex and the hex
client includes an only its own
implementation I think of the ssl verify
fan you need to remember though that
this list might change these
certificates and just like your browser
might sometimes drop on za because it
was compromised or introduce a new one
like let's encrypt if you if you want to
make sure that your certificate trust
story is up to date you will have to
update that dependency periodically now
the most all of these are basically just
examples the most common important
examples but the bottom line if there is
one thing to take away from from my talk
now is no don't treat these things as
magic boxes that will just work
distributed airline and the TLS protocol
and SSL module that implements it up
there do are doing amazing job but you
know you need to understand how these
things work and what happens under the
hood because you know like we said it's
easy to make a mistake and is if ideally
you have this included in your test
coverage you
have a test case it checks that your
client fails on a expired certificate or
you know see what happens when the
certificate has been revoked and also
for operational reasons if you're you
know do you know how your application
responds when I certificate expires do
you that your whoever's responsible for
maintaining your server or your client
do they know how to respond quickly when
when when that happens and so if you if
you play with this a bit you test it and
you'll be much more confident confident
when those things happen okay so i can
recommend two books this one is actually
by the guy behind that ssl labs website
and it's excellent it explains for
example how to use the openssl command
line for for testing servers and if you
want to dig deeper implementing SSL and
TLS it would be great exercise if you
really want to understand how TLS works
and and why it works the way it works
it's it's this book describes an
implementation in C but if you apply it
to elixir for example you'll learn a lot
about how to do TLS handshake and so on
so that those are really recommend it um
I am NOT going to be able to finish this
am I ok denial of service is basically
in denial service i'm going to talk
about like ways to affect your server in
a way that's fairly cheap for the client
but expensive for the server so it's
about robustness so if an attacker can
craft some specially designed packets
that will bring your server down that
obviously that's a bad thing the one of
them is adam table it's already been
mentioned but the FM table is limited in
size and not garbage collected and that
means that if if it overflows it will
crash the beam and this is not what's
meant by let it crash in airline let it
crash
is about processes not about the virtual
machine so you need to be very careful
about converting strings to atoms and
you should definitely not convert
strings that are coming from the outside
of your application from HTTP requests
for example into atoms that's just
eventually you'll run out of Adam table
entries processes and ports also have
limits so you need to tune those those
parameters when you start your virtual
machine in this case you will not crash
this VM if you run out of ports but it
may be you know some of your internal
processing might require a process and
then because there are too many clients
that are taking up all the ports you
can't start that process and then your
application starts to degrade because it
can start the internal processes that it
needs so what you want to do is limit
the number at the edge for example range
which lives under cowboy which lives
under Phoenix has an option to limit the
maximum number of connections that it
will establish so if you kept it
somewhere well below the port limit that
you configure that your vm level then
you will have some spare and for your
internal processing and error handling
and also monitor it there are
introspection functions that the vm
provides to see what is the current
number and what is the maximum number
and then you can see if you're getting
close to the limit another topic is
timeouts and this is this mostly related
to to handling load so here is an
example maybe a contrived example but
and client making a request to phoenix
phoenix calling some sort of jen server
aggregator that talks to some other gem
servers it makes three requests and then
when all the data is in it issues of
response to your client now the system
is under load response times are
increasing and at some point something
will time out what's going to timeout
obviously this one because you know this
one has to wait for all those other
three to complete and if those are
starting to take to one or two seconds
the standard five second gen server
timeout is not going to be enough for
Phoenix to get a response boom error
response to the client but the
aggregator continues working the data
store contain is working so all the work
is still being done but the clients are
getting error responses they're probably
going to hit reload which is going to
increase the load and then the whole
thing is starting again and again
they're going to get an error so this
just amplifies so the one way to handle
this is to make sure that you set
different timeouts you can set for
example a very short time out for the
first fetch maybe slightly longer one
for fetch two because you are already a
bit more invested into this particular
request but in any case fetch one two
and three the timeouts need to add up to
something less than the time out of
Phoenix towards the aggregator so
basically that's the fill fast paradigm
right the fail fast back pressure which
yours I mentioned that this keynote
already the dynamic supervisor will
provide some back pressure for spawning
children so back pressure is an
important technique and these are
techniques from from microservices
basically so what I would recommend is
look at the literature for back for
micro services and see how you apply
that within your vm within the extra
model add things like circuit breakers
and bulkheads which are documented in
books like these and and see if you can
apply that within the virtual machine
and not just between applications just a
few more small things if I can squeeze
it in one of them is Phoenix is famously
low latency and low jitter response
times right will love to get a response
within a few microseconds rather than
milliseconds but this makes the
application more susceptible to timing
attacks you know when you sign into a
website you type the wrong credentials
you get a message that says invalid
username or password the website doesn't
want to tell you whether the user name
was correct or not it just leaves that
ambiguous because otherwise an attacker
could do use an enumeration or
even worse if you're using email
addresses to sign in you could actually
capture email addresses for phishing
attacks and so on so but if if you're in
a Phoenix application you know password
hashing takes time so if your
application does find the user record
for the username that was provided and
then that's the password calculation and
finds out that the password was wrong
the response time we're going to be much
higher than a request that came in with
the wrong username so that's a timing
attack and a timing attack that leads to
an enumeration attack and you can
mitigate that by let's be doing the
password calculation anyway even if the
user types the wrong username and common
in which is basically the de facto
library for password hashing i think in
Alexia has a dummy cheque password
function but now you're susceptible to
denial service attacks because this is
quite an expensive calculation and an
attacker can send pretty fairly cheap
request to the server we just dumped me
usernames and passwords and the server
will do all the hard work of cash
calculation and obviously that's another
thing to mitigate so you can do
something with timers I don't have time
now to talk about it but these are kind
of things to think about and one last
thing and that's really the last thing
if you think that shipping beam files to
your customer servers if you're if
you're shipping applications to a
customer machine rather than hosting
them yourself and will protect your
source code so be careful because
airline comes with the option to include
debug information inside the beam file
and if the debug information is there
it's pretty trivial to basically
decompile that back to airline it's also
an interesting way by the way if you if
you ever wondered what your elixir
application looks like if it were
written in airline so you compile it to
a beam file and then decompile it back
to airline and then use then you can
learn some airline anyway you can you
can mitigate this because mix has an
option no debug info but again by
default elixir includes debug
information and so you can not include
it or you can strip it for example or
you can if you do want to keep the deep
information because you might want to
actually debug your application and
there's an option to encrypt it which
means that you can only really use the
debug functions if you set the right
password which is kind of cool and it's
all documented in the I think in the
beam lib library and anyway so there has
never been a better time to get serious
about Alexia and Phoenix just remember
to stay safe you if you can find me on
the IRC and Twitter sometimes and i
think if that's it thank
well if there are no questions I have a
bonus section but only if there are no
questions maybe I'll give you a teaser
what does the bonus section you want to
hear about using Phoenix as a TLS test
server okay okay i told you about how
important it is to to test your HTTP
client when you're using HTTPS and no
you want to use a server to test against
and where can we get an HTTP server
right phoenix now it turns out that the
ssl library of airline has a nice
feature in 80 version 18 that helps us
build a test server so you need to
specifically in the in your create a new
Phoenix application set the default
certificate and trust storage you'll be
using and then pass in this parameters
SNI fund that is for server name
indication it's a hook that the cert
that ssl library will call on your
application to modify the SSL options on
the fly so as a request comes in and
what that allows you to do is implement
a couple of versions of this of this
function one is the default one that
basically uses whatever SSL options you
put in your config file but one that
overrides this certificate file to point
to an expired certificate for example so
if I load expire to the local test of me
which resolves to local host IP address
it will actually present the expired
certificate but it gets better because
this you can tune any SSL perimeter
before the SSL module sends a reply to
the client so you can even change the
SSL version that you're going to be
negotiating with the client or the
ciphers that the client is going to
order the server is willing to accept so
this is really cool way I found this out
and it actually allows me to build in
like a minute just a test case for
something otherwise I would have to
figure out how to set up openssl command
line two
support this particular test case the
only thing you need to remember is if
your wanna try this would open SSL
command line the openssl client
simulator doesn't take the server name
indication from from the host name it
you specified you have to actually
specify it using the server name
parameter that's all thank you let's
have a break</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>