<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang End-To-End - Building and Managing Connected Devices: Ulf Wiger | Coder Coacher - Coaching Coders</title><meta content="Erlang End-To-End - Building and Managing Connected Devices: Ulf Wiger - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang End-To-End - Building and Managing Connected Devices: Ulf Wiger</b></h2><h5 class="post__date">2012-06-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/KPTtHbHOAOM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay and at the end of the presentation
I'm going to bring up our CTO magnus
foyer and so you'll get to meet him he's
a noob as an erlang programmer although
an extremely experienced C++ programmer
I'm going to talk a little bit about
connected devices but not so terribly
much since at least for those of you who
attended the keynote this morning that
was like an excellent warm-up to what I
was going to talk about and after that
I'm going to talk about what we're
building in our company a service called
XO sense and since this is a programmer
conference in an open source conference
I'm going to talk specifically about how
we want to relate to the community and
after that Magnus is going to tell you a
few things about our first customer
project now to set things off the CEO at
ericsson told their shareholders that by
2020 they expect to have 50 billion
connected devices basically saying
anything that will benefit for could
benefit from being connected will be
connected like nowadays we mostly have
the iphones laptops now that sounds like
a lot of course IBM came out with a
projection of a 300 billion and this
morning we heard Jim's Emlyn say one
trillion in any case there seems to be
some agreement that there will be many
now the question is what will these do
most likely we have no idea we can
imagine some uses but this is simply a
market that's set to explode because now
the conditions are right for doing this
finally
now obviously for hackers and
entrepreneurs this is good times so we
can just jump in we can pick our
favorite little commodity linux box
that's a cue box right there a media
server 3 watts fits in your hand
installer lang on them takes a minute or
two and then just start hacking some
applications now it's a little bit more
complicated than that obviously because
device programming has always been a
little bit complicated it's a lot of
tinkering but that's fun but when we
talk about connected devices we get a
lot of connectivity issues that create
complexity now for this room this is not
so hard because this is what we love to
do right Erlang is a coordination
language so dealing with data flows from
sensors and talking to the cloud that's
that's the fun stuff now for most other
people this will be scary and they
probably don't have any idea unless
they've tried how badly this is going to
wreck their architecture but they
usually find out gradually as the pain
increases now you will have failure
modes like having to switch between
different modes of connectivity
connectivity dropping out as you move
out a coverage and then if you're lucky
and you get lots of devices out in the
field you have the problem of remote
updates remote debugging all kinds of
stuff now all of this creates what is in
practice a very high barrier of entry if
you want to try to do this for real
there are also challenges in the back
end
now if you're going to have a good
service and lifecycle support you have
to factor in that you will have
different versions of your devices out
in the field you will have to be able to
support different versions of protocols
board types software versions
capabilities and you will probably also
need to in telecoms we used to talk
about northbound interfaces I think that
was because they were always at the top
of the sort of network map and that was
for interfaces to network management
network operation control centers
profiling services perhaps like like
boundaries service but also interfaces
to business logic and of course you're
going to have to have versioning you're
going to have to have some kind of
modularity and an approach for that
upgrade schedules if you have hundred
thousands of devices out there you're
not going to be able to just push a
firmware upgrade to all of them at the
same time so you're going to have to
stagger upgrades you're going to have to
worry about well in telecoms we call
that knockout units if you push a bad
upgrade out there how many devices do
you want to kill in one fell swoop
before you realize that you've done
something wrong bandwidth metering if
you're connecting over a mobile internet
for example you may actually have
different data rate plans there may be
times in the day where you don't want to
push large amounts of data these are
things you have to worry about and on
all the other things in a back-end
service like persistent scalability
redundancy now these are issues that we
plan to address with what we call XO
sense and
the idea is to provide an end-to-end
solution basically from the sensor out
into the cloud and the customers or your
business logic now this is the community
pitch so I'm going to talk to you as
potential developers in this foreign
labs is a small enough company company
that we can all fit on one slide we
formed the company in November last year
so this is pretty early day still some
of you may know at least some of the
faces that's me up there mark is
tailored is our CEO he used to be the
CEO of Erlang solutions before that he
was at logica he's done he started has
done startups on mobile communications
before Magnus foyer has been working
with telematics for a long time volvo
wireless card and he can tell you
everything about the horrors of doing
this kind of thing in c++ because he's
done it several times Tony dog well I
don't know how many of you who know him
he joined the computer science lab in 93
I worked there for a number of years
then he was one of the people who
founded blue tail which was then bought
by Alton which was bought by nortel and
then he went from there and founded
synapse which pioneered over-the-air
configuration of mobile phones I think
by now they've configured about a
billion mobile phones and a number of
other ventures as well so I think
together we have quite a few decades
worth of experience doing this sort of
thing and
that pretty much means that we know what
challenges are ahead of us which is a
good thing it also means that we know
what challenges are ahead of us and that
we're in full for quite a lot of work
but that's the fun stuff right partners
are motivo which is an expert company
working with they build concept cars
help automobile manufacturers designing
drivetrains battery systems Erlang
solutions an investing partner the
backdrop there is actually a performance
display that Magnus and Tony did in a
few in a past venture called magnin and
we're actually porting that graphics
package to Erlang so that part of this
solution will be a touchscreen display
for high-performance graphics and
embedded environment we're not quite
ready to release that yet but it's going
to be part of the open-source release so
a schematic for how what this looks like
you have the device application which is
essentially well some components for
data acquisition drivers for various
types of interfaces a link to the
backend system and logic for handling
configurations and upgrades and things
like that so the idea is you put your
application on top there and you build
on all this to get going really quickly
and on the back end we have links to the
business logic and also monitoring
operation and maintenance typical stuff
so the value proposition is that we're
pretty sure that we're going to offer
quite a lowered entry threshold for
people who want to get into this
business and do exciting things with
connected devices and much shorter time
to market depending on how complex your
application is you get some reference
hardware 100 bucks or so but might get
you started get it up and going you
should be connected to the backend first
day and then start testing and
prototyping your your application from
there now given that you are you're
getting so much for free and and stable
logic and you don't have to reinvent all
this think these things and also using
if you're using Erlang on the device and
you get a lot of the inherent quality of
overlaying an OTP pretty much for free
so and also the we're building the
backend to be highly scalable so the
plan is to be able to cope with millions
of devices up to perhaps hundreds of
millions of devices obviously not from
day one but that's a lot of what we're
putting together now are you know taking
the experiences from what we've done
before and and trying to really have the
scalable solutions for that kind of
volume now
the Erlang benefits I mean for people
who are not used to Erlang this is kind
of a hard sell because a lot of people
are used to thinking that it doesn't
really matter what language you use you
can program anything in Fortran and so
on but to us erling is the perfect fit
for device application development
nowadays it as devices are going
multi-core Erling is a perfect fit for
that just naturally expands to
multi-core and and you know multi-core
system on a chip designs that you have
today with integrated GPUs DSPs actually
pose a lot of challenges for programmer
if you want to really make use of those
and we believe that we can provide a lot
of very good abstractions for
automatically making use of this now
what this translates to in the embedded
world it's not so much performance its
battery life it's low power the best way
to keep the power down by and still get
good performance is to go multi-core now
debugging anyone who's tried to debug a
multi-threaded C++ application in a
tight embedded device that doesn't have
a TTY doesn't have a disk you can't dump
core will probably agree that debugging
an erlang application is slightly easier
we will also make use of the facilities
in our line for breaking up the upgrade
path I essentially just by going into a
functional language or a language like
Erlang you kind of shift the balance
between code and data so a lot of what
would normally be code updates will
rather be data changes
we can obviously do hot code loading or
modules and things like that and the
abstractions for connectivity I've
talked about that in other presentations
at other conferences how this really
with Erlang the abstractions you have
there you actually can contain the
complexity so that adding a new
interface adding a new protocol really
doesn't mess up your other code so you
really get true modularity in the
communication aspects which is extremely
good and also allows you to maintain
your quality over time even as you add
features now this is very often not the
case when you start adding new features
you get interaction with old features
and things that actually work before
suddenly don't work anymore and that's
something that we usually do not see in
Erlang so the open source idea here is
that well on the service side as usual
we will consider that closed source now
that obviously doesn't mean that we're
going to write everything from scratch
and we're not going to show any of it to
the world we're going to make extensive
use of the best open source components
and we're also going to release open
source components that we build
ourselves the sauce will be secret
essentially and now this is also for
practical reasons you don't really gain
much from releasing everything as open
source because really if you want to
release something for other two others
to use you need to document it in a
different way and so by by doing so not
only do you open up for competitors in a
way that you may not want but it also
takes a lot of extra time that doesn't
really buy you that much on the device
side on the other hand we plan to make
just about everything open source the
connectivity module there we'll see what
we do that but essentially there is no
point in making it anything proprietary
but obviously it has to be possible to
put proprietary code on there because
you want to make money on the products
you build on this right so you want to
be able to to have proprietary code
mixed into this so that of course will
affect the licenses we pick same thing
with the back end side the business
logic obviously that is the customers IP
and not something we worry about so the
idea is you get a free download it's all
ready to use we will pre test it with
some reference hardware you should get
maybe up to 10 devices managed for free
so you can register and at no cost get
up and running so again the idea here is
to really stimulate your innovation and
make it as easy as possible for you to
connect if you get successful if you
actually start having customers and you
start selling these things then there
will be a progressive licensing keeton
scheme that also gets gives volume
discounts as you start entering the
millions of devices which of course you
will now the back end you can either
license it for self hosting or you can
connect to it as a service so the device
platform is not just us it's actually
several companies within the Erlang
community that are already working in
this domain so travel pin for example
has packaged done embedded packaging of
Linux quite a while we're going to be
and we have found that we have a lot of
things in common in terms
of the technology choices that we've
made so essentially we pretty much
agreed from the start even as we started
talking to each other about how these
things should be built we're also
cooperating with tail f who are active
in the standardization of net com and so
we're I'm going to get back to that and
also ESL we're using ESL's embedded
Erlang distro just copy it down onto the
arm device and you unpack it and you're
up and running it's very very nice and
also we have with ESL the knowledge
partner transfer ship in in the UK which
you're going to hear more about at the
EU see if you go there in May where the
idea is to work with embedded device
manufacturers and also the community to
further strengthen Erlang's position in
the embedded in the embedded world now
as I said we incorporated in November so
we haven't really been at this for so
long but i thought i'd show you some of
the things design choices that we made
and some of the things that we published
so far we've chosen to for the data
modeling and this is actually a key
thing for in order to have some
discipline in the configuration
management we've chosen something called
yang it's it's a standard that it comes
out of the net conf if you don't know
netconf it's actually a quite a nice
configuration management protocol so
this is an extract of what yang looks
like we are have published a yang parser
I think you you have the link down there
together with tail F and using that we
also generate JSON api's for the RPCs
from the the business logic side
and we also so we generate markdown
documents specifying illustrating the
API we also generate code to
automatically verify incoming JSON
requests and do type type checking and
type conversion both on the incoming and
outgoing side and I think this is
actually something that you could look
at even for web applications I mean
there are a few ways to try to validate
your JSON and this works really well
actually so another tricky problem is
you have to have persistent store and
forward because when requests come in
you don't really know if the devices
that are going to be online and and you
can't just drop requests and you have to
make sure that you actually do things in
order so we've developed a little key
value database that we call kbd be as if
y'all thought that you needed another
key value database right it's actually
leveldb or it's a small it's a thin
layer on top of leveldb for the backend
and sqlite on the device side leveldb is
great but it uses tons of open files
which is not necessarily a great thing
on an entire embedded device whereas
SQLite uses one single file for the
entire database it's not that fast which
is a bad thing on the back end but we
have the same API the same semantics so
one of the things that we do is
persistent queuing and we feel that
we've engineered those cues so that we
can actually have millions of cues we
can have we imagine or we will have at
least 2 q's per device one for incoming
requests and one for outgoing so
basically we do the automatic validation
and conversion and it gets put in the
queue using G proc pub/sub actually and
update triggers in the database we will
trigger a dispatcher when the queue goes
from empty to non empty which will spawn
a process that deals with the queue it
also obviously has to check if the
device is online so you can talk to it
of course when the device comes online
you will trigger the same process and it
gets to check if there is something in
the queue and so on this is working
really well now a little tweak is that
you don't really extract the data or
delete the request from the queue until
you actually know that it succeeds and
then of course so then you can retry if
there are bugs or whatever and you need
to have a limited retry so that you
don't just halt all progress to the
device so that eventually you will have
to act on the fact that maybe a request
cannot be served and you have requests
backing up we also have some tweaks for
the configuration data management now
this is a fairly busy slide you don't
have to parse it all what we've done is
we feel that we've come up with a pretty
good representation to be able to store
configuration data trees and efficiently
iterate over trees or iterate over sub
trees now we also have a diff function
this is actually a little test function
that performs a diff on the data tree so
that you can see exactly what's changed
and of course the idea of that is that
to save bandwidth in the communications
with the devices now
we also have made a serial line driver
there is a there are a few serial line
drivers before this is actually going to
work on Windows it doesn't quite work on
Windows yet but almost there windows is
pretty nasty with overlapped I oh and
everything but it's almost there it's
very similar to jen tcp so you open it
with a similar to jen tcp options like
you can put it in packet mode so you get
one line at a time you have active one
semantics so you get out the automatic
flow control you can set the baud rate
and buffers and things like that and so
just like with jen tcp you get the
incoming data as a message you can set
options just like with jen tcp and then
you can just use normal pattern matching
and everything just like you're used to
doing and of course you have a separate
process for doing this it doesn't have
to worry about interleaving with other
things plain Erlang stuff and it of
course works beautifully for this this
particular thing is collecting waypoints
from a GPS feed
now we're using rebar and it's great but
of course you have to hack it a little
bit and we offer some contribute and
contributions back one of the things we
wanted to do was because we got tired of
having rebar check the depths and
pulling down from github all the time so
we wanted a way to at least in
development mode tell a rebar that we
were just wanted to use the ER libs path
and so then we came up with a way to to
patch the rebar config so you just put a
rebar config dot script and then at
least our version of rebar will pick
that up and use the file colon script
command if you're if you don't know what
it does does pretty much the same thing
as file eval but it returns the last
value evaluated so what this does is
reads the rebar config checks if I've
set the environment variable rebar
depths and then patches the
configuration to that dependency
directory so then we just have our code
and it goes directly to that instead of
going to github now obviously have to
remember to turn this off when you're
building the actual target system now
also we were too impatient to wait for
rebar generate and also annoyed with the
fact that it copies all the modules to a
separate directory which makes it
difficult to patch the code so i had a
little application from before called
setup I tweaked it a little bit so that
it can now read a rail to config file
but then pretty much from there just
builds goes to systools and builds boot
scripts and this takes about a second
and then you're up and running against
your development sources but everything
else is just same rebar configuration we
think this works really well you know
like Mike was talking about yesterday
you know all the seconds you can shave
off this
turn around in in your development is is
good stuff so this is pretty much what
we've had time for so far we actually
have a system up and running and we're
going to be documenting and publishing
some of these components and we're
trying to send pull requests to other
projects obviously and make use of your
stuff as much as we can so that's kind
of the story and we're hoping that you
will come up with great ideas for how to
do this how to build applications on top
of this and and then make use of this
service so you don't have to reinvent
the wheel with device management I would
be like ninety percent of the work you
will have to do otherwise so that this
will let you focus on your core
application and have everything just
work now I'm going to turn over to
Magnus Magnus foyer who gets to go up
and actually take my mic this one
because otherwise it doesn't really
should
one second kefalonia no subject hello
I'm Magnus foyer I was CEO of the four
laps up until Tuesday when I happily got
demoted to CTO and Marcus Taylor took
over so basically my role in the
company's two-inch I'm start to get
hacking after an airline as well I've
been far too busy with company
information and chasing clients etc up
until now but hopefully I'll can switch
back the technology which is really
where I thrive and happy guy and so I'm
here to introduce our launch client
which we actually signed off for a while
back we it's called get around a local
company here in San Francisco they do
peer-to-peer carsharing or car rental
and basically a very short story is that
if you have a car and it's parked
outside your office you can rent it out
to somebody else in the same a
peer-to-peer carsharing network for on
an hourly basis they can come up to the
car use your smartphone to unlock it
firstly reserve it unlock it to drive
around run a few errands while you're
still at your office come back to the
office drop off the car lock it and when
you're when it's time for you to go home
your cars there and you're now fifty
dollars richer for example so get around
and we started working a couple of
months ago and there are large clients
it's a full production contract so it's
not a prototype or demo or something
like that it's basically full arm we are
currently we deployed a prototype server
for internal testing with get around and
it's moving forward very nicely so I'm
here to kind of describe a bit of the
use case of get around and what we're
doing for them and also what we're not
doing so I didn't have time to modify
this for get around ok so basically what
we provide is only the server side in
this case so the license to server
there's a bit of money and what we do is
that we manage
all traffic through their devices which
is called a car kit and this so they're
not running an exercise in their end
it's an in-house developed hardware
software solution that we are
interfacing by implementing their
proprietary protocol which is pretty
cool we started talking actually this
week about you know you should try
exercise on the device side it's pretty
cool and the initial response was
airline scares me so we have a bit of
sailing to do there but we'll see what
we can get around to so what we are is
that we're basically the communication
router for all the vehicles that are
managed by the get around car service or
the pier to be a rental it's no
application logic we're not the magic
sauce in any way the only thing we're
doing is the nitty-gritty and boring
details or making sure that we can
communicate with the vehicles that we
can push updates to it that when the
vehicle calls in that we can received
data that we can unlock the vehicle that
we can receive waypoints for the vehicle
and see where it is but we take all this
data as it comes in as simply forwards
it to the distance logic that is written
and maintained obviously by get around
as well so what we can do is that we can
modify what we're trying to do is to
minimize we want to be we want to be
able to kind of manage the device under
such a fine grained detail as the device
itself allows so what we can do is we
can do a lot of configuration updates on
the device and how often to report in
and how often to transmit waypoints etc
so we can find to how much bandwidth
we're using because this little
bandwidth here is very constricted and
extremely expensive so we need to try to
compact the data as much as possible
using gzip and deltas and everything
else but we also need to go beyond that
and in order to figure out and this is a
generic problem it's not only get around
every all our clients have this issue we
need to figure out for example oh this
is too expensive we keep blowing our
data plan we spoke about data metering
earlier let's lower the waypoint
interval from once every 5 miles to once
every 10 months or once every 20 minutes
depending on how you want to set it up
so we can kind of tweak not only
how often things go in but the actual
density of the data itself and that's
kind of crucial to be able to do that
over there and tweak things asks you
move along and ask you start to shift
into production you see who here you
know we blow sixty percent of our data
budget every every month on stupid call
ends that occur you know the device
calls home once every ten minutes let's
extend that so it calls home once every
thirty minutes for example so all this
is standard a functionality that's built
into the excess end server and what we
do is that we threw our little protocol
adapter that talks to the car kit
protocol Korkut protocol to the device
itself we shift and we adapt and so we
can push those specific configuration
data elements out to the car kit itself
so things we can do the standard stuff
is configuration updates and store and
forward and you know bandwidth metering
and things like that and then we have a
few car kit specifics on top of that
such as door unlock the door lock and a
few other things there's a kill switch
for examples you can disable the vehicle
in case somebody steals it and then the
other way the massive data going from
the car kit up to the server is wait
point data because you want to be able
to see where your car is so you know if
it's not in the parking lot when you go
home you wonder if a I need to track
this so that's pretty much it it's a
fairly standard system from our point of
view there's a bit of extras in it that
the old again all the magic sauce is
outside us and we see this just as kind
of a traffic management system from our
point of view and what we managed to do
and what we did was to get that we took
this our standard yang spec which also
described earlier and we extended it
with orchid specific commands that are
not a part of our standard command
protocols that generated adjacent
command set auto dialer jason
specification out of that and expose
that and shipped it over to get around
and said here's our suggested json api
that you can use and they will then
implement that straight off so having a
yang centric configuration or yang
centric specification system is fairly
crucial in order to kind of single
source where how you generate
configuration data how you structure
your configuration data how you
structure your
see commands and also the interaction
with the at back and application server
I think that's pretty much it and we
have two minutes left so plus questions
I think we can jump to questions right
now I can talk more broadly what we want
to achieve if there are any questions
about that or if you have any questions
but wealth as well yes initially
automotive because motivo which is one
of our founders of a very strong
connection to 0 ease and be kind of the
new breed of low volume automotive
manufacturers such as code Tesla fish
car amount excuse me fisker and a bunch
of other people so and motive are
developing actually to drive trains for
a lot of these vehicles a motive also
develops smart energy systems such as
peak shavers huge container fill them up
with lithium ion batteries you have now
had 2 megawatt hours in a container that
can shave that can pump energy into the
grid at peak hours and kind of absorb
energy during off-peak hours in order to
kind of level the entire to level off
the load on the power generators
themselves all these things needs
monitoring so for the new small low
volume automotive manufacturer
especially the electric ones there's
telematics is not an option you need
every single car needs to be connected
even if the end user the driver itself
is not interested in telematics per se
the manufacturer are interested and for
example the insurance companies
interested as well because the if you
look at the battery pack in electric
vehicle today it's about thirty percent
their total cost of the vehicle is about
ten thousand dollars a complete battery
pack and a nice and leave the residual
value of this car or of the of the
battery pack at the end of the life
after three years for example if the if
you lease it or after five years is
completely dependent on how it's been
used how how deeply did you discharge it
how many charge cycles has gone through
has it seen overheating anything like
that the insurance companies are
extremely interested if they salvaged a
car to see how much money can we get for
this battery pack the van hours that we
now selvage because that determines
we're in which secondary market you can
put it so that's a typical use case for
us as well energy grids is obvious you
need to monitor these peak shavers very
closely because this vast amount of
energy and very you don't want anything
to go wrong at all so those are two
initial markets but we really see on a
broader scale we see the world as a set
of connected sensors that needs
monitoring management configuration and
you need to push you software to it and
all that so as soon as you have a sensor
that you need to manage remotely through
our device manager we'd like to be there
on the service side and possibly also in
the device ID yes no so what we do is
that on this unit this could be an arm 7
unit for example arm v7 we have a data
acquisition ship set on at an ad
converter 10-bit something like that so
what we do is that we have a Linux
driver for that we then add a normalized
seeing airline module on top of that as
a driver something like that that
delivers the data in a normalized format
so that means that you can read a sensor
package at the bottom you feed it
through the linux device driver and
through darling driver and have it
presented in a standard form so the
device application can read the sensor
it can read gpios it can read you know
anything basically and access all that
data in a very easy way front through
kind of coherent API if you want to call
it that or through coherent interface
and that means that we are on our first
step of becoming hardware agnostic if
you replace the data acquisition chipset
you gettin use gnu/linux device driver
you may have to tweak the Erlang driver
a bit on top of that but the application
should not have to change now we also
have I mean you could actually also have
a sensor gateway you could talk to
Tony for example about his other venture
see zone where he essentially has that a
number of very tiny devices that could
not run Erlang on you wouldn't want to
and then basically one gateway node that
is running Erlang and and handles sort
of the more higher level logic and then
then that nose itself would not have any
sensors it's early but it it's the point
of contact with so so this is not a hard
real-time system airline is not there
period it's a soft real-time system it's
a management system so in the device
here you can kind of do too high level
communication you can aggregate data
from sensors or promoter control units
and you can kind of monitor them and
manage them but this is a high level
system from an embedded point of view at
this point this is called X support and
it's an Bert our pc based protocol it's
going to be open i think so we mark this
is closed source but i'm leaning more
toward opening it so but we yeah yes we
haven't built we don't know we're aiming
at eight Meg flash and 32 meg ram so
that's the kind of starting point for an
embedded system obviously you can't pack
too much on top of that such as graphics
etc but that's where we're working with
travel ping because they've done a lot
more and they hardcore embedded work and
getting 88 megs of flash and 30 yes
yes that's the very low end I mean no
graphics no fancy stuff at all obviously
no no massive storage at all now on a
trillion device market we think that we
still will cover a fair bit you know but
but it's not it will not be the tiniest
devices no I mean it's we run a vm on
top of it we will never compete directly
with the low level market controllers
yes my initial question is why would you
not be connected but I see there are
reasons yes I'd say that it's a shorter
time to market and if you use the the
Canada exercise device side you can
start application development
immediately without having to worrying
about device drivers and libraries and
aggregating everything and also you
during the development cycle you can run
a simulated environment that's almost
identical I'd say almost because it's
never totally identical to the device
target and once it runs there on your
simulated environment you can just drop
it on to the target device and it should
behave identically and if it doesn't
need to update the code is trivial in
comparison with generating a new
firmware you know putting it on a file
system image dropping it in there
loading it etc with everything else oh I
did have on one of the slides but I
actually didn't speak to it was that
this X support component is just an
add-on on the exercise device platform
so just like Magnus said you don't have
to be
connected but you don't have to be
connected to two x's sense it's it's
just our share of we're going to do our
share helping Erlang become a really
good device programming platform yeah
you're free to develop your own device
management system I believe Oh as a lot
of questions I think you were first
yes but you obviously have to go through
the application through the exes and
server so if device a here wants to
speak to devise be hypothetically it
would probably go through the XSL server
maybe up through the application server
because we're just a router which we're
done forward the request down there
peer-to-peer communication in a mobile
and kind of a GPRS connected device
environment is very very hard to do
because the IP addresses are often
totally unknown and they shift very
quickly as well but if you can think of
a way to do that I mean you could
possibly orchestrate it using the exit
sense connection and then take it from
there and do something that's well from
our point of view completely out of that
and we're not going to come gunning for
you or anything yes thank you and a gray
jacket
yeah we can it's a sneaker network
basically if you remember dr. yeah I
haven't thought about it I think we
actually can't integrate that so this
basically becomes an extremely long
latency bachelor oriented protocol where
you can plug in remove and plug in not
around yes I do Joe on seniority yes so
one of the core things we want to do
just kind of digress a little bit is
that we want to break up the monolithic
image of firmware as a magic black box
that you're always pray that extra
before you start upgrading you may break
it you may push out something that's
unstable there's no rollback in case you
fail you may lose communication due to
breaking and you have to send some poor
sod out into Alaska to kind of you know
unscrew and install something you so
what we want to do is that we want to
kind of break this into smaller
components where you can install a
monitor ad-hoc after ask the system is
up and running by basically pushing it
from the application server you and you
push some an airline code out here and
it starts executing as a monitor looking
for an overeating condition that you
think may exist or not so we're breaking
it up a bit now this has to be done in a
secure manner and so what we do is that
it depends a bit on how this is set up
obviously everything is encrypted it
goes without saying with authentication
etc and so there are two things first of
all in the device here we have device
keys and it will only accept incoming
data and incoming upgrades and incoming
code that matches the signature that
passes all the tests basically
and also here it's a great question of
data integrity between customers so if
you really want to make sure that you
have the data and nobody else can see it
by a licensed and hosted yourself if you
don't care at all you just want to run a
demo run our shared hosting service and
set up a license there and provision a
few devices there we cannot guarantee we
will tell you that you won't see your
other neighbors day a device such a
thing like that we cannot guarantee
because it's a shared note somebody may
crack it we simply don't know or you can
ask us to host a dedicated server which
is kind of next step up so yes I think I
think so do I'm sorry oh no it's gonna
be at the ER lounge yeah and now I'm
here to answer questions if there's
anything as well thank you very much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>