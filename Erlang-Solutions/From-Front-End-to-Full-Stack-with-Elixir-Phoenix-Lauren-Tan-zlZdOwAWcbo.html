<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From Front End to Full Stack with Elixir &amp; Phoenix - Lauren Tan | Coder Coacher - Coaching Coders</title><meta content="From Front End to Full Stack with Elixir &amp; Phoenix - Lauren Tan - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>From Front End to Full Stack with Elixir &amp; Phoenix - Lauren Tan</b></h2><h5 class="post__date">2017-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/zlZdOwAWcbo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right hi everyone so today I want to
share how I taught myself elixir coming
from a friend and focus background so
I'm curved again my name is Lauren if
you just heard and when I'm not playing
overwatch or video game I sometimes code
I'm an engineering Netflix and I work on
applications that are creatives used to
produce Netflix originals so right now
we're actually exploring elixir in one
simple micro service so come speak to me
later after my talk if you're interested
and what we're up to you can usually
find me on the internet as sugar pirate
or Twitter on github as well and I find
starting off the top of a picture of my
dog helped disarm the audience and makes
me look more relatable I guess so this
is probably the best slide in my talk
it's all downhill from here and here's
my dog and office or she sits next to me
okay now that you're all sufficiently
disarmed let's continue so anyway I
guess I should start from the beginning
my first experience of the web was in
high school my dad gave me a pirated
copy of Photoshop and I spent hours of
my childhood making avant-garde lens
flare art you know some real cutting
edge stuff at the time some of you might
recognize this photo from the latest
Star Trek movie inside know this is
actually one of my favorite quotes from
that movie which is also why I started
off this section by saying long time ago
in a galaxy far away because that's a we
all know it's a great Star Trek quote
anyway I learned a lot about design in
the web by tinkering around with it and
I learned anyway from tutorials and
forums that I came across online and you
know the very first time you visit a
webpage and then you right click and
view source you know the very first time
you do that it's kind of a magical
feeling you feel like like a hacker
almost and in hindsight without pirated
software I'm not sure if I would have
ended up in this career not that I'm
advocating pirating software and even
though I couldn't afford the real thing
back then software licenses and
subscriptions are a lot more affordable
now and I think that's really really
great for lowering the barrier into tech
and ensuring our future generations can
also enjoy this same thing that we do
and of course I also learned HTML and
CSS for my friend in high school the
first thing I learned was how use the
marquee tag which in my defense was also
quite cool back then and fast forward
many more years I went to college I
found it a startup and I started doing
fine and work more seriously I started
learning JavaScript and especially enjoy
the functional side of things for
example being able to use matte filter
and reduce is quite nice in JavaScript
these returned new arrays so you don't
you never actually mutate thorough
jewelry and I would say that Chavez
actually really good language to learn
basic basic functional programming so
for example functions are our first
class so we can write higher-order
functions pretty easily and he also make
use of things like lambdas and closures
which are all really nice and I also
explore libraries like Randa and lo -
which allow for more functional
approaches so all in all I would say I
actually had some experience with
functional programming prior to elixir
and honestly the best way to get started
learning elixir or any other functional
language on the beam is to be familiar
with some of these basic functional
programming concepts first perhaps in
the language that you're you already
know like JavaScript and speaking of
JavaScript not actually such a bad
language I know so I mentioned it they
don't like it but it's used in
spacesuits so it can't be that bad
and after founding my startup and not
really getting too far of it I got
another job and I started building an
application in rails and ever
learning ember specifically was pretty
difficult back then the documentation
was very poor but it's improved a lot
back then since then and they were
actually my first introduction to MVC so
I learned a lot of new concepts working
in ember many of which translated very
well into service site development and
after working on a Phoenix project for
my last job at Dockyard a software
consultancy in Boston I realized I could
also bring some ideas from elixir into
the front-end so for example if you use
ember a JavaScript framework then you
can use this add-on called ember chain
fit which brings in extra change sets
into ember so you can work with
client-side models with
validations
rollbacks in a really nice API to make
changes to these client-side records and
it's been such a great experience Ling
elixir and I think the more I use of it
furthermore I want to actually ride it
everywhere so that's been really great
and of course reacts is a really great
introduction into learning punctual
programming at Elm which has a really
nice strong and static type system so
with that let's move on to the main part
of the talk let's look at what we're
discussing today first we're going to
talk about elixir it's important to
start the basics then we'll look then
we'll look at how to understand Phoenix
and write applications the elixir II and
finally we'll discuss the temptations of
bringing object-oriented programming
into it sir I think that's probably one
of the most common issues when you first
learn elixir so first elixir obviously
before you even dive into learning
anything like the or TP or Phoenix or
whatever other framework you should have
a strong grasp of elixir basics and I'm
going to cover these things that I think
are important to note and try to explain
them as simply as I can and elixir is a
wonderful language that's why we're all
here today and every time I use it we
shake it read it anywhere but the more
and use it the more I realize that it's
not just sugar on top of Erlang so a lot
of the power of elixir reviews itself
when you learn how to use OTP which is
the open telecom platform framework
implemented in early and Anila codes are
actually a lot of interesting ways of
solving a distributed problem so one
thing that was really cool at electric
on last year
drove a de beauté this library called
flow which is both on top of ghent page
so that screen really interesting OTP is
really incredibly powerful as I'm sure
many of you know and once you're
familiar with these basics I definitely
recommend checking out these two books
Benjamin 10 and Tesla Jurek's
books on elixir and they also cover how
to use OTP so first let's look at learn
how to learn elixir the feature that you
probably are
going to be introduced to first is the
pipe operator and here's the super
simple example the pipe operator lets
you ride this like this where each pipe
passes the value from the previous
function to the next as its first
argument now I might seem like a simple
sugar but it's a little bit more than
that I think one of the obvious benefits
is that actually sets you up to writing
your code in a nicer more composable way
which also happens to be easier to test
and reason about but yeah it's not just
about sugar in it enables a very elegant
way of transforming data in composable
manners and it also allows you to - we
handle happy and unhappy pads and when
you combine the pipe operator with
pattern matching it becomes even more
possible and you realize that you almost
never need to use a conditional like if
statement and when I was first learning
it sir I would have to say pattern
matching was one of the hardest concepts
for me to grasp but once again it is
really intuitive and now I'm what I wish
every language hat pattern matching so
yes thank you you're like sir and yeah
with pattern matching you almost ever
need to use conditionals instead you can
just define different function heads to
handle different kinds of data and this
forces you to think about your data
first what are the possible values this
function will receive and how do I want
to handle them so here's another example
where we have a plug using a case
statement to match this arbitrary
currency option so while this is fine
and works you could also write it this
way with pattern matching which in my
opinion I think this reads a lot better
it's more explicit about what this
function does it's also obviously really
nice we than map input to another output
so here's a an example of a controller
in sorry a web hook in Phoenix where you
might want to respond to an incoming
with hope and you might have been sent
an email to a user base on the topic of
that webhooks
so pattern matching you can very easily
just you know map the topic to an email
subject for example
another thing you you will definitely be
introduced to when you first learn
elixir or functional programming
languages in general is recursion so
recursions are really possible to a 50
when you do with things that are like
you know like tree structures or if we
need to reduce values down to a single
value and so forth so let's go through a
simple example let's say we have some
JSON and we wanted to flatten all of
these nested objects into one flat Jason
sorry flat object and that's just to say
just arbitrary constraints that may be
the shape of this jason is arbitrary and
you need to be able to handle deeply
nested objects so various steps so a
recursion is a great fit for this kind
of problem
so let's write a simple elixir module to
flatten some Jason so here's the entry
point through our function let's assume
that this Jason's already been parsed as
a map with string keys so first what we
want to do is we we will convert the map
to a list and in exodus is actually a
linked list so the reason we do this is
that elixir has a very nice way to
pattern match on linked list and when
you create recursive functions it's
really helpful to start with the base
case first the base case is where the
recursion terminates and optionally
returns value without base case you will
get an infinite loop which is probably
not what you want and in this case here
the base case is that if the recursive
function receives an empty list we will
just return this accumulator which at
the point at this point in the recursion
is a completely flat object so we know
that our recursive function will
terminate so we actually need to build
up the accumulator first so here we're
going to just pattern match on the
linked list and ideas that we want to if
the value of this the current value is a
hash or a map sorry then we want to you
know convert that into a list as well in
and call the recursive recursive
function again and then now we would
just need to have a case where the key
value pair is not an object and in this
case which was added to the accumulator
again and we pass it along to the
recursive function and that's going to
keep on going and going until we hit the
base case and then we're done is
recursion and receive our flat end
result and breaking it up as a smarsh
that's helped you built your recursive
function in a more straightforward way
and then here is a super concise version
I would have the face as a personal
experience that recursion for me usually
does my hidden but I found like doing
this in elixir was a lot easier because
of pattern matching and coming from the
front-end world where sometimes you have
to deal with tree structures like this
you know if you if you had written this
in JavaScript for example it would have
been full of if statement and it like
it's just not very elegant or easy to
read so now in functional programming
like to think about transforming data
and there are many kinds of data types
includes so let's look at the ones that
deal with key value pairs when data
comes from the outside of your
application and you need to represent it
with some kind of dictionary you want to
use a map so for example if your API
received a JSON string that you want to
parse and then use and elixir you should
always convert it into a string keyed
map and this is because if you're if
you're new to the beam that atom keys
are actually atoms and because Erling
has a default max atom table size of
about 1 million I think and that atoms
are not garbage collected if you
actually dynamically create atoms you
will crash Earl and pretty much
everything running which I'm not sure if
you can recover from so generally
speaking you if the input doesn't
comfortable if the hash is the keys
don't come from you you don't want to
use atom and when you do have to create
one off map that you use internally then
atoms are a great way to create these
kind of maps but this could actually
lead to the map becoming just like a
free-form bag of data where you just put
random stuff into it which is not always
the best and makes things very hard a
less explicit and it makes it pattern
matching quite difficult to structures
that are typically better since it can
actually make things more explicit so as
an example and if you've used
the scheming that actual provides are
actually just trucks under hood and
trucks are tagged Maps with a week
schema so they're really great for
pattern matching and the insure a
compile time that only the specified
keys are allowed to exist among other
things so here we are missus doing exact
receive and file where we define a
function that pattern match pattern
matches on the struct it's you can
almost think of it like kind of like
type checking and here we have two very
simple structs and the modules that back
them pattern match on the different kind
of stroke and this team starts at the
bottom is a simple extraction this
represents a collection of employee
trucks and then we have functions in
these modules where we can like we can
raise it a single employee salary or we
can raise all their salaries by a
percentage which is great so in your
function you can actually be sure that
it only works with a specific struct so
you know you can actually ensure that
the values are being passed into these
functions are the things that you expect
it to have and then of course we have
tuples and these are very common in the
standard library and even more so again
with when you combine with pattern
matching so these are all pretty much
most of the elixir standard library will
return you a couple of some kind and
then the nice thing about them is that
in awake fear there's this whiskey word
which lets you work really nicely with
text tuples so the nice thing about this
is that you don't necessarily have to
meet your function stereo each pattern
match like you know it's alright leaf
pattern match on the topo itself you can
just extract the value with the whiff
keywords over here and then you can just
use it like that so you don't you're not
forced into only pattern matching
against tuples and then finally there's
also a special kind of tuples combined
with a list known as a keyword and these
are generally just used as options for
function
and so forth and you and generally
they're not really recommend it for any
other use
now speaking of shrugs one thing really
cool about them is that you can design
protocols for them structs combined with
protocols are way to achieve
polymorphism in elixir which makes it
can access something generically without
knowing exactly what it is so from the
team struct example before let's build
it up with a little simple protocol so
first let's define an implementation of
this count function for the team struck
so we can see how many employees belong
in this team and you can do this using
the DEF implementation keyword inside of
the body of the module and now what
happens is that you can actually use the
standard library the enum module of
count function on this struct
even though it's not really like it's
not a list for example and if you define
all the necessary implementations for
innumerable which is count member and
videos then your team straps or whatever
the other struct that implements these
semantic functions they effectively
become a kind of enumerable even though
they might be a struct so let's take a
bit further than we actually fully
implement this enumerable protocol the
member implementation here if you return
error and a module in a temple then just
going to use the default membership
algorithm that elixir already uses and
then the reduce implementation at the
bottom is pretty much a coffee pace of
the source code so I didn't want to
write my own reducer so but what does it
means is that now you can actually use
all these innumerable functions on your
struct which is really nice because if
you had last talk by about libraries
about you building designing with
software libraries then one of the
recommendations was to you know make use
of the language features so I think like
if you if if for example you're writing
a library where you have a struct that
represents a collection of things then
if it's an enumerable is it's a kind of
enumerable then it means that consumers
of your of your library can actually
use regular language features to
interact and deal with that struct
instead of you know making custom
special functions that have to do that
do it to do that and the really nice
things that you don't have to implement
every single function of the innumerable
of any rule to make it in innumerable
but only three that you need to
implement our account member and reduce
so let's say we had a function on the
team module to promote all the employees
inside of it so the previous
implementation you actually have to know
like what this like what destruct the
internal structure of the struct looks
like but now that's in enumerable you no
longer need to care about how its
internally structured so again like if
you're if you're working with a
collection of things then it's it's
really nice to just use regular language
features to interact with this while
protocols work with data types like
structs behaviors our way to specify an
interface for callbacks in modules so
let's say we wanted to validate some
data that comes in from an external
request so let's start by using a really
simple strap to represent it request and
then let's just say we want to validate
this request is in some kind of
structure that we expect it to be and so
to do this you might want to write a
validator so here we might validate that
some value on this request is a number
it's present and so forth and then this
validator module you can actually
defined behaviors using the @ call back
at macro call back and at optional
callbacks and now in your actual
validator logic you can implement one of
these these actual validators that must
implement that interface that you just
defined so here's a super simple
implementation of the peasant validator
and USS we just have to implement all of
the non optional callbacks that you
define in that behavior if you don't
then you get warnings when you compile
but you don't actually get compiler
errors but if you run dialyzer which is
the static analysis to for Erlang
then you can't be checked to it at least
you can check to ensure that this
callback was implemented correctly and
it's over really not easy
straightforward to get dialyzer working
with an elixir project there is a
wrapper around dialyzer called dye
elixir which is pretty straightforward
to add to your mix project I think I
sorry typo there
and then using type specs is a tool to
do static type checking type checking
can be very useful and it helps you
catch errors before they happen and
there's a really nice blog post at the
bottom of the slides that shows an
example of test-driven development using
type specs which is a really interesting
read so I recommend checking it out
after talked and finally I wanted to
look at macros I think one of the
coolest features coolest is probably
easiest abuse language feature of the
lakeside meta programming no excerpt is
a first-class citizen and if you're not
familiar with meta programming it's code
that writes codes obviously that's a
very powerful tool and as an example
libraries ecto provides a lot of macros
that give you a nice domain-specific
language to create sequel queries and
phoenix for example also provides you a
nice DSL for using like for matching
different kinds of requests in its
router and you may or may not know this
but elixir is actually written mostly in
elixir as macros when I first realized
this a while ago I was a little confused
like how can you write a language in
itself it's how does that even work well
it turns out elixir is a compiler
technique known as bootstrapping and
bootstrapping here happens in early and
then the bootstrap being is actually
used to just define a period if
permitted macros that make up elixir and
it only understands the basic building
blocks of elixir and then you can
actually start writing elixir elixir as
even quote here is like def def PDF
module and so forth and yeah so it's
actually really interesting going
through the elixir source code because
it's actually very understandable
because it's all written in Aleks
so that's really nice so here's an
example where we have a module known as
kernel special front you know in the
elixir source and this module
essentially just defines the basic
building blocks of elixir like mass and
list literals and like all these little
language features and it protects them
from being overwritten by other macros
and then what happens in Erlang is that
it will actually call the relevant
airline module to create whatever it is
that is being invoked so the example
from before your math literal that %
curly braces it will get passed through
here and then we'll create the elixir
map and then the other function at the
top is responsible for updating maps and
you probably already know that you can
call early math modules in elixir so you
don't have to reinvent the wheel just by
calling the module with the name meth
and atom you can access them and then
you can also see for yourself that the
elixir math literal is equivalent to a
regular alignment so you actually know
that that's what they are under the hood
although for a while before they weren't
but now they are alright so now let's
try making our own really simple really
silly macro so there's this command-line
utility called Cal C not sure if people
here know it but basically it's a very
fully command-line tool or and it what
it does is it takes some text as
argument and just returns a little ASCII
picture of a cow saying what you said so
this is for fun let's just make a silly
macro that does that just for learning
purposes so here you'll notice the top
we define the macro with called using
with double and this forest also known
as a underscores I learned that pretty
recently and that gets called when you
bring in the module into when you bring
in this macro into into another module
and then what happens is the math the
macro will actually define the function
on that the other module at compile time
so now if you use this calcium module in
another module then this macro get
called because of the youth keyword and
that will define the cost
function on your modules so now you can
call Bob calculate and though it's not a
function you defined yourself and you
can probably see here like how like this
is probably pretty easy to abuse like
it's if you if you include a lot of
macros in your library for example and
you don't include things like you know
like documentation or behaviors or
things like that then you get these like
magic functions that appear on someone
else's module and they have no idea
where it came from and of course yeah it
does work so it's a silly example but
hopefully it shows you how powerful
macros can be and I didn't really go
into too much detail on them but if it
just said please read Chris in the
chords book it's a really great book
about macros and very interesting read
as well alright so that was a whirlwind
tour of elixir so now we're all worth we
know elixir 100% we can write some web
application so let's let's learn some
Phoenix now I title this section Phoenix
is not real because I think a lot of
real programmers actually are trying to
learn Phoenix because of the
similarities in syntax but one of the
things that a lot of people ship up with
is that thinking that elixir of Phoenix
is a kind of Rails but the only the real
similar the only severity between
Phoenix and reals is the syntaxes and it
starts and end there that's the only
thing that's similar about these two
frameworks and it's really good to start
with fresh perspective especially if you
go from an object-oriented language to a
functional language and I hope this
section will help that so once you're
familiar with about the basic building
blocks of elixir and the general general
understanding of the concepts that are
functional programming encourages then
Phoenix is a lot easier to pick up
because it builds upon them and then
expand upon them so let me use a really
simple Phoenix API as an example to
explain what I mean so Phoenix is mostly
made up of pipelines and a pipeline is
composed out of plugs and that's
yes mostly our pugs I'll get to that a
little bit and one of the main bits of
Phoenix is this little module in your
application called end point and this is
responsible for receiving connections
parsing requests adding headers sessions
and so forth and then this connection is
handed off to your Phoenix router which
routes that connection to a controller
action then your controller does its
thing and then passes the connection to
a view or even helps it if something
went wrong and then your view will
perhaps prepare the connection for
rendering education or something else so
here's a simple diagram to illustrate
what I assisted it starts at endpoint
there's a router then the plug pipeline
and then a controller interview and
optional side effects if you for
instance you need to do you need to
purchase something through a database
and if you really loom out and if you
think of it in an abstract terms then
you can even think about feelings like
this is obviously more than just like
this function but the idea is kind of
similar so there's a really nice
functional way of thinking about Phoenix
or web applications in general so yeah
and remember if Phoenix is not your
application it's only the web component
of your application yeah so basically
Phoenix is a pipeline a pipeline made up
of smaller pipelines and functions many
of these are plugs which I'll get to
preacher and then the smaller bits are
functions that you define in your
application and you can think of these
like the lower-level operation and the
Phoenix you have a very functional way
of pulling applications everything is a
function and everything's very explicit
there is no magic in this framework at
all and once you realize this it becomes
kind of simple and straightforward to
reason about and you know should always
just look at the stuff in the
application fail to understand what is
going on so plugs I mentioned plugs and
these are one of the core abstractions
that elixir standard library provides to
you a plug is a direct interface to an
underlying web server so
you're familiar with Ruby plugs kind of
like black but not really because with
plug there is no concept of middleware
there's only plug the only concept
inside is a plug and there are two kinds
of plugs so this is a function plug
which takes in a connection and some
options and the contract of a plug is
that it also has to return the
connection and in that way you can
actually using you can you can pipe
plugs together because they all receive
connections and the output connection
you can also have a module plug that
implements these callbacks in it and
call the call itself is the step
function plug I mentioned before and you
can also set options of the thing if
through the init function so yeah this
is very simple but powerful contract and
writing plugs becomes very easily once
you're aware of this contract and you
can make use of them not only in your
router you can actually also make use of
them in controllers or anything else
that deals with connections so here this
verify request signature from a function
plug will be called before any action
that's handled by this controller you
know you can even add guards for the
plug so it's only called for specific
actions or you can do it in whatever
other way and plug pipelines in the
Phoenix router are very compatible for
example let's add another pipeline for
our API to follow another spec and you
can just literally just add it to this
pipeline and it will start using that in
your application then as an example for
that for that let's just make two scopes
in our router and the v1 scopes at the
bottom is nested inside of this API
scope at the top and then we have this
public route called foo and the full
route will only go through this JSON API
pipeline at the top while the user about
at the bottom will also go through
another pipeline how authorized where
you know you might do some
authentication and so forth and remember
the endpoint module I mentioned earlier
if you look at it it's actually gives a
really big
plaza pipeline it just plugs everywhere
you know so like logging Jason parsing
adding headers session information
everything happens here before the
connection even hits your router and
will you be surprised if I told you that
the Phoenix controller is also a plug it
is though in some sense
Phoenix is fractal or in other words
each part of it has the same
characteristics as a whole okay let me
zoom all of it so a while ago I wrote a
blog post about using Phoenix to
incrementally replace existing API
terraform has no relationship to the
Hashi core product it is it was a Poor's
naming position okay but anyway
committing to a full rewrite is a really
difficult expensive and disruptive task
obviously and probably not the best use
of your time but if you could do it
incrementally one endpoint at a time
then you could perhaps make the case for
trying out Phoenix without having to get
significant buy-in from anyone else and
you can then see for yourself is a
rewrite is worth it
and now that we know how Phoenix works
on a relatively high level it should be
kind of straightforward to figure out
how to do it so I'm going to walk
through how I built this little plug
with an ex colleague of mine so we
called it terraform and essentially what
it does is it matches it forwards routes
that you don't handle in your
application to potentially another api
of your choice and while it will serve
up your Phoenix API if it does find a
match and then so what happens is you
can just implement one or more endpoints
that you want to replace in your current
API and then forward everything else to
your old API like a reverse proxy you
can use internet for this but we wanted
to try it out in Phoenix and an exactly
very little code if you look at the plug
itself so when we were doing this our
first hunch was to try and just put this
plug in the router in the endpoint model
that I showed earlier because that's
where we we knew the connection would
first come in to your application and
then in this plot we would just look up
all the routes this is initial implement
and we would actually like look up all
the routes in the router that you define
and then we would see if we need to
forward the request in or the real API
or to handle it in Phoenix but I will
say this turns out to be a bad approach
because as identified these double
underscores we're making some private
API which is usually frowned upon and it
was over very inefficient because we
have that we this implementation you had
to actually check every single request
and whether or not it needs to be
forwarded so that was a good first
attempt but we thought we could do
better so we went back to the drawing
board and whenever I get stumped I find
it very helpful to look at other people
for scores for ideas on how they solved
that problem and we had a pic as a
source for the error handler error
handler plug in the plug weasel and my
colleague Dan you realize that we can
actually use the same idea in a plug
which is to only handle missing route
errors and then that's where our plug
would take action and because that was
over rideable we could use the same
macro but then just update the catch of
this cache to do the forwarding for us
and so this little plug was born again
no relationship to the products by happy
cart we this chosen name because we
thought was a cool metaphor for
incremental rewrites like transforming
an uninhabitable planet into a habitable
one except it's an API alright so in the
plugs plug itself we have that using
micro I mentioned earlier that gets
called when your when someone else's
installs this plug-in uses it then we
will essentially look for this
terraformer option being passed into the
macro which points the module in the
Phoenix application that the person has
and then we restore it in the model
attribute so we can access it later this
before compile macros is run and we pass
a connection in the cache and through
the terraform which is itself a plug
that's one of the contracts that we
decided that would be important to
ensure so that we can again use all the
language features of pro-x earth so now
if you actually want to use this
in your application you can just use the
youth keyword in your router and then
pass it a reference to a terraformer
module using this care for my keyword
and a terraformers is a fancy word that
we came out with her a plug that handles
how the unmet request is forward and if
you use the plug outer mac code then you
get this really nice DSL for routing
micro so all the things that you might
be familiar with like get put post and
so forth you can actually use these same
macros to match and then forward
requests to your old API so you can even
match up very specific tasks you can
handle everything for a get request you
can send it to different API is
depending on the request you can add
authentication headers and do anything
and then whatever is a response from
that ATA comes back with will be sent
back to user so if you want to try this
out and you don't want you don't
necessarily want to use something nginx
to do a reverse proxy you can you can
even use this Phoenix on its own to to
do to do this alright so now it's on to
the next section I think one of the
hardest parts about learning elixir is
resisting the urge to bring in
object-oriented concepts that you don't
necessarily need in a functional
language before we continue I want to
say that I don't hate ol Pete I think it
has its use I've had a lot of success of
it but for my time Cenozoic so I
personally think it's a lot harder to
shoot you shoot yourself in the foot
with a functional language away from me
and when I go back to work on something
like a Ruby and rails API it's very it's
often very hard to understand what's
going on because it's so implicit
there's a lot of magic that happens
under the scenes and if you've done any
opie you've probably heard a design
penance
you've probably implemented some of them
as well but it's not always clear I mean
at least the beginners what the pattern
is the ones that the best pattern is
suited for the problem you know
sometimes I feel like multiple patterns
can solve your use case right and unless
you have lots of experience with TVs you
fall into the trap of
trying to implement all these fancy
patterns because you read a blog post
about it and you end up just misusing
these attractions and there's a core
everybody liked about choosing the right
abstraction by Sandi Metz I think
there's actually applies both to object
oriented and function programming but
perhaps even more so when you try to
attempt to solve hollows with a design
pattern but surprise there it turns out
to be design patterns for functional
programming too and it's quite
straightforward so there's this really
really great talk by Scott lation he
does a lot of work to the F chart
language and the next couple of slides
are kind of heavily influenced by talks
so if you have time to check out his
talk it's a really good now the biggest
thing in my opinion when you transition
from an object-oriented to a functional
language is figuring out how to do with
speed in object-oriented programming as
its name suggests you encapsulate this
state with objects and instances and so
forth and JavaScript for example you
might you know use the disk keyword in
the context of an object so that you can
access values on the object itself so
here's a really simple example if a
class can it does stuff like greet
report move you know classic example you
instantiate a class now you have an
object you can you can move or greet
report and so forth and these methods
can actually update the internal state
of this object and in other words they
have side effects and they are not pure
functions at all and you know if you can
obviously do a lot of other patterns
like you know extract logic into a
moveable class and then you can do
polymorphism and so forth but in
functional programming instead of
instead of doing that we actually we
want to think about data and
transforming data instead and in lxr for
example if you really need to have state
then you typically would hold it in a
process like an agent for example and
you can even share this across other
processes but not everything needs to be
faithful and so let's look at a simple a
very simple example
here we have a function it takes an
input it does something with it and then
and output this is the main contract of
a function in object-oriented
programming you might use a method on
this object to convert it into something
else for example so let's say you want
to convert a banana to pineapple but you
know this might blow up because you
didn't define this function to pineapple
which by the way is a great error
message for space suits but what about
in functional languages so we solve the
problem with composition and you can
tell that this composed function was
built from smaller functions and and one
of the really useful metaphor I like to
think about with all that tries to model
the system under interactions within the
system while in function programming you
just think about you know how does how
does my data come in and how do I
transform it as it goes along throughout
my application I mentioned earlier that
Phoenix is fractal the same can be said
of functional programming so again the
simplest example is this single function
if you use the value of this function as
an input to another function what you
get is a service so for example you
might go validator or whatever other
service that your application needs and
this is composed with small likely
low-level functions now you take your
services you compose them and then you
end up with use cases so again within
the context of a web application maybe a
user must update your profile and of
course if with another of those use
cases if you compose those together then
you end up with a web application a
request goes in and the response comes
out magic and if you recall this is
exactly the philosophy of Phoenix you
know you take connections and you return
connections so hopefully was that
example it kind of makes a little bit
more sense now
so to recap it's always a really good
idea to start with the basics first I
know I went through a lot of stuff in a
short amount of time
but hopefully this if you're new to the
language that have made you curious
enough to learn about all these
different features that elixir provides
so as a recap you know like
pattern-matching pipes are super
powerful if you combine them recursion
is something that you most definitely
encounter in a function language it can
be scary but personally for me and I
used to hate recursion like doing
recursion at all but I think elixir and
functional programming makes it like a
lot easier a lot more fun to deal with
and then we have all these other really
nice language features like protocols
and behaviors and macros Phoenix is a
pipeline made up with smaller pipelines
and plugs it's pretty much plugs all the
way down and very fractal in nature
plugs are abstractions that wrap
connections and return connections
making them very composable and
understanding this actually helped us to
create that plug that terraform plug for
incremental replacing api and in finally
in object-oriented programming you have
state in functional programming we think
about transforming data and function
programming is very fractal a low-level
function is composed with other
low-level functions to form services
services compose to form use cases and
your use cases compose to form a web
application you can keep in touch with
me on Twitter or github and you can come
to accumulator if you have a question so
thank you for listening you've all been
great</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>