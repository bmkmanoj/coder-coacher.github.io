<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>From Irrational Configuration System to Functional Data Store - Rob Martin | Coder Coacher - Coaching Coders</title><meta content="From Irrational Configuration System to Functional Data Store - Rob Martin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>From Irrational Configuration System to Functional Data Store - Rob Martin</b></h2><h5 class="post__date">2015-11-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/TetuYdZzBLg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so it's right after lunch and it's a
small room with a few people in it it's
probably going to get warm so if I not
off somebody you know not nudge me or
something okay so I met with see tanner
company and we do employee engagement
through like recognition and
appreciation awards and I'm going to
uncover some warts about our system but
before I do let me just say that we do
appreciation really well we created the
field when ohbert see tanner and so we
see tanner went off to Berkeley in the
mid-30s 1930s to earn his PhD in
philosophy it was in the philosophy of
appreciating people so we've been doing
it a long time where the biggest company
in the world doing it we've got offices
all over the world including right down
the street and Essex I've never been
there 28 of the company's on the fortune
100 best places to work list use our
software we're one of those companies we
use our software and we're on the list
we're at position number 40 OC Tanner
has grown over the years primarily by
saying yes to customers as but as we've
increased our capabilities we've also
increased our facilities I saw somebody
like raising a hand back there and
waving hi so as we've increased our
facilities we've kind of tacked things
on you know like an old house with a
family in it that's growing so you get a
new kid you make a new bedroom ok so our
basements are a good example of this we
have seven basements and none of the
basements are connected to each other I
heard a story about a woman who started
her new job at OC Tanner she went
through the half day of orientation and
at the end of it rather than going to
lunch with her cohorts of new employees
she asked if she could go visit her
friend who had recommended her for the
job down in one of the basements so she
got directions now the the person
running the orientation didn't expect to
see her again because
they were done she was supposed to
report to her boss and her boss um new
boss when she didn't show had no idea
whether or not she been there all day so
he just figured oh well she didn't show
for her job so is late that afternoon
that somebody found her down in one of
the basements kind of crumpled on the
floor hopelessly lost and crying and
this is what our software is like to I
mean that our software has grown
organically over the years mostly by
saying yes to customers can I have this
new feature yes yes can you do things
our way yes yes can I have that in royal
blue yes it's like a you know I castle
new tower every time with a royal blue
turret on top or purple we can do purple
too so this is where much of the
complexity and in our software and in
software and general comes from from
organic growth and I know we're not
unique in this and according to alan
watts this is you know a pretty
universal occurrence so when i first
started my boss put me in charge of the
team responsible for our configuration
tools for the second largest software
platform that we offer explained to me
that there were umpteen hundred settings
and onboarding a new customer requires
individually getting each of those
settings right every one of them had to
be set individually and that's a big
part of why onboarding a new customer
can take as long as ten months for us
and we have 175 people who do that job
so my team was responsible also for the
monolithic web app that is used by our
internal customers our implementation
specialist and our client services team
to manage those settings and I learned
on my first day the only developer I had
on that team it was on maternity leave
and nobody knew when she'd be back so he
also told me there is a standing
prediction in the office that anybody
who
took on configuration would be gone
within six months he didn't tell me if
that would be like my choice so here are
a few statistics from the beginning of
our project I found it intimidating but
really it's probably just a fairly
typical system we have about 75
programmers since on staff most of them
are carving up are monolithic platforms
into micro surfaces right now I
software's complex you've probably
worked on systems just as complex my
team is working on a better system for
configuration and configuration
management but the process that we've
been working through is pretty much the
same regardless of what our project
actually is our current configuration
data is poorly organized it's hard to
find it's hard to reason about it's kind
of like a kitchen junk drawer most
kitchens have one that's how come and
our problems are our legacy code is
written in Java not that that actually
matters all that much what matters is
that there's a lot of it and it doesn't
have very many automated tests so we
can't fix it all at once and we have to
work with it we have to support the
legacy system reducing complexity is
always my zeroth law of programming so
my goal on this project like any other
project is to reduce complexity so the
22 tools that I use most to manage
complexity our design patterns and
functional programming design patterns
prune a project back to a common shape
which makes it easier to think about and
functional programming makes it more
predictable I'm not going to cover all
of functional programming in one slide
so we're actually going to talk about a
pattern that i like to call functional
first programming the first design
patterns so you're probably here because
you think you might have problems I mean
you might have problems that look
something like our problems
if we're all lucky I might have
solutions that look something like the
solutions that are going to solve your
problems that's what a design pattern as
design patterns are generalized
solutions to generalize problems to help
us understand our problems quickly and
they give structure to the solution
really early in the process they help us
reason about our project right away
pretty much everything I'm going to talk
about today is a design pattern
functional first programming events
stores command query responsibility
segregation prefix tries static site
generators they're all design patterns
we didn't do anything new you still have
time to get to another session if you
need to we took we looked at the problem
that we were trying to solve and we
found patterns other people had
discovered that matched our problem and
then we look at they establish solutions
for those patterns and we implemented
them customize them to fit our needs one
of the really neat things about design
patterns is that they bring win with
them if I'd sat down to create goals for
for this project without having a design
pattern in mind I would have come up
with a pretty good list but the patterns
we chose strongly informed the design
goals for our entire project and we got
things out of that that we wouldn't have
known to ask for and of course I not
only oh by the time we got those we knew
we could have them then we weren't going
to let them go they were too good so
choosing the right patterns not only
helped us solve the problem they raised
the bar on what we could expect from our
solutions okay so I stole the term
functional first programming from Don
sign I didn't ask him and I never
actually checked to see if I'm using it
the way he intended if I am it's only
because he named it really well because
I heard the term and I thought oh that's
what I'm trying to do so I may owe him
an apology
I probably owe him an apology my version
of functional first programming goes
like this first code everything that's
possible to do without side effects and
then code the side effects the first
part should be purely functional it
should be easy to test easy to reason
about and maybe even provably correct
the second part is just side effects
which probably means that it depends on
Io libraries that someone else has
written and tested there's a good chance
you won't even need to unit test your
scientific code which is good because we
hate writing mocks right plus your your
interfaces to the outside world to your
databases to your web interface these
are all strictly modular and really
really thin so changing an interface or
changing a database is a very concise
process you can do functional first
programming in any programming language
even object-oriented programming
languages Gary Bernhardt has a really
good talk on that I think he calls a
imperative shall functional core but I
think using a functional programming
language makes it easier I like mostly
pure functional programming languages a
powerful language like C or C++ or Java
might let you do all sorts of amazing
manipulations inside of a computer a
flexible language like Ruby or Python or
I don't know javascript is a great
example might give you a lot of choice
in how you solve a problem and those
languages have their place but for
managing complexity I really prefer a
strict opinionated constrained language
power and flexibility lead to increased
complexity it turns out choosing a
language is a lot like choosing a design
pattern the languages that we the
languages we use change the way we think
about problems the languages we use
change the way we think my team could
have solved our configuration issues you
only Java and it would have been
acceptable but choosing an actor based
concurrent programming language created
opportunities for us that we wouldn't
have gotten which is Java when we
started I thought we were building a
specialized configuration service it
actually took me a month to see we were
actually building a pretty generic no
sequel database just a key value store
when I finally realized this I went to
my CTO and asked him why he approved the
project if I'd realized it sooner I'm
sure I would have dropped it I would
have dropped the project and tried to
figure out how to do it with you know
and off-the-shelf no sequel database and
the jury's still out on whether that
would have been a better move but by the
time we realized what we were doing we
already had some design goals that we
knew that we couldn't meet with any
off-the-shelf database so we kept going
so our data structures is basically a
try which is actually called a tree
because it comes from the word for it
comes from the word retrieval but I
prefer to call it a trying to
distinguish it from the word tree that
comes from the word for a big woody
plant tries help you find things quickly
and store things compactly by building a
tree that shares prefixes and our case
nodes could represent a dotted notation
key we map each of the nodes in the in
the try to an elixir process or an actor
and give it responsibility for
processing events root regarding its
state persisting new events and sharing
new events across the cluster our old
system doesn't have the concept of
default settings every new customer
needs to have every configuration
setting established by an implementation
specialist with our new system we wanted
to get most of our settings from a book
of defaults and only get involved when
the
fall wasn't what the customer needed
this is where our book metaphor comes in
handy we have books for system-wide
settings we have books with the default
settings for various option packages our
customer the the big custom and the
enterprise they have their own book
their profit division might have their
own book their users can each have their
own book and composing data is kind of
like stacking those books the book
closest to the top that has the data
you're looking for is the data you use
okay so you can just kind of compose the
data down through the books with the
higher book having priority so we have
this special situation though although
many of our customers can just use the
default settings that we have at any
given time some of them have to go
through a change review process so we
can't willy-nilly update a default book
and then distribute it to all of our
customers so until they approve a new
configuration in our system by going
through their engineering change request
we can't push it to them so we need to
maintain previous versions of books to
looking at the prefix try again this
time it shows that every node contains
not only its current state but also the
previous states for the nodes we keep
the value of the node over time in a
list so when someone asks for a setting
without specifying what version they
want they get the most current valid
data but if they specify any specific
version that's what we give them
under the old system when a developer
needed to create a new configuration
says setting he or she would create a
row or maybe a table in the database and
store the data their documentation
typically sucked the name of the table
the the name of the column and whatever
code you can find for it and if you as a
developer needed to interact with that
setting those were the clues you had to
figure it out from unless you could go
find you know the developer at least the
team that made it in our new system when
a developer creates a setting they store
alongside at any information that's
needed to find understand change and
validate that setting so our system
contains not just data but metadata a
title a description and a schema at
least did you want to ask you a question
oh I think so yeah
uh-huh there's a reason for that yes it
was a choice we made up front that
that's a pattern that we wanted to work
with and we'll get into it okay so
anyway we can store the the title
description schema and maybe also some
tags that define where to show the
configuration setting and who can change
it who can view it who can change it the
metadata tests everything we need to
know in order to expose that
configuration setting wherever we want
to with documentation that came straight
from the creator of that setting our try
structure holds metadata in each node
and when we query the configuration
service we can request the data or we
can request the data and metadata either
way as it traverses the try it picks up
the metadata and composes it with
metadata along the way so it so it's set
up so that we can inherit metadata from
parent nodes to figure out how to
display and where to display child nodes
we've been carving up our monolithic
code into micro services but we're only
halfway there and still have a year or
two to go our new configuration system
has to support the legacy code we really
don't have a choice on that if I knew we
delivered I knew if we delivered a
configuration service that required the
other teams to drop their work on micro
services and go rewrite legacy code to
use the configuration system that we
wouldn't get the buy-in we need for the
project to succeed and I knew that if we
only support a new code and not the
legacy code then we'd be delivering
tools to our internal customers shiny
new tools for the new code and they'd be
stuck with the old
tools for the old code and they would
hate us I don't like that solution
either so we addressed the problem by
supporting legacy code using a
functional data store based on two
patterns of n stores and command query
responsibility segregation a functional
data store is a pretty broad label it
means basically a database that doesn't
let you change the data it just lets you
transform it for comparison we're
probably familiar with the crud database
create read update delete a functional
data store doesn't do updates or deletes
instead instead of updates we create a
new state for an existing record instead
of delete we can mark things as gone as
of a certain time things change over
time and very often we want to know
about the data that we had before even
if the data was deleted sometimes
especially if the data was deleted so
our functional data store is based on
these two patterns that work really well
together event stores and command query
responsibility responsibility
segregation event stores are like your
checkbook register with most databases
we overwrite a value when it changes
right that'd be like keeping your
checkbook balance by erasing it and then
writing in the new amount every time you
spend money or deposit money and we're
not going to do that and so we keep a
list of all of transactions going back
to the first deposit we made when we
opened the account from that list we can
figure out what our current balances as
well as what our balance was at any time
in the past command query responsibility
segregation is the difference between
the checkbook register and the running
balance that we keep for the account
when we make a deposit or we draft a
check that's the command side when we
want to know what our balance is that's
the query side and we don't we don't
answer that query by starting at that
first deposit
then calculating it all the way through
every time we want to know how much
money we've got we just go look at that
last column that's the query side events
tours and command query responsibility
segregation work the same way we've got
everything we need to know the history
of the record but we also keep kind of a
hot value a projection of the current
state of that record we built our
configuration system with these patterns
because because of the design wins that
we got that we didn't even know that we
needed when we first started our
customers don't have to update their
configurations all at the same time they
can go through their engineering change
process so when something changes in the
configuration service okay so because of
the command query responsibility
segregation if something changes in our
configuration service we we also have to
get it into Oracle so that the legacy
code can see it and if something changes
in Oracle because the legacy code
changed it we need to get that into our
new configuration service so that the
configuration service has it because
it's the canonical data source so we use
what we're calling data coordinators to
do this with two types of data
coordinators with publishers and
subscribers and you can guess how they
work just from their names the
publishers pay attention to a data
source and win something changes they
publish a message about it the
subscribers listen to those messages and
when something changes they coordinate
the data with the the data source or
event source that they're working with
subscribers blah blah blah sorry I'm
looking at my notes
okay so even though it looks like we're
trying to keep two disparate data
sources in sync I think that we aren't
this may be a justification but that's
that's where I'm at this is my story and
I'm sticking with it the configuration
service is our canonical source Oracle
is just a place where we store a view of
that data so the event store is
canonical all of the views all of the
projections are not canonical Oracle
just happens to be one of those likewise
when the data changes in Oracle that's
just an event source for us it doesn't
really matter to me whether we found out
that a user changed a configuration
setting by using a piece of software
that we wrote or by changing something
in the database it's just another event
so basically we built a platform that
watches for data to change and when it
does it publishes a message so we made
it possible to subscribe to our data
rather than just pull it it's almost too
good to be true I'm rather worried that
it's too good to be true and if you want
to explain to me why it's too good to be
true I'd be interested in hearing about
it afterwards serious on that
so our work on this project covers
configuration and configuration
management and to end so we're not
building just a configuration service
we're also building the tools to manage
that service our current configuration
management tool is this web app that
exposes all of the settings possible for
any given customer basically in one long
list we don't want that we want our
internal customers to have a bunch of
small tools that support their workflow
right now they have one big tool that
they designed their workflows around we
want them to be able to design their own
tools and bring them to us to build we
want to be able to turn those around
really quickly like often the same day
if we can do this for you make it simple
for them to work with us on this then
they'll be able to iterate on their
process using us as you know their tool
builder one of my goals for
configuration management is that juniors
should be building these tools that'll
be a good indicator that we manage
complexity well but there's more when i
started at OC tanner we couldn't hire
any juniors we didn't have any work for
them to do if we can't hire juniors we
can't build seniors we could hire
seniors but we can't build our own we
can't contribute to the growth of the
community in that way at least and we
can't get junior started off right or at
least what we call right and OC tanner
is a really good company and we really
care about people a lot I mean like
that's what we do that's what we help
other companies do and that's like why I
work there it's amazing so it's
important to me that we have work that
juniors can do so that's one of the
goals for this one
most of industry seems to treat
functional programming is something that
senior developers do and sometimes only
the best senior developers it's almost
as if we don't trust somebody with
functional programming until they spent
a decade with object-oriented
programming and didn't kill anyone we're
teaching new developers to live with
complexity rather than reduce it so I
want to help change that our interns and
our juniors learn functional programming
I teach functional programming outside
the company too we're doing a session
this weekend with the London chapter of
women who code on elixir ask me about
that afterwards if you're interested so
ultimately whether seniors or juniors
build our configuration tools isn't
exactly part of our functional
specification but it is working for us
and in fact I have a team of interns
that are building the first set of tools
right now so i think there's this
natural boundary between server and
client software just like there's a
natural boundary between the company and
the user i think over the history of the
internet we've been building systems
that consistently violate that boundary
companies have goals users have
different goals I try to design systems
that keep the company's interest which
is mostly about the data and the
business logic which is basically
keeping the day protecting the integrity
of the data I try to keep that on the
server and I try to keep the users
interest which is meeting their needs
while they're online or using your app
right I try to keep that strictly on the
client servers shouldn't do client
things and client software shouldn't do
survery things oh and I particularly
hate it when client software is designed
around especially like a crud interface
you know
you could tell that they couldn't see
past their their crud api when they
designed the the client software and
that leads to all sorts of problems that
i like to call the tyranny of the
database so programs on the server
should focus on the on the data and
programs on the client should be all
about the client it's a single
responsibility principle it lets the
server team focus on the company's needs
and the client team focus on the user's
experience it reduces coupling where
there's no point in having it tightly
coupled and it reduces complexity so
that's one of the things we did on our
project the configuration service offers
an interface for managing configuration
but oh and the metadata that tells you
semantic things about the data but the
configuration service doesn't have any
opinion about how you manage that data
that's the job of the user side tools so
we talked about command query
responsibility segregation on the server
side and then for that we talked about
events not really about commands events
or how servers map commands the user
does something real and the server
update sets model by handling an event
about what the user did but the events
start with the user doing something that
something is the command when we put a
form elements on a page we're giving the
user the ability to issue a command to
change that value commands are
imperative commands happen in user space
commands are part of our shared reality
what we might call the real world events
are how the server tries to maintain a
consistent model of the real world so
here's another way to look at it we can
call this sanity in psychology we
consider somebody to be seen a scene not
insane when their view of reality their
internal view of reality matches what
the rest of us think about it okay
otherwise we call them insane
our data is saying when we maintain
consistency between the users experience
of the world and the model we're keeping
of that world very limited model of the
world usually so we had to consider what
happens when someone sends us a
configuration value that doesn't
validate now if we were a regular old
database we would just don't reject it
but if we were a regular old database
we'd only be keeping current state and
it would break our contract with the
user to give them state that lacks
integrity that doesn't validate as an
immutable and time-variant database I
think we have a responsibility to accept
all of the events even the ones we don't
like and handle them somehow and because
many of our I can't tell you where our
events are coming from you know it's
like the changes to Oracle I treat that
is just another configuration change
event but I don't have anybody to talk
back to when I'm just noticing a change
from the Oracle redo log so even if the
data is invalid we need to accept it so
what we decided to do was use metadata
to mark States as invalid and if you ask
for a data point a key we're going to
give you the latest valid value but if
you ask for the whole shebang you know
data and metadata will give you the
latest value regardless of whether or
not is valid then we can use that valid
flag in the metadata also to generate a
report of broken keys that we can use to
ask some human being for help
so we could created the slick functional
system for building configuration
management tools and its really bone
simple to use one of our design goals
was for a single point of specification
right when it developer creates a new
configuration setting we want them to
tell us all about that setting what it's
called how it's used who can use it how
to tell if it's valid all of this
information is stored in the metadata
for a key which means that each key can
tell us everything we need to know about
how to manage that key metadata is the
basis for our configuration management
tools too because the metadata tells us
so much about the data we can use it to
automatically render a form element for
changing that data if we want to expose
a setting in a configuration management
screen we simply insert one line of
JavaScript and pass it an argument
that's the key for that data it goes to
the server gets the metadata renders the
form handles changes it doesn't matter
what kind of configuration management
tool it is either we can use that in our
internal tools or implementation tools
our client site administration tools
even like user profiles so right now the
main tool that our implementation
specialist and customer service team
uses is that big app with all of the
settings they designed their workflows
around that app that's backwards our
tools should be designed around their
tasks around their workflows so that's
what we're working towards so we built
this the stack that builds tools and
manages collections of tools each tool
is defined by a markdown file markdown
it's like a markup file but cleverly
named so each tool is defined by
markdown file and then where it is in
the source tree for the project
determines where it is in the navigation
including like symbolic links if you
wanted to show up the multiple places
and and then a static site generator we
use it's called metalsmith
turns those source files into a website
of custom-made configuration management
tools the site is built as a collection
of static files so deployment is simply
pushing it to the server metalsmith is a
JavaScript node functional pipelined
build tool the main loop is one long
filter chain operating on all of the
files in the source directory
recursively we start with the markdown
files in the first pass the filter a
filter rewrites those configuration keys
as JavaScript calls and then wraps them
in a form element and the next pass
filter converts the the markdown to HTML
and another pass a filter calculates the
the navigation for this site another
pass supplies applies the layouts
including calling you know all of the
static files for JavaScript and CSS and
whatever else our output for each step
of the filter of the build chain the
output from each filter is the input for
the next just pipelining and then when
it's done the resulting file is written
to the build directory about the time we
finished our design goals and we started
to write code we kind of got thrown for
a loop another team came to us and said
that they had a problem that wasn't
about configuration but they thought
maybe our configuration service my help
so our software's used worldwide it's
translated into I don't even know how
many languages and and each customer's
platform is is translated into the
languages they need for their employees
because they can customize all of the
language throughout the software anyway
that means that we have a default
translation to a bunch of the we have a
default english translation and then we
have default translations to a bunch of
different languages and then the
customers have they
default translations it sounds like the
same problem so we spent a couple of
hours reviewing what the translation
service needed and looking for gaps
between what they needed and what we
were already building and we couldn't
find any our design goals fit their
needs exactly so that was actually the
moment when I realized hey we're just
building a database so when we started
on this project I had one programmer
available to work on it and he's great
at Java but he had no functional
programming experience he did have an
interest that was nice so we did our
best in the first release of this system
which is the version we have in
production right now is not exactly as
I've described throughout we try to work
in a lean development way so we try to
get services into the hands of
developers as quickly as possible new
features into their hands as quickly as
possible and then learn what we did
wrong so our production version is
written in Java 18 and it uses one
process per book rather than one actor /
key and because of this a book is a
container for a set of keys and and we
can only compose data across books also
books maintain their own projections are
views and their own events tours and it
doesn't scale well so we we quickly
started identifying you know problems
with it that we expected to have might
be a bias thing too so our development
version our current development version
is as being written in Alex here and in
that one there's no difference between a
book and a key a book is just a key so
any key can be a book compositions can
happen at any level each key is an
erlang process maintains its own state
across time and includes the metadata
and either the data or a link to a child
node in each version
across time each key manages it's on a
vent store basically and manages
communication with it to synchronize
across the cluster and both versions
clients interact with the services uses
using messages sent to RabbitMQ so we
just hook into a RabbitMQ channel this
service also publishes changes to the
data to a message queue so that events
can be stored across multiple machines
in the cluster multiple clusters
distributed globally and coordinated
with with the data coordinators for
Oracle for our legacy code so that's it
that's the system and to and from the
functional data store with an immutable
time very end data to a pipeline static
site generator that builds the
management tools we're in the process
moving configurations onto the service
now and we're learning from our users
and their patterns of use we have
permission to open source the project
and we will after we prove that it works
yeah better than we have so far we
haven't really done anything novel we
just combined establish patterns in a
way that fit our problems we got some
surprising results from that two things
that we wouldn't have asked for if we
weren't already looking at the pattern
that offered it and like I said once we
knew we could get it we were sure we had
to have it we weren't letting go so so
that's how we ended up getting a lot of
cool things that we didn't even know
that we needed we also got a lot of
reduced complexity from doing it this
way the project's fixing problems with
how our configuration is managed that's
proven but we haven't done anything
about consistency problems within our
configurations so we've got this great
new tool for writing buggy
configurations that are impossible to
reason about so moving forward will
probably work in a way to make
declarative statements about
relationships between different
configure
raishin settings probably using like a
dependent type system but of course that
would be a different talk thanks we're
using a licks here so yeah and still I
guess referred to by Missoula turquoise
it is a conscious decision yeah yeah in
our team of 75 programmers we probably
have 40 of them working in Scala right
now but none of them are on my team
because I'm a rebel and I maverick and
and don't play well with others yes
sure yeah so each of these great out
versions are kind of like past versions
and they're stored in a hashmap so we
create a hash for the version and then
the custom or the the the client of the
configuration service can either specify
here oops yeah you can you can either
specify like just the the dotted key
notation and get the current version of
that lens into the book it's a version
of the node so from that point down the
value the state of that node and its
children across time there's a version
of a that was connected to be so you
have to go to that version of a to get
to be and then you can go from there to
any version of its children
I'm sorry there was a gentleman two rows
back yeah yeah we started off with just
json schema because it was present and
and easy but again we mostly have coded
to get the ideas out there and into the
hands of developers going forward I
fully expect that we'll be looking at
dependent types and not that I know
anything about dependent types but I'm
hoping to learn about them this week
here in the second row yes okay so
you're suggesting that I think you're
suggesting there because the event store
is going to save that that command
anyway or a map to that command that we
can see it from that we don't actually
have to create a state that's invalid
oh because we don't know that the users
on the other end of the line right
because for instance that user may be
using the legacy code to change
something in Oracle and I can't there's
no way for me to have a message bubble
up through oracle to the user to be
determined we think that the performance
is going to be fairly linear it
definitely has designed to to scale
horizontally so for instance in in the
node view we only populate the view when
somebody requests the key on that server
and then our routing algorithm that
we're working out still is going to try
to you know help maintain affinity for a
query to a server that already has that
key so it's kind of a natural charting
if it works we'll see so from that then
really it should distribute very well
over a cluster and we should get fairly
linear performance out of that we're
replicating the event store across the
cluster too so we had to work out like
how you do that if you're not actually
forming the whole tree until somebody
asked for it but we've got we've got a
algorithm working for that and as far as
the cap theorem goes I think it's going
to be tunable much like you'd see in
react in the back
my my thoughts on dependent types are
that I that might developer who's doing
a lot of the work on this right now and
is currently the project lead said rabbi
think we need dependent types while
you're in London you should learn
something and quite honestly I feel
relatively weak in both category theory
and type theory and dependent types I'm
very much looking forward to learning
more about so that I could talk with
Michael and understand them any other
questions I think we're probably about
at a time yes is it a problem somehow
yeah something like that yeah so um so
we persist event right now we persist
events nine states the states are
ephemeral they're just a view of the
current state of the data the event is
the canonical data store and that's just
pluggable so like right now we just
store it to a local hard drive on each
node but down the road we'll probably
try to get better conflict resolution
and such either by doing like crd tease
or maybe just writing them to Cassandra
I don't know we'll figure something out
we'll probably try a couple of different
things and it's definitely written in
such a way so that you know persistence
is a very thin wrapper so that handles
the persistence and then it's shared
across multiple nodes in a cluster
basically what happens there is like
let's say the e changes in in one tree
on one machine it will send a message to
rabbit that's picked up by the the top
know the root node on other machines and
then it passes it down to the last child
it has instantiated in the tree and it
stays there until somebody asks for it
so we take a performance hit on an
initial read so we're not going to be
good at records that have lots and lots
of events that make them up and all of
our initial reads kind of suck but we're
really fast after that and in terms of
like memory management we just kill the
nodes starting at the bottom of the tree
that have been least recently used and
then our routing table loses its
affinity for that server so then when
when somebody asks for that note again
which you know hasn't happened in a
while then is simply
to a server that's got capacity any
other questions it's noisy out there I
think they're calling us thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>