<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2015 - Martin Kristiansen - Efficient Architecting and Implementation of Systems | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2015 - Martin Kristiansen - Efficient Architecting and Implementation of Systems - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2015 - Martin Kristiansen - Efficient Architecting and Implementation of Systems</b></h2><h5 class="post__date">2015-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/HqTO3-IM6JU" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Martin Christensen I was born
and raised in socialist Denmark but I
live in LA now I have a yeah masters
from off university in computer science
and I'm an erlang engineer at tigertext
so any and all sort of spelling mistakes
I will blame on my Danish heritage and
then yeah but anything good in
scientific I'll sort of credit at the
University and yeah i work at tigertext
we make secure HIPAA compliance
messaging and a bunch of service and so
on top of that and my plane ticket tells
me that i should say that we're hiring
we are looking for any and all good
programmers especially people who like
functional programming so if people are
looking please come to us we're friendly
and we actually have sort of fun even
though even though the subject matter
that we're treating is sm a bit series
soup yeah my main objection when
building in Erlang is that i am not a
patient person i really really like the
fact that i can model think things
quickly and i can do that way fast or no
language i can in other languages that i
came from but but it still feels slow
right so so the motivation for what
we've done is to get to a point where we
can quickly build big scalable backends
and even quicker than then with normal
or lang so this is sort of a stab at
that and personally I have a sort of a
belief that people have a tendency to to
try to over optimize very early
especially bright people will have a
thin
c2 to look at what they're building and
make the assumption that they can do it
better than anyone else and hence not
use any languages and health hence
discover a lot of things on their own
which this might be a an example of but
but let's wait and see and then I found
that that you often run in to vary and I
say PHP like in the nicest possible way
cold in Erlang where people sort of took
am usually cowboy down from the shelf
and they started implementing handlers
and they never actually used the rest of
OTP they just sort of have this layer
that goes to a data store and gives back
results and which is nice if that's what
you want to be doing but often it's not
often there are a bunch of constraints
and race conditions that they just sort
of forget about um yeah um what are we
trying to solve and we're basically am
looking at does the thing that gotten
looking at applications and I'm trying
to do simple data modeling and and what
I mean by simple data modeling and and I
hope I don't in an offend anyone because
I actually heard the opening talk on
this tracking and then I would like to
be able to draw boxes and generate code
that would make me happy if I could draw
sort of UML but that's short for utopian
markup language right if I could draw
uml and generate code and then have
something that actually worked that
would make me happy I have not seen that
work anywhere and but but the closer I
can get to that point the closure i can
get to just sort of making statements
about the things and then having the
rest of it semi for free the happier i
would be um then i want to be able to do
large-scale rollouts
and by that I just mean not toy projects
and then I would like some fault
tolerance I would like my application to
have some of the features I like from
where lang um yeah so why do we want to
do data modeling and I would like and
again this is sort of this is perhaps a
bit controversial in this setting like
I'd like to have one source of truth for
my data I would like for any piece of
data to know and buy a piece of data I
mean something like often when people
build things is like an account I would
like to know what this account looks
like and I know that sort of goes
against the whole CRT way of thinking
and but I would like that because it
makes simple and makes it easier for me
to understand my application and I
actually think that in order to make a
semi reliable and not full of bugs
software I need to understand what's
going on so I sort of want to have
simple and building blocks and yeah and
that does mean that I would like to have
one path of mutating data and when I say
one path I mean one path for a
particular piece of data again an
example being a user account I want to
have that and live in one place and do
updates to its instead of one way um so
I like the data modeling to be OTP ish
because I like oh to be and and i really
like 10 servers again because they
actually do what I talk about they
should I encapsulate something and then
they work on that thing in a in a very
sort of a local way um yeah and they
give me transactions on my data and
seward it for free and and I want that I
want that from my project and that gives
me encapsulation of whatever
responsibility if I've got a gender
corresponding to a user account then
that Jen server is my source of truth
about what that
user account looks like that now yeah
and then i'd like to have sort of nice
definitions and generic database
mappings and just because i'm sort of
lazy and I don't want to write that all
the time and you end up or at least I
end up spending a lot of my time writing
database accessors and which is boring
when you've done it 20 times yeah and
then we want some fault tolerance
because critical applications just have
to have it and it's yeah it's not an
option to ignore it it's not an option
to just say one yeah how are we planning
on getting that sort of thing we're
going to be using the raft protocol to
ensure consensus on some shared states
or eventually and sentence um and yeah
that's how we're going to doing that and
yeah the fact that we have this nice
shared state means that we've still got
a more glue or global truth in our
system and yeah first principles and I'd
like what we're building and I haven't
even told you yet what it is but we'd
like it to feel like Oh TP this sort of
modeling tool for having things that
yeah that interact with data and we'd
like it to be simple and when I say
transparent I mean I'd like that if you
understood what the insurer was then
you'd all also understand what this is
it wouldn't sort of require you to know
a lot more and and then I'd like it to
be easy to debug yeah so now those sort
of the goals and the motivation and so
we created something called industry um
yeah and when I presented this last I
was told there was a negative
conversation to the word industry and I
said it's called industry because it's
full of factories and then someone said
negative connotation on that word but
I'm guessing that's not the case here
yeah so what is industries let's talk
about what a denture is Jim server is a
pit that carries some state and you can
do Cal calls and casts
that's what you do you've got these pits
they're talking to each other than
sending each other messages that's all
fine and again it's easy to understand
it's easy to model and what would we
like we like something that looks like
it except I don't really like talking
about pits I like talk about some kind
of digest go backwards some kind of
global ID I like talking about account
identifier I like talking about yeah
again for pretty much anything I like
talking about the ID that that
represents it's not the random period it
was assigned I would also like to have
this sort of fact by data right I like
for this thing to be maintaining a copy
of itself so that in case of crashes I
would like big crashes I would be better
off than if my airline we m machine
should have the Amazon caught fire right
um yeah and and the example again is
this sort of user account that carries
some state and I want that state to be
persistent to a data store and I want
that to be somewhat transparent and I
want to address it by yeah by the ID and
not by the pit is living on and so how
do i get there again i want to be doing
some kind of call i want to be i know
there's a ginger behind it with a pit
that's fine i want to be able to persist
to to restore it and i introduce these
factories and hence the name industries
and what are these factories to their
sort of the they're the they're the
magic right there in charge of making
sure I've got a way to do these look ups
from IDs to pay its they're in charge of
making sure these things are actually
alive and and and and then available so
yeah they're sort of a it's a factory
pattern with some extra stuff sprinkled
on it and well they're in charge of this
and then we can of course add more sort
of optimizations if we want to be able
to access the state inside the gin sugar
so how do we do that first of all we
need to pick a data store to have this
data persisted too and now there's sort
of a twisted argument that I never
actually get right so please yeah ask if
it's nonsense when you have a dense
server and you have a state change and
you want to persist that state change so
you're doing rights out to your data
store and you're doing them often right
the next time you're never actually
reading anything because you're assuming
that your state is right and which means
that you're you're very very right heavy
and you're not really sort of doing any
reads unless there's a catastrophe and
which means that the fact that Cassandra
likes rights and hates reads makes it
your best friend right um because you
can just push off all these updates to
your to your running game server and
cassandra is fine and it's fast and it's
yeah it's good um yeah so that's why we
chose Cassandra and then the next point
is well how does this scale beyond one
sort of machine right how do we have
this table in place and and the answer
that we chose is to basically have a
raft cluster that this attaches to so
that the rat cluster can carry shared
information about how to do this mapping
and the factories on the individual
boxes can sort of course talk to the the
raft cluster yeah and there's already a
nice implementation fly by andrew stone
and the dust is and when you look at
that the first thing it says on that
page is not production ready and I beg
to differ it has flaws but but they're
fixable so yeah you can get a nice raft
flutter with leader elections building
with a commit lock that has I think
unintended features but it's yeah it's
good and so you can actually get that
I'm
starcraft raft is about leader elections
and distributed states and it's based on
time outs so basically the way it works
is that it you you select a leader and
that leader then pings the rest of the
cluster and when the rest of the cluster
haven't heard from the leader in a while
they started initiating new elections
and yeah it's it's it's amazingly easy
to think you understand then go back try
to implement and realize that there
might have been a few details you had to
think some more about and but it's nice
and simple program and then there is a
shared state which is basically this
commit lock and here there are leader
elections yeah so okay we've got that
that seems sort of bordering on trivial
right we got this factory we've had
these instantiations of whatever we had
in the data store we were able to
persist to the data store and so what we
need we need to look at that right we
need to look at that conversion from our
state to our latest or we need to look
at the actual states and we need to look
at the data store those errors did not
match what would be a simple way of
doing that we could define a simple
domain-specific language to just
describe the state and then we could
write a translator and yeah be done with
it yeah so so then the question is what
are these things that are in the states
and and we call them entities right in
it's basically a description of the
thing right what is the thing and
comprise off so yeah a bag of attributes
and yeah it's basically a collection
it's a state it's like a gem server
state except we can't really use the N
server States because I'm we back we
want to know something about types that
Erlang doesn't like giving us because
because Erlang was born without types
and then someone added them right which
made it something else so we have to we
have to sort of come up with something
something real right we have to sort of
say we've got these we've got these
fields but we've also got types right so
we have to or at least I believe and
have to create our own types so we did
this is sort of an example right we've
we've got a we've got a bunch of
attribute ID name email primary meal
we've got a bunch of types on it right
um and we define such a grandma got
quite small which is basically we
introduced a bunch of types we
introduced a behavior for these sort of
workers that were the things that
carries state that were Jen service
before but now something else and then
we said sure let's start building these
things right and so this is what a
schema for a basically for the state of
one of these workers looks like right
it's the example from four and if the
example our demo in a second so we
basically say there are some attributes
and there are some options and the
options are basically callbacks when
things happen and then there are
timeouts which means if I haven't been
touched for a while I can probably sort
of kill that Jen server and take it back
later and and yeah if you if you notice
we should have got complex things which
is we've got an ID a name and last name
and then we've had these in this case
this is an account we've got these basic
auth keys right which is a set of
references to other to another module it
looks like this which again has some
attribution callbacks and and has a
reference back to that and demo accounts
um yeah
and turning these these schemas into
queries becomes quite simple this really
got small um yeah basically we were able
to create nice tables from that
description and that is quite simple
it's just it becomes just figuring out
what the reference is actually reduced
to in the case of an account it means
going to the account and seeing what the
idea is and just building first like
that um yeah and we need to yeah render
types and things but it's it's pretty
pretty trivial that the more interesting
part is things like how do we create
these things right if I want to create a
new account for instance what do i do
well I have to sort of ask the factory
to create it which means go create an ID
and then spawn a process and then
actually set it in this edge table so
that someone else can look it up
afterwards and then doing a call is sort
of even more cryptic right because that
means looking in the edge table if I
can't find it then go to the factory ask
the factory then the factory has to sort
of figure out if it's actually able to
load it if it can load it put it in the
edge table and we can try again and it
becomes sort of interesting but luckily
we can hide all of that right because if
we've got this in place then we're able
to and basically do calls as if
everything's addressable by an ID and
not by this and and it does make it
nicer and easier to talk about things um
yeah so so doing a call would look
something like this we've got a caller
and he actually asked the s table
figures out that there's nothing there
then ask the factory and the factory
instantiates the worker and make sure
the workers in the s table and the
caller gets returned that you have to
try again because we trust the edge
table and then the caller goes to the
edge table yeah so now I've got a coat
demo
which is an interesting thing if I
maximize this will the world and loop um
soup this is our demo and of how to use
this at first there's some setup for
making actual database connections but
down here the internet is that right um
yeah up there we go to walk throughs I'm
sorry about them and noise um we
basically go to the two modules get the
schemas then we append them and then we
throw them at this industry's add
factory which from schemas generates
factories and then we can ask the
factory to create an account which
basically means giving it a provost and
saying I would like one of these demo
accounts then we print the states then
we sleep for three seconds the only
reason we sleep for three seconds is
because we have a one civic second time
out and we want to show that this thing
falls out of memory then we actually go
get the API keys of this account because
an account gets created with an API key
and then we check if the passwords if
the password is top secret which is
which it is by default and and if we
look at the account code and we're
implementing this behavior that we saw
before and we have two calls we've got
get api keys we've had print state and
we've got our schema from before and
down here we see the time out of a
second and and then yet we basically
have two callbacks and then we've got
sort of our known calls and casts from
the gin server down here and they have
the same shape conformance we're used to
and then i'm using laga comments like
crazy to be able to print things so that
it becomes pretty for you guys
and um yeah and we've got the same for
our basic off keys these api keys we've
got the schema and then we've got a
couple of sort of trivial and methods
are one of them being this validate call
actually checks if the if the password
was correct and then let's try and call
this thing and if we go to I'm sorry
industries sauce oh um demo it's not
even the right thing we start up for
parole yeah this one I have a small
mistake right because I have actually
started this up in another window that I
can't get to UM in here let's just kill
that let's move to that one sorry about
that um
yes and now I can start the server and i
can give you something that's actually
reviewable um like it's a demo go and
and we did what we sort of said we would
do to do and and we can see that we
started out creating some tables and in
Cassandra because we did that
automatically from the spec just out of
ya created some tables we then created
some instances of these accounts and we
created workers for them we inserted the
data in Cassandra we printed the states
we then shut down because we were
waiting for three seconds we shut down
the workers and we tried to do something
to the first worker again which meant we
did a select and loaded in for memory
and we printed out looks fine and and
then we went on to do the same thing to
the API key to check that it was the
right API key and so that means that we
were able to interact with it if we look
at the if we look at American we were
able to interact with it as if as if it
was a normal gem server except we've got
all these rappers right but but we were
able to do calls to it as a TV at James
River which was nice and meant that we
did not have to think about persisting
it to the data store and we did not have
to think about sort of yeah all that
look up stuff because the library the
industry's library took care of that and
so do you do I have somehow gotten my
mouse lost yeah um
there's the coat demo and then um things
that are missing right we don't have the
raft stuff in place yet but it's coming
we want to sort of support fully nested
structures and by that I mean wide rows
in Cassandra or nested things like I had
a list of API key references I would
like to have a list of API key objects
instead and that is most of these things
a trivial in the sense that they're not
hard they just take time and and we
haven't spent the time yet um yeah and
then we'd like to have dynamic expansion
of the tables as we go as the entities
grow and by that i mean if i change the
schema i would like to automatically
update the data store definition behind
me so that i could so that adding a
field two estates and having that
persisted in data and having all the
loading and saving and became like a
no-op um and again simple but haven't
been done yet um yeah and having white
rose and then the fact that we have all
this living inside of a gin server means
that it would also enable us to do a lot
more so the lazy loading if we had a big
set nested inside a gin server we
wouldn't have to load it until it was
addressed and the fact that we have our
own function for getting it out of the
state means that we don't even have to
sort of have the user think about that
we could just know if it's in state yet
and we could load it and as we go which
again makes optimizing global and not
local to whatever you're looking at and
so once we've got that and one thing
we'd have it across the board and
everyone would be happier um yeah and
then this was actually something I added
20 minutes ago which was when I realized
that even though we had a very specific
use case for this and what we've done
and is sort of the
just a persistence layer on Jen servers
which was not what we set out to do but
actually what we ended up doing and so
any OGP structure that carries state we
could do something like this to write
because what we've done is we've
implemented an algorithm for figuring
out the smallest Delta we had to send to
the data store when we did updates to
the states and that generalizes to most
of these things right so so we could
persist everything if we wanted to
there's of course sort of a.m. do you
want to persist the entire state of your
running system probably don't and but
you definitely do in some places right
there are things that carry a value and
where you want to persist them to
another storage and yeah and persisting
our data in audience servers to
Cassandra means that um means that you
inherit that start with all the good
from Cassandra right you inherent the
fact that you now have if you do sort of
coral reefs and rice then Cassandra is
promising you consistency I think you
said it then you're then you're happy
and then you can make claims about your
system right which i think is when I
took the the functional programming
class at University and we were asked
how to implement recursion and the
answer was of course a jutsu recursive
target language because then simple and
you're done that you just translate to
that and fine and this is sort of the
same if you're leveraging Cassandra's
and features then then you happen right
um the current limitations of raft and
is that the current implementation
allows you to only do reads and writes
because of the whole commit log through
the leader which means that you
basically got this one big bottleneck of
a gem store a living somewhere in your
cluster and that's like it makes sense
for the rights and but I don't think I
care as much about the reach right so
and if I got a persistent but not enough
and not entirely up-to-date copy of
whatever table I'm doing look up did
lookups in on the box some sort of
running on and I don't think I care and
because if I have to check a couple of
places to make sure
I can find the right one and I'm I'm
happy um no and the fsm implementation
of rafter does not have a nice way of
figuring out if you are in the cluster
which means that you have to be a bit
hacky to em to figure that out and but
again it's it's solvable and the
upgrading of tables um yeah I think I
said that already but we basically want
to be able to to do a diff of the
definition that's in the data store with
the one we'd like to have there and
either sort of generate a file that you
can run or just do it automatically
probably generate a file that you can
run for expansions but not for
destructions right and so that you don't
go dropping tables um and it's pretty
simple but haven't been done it um and
then we'd like these nested structures
and this example might be a bit sort of
yeah but yeah currently all we have is
these lists and sets right which means
that we're basically storing references
like crazy to to get this and it also
means that we have a lot of live objects
so what we want to get to is we want to
get to a point where instead of having
references we can nest entire objects
and again Cassandra totally does that
we've got wide rows you can put things
there and but we haven't done it yet um
and it's yeah that's that's not as
trivial as the rest of it that's okay um
so basically ending up in a place where
we're a full list of nested structures
can live inside an object um yeah and
that's the same stuff basically saying
that we have DCM yeah
and it's available there soon um right
now it's it's it's got a bit of what do
you say a bit of Tiger take specific
code in it that needs to go but after
that it's should be available for
download and criticism and hopefully
constructive but yes criticism yeah and
and i think that was its questions yes
so I did not look at the park but I got
the same question last week and then I
looked at epoch and sameer the factory
fog is more about sort of pops up set up
and but i might be wrong and I did not
look at epoch before doing this but I
can see how some of the like basically
the hook-up mechanism right and it's the
thing that you'd replace so I think you
probably replace you will be testable
you are
I think I don't know about you yes I
think you would replace each a stable
are you talking about yeah I need to so
that's a parent right because if if
you've got to look up table and so if
you might be right at the local civil
way you are the key to any other process
yeah just whatever passes Yuki you could
always just will require a new property
possess dictionaries is I think I caught
one or something so that's like the
first question I'm the second plane is I
like a boot track this against every
rule cause it seems like if you have
like a billion records new Cassandra TV
you might have a processor Vivian
processes and the other things in your
old in states like don't you like a
beaut tried like trim your intestine I'm
seeing oh that's one should you consider
by use no more your memory wait without
like that works Cassandra yes so some
bunch of questions by some the memory
question
if so spinning up processes is not our
difficult our solution might be very
local to our problem space but memory
has not been a problem for us and we run
yeah millions of users but that might
come from the fact that we are at timing
things that are idle out and we don't
have millions of up sort of active right
now users right um so the fact that we
have timeouts and that we pull these
things that we kill the denture which
basically means that our memory
footprint is small but if we had sort of
spikes in traffic then yes then then
that would definitely be a concern yes
yes
so the current implementation do you
think about complex things i do you
think about listing sets right so if you
do an update to a set that's in memory
then I'll calculate the diff and and do
that update to Cassandra alright so i
won't be trying to persist i won't take
this giant thing and so this Chevy like
Cassandra I'll say I know this late
before I know the state after I know
what you did up mutations and I'll throw
that at the center right which which
means that you are sort of push them
some of the heavy lifting to Sandra yeah
yeah and you're not fat you're not
typing a lot of data or not as much as
you could
oh so if I understand your question
correctly then I was not good at
explaining what I wanted to do and so
the whole point of this was that a data
structure is owned by one process in one
process of them which means that only
one guy is trying to do updates that
sort of the invariant right so no two
guys are trying to do updates to the
same piece of data at the same time that
is that is sort of the theater right yes
yes
they're doing that they're doing the
operation in sort of the gen service
process space right so they're not
fetching it doing updating saving it
again they're sending it yes sending
like an ad and having that run in the
fastest pace right yeah because the
other thing would be sort of horrible
yes so problems like welcome 20 push-ups
why the process crashes in between when
you have backup things into is Q like
what are you doing the Constitution when
it when it's cut things in the sky since
you fired optic resident process and the
process acknowledges it like it was a
cartoon accurate I immediately and the
person will send a message like you my
right to like a movie problem where you
send a message to to to the process and
it was a document that its object at
least important is backed up in eq
because yeah he asked things luckily
have implied like 20 of these messages
are things and as we need beeping and
things like that in between yahoo crash
what happens so we would correspond to a
normal like it so basically it's just
slower right it would correspond to a
normal gem server crashing while
processing because this this guy does
not get to proceed on its mailbox until
it's done with one cycle so the cycle is
just heavy right so if if i'm doing one
operation then once i'm done with that
then that one operation is persistent
right so we're just sort of it's the
same problem as without it's just slower
right that make sense
oh yes
I don't see any hand
then I think we're done</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>