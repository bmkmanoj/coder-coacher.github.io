<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2015 - Edwin Brady - State, Side-effects and Communication in Idris | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2015 - Edwin Brady - State, Side-effects and Communication in Idris - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2015 - Edwin Brady - State, Side-effects and Communication in Idris</b></h2><h5 class="post__date">2015-03-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kpPyolN65s0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay thank you very much um so can y'all
hear me okay is this thing on
yes good brilliant so it's going to be
here I've never been to cracker before
to the beautiful city
i I've come here from Scotland and you
might know that Scotland has quite a
heritage of functional programming so so
ml the programming language developed by
Robin Milne at the University of
Edinburgh so many descendants Oh camel
standard ml F sharp we're hearing a lot
about Haskell obviously the the the
principal compiler the Glasgow Haskell
compiler developed in Glasgow and I was
I was pleased to see wandering around
Glasgow the other day that the Scottish
flag has now changed we now have we now
have a flag that's that properly
represents the history of Scotland this
this important part of Scottish history
anyway I'm from oh I'm I I work in st.
Andrews which is in theis just a little
north of Edinburgh and you might notice
these days when you go and visit
somewhere you you you have a machine
that's maybe a touchscreen display that
tells you about the area and we have one
of these in st. Andrews bus station so
you come and say man these bus station
and you see this touchscreen display and
oh well so five has crashed so so you
decide so you turn around you look at
the display of bus times to find out
where you can go and this is what you
see it's a little unfortunate so the air
about you you want bill to read this
error but the problem is there isn't a
keyboard plugged in so this this
machines but they're working for an
engineer to plug a keyboard in to sort
it out
so this sort of thing we're kind of used
to this you see this sort of thing all
the time that machines that are out in
public of crash and really all you have
to do is turn them off and on again and
everything is fine not every computer
crash is quite so photogenic sometimes
sometimes you get a computer crash or a
software failure where you have to get
the marketing department involved just
to get a good picture of what the what
the area is so this you know I remember
this one the heartbleed bug so this is a
more serious kind of software failure
well let's not go to the details of what
it is but it's it's it's the kind of
thing that we encounter or know over and
over again sometimes if your software is
infrastructure where you're you're
you're worrying about users privacy the
data is being transmitted over a network
and might be interfered with you really
need to think carefully about how that
software is going to run without
crashing we kind of shrug when we get a
you know your your your software files
on your desktop okay you turn it off and
on again but what happens if your
software is really crucial to the
privacy and security of all of your
users so my my attempts or my
contribution to this space of solving
this problem it's well my claim is that
the more we can the more we can get
machines themselves to statically verify
static a guarantee what our software is
going to do the better that is for
everyone so the more we can we can be
precise about what the software is going
to be and more we can get the the more
we can get the machine to check the more
confident we will be that our software
is actually doing what we think it's
supposed to do now what I want to get
across in this talk I don't really
expect I'm going to tell you about the
Idris programming language I describe it
these days as a pacman complete
programming language because tiering
completeness is one thing but so many
things are tearing complete you know C++
templates for tearing completes the game
of life is tearing company-wide space is
tearing completes all of these things
are tearing complete but you can't
really do anything you can't write a
whole practical system in them so I talk
this is a far more interesting property
that you can you can write libraries
that interact with other parts of the
system and so on so yes addresses a
pacman complete functional programming
language with dependent types okay I
don't really expect by the end of this
that you all go off and chuck away all
of your software that you have in your
aura and your companies and start
developing using interests but what I do
hope to get across is an impression of
what type systems can do that you
previously didn't realize they could do
so people often I often hear people say
things like types don't do this or types
can't do that and that really is to me
when I hear that part of me thinks okay
challenge accepted let's see how we get
types to do that and I'm hopefully
something of what I'm going to talk
about today we'll get across one of
those challenges
that that I've tried to do them tried to
deal it so I'm going to talk about side
effects in particular station systems
side affecting systems and eventually
I'll talk about how you might implement
communication protocols the like of
which you would typically see in for
example Erlang programs or scholar
programs with actors that kind of thing
in particular there's anyone accounted
uniqueness types before so yeah a few of
you so if you programmed in the clean
programming language you might have
encountered unique list types well you
might have counted linear types yeah
anyone accounted linear types so it's
similar kind of thing the idea of that
is that once you've once you've used a
value you can never use it again so what
I this this is this is a completely new
thing I'm talking about today is
addition of uniqueness types into idris
to help us reason about how states
change across the running of a program
and making sure that we can't use things
that are already you know values that
are already somehow spent so i'm gonna
in particular talk about that but before
I get into this I should show you just a
little bit about sort of workflow how
programming and it just works all the
programs I'm not going to just show you
a load of slides with interest programs
on them I really want to show you the
system up and running and all of these
things you can download later and so
it's all on github and you can you can
play with it yourselves the flip side of
that is we are going to see you know
this is version Northpoint 916 get
version so there will be a couple of
bugs so because I'm using the real code
I can't hide so I'll point that out one
you know when these things happen okay
so is this legible is this big enough
some people said no are we okay it's no
did someone say no I don't think
move move move closer it's if it's to it
it's if I make it much bigger than it
goes off the end of the screen in it sir
um okay so this is some it's kind of
everyone's favorite first example of a
dependently type program a lot of you
might have seen this before and are now
groaning because you've seen it a
million times the reason we always use
this is it actually has a lot of useful
characteristics that you see over and
over again in real programs as well
as being a kind of easy to understand
what's going on when you when you've
never seen it before so what's going on
here is I'm defining a data type of
Lists parametrized by their lengths so
effect vector ten int is a vector
containing exactly ten integers for
example so if I write a function from
vector n instead active Emmons and it
returns a vector n plus M int
chances are of implemented the append
function so this gives us more idea by
looking at the type of what a program is
actually supposed to do so this is an
example I'll take you through the
workflow of writing a this zip width
function so the zip wave function if you
haven't encountered it before it's a
function that has a list of things and
another list of things of a different
type and it zips them together much like
a zip on your coat with a function
gluing the things together as you go up
that's why it's called a zip width and
it will give us a new value of this
third type back so what we do is we put
types up front so this is kind of type
driven development it's kind of
unfortunate that that's the abbreviation
TDD but this is what we're doing we're
doing type different development we
write the types first and from the types
we can't derive a program that does the
thing that we we already knew we wanted
it to do and because the address type
system knows about types and knows what
constructors are available we've got
some interactive features in the text
editor so this is just a bin with a with
a plugin that the calls into idris to
say what program should go here similar
thing worked in Emacs if you're the max
religion but I'm gonna be using vim just
to show you how the vim editing works so
what I'll do is I'll hit backslash d
here and what it will do is it will give
me a kind of skeleton definition of what
this function should be so I've got a
function that take my zip with function
takes a function f a vector X is a
vector wise and it returns something so
this whole thing here is a type correct
program at this point I have this this
query v zip with RHS that's that's a
legal expression what the type checker
does when it sees that is it is it it
invents a definition that would fill
this in it event a type for the
pression that would fill this in and
that means I can inspect it and inspect
its context so I can do backslash T here
and it will tell me what's available to
me so I've got I've got some types I've
got a function I've got a couple of
exits so what I'm going to do is case
analysis on axis and case analysis on
Y's and see see how to build this
function so I'll do case analysis on
axis and it gives me two possibilities
so if I look on the right here no it's
now you see that it's we find the type
slightly so so the type of why's it now
knows that Y is a vector of zero things
there's got to be zero things in in Y's
so if I do case analysis on wise it only
gives me one choice because it can only
be if it's if it's an effort of vector
of zero things it can only be the empty
vector and then on the right hand side
there's a shortcut backlash oh where oh
stands for obvious that gives me the
obvious answer so same thing same thing
here so it can only be it can only be
the vector with something in it so if I
look on the if I look on the right-hand
side I've got a function I've got a
vector of K things I've got another
vector of K things but I think they're
different things and I need a vector of
successor of K sees so again what
happens if I say give me the obvious
program gives me the obvious program so
I've given type precisely and the
machine has essentially guided me
through the definition of that program
now this is where people tend to stop on
this introductory example but the thing
is when when people fill in your you
know you've got a form on your website
where you enter a list of things and
maybe you've got another form where you
enter another list of things users are
not generally very cooperative about
providing input that makes sense so this
this this function here tries if with
we've got um we've got a vector of N
Things and whether my calculators we've
got a vector of N Things and a vector of
M things and what we're going to do is
if N and M happen to be the same we're
going to invoke these if with and if
they're not we'll return some indication
of failure so they're to the beginning
we'll do the same thing so backslash
teen what we need to do
it's only run visa pwith if N and M
happened to be the same so I'll just do
this quickly
just to give you a picture of what you
might do so what we have to do is bring
the lengths into scope and then we can
say we can we can add we can add extra
arguments when we're pattern matching
and those extra arguments could tell us
things like proofs can calculate proofs
two things are equal or unequal we have
a function called deck eke which is not
only calculate whether n equals M but if
they are equal we turn the proof that
they're equal and that proof is
something that we can then use to do
further computation so we vent we've now
got this world where you don't return
billions anymore billions are almost a
code smell in a dependently type program
because well just if I tell you that the
answer to a question is yes what was the
question was if I tell you that the
answer the question is yes because I
looked at the arguments and they happen
to be the same throughout then you have
some idea of what the question might be
so this deck e gives us the result of
this is going to be whether the things
were equal and if so proof so oops if I
do backslash see here you'll say in the
case of yes there is a proof that they
were equal so let's just do that again
let's inspect the proof there is only
one proof of equality and because the
two things because we have a proof of
equality and the two things are
definitely equal we'll see that it's
it's it's changed the expression on the
left hand side to say N equals n and now
we're at a point where if I look at the
type of if I look at the types here I
have X's has N Things wise has N Things
I need may be effective and things so
now it's okay to call zip quiz I've now
explicitly checked that they're the same
there's a kind of pattern that you'll
see is you you'll write a function that
just works under assumptions basically
we've made our assumptions explicit this
is the crucial thing about everything
you're gonna see is that if you make an
assumption about what your program is
doing write it down make it explicit and
your do you you make assumptions about
your programs all the time I certainly
do I mean I when I'm writing a Haskell
program
interest as a Haskell program for
example it's implemented in Haskell I
will I will have fragments of that
program where I know that a vector is
going to be or list is going to be
non-empty because of it because of
another thing I called beforehand but I
don't have any easy way in Haskell of
explicitly saying so so of course what I
do is I write the comments assumption
this vector is this vector is never
empty and then about 6 months later I
violate that assumption I forget about
this comment the compiler doesn't know
about the comment I get a runtime crash
so what we're trying to do here is when
we have an assumption write it down and
then any time we invoke that assumption
the machine is going to check whether
we've satisfactorily used it ok so
that's all very well that's that's just
a pure function that's taking a couple
of lists and doing something with them
slightly more realistic situation is if
you have a state machine so a lot of
software that you work with has at some
level a state machine underneath like
opening a file reading it closing it
you've got a state machine where the
file is in some state closed open for
reading closed again well you might have
a network communication protocol like
you remember go to fail because whoever
goes you fail there's something of a
protocol going on there where you check
at each stage that it's ok to move into
the next state and if it's not you go to
fail and if you have some violation of
that progression of states which of
course as we all know they did then bad
things happen so this other thing just
naturally exists in any realistic
program on a realistic API so the kind
of thing we might do in in a dependently
type language is again make that state
make those assumptions that we're making
about the state's explicit so this
little example is a state machine for a
door a door is in one of two states
it's either open or closed if it's
closed we're allowed to knock on it
we're also allowed to open it and if we
open it it goes into the open state in
the open state we're not allowed to
knock on it I'm sort of imagining it's
one of those sliding doors whether
there's always someone picky because
your programmers and therefore pedantic
by by training so yes there's no way of
knocking on an open door in this system
but you can close it and well let's
let's try capturing that using this sort
of idea of making assumptions explicit
in in the types and what did I call it I
called it door zero because it's my
first attempt and it's not going to work
properly so this is this is how I've got
a badge here so door state is either
open or closed and then I have a I guess
if you call this a door handle and I've
defined three commands on this door I
have the open command the knock command
in the close command and it's
parameterize over the state because I
parameterised the door handle over the
state it's in then opening a door will
take a closed door and give us back an
open door knocking on the door will take
a closed door and do nothing with it and
closing your door will take an open door
and give us back a closed door okay the
reason I define these by commands by the
way rather than by top-level functions
is it's quite handy to be able to
implement the commands in different ways
in different contexts so it's like a
generic approach to programming
separating the algebraic description of
the effects from the effects themselves
so in the case of a door for example you
might have you know a door simulator
running on a running on a computer just
showing you what would happen or you
might implement it as a robot arm opens
the door or you might implement it as
mechanical sensors that open the door
here we're just talking about the states
we're going to write programs that
describe the states and eventually we
might have something that runs that
program anyway down the bottom here I
have a valid use of this door protocol
so we knock we open we close and we're
done so question does anyone see a
problem with this
I like I like questions in the forum
what happens if by the way because sorry
knock the open door so I would have to
knock oh I'm in the wrong place
H
Connie if I'd opened all the clothes
we've got something out of this
we've tried knocking on an open door and
it didn't work so this is somehow it's
it's a it's a lightweight way of giving
us more type safety than we previously
had so what I was wondering if anyone
would spot what happens so if I try
closing a door twice then I get the same
problem but what if I try closing the
door and just happening to call the
handle something else I've closed the
same door twice and it's okay it's happy
with it so we've got something but we'd
like to go a bit further and we saw
we're still programming in this you know
purely functional style which is nice
well so what I've introduced recently is
taking this idea of uniqueness types
from clean and basically taking their
typing rules because they've they've
been thinking this through for a long
time and if someone's been thinking
something through for a long time I
think it's a very good idea to steal
their ideas rather than try to work it
out for yourself
so I stole their idea and I implemented
it in a dress using pretty much directly
the same rules now what I have here is
that if this is the same program but
you'll see up here that I've said that a
door handle is a unique type and the
rules are anything I mean intuitively I
won't go into the details of the rules
but intuitively anything any any
anything that is have kind unique type
if if it's referred to more than once
you will get an error that says sorry
you used it more than once so down here
it says so this is one of those little
bugs I was talking about it's a it
actually reports the internal name
rather than the name that you use but it
says that the unique name is used more
than once so so you can't do that and
well I can fix that by well basically
not doing that and then we're okay
so there's another problem here because
obviously it can't be this easy I think
this is a reasonably straightforward way
of writing down the item i hope
hopefully readable even if you haven't
seen this style of program before to say
well we're doing these three actions in
the right order and then everything is
okay with the handle but not only do
programmers provide or users provides
invalid input data things in the real
world go wrong too like for example this
door
it might not open when we try to open it
it might it might jump and so this this
action of opening the door might not
work and if it doesn't work what we do
with with the state machine to to deal
with that properly so I have it's
another yet another door protocol
implementation looks a bit like this so
I've defined here a this type here this
is a result type so the result of an
operation this this type star you see by
the way this just means that either a
type or a unique type can go there and
the rules for a type star are just
conservative in that the system will
make the assumption that it's
instantiated by a unique type so you can
only the type start once but you can
feed in an ordinary time so you can you
can still write to some extent
reasonably generic polymorphic programs
over these things now what happened what
I've got here with this this result type
is it's a you'll see like all the ass in
a moment Oh in a little while
so we have a value and this next thing K
eval so this second thing what that
second thing is the type of the second
thing is computed from the value of the
first thing so this is one of the key
things you get with dependent types this
types of first-class quite fully
first-class so when you explain or
certainly when I explain functional
programming in Haskell to to beginners I
so know the difference where the thing
about functional programming is that
functions are completely first-class you
can manipulate them just like anything
else well this is just the next step
along
types are completely first-class we can
we can calculate types just like
anything else we're kind of calculating
this at runtime to we're waiting to see
what turns up and then we know what its
type is
so now what the door what the open door
command returns is a boolean code smell
I should have I should have caught that
something like it jammed okay or jammed
right it's a boolean and then the result
is going to be well we'll look at that
boolean so if it's okay if it so if this
if this boolean is true then we have an
open door and if it's false then we have
a closed door so what we can only find
out at that out at runtime at compile
time we can state what the options are
and have the type system to lead us
through dealing with the possible cases
but at runtime will actually find out
what it is so what does the program look
like in the end
just leave my crib sheet off the bottom
of the screen there so I have a program
here that takes a closed-door and then
run something in this door protocol and
this this handle okay in fact I'll show
you what happens with this handle okay
is so the type of okay can you see this
thing at the bottom is that okay the
back so the type of okay it says well I
don't actually know what it is I don't
know what state it's in it's it's some
it's in it's in some states but you're
going to have to look at what okay is to
find out what they to tip so let's do
that so I'll just do the same thing
again this is it by the way this is
quite a handy development and debugging
technique just to write half-finished
programs and let the Machine tell you
what's expected at each point so if I
look at the type now it's also very
helpful yes so if I look if I get it to
evaluate the type of this it says that
I've got an open door so I can now work
with it like it's open yeah the question
in the back
oh I could do that yeah that's I mean
there's all kinds of things I could have
done here but the thing is you could go
you can go quite a lot further with
these things so here I have two options
there might be a lot more than two
options
in fact I have an example coming up
shortly where I have three options that
I do various other things so it's you
can be completely flexible here I could
I could have returned I could have
returned in either I could have returned
something more expressive but right so
let's put that back together one other
thing that I should point out is that
sometimes these things could get deeply
nested and if these things get deeply
nested then it kind of starts getting
ugly so what I did was I I looked to
that most inspiring of programming
languages pearls and and I discovered
this you know the open something or die
idiom that you've got in Perl well
that's what that's what's going on here
I've got the we make the we bind the
result of opening the door as if it
works and then this is the or die case
so the real valid so this this program
that you see is exactly the same I mean
it elaborates in an identical
it's basically syntax syntactic sugar
for what we had before and this thing on
that this this all case is you still
have to finish the protocol on the
assumption that the door didn't open but
you don't have to have this noise of the
deeply nested case so I could you know
imagine how deeply nested it would be if
I did if I opened and closed open and
close and open and closed so um
type checks didn't then wide I'm not
going to go and debug it right now so oh
because I didn't didn't find the action
so this is this is sort of how we deal
with exception so when you have a when
you have state machines where the the
exception might happen with the machine
in a in a particular state you can't
really throw an exception and expect to
deal with it because you basically don't
know what state it was in when it threw
that exception so this is a kind of
halfway house notation of
of how we might fix that problem I want
to fix this no but I probably better not
coming at a time just one final thing is
there's nothing here it's a guarantee
that we complete a protocol so we could
open the door and then that could be it
we could just forget about it but in in
reality you might want to make sure that
a protocol runs from start to finish and
you really do end up at the final state
of the protocol so this is a slightly
amended thing where I've explicitly said
in the type here that I'm going to
return a closed door handle at the end
and well assuming assuming I've cared or
HM tracks the only way I'm ever going to
be able to return a closed door at the
end is if I return either the one I
started with without doing anything or
if I properly complete the protocol okay
so that's that's your basic writing down
protocols implementing them and making
sure they work so what sort of situation
where might this might this be useful
because I'm sure that you know no one
was there expecting a million dollar
contracts the door opening in the next
little while but we might be interested
in writing communicating systems or
concurrent systems I think about the
concurrent system is what's happening
you're sending and receiving messages
the message you send at each point or
the message do you expect to receive at
each point is going to depend on the
point of the protocol that you that
you've got to so what I've got here is a
language of protocol actions so I'll
just take you through this quickly you
can you can largely let the either the
let this wash over you just try to get a
picture of what's going on but I'm
saying that a communication at each
point is going to have a number of
things that are valid operations to it
so one thing it might do is the next
thing it might be allowed to do is send
something so send it to some destination
participants so if this P is just you
can think of this P is a label for a
participant in a protocol so we'll send
something of type packet and then the
rest of the protocol takes that packet
so not the type but the actual packet
that really does turn up at runtime and
then it calculates the rest of the
protocol from the value that I sent over
the wire
so this is quite handy if you're sending
like you maybe send the command to a
server and then the rest that the values
you sent to the server will vary
depending on what that command was so we
can compute the rest of the protocol
based on a value that was sent
similarly for receive and then listen is
like if you're if you're setting up a
server you'll listen for connections on
a port for example so these are these
are the commands that are available to a
particular communication channel handle
so just to give an idea of how that
works in practice so this is a this is a
program written in a protocol language
that's built on top of this this actions
structure so what we'll do is we'll
write a protocol not for individual
participants but we'll write a protocol
for the entire system just will write
essentially a communication pattern for
a complete running communication system
so this is a this is an echo server
where the client sends a server string
and then the server sent declined to
string back so if you've ever done any
security protocol work or looked at some
Kerberos style notation this is what
it's really inspired by so it's a it's
an attempt to write down communication
protocols as an overall scripts and then
we'll calculate for each participant
will calculate the valid possible
actions from this overall script so this
is the sort of thing we'll get if we if
we calculate the echo protocol relative
to the clients then you'll see that it's
expected to send something to the server
and then it's expected to receive a
string back from the server and then
it's expected to finish so this is like
a one participant version of the scripts
and then the server has it the other way
around it's expected to receive
something from the client and then send
something back to the clients and both
of these are calculated from the same
overall script and so if we're firing if
we're like spawning a process for each
of these together we'll send in the
protocol description rather than the
scripts and we know we're getting the
same scripts or the whole thing so some
of you might have seen session types so
session types are I mean it's
essentially session types if you want to
go and read out the theory behind this
so I know what you're thinking you're
thinking that's not an echo server you
could send any old string back and that
would be fine so what we can do instead
is we could we could compute the rest of
the protocol from the message that's
been sent so now we've got a more
precise echo protocol where the we we
bind the the message that gets said so
again this is this is a value that we're
only going to know about at runtime but
we're just saying when it turns up at
runtime this is what we're going to call
it so the protocol now is there really
is that we we send a message and the
message that goes back had better be the
same message or it won't type check so
you'll see down here when we calculate
the protocol description it's kind of
turned up here that the message they get
sent is banned down here so the sort of
sort of client that might work with that
we we say in the type that we're writing
a client for this client-server protocol
runs according to the the echo protocol
and then this program basically connects
to a server handle and it does what we
can do we can do whatever we like in
this program we can write you know print
things do things locally provided that
anything we do that is that is a
communication part of this program is
the thing that's correct according to
the script so there you go it'll print
back a message the message that the
server sends back so I'll show you that
just because I want to show you there's
much what happens when it goes wrong is
when it goes right it's it to be honest
it with these things the error messages
are at least as interesting as the
programs you can imagine so this is a
bit where I have to pretend that I'm not
typing - - type and type I don't need
that so corner of you know the type of
types is type 1 the type of type 1 is
type 2 and we have to calculate it this
is all consistent this program is
consistent it's just a couple of days
ago I discovered a bug in the check
check if it makes it run for ages so
that's that's the thing that I'm pretend
wasn't happening if I had this on slide
but now that I've typed
and I have to show you anyway so this is
an implementation of the the the echo
protocol so we've got the clients and
then down the bottom here I've got a
main program that's that starts the
server running and then just loops
repeatedly sending it things so I don't
program in Erlang much but I gather that
this is one of the patterns that you
might use when writing an Erlang program
is firing off a server and then having
your treating it as a module essentially
and having things cocoa and threads talk
to that server so I haven't actually
compiled and run the program have I so
this type checks so we can ship it so if
I execute it it's not seem very lower oh
I have this it just feels like you at
the back when we oversee it let's scroll
up hello now so we've written this
protocol and our customer comes along
you know they paid us a lot of money for
their echo server and so we should
respond to change requests so the
request that they've sent is that the
server should actually send back the
length of the message - so what do we do
we add that to the protocol so just
we're just a natural number length and
let's try now when I when I edit Haskell
programs if I add a new field to a
record for example I don't add the field
and then go through my program looking
for where it might go wrong I just
compile it and let the compiler tell me
so let's do the same here and it says
channel error it's a wreck this rec
delay act basically means you
recursively did something on the channel
but you were expected to send to the
client and then for the client it says
hang on you've ended the channel but you
were expected to receive from the server
I think that quite readable error
messages I think we've done ok there so
ed rich has a system for essentially
reflecting error messages so all of the
error messages you get from this sort of
system have exactly the same form so you
write a program that interprets the
error message into something readable so
that's what I've done here so what we
could do is basically send the
length of the message afterwards and
receive the length of the message
afterwards I suppose I could even show
it
hopefully I'll compile no because
because I was supposed to receive a
length and the channel this is just to
prove that I'm not faking this I'm
making these mistakes so it type checks
 okay
so there you go it's sending us the
message in the length back right I have
a very small amount of time left so I'll
show you I was never really intending to
show you this but just just a just a
vague idea about how this works
we have channels that are parameterized
by the endpoints and this is this our
channel is a replicable Channel so this
is using exactly the same thing that
we've just seen with the doors except
the states are more interesting so so
you've got a channel that has the the
actions that it's supposed to do and
it's a unique thing which means once
I've sent something on the channel that
channel is over I can't use that channel
anymore but I can use the channel to get
sent back so it means we have this this
slightly ugly thing of having to send a
new channel back but the payoff is you
know with a little bit of notation but
we know that this really did do the
protocol that we were supposed to do so
if I if I change a communication
protocol in a real running program I
have to be very careful to ensure that
I've got the thing I've got the
communications happening right at each
point otherwise I'm gonna get a deadlock
and maybe I've got an obscure case that
doesn't get called very often and well I
now check that by type checking not by
waiting for a customer to complain and
I'm not gonna spend weeks debugging it
because if you've ever tried debugging a
concurrency ever error you know that you
never want to debug a concurrency error
ever again so the type checker is going
to find out for us
um so send and receive basically we're
sending a thing and the rest of the
channel is completed from this thing we
sent and receive the rest of the channel
is computed from the thing we've
received so this is just a pattern we
saw before but the thinking the channel
can change and I'm just gonna skip to
this one little
so this is a slightly more a slightly
bigger example where maybe you maybe
you'll write something that's
essentially a module providing no it's
carrying some stage it's doing some
computations independently from multiple
threads so this is a rather trivial
utility server it supports three
commands a multiply command where so the
first thing that happens is the client
sends the server a command that command
is either multiply in which case the
client then sends a server a pair of
integers and the server sends the client
in the initiative
integer back which is the product of the
two or will the client sends the server
a string and then the server sends the
client a number back and then this last
one just to put a bit of state in we've
got enough time which is the number of
cycles this this server has been running
so hey let's show you it running why not
I've got a minute or two well I think I
called it util server yes
actually what I'll do is I'll I'll just
show you how quickly these things type
check well slowly so that's that's like
three or four seconds so this there's a
little bit of work that the type checker
has to do just to make sure that each
program is is propagating the values
properly so you do you get a little bit
of a cost but I don't think that's too
bad that's I mean that's it's the price
you pay for for one thing to know your
program works also we can do a lot
better than this you know this is this
is research quality software so we don't
you know if if if it gets too slow for
my programs I get annoyed and I profile
it and make it quicker but I think this
is this is okay for what we have so far
so here's our utility
protocol down here I've got a server
basically just responding to all the
possible commands and then down here
I've got one example of a client
function which is going to take a
channel that we're communicating on a
couple of integers and returning an
integer in a concurrent program so I
haven't set up the whole thing but it's
the kind of thing you might do is
basically write write functions of this
form and that will be your your library
that you give to a user that can use
these in a concurrent system so
well we saw that working I guess I could
compile and run it and hopefully we'll
get the answer 36 that's reassuring but
I could do something like this is the
kind of mistake that I know I make if
you know accidentally accidentally
putting the commands the wrong way
around because I have enough coffee yet
today and so what the machine will do is
it'll say hang on on line 24 I was
expecting to receive from the client to
send to the client but you received from
the client so I look at I look at line
24 so yeah I'm receiving from the client
but I wasn't expected to receive any
more input from the client so this is
now being caught by the type checker
rather than than my 3:00 a.m. debugging
session which I'd like to think is a
good thing other things I like doing at
3:00 a.m. sleeping mostly okay so um all
of that I only thought it's basically
thought of that last week so if you
found any problems in it please let me
know this is the first time I've shown
anyone sorry but it's it's what we've
seen is a way of writing down explicit
protocol types and writing programs that
conform to those protocol types and you
know I could go into more depth about
how how the internal system works how
the channels work but the great thing is
as an application developer you don't
need to know that all you need to know
is that you write down the protocol and
then the actions have to follow that
protocol and they call things like send
and receive and we're quite happy with
things called send and receive they make
sense to us so why do we care we're
making assumptions explicit in types so
if we if we violate an assumption at any
point then that gets checked for us we
can write much more descriptive api's
than we've ever done before so I mean
it's fairly clear just by reading the
word send what it's expected to do but
now you really do see how it affects the
protocol that's underneath and I don't
know if you've ever read the the the
POSIX documentation for opening a
sockets on a server and trying to trying
to send the message to the other end and
receive a message back it'll be very
nice if we had at least something in
that API that told us what the state of
the soccer
and if you know if we got the right
thing so this kind of thing happened
with API all the time now we can write
it explicitly in the types so we've got
time directive development the machine
helps us get to the right program and
the real the thing here is that you kind
of feel sometimes when you get a type
error from your compiler that it's
scolding you like you haven't done your
homework properly well it should be
there as a research assistant it's like
it's your it's your helper not your you
know your teacher so the type system is
there to help you not to tell you off
and then what I haven't really touched
on but because I've written these things
as commands rather than as rather than
as functions I could I could write
exactly the same program and have it
work over a network over a distributed
system another thing that we have to
think about there of course is what
happens if the value doesn't get to the
other end and I think we can learn a lot
from for example Erlang in how we have
we build these systems that not only
work in a distributed concurrent way but
also also deal with failure properly and
you know crash in a in a controlled and
predictable way ok so I always like to
end on a joke so there's a joke for you
and I'll finish there thank you very
much
yep so I would probably do in a similar
way too so here I've got that it's a
literal message now that little method
is actually what it what it is is a it's
remember that this red type with the
value and the thing computed from the
value so it's a similar thing going on
here that's a message paired with a
proof that that message is equal to the
original one so you could do a similar
thing with with lengths now typically
that's not massively useful because
that's just the computation but if what
you're doing is not so much the
computation but an important property of
the computation that you can check then
that's that's where you would use that
sort of thing
but if you would do basically a similar
sort of thing to this and it's yeah it's
it's it's dead easy dependent pairs all
the way lots of other questions
okay so again you could use something
kind of similar if as long as you have
some kind of way of expressing the fact
that you like these facts that you
expressed about data are very much like
horn clauses in a Prolog program somehow
so if you if you can write something in
this sort of predicate style where you
can say if I have these two things they
relate in this way then as long as you
can do that then you can write it down
as an English program
well I wouldn't go as far as to say
Burris does everything at compile time
so you might get some data that you you
simply don't know what that data is
because it's coming over a network or
from a user but what if this does give
you is a guarantee that any necessary
dynamic checks are done and once you've
done that dynamic check you can have a
proof that you've done it and you can
reuse that every time you need to do the
proof again so certainly you can move
this is the goal moving a lot of those
things that you put in as contracts that
you you check at run time but as far as
possible checking them at compile time
and if there is some kind of violation
deal with it gracefully so sure that's
that's that's a good way of thinking
about it yeah so you would have to have
a proof that the vector was that long
in fact that's just just on the
off-chance I think I think we have just
such a function I moved this module so
hopefully it's a hopefully it's in the
same place the answer is yes Idris can
do that
so what we typically do is any if
there's anything interesting about the
the properties of the function you put
it on the argument rather than the
return type so you have to feed in
something that is n plus n long so
somehow you're going to have to check
this but I mean that's ok because you
should have done that anyway otherwise
your program will crash yeah yeah so
when I when I say types our first class
I'm not kidding you can put values in
you can put values in types just so you
can plug types and values yeah yeah
I think I'm gonna say challenge accepted
I don't know I don't know but this is
this is something we should do with this
system I yeah so we would probably have
to extend this protocol language and
what we are really interested in using
this for properties of some security
protocols so that's a really good idea
actually let's take a look at that yeah
okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>