<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2015 - Inaki Garay - Teaching is Learning: Training New Hires | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2015 - Inaki Garay - Teaching is Learning: Training New Hires - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2015 - Inaki Garay - Teaching is Learning: Training New Hires</b></h2><h5 class="post__date">2015-03-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sm9QB_OyB9w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you very much for coming here I'm
very very very happy to be here so my
name is Enoch Eri
I've been a neuro-link programmer for
three years now and I love
non-traditional paradigms and I'm from
Argentina so my name is in hockey and I
work at Anaka that's actually my email I
have the best email on the company but
it's not my company I'm not the founder
if you haven't heard of us we started in
2010 and we were acquired by rolling
solutions last year and I've been with
them since 2013 we build end-to-end
applications in Erlang Ruby with a web
iOS and Android components and we'd like
to develop highly concurrent
applications such as whisper or Tyre
text and we're active contributors to
the open-source community we really
believe in giving back and we love
working out in the open and this will be
relevant for the dumb talk so to give
you a brief outline of my talk there it
is I'm going to tell you a bit about my
story not that it's very interesting but
it's gonna like it ties in with what I
want came to say we can have a little
popularity contest and I'll make the
point that hiring is hard although we
already know that and that training is
easy and what is our approach to
training new hires so where did I say
was from this is Argentina if you the
other land down under that's the promise
of one Osiris the big dog is one Osiris
the capital and I'm from that's hound
buyer Lanka so for scale by Ivanka has
about three hundred thousand inhabitants
and when Osiris has 11 million in the
greater area and there are about eight
to ten Erlang developers I work with six
of them and there aren't that many more
because believe me we've looked
so I'm just a very humble and lonely
programmer I'm very happy to be here
because this is actually the first time
that I've met face to face with other
Erlang programmers outside my company so
it's very gratifying to know to get to
know like-minded people because it gives
you the feeling that you're not alone in
the world and I feel that the same
feeling that I've had on a personal
level we have as a community because the
truth is that we are a small community
at least you know relative to other more
mainstream languages has anyone ever
seen the this OTP life tumbler raise
your hands if you know it great so this
is like the highlight of my day is
checking whether the tumbler has been
updated and this is one that was posted
by Tristan but thank you to us and for
that one so we're a very stable
community we've been here like forever
thirty years more and we'll be here for
another thirty but we're not comparable
in size and recognition to other ones
and as developers this is not always
obvious it's more obvious for the sales
and marketing teams because they have to
make the case sometimes of adopting
Erlang for a project there's nothing
wrong with being a small community has
anyone ever heard of APL or the Kay
programming language yeah so there are
also you know they move millions and
millions in the financial sector but
heaven knows how few of them there are
so one issue with being a small
community is finding new hires you know
when you want to have a problem a new
project need more developers where do
you get them Erlang is well known thanks
to the functional programming revolution
among developer circles if you've been
to hacker news read it you know what it
is but not so much about managers now
last year there was a great talk by
Garrett titled why the cool kids don't
use Erlang and he did what everyone
should do in these cases which is to do
a survey and ask questions one of the
questions he asked was what challenges
do you see in adopting Erlang for a
project I'm concealed not a slide from
him because from his results the main
the foremost answer was finding
developers so how is her life doing
lately we can examine the bogus indexes
that we all
you know so tea Iove if you don't know
how it works like I I I research you
just want to see how they get their data
so supposedly tea Iove they do web query
results from the twenty five main search
engines which is indexed by another
search engine called alexa and Erlang is
because consistently year after year in
the 50 to 100 rank they don't list those
because there's such a small difference
the first programming language the first
functional programming language to reach
the top 20 was that sharp unfortunately
so line pop is another one they use
github google search Olo and craigslist
they were last updated in 2013 so that's
the latest thing they have Erlang is
there but at least we're there right on
the top 30 the problem with the previous
two is that one thing is the hard thing
about surveys is knowing what to measure
and the other thing is transparency in a
sense of how they get their data so the
transparent popularity index tries to
solve problem number two by opening up
the data and all the code they have to
crunch the numbers and on that wonder
language member 27 in the all languages
category they like categories languages
by purpose and it's number 15 the
general-purpose so the big point is that
it's open data and you can access the
the route of the link at the bottom red
mark is another one Garrett examined
that last year to red mark is different
at least they're more honest in that
they don't try to offer a statistical
meaningful representation what they try
to do is rank they they compare
popularity on github only against
ranking on Stack Overflow
by tags so the idea is to correlate
usage with discussion so if you have a
good correlation you'll be on the center
line and if you're talked about but not
used or much used when I talked about
you'll be outliers so where is their
line there which is a good place to be
github is newer that came out last year
and it was more of an experiment in data
visualization what they do is they only
took data from github archive using a
Google bigquery and they track active
repos and per repo the number of pushes
and the number for
and open issues and you Watchers and I
highly suggest you get to that website
because it's so fun to play with this is
what it looks like sorry fits so small
the black line highlighted is Erlang so
they try to you know correlate each one
so Erlang is up there in the top 30
which is good also and it has a healthy
number of pushes for a repository and
what you can do is the data is per
quarter so you can see how it evolves
quarter after quarter this is the first
quarter of 2014
second quarter and it maintains that so
the point of all of this is that what we
are seeing is linear growth in our
community in Erlang adoption but it's
not exponential and it's not you know
very high linear growth slowly but
surely there are more of us and some
things have helped like though as they
mentioned in the keynote the whatsapp
success story is you know very important
in using that as a selling point elixir
is also helping in bringing an airline
to the attention of other language
communities and in you know ensuring
them that it's safe to you know to come
to our platform but it's still not
enough because the fact remains that for
small companies and companies that are
not based in the the main airline
development centers it's hard to get new
hires or to have them relocate so I
didn't come here to gripe and whine and
cry or harp on an established fact we
all know this but the point is that it's
hard to find hires but it's easy to
train them and that's what I want to
talk about so one thing that you have to
take into account when training people
is that there are two kinds of line ups
you have the inexperienced guy which
doesn't have much a long experience much
experience of any kind in industry and
then you have the experienced guy who
has maybe done telco for 15 years or
something like that and each one
requires a different approach to
training you know to onboarding another
question from Garrett's talk last year
was how many years you have been working
in software and the vast majority
answered they had between 5 and 15 or
over 15 years of experience you know
very few people start learning Erlang as
like a first programming language or a
second or third so what is our approach
to
following this problem that we have in a
nutshell it's choosing the right
candidates putting them in
apprenticeships because software is you
know more like a carpentry than
engineering in that sense you need you
need someone to guide you how to do it
well you have you have to give them
clear guidelines for development and
improve their tooling you know Erlang
has traditionally suffered from crufty
tooling compared to you know the newer
ones and give them a toy project which
is almost the most most important point
underpinning all of these so the first
point is selection and this should go
almost go out saying you have to choose
the right candidates in the sense that
motivation and passion are key factors
that affect the learning process the
person that comes to learn Erlang has to
want it really bad because know-how is
not absorbed by osmosis and they need to
they need to accept the the paradigm
change of working with a concurrency
oriented programming language so that
ties in with getting young young young
is not about age this is not about
ageism it's not about how old they are
it's more about the mindset they have
there's a phrase in buddhism that says
beginner's mind send mind what it
relates to is the fact that in a
beginner's mind there are many
possibilities when faced with a problem
and in an excellence mind there are a
few possibilities because they know how
to do stuff they're set in their ways
and that they've solved that problem
before they know what I'm doing and
sometimes carrying over those
preconceptions to Erlang is not a
beneficial to learning process you know
they'll have to you know break their
horns against their I guess the problem
until they've realized they have to
change their ways so younger programmers
will suffer from a lack of skills and
you know know-how with tools available
but they have the benefit of having
those few preconceived notions and you
can use that in the training process to
mold them in the image you need and this
is important because like I said earlier
presents a non-standard paradigm and
many of the design decisions that make
Erlang the language and the platform the
way it is stem from the original domain
requirements so unless you've had these
problems and they see you're trying to
solve the problems that Erlang is good
at solving you don't know why those
decisions were
whether we're taking Joe and everyone
else has you know taking a lot of time
to try to explain that but you you have
to be very explicit to the newcomer why
things are why you have to do things the
way we do them the apprenticeship is
also key because assigning or mentor or
tutor will encourage the newcomer to ask
for help and you know reduce the time
that they will spend blocked on an issue
an experienced programmer will know you
know when to get help how to get help
where to get help but a new guy will
just you know like freeze up and luck
and say well where do I find this out if
you have a guy next to him under you
know and have him under his wing he will
point him to the right direction as soon
as he has a problem or as soon as he
doesn't know how to do something so it
reduces the amount of time to unblock
and it also integrates the newcomer into
the year development team
this field has some feeling they're part
of you know part of the team part of the
community from the bat guidelines had
documentation and Erlang used to suffer
from you know serious lack of
documentation there were no books there
were nothing like I said Fred came out
with a learning some Erlang that was
instrumental in in helping people access
the language and the platform how I
started something newer also by Fred and
by Jose there's a cipher elixir and
we've started a repo with a document
that anyone can contribute to trying to
you know list the main resources main
blog posts you know everything that you
know is scattered around the web try to
have it in one place so that's the spawn
shelter documentation and guidelines go
together when we started growing as a
team and you know acquiring more people
one of the issues we ran into was that
everyone had their own style so you know
one would do things one way the other
way you know just the way they had you
know found out as they were learning and
you know having a common style is
necessary beginning when you're moving
from one project to another so we
started you know bashing our heads
against each other and we decided that
we needed consensus on at least basic
issues so what we decided to do was get
together and vote on those issues
as a team and every decision that we
made we put it into a document and that
document is also open it's also on
github and the idea was that each rule
or guideline corresponding to one of the
ways that we decided to do things have
to have a clear definition it has to be
as unambiguous as possible it has to
have a reasoning behind it I had found
an example of proper compliance and an
example of non-compliance so all these
issues each one of these is important
and our process for incorporating new
rules is okay so you have a suggestion
on how to do stuff or why we're changing
our ways you open an issue you document
it we vote on it if the majority of the
team agrees we incorporate it and
there's a pull request with all of these
issues why are each of these important
and it's because each one of those key
elements is very important in making
another person understand another person
who hasn't gone through the process of
thinking about those issues why the rule
of the guideline is in place why it
exists in the first place so it it gives
them insight into the thought process
for more experienced developer a guy
that's new to Erlang won't know why it's
bad to have a module with a hundred and
fifty explored functions or why this
architecture will you know have you run
into scalability problems why you don't
have a single gem serve as a joke
process so this is invaluable to the new
guy because it gives them insight in how
to think I'm the training process it's
very this is the moment in which you
don't give them the fish you teach them
how to fish so it's about teaching them
how to think down the line once they're
on their own on a real project so we
open the document up we posted it and
share it around it became quite popular
but we realized that those are just our
guidelines for us we never expected
adoption although we we loved you know
new contributions because we understand
that each team is different because of
the people that compose it are different
and also because the products that each
team builds have different needs and
different priorities so our hope in
sharing the document was that each one
would use it as a basis to form their
own
you know to inspire you to have your own
documents it's very important because
these having guidelines for not only
coding guidelines but also project
management guidelines like whether you
have stand ups or what are the
responsibilities of each person that
reduces the amount of decisions that a
newcomer has to make and that's
cognitively very important for example
if you go to a supermarket and you know
you're shopping for a long amount of
time preparing prices that's you know
mentally draining and you end up
consisted and the reason is that each
time you decision takes a little bit of
a mental energy and if you take away all
of those decisions from the newcomer and
say just do it this way and this is the
reason why we do it this way it frees up
their mental energy to learn what's
important to give you a feeling of what
that's like I'm just going to show you
just one rule from our guidelines we
like to avoid deep nesting which means
don't have you know of a try inside of
case inside another case with a function
in it so try not to nest more than three
levels deep a little bit more clearer
and it'll have a link to code in the
same repo showing an example of what
what should not look like and what it
should look like and these this is also
very important because it gives them an
example they can they can compare it and
it's different from you know giving them
an abstract idea like don't nest deeply
and showing them visually what it should
not look like so examples are key are
key to you know making someone
understand something it may it lowers it
down from an abstract idea to a concrete
idea and it should also have a clearly
enunciated reasoning behind it so we do
not like Nestle nested levels because it
implies that the function has deep logic
it makes many decisions and that harms
readability it harms maintainability
that's our opinion you might not think
that way you know so each one take it
with a grain of salt but for us when a
new guy comes we say don't do it because
of this tool he goes the second part
you've got a new guy you know he's with
a mentor he's ready documentation
and he you know you you now have to give
him a task and tooling improving
improving the tooling is about reducing
the amount of time it's spent until to
get you know running an active and
writing code so we've attacked this
problem from several angles one is by
creating the common utility library sort
of like a Swiss Army knife of code you
know just a grab bag of useful functions
but you know Swiss Army knife isn't very
important if it isn't very cool so you
named it Erlang katana which is a bit
nicer so what did we put in that for
example a function to join but elissa
binaries functions to transform from one
date format to another to process Jason
process maps do common RPC tasks between
nodes and the important thing this is
our answer to the newbies question how
do I do X you know how do I do this you
know there was a ton of problems you
know common problems with common
solutions that don't experience the ball
the developer will know how to do but a
new guy you know it's just not in the
standard library maybe so the idea is
not just it's this is not about code
reuse this library that we have around
katana is documented it's a requirement
that funds to be documented if you want
to incorporate something new it's tested
and it has examples so then you guys
says well how do I do this how do i
generate a random string with ASCII
characters so this way and this is the
proper way of doing it so like I said
examples for key
gute is another one is short for
Gutenberg like the printing press and a
good is a scaffolding tool similar to
human or rails generate we made it we
tried to make it easy to use like rebar
you just download it put it in your path
and what it does is it'll use the github
API to search repos with the specific
tags with these repos we'll have like a
structure with templates in it you can
use it with cut search you get online
help on the command line with good help
and what you do is you get new with the
name of the repo it'll download it and
instantiate it with all the variables
that you give it and we know that there
are other
I do this rebar has templating Erlang
and K also there are tons of it you can
use a human if you want but this project
was started by one of our ex
co-workers as a learning tool he won't
yeah he had this need
he had it stitch and he scratched it and
out of this project we gained for
example to know how of how to escape
ties how to properly eat script eyes an
application so everyone in the press on
the team gained from it even if we don't
know not everyone uses it everyone now
knows this is how you do it
Elvis is the most interesting tool that
we have the the link above is the repo
for the code and what we it's a service
that we were not offering it's an
automated style checker similar to
Ruby's hound
we call it Elvis because he's nothing
but a hound dog so what happened with
our guidelines was that as we you know
developed them they became extensive in
the sense that there was a lot of rules
keeping all those rules in mind when
you're doing code review is hard and
it's also not fair to just give a newbie
you know a hundred rule guidebook and so
ok memorize all these and start writing
code so what we did is we tried to
automate as much as possible our
guidelines by formalizing them and
having the tool you know check the pull
requests in our code review process it's
so it started out as a toy project for
one of our more experienced new hires he
he already had you know experience
working with code doing meta programming
so he wants something more interesting
and he said well we have this problem
which is that you know code review is
getting tedious can you automate this
and it started out as a simple you know
he a tool that he would run on his code
then he is he scripted I made it into an
e script so you can run it on the
command line anyway anywhere then we
turn it into a server the guy learned
how to use the the github web hooks so
we made it into a service and it just
grew from there
Elvis is extendable in a sense that all
you have to do is have an Elvis config
file with the rules you can add new
rules if you want implementing
we accept whatever whatever you you
would like and some of examples the like
checking for a line length we'd like to
have 80-column files
some people use 120 you can configure
that that's you know some people use
tabs and don't we don't you can add or
remove that we don't like macros some
people do so there these are all
configurable and removable if you want
but the point is that this tool helps us
to give quicker feedback to the ubii
because he'll just you know he'll write
code issue a pull request and there's a
bot telling him how to code this is an
example of Ellis in action so this is a
pull request on github and Elvis says
the expression of line 128 and call 19
is nested beyond the maximum level of 3
so you know please refactor that
function into something more
maintainable and we have many others we
have like a ton of open-source projects
on the Anaka profile sumo DB is a
persistence layer because we got tired
of writing the same code to access at a
bunch of different databases lassi is an
exam handler for the SSE server sent
events products on is an extension of
Lloyd's gun to test servers and event
endpoints etc all of these came out of a
learning process of one of our teams and
that brings me to the main point which
is the toy project now what do I mean by
a toy project a toy project is a project
with the express goal of teaching than
you guys and it should have what I call
Goldilocks scopes so the project should
be small enough in scope to be
accomplished in the expected training
time but a large enough in scope to have
the new guy learn all the know-how that
you need for your organization and your
team so what should be the project goals
the first is to reduce the amount of
pressure on the new guy because he won't
be right out of that on a client facing
project it should give them an arena to
practice all the everything that you're
teaching they should be able to make
mistakes in that project it should give
them this is very
should give them a mental framework the
structure of the toy project should be
as similar as possible to the structure
of the applications that you usually
develop whether you have a long-standing
product or you know consultancy jobs if
you do you know one thing over and over
you should give them something that's
very similar so that later on they have
a framework English so they can slot in
new knowledge as they gain it like for
example with Elvis you know once he
learned how to use web hooks you know
just incorporate that it should give
them obviously the familiarity with the
basic design of the of the paradigm so
you know you should teach the functional
programming if they don't know that you
should teach them you know everything
about concurrency and you know the
platform and very importantly like I
said you're not teaching them you're not
giving them the face you have teaching
them how to fish so it's important to
teach them consistency and
self-discipline because some of the guys
that we get are very very junior in the
sense that are not only learning how to
program Erlang they're learning how to
program so consistency and
self-discipline is about you know
writing the clear scold possible
refactoring it before it's too late
not not writing just good enough code
that you do that on a time constraint
project it's something that just works
this is the time to set the bar high for
the training because you want to teach
them how to do it right in the beginning
and not you know when they're on the job
so you want to teach them to write your
tests before you write the
implementation if you do test-driven
development and finally you should use
that time not only to teach them how to
you know learn Erlang but also leverage
that time to teach them how to do things
the way you do in your organization so
all the software development process
elements that you have like for example
if you use a special tool for time
tracking that toy project even if it's
toy for you because you know you won't
get revenue or won't be used or or not
for him it will be a serious project he
has to time track that the same as he
would on a real on a real one if you use
code versioning which I hope you do you
teach them which code version to use if
you do code review you code review that
project same as
real one and so on so by the time that
he finishes the toy project he should be
fully aware and well-versed with all the
tools that you use day in day out I want
to give you an example of one that we
the last one that we did some one thing
that I didn't mention is that each toy
project is not they're not reused it's
not like you have an example like like
four in a row or some NGO or just some
game and that you everyone reimplemented
every time they come to the company so
you should tailor the the toy project to
the needs of that of that guy like I
said you have different kinds of of
profiles you have the guy with lots of
experience and the guy with none so
foreigner four in a row was the last
project that was undertaken by the
newest hire who had he's like not even
fresh out of college he hasn't finished
college so he's learning how to program
actually and it was very successful
well the foreigner Rose also connect for
everyone knows how to play it so how did
we structure his learning process so
first thing we taught him was obviously
sequential around that functional
programming he didn't know that so first
you know how to do higher-order
functions etc and his task was to
implement the basic game state how do
you represent that using idiomatic
Erlang using the common data structures
that you use and how do you transform
that game state in valid ways according
to the game rules after he got the
basics down we taught him concurrent
airline because obviously the fee at
four in a row is a game it's a
two-player game so you want to be able
to have two players you want to have
multiple games going on at the same time
so we teach him about processes we teach
a message passing linking monitoring
that's you know you try to look for
something in the end into the problem
that you give him that will use that
that will leverage that it's not about
making a real you know whatever like it
wasn't about making a real four in a row
implementation in Erlang it was about
teaching him how to do you know what we
do
after the basics of concurrent Erlang we
teach him what we the tools we use so DP
you know after you if he's written
enough boilerplate code so you teach him
how to ride a giant server he teach him
how to do common tests we do test room
devoted to do is you want to turn those
modules that he started writing into a
deployable application that you can give
to ops so once he has an a deployable
application
what do you that's when you actually
really turn the screws on and mold him
in your in your image in this and what
to your needs so for example we are in
akka what we do is mostly mobile
applications backed by a REST API server
right so what do we use every day we use
cowboy we as rest we use server sent
events as a lightweight protocol to you
know send events to the clients so it's
very important to use the tools and
techniques and the libraries that you
commonly use so we teach them how to do
cowboy web handler
we teach them how to test that and so on
the conclusion that I would like to make
is that the title of talk is teaching is
learning and that's because teaching is
a learning process
you know Einstein said that unless you
can explain to your grandmother you
don't really know it so if the the
process of handing on handing off that
know how you've worked so hard to
acquire is very gratifying because in
that process of explaining you learn
what you really know what you don't and
you reinforce that and the thing is that
the whole team benefits from that
process because everyone learns and okay
so this is really effective because it's
down to down to the ground it's concrete
examples there are real-life work it
will get the guy working in a very short
period of time so it's easy to train
them it's not a large investment and the
lesson that that you do make actually
benefits the whole team everyone gains
the libraries having gains
and everyone you know spreads to know
how so we've gotten this guy to working
on an actual client project in under a
quarter just you know two to three
months and we think that's impressive
given that you know he's really brand
brand new so I hope that this is
applicable to your situations we know
that every company is different so you
should tailor that process the
customization is the key and that's
about it so thank you very much for
listening and I would love to answer any
questions that you have is trying really
hard
I guess it's a matter of my personal
research what's the average time of your
engineers starting to write production
code well it depends on the guy
obviously sure like what's what's your
impression like two months maybe alright
that's that sounds fair enough like
there is a lot of discussion in Russia
how much it how much it usually takes
you programmer to start writing
production code and I guess mostly they
take board people with some real
software experience like not just
students from college and for them it's
like about two weeks on average two
weeks oh yeah I guess I guess if you
count newbies in that in there as well
then it should be a month or two right
well it's important that one of the
points is that if you're taking you know
new guys so you should be afraid to take
on programmers that have no experience
because like I said it's it's not that
much of an investment because obviously
they're cheaper so if you have the bit
if you if you're lucky enough to get a
guy that you know it's really a really
experience to know all he needs is just
to learn the platform and you know give
the basics and like I said he knows
where to go for help and how to learn
something on his own that's just great
but if you don't have that benefit and
you know you have these other guys that
also works very well yeah another
question
another question is do you guys have a
new methods of measuring how effective
you are as teachers and basically like
whether you should or should not change
some processes well we don't have any
formalized methods but the the thing
about an apprenticeship is that since
you have a guy that seemed to dedicated
to teaching him working alongside him on
that project that that feedback loop is
really short so you'll know where you
know when something's not working when
he's not learning or something that
right really soon without having to do
like a post-mortem of his learning
process
so you're saying that you have a
apprenticeship is that a one-to-one
mapping or do you have someone training
multiple people at once like well most
of our training is done by our CTO buco
he's here in first row but you know
sometimes when he's not busy someone
else will have him once we move them on
to another project maybe that there's a
previous guy that has already been
working so he'll work closely with that
one so it'll depend when the whole team
is also very big on sharing and teaching
we everyone loves their line we love
explaining it so it's important to have
one guy with the responsibility of you
know having of that apprenticeship but
everyone can obviously contribute to the
process of teaching him and that also
speeds up the process
precisely okay and I have another cause
for you related to how you go about
hiring people are you just looking are
you looking for someone with like a
specific amount of experience or do you
not care given this type of philosophy
if someone's really inexperienced versus
very experienced with you onboard
that's great
well hiring is hard everyone knows that
interviewing it's hard getting people
the right people to the interview is
hard and I guess it depends on what you
get obviously we would love you know
just you know having ten guys to choose
from with everyone a loss of experience
so it actually you have to tailor that
the answer to that question to your
communities this is what we've come up
with to do development in Windows iris
maybe you know here in the San Francisco
area you hear you there long guys
growing trees so it like it it's it's it
depends basically
I have two questions for you the first
one is do you use any form of test
programming test when you're actually
trying to recruit people or evaluating
people and the interview process you
mean before the interview process maybe
yes yes yes we do you know we ask them
high level architecture questions we
give them a little coding test do you
actually get them to program something
to see that they can't program yes yes
definitely but it's more about like you
said verifying that they can think and
program more than seeing if they can
write erikson when I was there we had
the programming test then we used to
send it out to people who applied for
jobs and it was actually a bit telecom
oriented and he also said that explain
to people they were going to help if
they had an interview they'd have to
explain the results of the test to make
sure they didn't cheat and give it to
someone else it was very interesting
because with this process we never had
to mark the results of the test because
the people that knew they couldn't do it
never bothered to send it back the other
question I had is that if you write code
after about two or three years that code
is going to have to be maintained the
difficult bit about that is not writing
comments or documentation about what has
been done but writing documentation
about why it has been done not exactly
how do you actually make sure that the
code is documented to an extent that
people not be a new beginners understand
they document the right sort of thing
well like I said we're very big on code
review so nothing goes in the code base
without having more experience to
engineer look at the code and explaining
making it readable and understandable
and having the comments explain why the
code is there is a requirement for the
code to be accepted yes those are very
important issues another important issue
that I neglected to mention during the
talk is that this culture of training is
not really a substitute for for real
training so that's also an issue so it's
not the same as sending someone off to a
one-week course on
underline but it can stopgap the measure
in a measure the lack of developers
which again feeds back into going back
to the higher-ups and saying it's no
problem we can get guys train them and
we can still do the projects even though
you know getting offers for long term a
long long experienced line developers
it's hard could you talk a bit more
about the code review process sorry come
again can you can you talk a bit more
about the code review process or you
keep it like positive fresh I'm sorry I
can't hear you sorry and you talk a bit
more about the code review process
oh the code review process well we use
github even you know for our private
repos so it's really basically actually
you know they'll you know work on their
own branch once the code is ready for
review the less you pull request and
then they have to let you know the
person responsible no and it's just you
know going through the code sometimes
it'll be together with them sometimes
it'll be on their own that really
depends on the nature of that pull
request in particular some are more easy
some are you know more complicated if
the code is more complicated you'll have
them you know do pair programming until
it's clear I was more asking about like
the emotional side of the thing like I
know that criticizing you know it can be
oh well that's interesting that's
actually an interesting question because
well I showed you our coding style
guidelines but we don't have only those
guidelines we have you know company-wide
guidelines you know for for the project
managers for everyone and the code
review process is in there and having
the positive attitude is included in
that the part I said about having having
having them with a beginner's mind it's
also related to that because a guy you
know who's not willing to be in a
situation in which
the criticized even though they have a
lot of experience you know will have a
little bit of friction in that situation
so I guess you know don't hire jerks is
also part of the valid hiring hiring
process any other questions back yeah is
there any plan to extend elvis to the
other Erlang language like LFE or elixir
do you think the syntax is too different
so it's not it's probably better just to
really implement it in those specific
languages because they'll understand
themselves better well we're not using
the elixir yet yet but in our experience
the syntax is not the major barrier
that's that's mostly online and in the
sense that like like I said to get today
like like Robert said in the keynote the
main barrier for understanding or line
code is the semantics having value
semantics is odd in a language and it's
it's more important to explain those
parts than then they'd looks at the
syntax so that's not hasn't been really
a problem for us I think the question
may have been more about yeah Elvis Oh
Elvis yes like it is how how tied to
Erlang's
syntax and layout is Elvis or is it sort
of more a generic tool you go oh no no
it's completely tied it's it's for Elvis
it's for Lang yes yeah
oh right so well one of the building
blocks of Elvis is Aleppo which is a an
alternative parser for lang
so you know it's completely tied any
other questions in the audience all
right Inaki thank you very much
thank you guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>