<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang on Microcontrollers: The Research Continues - Dmytro Lytovchenko - EUC17 | Coder Coacher - Coaching Coders</title><meta content="Erlang on Microcontrollers: The Research Continues - Dmytro Lytovchenko - EUC17 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang on Microcontrollers: The Research Continues - Dmytro Lytovchenko - EUC17</b></h2><h5 class="post__date">2017-07-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6NUPormxgw8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">and let's begin so good day everyone
today I will tell you about my ongoing
project it is a hobby project it's been
happening in my free time so it's quite
slow it takes many many monks months to
accomplish stuff mean this is not just
simple presentation I will not just
scroll through with 10 million slides I
will tell the try to tell a story
what were my adventures and what I found
and what I decided and how it's been
solved so a short word about myself my
name is Dmytro litovchenko I work here
in Stockholm for airing solutions for
the past 5 years my long experience
stretches 2 years longer and my
programming experience goes back to 90s
I started programming basic back in
school and then C in C++ III took like
somewhere the age of 15 or something it
was 1995 so this is this is most
relevant because my project is is C++
and airline also since 4 years ago since
2013
I've been doing some translations of
educational material and books to
Russian I translated learning summer
long for great good to Russian that's
the paper the paperback designing for
scalability by Francesco Cesare me and
the TV no skill is the other one also in
Russian and I translated these two
things they are not on paper they are
published just what a handbook is on
ESL's github and along in hangar is on
my github also while working while
working on my project I I have noticed
that that it's too much knowledge in my
head it just
going to get lost if the time passes it
one Isha's so I created a website where
I started storing on my neural knowledge
and facts in form of simple to read
articles and as well as advanced
articles so it has to it has two parts
easy to read in form of air li5
explained me like i'm file it's very
simple in english and the second part is
bottom on the front page is more
advanced like technical knowledge parts
like how the data is structured how the
bin file is structured what are the
opcodes and so on so it's documentation
which was hard to find before which I
have found structured and saved in a
form of articles and then one day I
thought to myself let's run summer long
but not on
Erikson's air long and the first
question that comes to my head where do
I begin
so you can as an example you can imagine
yourself trying to begin a new hobby
for example metalworking I really like
metalworking I never did this single
thing in metal but I really liked it
like from far from distance so where do
I begin
I have no prior experience I never did
anything like this but what tools do I
need what materials do I need how to
organize my workshop what are the safety
requirements what power even will I need
in my workshop to start it so the same
for my for my project to run air lung
where do I begin I had no idea so I
started googling I started reading white
papers books source code everything I
could find so I didn't come empty-handed
of course I wasn't Blanc in my head I
some experience before so well this all
went together so first to run something
to run something I need the code the any
any form of code but well for for
virtual machine it should be by code I
could well I found a for example I found
a longing interpreter closer oh this is
really deafening okay so so for example
I found on a github
I found the project by Tony rock ball
which executes interprets Erlang a
syntax tree or a long beam assembly in
Erlang form I used it as the source of
knowledge the first source which helped
me loading the bin file and this was my
basically three sources of knowledge
where do you begin if you want to
understand how it works so and main main
well the base of everything is the
compiler the OTP application which write
these modules so it's the source of
truth of course I had to consult it too
it's not the easiest read no the next
comes the data we'll assume I I parse
the beam somehow I figured out the data
format in it it's not easy to compact
some bits they use is used to write it
more compact and assume I I did it next
comes the data what is what how does it
look in memory I need to represent it
somehow nicely and this still at this
point it still wasn't oriented for a
microcontroller it was just I I just was
just making an airline from scratch to
interpret to make a virtual machine so
to compare it for example to Java or to
Python how they represent data in memory
and in memory they have every value in
memory in those languages has at least
two words is a pointer to virtual table
n2
to the clock so integer is a class your
own class is a class of object and
double is a class and so on and this
isn't the case in air lung because air
long uses more compact representation I
had to find it I had to learn it how it
works and also it's documented on my
website now because well I had to know
it it was too much in my head I had to
write it down and then like one more
question I I found in the code so much
so much this was mentioned what is a
boxed value what is the box so box is
anything that does not fit in in the
world does not fit in register you put
it somewhere in memory in store the
pointer that's the box so these these
things very confusing I had to find them
and document them and later this year
like few months ago Erik Tilghman
published his his his bin book on github
which contains parts of what I already
found documented so he he knew it all
the way long and now I'm also
contributing to his book and this is the
timeline of my project it started two
and half years ago when when I basically
started with zero knowledge and started
doing the person beam format
interpreting doing everything to run the
code it was also the most successful
project if I look back it of my several
attempts the latest one took several
pages it was the most successful project
it did most of them all so then so at
this point I I stopped thought to myself
what wrigley I want to build why I am
doing this who wanted so then year has
passed I was busy translating the
scalability book I also had public
presentation of my pro product on the
same year on a long solutions company
meeting
it had some positive response for a
hobby project that was just done in my
three innings and in 2016 I also had
some exposure to all TP source I was
working with the OTP team
I added if you remember the keynote from
the start of the day way
Kenneth London he mentioned that OTP 20
now has a garbage collect call with
options to do my major minor that was
mine and also I did my refactored
garbage collector code but it it was
satisfying in stable but they didn't
make it in the master branch for some
reason we decided to not do it yet so
end of 2016 I have started the new
project with a new vision understood
that the first one is it does not have
the target audience it does not have the
use case it just goes parallel with the
OTP and gives nothing to two people so
who would want to use it and then I came
to idea that the world probably needs
smaller smaller virtual machine that
will run air long and there it started
so so this started in 2014 this is the
first project it's on github if you ever
are interested to look on the simplest
code to load beam files it parses normal
beam files from your compiler it's very
successful it's it has basic datatypes
it has processes process heaps message
passing receiving exceptions it does not
have catch though but you can create
exceptions and crushing processes it has
closures and all that basic stuff that
you need to run simple thing also it was
able to encode JSON using Maki Jason I
just loaded module called it and
introduced salt
this is the logo I created for it
already then I was guessing that
probably the target should be something
small so I started munching on those
little chips and so yeah this was the
same slide okay
now the interesting part this is the
printout of when you just get the source
from github and run make so if this
screenshot shows a lot of interesting
pieces in facts which I already
mentioned so for example it finds
modules automatically these hard coded
so when I use it on 19 it I had to
change novel version numbers and then it
started actually before it was
complaining the module is not found so
it finds bean files it finds the
function it has scheduler schedule
around q3 which means normal priority
queue it reaches quite often because I
lower the threshold of reductions to
monitor how it behaves because if I do
2000 crushes after 10 opcodes it's not
interesting so I'm lower the threshold
of switching has bits it can do calls it
can create here it can create functions
these are closures it can call them it
can call normal functions and also it
creates an exception here somewhere
Agnetha error I think that great
exception the unconscious so good stuff
I think this is the most successful this
is the most far I've got with an
interpreting bin I will tell later how
the latest attempt goes next milestone
in this project where I stopped was to
make a long in e-tron and to enter the
shell but in it does a lot of magic in
it to get running spawns processes which
were easy
me it does monitor in Lincoln between
them which was almost easy then it
crushes something or thing he sends an
exception for some reason and that was
too much I did not have an exception so
I could not pass through that break
point so I could not make any turn yet
then I realize that is too much and I
slowed down they are ended next year was
the book and next year was the new
project which continues this idea so
basically it was discontinued at that
point then I also end of 2016 I ordered
2015 I ordered garbage collection
handbook so I now I know much more about
garbage collection and I worked the
garbage collector in OTP so I have this
knowledge now and it's ready to be used
just coming to it soon so this project
was stopped in still github it's
runnable if anyone is interested it
there that's the book now end of 2016 I
realized that there is this small J 1/4
implementation which is like few pages
of goal but I could implement it in C in
C++ and I was thinking to myself like
let's try adopt it and make a long run
on this it's very small it is very
promising and that example is piece of
fort coded that calculates Mandelbrot
fractal picture just just to get the
feeling what for this is for those who
don't know it it's very simple it's a
stick based language that this is the
first problem is stick based and a
language register based so but it wasn't
the biggest problem of mine and the j14
has just four instructions then all the
magic happens in this ALU instruction
which has bits saying what to do with
data what to take from stack what to
move from stack would increase what to
decrease it's all encoded in bits so
these function
but does all the magic that's all
default functions you can implement with
it but single opcode and it has a VHDL
implementation which Dale is this
electronic circuit description language
which you can use to build physical
chips or program FPGA to run it so j14
can do it and I was thinking to myself
let's do some modifications here and
there maybe it will work for me and I
can run along CPU right
not too fast run so this is the compiler
chain the the left-to-right chain is the
original Erickson's compiler LC it takes
or spree processes max core but the
magic produces kernel we must simply and
there we have been filed we can run it
it's ready on our disk I tried the core
initially it was going mostly well I was
producing my fault from it I was
compiling to bytecode it looked coated
make my eyes happy and then some point I
came to pattern matching and that is the
horror
so pattern matching is pattern matching
must be compiled into a decision tree so
it takes pieces from left pieces from
right checks if the variable is defined
was the type what to do next is it all
much variable is it and so on so it this
algorithm for building this tree was not
so easy it was not so simple and I
understood that it's not it's out of
scope I don't want to do this in this
project then I look down the chain into
colonel and colonel already has it done
so basically I just switch to Colonel I
wrote my input to take colonel it was
very similar it was not hard and now I
have pattern match pattern matches
compiling two decision trees already
just three of ifs or something to you
checks off values and types
so the chain now looks like this my tool
called e4c it's part of compiler
application it takes it invokes an l1
compiler takes kernel stage produce J
1/4 text as a list of strings which I
can as well parts from source file if I
want to write simple forth and then the
next tool the same of the same program
but different application produces
bytecode two-stage is very simple so I
was adding more and more up codes
because 4 were just not enough by I I
really thought that making everything
with 4 up codes would work but it would
be too slow so I started adding more and
more up codes to do along things and it
was without any system on the hidden
miss basis I tried to backup codes to
save memory
I tried here in their optimized
prototype it was really easy in Erlang I
really love writing this tool inner lock
and it turned out that I will eventually
have huge code the virtual byte code it
will be big and I don't have so much
memory I started realizing I want it to
be very small I'm targeting
microcontrollers so at some point I just
separated this problem I will have to
work with code size later let's make it
work first and then another problem J 1
has 16-bit words for op codes and that's
not enough air long runs on 32-bit
minimum to encode all the good stuff on
the integers all the pointers all the
words they have 32-bit size it does not
fit in 16-bit I have to do various
clever tricks to encode longer integers
it also it was progressing I I started
like working around and going here and
there trying to make it work it almost
work for them I just noticed the
complexity grows out of control
so these are the opcodes I defined +4
marked the original j1 and I noticed
that the more my language grows the less
I'm using or I'm not stopped using at
all those chores for opcodes they just
have different semantics
they don't map to air long at all and
the new language looks more and more
like beam and less and less like forth
so do I need forth here at all it I
asked myself
so probably 16-bit fort was not ready
for this
what a surprise but still the idea was
very nice having a small fort supported
wrong interpreter is still possible but
I will have to come to it again maybe so
well we may have a long CPU eventually
from this it may ruin it it may run it
at a good speed possibly just not yet
but I tried this I liked it it almost
worked
now new round of ideas this one was
short but very promising so let's look
at lvl I said to myself since I have
around I'm library for a long anyway
it's in C++ it has all the types the
processes with all the stuff along needs
I already have and so let's compile a
LAN module to learn VM it also had a
single static assignment as I say so I
just keep assigning names to numbers and
it all works well in theory a pleasant
coincidence I thought to myself but then
also why I was thinking to go here I
believe that I may save some code size
so typically when you load beam in
memory it expands by the factor of 4 to
6 1 64 bits beam growth 6 times so it's
not really good for micro controller
because Airlines core application e es
is 400 kilobytes and my goal was to go
on the top megabyte and it will bloat
it just not something I really can
handle at that size
so I decided maybe LLVM can help me and
here I did my first mistake the major
mistake for this project I took airline
HT less the airline first airing it was
going almost well but the complexity
exploded too fast if I come back to this
idea I would have to go somewhere down
the pipeline like Colonel for example
because it has so many things
conveniently compiled for me
so they took too much focus and brain
power to get this going
the VM is very good stuff for this it
could work in theory but it's really
slow to build I must use the source
because from libraries is not really
working if I link with libraries well it
didn't work for me I had to build from
source source is huge is like five gigs
for my virtual machine the the
VirtualBox that's too much well it
almost and it brought my virtual machine
down when linking it so and it builds
seven hundred megabyte executables so
must get almost a gig and so I I was
thinking to myself is probably too big I
need to take it out on my computer not
in virtual machine that's too much and
hot code loading would break it would
never exist because I am linking I'm
statically linking on to make her own to
flush it on the chip so this was
basically a deal-breaker for a long you
is the selling point you you don't have
code reloading on a anymore you have to
reflash you can just push one module and
reload you have to refresh the whole
thing so this was the cool idea I liked
it but it it was too hard to build well
it's like too slow it was too slow it
was the complex thing a team could make
it not me alone so team probably does
JIT now in in Eric's on nd they face the
same complexities but they have more
power to do it
now a moment of helpful references
reference how how which or machine works
how OTP works as well is the same
principle and I'm using it as well so
imagine you have a beam file which has
up codes and arguments encode it in some
compact way like 8 bits here 16 bits
there up code 8 more beads one by top so
it is like six bytes or seven bytes then
when the virtual machine is starting it
enters the VM loop function which has
labels to do every op code but labels
are internal to the function you cannot
see them from outside so you have to
enter it first with the let variable set
to true it will jump down here fill this
global array conveniently for me and
exit then I can load this code I see up
code I take the label zero put it here
for byte gone
I see argument it's small but airline
has everything world size it becomes
four bytes here 32 bits gone then expand
as well up next up code I take address
put it here for mobiles former bison and
it blows to 24 bytes now but this
approach is well known to me it's used
in all the virtual machines we have now
in Erickson's OTP and in link as well
the UM approach this is the fastest
approach and the next tweet goes switch
case approach when you just store up
code instead take them to switch and do
some magic jump to next take it the
switch the magic this day next by speed
what is like 20% faster so I decided to
do the familiar way it's not memory
efficient I will have to redo it later
but that's not so hard so this is
basically great data from Wikipedia you
can find
how different trading models work this
is directory trading this is what we use
in our virtual machines everywhere and
then when the time comes to run this
code we have loaded we enter we have
loop again within it false
it skips to hear it I omitted some code
we do go to address we just take this
label a jump to it jump here do
something go to next
it sees B jump here do something go to
next and so on so this is very fast it
jumps it's like it's threaded execution
is studied through the VM loop and does
the magic does the work and it's very
fast it's the fastest we have before JIT
now the last project which is running
now it's most successful so far I like
it most it's not so well not so advanced
like the first one but at least I have
gone now I wanted small I want it to
feed on the small things
now I had to invent a custom beam like
format why because I want to have
reprocessing done ahead of time and then
I don't need this code on the virtual
machine on the chip so I save space here
that's why I write some prepared format
and now it is similar to B but not being
exactly and it's also like a long go TP
this is a direct reddit emulator which
uses go to table I'm aware about
different ways to do it for more compact
code I can use Huffman coding to encode
up codes in a few bits as possible
according to their frequency and this
idea here is to the use instruction set
OTP has hundred fifty-eight instructions
up to date and I'm I have like 30 or
around 20 but it will grow and the rest
of the work is of
loaded two beefs so two ways to
represent the code and and and this is
what I've been talking to so to run
faster
I put label addresses in memory and
arguments follow and they all take full
word so this is the fastest approach
it's absolutely not efficient memory
wise I'm losing so much memory here so I
could improve this but being on Intel
this is very easy to read single byte
it's cheap intelligible talks single
bytes when I come to armed access to
single bytes becomes much harder because
lower our models don't allow unaligned
reads on addresses that are not
multiplies of four and higher our models
are more lenient to this they allow it
but it's lower they still have to read
full byte full word so approach to same
memory would be to place one byte here
with opcode some argument some shorter
argument another opcode and so on well
similar to Huffman coding which would
use bits instead of bytes too because
some some frequent up codes can take two
three four bits instead of eight so this
is so the lower one is how I do now and
this is the same way how addicts owns
OTP does now the library code that's the
biggest problem I have to come to
approach and to solve the library code
is is really big huge the elts has four
hundred kilobytes of beam files I can
probably shrink it just removing the bug
in foreign compressions here and there
but still is too much then standard
libraries three megabytes but I don't
have to store everything in memory I
just need few modules and everything is
absolutely blowing so I I will
definitely have to solve this just after
I have it working yeah after I have it
working I will have to shrink it cut
their functions aggressive unloading
compressing the Huffman code
for for code and so on and probably I
could even do garbage collection on code
I think it was your Armstrong to mention
it somewhere in mail list or on one of
the meetups that you could garbage
collect code per function here is my
current progress you can you see the
color as well so the black ones are the
best progress I it's mostly done it work
site I'm taking pieces from the first
project that's glue on VM the blue ones
have measured progress so they work
mostly they don't they're not complete
the time happy with them so transpiler
is proof of concept is ready and does
the job code loader is fine I will have
to redo it for new format if I changed
the format modules are fine but I will
have to add more aggressive code
management here VM loop is not fine but
I have it in blue and I will take it
that's okay
data types mostly done except few things
like maps and binaries I will come to
them major and minor op codes the day
they are not done but I have them so I
will just migrate them major beefs as
well I have the stuff that was needed
first I have it so I will migrate it
from glown the green stuff is the stuff
that's not there at all but I know how
to pull it off I had the knowledge so
you see I know running on arm
I understand how are more I played with
the simulator I played with the board I
took a couple of programming courses so
we are coming there I the simulator i I
have the the 384 K simulator that I can
play with those arm so distribution I
currently do the Python airline node in
Python so distribution protocol I'm I
work with it right now I know how it
works so distribution will come easily
and then I can report
how what what can you really interact on
a chip without external chips so you
just have GPIO pins that's it unless you
plug in some some shields but Wi-Fi news
being everything so that part is unclear
and hardware drivers that's unclear
until I have the use case I I'm not
doing it because I don't know I don't
know what will be needed and the
library's sighs I just discussed as well
as network so there was I have no idea
how to do network but I will have the
embedded OS under me that's like that
possibly has disappeared I think I can
enable it so that part is that part is
not not carrying me much will come there
now that I cleared everything for me the
what's in front of me was waiting for me
I don't know exact platform where my
project will be running I'm just
targeting the biggest family of farm
processors and half megabyte limit is
self-imposed I'm just trying to limit
myself and limit things run running the
drivers I just mentioned I have no idea
what the hardware I will have but we
will begin with the at least disk
storage and maybe GPIO so the busy word
goes from there and I try to keep it
super small so to like to cut off every
piece of work that's not immediately
needed to have chance to finish it and
it's still hundreds of hours of work now
that I have created this presentation I
look back at the evolution and it makes
perfect sense to for me to create a
special edition for Erlang like smaller
Java is even tiny Java EE and Java him
he requires just 30 kilobytes run it
runs on your SIM cards in your pocket so
and on your bank cards as well so you
can call it a link embed it or give it
any other name but it would be something
that I can direct my feet - and make
embedded small subset of a long of
course there will be no
no point of discussing compatibility
with your legacy code and running your
business logic on this tiny interpreter
but it will still be along it will still
be limited and it will fit and you will
have to write for it
not from your legacy on it that's this
the latest idea the last idea I got like
yesterday makes perfect sense to me wait
because it otherwise it will go in
mangle the count will go up two
megabytes it fit everything to run
everything it will easily hit megabytes
I'm not I'm not reaching my golden so I
will need all support I can get from the
members of community I need your
comments ideas possible use cases hints
what I can three make smaller and so on
so the project is a bridge it continuous
it in full at full speed thank you
well am i planning to do it fpj it is
something that became possible when I
looked into j1 for j14 has very simple
VHDL implementation so I in theory I can
build on top of it and I can make it run
in just make may be extended to bigger
bit width so I can enter code bigger
numbers but in theory it could be
extended to run like this I just left
this idea as promising and moved on but
it's still there it's in my head I
remember it so a long CPU is possible
but not in in with the 158 of codes we
have now that would be to be good and no
FPGA will fit it
runtime is my own it is the C++ source
with data types with everything I need
with beefs but the processes messages
scheduled in everything is there it's my
own so that the first screenshot I've
had like 20 slides ago these this
everything is my code it is being
written from scratch so if this is the
wrong time and it seems quite small it's
like this one that can do this it's
about 35 kilos without C library so the
C library can be maybe 50 or 60 I guess
it course it will grow when I rise more
beefs and I do everything to grow but
not so much thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>