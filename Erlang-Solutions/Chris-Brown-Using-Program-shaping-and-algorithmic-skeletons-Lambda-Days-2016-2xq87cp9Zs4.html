<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Chris Brown - Using &quot;Program shaping&quot; and algorithmic skeletons (...) (Lambda Days 2016) | Coder Coacher - Coaching Coders</title><meta content="Chris Brown - Using &quot;Program shaping&quot; and algorithmic skeletons (...) (Lambda Days 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Chris Brown - Using &quot;Program shaping&quot; and algorithmic skeletons (...) (Lambda Days 2016)</b></h2><h5 class="post__date">2016-04-01</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/2xq87cp9Zs4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">start by saying it's not all about me
we've got quite a lot of people working
object that I'm going to describe today
so and there's a few of us from st.
Andrews Adam is a PhD students he did a
lot of the work here I didn't really do
much on this I'm just here to present it
and take all the glory but really Adam
was a guy who did all the work void
check and Alec from Poland what check
you probably know if you have any
questions about what I'm going to
present today come and see me void check
colic and we'd be delighted to have to
try and answer anything that you might
be concerned about so what are we doing
at st. Andrews well we've been doing
obviously you've research for a long
time 600 years but recently we've
established quite a lot of collaboration
with with EU partners one of this is a
new EU project called rephrase this
started about 10 months ago in April
it's quite a large project it's three
and a half million euro budget so it's
not it's not a small project we have
quite large partners some huge mega
corporations I IBM we've got other big
commercial partners i evil pro I've also
got a lot of academic collaboration
we've got university of pisa Madrid you
can't quite see that but that's Torino
and what I'm going to describe today is
work that's come out of this EU project
and so it's ongoing work and we still
got over two years left of the project
remaining so anything that I'm showing
you today is really kind of early days
it's not established research so what
are we trying to achieve I'm guessing
everybody who see has gone to university
and studied computer science if you
haven't then don't worry
I guess what your lecturer always tells
you how to program like this right see
also perfect distribution puppies to
sources nothing can be described so
although all the puppies get the food
however what happens when we go out into
the real world we get a job we want to
start writing this code or this usually
happens you get absolute chaos so here
you get everyone fighting for the same
resource puppies always very boisterous
and it's the same with power lism it
nothing ever works out in practice so
everything that you're taught in the
classroom just forget it basically none
of it none of it works so I'm going to
tell you today is basically how to do it
properly so some of the real challenges
that we have to face when we write
parallel software so the things you were
taught in the classroom the things on
the left they don't really exist
unfortunately it's a theoretical
assumption so what we're trying to do is
to solve real problems I know this is a
research track but this is really
applied the research i'm showing you
today there's no theory there's no
horrible Greek letters don't get worried
about that we're doing real software
engineering work trying to solve real
challenges and some of these things
include things like building new tools
for testing debugging or parallel
applications things like quality
assurance introducing new standards for
parallel software for writing parallel
code deployment on different types of
hardware this is becoming very hot topic
recently things like CPUs and GPUs and
becoming very trendy also many core
fpgas things like how we schedule these
applications on these big hardware
platforms how do we maintain software is
very important you write software you
need to maintain its you need to deploy
it you need to keep your customers happy
this is how companies make money so this
is this usually these questions I
usually never answered in academic
papers what we're trying to do is to
really try and understand this problem
we really think about it in a pop of
applied way
so what we're doing on rephrase is
taking quite a different approach we're
kind of looking at different areas of
software development so things like
requirements capture design
implementation testing deployment all
these kinds of agile or what fall type
software development practices and try
and apply them to parallel programming
because really parallel program is no
different to any other type of
programming it really needs lots of
thought lots of design lots of
verification to test on that's correct
and probably actually more so than
sequential programming it's much easier
to do something wrong when you're
writing parallel programs so what this
talk is about today is one aspect of
this research so it's called program
shaping and what this basically means is
that it's all about restructuring a
program could already be a legacy
application that you've got so it could
be an old application could be a new one
it doesn't really matter and restructure
it in l.a knows in a way that you can
enable an introduction of power ilysm so
you can enable just to put the power of
them into it very easily usually putting
parlors in the decoder is actually quite
easy if you want you understand it the
biggest problem with it is that most
programs they're not in the right shape
that you can just put the power lazim in
so people do it in all these incredibly
complicated ways which is really not not
the right way to do it and usually don't
get much parlors and out of that as a
result so what we're doing is taking a
different approach first you restructure
your code to make it a nice hygienic
safe type of application and then you
introduce your parcel into it and for
example some of this might include
things like moving side effects so side
effects I really don't want side effects
when you're having something running in
parallel because things can interfere
seems quite obvious but a lot of people
overlook that things like eliminating
dependencies a dependency is sequential
okay if you have something that depends
on something it's sequential you can
never paralyzed something that has a
dependency okay you have to remove it
might seem counterintuitive but it's
it's that's that's life unfortunately
most of these approaches are quite
ad-hoc so people just do this by hand
you get a you get a enough
vacation and you just randomly try and
change it until you get something that
works okay this is very non-trivial it
requires a lot of knowledge you usually
have to be an expert in the application
that you're writing if you were working
for a big company you might be given
something with thousands of lines of
code you really need to know the call
very well and very detailed to be able
to do this type of work and ensure that
it's correct you also need to know a
little bit about the language how do the
libraries work out of the language work
how can you exploit it you need to know
about powell ism you need to understand
how powerless and works in the
particular language you're using so
there's quite a lot of things you have
to think about and juggle to do this
task properly so we're going to show you
today is a technique called refactoring
which I'm sure everybody has come across
we're going to we're going to use these
refactoring techniques to kind of
automate this process so automate the
process of restructuring applications so
then you can just introduce the power
ism which is almost a kind of a trivial
step afterwards hopefully that'll make
sense later so what is refactoring or
refactorings been around for a long time
it's the academic way of describing it
is a conditional source to source
transformation that preserves functional
correctness okay which is almost
meaningless I guess to most people what
it is it's it's a tool that allows you
to restructure cold so if you use
Eclipse you can do things like we named
variables you can move classes two
different functions you can you can add
parameters to things and the tool will
do all of this automatically for you so
it will do all of the checking they
won't let you rename something to
something that already exists for
example it won't let you move something
to a file that will introduce conflicts
etc so it does a lot of all of this
automation for you and it also rewrites
the cold and lets you see the result
automatically so we're going to use it
for parallelism and they help you with
this process because they avoid
introducing evers so a tool can do all
of the work for you you don't need to
think about how you're going to write
parallel told it knows how to do it so
just let it do it you basically you can
you can give some input and you can
choose from a huge range of
possibilities and then just select the
one you want
it's quite quite easy the work today has
actually been implemented in a factory
tool called wrangler which is
implemented for airline this has been
around for a few years now is originally
developed at the University of Kent it's
an extensible tool so you can build
refactorings into it and we've exploited
that and work i'm going to show you
today builds on top of that technology
and but if you're not using Erlang it
doesn't matter the what i'm showing you
today can be applied to any language
it's completely generic so don't think
what i'm showing you today only applies
to Erlang it doesn't okay it's a high
level idea that I want to get across to
you so another piece of technology that
I'm going to use is something called an
algorithmic skeleton so people probably
have seen these but they've never heard
the term there's basically just a high
level abstraction it's just a function
okay function that encapsulates and
parallel behavior and that's all it is
so just think about these things is just
normal composable nestable functions in
principle the idea of a skeleton is
completely language independent if you c
plus plus you have parallel skeleton
libraries I TBB OpenMP Erlang we've
implemented of all library i'm going to
show you that in a short while pascal
you also have equivalent libraries
doesn't matter whichever language you
have the ideas apply to it and they work
by your only kind of problem specific
cold so you only concentrate on the part
of the cold you want to paralyze the
kind of the building blocks of the code
and then you plug them into the
skeletons and then in that time you get
a parallel program typically they're
implemented and collected in libraries
so you just call a function in a library
and you get a parallel program as a
result yeah by the way if anyone has a
question please just shout it out don't
think you have to wait until the end if
you don't understand anything so these
are just some examples of kind of the
common types of patterns that we see
most widely used in parallel programs
the one on the Left T is called a
parallel pipeline so the way this works
is you've got some inputs some data here
at the top
you've got some functions so think about
this like a function composition kind of
a nice way to think about it so I've got
some functions here I get take one of
the inputs off x0 I apply a function to
it I take the result of that I pass it
to the next function which computes on
the result of that and so on and so on
and so on and where you get the power
lism from this it's not each of these
functions can execute in parallel ok so
while this this second function is
computing the result of this one this
one can then get the next input and
start computing and so on and so on so
you get pals them that way on the right
is kind of a more I guess the more
intuitive type of houses a data parallel
pattern this is called the task farm
this works in a similar way you have
some inputs you have some data you want
to compute over you have a function and
what it does is it takes these inputs it
sends them off to this function which it
distributes in parallel they all turn
away on their results and they spit it
back out and you get some kind of thing
that puts it all back together and then
you get the results here so the power
ilysm here is you can basically take an
operation and put it on different
threads or different cause so that's
kind of a data parallel operation seems
obvious probably but when people try and
do this I don't usually think about
things like this I see people write an
airline code and the thinking things
that spawns messages receives really low
level you don't want to be thinking like
that it's really not the way to do
partisan these are nice simple
high-level concepts which I think really
kind of get the idea across very well
another example is a feedback so this
basically what this allows you to do is
to take any of the skeletons for example
the ones that I've just shown you on the
previous slide you plug them in here and
you take the output of that if it
satisfies some condition you well it's
kind of counterintuitive it doesn't
satisfy a condition you stop you
terminate if it does you just plug the
results back in so it's basically just
like a loop so you can get the parallel
operation then you can keep looping
looping on it and of course these
patterns are fully nestable you can put
farms in pipeline
pipelines and farms etc so we
implemented a library for Erlang but
basically is a parallel pattern library
it's called skel it's available at this
website you can download it you can try
it it contains many different types of
patterns things like pipelines farms
feedback all sorts of different ones it
also contains hybrid skeleton so it
allows you if you've got a GPU on your
system allow you to use that GPU out of
the box you can download the librarian
and start using gpus we've got various
things on the website tutorials podcasts
all sorts of things so if you're
interested please go to the website
download it take a look thank you and an
example of how it works this is an
airline a simple map operation in Erlang
we've got calling map function here
we've got some function called worker
and some input and if you want to
paralyze this operation all we need to
do is change that that map operation
into this thing on the bottom and what
this is doing is it's calling our scale
library with a farm which is the task so
the data parallel operation that I
showed you where the the operation is
going to be worker with the same inputs
and W then could be I don't know might
have four cores on my laptop so I put
four and I get four copies of my worker
and then I get the power lism so it's
quite simple and if intuitive so it's
almost like a map but you have to do a
little bit more work but not very much
so what I'm going to show you is how to
how we're going to paralyze a
multi-agent system so a multi-agent
system is built up basically in three
steps firstly we've got agents which are
intelligent autonomous entities that
solve some problem so some function or
worker solve some problem and we've got
multi-agent systems which brings many of
these agents together to form a system
so they work together and then an
evolutionary multi-agent system combines
these multi-agent systems together with
some kind of evolutionary algorithm so
some kind of way of evolving
some kind of condition it's highly
parallel because the agents are
independent however it's not quite as
simple as you might think so what I've
done is I've simplified the structure of
the application and kind of broken it
down into its main components here what
we've got to you is a number of
operations first we do some tagging then
we build some migrants doesn't really
matter what they do it's not important
it's the structure that I want to get
across we do some grouping of the
migrants then we send them to agents and
then we shuffle and then we repeat and
so on and so on so there's kind of a lot
of different stages here that have
dependencies here we've also got loops
so we've got things that it of eight and
then we've got something that that kind
of feeds results out so looking at that
it's not quite clear exactly how to
paralyze it probably okay I could show
you the cold but most people don't like
seeing cold I don't like I hate seeing
cold and talks I just can't read it it's
just don't like I just I just see mess
and I just can't see detail but anyway
this is the code it's quite complicated
it's several tens of files hundreds of
lines of code this is kind of the main
part of it but want to want to show you
is how we can use our program shaping
refactorings to break this down and make
it parallel so we could do is simply
introduce a farm so everywhere we've got
a list comprehension in the code like a
map we can just make it a farm right it
seems an obvious way to make a parallel
the problem with this is it's incredibly
actually incredibly inefficient and
creating the farm itself actually has a
lot of overhead so spawning process is
annoying is actually very expensive it's
not people think it's lightweight but
it's not light weight at all the problem
is if your tasks are very small the
overhead of creating the farm just
dominates it and it actually slows your
application down quite considerably also
the function loops and so it compounds
all of these issues every time it
iterates it's it's again setting up
farms and the whole thing just blows up
and you get this huge overloading
explosion of slowdowns and you
just doing that it's much better to try
and express the parallelism in a single
operation because that minimizes the
overhead of creating all of the
processes you want to minimize out as
much as possible okay and just have one
place in your cold where you do the
power lism much easier but as the cold
stands we can't do that it's too
complicated conscious we can't just make
a single operation parallel so what we
need to do is you need to first divide
up the code into components so these are
kind of atomic operations things that a
side effect three simple functions that
do simple computations and then all we
can simply need to do is just arrange
them and we're going to use several
different refactorings that we've got
and i'm going to describe in turn so the
first thing we need to do is to use this
function called extract composition
function which takes all of this in
lined cold here and makes them into
functions that we can just call okay it
seems quite obvious most people overlook
it so once we've got that that nice
structure in place we can then start to
group the operations together so the
first one is to group these three
operations into one single operation so
we use another refactoring called
compose maps so it composes these
together into one operation after we've
done that we can simply introduce a farm
here into this component here and then
once we've done that we can then further
paralyze it so want this is already a
parallel version of our application but
now that we've broken it down into nice
steps into nice components we can
continue to paralyze it so here what
I've done is I've introduced a pipeline
so here's the first stage the second
stage which was the farm the third stage
and then additionally on that I've
created a pair feedback so I've also
made that a skeleton so broken this down
into into three different types of
patterns a pipeline pattern a farm
pattern and a feedback pattern okay
and the results what I'm going to show
you is just two different versions of
this e mas we've got basically a
concurrent version so this is if you
just read Joe Armstrong do Connor lang
this is how you power lies in a line
application second one is a hybrid
version that basically takes our scale
version our we factored version and
tunes it much more these are the
optimization optimization benchmarks I'm
not going to go into the detail it's not
really important there was also very
interesting so what I've got here is the
blue line this is just the bog standard
airline version out of the box a line
using spawn sends receives etc so you
can see it kind of scales and then it
just well just tails off if you don't
really get much more than 20 speed ups
on 64 cause which is not really very
good to be honest busy using scale so
using our refactorings in our scale
library we it scales much better kind of
over 40 speed up and then using the
hybrid version so taking that scale
version then tuning it just a little bit
more we're able to push it to almost 0
just under sixty speed up on the 64 core
machine so you shouldn't just take what
a language provider gives you as a
parallel implementation it usually
doesn't work you need you need to think
of it more intelligently about it this
is just to show that in some cases
actually the results are more or less
comparable to textbook versions however
it doesn't matter because our what we're
doing here is saving you enormous effort
in your coding so just using a
concurrent version der line version you
write something like over 350 lines of
code takes you seven days these these
were anecdotal results given to us by
our partners on developing this software
the sequential program already took
eighty five days of effort so these are
f this is effort on top of that 85 days
so if you're a company writing code for
customers this is very important okay if
you go over schedule because you're
writing parallel cold you're really
going to run into problems so using our
effort okay get there's still 100 lines
of cold but it takes a day of effort and
that's it I'm just going to wrap up so
what we've done is introduce some
program shaping techniques ease allow
you to kind of introduce powell isn't
very trivially into a code by just
simply restructuring it so then you can
just think about the parallelism other
than all of the nasty details we've
gained very impressive speed ups at
almost zero effort do you a programmer
effort and we of course we can apply
this to other languages as well as
future work is basically just lots of
more use cases lots more patterns the
usual stuff and things like static
analysis techniques we can automate this
process rather than it being a user
driven process and that's basically I
believe my times up so thank you very
much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>