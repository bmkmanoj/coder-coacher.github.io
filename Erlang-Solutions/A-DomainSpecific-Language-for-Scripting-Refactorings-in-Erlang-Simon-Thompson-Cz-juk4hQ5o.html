<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>A Domain-Specific Language for Scripting Refactorings in Erlang: Simon Thompson | Coder Coacher - Coaching Coders</title><meta content="A Domain-Specific Language for Scripting Refactorings in Erlang: Simon Thompson - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>A Domain-Specific Language for Scripting Refactorings in Erlang: Simon Thompson</b></h2><h5 class="post__date">2012-05-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/Cz-juk4hQ5o" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay so what I'd like to do is talk to
your tiny bit about refactoring what we
do what it's about what we do what we've
done in the last few years in building a
tool and what we see the root the
realization came to perhaps a couple of
years ago that what we've done was was
fine I mean were pleased with it but we
realized that some limitations and that
was to do with it not being extensible
so what I'll talk then about how we've
chosen to extend it and they're two
different extensions we've made I'll
talk about those both but a micro
extension inaudible macro extension and
then I'll concentrate on the latter and
do a demo of that okay so refactoring I
guess people have been doing this long
before people use the word refactoring
you write a program and the two things
you might do to the program once you've
done that you might change it to change
what it does but you might also change
the way it does it perhaps because you
want to make another change further down
the line Pat because you want to change
an implementation to make things more
more efficient so often we have this
cycle where and this can be a very tight
cycle where you do this as part of your
development or it can be a cycle much
bigger cycle where you build a release
and then perhaps refactor to eliminate
problems and module structure or
whatever so that's what we thought I
mean where I talk about refactoring one
reason we might do it is and one of the
things that people use our tool for the
most arm it's just if you see a piece of
functionality that you want to reuse
then you turn that into a function so
typically what you might do is is spot
that you've there's something you've
done that you want to reuse what you'd
like to do is be able to select that and
turn it into a function and so where is
originally appeared you got a song she
call and you get a function that
corrosion and then you can reuse it just
like all your function again so that's
one example of why you might do this
another is you know as try and go
on our systems might they start off with
me beautifully regular and so on and as
we modify things they get less regular
we've got ad hocs leaks from one module
to another we got copy and paste has
gone on so we've got software clothing
across our project so we want perhaps a
contract decay and perhaps to understand
our software all the better okay so
that's the reason why we might do this
how do we do it well and it typically is
a very nice study I've got the reference
little bit later on people reckon in the
Java world night percent of refactoring
is done by half though there are
refactoring tools but if you identify
what people think of as refactoring a
lot of it is done by half in edit it's
flexible you can do changes which only
you know will preserve what your
programs the meaning of your your
program but some things are simply
pleased about if you're going to do than
by hand so you really do need have a
tool um and not simply because of the
size but because of the things you have
to check when you're when you're
implemented way of performing a
refactoring you have to worry about
inner line at least how items in use to
denote different things and at'em here
can mean a module left and say out of
here means a function the same atom here
means a registered name there with side
effects and so on and so forth so it's
all can support that sort of that sort
of analysis so what we've done is build
a tool called wrangler and what we
started off doing was building a whole
collection basic refactorings and
structural refactorings like all
function extraction and so on a lot of
remainings macro death microextraction
some time to do a process process
structure some to do the test framework
what we found when we done this was
people say ok that's fine um you've
given us these three factories but what
we want you to do as well is tell us how
to use them so what we built on top of
that were two things which provide
decision
support I don't have time to demonstrate
these today I'm sure some of you have
seen the demo before what we can do is
clone detection across whole project and
you can tune that according to size the
size of clonely how closely the similar
code is a whole lot of parameters
allowing to tune that we can also do it
incrementally so over a large project if
you're looking it up hundreds of
thousands of lines it takes a while to
do an initial term retention but then we
can do an incremental detection which
will only look for clothes that have
been introduced by the changes you've
made and people find that very helpful
and we've worked with was the figure
particularly in refactoring test code
where we find a whole lot of copy paste
programming going on the other thing
we've done is produced a report on on
module structure for instance detecting
circular inclusions of modules there are
situations where you want to do that
it's practice for two to have to point
it out to you that you're doing that and
then we can we provide suggestions of
how you might move functions between
modules in order to to clean up module
destruction so that's what you've got if
you take Wrangler out of the box what
we've done is automate simple things and
provide a city support on top of that
it's a dependent in Emacs and in li yi
it's built an urn and we used it
ourselves it's been very helpful for us
find a circular logic module occlusions
also remains and so on function
extraction we use it a lot our selves
what it looks like embedded in Emacs is
this you we have a lot of refactorings
we also have a lot of code inspection
functionality
but somehow you see up there cinema no
protection what your structure what I'm
going to be talking about later on this
is how we can support avi on migration
and these January fax these
user-contributed refactorings ok so I'm
you're not going to do a demo of the
main stuff here instead here's the
scenario we built this tool you take it
out of the out of the box as it were you
unpackage you connected up and you find
it doesn't have the refactoring you want
you can swap two arguing position so you
want to delete an argument in a function
where where that argument is no longer
used perhaps it isn't another
refactoring oh so the seeds of icing but
he's not provided because Wrangler looks
like this big black box now there are
two before we did our extension work at
least there were two ways that you could
get around this one and the most the
most efficient is to talk smile sweetly
to a king who does the implementation
work and say I'd like this refactoring
implemented please and that's you that
is usually good way of getting it done
but that limits our bandwidth the
alternative was to learn all about the
internal representation that we news so
to learn about we extend the standard
Erlang sit at representation from the
compiler putting a whole lot more extra
semantic information on there we have
ways of handling wide spaces on which
which typically the compiler isn't
interested in because we want to make
sure that you get layout that looks like
your original layout once the changes
have been made so in internal to the
system that's quite a lot to learn if
you want to die there
contributor so the question was is there
something in between can we provide
something better something higher level
than this and also something that
everybody can use and what we came up
with were two separate extensions and
took us a while to to realize that this
is what we were able to do I think first
of all we thought we were trying to just
do one thing but I think it crystallized
ability to separate things so first of
all we've got an API which is higher
level than the original API that was
visible just as part of the central
project and we've provided an API that
allows you to describe it tirely new
refactorings from scratch these are
things like swapping two arguments or
deleting an argument and so on we'll see
some more examples some more complicated
examples later on but these are just
built from scratch but the other thing
that you often you want to do is arm is
to compose a more complex refactoring
out of simple ones and this is really
the subject of this tool so this is what
this idea that we've got a
domain-specific language and I'll
explain precisely why it's a
domain-specific language not just an API
when we when we come to talk about it so
we owned on top of that you can build a
single refactoring to remove clothes for
example you can build a refactoring
library
anything I which I'll talk about later
on but in order to get to the examples I
want to give light at the end I will say
to find a better behaved the guy first
now their design criteria for this was
missin keep the programming that like we
assume you're comfortable with that it
wouldn't be using what we using at all
but we thought you didn't want to learn
the intervals in fact he didn't want to
learn how we represented things and so
what we aimed for was something a simple
language which should allow you to
describe transformations in a clear way
rather than a meat either totally
general language that would do anything
you wanted so we are only meeting with a
pragmatic design for simplicity and
clarity we provide integration into our
standard tools like Emacs and ie by
describing refactorings by been a view
so if you can if you can make your
refactoring conform to this behavior by
you finding my callback functions we can
plug it in arm into our framework so you
can preview the read the effect you can
undo things you can get interactive
behavior for free so where I muted all
that stuff without you having to worry
about the hooks into the system for
doing that let's take an example and see
if you like to a rational reconstruction
if I will go to the design suppose we
want to describe this sort of
generalization what we're doing here is
taking got this take a dysfunction out
of that loop or we like to generalize
over that that string so it's positive
as an argument and that means to have
argument there will have to have the
actual argument up there and this is a
this is refactoring we already have a
Wrangler but it's one that we thought
was a good test for our API so what we
have to do to in order to
well despite generalization we've got
failed to describe expressions in our
beds of the heart syntax so we got to be
able to talk about on these like that
that that function call there and the
function definition there got fail to
describe those and we've got then got to
be able to explain how they're
transformed so we've got feel so here's
before is the after we have to explain
as well what the soap is for a
transformation suggesting this file it's
a dysfunction wanting all module is it
across a project and we need that
because we need to know whether it would
be valid some transformations will not
be or look will be valid within a single
module but might not be valid in a
client of you look for that that module
so you have to be to look at that that
sort of context oh and finally we have
to be able to check preconditions um if
i said i want you to generalize over
that sub expression n minus 1 I couldn't
because that involves one of the
parameter to the function it doesn't
make sense to do that so many details
Express preconditions so expressions how
we transform them context preconditions
and those translate into the right
directly nights at the base we have a
template language using Erlang concrete
syntax for describing expression and
other bits it's in fact we can describe
rules on top of that saying this bit of
sin tax returns is Elizabeth syntax
we've got the context available through
through some api functions and we've got
a language a language for describing how
these transformations are applied is it
applied top down across the whole syntax
tree is it just applied in one place and
so on so that's what they look like in
practice are we just enclosed templates
in
macro call it so templates look like
this here's a template that will match
majak at the variable capital n but then
any function name applies the Ottomans
12 so our meta meta variables of these
variables that end with a that symbol so
single at variable will match a a single
syntactic item a double that's one will
match your sequence of items so that
matches sequence of argument sir and for
example here we can match your school
and where we are just first argument the
second argument and then match whatever
remaining arguments there are as a
sequence and those turn little inner I'm
list but you can see here we've got we
don't have to describe the names of any
individual nodes inside the syntax tree
we've just got this directly described
in now how many different ways are to
apply function than I a whole lot so if
you're going down the concrete syntax
route you've got to apply f the one
after one and a and three here are two
three four five six seven ways that F
gets applied and if you're going down
the concrete syntax route the first of
the first thing we found was when we
were writing thanks to transform
applications we were writing center
rules in a very stylized way so what we
do now is we have a general way of
saying fun and fly we've got this macro
and that will allow us to find any
application of other function any of
those forms so it can be a symbolic
application and we have function
described like this and all those hit
covered by that that fun apply so again
that's that's making work making a lot
less error-prone a lot more likely to to
be successful because if you do want to
do this you can we're not stopping you
but we're we're not forcing what do
rules look like well the rule that a
template for the old Cove and extraction
of the new code and the site condition
so an example here and again this is the
lang syntax I hope isn't too forbidding
here what we're doing is saying we're
matching function f a function at with a
list of arguments the condition is that
that function is actually a particular
module function argument and what we're
doing for the replacement code is
deleting a particular variable from that
so we treat leigh-anne aren't at at
turns into a line list and we can
operate it on it as all this so that
gives us a way of describing describing
that I here i'm using the concrete
function application but we can do a
similar thing without what we saw
earlier on we didn't have to get you to
use some we can't hide everything and
you do need access to some of the
information
the annotated abstract syntax tree until
we provide you with a collection of API
functions to tell tell you about which
variables around where tells you
location information where is this
particular identifier going from a
variable time I'm going to the variable
to all findings or a function to find we
do a lightweight analysis of how items
of use so if you have a module s which
has a function s that registers a
process under the layers and you renamed
a function call that you don't want the
module intent and they process to get
renamed at the same time so we knew that
sort of battle analysis and that's
available to you to use okay so we can
do all that stuff and where does that
get it well finally we have we describe
how they how these rules should be
applied across the hall syntax tree and
say it could be done top down through
the full tree or it could be done we
could stop at a certain point as you go
down the tree is sometimes fine what we
do is go down until you reach your
certain point and if a rule succeeds you
then stop you don't fire it in any of
the subject and here you see a simple
example this is a swapping two arguments
you can see here the behavior
this tells you what to do with the input
what end up there are and the props for
them this tells you what to do with
their focus that's inside the editor
what is what is on what is currently
selected this is a precondition check
the check that has to pass in order for
the transformation to work and then
finally a transformation so that's all
you need to do as long as you implement
those four functions it will get cooked
into how the arm the emacs or they give
the arm early refactoring tool and will
allow you to apply it from within there
okay so that covers the API I guess the
key is that that we've got some way of
using concrete syntax with some
additions to specify the sorts of
transformations we want to do right okay
now you guys are subject to the talking
halfway through domain specific language
so what we're looking at here come visit
refactorings we want to put together a
sequence of simpler factories to achieve
something complex um I mean we all love
concrete syntax we all have conventions
some of us like to write identifiers
like this in camel case but i guess the
airline consensus is he right instead
with with under school so would it be
nice if you could write a a high-level
description of a refactoring that turned
all those identifies into camel case
across a project well what you could do
is you could look to the project and
find every identifier looks like this
and this you a single refactoring call
for that but that's going to be
time-consuming tedious and probably an
error-prone so what we'd like is
something will allow us in a higher
level way
to do that this wonderful paper there
are we build systems lots of build
systems and we design them because we
think what we're doing is going to be
useful it's very interesting when people
go out into the world and actually look
at what house how software engineers
behave so this if you're interested in
refactoring I think one of the best
papers I've read in the area which talks
about what people actually do in
practice and one of the things that they
they they found we're about fourteen
forty percent of cases people didn't
diss your similarly factoring but they
want to put multiple refactorings
together so that's if you like that some
justification for us trying to trying to
do what we're doing here okay another
example arm in fact this is my said this
is an example of our plum detection you
see here a report what the clone is
actually the thumb is seeing that these
to identify bits of code are similar
they're not identical see they
difference trip there and in the
destination of a message so here what we
what we give you is a new function
definition which generalizes other two
places with new variables and so on and
as things were what you would get we
were giving that generalized version of
the clone and what you have to do is
paste that into the module of your
choice and if it's just a single module
you choose the one these are eight and
then you'd have to do a series of things
we're typically what you do is you
evening a function you wouldn't want it
to be called a new fund you want to
rename these variables you might want to
reorder the weave
the lunatic a little bit but it's not
clear that's the audio will necessarily
want the main you want to add this new
function to the actual list and then
what you would want to do is
interactively run through because you
may not want to eliminate all the
instances you might just defer 35 you
may just want to eliminate 33 is it so
interactively what right do is check
each of them and say okay if I want to
eliminate that in favor of this new this
new function so that it's something you
can do with the tool as it is but
wouldn't it be nice if we could describe
that in a single repack so that was if
you liked up a saintly a test case for
us now why is this not just a script why
is it not just a collection of API
functions parking is complicated because
if you're changing names of things if I
rename food to bar and I want then to
talk about it I think I've ever had some
way of talking about the original
function potentially or relating food
those two names to go we have to think
about perhaps generating refactoring
demands rather than safety no explicitly
and we have to think about what to do
with failure and i'll talk about i'll
talk about all of these in a bit more
detail it's interesting that there's a
literature of talking about putting
refactorings together that stop
completely hung up about how the
preconditions of secondary factory gets
satisfied by the post conditions of the
first doing all sorts of therapy will
start it doesn't really seem to be any
value if we do bit of rechecking
it's unnecessary we don't care that much
what we like to do is provide the
language of flowers should be useful in
practice so I think where it's nice to
see what the weakest precondition of
blahdy blah is but it's not you can
write papers about it but I'm not sure
it is changing many programs so let's
think about generators what we've done
is change the way that we interface to
our refactoring functions and what we
said what we used to say in the original
our real a functionary factoring would
take a module name pair of function name
arity and any name and just do the
refactoring what we provide now is
something rather rather than
sophisticated so instead of providing
names you provide predicates effectively
so this function here describes all the
modules that you would like to apply the
refactoring to you don't give a less if
you give up a test and the test would
have a list built inside it but having
it as a function allows you to be much
more expressive we provide a test on
function names for but that functions to
be renamed and then we generate a new
name this function describes if we are
going to give it a new name as we
generated and what this results in
forget about aluminum the same what this
phasers back is a list of refactoring
command so that generates we take this
description of a refactoring and apply
it to the whole of our project and that
gives us back a list of refactoring
commands so if you like generates this
script it doesn't ask you to write it
yourself what we can also do is if you
make this true you say you want lazy
generation you can generate 20 of those
commands and
configuration function that will
generate 20 or so you're not generating
huge collections of refactorings so
that's the way we get we get generality
and if you look at the camel case
example we can then describe that
refactoring like this the same locks
apply to every file in project and we
want to apply it to all functions we're
doing the transformation will make a
difference so if you do come up a step
camel space case you get something
different from arm for nourishing and
here what we do is pass the thing that
generates the new names thats a camel
case transformation punch so that's the
way we describe a sequence of
refactorings by that generating
so I say about these if I motion the
other thing is that we can if you have
done renaming you want to start off with
a function foo what to do something to
that further down the line you can use
the macro current and that will give you
them the current name that foo has so if
I will track forward from the original
bag now what do you do about failure and
this is where we got a small
commencement specific language it's
quite possible when you apply a
refactoring you apply to a number of
different situations that things that
you might get faded and there are two
possibilities we call want to make it
the other the other non-atomic and we
describe refactorings or these
composites or components of them as
atomic or volatile so we see something
is atomic if um if one of the parts of
that fails the whole thing fails so it
works as a transaction you I do
everything or you do nothing so for
example if you're generalizing country
and at one instance of the function you
are unable to add that extra parameter
then you've got to abandon the whole
thing whereas if what you're doing is
turning camelcase with capital letters
into camel case with underscores just a
matter if you may see if you're unable
to do that refactoring in one particular
place so some things are atomic someone
on the time and you need to describe
that needs to be described we can tint
we can't in further from what you write
you have to say this portion of the reef
factory is non-atomic but the whole
thing is a time for example we have to
have ways of handling interaction so we
might say and I gave you an example
earlier on where you got
a number of instances of clothes you
might say do it more interactively just
applied everywhere but you might equally
well say this visit the refactoring I
want to ask the user so you're going to
do it interactively as part of the tool
you're going to add each instance say do
you want to do this or not and you might
choose to have a portion of it
interactive and other portions not so
again that's a choice as part of this
little language and finally you get
repetition there are situations make
where maybe want to do things while the
condition is still true or maybe what to
do that exactly what keep asking a user
do you want to do this again until they
say no so this describes a complex
interaction it could be you've got the
transactional access you've got the
interactive access and put the accent
access and you've got the repetition
axis so that's what I looks like a
domain-specific language and it's
embedded in like they know so we get
leverage from the language itself and
here's let's go back to this example you
rename the function rename variables
ryoga's variables what does this look
like in our in our language well at the
top level it looks like this we want
interactively to rename the function
because we want to ask users for the new
name
we then want to rename all the variables
of all new our star so there we do some
generation we check to find all those
all the variables with a particular sort
so it's not one refactoring it's one of
these generated refactor then what we do
to swap the arguments and there we we
have a simple refactoring to swap two
arguments we maybe want to users made
one that once or zero times or a number
of times so we do that repeatedly
interactively prompting each time we
then conditionally put something put
this new function into the export list
if it's not already there and then
finally you do this is following
instances of the clone and there we run
through every instance and that suffered
a place where we can be non-atomic the
refactoring doesn't fail if we don't
fold a particular incident so that it
allows us to if one instance we'd like
to fold fails to fold for some reason it
doesn't matter the whole refactoring
doesn't fail but as a whole we won't
thing to be a transaction so all these
things have to succeed in order for the
whole refactoring to succeed so you can
see this is a bit of a subtlety about
how we choose which sub bits are
transactional yet or non-transactional
which is how the whole thing is treated
so then one second let's see if we go
through demo
well let's have a look at the
refactoring camelcase example
so this shows you I think like this was
in the slides in fact but this is the
whole this is all you have to write for
doing that we've said it's a gem
composite roof rack it's just like it's
a different behavior because it's a
composite refactoring but we still have
oops so in fact there are no inputs for
late for the overall refactoring we're
not interested in focus and then we've
got the description of the camel case
they come off base here we are
describing a predicate / files a
condition on which which makes em
renamed and the renaming country and
then we've got bit of a line at the
bottom it actually does the check
doesn't remain a bit don't does the name
transformation bit but you can see
easily it's pretty straightforward
Olivia if you're happy reading nested
erlang tuples for sure you are and
that's what it looks like and we could
actually try applying it
so here's an example this is a scary bit
so these are in there now what does it I
have a project here and there are a
number of functions in there in fact
alliances valley is other functions in
this test camelcase directory so I'm
going to say no which runs interactively
through all the possible functions on my
green a so getting this as they getting
this for nothing so we say no to this no
to this note of that no to that now
let's say you want to rename this is an
option let's turn that into it a proper
early underscore let's say yes now you
can see we got an error there that's
failed because there's already a
function in that app for we can tear a
report but because this is not atomic we
carry on and we're going to say do we
want to rename this is another function
let's say yes and then we can preview
the changes that have been made this is
using a diff and that's showing you
there's a change in export list it's a
change in the client function there
isn't changing the definition so we've
got that preview and that bass river all
refactoring then you get out for free
that's equipment at quit this
intersection and then we asked after
previewing do do want to form the
refactoring let's say no as it ruins my
example file photo
but that gives you a sense of what you
can do so you're getting full it's
behaving just like a built-in
refactoring you get interactivity this
is track non-trans actual behavior yeah
so that is quite nice let's go on is
what I'd like to conclude with what
we've done most recently what is put
together the API in the dsl so putting
little little refactorings defining URI
factories using the API and putting them
together at the dsl so this was very
nice we've done some work in the fast as
part of the protest project with people
from q faith who build line levels for C
code and as part of that this is Thomas
arts particularly Davis's challenge what
they do is to avoid eating the same bugs
in the on the code they're testing all
the time they put annotations in there
are models at least they called bug
praetorship macros and whatever to do
when they deliver the models is to
remove all of those and the question is
how to do that in a way that is
automated correct and easy to do and so
what we did was find that with the dsl
we could put together a sequence of
simple refactorings some built with the
API and some distilled it so what have
we done what we've got first of all are
some very simple rules this says if you
got a bug condition macro
but condition macro sits in the code he
gets replaced with a false so and then
we do so we've got some simplification
rules that turned off falls into true
and so on so we could apply all those
rules and that gets rid of the quite a
lot of the the this is a keen
transformation but what we want to then
do is do enough simplification to make
the code look like what we do my hand
rather than water what a tool would do
so simple rules are okay but they do
believe us we still get some simple
complex things that remain so we get
things like this we have a case
statement which has a default so we want
to simplify things of that format and so
you can imagine me what we do is simply
jump to the false case and then the
third thing that we found and this is
often the case is that you get um as you
do simplifications you get reverse
things coming into your code so the
resulting see if it's like variable
equals variable too so we in line Liz
variable definitions so to get moving in
the sequence of three refactoring steps
first of all described by the rules but
also built in we can transform the code
to a a readable version and here this is
an example of Thomas sent me just at the
only last week what you see here is that
the the tool has chosen to reef to
simplifying the blue bid to the yellow
bit down there so some quite complex
manipulations have gone on in there and
that's certainly not stuff you want
I am particularly if you're doing this
repeatedly so we've taken a bit of
repetitive grunt work and turn it into a
pushrod operation ok so that was
application won the second application
which you've been on we're just working
on very recently is how you migrate when
some of the upgrades a library how do
you migrate your client code when a
pertinent example is a red X library in
in LA which is now no more so it's been
replaced by a library re but it's quite
actually quite a different library and
so how do we refactor client code to
accommodate that well there's an obvious
answer when somebody makes an API change
got it we've got the old situation
client and old API here's our client and
something's change the API so one thing
that one can do is write a they've done
an adapter module so you can say what's
the problem if you can write it out to
module that is the trouble with that is
is that in the end the quality of your
code that's going to degrade if you have
this happens again for example you'll
have to adapt some of yours you might
have different adapter modules interact
so for this to work what we really need
to do is then migrate that adapter fold
that adapter module is your client code
and that's what we've been working on
most recently so what we do on here
here's an example from reading story and
it just shows how I mean everything that
could have been different is different
so the key the key operation in that
library
something that matches that tells you
where there are three matches are so the
old the old function was match the new
function the way you implemented inre is
to use the wrong approach these are
different so the wrong function returns
a collection of matches whereas match
just returns the first the other lovely
change is that they index from different
they indexed rings starting from a
different number and they also are
different in the way that they handle
errors in the regular expression so re
will raise an exception whereas a match
will return to their a tuple so they're
different in how they index are
different in how they handle errors are
different in the results they give you
but what we got here is sim adapter code
now what we've done is for me an app to
come January successively factories for
the client code so you provide the
adapter we generally refactorings format
and let me show you how that works in
practice
so here is the yeah I won't be long here
is this adapter this is the code i just
showed you and what we generate is this
yuck so we generate lots of stuff of
this format so far how many lines we
generated about 500 lines of
refactorings which handle which will
fold those those refactorings into
easier client code as much as we can
let's just take a quick look at this so
here we got this is a set of a choice
set of uses of red X from standard
library source from relatively recent
versions of the standard libraries so
it's good API migration from rang sorry
only if I sit current file yes now it's
done it and what we're going to do is
preview the results
you can see here we have to do we there
you are to change Lee on the starting
value let's see what else we've got but
you see what's happening on the whole
most cases are not like this one this is
one where basically we've not been able
to do any simplification because it
deals with error handling so we have to
do this try catch because there is an
era Kasich specifically happened but in
general we're not you only see error
handling code where that's important so
here we've got a shorter wait three
nights and three nights so we're getting
we've got the best possible
simplification okay I think that pretty
much shows you what would you do that's
in that it's not village could we go
back to my side so what we want to do
next and I think we want to refine the
detailed design of what we're doing
we're open to user contributions we love
you to write your own refactoring we
hope what we've done is equal to where
you can do that and I think we're quite
excited about how we might apply the
strong linkages because I don't know
anything as far as I can see this is
putting a line refactoring way ahead of
you can do it in most other languages
okay and this is all if you go to a
project web page you can download the
system it's also got it's on github so
you can there's a link to the github
repository there so contributors very
well thanks very much
Yeah right and have you specified yeah
but through a list of illicit of
directions so that's configured in E
much you karai to Elance a list of
directories you explain yeah no that's
right so what we've got a configuration
item in the menu and you just say the
project lives in these directions yeah
have you considered two kinds of
refractories one take something that's
not TV and making energy to a proctor
agenda to using make it compatible with
reebok so that you could just look at a
rebar compared and not have a specimen
record the second one's asked for you
I just wanted game time by golly it's on
our list because I mine is so
unstructured it's quite difficult of it
I mean something we've thought about
it's tricky I think we what would be
nice is now we've got it a way of
playing around with refactorings in a
more lightweight way so we can look at
whether we can be muscle because I agree
in principle it sound it's the sort of
thing that we often do yeah the
complexity of the last refactoring leads
me to believe that you could get to the
point where a reef rebar command to
upgrade to OTP we just go through change
the whole application convert things to
jennifer's importance servers and then
you can start editing the new kobe yeah
not a thing as well it's how much you
trust what we're it's how she trusts
what we've written and what you write
it's not there is emitted by underbody
and you can realize their ego you can
run all your tests so and you could you
can examine we do show you what we're
doing so if you like we did we start off
with this simple thing we generated so
you could read them do it so it should
be comprehensive policy it's not very
pretty I'm nothing the question
is an important and I think other other
refactoring tools how this have this
problem I think they're even monitoring
the ones have been used in for java the
long-period do do sometimes break
people's code if you mean something I
mean yeah there's any question well
maybe it doesn't matter if it breaks it
go too much because if you were doing I
have how will you do it you do something
in your editor which would break the
code and then try and fix the places
where it was program so what we're doing
is getting you more quickly to the to
break your code over the past perhaps I
didn't express everyone but I think that
he died I remember seeing another very
impressive talk about refactoring was
the guy who from Apple who built the
refactoring tools inside the xcode ide
and what was fascinating never seen
saying that this is benign be like 99
cent at a time that's fine as people
will people will clear up the last the
last one percent that's all about
delivering quality of service for people
wear your refactoring huge don't you
show basic
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>