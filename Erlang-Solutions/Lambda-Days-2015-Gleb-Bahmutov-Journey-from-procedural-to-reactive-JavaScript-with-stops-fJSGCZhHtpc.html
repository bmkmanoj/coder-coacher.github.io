<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2015 - Gleb Bahmutov - Journey from procedural to reactive JavaScript with stops | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2015 - Gleb Bahmutov - Journey from procedural to reactive JavaScript with stops - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2015 - Gleb Bahmutov - Journey from procedural to reactive JavaScript with stops</b></h2><h5 class="post__date">2015-04-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/fJSGCZhHtpc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this talk can go either really really
well or very very badly and it can go
badly because it's a lot of slides it's
it's a long journey from another way
people write JavaScript all the way to
reactive I have 87 slides I'm not scared
because for two reasons every slide kind
of builds on the previous is very
incremental so but it's not a lot of
information it's not like a you know
huge slide content and second you guys
look like very small group so you can
keep up right first of all
why am i risking my physical safety
talking about JavaScript you know as you
know from keynote people slap you if you
describe JavaScript language certainly
it looks crazy right like the guy who oh
it's a joke but the guy who invented the
JavaScript doesn't understand equality
he doesn't understand less than operator
it's completely crazy and yet it matters
right so jealous could make us a lot ah
it used to be you know kind of limited
to call backs and sending emails and you
know blinking tags and stuff like that
but but now it's everywhere I can
program using the same tools everything
from from my server to my website to my
mobile to my embedded device everything
so JavaScript is everywhere oh no that's
not where I want to go
if we go to stack overflow and you look
at number of open positions for
JavaScript it's almost a thousand right
who wants to venture guess what
functional language there is right next
to it scholar java okay right
yes and this is very unfair but if you
look at number of open positions this is
not even true representation because
bunch of positions for example for a
camel come from only like two companies
right if you look by a number of unique
companies by language it's even worse
you know anyway so now you are all angry
mob right but it will if we actually you
know discuss things that were most
popular will discuss this dress and a
scholar look it up it's ridiculous
what's that
cooking's mrs. white dress raise your
hand
who thinks it's a black dress exactly it
no I'm not going to get sucked into this
but what's important from language
popularity is that if we take all the
functional people who you know in the
world and we improve them by a factor of
two right to improve everything you know
you know you guys do tremendously we're
still going to make a lot less impact
and improving JavaScript developer
spectrum decide you know this is huge
area and if we kind of can do
incremental steps you can have a huge
impact on software policy i'm a software
quality fanatic because i'm tired of
crappy software it used to be but you
had to install the crappy software now
you can't even go to website and use it
because it's crappy try loading any
restaurant on your ipad you can't use it
ah so I work at cancer cancer is the
startup we in Boston in New York now we
provide financial analytics software
basically we can answer in couple
seconds a question that is on
everybody's mind how does the like a
cold event like cold temperature
Facebook price of bananas right you're
all wondering should i buy bananas ducks
when it gets colder people sit at home
they get hungry should i buy stock we
can answer that so we have the huge
angular application easily backbone we
have originated an angular with a lot of
Python server-side code replication
because we are startup we're still
trying to find with features that are
gonna sell is very modular we constantly
you know based on the feedback rewrite
add new features and it has to work
without you no truant face the customer
pays to access our website and use this
app we cannot fail
wait that's a whale
that's not party my presentation so
anyways we have this app right we're
trying to sell it we're trying to add
features we're trying to make sure it
works and you know the code keeps
growing growing right like every
software we were lucky we will start up
with start from trash we don't have
legacy code we don't have qg no java
hast work at Smashbox I know but lexical
so what we want out javascript code it
to be is as easy to understand as
English or even simpler so my native
language is Russian Russian is very
ambiguous language english is much
simpler but we want our code be even
simpler and
don't know what goes backwards grab the
software
I always want my stock software and code
produce expected results no
like bed was unexpected I wanted to be
simple to task we want our code to work
that means we want to test it it has to
be simple
and finally we don't want to write the
code over and over right you want to
write one widget and assemble it a
larger application want to write simple
processing pipeline reuse it over and
over again so I don't have to sell you
on this we want to use functional
programming in JavaScript to implement
reactive programming patterns right this
is kind of our solution to the code
complexity you guys program you know if
I'm really because you think but this is
a good solution but what happens so what
happened lately is that you can buy a
book it's called functional JavaScript
you can listen to videos Netflix is a
huge company that pushes a lot of
reactive you I you know paradigms using
javascript so you can which buys your
videos they kind of do the same what we
want to do and it has two major parts
functional programming Java Script small
Bureau functions I know your is
impossible but they're kind of clean one
yes
I know I know I hope you would not
notice that paypal is the second largest
company paypal is here but guy moved
from who does it with in charge of you I
about right now came from that look so
he brought the same kind approach I
apologize for netflix maybe one day
who knows okay so we have two parts
right we kind of have a synchronous I'll
talk about a synchronous performance
and then the reactive you I write like
the previous presentation was actually
pretty good right it's all my sequence
of events so i'll show how we implement
what the whole callback how we think
about everything as a sequence of fun
let me just go to computer code lists
okay everything is a sequence of events
browser side service side doesn't matter
and we process all the streams using
very standard very small set of
operations and then you tell this to
your developers and they are like what
do you talk about right and the problem
is we have smart people working for us
but most of people come from languages
but not functionally oriented he become
at all right I came from c plus plus
side I'm a new computer graphics and
computer vision person when I actually
looked at JavaScript development I hated
like I hated it so much because it was
painful right our people come from
Python or maybe Java or maybe even you
know a UI designer who kind of started
in CSS and styles and went kind of oh I
have to implement jquery called back
with something right so you cannot
assume that they come from a camel a
haskell a scholar world right you have
to take people you know before once you
get who are smart but they're not used
to program the web the way you know you
want them to program and now the
important thing is if you look at the
bottom row your developers are usually
especially at startup doing everything
so some people spend majority of time on
the front end some people only
occasionally tied to front and so you
you want your code to be simple enough
that what the person one spends ten
percent of a time working a front-end
can come in fix you know a bag or
implement new feature and not break
anything you know else and leave
it's not a problem or it's not a
question of hiring junior developers
versus senior javascript is huge you add
browser api's and styles and dumb and
frameworks everyone is probably more
proficient in one area if even if a
junior or senior some people just do
jquery and styles I never touched jquery
farm somewhere here right i want to
touch javascript code so we want to take
every developer no matter what verse
skill level right and kind of move it
and train them and get to where we want
to be right so out of all talks at this
excellent conference this is the only
useful because i'll show you how to take
anyone and get them to program in
functional style and reactive pattern
everyone else just preach to acquire
right everyone said or use scholar or
use a camel or elm or closure script or
closure right i'm going to show you how
to take a step and bring everyone to
functional style no matter what the
language is I use JavaScript of course I
cannot jump all the way
yep
okay I have to take bunch of baby steps
I think the internet here is bad that's
why so bunch of steps will go through
all of them it's a lot of steps right so
we usually get people who write you know
it's not imperative it's procedure
procedural code right like playing you
know variables leaking global stuff and
then at most people in JavaScript you
use object-oriented features but we want
to actually go all the way to get to
reactive part you don't have to learn
everything I personally think but if you
want a shortcut you can just look at the
orange stuff but of course it doesn't
matter if I don't show you code examples
or do live coding if you code the tree
in a forest and don't share these hubs
as it really happened so we're going to
look at a small problem we're going to
take an array of numbers we're going to
multiply those numbers by a constant and
we're going to print it we're going to
look at this problem over and over again
and every time it's gonna
use more powerful feature but the code
should look simple and the function
orient so we start a very simple
solution right right there is no syntax
highlighting it's something much and so
this is what you get when you hire a
JavaScript developer right it works
um you know I hate for looks hi i come
from c and c++ and for loops always
cause problems right l like always it
was ridiculous and also inside the for
loop we doing multiplication and the
printing so we mixing concerns so the
first thing we want to do is 22 to tell
the developer to to separate the
concerns right separate multiplication
from printing from forward already
better code this is easy right you can
give this advice during code reviews but
I think overall principle that I always
ask or from myself and from you know my
team is can you make the code is boring
as possible another I'm not saying like
Java boring right like their bows like
oh my god I have to look for like ten
thousand lines of code to find
multiplication and impede I want to code
but doesn't surprise you right so before
looks will always surprise right well
anyway it will drive a crazy using this
that means using what object-oriented
context and assuming but this is what
you think this is will surprise you
using anything not inside the function
will surprise
so
what's the most boring solution to this
problem right a pure functions so
multiplication I can see the print in a
pretty pure missile output depends on
the input sam botta blonde no surprises
very you cannot prove that the function
is pure it's it's equivalent to a
halting problem but what you can do is
prove or test if it's pure against a set
of unit tests so if you write unit tests
I have a tool that takes all your
functions and mangles them up and move
them out of context and it creates them
and then runs the unit tests and if
everything still works and your
functions behave pure just like boring
parents raised boring kids boring
functions make boring pure functions
make boring pure children so if I have
multiplication and I can do a partial
application from left to right using
built-in JavaScript client operator so
this is blank which feature or not I'm
not using anything yet right I'm just
using plain JavaScript I can provide one
argument a or both arguments I can
create a print method very boring code
right no surprises because my original
functions are boring
I know you're bored already but let's
move on to something more interesting so
this was a great language maybe but it
operate on the concept of a list or
array so JavaScript in current version
has an array an array has bunch of
prototype methods methods you can run
like map or filter or for each and
reduce and if this is the best one
because you can implement everything
else in terms of just reduce so you can
use it on any array so instead of for
your for loop you can implement you know
numbers for each and then you know run
your pure functions so you eliminate it
for a look at our company with our
static analysis actually bands using for
loops you have to use for each or you
have to provide an exception like
specifically so we completely eliminated
for loops
we kind of mixed confirms right we kind
of create process number functions just
because we wanted to first multiply but
we can actually pipeline and we can say
number map little function and then for
each print so we can express the desire
or express our pipeline semantically
using built-in methods so already the
code is boring no surprises produces
expected result and is simpler to
understand because it's kind of mimics
the English language
and then you know most of all code just
manipulates lists of data right we get
something from a server we wanna show it
in the table we want to compute min and
Max we want to compute maybe the
standard deviation we want to you know
show it as a graph or anything we
manipulate bunch of data and so what we
notice is or what if we use building
methods like map filter for each
sometimes it's not enough right the list
of built-in methods is pretty short but
people recreated them using third-party
libraries so usually if I you have to
use reduce I can find library but has
reduced and it has a bunch of other maps
so people think of JavaScript as
you know widgets and we don't crappy
stuff if you look at NPM registry which
is largest public repository I think it
just surprised Ruby but top two out of
the top three most dependent packages I
with utility belts belts of little
functions like map for each and then
bunch of hours blow that called lodash
and underscore which are both lodash is
just a fork of underscore but now it
surpassed it so you can think of this as
a good thing people use functional stuff
in JavaScript and they see the need or
you can think of it as a bad thing
because the language doesn't come with
built-in functions siren has to use them
but the most important thing is that
people using so I'm ready to be slapped
anyway so i'll use lodash we instead of
built-in by and we can use partial we
can pipeline our numbers and run map and
for each we can print that's the same
thing we can combine things differently
in all cases we followed the built-in
order of arguments what means i put my
array first or i run my map on an array
but then people came along and we said
well doesn't it make sense because if i
run my let's say i want to multiply
everything by a constant I usually know
the constant first I don't have a data
yet but I know the constant so if we
have a built-in way to partially apply
from the left I usually know the frost
arguments at inova erasers yet
so there's a new library called ramdev
it just took everyone by storm because
this like smart guys what they did they
enable clearing by default that means
you can just you know partially apply
until you get all the arguments filled
in and you always put the data last so
what we think is a prerequisite for a
functional language right all right
there just you know use this library
create a pipeline of your
transformations you get back a function
and when you just run it on your data
and you profit and you profit because
this is very vegetable if my code is
very very testable it works I can feel
you know good about modifying it I can
sell it to clients and not constantly
debug problems and i can sell new
features so profit
we'll get to that yes don't run ahead
reactive was the very last thing another
cool thing is that these abstractions
this libraries they don't care if it's
an object or a list right they can
usually iterate over everything so you
get more power so just to compare when I
worked in C++ or Java or C sharp I used
to write a lot of these chains like I
need the piece of business logic so
dried number multiplier class and it
would have a method add and I could add
numbers in one by one or all of them and
when I could maybe multiply and then
bring so I write a lot of custom logic
making very smart objects or classes and
passing very simple data like in this
case the date is only numbers right 317
and two but now I I write very or use
very dumb objects right just a list but
I build a very smart pipe line I pass
pieces of logic
and there is very good quote from the
guy responsible for algal and he says
it's better to have hundred functions
operate on one data structure pink list
that rather than have ten operations
operate on 10 different objects so if
you think of your data as a sequence or
a list and you have a bunch of standard
operations
it's a lot more powerful no oh by the
way look it up where is a huge article
of his sayings like that it's hilarious
you should you should definitely find it
out I'm going to skip transducers
because we don't have time unfortunately
at this point we have to say goodbye
not to me now you're not that lucky
first goodbye we have to say is to
return values and which is very weird
coming from you know imperative style
like C Java where you run a function you
get a result you map something get
result notice when we start doing you
know pipelines we don't get intermediate
values and we don't get a result back we
fire off you know this number somewhere
in a nebulous pipeline and we never
actually get anything back right there
are no return bollocks so bye-bye return
values I used to create bunch of
intermediate functions that use the pass
stuff around I don't need it point three
is not pointless right it's if you all
you do is pass one variable you know
from a call back to now a function you
can adapt your callbacks
this is actually much easier to read and
that means fewer surprises testable
easier to understand not break profit
side effects so immutable data
structures are not part of JavaScript
but a whole bunch of libraries nowadays
if you don't use them by definition I
can modify the array at any point and
when my next iteration will just break I
can you know get the library of a shelf
and then all my data will be immutable
but guy one guy came from closing
closure and hero the whole library of
immutable data structures for JavaScript
but a very efficient but don't make you
no clones instead it's like defector so
it you don't pay a lot of performance
penalty for using of a shelf in interval
data
like a back to lodash another
requirement for functional languages
lazy evaluation you download with by
default it's lazily evaluate now very
cool yes
I i was in my polish developer see yep
yep yep
by the way I will not say what country
is hiring but you know why not open the
office here and now the interesting
library is lazy that GS and lazy
provides asynchronous operations on a
list and the first time we actually see
something bad not synchronous but notice
that we using it exactly the same
semantically as we used before it's just
now every number is processed or appears
a second after we're done so now if we
have to talk about asynchronous we have
to talk about promises standard
JavaScript it's all called back base
unbelievable spaghetti code like you
know you hear pyramid of doom and then
always extremely bad so right away use
promises promises wrap a single I
synchronous iteration it either either
succeeds and you get resolved or fails
the best thing about this where error
handling now you can actually handle
errors in predictable manner anyway we
can wrap our number operations in
promises now I told you guys you're very
very smart so you don't have to worry
about anything you will understand this
but actual JavaScript doesn't really
matter I'll point out the important
things in this case the important thing
is i can do sequentially I can do you
know shortcuts there's a lot of
boilerplate and the problem is that for
every number we have to generate a new
promise chain because promisee only
operates ones right so every number has
to set up its own promise and that
creates a lot of boilerplate code and
we'll play this bad so there is
something else called Evan emitters it's
part of no gs4 browser you can get the
library that's where you want to
generate a handle events over and over
right not one slick promise but over and
over and also decouples right the source
of events from processing so if you
attended a previous presentation that's
what's nice so I can create new event
the meter I can say on number print and
mobile after multiplying by constant and
I am using my lazy sequence to generate
events and for every event it will do
something but it's completely couple and
it can happen over and over and I notice
very very little boilerplate I can take
just these two important things right
everything but that is a boilerplate I
can
you know create like little wrapper
class and I can say for my source which
is numbers do something and that's a
functional call back again if my print
and by constant are you know boring pure
functions it's easy to reason about this
and we can decouple even generating
things and if we actually look at value
Novus the user code we take the third
and fourth source will do something and
it fall little functions
and this pattern is used in JavaScript
all the time you know we reach the
callbacks for events like you know mouse
clicks we register communication and
balance or web sockets like I was
controlling this presentation for a web
socket for example so it it's easy right
we just extended the same approach to
anything or everything and yet no I I
feel bad right like I used to do
something like you know map and then
just call back and now i have to do
source and then on action and and what
is on in this case I used to have maps
filters reduced now what on is too
generic it doesn't semantically tell me
what's happening
and also I don't see how we can actually
combine multiple steps it used to be
very quickly easy to create a pipeline
saying map multiply and then for each
print what we'll do here so if we go
back to our original inspiration when we
use our building methods I really want
to create the same kind of semantics
syntax I want to say source of events
map and when the callback could be
asynchronous and when for each and now I
asynchronous stuff and I wanted to work
so I wrote something called Chaney
meters so I took an event a meter and it
said well I'll add a map function to
that and the map will process everything
but instead of just returning some then
it will return another exchange emitter
instance so I implemented map and for
each
and now I can take my numbers and I can
map and for each so this returns another
van emitter and this returns another
event emitter and now i can create
pipelines so that's cool
but now I have sequences of events so if
I don't want to process every number
individually I can for example write a
method called buffer and what it will do
it will keep a little buffer and once it
reaches the full buffer van it can send
the bar for all at once as one event and
now I can for example generate number
every second multiplied buffering Bob
and then send all three numbers all at
once very easy to do wear fur coat looks
nice and clean except it does now two
things right map transform the data
for each you can think of is also
transforming the data right that's
something of a data but buffer doesn't
really transform the data instead it
kind of coordinates with sequence of
events right
again you can think of this as mixing
concerns like multiplication print so at
this point oh the developer who can
start it with like four loops right kind
of wind and everything was very natural
we want them to notice that there are
two different types of operations and if
we keep implementing the stuff over and
over we listen will be boggled in
complexity so
instead of implementing everything
ourselves okay I'll gonna skip this
we're going to just use off-the-shelf
library
so and conceptually we're going to think
about everything that happens as just as
I know an event being emitted
asynchronously just me no sources with a
pipeline maybe sings
and all we're going to do we're going to
write the same code but just reacts to
us so I'm going to use off-the-shelf
library called irex irex is the library
published by Microsoft I think it's open
source everything it has implementations
and bunch of languages javascript is
very popular library it has bindings for
other frameworks and here's an example
instead of me generating a number every
second right at kinda mixing time and
generating numbers i'm going to have one
stream with justina raised timestamps
every second right so that's the first
time event stream and then I'm going to
generate my numbers from an array that
means it will generate a number it's
called after it at each iteration and
then I can see both two streams together
so zip is one of those like sequencing
methods but I never had equivalent when
I just did you know array processing but
once you have to know more sequences you
have to implement this so zip is the
interesting thing it just takes two
streams and when you can pick which
value a we want to actually process or
you know guest pass forward so in this
case I don't care about the timestamp I
care only about the number so I'll
return the second argument so zip
creates a new stream and then I can run
my by constant my little pure function
in this case it runs asynchronously but
what's fine you know it's boring what
can I do why does it matter if it is run
synchronously or asynchronously and
interestingly I i wrote stream number
three here but in reality zip returns
the stream map result the stream and
subscribe returns and alice tree it's
kinda like chained emitter every step
return something else
and now I decouple completely my numbers
right from my time stamps everything is
an observable in this library I can see
both streams and what's good is that I
don't have to use for example the timer
I can use any source of events in this
case i can create advanced from clicking
a mouse so what this means instead of
generating a number every second and
printing and multiplying and printing it
it will multiply and bring the number
every time I click a specific body now I
just removed whole bunch of complexity
from my you i right I'm thinking about
everything in exactly the same
conceptual abstraction as processing a
list of numbers
only now I have to deal with multiple
streams but it's easy
and here's what kind of tour de force
they showed this example for every
freaking reactive library out there and
the example is a smart search so you go
to Google you start typing something and
once you typed a couple of characters it
actually goes and does research and when
shows you of a preview of results and if
you keep typing it will do it again and
again and again implementing that using
modern frameworks soil jquery callbacks
is a pain like you would never imagine
all right and if you actually try to do
it right if you try to handle all the
possible errors and especially we try to
handle for ordering right because you
can you know for fire off a search query
it can take ten minutes and then you
just keep typing you fire off an hour
search query but it comes right away and
then the first one returns and all
sadness you know you typed in like why
my and many type my car doesn't start
but also need to return results like why
my wife thinks of abandoning me no
pressure but this is how easy it is to
do using reactive you can think of all
your keystrokes as a sequence of events
but for original input we just grabbed
key value actually this is a whole text
in the input box we filter that means
we're not going to do anything until
unless you type at least two characters
which makes sense we're going to
throttle that means we're not going to
fire off like every millisecond and you
search we're not going to do anything
unless the text actually changed so she
fired off an event or search and when
you added character and remove it right
away we're not going to fire off
flat map latest the whole thing about
managing the sequence is soldered one
call one method
like I don't have to worry about that
right because this is completely
decoupled and when you get the data and
it's always guaranteed to be the last
data from the last event beautiful so
all reactive damn it with the spelling
are all reactive libraries implement
both are you know array or less methods
like map for each and also all the
stream sink for sequencing methods any
one of them are eggs bacon so just to
kind of conclude our journey but first
step we have to make is start writing
smaller and smaller functions the most
boring functions and then you'll notice
what you don't have to actually write a
lot of a mule you can use off-the-shelf
library or you can reuse the boring
functions you start you know kinda
dipping your toes into a synchronous
processing using promises instead of
callbacks and you find it's actually
very nice and then you can switch to
maybe asynchronous reactive streams
so I've been preaching right I said
versus what I want from my team this is
how we write code so here's our progress
report we've been writing code for a
year and a half so where do we stand
this is not a rating this is more like a
matter of Duke how much we used in our
code so object oriented stuff you know
creating new instances using prototype
prototypical inheritance we almost never
use in our code right we have it for
some data but we avoid it functional we
use both lodash and RAM de and we wrote
whole bunch of utilities what allows the
pipeline stuff like where is no tomorrow
so we actually do a lot I'm almost done
it's immutable data we currently are not
using it but we see and need to start
using it as soon as possible and the
problem is you get piece of data from a
server you process and then you give it
to some other component some our widget
and met widget can modify and add more
you know compute more and now we have to
reason did it compute already or do we
have to compute ourselves so we
reasoning about how data flows became a
problem so we have to use it we're not
using lazy evaluation lazy evaluation is
useful in very specific cases when you
do not you have a lot more data than we
need in our cases we mostly process
everything some promises we use
everything have any meters we use
angularjs where a lot of events reactive
streams still not we're not using but we
strongly considering so what we'll do a
future is bright javascript is very
quickly evolving everything at all today
is over shelf javascript i can open web
browser and your browser and it will
just work
and then where is a new version that
used to be called egg my 66 or at my
script six now is Ahmed script 2015 but
means they're pretty sure it will come
out this year it adds a few bells and
whistles but nothing will change you
know in in a cordero maybe it will be a
little bit shorter but conceptually it
will be all the same and finally this
presentation is available I'll be happy
to answer any questions or I can just
take applause yes
and
so right now the cold rendering is taken
care by angularjs with kind of sinks
everything to digest loop after we
finish processing we have a lot of
charts and tables and there we start
using react so we compute in a virtual
down and when only updates are sent to
actual dance of it and we actually do a
lot manually so for example we have
tables that can have anything from like
one item to look 10,000 so we only stick
in a damn what's actually going to be
visible using you know of a shelf
widgets so it wouldn't find them so not
to brag but I'll brag I wrote a blog
post on angularjs performance because we
were running into performance problem at
some point it was number one in Google
search for angular performance the DOM
is not the slow part the slow part is
figure out what's going to be visible
right and only kind of setting that when
the dam is not the problem you usually
have a lot more data than what you
control I hope it answers your questions
somehow
yeah so yeah
I think our X so we actually tried
implementing with Smart Search a couple
times using different approaches it
never actually worked because of natural
language processing on our back end the
front end was easier I think Eric's now
even includes like automatically try as
one of the methods so you can retry
things so I think if you implement
something it's going to be generic
enough so that you can actually put it
in the library and not reimplement it in
your custom code so that's what we would
strive for can i implement very generic
solution
I think I Rex right now has pretty good
again we could not integrate it but from
examples we've seen Iraq snacks does
very nice integration of angular because
it can update the data and then kick off
they just cycle of thematically so you
don't have to worry about you know is rx
you know done or not so you don't you
actually don't see the integration pain
point I think we actually struggle a lot
more with immutable data structures the
libraries are pretty new and the fast
ones implement completely different API
from the closure script or like really
like we don't want to create a little
data and you know our maps and for each
in a different syntax so our exit thing
is is fine
did everyone kind of give give give you
questions beforehand thread
now
it might be it's also the same problem
you have if you even even if you did not
use our ex right it's not the problem
with Weaver X it's a problem of your
data your pick it's very
application-specific as far as if we hit
the problem again we cannot start using
our X in our code we can resolve like
all the damn performance issues and you
know garbage collection too we're not
relocating the structures over and over
once we hit it we'll we'll see if
there's a way to avoid the performance
in creating a lazy evaluation will have
done yes
uh-huh let's
excellent so the biggest thing is
what program were saying
it's not natural right I'm so used to
for loop which returns the result for me
up like abandoning the return value
because if you move to promises you have
to abandon return values all together
before you know I kind of showed the you
know map and print and you can get in
and say oh it's very artificial
abandoned in return values once you
switch to promises or a stream you have
to abandon anything better mental switch
where was the biggest pain point for me
other people who start programming on on
the front end of said kind of the same
thing like why do I have to use map or
something that doesn't return things if
I can just write my logic and explicitly
so I think that transition right to
asynchronous no return value just create
pipeline an original magic happen is the
biggest point that's awesome said it's
probably for time for in terms of
questions is it a quick one okay last
one last is no okay that's right here
yep
so yes we had a lot of problems but with
amount of data with trying to show on
the screen right which is you can say
it's not JavaScript specific it's more
like in a web browser and specific but
another thing that we kind of noticed
that's why I kind of called it semi
performance asynchronous using promises
promises are slow and they are slowing
up with one browser compared to the next
so we're actually looking at ways to
avoid using promises everywhere can we
grease anklet once again</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>