<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Michał Muskała - Ecto - the Past, the Present, the Future (ElixirConfEU 2016) | Coder Coacher - Coaching Coders</title><meta content="Michał Muskała - Ecto - the Past, the Present, the Future (ElixirConfEU 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Michał Muskała - Ecto - the Past, the Present, the Future (ElixirConfEU 2016)</b></h2><h5 class="post__date">2016-05-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/msdYuidWYQA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody as you can see I have
some problems with fault tolerance but
let's have the the presentation won't
have any so let's stop act Oh
what is happening sorry yeah okay we're
good now so let's talk a little bit
about octo I think
echo is one of the biggest elixir
projects it has opened over 3,000
commits and almost 200 contributors and
I think it's really cool to see such a
big project also if you look at hacks
octo has Oh almost 800,000 downloads so
it's and it's as you can see it's like
4,000 downloads a day now so it's also
growing like really fast so that's
actually the past the present the future
I tried to like tell you shortly about
like how actor looked like what's going
on right now and maybe what will go on
in the future
so I'm minimus Kawa you can find me on
the Internet as me how muscala because
I'm not very good at naming so yeah I
work with great people at will media and
I'm also a student at Silesian
University of Technology and I got into
a lecture through google Summer of Code
last year so I worked on octo and
especially on bringing MongoDB to ecto
and like trying to marry this SQL
library which actor was back then with
no SQL stuff like Mongo and also
leverage additional features like Jason
be in Postgres and I think it was a
success the the MongoDB adapter is is
there and there are people that are
using it so I have some questions for
you
Andrey are tested yesterday
that you can raise your hands so there
shouldn't be any problems with it so who
is there anyone using act oh great is
great to see that and is there anyone
using the MongoDB adapter also a couple
of people you should talk to me later
and the the actor too dot oh gosh like
whatever right now great so let's talk a
little bit about octo history so that's
well active version Oh dot one that was
released over two years ago but you can
see it's not that different from what we
have right now so if that was released
like two years ago what was happening
for two years like if that's so similar
so a couple questions for you with like
basic features and you can tell me what
version do you think they land it in and
you can choose from Oh dot one until OH
dot 15 that immediately followed the the
stable release so Frank bands what do
you think like shout out is it also it
was it early or was it later so
fragments were out of three so pretty
much early and map type yeah this was
like one of the the later editions
without thirteen and associations could
you imagine actor without associations
and actually that they weren't there
since the beginning the change sets
could you imagine actor without change
sets and it was only oh that five that
arrived there you could see like before
this was the the validate validates
macro that were creating functions for
you and changed as a write later and
timestamps there were also quite late
the act I'll type thing arrived together
with change sets the embeds were one of
the last editions and MySQL support was
around the like it's almost I think a
year now that we have it
so where does Excel come from and like
the most more recent features where they
come from I think like everybody from
you heard that the key word syntax and
the query syntax an actor comes from
link in c-sharp and that's true but
while there I like Erik with Lewis
Jersey back then took the the ideas from
there it they also expanded on it so we
dot or not only have like the the
keyword syntax for query but you also
get the pipeline syntax and that was
recently also like simplified that you
don't have to bind the variables right
now so you can do just just say like
where foo equals bar so yeah what what
allowed actor to like marry this world
of no SQL with no SQL and I think there
are couple factors for starters is that
actor is built on this idea of adapters
for for databases so until you pass your
queries or your your structs to to
repeal there are completely database
unaware it's only when you pass the the
query to to repo that it is translated
to either SQL or like MongoDB queries or
something else and it loves for for
great flexibility and allows for
changing stuff how you how you'd like
also like even if I told you we have
like three queries in taxes they're all
compiled to the same stuff so the
adapter only ever sees one syntax which
also helps and the interfaces are really
clean for the adapters
I think there are like they are poorly
documented by the but they are really
clean because there are I think only six
or seven functions that like the basic
adapter has to implement in order to
work with with queries and and with like
inserting and updating stuff so yeah
ecto-1 that Oh arrived
in August last year and it was mainly
about API stability so it was saying
like we think this software is solid and
that you can use it safely in production
and to unbreak underneath you and so
there weren't many like additions or new
features but this was a very important
milestone in the project to say like we
think this is solid and you can use it
after 1.1 introduced many changes many
enhancements and some deprecations
especially like the most important thing
I think was deprecating callbacks and
renaming Actos schema to active model to
active schema and I will expand on this
a little bit later there were also some
performance improvements and like
enhancement in like some additional
functions so 2.0 where you can see that
there's a question mark there
because we're like working on it and I
can't promise you any like date to 4 for
release I can say that probably like if
we keep the current rate of releases
like we can release like active RC 2145
in meets to 20 24 25 so yeah you can
expect that but let's see how what are
what are the feature is looking like
which we are introducing so a huge part
of active 2.0 is the DB connection
library and Raya was talking yesterday
about the connection library and DB
connection builds on top of it it gives
you like the general generic stuff that
all databases need like pulling
connections also transactions the test
pool that allows for concurrent tests
that I will also explain a little bit
later so it's a it's a great library
also made in huge part by by James fish
and I think if you look at and like any
part of a lecture if there's like a
Tippie heavy stuff it's him who I either
did it or had a huge pirate part in it
so yeah it's really great so actitude
are also supports sub-queries it might
seem like it's it looks really easy but
there's actually you have to do a lot of
stuff around extracting the real model
underneath to maintain proper
typecasting and and stuff like that but
I think that's the the sub-queries will
give you more power especially around
like doing aggregations so it also
there's a new function called rapid
aggregate that allows you to pass the
query and calculate an average of a
column or account something in a very
like succinct way another thing is many
too many support which was also like
long expected and I think it's a very
important feature it's it's great that
it has such a short time at not last
something like has and belongs to yeah
and what I was saying in the beginning
about the B connection it allows for
active with pause dress to have
concurrent transactional tests so how it
works is basically that when before you
could have like only one connection to
the database for entire test suite that
and all the tests were running
sequentially but right now we have this
ownership mechanism that allows a
process to say like this connection
belongs to me and I can give access to
it for other processes so you can still
have the tests that are using mode like
test things that use multiple processes
but doing concurrently you can get into
like problems with deadlocks in your
code if you're like you're running two
transactions that are updating the same
stuff but I'd say that's good thing that
you can catch this in tests because it
will it would
probably show up sooner or later in your
production code anyway so yeah this is a
great feature that will enable your test
to run much faster and it's very easy
easy change so you basically have to
change like code in two places at a
thing true to your test cases and to run
concurrently which is so nice and it's
it's really speeds up the tests and I
think faster tests are very important so
also actor dotto enables parallel real
elves by default we had parallel
preloads since 1.1 so this feature
basically says if you fetch like a list
of comments or blog posts and then want
to fetch authors for each of them and
maybe comments so with if you do this
sequentially you go first to fetch like
the post then all the authors then all
the comments comments but we can do
better we can fetch all the the post and
calculate what what authors we need to
fetch and what good comments we need to
fetch and do this at the same time
concurrently and this feature was
present since since actor 1.1 but now it
will be turned on by default so it
should also speed up your your
applications also we got like easier
associations before we only allowed we
we didn't allow you to pass belongs to
associations with to work with belongs
to associations with change sets so this
is no longer true you can build your
entire like tree of schemas and structs
and stuff like that and pass it to repo
insert and it will figure out how to
insert everything in the right order and
write it and you'll get everything in
one go so it's very nice for testing
because you don't have to rely on some
like external tools that do like insert
this model than this than this than this
you can do this all in one go very
easily and yeah there are no callbacks
it's a like process we were getting at
since 1.1 so many things that we're cold
bags actually turns out that you can do
them with change sets so an example of
that is optimistic locking instead of
having a callback that like increases
the lock you can have the lock number
you can have it on the change set and
just like increase the may put a change
with an increased lock and it should
like it's very also like easy and it's
not global so you can choose which maybe
you have some like operations that don't
need locking another does that do and
it's great that you having this this
flexibility and as I said the D active
model was renamed to active schema this
may seem like a superficial change on
the in naming but it has like profound
basis in terms of what we want you to do
with this we want you to move away from
thinking about for about ecto as the
model of your application but rather as
the like data layer that you build your
models on top of it I will talk about
this a little bit later too
but that's the the main idea before
behind this disree naming yeah there are
also some simplifications in change sets
the like before the the function the
cast function it one dot oh it was
responsible for casting validating which
fields are required and working with
with associations so 1.1 removed
associations and gave you like put embed
and custom bed and 2 dot L removes the
required validation so you have a
separate function called validate
required and I think it's a it's a good
move because we're like separating
things out so each function has one
purpose and we got actor multi which is
this idea of like change sets allows you
to encode in a data structure how are
you going to modify your your
data multi is a similar idea that allows
you to encode in a data structure how
are you going to modify multiple things
how are you going to encode your entire
database transaction
so here's we have a simple like example
with like a user manager module and you
have like a password reset flow so you
you will notice that we have like the
the repo stop and all of this wrapped
inside this module so from the outside
you don't see ever that it's using
active for example it could be anything
and it's like loading the account
creating the the multi and passing it to
transaction and getting all the the
results and then doing something like
sending emails with the reset code or
SMS with some like you have token and
that's basically how you do things like
after commit with active to that oh so
you drop it in your own function and do
it yourself it's a little bit more code
but I like how it's explicit and also
it's not like it's a opt-in thing not
that you you are always going to do this
callbacks but you need to explicitly
opt-in that you're going to send the
notifications and if you have someplace
that doesn't need to do it like for
example like in testing maybe you don't
want to send real emails I did that so
you can you can skip it
so let's look how you build a multi so
you basically have a very similar
interface to repo so the the two things
on top of our are change sets so we
create change set for updating the
account we create a change set for like
a log entry that someone reset asked you
to reset the password so we say we're
going to update the account we're going
to insert the log and we want to
we're going to delete all the sessions
because like you have to login once
again
after you change the password and it's
not executed right now it's just a data
structure that you can inspect that you
can look into what is it what is it
going to do which allows you to eat very
easily test it without actually running
it which will be I know we got like the
concurrent test that hit the DB but if
you don't hit the DB it's even like
faster it's even even better you can
check more edge cases like that and so
you'll see that this function is made
public but with doc falls that's exactly
because you don't want it to be used in
your application like floating around
but you want to test it you could put it
in a separate module for example but
yeah like having a module with a single
function that makes no sense so you can
make it or just mark it with doc falls
that's like I think it's like a
universal need elixir to say like yeah
it's public but don't use it outside if
you don't want know what you're doing so
yeah so ecto like since i think like
always has this ability to do
schema-less queries and it's it's i
think it's not used enough so what do I
mean by schema-less queries is that you
can instead of using schema module you
can use string that represents your
table name and you can build your
queries without like defining modules
and schemas and I think it's really
powerful if you want to work with raw
data and you want to you don't want to
like structure everything define modules
and stuff like that if you're going to
do something really quickly for example
in migrations it's great because you
don't want to use that there are models
in migrations because they may change
but you still want to like update the
data and change it so that's a that's a
great way to do it
you're not coupling yourself to to any
modules
yeah and you get a map back so you
you're able to work with like raw data
and actor 2.0 introduces the insert all
additional command so you can like
insert data into the database without
schemas update it and delete it so you
can do like everything you can do with
schemas you can also do without them so
you can see like is we're trying to be
less opinionated and allow you to get
more flexibility in your in your
applications if you don't want to use it
like don't do it yeah you don't need to
use schemas to to query the data you can
work with raw data with just like the
database and related to this is this
idea of having multiple schemas with a
single table so what would be an example
use case of this imagine you have like
the user model that is really huge night
you have all these fields for various
stuff but you don't want to get all
those fields from the database each time
so what you could do is like use like
the Select to limit the fields you want
to you want to get from the database
each time another solution is to have a
separate schema that uses the same table
but defines only a subset of the fields
and if you use it it will like get only
this subset from the database so for
example you can have like user invoicing
data that will that will get only the
data that's connected to invoicing or
user or I don't know like user
notification data that will get only the
data that's that's related to
notifications like emails and mobiles
and stuff like that another example of
this is that you can have the universe
and you have to can have like table less
schemas so schemas do not have to like
be tied to two
a particular table in the database so
you can use this for example to have
like validating the data that's arriving
at the boundary of your system so for
example you can like have the the
request validated immediately after you
get it and then map to some like other
structures that you like it's completely
unaware of how you're saving the data
later is just like validating it and
actor works really well with it this
syntax that allows you to define like
nested things in line is not there yet
but it's it's one of the things we want
there to get maybe even before - data or
soon after so as you can see like this
this allows you to get things like
similar to form objects or stuff like
that that like Giada are concerned only
with validating the data and not doing
anything with it so you can see like
here's an example of like a validate
function that returns a tuple at the end
so you can use a key to change that
apply changes to get the destruct back
with all the fields filled out if it's
if all the validations pass and if they
don't you return an error tuple with
with the with the errors that were
recorded in the interchange set and I
think this this is a really powerful
idea that allows you to decouple the
format that you're speaking with the
outside world from the your storage
inside the application and also it's a
very recent addition that we also allow
you use you to use change sets without
schemas actually so what you can do
instead of passing like a struct you can
pass a tuple where the first element is
the the data which is a map and the
second element is like a map of types of
the fields and types and that's all we
need right now to do to use the change
sets so again this is about allowing you
to be more flexible with what you're
accepting maybe you don't want to define
the whole module folder for like the
registration validation you can do this
very easily like in line without
defining anything anything else but I
told you all this thing that allows you
to be more flexible having more code and
like do stuff like that but we don't
want to complicate the Dagda basic case
you have a simple crud interface like do
it in three lines and be done with it
like you don't need to have like modules
upon modules to work with it and I think
it's right it's my position that we
should like keep simple things simple
and not complicate them so you can still
use all the things you're used to right
now from from acto and with with the
change sets in and repo but you also get
the ability and to like sorry to go to -
to customize it if you need to so what's
the future as I said it's like one of
the one of the immediate things is the
the inline embeds this will actually
define a module for you like if you
define it I side by side but you don't
have to like write all this additional
code and I think this is really cool and
the other thing that we maybe do in the
future but this is something like long
term maybe actor 3 is looking at the
protecto we have two parts of it like
the data manipulation part at the data
base part and maybe what we could do is
separate them so have the like
data manipulation library separate from
database library with like queries and
adapters and all of that because I can
see how the likes change sets and Excel
types could be used for talking to
external api's without actually like
using any databases or like validating
user inputs without like having
databases so and this would allow you
can do this today but you kind of have
to like bring all of the ecto so I think
it's it would be a nice idea to look how
we could separate those things and it
will also help actor internally to
define better interfaces between modules
because right now there's like there's a
lot of coupling between modules so if
you change like one module nearly entire
actor will recompile and it's really
annoying if you're if you're developing
some some new features because it's
takes it takes a long time to do this so
what are like I told you about like the
philosophy and then we want to change
the perspective on actor so this is
exactly the points we want you to to
notice and to take into consideration
that we want to make actor to data
centric instead of model centric so it
focuses more on the data and you can
build on top of it it's less opinionated
it allows you to get more flexibility
it's and most importantly actor should
not be your model it should be just your
data that you use to build your model
and related to that is that actor should
not be a solution to your problem right
it should not be like the thing that you
use to solve your problem it should be
rather a toolbox of like useful things
that you can use to build your own
solution to your problem that fits your
domaine that fits your your application
and you should not be like tied down by
by anything so yeah that was octo the
past the present the future and you have
any questions
the software
Thanks
yep it could be but I'm not really sure
like that because if you if you look at
SQL you can only have like one select
thing yeah
so we I think also like you have to you
have to ask you chose a about this but
one of the the goals with with actor was
not to add like additional layers and
upon layers upon layers of abstractions
and not to try to emulate things that
you can't do with database directly and
to stick to the semantics of the
database that you're using so for
example in the Mongo adapter if we don't
have things like joins or a group by
we're not trying to emulate them
we're just saying sorry like you're
using Mongo you're probably aware that
you don't have joins so don't try to use
them so and I think it's it's important
does this answer your question okay
anybody else
so let me go back so what you can use
right now is like the thing that you
can't use is this part the do and the
the nested stuff you can define the DM
bed separately in a separate module and
use it today right now even with actor
1.1 and even maybe with 1.0 so and yeah
so you can use this did the only thing
that's missing is these inline syntax
so actually actor has this concept of
prefixes so there's a little bit related
to this that you can say that you using
this table with a particular prefix so
in the terms of Postgres it will be like
Postgres schemas and in terms of I think
MongoDB it will use another database so
there there are concept around this but
yeah I think I think it may require like
more documentation and maybe like more
thinking about it but there are things
about this and if you see like some ways
to improve it it's it would be great to
like hear something here some ideas
they have question of all parties
so it was merged recently that we allow
you to pass a function to insert to
insert or update and this function will
receive the map of the changes so far
mate and you can and it is expected to
return a change set from it so yes you
can you can receive like what what will
what models you inserted up to this
point extract data from there and
constructed a change set later yeah
so I have to admit I haven't look that
closely at the B connection so I can't
really answer your question you can
probably ask maybe Eric I don't know
yeah you can ask Eric about this</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>