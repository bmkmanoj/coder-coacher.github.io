<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days -  Jerzy Müller -  Type classes 101 | Coder Coacher - Coaching Coders</title><meta content="Lambda Days -  Jerzy Müller -  Type classes 101 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Lambda Days -  Jerzy Müller -  Type classes 101</b></h2><h5 class="post__date">2014-04-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/CCsGHPxA9E0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Ezra and I will be talking
about type classes it will be an
introduction to type classes short
information about me I'm asked all
developer at filters lab and we are
hiring I'm a functional programming
passionate I like Scala like closure I'm
reading something about our lank after
talks on this conference you can find me
on github and I'm also a co-organizer of
crack of scala user groups color comes
there so that's on me I have a few
questions how many of you are familiar
with Scala well so that's most and two
if Haskell ok i will have one i will
have one slide in haskell because i
think thai places looks nicer in Haskell
but I will still start with a problem
the problem is how to design an
extensible API and there are a lot of
different technical solutions for this
for example we have an entire a tense we
have a structural talking which was
covered partly by Conrad on his talk and
we have we could use also static or some
kind of extension methods as for
inheritance we have a trade clothes able
and for example you have something that
do something on clothes able and then
close a function that's really nice we
are using that in our hour ooo languages
it's easy to create is easy to
understand in the command but it has a
problem that you cannot add your
interface to existing classes so if you
have something that does not implement
closable or you want to add for example
you're writing a serialization framework
you cannot add your own cereal is able
my cereal is able trade to a
java.lang.string it's close you can
adapt to it so one of the solutions that
is
on them except in Scala you have a
structural types you can define a type
not by an interface but by using its
contract so I actually have the same
example as Conrad we have a closable
that have a method clothes and then
that's that's really useful in Scala you
can think you can write exactly the same
code as before and use closable and it
works we used that even on production
but it has some problems first it's slow
they use reflection at runtime in Scala
I don't know implementation that does
not use the reflection and the second
problem is we run into codes like this
so you have methods that does the same
thing but I don't have this exactly the
same names and you can't cover all of
them using structural type we have a
static and extension methods but you
cannot make your API to accept something
that has an extension method on them or
some static method that that applies
accept this type and just does something
with it so in that reason you can extend
existing library ok but you cannot
design an extensible API so as for those
solutions there are some ways to make
your code more more more extensible or
extensible but all of them are lacking
are lacking it's one way or another and
there is another approach and that
approaches type classes it's an idea
that came from or originates from
Haskell and as I understand it because
it's a complex definition it's the main
idea of the type class is to the couple
of free things you have an abstract
interface so some contracts and methods
you use you have your data type and you
have an implementation of that interface
for the data type
and this will help us achieve something
called ad hoc polymorphism and in
Haskell the most basic the type class is
an eco it's an equal and it's used to
compare things if you're not familiar
with Haskell that's the definition of a
type class it does it do not have and to
do anything with a class from the oh
it's it's just an then that's that's the
name of a type class that's a generic
parameter it's like it's a type
parameter a and here we have a
definition it has two methods to
operators first is equal that takes an a
and something of type A and something on
tough ape and returns a billion and that
its opposite is not equal of the same
time and here we have some utility that
defines one of those functions operators
using the other it's one is not the
other the other is not the one so when
you have to implement the Equality you
just have to implement the one you will
get the other for free to get out of you
okay and for example we have some data
type traffic light and we have if we
want to compare our traffic lights if
you have some API stage requires the
data types to be to be compared we just
create an instance it's an instance of
an equal equality the type class for a
concrete type traffic light where we
defined if it's red equals equals red
straw green equals green it's true
yellow equals cielos it's true and if
you try to compare anything else with
anything else it's false and after that
if you have that instance in scope we
could just create a method that is I
accept any type a as long as there is an
EQ for that type a and then use them as
equal
and not he goes in Scala in color the
type classes are not the first class
concepts there are sort of hack on the
language but they're still useful they
are used in the scholars color library
standard and in many libraries so that's
the example I've created myself we have
a configuration file we have some
configuration there and it was in
strings because it was a text file and
basically off most of the configuration
values ward where dates or some periods
on something like this and you have to
remember if that date is if your period
is is 12 is that the 12 days or 12
months or something like this and i said
no i have asked i'll ask Eliza's
strongly typed language I didn't want to
do with that if I read the value from a
configuration I want it to be a date or
a two-period so I write a simple trade
its configuration serializer it has two
methods want to write any type to a
string and want to read a string from a
string to any type and then I have a
configuration parameter that takes that
is parametrized with any type a as long
at there is a configuration serializer
for that for that type and it does take
a name and we have a value method that
reads from a file i omit the
implementation here and we have a get if
you like exceptions not an options and
then if user want to you to read for
example the other time you have to
provide a daytime serializer we have an
implementation using iso date format
there the library itself provides
circularize ER for long since they x
periods and so on and then your user
only use configuration param datetime
some the date value and that returns
option of date time and
if you try to I have another one for the
configuration table in database you
could try to save the incorrect data
type it will it won't compile psych
notes type classes are not first class
concept in Scala they're built using and
implicit so if you see full a of type
fool it's just sugar for that test
function takes an additional parameter
list and that additional parameter list
it's an implicit of type for a and
implicit parameter list arguments from
implicit parameter list could be
provided explicitly like in it's just
carrying we have two parameter list but
if you have an implicit value in your
scope it will be put there by the
compiler automatically so here if I try
to call foo its results if implicit not
found because we do not provide it and
it's not in this in the scope but if we
I create implicit Val of correct type
this color this color will not now
insert it here it's not some runtime
magic it's just inserted in the compile
time and that's that connected to what
Conrad said about type inference scholar
inferences here that foo is the type
parameter is string and then inferences
that the full should be looked the thai
place should look for a type string if i
had to provide all of this it will not
live nice and i have some fun examples
for me first one what you can do with
type classes it's based on the rapture
rapture I oh it's a library by John
tricky he's here he was no don't hit
still it's a library for an IO and it
has two options you could your you could
have your functions returning to try or
an option
the functional style or you could if
you're like Java style you could have
your functions shown and exceptions and
how to handle that without creating tufa
sides you can use a result shopper or
something like this a type class that
takes a single method gives have a
function that takes nothing and returns
an a and three regions and B and then i
create two instances of that of that
type class first one is in package
exceptions in package object exceptions
just to import exceptions dots
underscore and it's drawing exceptions
it's just a result wrapper that applies
the functions that user provides to it
and if it's throws exception written it
will be redrawn and the otherwise is try
wrapper that will create a color try
scholar try constructor here will catch
any non fatal exceptions and return
success with a value or failure with
action exception and we have a
functional waivers i have also something
for eaters and I've heard you you could
also use futures here but it does mean
that does not fit on my slide and that's
for usage we have some API we have a
method bar and that bar accepts a string
and it accepts an implicit trapper the
trapper is for a string and the return
type is B and the return type of the
method is be so here the return type of
the bar method actually depends on the
implicit wrapper that is found so the
drawing crapper the result type is the
same as the input type here that's the
first one is saying goodbye that second
one is the result type so in the in that
one e that took
we'll return the same the same value so
for this one string but if user provides
a trice it will return try of a so for
this example try string mm and usage
looks like that if you import exceptions
and kolb are you will get legal argument
exception and if you import rice you
will not get an exception and that metal
bar returns failure with that
illegalargumentexception inside and that
trick is used by its color collection
library it's something cold if you ever
see something called can build from when
you call a map or flat map or filter on
the collection it actually looks what
should be the type of the collection
after the map and it uses the tight type
type class type classes for dead another
funny thing to you can do with type
classes is recursion because in scala
your you have you could have an implicit
method that requires an implicit
parameter and scholar will if that
method richard type matches what you
want it will get them and then we look
for the implicit parameters for that
type so you your type class in scholar
can require other type classes to look
and this will for example allow you to
create a Pickler a serializer for least
a that requires a serializer for a and
scala if you try to serializer serialize
a list of date it will first find search
for a serializer full list of anything
and that serializer will need a
serializer for date so it looked for
sellers here for days it's there is a
very nice serialization framework based
on this and macros force colleges now
it's called scholar pickles and it can
serialize your case class provided it
has a serializer for all those oil
fields and it's just recursively night
stead for as long as you have an
implicit if it fails on any of the
implicit resolution it just output you
an error I haven't found a serializer a
particular for that type or another type
and it also provides you a way to do a
type level programming so if you have
recursive implicit searches in schol
other libraries that for example
implements heterogeneous list h list and
then h list is a list that has a tie all
of types of all of these elements
included in the type and to work on that
types you use implicit mm oh and the
recursive recursive recursive type
classes are also as if some if anybody
uses play or slick for play uses those
for mapping data from forms from web
forms and to web forms for example you
could have if you have a mapper to for a
date and the mapper for an option of
anything play joins them scholar joins
i'm using the implicit resolution and
create a mapper for options of date so
we can have now dates in your web form
and that will be automatically parsed by
play and the same is with saving and
reading to and from database in slick as
a for summary I think ty + this is a
nice tool to have it provides you with a
way to extend extend something that you
you hadn't thought about for first so
you can extend you can provide that type
classes for it types from a standard
library but you can your clients could
create the type places for a type
through his own library that was created
after your API was created and without
we have knowing over of your API withers
was created and it is really nice for
methods that are not strongly connected
with the type for example sorry
Shin of all kinds it's not that one type
has one method of serialization or
deserialization then you have pluggable
serializer in the serializer depending
on this code depending on the wood what
do you want and you could have one
implementation for this and I think this
is nice tool it has some problems
especially in Scala the implicit
resolutions and object in X next how it
go the implicit resolutions have problem
if you have classes that it extends
other processes are true it sometimes
searches first not think you are
thinking you'll get so it's a bit tricky
sometimes but most of the times for the
for the basic ones it's it works and
it's nuts nice nice tool to have in your
in your toolbox I have some resources if
you want look that my presentation is on
my github it's faster so you can look
the source of them and I thank you and
do you have any questions for me
faster faster what is in Polish yes okay
okay w.e are sto air okay w/e i will
show it those oh yeah it's here for what
sorry double dispatch how multiple
dispatch I I hundred found that example
I will say to it yeah hi hello am i
normal the normal language is java
normal language i think i think that i
think that ordering in java is a type
class if you sort your collection you
provide an ordering ordering is a type
class you just have to provide your it
explicitly i know i'm pushing the
boundaries of typos definition but it's
it's just for me the main idea of thai
plus it's decoupling the implementation
of some some behavior or from a type and
from a declaration of that behavior
through inheritance
inheritance which is intended to achieve
a similar purpose that doesn't have the
same strength as time asks so you could
imagine having we're probably going to
be an object-oriented language because
this is this is type oriented rather
than object-oriented you can imagine
type of orientation like Java used of my
classmates not to make perfect sense if
the main difference is the trikes are
static and objects are dynamic this is
real also you get quite a lot of recent
power from the type classes you didn't
you don't mention this my favorite type
is color there are vampiric types but I
will not cover them here it's it's a
trick that uses dynamic typing in Scala
with macros with structural typing to
create type providers from F sharp
before before Scala to 12 when we have
more powerful macros to do the type
providers the right way
it is</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>