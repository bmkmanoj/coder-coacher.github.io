<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Justin Schneck - Enhanced Embedded Systems with Nerves (ElixirConfEU 2016) | Coder Coacher - Coaching Coders</title><meta content="Justin Schneck - Enhanced Embedded Systems with Nerves (ElixirConfEU 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Justin Schneck - Enhanced Embedded Systems with Nerves (ElixirConfEU 2016)</b></h2><h5 class="post__date">2016-05-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/118-g0ODfgg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">imagine you're in an era of seemingly
infinite inventive possibility lots of
things are ahead you can create anything
you want there's new hardware that's
come out that's smaller and faster on
top of this we have powerful languages
that are given us the ability of
creating fault-tolerant amazing devices
that will use to be able to drive our
innovations forward during this time
we've also experienced a situation of
connectivity I don't know if any of you
have experience in this realm but
bulletin board technology comes out
connecting people together giving them
the ability of sharing information
moving on from there we have the
internet taking hold getting us 500 free
hours every week in the mail for decade
and during this time this spark that
happens starts to drive more and more
people towards the web this connected
place more people are coming online so
more developers are joining the
community to be able to facilitate new
innovative ways of creating these
digital landscapes and then something
happens in this realm well things get a
little bit easier some players come into
play that that offer tool sets to make
this a little bit nicer you have rails
it enters in a new era of developers
suddenly were flooded with all of this
we flooded the space with while all of
these new people that have creativity
and web 2.0 is born in case we've
rewritten the internet we were okay with
that moving forward now the landscape
continues to change and connectivity
lions start to get blurred more and more
enter phoenix and it's channels and
sockets and real time we're starting to
now try to bring the web together back
with those devices that enriched our
lives
but what happened to those devices to me
it doesn't seem like a lot change I mean
here you have a credit card processing
terminal on the left and you have a
credit card processing terminal on the
right both with mag strip technology
still hanging on to them it seems like
during this time that the web was having
explosive growth hardware developers
were concerned over how rounded they
could make the corners on these devices
well it seems like there's a lot of
problems that need to be tackled in this
area to be able to give us the ability
of pushing the design forward again one
of those is the ability for us to
rapidly prototype these kind of concepts
and ideas so here's a quote that I've
got from a colleague of mine company
called element ID I need an embedded
system and I need it in one week now
this was said to me one week ago I
thought to myself sure it's not like I
have a conference to prepare for well
after putting down a lot of work on some
projects that I was invested in I
decided sure I'll do it I'll take that
job I'm crazy enough to do that and a
week later we were given this fully 3d
printed case and all and it was actually
kind of enjoyable the experience it
didn't feel rushed and it was the first
time where I felt like I delivered a
project that was dare I say it on time
well they were a static this is this is
my brag slide for now they said that
they were able to we were able to
deliver production product tested out
the door in five days without
sacrificing performance or reliability I
was like that's a fantastic quote I have
to put that up there but he went on on
top of things we've sort of created a
landscape for them to be able to make
updates to the device easier for future
usually when you get into this realm
you've created this complex device it's
really hard to do well how did we do
that with two web developers in five
days that kind of rapid prototyping is
really what the industry needs and
that's nerves so what is nerves behind
the scene well it's a team of extremely
passionate people about rewriting the
concepts of embedded system development
to make it easier for and more
attainable for developers all types of
developers to have the feeling that they
can create embedded hardware so what
exactly is it well it's easily broken
down into a group of about three
different categories we have a
collection of frameworks we also have a
platform that we build on top of and
there's also a suite of tooling that we
use as well so that seems pretty easy
well what are underneath the covers of
all of these lots of lots of stuff some
goodies for everybody to be able to play
with to break this down a little bit
easier the frameworks or just libraries
that you can use in your embedded
projects to get you working with
different things like LEDs or different
ports our platform is a collection of
of systems that we've generated to run
on all types of different target devices
raspberry PI's and beagle and blacks we
also have the suite of tooling which is
a collection of utilities and mixed
tasks that'll get you to the point where
you're feeling like you can get up and
running easily now this seems like a lot
but bear with me it gets a lot easier
here's a list by the way of some
supported targets that we have for today
we've collected a bunch on the top there
that's pretty much all of the original
raspberry pi is the a plus B plus the
zeros the PI to PI 3 we have a
collection of other great prototyping
boards as well and it doesn't really
just stop there we're extensible in a
way that allows us to create on top of
pretty much any number of Linux single
board computers and because we want this
stuff to get smaller and faster and more
connected we're also looking to be able
to integrate some smaller devices you
might be familiar with the the chip that
was the world's first nine dollar
computer before Raspberry Pi rip the
carpet out from under him and said five
dollars we also have a product here from
seed studio it's called the link of duo
we're working on bringing that up to
it's a very small device in person and
it's got built-in Wi-Fi these tiny
little mitts processors in them have
enough space on us to be able to run the
entire airline vm linux and your
application so how do we do that with
just a small collection of frameworks
platform and tooling well the first
thing i want to show you is an easy way
to be able to transition into getting
started and what and what we mean by
that is everybody wants to be able to
play along in the sandbox so a sandbox
to us is away with the most minimal
steps to provide an environment that
will give you the ability of
accomplishment without having so many
variables to go wrong and I mean by that
with a raspberry pi you can use a
raspbian which is the operating system
that typically ships with that it's a
form of debian and everybody knows with
working with Linux machines that then at
that point you just plug it in your
network shell into it and everything's
good to go well here's a small laundry
list of things we have to do to be able
to get this one running we have to get
the system updated to make sure that we
have the latest kernel establish a
network connection then we can ssh into
the box then we can install our line and
we can actually use the ESL Erlang
solutions was kind enough to be able to
update their raspbian repositories for
us then you can go on to install a lick
sir finally you can check out our blinky
code blinky by the way is the hello
world of hardware and then at that point
you can finally run your application all
of that so you can blink an LED light
it's amazing and from there you can
check out some of our example code to
get it running on the sandbox so this
seems like an easy place to get started
with the frameworks but well what are
the costs associated here the sandbox
weighs a lot I mean a Debian
installation you're talking about 600
700 megabytes it's going to take a while
to boot to bring up the entire thing
about 30 seconds or so updates are going
to be happening through some package
management utilities and it'll be a
little hard to be able to remotely
monitor control and reproducibility of
this system is low because you know you
could have the package updates happen in
one area and they get a little bit
further along in another area and then
you're out of sync in these systems you
don't know really know what software is
on what and if you have 100 to 150
devices distributed it becomes very
difficult for you to be able to
synchronize this kind of stuff well
there has to be a better way and there
is and that's the platform so once
you've experimented with the frameworks
and you may have something working on
your device now you want it to be a
little bit more distributable so what we
do is we build our platform on
top of an opt-in approach we use
buildroot underneath to be able to
create a lean but robust enough that
with everything you want included system
that you can attach your application and
erlang to and then it'll give you
maximum performance and distribute
ability so what does that look like well
we've taken that size down a notch you
can ship the entire Linux operating
system with build root on our systems
and your application and the Earl nvm in
about 20 megabytes it boots in about
four seconds the entire update is the
entire firmware includes the entire
subsystem as well so if you need to be
able to make an application change that
requires you to install additional Linux
configurations that gets versioned along
with your application reproducibility is
high because all of our scripts and
systems will build the same way from our
configurations today as they will
tomorrow at that version and volatility
is low and what I mean by that is in the
case of the full on debian installation
rewrite is happening all the time and
these devices are booted off of SD cards
and i'm not sure but if you take a power
plug and unplug it while on SD cards
being written to you're not going to
have a good day most of the time what we
do in our systems is we actually reduce
the volatility by making your filesystem
read-only this doesn't sound good right
now I know the first time I heard it I
was like it gets better so we wanted to
make this easy for people to use because
there's a lot of complexity and the
amount of services that nerves is so the
first idea that we had was well you can
only lint you can only actually build
systems using Linux hosts buildroot only
really runs on linux but as i've seen
from the sea of developers in this
conference and most others there's a lot
of people that use machines other than
just linux so our first answer to this
was to create a service we're calling
bakeware and we're like let's make it
easy we're going to be able to
that somewhere else will ship you a
cached version of it all you got to do
is install this utility create this
thing we're calling a big file then do
these commands that you'd be like just
get the system and then get the tool
chain and then bake the firmware and
bake burn and and you'll notice that
this didn't none of this felt like what
it felt like to create other elixir
applications no we're in there do I see
the word mix and and so it wasn't until
one day when shows they called me up and
he said to me tell me about this big
thing you're working on that we actually
had to question what would it was
because it it should be easier than this
this was even too difficult it was hard
to maintain and in reality when we were
working on baked it just kind of felt
like we were reinventing mix or trying
to do hexagon or something like that and
handle it on her own and it didn't make
sense but we needed to be able to open
the conversation so that we could
integrate ourselves to make it even
easier for developers to get started on
these so we turn this into this starting
today you can now completely use nerves
from within mix it acts like any other
application and exposes several commands
that we added in for you to be able to
export your project to your device and
run it all you have to do is fetch your
dependencies and mix them firm or so how
does this work well behind the scenes we
have your application and your
application might consist of some elixir
code and you might have some C code in
there you might have some nips and ports
if you're using something that might
have to reach in to do some crypto or
something like that and when you compile
all this stuff down typically you
compile it on your machine using using
mix and all this stuff gets fed into the
elixir compilers and it gets mashed up
together and on the output end you get
some some bean files and some binaries
with your compiled C code and voila you
have your application specifically
compiled for the machine you're running
on completely different than any other
architecture
because of that binary code that's
included in there those dependencies
have now been compiled down to only run
on that machine so why did it make sense
to make big well baked allowed us to be
able to take mix and just go I'm just
going to wrap around it and that gave us
ultimate control over being able to rear
out the requests that you were making to
compile your code to ensure that it
would actually run on your Raspberry Pi
to this was a big requirement for us
because we needed to be in charge of at
the time when mix asked called out to
the environment for who's the C++
compiler or who's the c compiler that it
actually went to the right place because
we don't just support raspberry pi 2 we
support all kinds of target
architectures so let's look into this a
little bit further well under the hood
what we were doing is you fed in a
target and you said bake I want to build
for raspberry pi 2 and bake will go all
right cool you know I got the tool chain
and the system here the tool chain is
going to be able to give us the ability
of cross compiling the system is going
to be that platform we build on top of
and i'm just going to feed those in the
mix the way i need to and out comes the
other end your application for the
raspberry pi 2 well right here is where
we saw it we're like well why do we need
bait why can't we just have mix it needs
to just be simpler and the way that we
handled this was at this point we needed
to be able to sort of invent a phase
that happened before any of your code
was getting compiled we needed a
precompiler step that allowed us to
bootstrap the mix environment so if any
of your application dependencies start
compiling or your application itself and
it contains C code it's compiled using
the right environment settings and this
is tricky trickier than you think
because oftentimes because we want to
use mix oftentimes the tool chains and
the systems are actually included as
dependencies in your project but we
don't know where they are so if we just
if we
if we start loading dependencies it
starts compiling dependencies and if we
start loading dependencies trying to
find who's the system in the tool chain
so we can set up the paths right it's
already too late you've already started
compiling stuff and you're compiling it
for the host and oftentimes compiling
these things that exist on the target
might not work on your host so what are
these things here actually and why is it
so difficult why is it so important well
let's start with the toolchain our tool
chains are built on top of a
configuration you feed into it the
dependency is basically a tiny little
configuration and it's built on top of
cross to lng giving us support for
running on mac OS and linux and
soon-to-be windows there's a few
namespace length path and problems we're
having that it's built for the target
and it has a host configuration so a
tool chain basically is a series of
compiler binaries that are built to run
on your host but they're made to compile
for a target like a raspberry pi and so
we feed that config into a compiler and
out on the other end comes a quite a
large collection of files like a hundred
and some-odd megabyte collection of
files that is specifically intended to
run on your machine now we cache all
this for you because tool chains don't
update that often when you download a
dependency from hex that has the
toolchain config we already know
everything about what the one that what
it is that you need so we have a series
of HTTP mirrors in place that allow you
to fetch down the actual compiled
binaries for this making it lightning
faster process what is one of these look
like um you don't really have to worry
about it but we've uh they're all
exposed inside of the configuration if
you're ever curious and low-level enough
to be able to try to figure out if
something is enabled in GCC or what
version it is that's running you can tap
in and take a look at the tool chains
it's part of the dependencies just like
any other dependencies you'd bring into
your mix project
so on the other half of this equation we
have the system systems are about the
same thing the distributed dependencies
that we have are the system
configurations and these like I stated
before are built on top of build route
they use an architecture that's known as
a defconfig and that's basically a
configuration that then gets compiled
down into a real config and in addition
it's a collection of root filesystem
additions let's say you turn on wpa
supplicant to be able to do some Wi-Fi
then you need to include some files or
configuration files in like etsy on the
host or on the target or you want to put
some additional binary files on your
system as well those are the root
filesystem additions and we basically
through the elixir compilers for nerve
systems turn those configurations into
systems which way equally large 80 to 90
megabytes in some cases and so we do the
same thing we have a series of HTTP
mirrors in this case that allow you to
be able to download these pre-compiled
systems so you can start building on top
of them now this is where it gets a
little bit trickier in the case of the
systems we offer a minimal install
images that allow you to get started to
putting your application on but
sometimes you want to enable other other
things in the and the the file system
like maybe you want more enhanced shell
or some additional utilities as I said
this is an opt-in approach that we take
so it's extremely stripped down to be
able to run well you can do that by
editing the defconfig oops wrong one
that one you can do that by editing the
defconfig you can add additional
packages you can also if you're familiar
with Bill group gained access directly
to the screens that allow you to be able
to enable or disable other utilities
inside your application but as I said if
you're if you're we include a lot so we
include Wi-Fi we include things like
that networking that allow you to be
able to get up and running quickly
typically you won't have to be able to
dive down into this level but if you do
you can certainly edit a configuration
and create a new system
so that's what brings us back to this
portion here now we know what's
happening under the hood with mix we can
see that the tool chains and the systems
are in place for us to be able to when
mix goes to compile our assets point to
the right places and structure it
together with the right version of
compiled Erlang and also with the
compilers to create your code but let's
take a look at at the path that we took
to get here well it's important to think
about mix as far as the lifecycle is
concerned when you fire up mix to be
able to start executing commands what we
do at the time of precompile is we
bootstrap things this is where our
bootstrap utility comes in place when we
call into the bootstrap at precompile
which is any time that you're asking the
composite to start compiling
dependencies we first make a call out to
say where's the system we're
guaranteeing that if you have a nerves
application there's at least the
dependency for nerve systems present
under the hood once we've identified
that that's available we then look at
the rest of your dependencies and
identify the other components that were
interested in nerve system contains all
of our compilers they know how to that
knows how to turn the configurations
into the actual product and under the
hood you have your dependencies that say
oh I want to be using for nerve system
raspberry pi 2 and that system is built
on top of bill group all you have to do
is include raspberry pi 2 and it does
the rest for you so how do we do this
well for more advanced users when you
start creating new systems we look for
any dependency which contains this
nerves the excess file it's a special
file that we've included in our
dependencies that allow us to be able to
app precompile time determine which one
of the dependencies on the system are
actually relevant to us so we can put
the right pieces in play without having
to compile any of them because then it's
too late
so from here what does this look like
well now we've identified things and
we're going to go into start loading
code paths together once again we call
into the nerve system to be able to
identify make the identification of that
system and that system as a dependency
of your tool chain and the rest of it so
we know now and mix can go on to compile
your application we've already bootstrap
the environment and everything's ready
to go and because of the steps we've
taken here we're able to always ensure
that your code is always compiled for
the target so it's important that you
have the bootstrap piece in place and as
of today we have the world's longest URL
that you can go and install the archive
it's very lightweight it's small all it
contains as the information required to
be able to bootstrap your environment in
addition it contains a new project
generator getting started with nerves is
now easier than ever you just call in to
mix nerves new create an application and
pass it a default target you want to
start using and from there everything is
downloaded and ready to go on your
system so let's look at some of the
magic under the hood that's required to
be able to do what this does for you
let's start with the mixed file the
first thing we do is we try to gain
access to what you're interested in
using for a target now out of the box
nerves supports the ability for you to
use multi target so if you want to
develop an application that you want to
both run on Raspberry Pi and beaglebone
black you don't need to code bases will
handle all the switching behind the
scenes for you and ensure that when you
tell it what target you want to deploy
for at that time that we choose the
right system and tool chains for you
original is actually passed in from the
environment so much like how you use
mixed environment you'd pass in herbs
target and the nerves target will let
you change on the fly but you can also
set a default for your project as well
that's where the target flag comes from
from the the new
and here further in we extended the
project configuration there's been some
new additions to elixir that allow us to
be able to specify required archives and
we can see that we require nerves
bootstrap to be involved this gives
users a pretty error message that asks
them to please install that nerves
bootstrapped archive so that things
compile correctly we also require that
you expose the target to the project
because we use it later down the line
and to be able to do all the magic
behind the scenes we supply a group of
aliases that allow us to be able to
patch into the right places for
precompile unload pads from here we do a
little magic and we allow you to be able
to use any one of our targets with a
single line the reason that we split out
the systems in this case if I go back to
this one here you'll see that the the
dependencies are brought in concatenated
with the a system call the reason that
we do it this way is because we only
ever there should only ever be one
system present at any time so for
handling multi targets you should never
bring your dependencies for two
different systems in at the set together
because the bootstrap utility will get
confused on which one you're supposed to
use during that time and that it'll only
be able to have one present at any given
time so by switching targets we
automatically switch systems and in
addition we automatically organize your
dependencies and your build tool or your
your build products by target so that we
leverage the caching of the toolset so
when you switch between one and another
you don't actually have to completely
blow away all your dependencies Andrey
fetch and completely blow away all your
intermediates and rebuild everything
will be cached and ready to go super
fast for you
so we go on from there to be able to
allow you to do some advanced
configuration you can in your
configuration file you can actually
import specific configurations for
targets this is important when you use
utilities like our LED classes for
frameworks you want to be able to make
it so that for the Raspberry Pi you you
specify where the LEDs are on there but
for your beaglebone black you want to
specify where they are on that one and
that will allow you to be able to import
the correct configuration for the
correct target changing targets is easy
like I said you can switch it at the
command line you can pass whatever you
want then you can or you can set it
permanently for your session if you only
own a raspberry pi 3 and you always want
to be compiling for that you can just
set your that I have a raspberry pi 3
and every single time you download an
example application or somebody's nerves
project it'll automatically start
compiling for your target to get it
running for you in addition you can set
it in the project specific ones so that
if you want to just call mixed commands
directly without having to override that
project will be for that target so here
we are we compiled our application we're
ready to go well there's one more step
we have to get it onto that device and
the way we handle this is by building
firmware so firmware is basically your
application compiled into our systems
and we do this using OTP releases and e
XR m specifically we have a plug-in
that's automatically included as part of
the dependency chain which will ensure
that when I xrm reaches out to be able
to ask for where the version where
Erlang libraries are that we point it to
the right place and where the system
files are as well that it's pointed to
the right place that's all handled for
you once you have an OTP release we
during the firmware mix for more step we
also then use squash FS tools to be able
to take your application and squash it
into the system you can imagine the
system to be you know your Linux like a
Linux system so we just basically marry
the two together at that stage and then
we use a utility
that we see that we've provided
frankenmuth wrote called fw up which
creates a firmware bundle and this is a
little different than considering the
idea of for more images because the
firmware image has a lot of empty 0
space in it we make this really small
and portable with firmware bundle files
that in this case is an accurate
representation pretty much of the actual
space of your project these will be
about 20 to 30 megabyte files very
easily distributable so now that we have
our firm or bundle and that stage is
kind of put together we're ready to burn
it to an SD card we provide a step for
you with this as well that also uses fw
up its supported on mac OS and linux and
zoom windows where you'll be able to
just say mix firmware not burn and you
have an SD card in your machine it'll
automatically discover it ask you if
that's the one that you want to burn
onto and then it'll just in a few
seconds you'll be ready to take that SD
card and put it in your device and start
running nerves so what does the
resulting system look like as I've
mentioned before read-only then the
reason for this is to prevent corruption
on your systems but what we do it to get
around the fact that we know that you
want to be able to write places is you
are able to split the a partition into
four different areas by default we have
a boot section which is the boot loaders
and linux kernel and then we have a
firmware chunk now you'll notice that
the firmware chunk on the left is
illuminated and the one on the right is
not we do a little bit of block magic to
be able to make it to that we slate out
an area on the disk and split it in half
and say this is a and this is B and we
tell the partition table that which one
of the two chunks that it should be
booted into and this makes for more
updates really easy and tolerant because
now what we do is we're only actually
using one partition for your active
firmware empty block space for your
inactive firmware which leaves you two
partitions to play with
now oftentimes what we see people doing
is will give you an app data partition
that's read write and in the app data
partition we you commonly see
configuration information that's usually
free or infrequently written data that
that during a power failure could cause
corruption to just that partition
strategy here would be when you boot up
for the next time you just do a logical
check to make sure that your database
files sequel light files are present and
working before going into the further
steps and if they're not then
reinitialize them from a scene you can
then also expose a additional partition
commonly we see an extra partition being
used let's say if you want to be able to
tell logger where'd of rotate files to
this is more frequently updated
information but isn't as critical as the
configuration data if you write files to
a partition because that you're doing
that frequently because you want to
continue to log out in that manner you
don't want the corruption potential
there to affect your actual device
configuration if log files go away
between reboot who cares redo them so
for former firmware updates as I
mentioned we make it really easy all we
do is when a new firmware update would
come in using fw up you don't have to
write the complete image every time you
can say hey here's some new firmware
write it to the next partition and what
we do is we stream those bits into the
other area we enable the other partition
we ensure that it works and then when it
boots up and it says that it works we
change the Master Boot Record to point
to that portion of the chunk and say hey
you're active now the beautiful part
about this scheme is that your old
partition contains a last known good
working copy of your application and
your system you can always fall back and
as I've stated before you can enable an
additional partition because we've given
you four to be able to write into more
frequently written data sets so that's
the nerves platform now let's take a
look at some of the frameworks that we
have to make things easy there's some
interesting areas you have to consider
what nerves
and one of which that you normally take
for granted is that the network's
actually there and up it's up to you to
be able to say that you want to bring
the network up and how you want to
configure we expose some frameworks to
be able to make that easy so that you
can specify which adapter you want to
use and what the settings are you can
choose between DHCP static it'll do link
local fallbacks and you'll also be able
to configure your own dns or subnets
things like that I've only briefly
touching on this one it's a sore subject
in a way we've been asking we've been
asked a lot for Wi-Fi support because
the new PI 3 has it built in and indeed
that's an interesting addition that we
want to make currently we have a project
that's just come out today as well that
we're calling interim Wi-Fi because
there's a bigger thing that we need to
solve under the hood and I only want to
briefly touch on this topic but it's
something that we're working towards the
future on and that is the idea of
handling system initialization see with
nerves when yours the reason that your
system boots up so quickly directly to
your application is because unlike other
Linux systems we basically replace
common initialization like systemd or
you dev directly with the Erlang vm
because we figure it handles supervision
for you it's probably the best thing
around to be able to do a system
initialization for you that's why it's
up to you to be able to bring up
networking and in the case of Wi-Fi
things started to get a little bit more
complex because now we had different
utility actors that we wanted to have in
place that needed to kind of know about
each other but not and share state
transitions between them so we're
working on methods of being able to make
initialization easier for developers so
much like working with phoenix routers
you'll be able to actually just state
rule sets that will allow you to dictate
how different libraries will interact
with each other so that you can make
sure that when a network device becomes
available that it furthers down the line
to be able to establish your network
interface but not only that that when a
network device becomes available you can
perform whatever
directions you also want to perform
during that time so moving on from this
problem its hardware we want to be able
to do some real-world work right we also
have a library written by Frank that's a
elixir ale and this library allows you
to be able to interact with gpio you can
do analog reads you can do digital
input/output you can do spi i square c
and in addition to that we also have
some community editions greg meffert
wrote the neopixel library Adafruit
Industries sells these extremely awesome
tricolor LEDs that you can you can
string them along for as long as you
want to go there all addressable and
they use pretty much three they use like
one digital pin to be able to actually
enter an interface with your device so
from there you can specify you can
address them individually and you can
change their color individually you can
use animations with them it's it's
really cool stuff you can do with those
so now that you connected to some
hardware you're going to want to put
some skin on this thing so let's talk
about some user interfaces well
everybody here knows that when you go to
router pages or device pages that
typically these are like web interfaces
that we're talking about and what better
to be able to use for web interfaces
than Phoenix Phoenix gives us so much
that makes things in the embedded space
instantly cool and the structure of this
we've come up with an recent project is
if it's it felt so natural to make it as
an umbrella because we wanted the
ability for you to be able to rapidly
prototype your interface development
with your nerves development at the same
time and to handle it this way because
nerves projects are always compiled for
your target and those nerves projects
may contain nips or ports that are then
compiled for a Raspberry Pi when you try
to run that project on your host in IX
you
we won't be loading the right binaries
and the system will get mad at you so in
this situation you want to be able to
still leverage all the great tools you
want to use live code reloading you want
to be able to see your changes happen as
you go along so what we did with this is
we set it up in a way that you can make
calls in let's say you have a web
interface panel that you want to set up
some pins and those pins that that
Phoenix application doesn't know
anything about gpio it doesn't need to
actually start supervisors or processes
that are going to start monitoring
physical pins on your computer they're
not there so in this case we have to
take a little bit of a Liberty and we
meant that we we say that if you're
running in dev you should start pointing
your stuff towards these stubs and these
stubs are going to be including on our
library conveniency that'll allow you to
be able to use unit testing with Phoenix
application you is so that way you can
simulate and put an output on pins or
when button presses are happening or
more complexity like actual protocols of
streams of data coming in once it's time
to go to production well we just swap
things out we say all right let's put
those active pins into play and now we
link in the core and your entire
application is up and running and ready
to go this was the technique that we use
to be able to rapidly prototype that
product in five days and here's the
result that we had that the customer was
enjoying the liberties that we ended up
taking or people in this realm they
don't really see this kind of real time
updating and when it came down to it we
we looked at the at the what we pitched
to them what they're asking for us to do
and when we had to put counters on the
display for when events happen and we
had to put a real time log streaming on
the display and we wanted the clock to
start counting up and things like this
well you know it just felt naturally
like well I'm reloading the page because
it's what they wanted and I have to say
Phoenix never made scope creeps so
palatable so that's some of the basic
stuff let's talk about a few advanced
things that you can get into one of the
things that comes up often is hey I
built my system I've
my elixir application but I need to be
able to interact with some other files
in my file system I want to add some
additional files to my root filesystem
well we expose the ability for you to do
this directly you can set at a
configuration option for your firmware
to tell it to point to where your root
filesystem editions are and by using
multi-target you can actually get away
with specifying this in each individual
targets configuration file so if you
needed different files or different
versions of files for different targets
like a raspberry pi or a BeagleBone
black you can make that decision and at
the assembly time so all you do here is
you point it at a directory the contents
of that directory gets merged into the
actual file system and then this happens
at the time when you call mix firmware
so it's really fast and it's it's not
always doing it on every compile well
what happens if you want to change files
on your root filesystem a common use
case here is a raspberry pi well
raspberry PI's we have the we have to
choose which interface which TTYL we
want to be able to send standard in and
standard out to be able to show that I
ex prompt on the device and that differs
between the serial port that's on it
most times people use a serial console
cable to connect USB to connect the
Raspberry Pi to see on their host
computer what's happening on it but
other times you might want to be able to
just plug it into an HDMI display and
show the display output because there's
an hdmi port on that device so we by
default right today ship that the elixir
the i-x prompt to be able to be sent out
to display on the hdmi port and a common
situation is hey i want to use a serial
console cable so with this strategy
you'll just point the same way root
filesystem editions but any files that
you find that are already present on
your target like ones that we include
directly with our system configurations
if you provide your own will just
overwrite it with the version that you
provided at the time of assembly as well
in this situation we're just showing
that inside of the ER Lynette conf which
is the Earl in it is the thing we
replaced system v with we can we can
specify
I when with the device would hang that
we want to be able to have the device
hang on exit so that if the airline vm
crashes and we need to be able to see
the crash report we can actually see the
crash report without it completely
rebooting every time good for
development not good for production so
changing root file system files is one
thing you just want to make sure that
you don't do it that if you're expecting
different results that emerges it won't
it'll actually completely replace that
file and we do all this using fw up i
had to present this apparently in the
urban dictionary there's a it's a cute
puppy so we had to grasp that concept
and come up with a logo that looked like
a cute puppy one other thing you're
going to want to do is have access to
change files in the boot partition with
using fw up you'll actually there's a
con fw up come file that you can replace
that in that com file is also the
location where you specify additional
file system partitions the sizes of
those partitions the structure the
format of those partitions and when you
add those additional partitions let's
say in this case what this is
illustrating is on the raspberry pi 2
you want to be able to change the
console output to be able to go down the
serial console cable you can use this
strategy to also replace files on the
root on the boot partition the reason
you have to do this differently is
because some the files that are located
on these partitions are different for
all different devices and as seen before
this is just the text example of how
this kind of stuff is laid out so this
is how you would also use the fw up com
file to be able to declare additional
partitions like the log the log file
partitions you can see more about this
by visiting the fw up git hub page
there's extremely good documentation on
all the different options you can use to
make configuration changes to that
something cool that you also want to do
too is connect to remote nodes once your
devices on the network you can actually
use IX to be able to connect directly to
other nodes so all this cool stuff comes
included today and with that there's
still more we're working really hard to
be able to bring some great next level
technology to this platform and in the
last several months there's been a huge
explosion in commits and contributions
to the project so what's ahead here's
the future ish we're going to be
bringing in display and touchscreen
support so that your phoenix web
applications will run natively on
touchscreen devices we're also working
on bringing network firmware updates
which I here are actually done today as
well I have that in this one because
there's some testing that we need to do
with that we're looking to make the
development lifecycle even faster by
using serial console cables we've we're
looking to make it a way to be able to
use code reloading on your devices
during development without having to do
it over the flaky network because as
we've stated before that's not always
great on everybody we want to be able to
make things always connected we want in
that development lifecycle the ability
for you to be able to write tests and
have execute remotely on the device to
verify that your hardware is working
we're looking to create some development
kits and on top of all of this we are
doing better documentation adding video
camera support and I hear they're there
are actually books in the work for this
too so this leads me to the statements
made earlier and that is that it's time
for embedded to have its revolution it's
time for embedded two point oh so what
are we doing to change the world in this
case there's some experiments that we're
running and with some others in my area
on how to be able to embed nerves
devices really lightweight updateable
nerves devices and drones and 3d
printers to be able to control these
devices and network them together in
addition we have several clients using
things in production we've taken a
distillery and automated their entire
still to be able to use nerves for
actuation of valve systems control flow
and it's all driven from an Apple watch
we also have rose point navigation Garth
is one of the main core team members his
company ships products using nerves they
have battle-tested these things they are
rock solid and have actually wonderful
experiences producing these products on
this platform so let's do it let's get
out there and rewrite embedded we have
other people in the community that added
some projects as well Wendy's been
making a automated cat feeder and tim
tim o's here he's been using nerves to
be able to do temperature control on
fermentation for beer so I ask you
imagine you're in an era of near
infinite inventive possibilities and you
have hardware that's become smaller and
more powerful and languages and
frameworks that are new and provided to
be able to give you the power to invent
anything that you can put out there and
it's easy thank
thanks all justin i'm afraid the rest of
the conference in part because developed
by our some grocery i watch the scenery
talk with you questions
and we like one of I will supply some
baby rattles okay so with the interim
Wi-Fi package we've also enabled a small
subset of Wi-Fi common Wi-Fi drivers for
the Linux kernel under the hood
typically these are the realtek drivers
we're going to be assembling a list of
all the currently enabled ones but if
you want to be able to do if there's a
Wi-Fi driver that you have there's a
Wi-Fi chip like dongle that you have
that enables a driver that we don't have
enabled we'd certainly work together
closely with you to be able to get that
added in as either a system edition or a
system extension as well which will
it'll it'll offer the support for you so
as of today you can plug it in using the
new nerve systems and if it doesn't work
let us know we can we can make it happen
so then your migration is what's the
next step what's about saying things
about starving people tourism is
different devices
so for the Internet of Things and
connecting devices and accessing this
sort of debug code that's all part of
some future work we're working on right
now you can actually take nerves devices
and use a distributed Erlang to be able
to distribute strap them together do
node connects with them for IT purposes
we're invested in looking into new
technologies like Lauren and supporting
that out-of-the-box to be able to do
local why distributed networks and for
your debug messages and debugging your
devices the serial console cable
connections for the development
lifecycle we're looking to standardize
the ability so that when just like your
Phoenix or other Alex or applications
when you type like I exs mix and you
want to be able to like play around with
that device on your host connected we're
just going to do all the magic behind
the scenes to be able to make the remote
shell connections happen for you so
that's in that's in the works right now
I see toejam this is the umpire I'm so
we don't our tool chains right now are
mainly G lipsy GCC based but like I said
we're built on top of cross tool ng with
our configurations so anything that you
can really create out of cross to lng
which i believe you can create llvm ones
in there you'll be able to generate
those and using using the structures
that we've implemented with our tool
chains you can also out-of-the-box
support mirrored caching of those as
well with our same fundamental so
they just think so
curiosity what kind of complexity were
talking about your five days project
markers so really the device was created
as a universal example of something that
can be done we made something that
allowed them to be able to dynamically
through the web interface configure pins
to be inputs and outputs decide whether
they wanted to connect LEDs to them or
also associate dynamically associate
actions to be taken when a digital pin
would go high or when it would go low so
what they ended up using this technology
for was to be able to monitor equipment
in a manufacturing facility and when the
equipment was set an alarm off they
would make HTTP posts against their ERP
system to synchronize the data with the
the point at which the process was was
that so they could further inspect the
product and ensure a quality control on
it so it was really flexible there was a
lot of great configuration that came out
of it but in reality it didn't require a
lot of low-end embedded experience
because of all the frameworks and things
that we we give you in the project
uh yeah um ourselves I have a lot of a
lot of hardware at home I my wife gets
upset about every time I buy a new a new
one but yeah so myself frankenmuth Garth
Hitchens we're all members of the core
team we have a great community of people
that have also stepped up to be able to
contribute code and libraries and help
with testing and documentation we could
really use anybody to be able to come
along and and give us a pretty-looking
facelift on our site and some
organization documentation is definitely
one place that we were really trying to
attack and bring up to speed but
currently as we are we we put a lot of
our time effort and money in it
ourselves we really want to see it
succeed thank you so much thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>