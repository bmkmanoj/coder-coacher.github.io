<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>RefactorErl by Melinda Tóth/ELTE-Soft Nonprofit Ltd | Coder Coacher - Coaching Coders</title><meta content="RefactorErl by Melinda Tóth/ELTE-Soft Nonprofit Ltd - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>RefactorErl by Melinda Tóth/ELTE-Soft Nonprofit Ltd</b></h2><h5 class="post__date">2017-09-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nUa_aF7dyWk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay just try and do it working could
you hear me okay thank you
so ah thank you for the introduction I'm
Melinda thought coming from Hungary I'm
a researcher at Ashland University and
working with refactor what you may heard
the name of refactor are maybe some of
you heard some talk before about
refactor as well today I would like to
present the main cost comprehension
functionalities of the tool presenting
you some general ideas about why we are
doing it why we are saying that a tool
like that is useful and at the end or
maybe in the middle we will see I want
to show you a short demo as well just to
present that this is working and if you
want you can try it at home as well so
you may ask that why the factory I guess
that your first idea is that this is a
refactoring tool because refactor is the
first part of the name of the tool yes
it is a refactoring tool as well but not
just a refactoring tool this is also a
code comprehension tool and nowadays the
main focus in the development of the
tool is trying to support everyday
software maintenance and code
comprehensions asks so you have probably
a huge amount over a long source code
some of some part of the code may
written by you long years ago or a long
time ago and some of them may written
not by you but some other team members
and in a case like that you just need
sometimes to figure out that what the
code part certain code part is doing and
this is the point where we hope that
refactor can help you
so you will see at the end of the
presentation so what we have is that we
support different to add toolchain we
give a tool chain in refactor and that
has different functionalities like code
browsing and and querying about
different semantic information of the
source code checking the complexity you
can check the complexity of your source
code tries to investigate find we try to
help in in in bug finding and bug fixing
as well try to draw the dependencies
among the source code so once you wanted
to understand a source code or or a
software the source code of a software
you may be interested that what code
power depend on depends on an other part
so this is what we try to do so
basically focusing on grokking I don't
know whether I have that strange letters
or I do not know what instead of case so
we are started as a refactoring project
but now focusing on code comprehension
basically it's an academic project so
this tool developed by several
university students bachelor and master
students and and some researchers at the
University so we try to bring and among
the different functionalities deep
semantic analysis so not just analyzing
the code on token level and and do some
something like a plain text search so we
really wanted to add some semantic
information about this source code as
much as we can find in it so sometimes
doing aesthetic analysis in a dynamic
language like or long is not really
straightforward but we try to gather all
of the information that is possible
together from the source code and we try
to add it and present it somehow
to developers this still is open source
so if you want you can download an and
try it I wanted to highlight three main
parts of the tool the first one is the
code comprehension that is what I will
demonstrate you in a indie demo as well
the other part is obviously the
refactoring part and when I'm talking
about refactoring I'm talking about
different aspects of refactoring so at
first you have the basic refactorings
like renaming or introducing some
variable eliminating some constructs so
just just the basic steps which usually
change only a small part of the code or
may have some effect on other parts but
usually the change itself is not so huge
we have refactorings to support the
introduction of Perak constructs in the
code as well but this is also something
that can be considered as a local
transformation and under refactoring I
mean also application restructuring or
software restructuring when you have a
huge application or or an annual long
software and really it's really hard to
see what are the dependencies in it and
you wanted to split it into for example
several applications then we have a
component that calls clustering
basically to have the source code and
try to split it to smaller components it
can be done on function level so
splitting the set of function to smaller
set of functions or or do it in in a
module level so having a big application
and partition it to smaller applications
for example and what we can do is at
first try
to calculate the optimal or in some way
an optimal partition and also supported
by refactoring to apply these kinds of
restructuring I do not really say that
it's really a refactoring it can be a
kind of software restructuring and the
third part is to providing some metrics
to give a kind of description of your
source code about its complexity about
its quality it's not an obvious task so
we have defined several metrics and
usually it depends on the project what
is considered to be complex and what not
because when I'm telling you that the
length of the recursive change should
not be longer than five or two or
something like that then you may say
that okay I can understand if it has
langston as well so it depends on the
developer and the project that what are
the rules it can be considered as a kind
of design to with that so basically
these metrics usually are are just
numbers and you have to somehow build or
configure it to your own environment
that what you consider complex and
whatnot so the what we think is that a
tool like that may help you to
understand the source code help you to
find sometimes some bugs so you see the
magic bed match in the source code or
function close or something you have a
value and you do not know where is that
value is coming from and you just point
that code for refactor our code part in
for refactor and we try to figure out of
course driven by the developer with some
queries and and try to help to find the
corresponding source code parts
it's good for newcomers as well so if
you have a product that you are
developing and you just want to you know
hire some new developers and this
usually the new developers spending
hours days weeks on on on just browsing
the source code and try to understand
what what's in it or what are the
dependencies and and the tool like that
where thing may happen in it as well so
just to mention some features of the
tool so have the tool is working
basically you we have an environment so
we are taking that we call a static
analyzer framework and a synchronous
static analyzer framework which takes
the long source code and and of course
parse it and creates a syntax tree and
that kind of usual way of static
analysis but after it it makes a step
forward so usually when you are using
extra 4 or C tags or some tools that try
to identify some entities or some
references cross references in the
source code it usually does it on on the
string string level so in in the text or
or some tokenized form all the tags but
what we are doing is that we try to
identify so called semantic entities in
the source code so once we find a record
definition we will exactly market that
this is a record this it has a name it's
located here so it belongs to some files
and whenever we find a reference to a
record we try to identify that which
definition it belongs to
so whenever next time
you will look for certain references
certain kinds of record updates or
something and you just name that I want
the references for this record we can
exactly find only that one that had that
the real the early friends so if you do
it with a plain text search and you just
try to find the references of a state
record then you will have it several
places in the source code but if you if
you try to say something that the state
record that was defined on some certain
modules in the code then you can't
really filter it based on based on a
token based or some kind of search so we
try to during the analysis we try to
link together those code parts that may
be at different point of the source code
in different modules different files but
some house belongs together that's same
stands for function calls so whenever we
find of course a reference to a function
we try to connect it with its definition
we do it in a dynamic level as well so
when we see an MFA or or an apply call
we try to analyze that which function it
may refer and connect it and next time
when you are asking that
where are the references to this
function then we will point you the
possible dynamic references as well and
not just the static ones and as well a
river that it may occur so we have our
compile time analysis try to be as as
broad as possible try to covering the
analysis of different entities functions
variables record module so some entities
of the source code we call it cement
semantic entities and perform some
initial analysis on then so for example
the scoping
of the variable static and dynamic
function call and analysis and some more
advanced stuffs for example data flow
analysis which means that whenever we
see a variable or something in this
source code we are able to calculate
that what are the possible values of
course it will be a static analysis so
we do not know anything about the
dynamic values that may come from the
yearlong VM but anyway if it goes
through its an inter procedural analysis
so we are trapping the control flow and
the execution and and try to calculate
all the possible values I've already
mentioned dynamic call analysis just to
show you some features of the tool one
of them that I wanted to mention is the
semantic queries you may ask that
weather is different from xref yes it's
different because you may ask the
semantic informations not just about
function level but also about records or
macro so you can build your own queries
of course we have some built-in queries
for for often used queries like where is
the definition of a record or something
but you can build your own query and if
you are an advanced refactor a user then
then you can build really cool queries
that gives you lots of information about
the precise information about the source
code I've mentioned the software
complexity metrics but we have for
example the applicated code analysis as
well so you can search for different
applications and if you want you can
eliminate them as well and just marked
the dependence analysis since this is
something that also can be useful but
for huge code bases it can result a huge
graph so
sometimes it's better to filter it out
you can freely use refactor on on
different environments so you can just
install it basically the very core
functionality of refactor air is working
if you haven't or long if you want some
advanced stuff or or the whole
functionality then you need some
additional software or dependencies as
well but basically and we're long is
enough for example if you want to draw a
dependence graph then you need graphics
tool just to calculate the positions so
we have some external dependencies but
basically it can be installed to any
environment and try to use it the main
so if you wanted to use the tool in app
in a team environment it's usually fine
if you just have an installed server for
example where you install refactor and
the developers can join to that server
simply log into the refactor environment
through a web browser and and that's
enough and the basic functionality can
be reached from there but if you want we
have several user interfaces so if you
are a Mac user you can integrate three
factors any max plug-in we have a VI
plug-in as well console interface so I
under console we mean several things so
we have a and our long shell interface
so typing your lung functions and it
prints you out some results and we call
it interactive or long surely shall
interface we have a scriptable one so if
you prefer to script then we have a
scriptable one and we have a console
interface a command-line interface for
Linux users as well and all and and the
web interface I've already mentioned and
all of them can be connected to the same
server so you just install refactor to
your machine start it in an hour-long
shell and and and then you can for
example manage your files from the shell
interface but you
use emacs for refactoring and the web
for browsing the source code so you can
combine it it's easy and we have some
desktop GUI use as well based on WX and
we have a QT based one as well but this
is just a local copy of the web
interface so you can basically just have
a browser and have everything that's
every functionality there so just to
mention that you can try it it's it's an
academic project so it's not really a
product that you buy and it's a hundred
percent perfect
so it's an academic project but it's
already used by the industry as well so
there were several project who tried it
and it's working it's able to handle
millions of lines of code obviously
analysis analyzing a huge codebase
because of these precise analysis I've
mentioned next time but I must mention
that you have to do it only once so our
analysis and incremental analysis so
once you've analyzed your source code we
store everything in a database and when
you change the code then you just say
database synchronization or try say that
analyze it and we will automatically
detect only the changes and analyze just
the relevant part so just to give you a
an example how long it takes for 1.2
million lines of code it tooks around
five hours five to six hours to analyze
it initially but when you are just
updating the code so changing one or two
percentage of the code or maybe less
with one commit then to analyze it it's
just a few minutes or even less than
minute okay so you just have to wait
once just press the button at the
evening and you will have the database
ready by the morning okay Andy and the
incremental update is is usually really
fast mainly the functionality that was
used by the industry is the code
comprehension and this software is
restructuring neither the refactoring
need or other small functionalities were
not tested by the industry but you can
do it if you want so as I said it's open
source it has a wiki page you can try to
use it and let me give you just a short
demo that obviously it looks like
because I've told you queries and that
kind of stuff just to show and then at
the end after the demo I would like to
show you some more functionalities as
well so let me go back to the basic
interface I've mentioned so this is that
and already started refactoring stance
which is just being /c further and it
started after the installation so
basically i've already analyzed Nisha
from OTP this is the source code of the
museum and you can see that if I type a
last it just simply print the content of
the database and now you can see that I
have around 20 or something 25 files
loaded to the refactor edge database and
if you like just type in your lung or
lung function cause you can just simply
type for example Q for querying there is
a have functionality so if you want to
check that have to build a query you can
see of course the semantic entities and
the real queries are not really
here you should check the wiki page if
you are interested in but if I'm just
saying that I wanted to check all of the
functions what I have in the source code
and have a list of it then you just type
more dot funds which which is a kind of
expose dial or something so you have
selectors and build queries based on
these selectors and you can optionally
feel to it so if you wanted to see only
the function that has a name pastor then
you have it obviously this is not what
you wanted to see for example you can
check where this function what are the
functions that call in this bathroom
this is from another library so I'm
interested in that where is it called
then you can see that it's called in the
initial text returned from state
function okay
stream sorry and you can build queries
like that just typing typing and you
have some result if you wanted to work
further with the result you can use this
scriptable interface off refactor add or
you can just print it into a file and
having the line numbers with the with
the result as well and you can script it
and do anything what you want let me
show you the web interface and possibly
the same queries on the web interface so
on the web interface you can type the
same queries so here the same what I've
done before it has a kind of auto
completion so it's a bit better than
typing it in the long shell because it's
a it at least offers you the possible
selectors that you can use so I can type
more dot funds and the result possibly
I'm just showing the
all result is the same as as I had
before you can't compare but it's a much
a bit easier to handle because if you
have a result you just click on the
result and it will show you the source
code immediately so it's a bit easier
than to do the same from the long shell
because then you need a separate editor
or something and and and and to check
the body of the function but here just
you press a button and and everything is
there let me show you a query that is
more than just to have function cause
for example one related to records
obviously I can release the records this
is something that's not so difficult so
I can type mods dot records and that
will list me all of the records if I
wanted to see just these date records
I can filter it so just having it here
and if I click then obviously it shows
the definition of the state record but
what if I wanted to ask a query whether
a certain record with some field is
updated at some point in the source code
so let's see this query which is
searching for the state record let me
try to use this one
so searching for all state records and
that has a field loader queue and I
wanted to find the references references
for this state but I'm just want to know
that where this field updated so why I
want to see that because I have a
problem that the this field has a wrong
value so I wanted to see all of the
places
where this record field is updated so
then I can write a query like that so
filtering out only the record updates so
let me run this query and then you can
see that for example no it was not the
result of this yeah yeah it's the result
sorry
just not the whole state record is
highlighted just the just the field I
will explain it to you soon that's why
okay but this is a record and the loader
queue is updated why it's just a field
which is updated because I have a so
called embedded query here which means
that the semantic query is working in a
way that it always reflects to the last
entity so when the result of the
semantic query is the last sector I've
used here is an expression but if I use
an embedded query which means I'm
putting the query a sub query into a
into a square bracket then it means that
the last element is the difference so
the field reference so that's why the
result of the query is the field
reference and not the whole query at all
so if I'm removing this extra filtering
here then the result will be the whole
record update expression okay so now but
basically the result is the same just
what is highlighted it's a bit different
okay so we may have some other
differences as well just just to show
that all of them is referring to this
certain record okay so I have a few more
minutes so I wanted to show you the
dependence graph as another point of my
demo so you can run no just one more
point
I hunt if the show sorry so when you are
running queries so let me just find one
of my previous queries so I'm filtering
the open log function so you can type
something here and run it and then you
will have the result but in the browser
you can also have so-called built-in
query in a popup menu so if I'm just
clicking on the function name then I
have a function references so I can
check so it's a context menu I can call
the function differences if I'm checking
the clicking on the variable then I have
a variable related context menu and what
I can do is that I can click for example
variable origin that will calculate me
all the best possible value that may
flow to that variable so for example if
I click on one of these elements then it
shows me that this previous log may flow
to the function call as an argument of
the function call it's really
straightforward here because I have a
variable I assign that value to the
variable and then I'm calling the
function is that variable okay but we
can calculate it interprocedural through
different function calls and and and
track the flow of data so just to show a
dependence graph finally as part of my
demo so what you can do is to calculate
that which entity depends on each other
it has two levels the module level and
the function level so you can calculate
that if you have a fun mode you'll what
other modules depends on it or what are
the what is the whole dependence graph
of a software this is what I have here
so you can just calculate as a module
dependence graph this is the module
dependence ground for the media library
and if you okay it seems to be a mess
so there are lots of nodes and links in
it but if you click on some nodes then
it will be dynamically filtered and and
then you will still just irrelevant
results okay so you can see some red
edges as well it means that there is a
cyclic dependency possibly a depends on
B B and on C and C on a so there is a
cyclic dependency between modules if
there's no cyclic dependency you may use
this result for example on based on the
policies to define a load order of the
modules or something like that so this
is a module dependence graph I have
function dependence graph let me try to
show some of them yeah
I've updated the database so it's warned
me that it's probably out of date so
maybe the information is not accurate
enough this is just a filtered one but
you can see that you can filter it based
on what's the starting module or the
starting function you can see that these
are the connections only from the media
and from the active checkpoint function
okay so and you can see that there is a
code applique it's step here there is
one result that highlights you different
code applicate that you can play with it
if you wanted to try so just two this is
the functionality that basically tested
and used as well but we this is just a
technical information and I have a few
slides about what I've showed to you so
now I want to jump on some experimental
functionality that we are developing for
example we try to analyze well-known
applications or well known structures
from the Erlang go TP so for example
lots of the
dopers using generic servers to
implement client-server applications or
state machines or of course super
supervision tree also supervisors or
often used so what we are doing is that
try to analyze these structures as well
so based on the what I've mentioned at
the beginning that was a we call it pre
analysis or a basic analysis and then be
trying to build some post analysis on on
that framework that is not done
automatically when you load the code
it's just that an initial analysis and
then you can run them as additionally so
for example you may have some
supervisors implemented in your code and
then we can analyze and try to draw some
graphs that what are these supervisors
and what are the workers and if you want
you can so there are always a compact
view that is just the basic structure
and there are some details you about it
we can generate kind of um a style state
machines from the from the finite state
machines there are internal
representations as well this is just for
um a funds but we have other internal
representations mmm this is related to
generic servers so if you have some
Jennifer and you wanted to see that what
are the what are the messages that
handled by Jen server cause and and cost
and what are the possible replies for
that then we can visualize it and and
you can hopefully understand a code
better
I think we have a detailed view based on
the function closes of the handle cause
as well because you can say
that okay these are cause and cost or
separated by the different branches of
the eCos and costs and one more thing
that I wanted to mention as an
experimental feature is is the analysis
of the beam files refactor and now is
working on source code level so if you
have a source code then the source code
the urn on five the source of your long
files then we can analyze it but if you
have only the beams then we can't
analyze it so that's why we try to
working on add the compiler and it's not
released yet so we are finalizing it but
basically we are able to handle most of
the constructs from the Erlang code so
for example for this simple obviously
the result won't be the same as the
original code so if we want to analyze
it through the beam code its so this is
the this is a layered version of that
pink function with lots of moves and
registered based operations and finally
we can get something like that which is
really ugly we do not want to know
anything about obviously it looks like
we just need the information so for
example if we wanted to know what is
variable and have the values flows
through the variables then we can detect
from this code so we do not really care
whether we have some extra variables
data flow can just simply step forward
on it so we do not really want to
recover the original code just something
that we have information on it and my
last slide is just to raise some
attention that we are working much more
for example we have functionality for
pattern candidate discovery which means
we are able to analyze that detect some
sequential code part that reflects to a
parallel behavior so for example that
can be replaced with a divide and a
parallel version of divide and conquer
or a map a farm pipeline so that
well-known so-called algorithmic
skeletons so we identify some source
code parts that reflects to that
behavior and we can assist in the
polarization it's not fully automatic so
it's not so easy to do it automatically
but we can assist with refactorings in
the paralyzation process and I think if
you are interested then you can check
the homepage of the tool and check the
functionalities as well so that was my
talk so thank you for listening I just
have some screenshots you know if the
demo is not working so it always happens
and I have a question answer at the at
the end no I do not have a questions so
thank you for your attention
Thank You Melinda do you have any
questions I'll throw this to you each
other some drinks there maybe hi thank
you for you talk at the moment your
University projects do you plan to some
sort of form of start-up and
commercialize what you're doing not
really
we do not really want to create a
commercial project for it so it's an
open source project everybody who wants
can contribute so we are open and if you
want to add something then then you can
we do not really plan to do it the
university has a non-profit company and
if you need some special assistant so
for example a kind of support or help in
the installation or
and of stabbed then this research and
Allen Institute may have but we do not
really wanna to commercialize it another
question no okay well thanks a lot
Melinda thank you
and now we'll listen to you on
Sommerfeld talking about airline meets
python</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>