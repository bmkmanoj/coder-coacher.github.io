<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Witchcraft: Monads for the Working Alchemist - Brooklyn Zelenka - Elixir.LDN 2017 | Coder Coacher - Coaching Coders</title><meta content="Witchcraft: Monads for the Working Alchemist - Brooklyn Zelenka - Elixir.LDN 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Witchcraft: Monads for the Working Alchemist - Brooklyn Zelenka - Elixir.LDN 2017</b></h2><h5 class="post__date">2017-08-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/psdG5iV57q0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">[Laughter]
the title of our talk is monads for the
working alchemists but that's a bit of a
misnomer mostly cuz people go crazy from
Lerna ads this is really a lot of stuff
for the working alchemists there's a lot
of stuff in these libraries it's a
little bit about this talk I'm gonna be
talking about a few libraries for
libraries I'm gonna make it easier to
write algebraic code and elixir and I'll
tell you a little about what that means
in moments and don't worry yes for
reporting a lot of stuff over from
Haskell address pure script etc you
don't need to know any of those
languages it helps but you don't have to
come in with a pre-existing knowledge of
those things I will be throwing quite a
lot at you so sorry but we're only
covering a subset of what's in these
libraries though the one big takeaway
from this talk is once you've added
witchcraft to your dependencies all you
have to do say use witchcraft and you
get everything imported the entire the
entire hierarchy there's a lot again a
lot more stuff in these libraries and
I'm actually really excited to see how
people start using this because we just
hit 1.0 over the weekend so yeah so Who
am I I am EXPEED pretty much everywhere
Twitter github etc I'm one of the
founding partners at robot overlord
software we're based out of Vancouver
Canada and I also run the Vancouver
functional programming Meetup and thank
/ elixir in Erlang plus another one code
and coffee and I've written a couple
libraries and a few more after those too
I also have stickers so if you want
stickers please come see me after the
talk for the witchcraft logo and eyes
are called witchcraft long story made
shorts so especially with my experience
at the function programming Meetup a lot
of people so it's a cross cross language
made up a lot of people coming in you
know really afraid of stuff like you
know monads in applicatives
and categories and all this stuff and so
they'll they'll see somebody do
something and they say oh that's that's
absolute witchcraft that's dark magic
and people know like there's Haskell
golf or they try to you know do the most
you know it's shortest possible crazy
thing that they can do do with these
idioms some people call it you know
abstract categorical nonsense and it's a
bit of a you know gonna have a fun pun
because its we're trying to make it a
little bit friendlier in which crap so
we're just you know calling it out right
right immediately so what so what's so
great about it we get a lot of
abstraction this is gonna look a lot
intimidating for newcomers there's the
scary word monads right there's about a
million monad tutorials online and they
can be a bit of a hard concept to grasp
initially but if you see enough concrete
examples you start to get a feel for it
so I'll be showing a few of those later
and it also has this math basis this
thing called category theory you don't
need to know it right it's it's helpful
to understand the underpinnings of it
but you don't actually need to know this
you will hear people talk about it
though on that topic because I've talked
to a few people here who who have talked
about these things in people reading
papers or category theory in high school
they'll talk about being in the category
of HASC
I wanted a coin that we're gonna be
working in X so if anybody's writing
papers talk about going from from X to X
this is an example of the sort of thing
that people find a little bit mystical
right so we have you know a simple
function and a couple of arguments
getting chained with with some operators
and we get back a whole bunch of a whole
bunch of numbers which is actually every
possibility you know the first list as
the first argument second list is second
argument so on each element of those as
each arguments turned into a single into
a single list so it's the general
reaction
but don't worry it's really really not
that bad right once you once you
understand some of the some of the
basics so why should we even care about
this
so algebraic code algebra here really
you know the lay definition is just a
set of rules for manipulating things
right you know in a sort of structured
way you can make your own algebra as in
fact you do a lot of dsls a lot of
protocols are already already algebra
algebraic code gives us oops
gives us a bunch of useful things right
you have a high confidence in our code
because it's respecting these rules
because we get so much more abstraction
our code becomes very reusable its
declarative so you don't have to go
through and specify you know I'm gonna
do this this this this and this once you
have the concept you can say I'm gonna
do one of these things and here's the
this specifics to fill in the
abstraction so for example a map is a
general strategy for applying a function
to two elements in the container right
and then you pass in the last piece
which is a function to say do this to
each of the elements you don't have to
go in and write new a for loop and do it
everything by hand you have this general
strategy gives you more tools in your
toolbox so you can start to see a
problem and say oh this is you know
blank therefore I can use these
solutions that are already know and you
don't have to reinvent the wheel all the
time which makes them very convenient
they're well understood these are
essentially functional design patterns
there's been a lot written about them
since at least the 1940s and we get some
very powerful things lenses free monad
and interpreter DSL the free monad in
trip a turn is actually really cool
somebody earlier say mentioned being
able to split the structure of a
solution from the actual running of it
and that's a generalized solution for
that I won't be showing it
because we don't have time but that's
something we have and then we can also
unify a bunch of different or seemingly
different concepts that share some some
similarities so for example all of these
things edition whiskey catenation
appending strings unioning mapsets all
of those they're taking two of something
and sticking together and you get back
the same of that same thing again right
so you take two lists and you can cap
them together or you get back another
list and you can keep doing this right
so we have a single concept and the
technical term for this is a semigroup
and we could have a single operator in
fact in witchcraft we do have a single
operator we've overloaded the diamond
operator the the two angle brackets to
do all of these things which also has
the nice side effect of its falling back
to the same behavior for Strings so
crystal is driving our design even
though we're bringing in these otherwise
foreign concepts into a lexer we wanted
to stay fully compatible with your
liqueur elixir ecosystem you should be
able to use this and still use all of
your other libraries together
it shouldn't break anything we want to
have it be consistent with the way you
think about your codes that you don't
have to you know go off and learn
another language and then come in and
you know start working in a very
different way it should feel similar or
similar enough almost like we're
powering up some of the the basic parts
of of elixir we do want to be compatible
or at least portable to bring stuff in
from other languages so when I was
writing doc tests for the library a lot
of the time I was able to go into the
Haskell doc tests copy them paste them
and just run them and it would just work
not for everything you know we don't
have you know an infinite number of
operators in elixir for example so
sometimes you have to make no small
adjustments but for the most part it
just works and then also being able to
teach these concepts so again at the
function programming meetup we have a
lot of people who are interesting these
things but they don't wanna have to
learn you know
type systems and new syntax and you know
it's a lot to get to just get off the
ground Minh the you know these general
applicable concepts and there's a lot of
interest in elixir right now so why
don't we use a language people already
learning to teach these these ideas this
is a quote from a blog post late last
year from Josie
talking about how elixir and Erlang are
functional for pragmatic reasons right
they were looking to solve certain
problems and that happens to have a
functional solution right it was very
you know oriented towards actually
solving real world problems
which is great I had a different
motivation just how can I make this more
like a school and this is a classic
example of the the bulbs paradox so if
you're coming from a language that has
features that another one doesn't have
you're looking and say how can they live
without this but if you're going from
the other way and you're saying like
well why do they have all these crazy
features I don't get it
right and the only way that you'll know
is if you've already gone and you've
learned those things and then you see it
missing right so all of this stuff is
sugar syntactic sugar for regular normal
elixir we just clean up some of the some
of the boilerplate was with
bootstrapping up these concepts so the
three underlying or surrounding I guess
libraries are quark type class and LG
which put together like this so quark
and type class our dependencies for
witchcraft which is a dependency for LG
though LG can can stay on its own it
implements a lot of stuff in witchcraft
so quark first one this actually use in
quite a few projects even production
this gives some of the classic functions
going all the way back to you know the
early days of functional programming
things like being able to flip arguments
in a in a function or compose functions
without having to wrap them in an
anonymous function things like that and
currying where we take a function of a
certain era T and break it up into a
number of nested unary functions single
argument functions so that we can cast
in one argument at a time and pass the
intermediate result around this is very
very important for witchcraft some
things aren't are literally not possible
without it type class enhances protocols
so we get a couple things out of it one
is so the example I usually like to use
is you know so you want to influence
things for enum you do implement
enumerable and then you get all the
functions of an enum well I shouldn't
have to know about another you know
another another protocol another name in
order to get all the cool stuff out of a
gnome so we hide hide the protocol so we
have def class sort of def protocol and
then when you implement it you do def
inst to find an instance of and there's
still a protocol there and you can still
use it normally it's just the class name
dot proto but it's hidden away from you
you don't have to worry about it you
don't think about it we've also added
properties so in order for it to compile
when you have an instance you have to
provide not only implementing the
function at all but that function has to
respect certain properties right so
again using the these
from before when we were able to keep
concatenated more of the same thing on
we should be able to do that forever
right so we should be able to do 4 2 4 3
4 4 etc we also have type crossed
hierarchies so if we can specialize
specialize down so again these things
that can concatenate together really
nicely if we add a starting element 0
element like using list as an example an
empty list you get a thing called Amano
ID and it has some other properties and
some other functions because now you can
make assumptions that this thing has
these other properties and it has this 0
element you could even take it further
right and say and we haven't implemented
the one-wheel 2 dimension but you could
say we don't care what word of the
arguments come in from right that's very
helpful in a distributed concurrent
system because now you don't have to
worry about ordering right it can just
come in and you can just accept it as
needed and the last one is LG which is
short for algebraic data types and it's
just a simple DSL for for writing
structs so here's a little example
so def data and gives you those fields
in a struct and then we're saying that
these are of these types and will give
you defaults for each of those and if
you don't like the default of string
which is empty string you can pass in as
well a default implementation on top of
that we have this thing called a sum so
instead of saying this thing has all of
these we're saying that this thing this
module is going to be one of these other
structs right so in this case we have
nothing in just I'm saying that either
have some data it's just anything
sitting inside of this one struct has
one field or nothing which is a struct
with no fields
you can't even add anything to it for
saying that there's an absence of a
value here
we don't get them at the same time like
we get with a regular struck we're
saying it's one of these or one of those
but there's something similar about them
enough that they're you know two sides
of the same coin right so you can see
that they kind of have this structure
right deaf data i gets nested inside of
deaf thumbs and we'll be using this this
nothing in jest it's called a maybe I
will be using that in examples in a
little bit and so when this gusty
sugared it looks I mean I've pulled it
some extra stuff that comes with it out
we get basically this right you get a
two modules def struct totally empty and
some constructors as well
and this is a don't do this in
production it was simple use case right
we're saying we're gonna add two things
together but I can't add something
that's not a number to a number right so
if I add one and two I'm gonna get back
just three because that's valid
and if I add one in nope I get back
nothing instead of the error now again
don't do this in production because this
is you know you've lost some information
about what's gone wrong this gives you a
general sense of the idea behind it
consistency and language ethos so the
way a language feels and consistency
with the rest of the language so Scala
and Swift have languages scholars and
Swift's respectively and they're
famously referred to as Haskell
fanfiction because people can go and
especially in Scala Phil writes what it
essentially looks like Java and then
other people will write which just
essentially looks like Haskell right and
never the twain shall meet right because
they don't sometimes you can make them
compatible but not always so you'll have
one team working over there doing their
Haskell thing and once been working over
there doing their Java thing we want to
avoid this obviously right you'll want
this to all work together elixir has
drawn a lot of attention because it's
borrowed this you know friendly
community from Ruby it's easy to learn
well-documented you know all the stuff
we think in terms of dataflow which is
very easy to think in because you know
we're just going to do this and listen
listen this a series of steps
Georg transformations so we're not you
know unlike doing stuff in Scala's and
Haskell you know where you're thinking
in terms of mathematical expressions
you're thinking entrance are just
flowing data right and it's dynamically
typed or the other way of saying is type
checked at runtime so you don't have to
learn about a you know strongly typed
system and how to do all the work rounds
for that
what we're trying to avoid really is
this comic
so there's definitely especially in
Scala's and Haskell there's this you
know Lou Bernhard thing that happens
just like you all you know how many
levels of functional programming are you
on right and this is not a hypothetical
so we don't have Pro functors yet but
they should be coming in 1.1 so ok let's
talk about directionality data flow so
to bootstrap up your intuitions on how
all the stuff works
some it elixir we prefer what's called
diagrammatic ordering or data flow with
pipes right so the example on the side
there you know we take two pipe it into
times 2 we get 4 plus 1 is 5 pretty easy
right we want to maintain this because
we want it to feel like the same
language we don't to feel like something
completely different pipes are great
they're easy to think about right so
what if we just take this regular pipe
and just give it superpowers and this
first one you're already pretty familiar
with it's a little bit different but the
basic idea is the same so our operators
are much craft follow the same flow
we're just using the squiggly arrows so
this is what's called a functor go into
a little bit more detail later and all
that it's done is it's taken a regular
set of functions and told it how to work
inside of these containers right so in
this case it's a list right so we still
have 2 4 5 in the middle of the list
we're just running on all of them we
also give a couple other conveniences
for example this is sequential versus
concurrent map right so I realize this
isn't a totally fair fair example but so
we have async map over
is this thousand elements and with a
sleep simulating that it's a
long-running process there of course
different trade-offs when you do things
concurrently there's a some bookkeeping
that happens behind the scenes but as
you can see it's much much faster for
this long list with you know even just a
5 millisecond sleep right so let's keep
giving pipes even more super powers we
can keep ratcheting up the extra things
that these pipes can do they always
follow the arrow direction and we
provide a reverse version because
sometimes is actually easier to think in
the opposite direction right though in
general I would say use the use the one
pointing right so for example we have
this is the map operator a squiggly
arrow we have right and left pointing
and those are totally equivalent
so these are again these are functional
principles design patterns wrapped up in
functions here's the hierarchy in
witchcraft it's a few things in there
right some of them have scary names like
semigroup Boyd don't worry we're only
looking at this bit right now and this
is the bit that gets people really
excited about this style of programming
anyway so this is the one we'll look at
so I said we're gonna look at functors
this is functor you implement map and
you get a bunch of things back like a
sync map and curried versions called
lift so lift is a curried map so any
function that you pass in becomes one
that takes one arguments always and
returns a partially applied function or
if it only takes one arguments just
applies it right it also always returns
the same type that you give it right so
if you give it a map you're gonna get
back a map so you don't have to pipe
into enum got into in a map anymore it's
just going to give you back exactly the
same thing same keys it's just mapping
over the values and it works on lists
the way you'd expect and then as the
example from from a maybe Justin noting
the extra thing that we've said about
this is if there's a value in there run
that function on that value and give me
back that same thing if there's no value
don't blow up don't worry about the
function just give me back the same to
say nothing because there's nothing to
run it on and this is an expected
behavior
the next one is apply it's thinking
inside the box so we take a function and
some data wrapped up in some kind of
container so can be inside of a list in
the inside of a instead of them maybe
inside the map doesn't matter we pull
them out of the container apply them
hence apply and stick it back in the
container this's also adds some
embellishments to the function because
when we're pulling these these values
out there might be other keys that
aren't part of that that application
right and so we have to know what to do
with them when we've struck this
together and put it back in this box
again what we do with these other values
some cases we will concatenate them some
cases we'll add them together you know
you you can you can specify what you
want to do with them right and so that's
the the embellishment that gives us all
the power from this and that
embellishment changes based on the type
of struck that you've passed in or the
type of container you've passed in right
so you can model a system where you
don't have to worry about all these
other things happening and you're just
running your function but these other
things happen kind of a side effects but
they're pure side effects because it's
not happening over there somewhere it's
happening in this very rigorous way in a
pure setting you run it again you'll get
the same result so for example we've
taken the that single squiggle arrow you
added another arrow to it second five
this is what it does one two three and
applied it to a list of three different
functions they don't have to be the same
number of arguments and and functions
and get back each of those arguments
apply to each of those functions as a
single list right so one's pretty easy
but you know 2 times 10 is 20 plus 1 is
3 minus 5 is minus 3 and those are the
three middle ones in the results this
also gives us some some further things
with lift so now lift has it before is a
crude version of map and now we have one
that can do more than one
are you making up more than one argument
on to a function so one two three four
five six multiply them together and we
get one times four times five times six
two times four times five times six etc
and we get all the all the results back
it's not that we're applying lists we're
saying we don't know which one of these
is the one that we want to do you know
no deterministic that our solution is
maybe all of them or somewhere in here
we're going to go look for it later so
that's one way of getting all of those
things and using just again very very
different behavior from a list but it
still has the same general structure
right I'm gonna say one piped in two
times ten is just ten but if I pass in
no arguments in this case we're saying
that's a normal thing that's the thing
that can happen so give me back nothing
or if I try to pipe one into no
functions I get back nothing again
because there's no function to run look
if it's pretty easy
it just says take a take a value and put
it in the right context put on the right
struct for me basically a constructor
right because we're doing this with
protocols you have to pass in a sample
so in this case would be a list and 4tt
gives us a list with just 42 in it
doesn't have to be an empty list you to
put whatever you want it's just this is
the most convenient one and then same
thing with just just 42 gives us 42
wrapped in adjust if you passed in
nothing you'd still get just 42 because
they're part of the same maybe some
Shayne which is the you've been
following the graph on the top right is
the the one on the right hand side but
then it's building all of these together
this is the last one that you have to
actually specify a function for monad
which is the one on the bottom just says
you've done all of these but now I need
some extra properties so you don't have
to do anything else anything special
you're just as long as it's a chain and
an applicative that also does a couple
more properties then it's one of these
two and everything will work normally
right Jane by itself is a lot like like
apply we take a raw value we have this
linking function sorry I mean so we have
our wrapped data in this linking
function that takes a raw value and
returns back doesn't think about value
and returns it back in a wrapped in that
in the correct data structure so for a
just it might be a gesture oh nothing
right and what this gives us is we're
taking some data and every time that we
run a chain which is this three arrow
operator totally run a chain we get back
the same type so we can just keep doing
this forever
so unlike apply where there's a certain
number of arguments that you're filling
in you can just keep going right this
case in the bottom left is a example of
using this as a guard right so the first
case here have just one and I'm saying
if it's even give me back four to two
otherwise I won't be able to do the rest
of these so give me back nothing it
skips the rest of them because it's
always going to be nothing and just
gives us back nothing okay so this is
one way of saying I'm gonna be doing
something dangerous over here don't do
that if I happen to have a side these
conditions for the list example I've one
two three and piped into or a putt
chained into a function that returns a
list with that same element twice and we
get back every element doubled or
doubled twice of every element and we
can keep doing this and keep
chaining in two more right so give me
two of each element and then give me
that element and then times ten and
times 100 and we get back twice 110 100
to 20 200 etc we could keep going and
keep adding more stuff and filtering
things out and so on so this is the the
hierarchy we've been looking at we've
taken pipe which is application into a
functor it can apply and then change to
apply a little bit so that we can just
keep doing it forever so nothing nothing
too crazy right but out of this we get
some some cool stuff and some cool
notation this is du notation for chain
so I have this nested chain happening in
the top and then we can rewrite this
with a macro called chain do the arrows
the left facing arrows 4x that's the
same as when I pipe in binding it to
that function and that in the 10 in the
linking function that does the exact
same thing so start of having this you
know really deep nesting we can just you
know linearize it this way and these are
totally equivalent it gets distribute
into the top version add a compile-time
what we're doing in this example is
we're pulling out values and then using
those in the the bottom in the last line
that just x times y plus said we would
have had to have it nested pretty deeply
in order to get access to all of those
variables what we're saying is we're
drawing out the the inner wrapped value
and we're gonna use them
what attic do very very similar has to
be a monad obviously and you get this
thing called a return which is the same
thing as we had that of an applicative
that basically a constructor pull
something up into the right type
and return just kind of cleans up the
syntax a little bit so that you can make
this more more reusable so when you have
the last line and you're returning
something to the into the right type of
struct you can just say return and it'll
just work for any type that implements
monad so in this case we're going to do
a Madlib with lists so they're passing
nouns adjectives verbs and actions draw
out each now and each adjective of each
verb each reaction return a string and
because I've specified that this is
going to be a list return is going to
put that into a list right so we're
going to have this that last line is
basically this this string in a list by
itself here's my here's my arguments so
I'm just a bunch of random stuff I need
to make this fit on a slide so these
aren't exactly the most hilarious
Madeleine's but oh well and as a result
we get back every possibility for each
of these and so we can go through scan
it and find you know some of the there's
a near ones in there like I think one of
these is the the slide test or deleted
the code oh no do a notations actually
really simple to implement this is the
macro or the the function that runs as
part of the macro and just these three
cases the bottom case is do as normal
there's no special syntax just pipe it
into a function that doesn't take any
arguments or well takes one argument but
ignores it otherwise draw put it into
one with a argument with the right name
and the top one is let which is a
variable binding that doesn't run one of
these one of these effects
got some simple cases or common cases so
the writer monad we have to specify the
types of writer here the function is
just a helper constructor kind of like
new but takes takes a tuple instead what
we're saying is add one to Itali we
don't start the tally at zero we don't
even tell anything about it just add one
to a tally square a number and that's it
and this is wrapped of course in a
function called exponents run that three
times with the chaining function and we
get back because we know now how many
times it's been run which is that tail
line there this is one of those hidden
variables I was talking about where all
we really care you care about is this
return none sometimes num which is our
result we have this extra thing
happening where we're appending together
this extra tally right so I know how
many times this has been run it doesn't
have to be run all together we could run
it like this save it somewhere later run
it again I take the square root of it
and tell minus one and we'll know how
many times this has been squared and
then we can print a little a little
helper log saying 42 to the eighth is
this huge number so really useful for
doing distributed computing because now
we can pass around both we don't need a
centralized logger we can pack we're
passing around both of the value itself
and a log for that specific value
nothing's gonna come into the log out of
sequence right we could run it again a
year from now right as long as it's
still sitting in memory we'll still
continue that same log and we don't have
to worry about like yes you could write
your own logic to increment this counter
but we have a general pattern for doing
this and it's called writer which is
based on monad
a similar example and this time with
strings I'm going to log the initial
value that we get in then we're going to
make a change to the string we're gonna
add an exclamation point to the end and
we're gonna log that with that towel
again and then return the result run it
three times and we get the original
version and the updated version and then
we run it again the updated version to
the new updated version and again and
again and again we could keep doing this
forever we could have other functions
with different transformations and we
could log the before and after state of
it every time it's run without without
needing any sort of side effect at all
this is completely pure so you could
pass it around to different processes
you could make a copy of it
and continue on in a different direction
with it and pass another one to a
different one and you you know then the
logs would be different from each other
and the last thing I want to talk about
is arrows so these are actually I think
there's maybe something in here for a
Luxor in particular this might be might
be interesting
arrows are basically data flow on
steroids right so we can specify a graph
like this so instead of just flowing you
know a single line from left to right we
can split the values and have them run
separately and then combine them at a
later time and this is absolutely
nothing about whether or not it's done
in parallel concurrently sequentially
you can tell it how you want it to run
based on the data type that you pass in
so in this example if I pass in 20
here's the different points along the
graph and at the end we'll just get back
a string with the number 1 in it
right so every time it says split we
make a same copy on both the top and
bottom and then continue on the unsplit
you also need to pass in a function to
say how you're going to recombine them
so for example the orange unsplit we're
saying take the 441 and turn it into a
string and a pendant or prepended I
guess this is the that same graph here's
the Associated code so functions
themselves are arrows and there's this
quite a few of them in fact monads are
also a kind of arrow but don't worry
about that too much for now so functions
are arrows so we can compose them in
this graph and run it and get our data
flow split and merged as we needed and
here's the color coding that goes along
with it so fan-out is that splitting
splitting behavior so from a you know a
couple lines of code we get we can build
up these large structures and not only
that this whole graph is also an arrow
because we've just composes together
create another arrow we can compose this
then with other arrows people is it with
itself split values and put them both
into arrows in parallel if you want to
this is almost maximally higher-order
function right as really high up on the
abstraction scale so future directions
for this work would like to have more
algebraic data types so more of these
structs these special structs I
currently have I think about nine or so
then have these you know multiple pieces
inside them nine nine sums in LG I would
like to pretty print them you know a lot
of trees in there so be able to print
that out without having it be these you
know really deeply nested structs
automatic deriving so any kind of
container is automatically a functor so
we shouldn't always have to
write our own instance of it it should
just work and then if you wanted to do
something special then you can go and
read your own haven't done that quite
yet but that's hopefully soon alternate
minimal definitions this is a really big
one so for certain classes these
protocols you should be able to define
one or the other or both of some of the
defining functions for it right so for
example in foldable which is it shares a
lot with with enum this is reduce right
right fold is reduce you should also be
able to provide fold map because they
can be defined in terms of each other
and you should all spill to defined them
both right and sometimes it's easier to
think in fold map and sometimes it's
easier to think in write fold based on
the type of data that you're working
with this is a prerequisite for
something that it's been the back of my
mind for a while now that I'm going to
be playing with as soon as I as soon as
I or somebody else who wants to
contribute makes this change which is
gennero or maybe arrow server those
arrows that we were showing before
there's no reason that we couldn't use
that as a declarative way to talk about
Jen servers tasks agents and so on right
you could write a data type that in its
implementation creates a gem server and
run something in parallel and that is my
talk some links on the on the right side
there and thank you
thank you thank you so you can take like
one question basically cuz sorry no it's
okay okay just we we need to prepare for
lightning talks so very important
question can we get a question from
someone who hasn't that's the question
yes sorry about that
in a lot of examples that you showed us
you used that thing that just maybe
maybe sing and you always parameterize
this with the integer it was it always
kept one or ten or something so what
will happen if we will have saying may
be parametrized with integer but we will
apply to each piece using some function
that takes value from another domain
from so for examples a string to integer
I I think it will crash in this case
yeah
depends on the function that you give it
so if it's gonna be inspect it doesn't
matter right inspecting concatenate it
wouldn't matter right so it depends on
it depends on the use case is it
strongly typed you know right so you're
not gonna get anything that's going to
prevent it from having these these
conflicts so you as the programmer are
also a type checker in this case so my
general my question was is it a make
sense to have all these concepts from
Haskell you know if you don't have the
main things type safe with you
so you don't have as much help as you
have in a strongly typed language but
you can absolutely so use the concepts
there's nothing stopping you from using
them and another question don't you
think that that that that arrows think
and a new sink in elixir called
flow is doing the same thing and it's
just buildings flow how it will
calculate on based on the data flow so
I'm not familiar but I'll take a look
let's let's connect after and all take a
look at it thank you all right thank you
again another plus
[Laughter]</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>