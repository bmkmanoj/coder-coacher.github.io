<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Conor McBride - Keynote: SpaceMonads | Coder Coacher - Coaching Coders</title><meta content="Conor McBride - Keynote: SpaceMonads - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Conor McBride - Keynote: SpaceMonads</b></h2><h5 class="post__date">2016-11-22</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/QojLQY5H0RI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">it's amazing what you can achieve with
with Twitter it's like do you want to do
this gig oh is it a Thursday yeah cuz I
don't this is my busiest teaching time
I'm teaching three classes at the moment
but I can but Thursdays have no lectures
so I can sneak off and you know do nine
o'clock talks was normally at my
institution the timetable people are my
mates and they understand that the
expecting me to show up at 9:00 in the
morning just isn't going to work so this
is I mean in a different time zone I
might have a bit of jet lag anyway
this talk is based on a homework that I
set my fourth years so I thought I'd
just actually start by by running a
program that's actually written in actor
and it said like this is an
honest-to-goodness terminal window and
and I'm going to you know issue a a
command line requests to run a program
and then my program will run in this
terminal window basically I asked my
students if they would write the simple
window manager that runs using ansi
escape codes in a perfectly ordinary
terminal window when it's got to be it's
good to have at least two windows and
you've got to be able to to move them
around and then you've got to be able to
toggle the window and maybe you know
resize them a bit and toggle back oh and
it's got to cope with somebody kind of
resizing the that's always fun while it
happens and and the the code to do this
is is not particularly well particularly
long whether it's particularly simple as
an
the matter of opinion but but what's
going on well I'll tell you what's going
on if I can only find mine what space
monads so this is an honest-to-goodness
agter buffer and so by way of starting a
conversation how's the font size not the
figler font size that the little ones do
I need to make that bigger yes I thought
I might I thought that would be good too
so it's changed the font it's currently
it's always happens when you plug plug
into an HDMI how's that what sorry oh
yeah that happened earlier I think
let's try turning it off and on again
like you do it's amazing
why should changing the font size mess
the display up yeah any sufficient
manners now yeah that's it then of
course you're gonna tell me it's too
small and I'll go through this rigmarole
again actually that's not what's gonna
happen what happens right if I change
the font size in the other window then I
will have to go through the same rigor
again font for compilation that's gonna
be important
that's 24 as well am i getting away with
that okay and I've got mirrored displays
and my cheat sheet is still hiding
behind the other window right so of
course my original plan was to like walk
you through the homework that I set my
students and then yesterday I decided to
rewrite it completely so so I finished
it at about half-past seven this morning
and then I wrote my slides
but that's more preparation than my
undergrads ever again
right okay
of course I've forgotten what I was
gonna say so I always leave leave myself
some some notes right it's basically you
know one of the most marvelously useful
facts that that the perimeter of some
sort of area scales much more gracefully
than the area itself right so take a
circle if you scale up the circle
the circumference of the circle will
grow linearly while the area enclosed in
in the circumference grows quadratically
and this has been absolutely vital to
human progress for longer than anyone
can remember
because basically basically right back
in the hunter-gatherer days it all got
so much simpler when somebody invented
the fence I mean you know the macho
hunter-gatherer people thought fences
were kind of cheating and you know they
would point out that there were tasty
animals outside the fence and it was
sometimes necessary to go and find them
but you know keeping keeping you know
lots of handy animals that that could be
you know managed inside the fence made
you know so much more production
possible and then all you had to do was
maintain the fence and if you wanted
like a bigger area you could you could
you know you could quadruple your area
for only twice as much fence so the
message is if you want
to create a workable space manage its
boundary I could make some tart remarks
about taking back control of our borders
but I'm but I'm Irish and they promised
us that they wouldn't write what's all
this got to do with dependent types of
what's going on anyway well let's sort
of have a dependent types 101 this are
the I'm not loading any libraries in
this file so you're pretty much seeing
everything so I'm going to sort of kick
off with a typical example which I'm
actually going to use seriously so I
start by saying what the natural numbers
are in kind of reassuring the efficient
unary and and how to add them up and
then here's that the the typical example
of numbers being used to control
precisely the length of Lists we call
length indexed lists vectors and you can
see that there's an empty list called
nil which is known to have length zero
and a cons constructor which increments
the length of the list and then we can
we can try to to write some programs
let's let's have a bit of that so we
might for example want to concatenate
vectors which should mean that we should
add their lengths so so it's too early
in the morning to do that sort of thing
so I'm just gonna ask AG de to do it and
because there aren't very many programs
of that type it just guesses the right
one it's not a very pretty program but
it's saved me writing it clearly does
the right thing and then what else might
we want to do well if we have like one
element of X and we want
to make a vector of exactly n elements
of X well there's only one thing we can
be really which is just to copy the
element we've got the right number of
times so there only is one program of
that type so again I'm just too lazy to
write it and then another thing we might
like to do just by way of example this
is sort of a zippy example here we're
using the length invariant seriously
we've got a vector of functions from s
to T there are n of them and we've got
exactly n elements of ass to feed to
those functions so we should be able to
pair them off and and produce a vector
of n elements of T and again it's just
such a boring thing to do that that
actor does it for me so sort of people
sometimes have this strange idea that
typed programming is if you're pardon
the metaphor a challenge rather like
pissing over a wall into a bucket and if
you you know and sort of impression is
that you know if you make the types more
complicated in more precise than the
wall gets taller in the bucket gets
further away but that's that's not
what's going on at all if you're if
you're making a more precise down
payment in when you write the type of a
program then there are fewer choices
that you have to make to refine that
type to get a program so the work moves
to designing the type and once you've
got the type then cranking out the
program that turns that into a bunch of
algorithmic choices is much less work
than it was before
of course designing the type is
non-trivial you know so that's why
that's why I only I've written all the
types in my file and I've just got to
write programs
but yeah so it's sometimes that's that's
where the effort goes it's moved to a
different place it's moved to a
higher-level place and that's a win you
know lots of people try and flog you
type inference but I'm type inference is
so last century the the right thing to
do is to write the type stone and then
get as much mechanical assistance
generating the programs as possible
anyway what am I going to use vectors
for I'm going to use them at least a
little bit as matrices so I'm going to
so if I give define this type of of
rectangles rectangular dimensions width
and height then I can say what a matrix
of roses by saying it's its height many
vectors of width of the given width okay
so that that type will come back and you
can see it's very easy we know that all
our rows are the same length it's not
like a list of lists in Haskell or
something like that
so these things behave nicely and it's
possible we can kind of fit them
together in nice wear so this is one
tool we've got to help us control the
use of two-dimensional space is to
actually manage the the size of things
okay I've got no idea what's on the next
slide oh yes yes so here's here's some
other stuff that we've seen vectors
indexed by napped and weave matrices
indexed by rectangles or or pairs of
knots now let's let's figure out just
hard to work in the indexed world in
general so we're going to see a lot of
these things things that live in
something arrow set iro set where I you
can think of as index and so what is one
of these things well it's it describes
what it is to fit
I so we've got for example our vectors
had to fit with their length so we've
got some notion of data that has to fit
with some information that describes
some important property of it and then
it's reasonable to consider if we've got
two such notions for the same note for
the same kind of index when when do we
have an index respecting function right
if we have and so this funny arrow means
yeah it's one of my worst habits
actually I routinely define infix binary
operators which take three arguments I
can't help it it's it's a component I
use them in a higher-order way right so
so this s funny ro t is the indexed set
of functions which for a given I may
turn SS that fit with I into T's that
fit with I and then here's how I use
that thing I have this set of square
brackets which wraps up an indexed set
as a set just saying well I have one of
these for every index and that means I
can write down a notion of arrow between
indexed sets which says so at one of
these square brackets X funny arrow Y
means I can always turn X's into Y's
preserving the index okay so let's just
see that if I normalize arrow I don't
know how to make the mini buffer font
bigger then then the type of of one of
these things in boxes is for all I that
will use this curly braces mean this is
usually kept implicit but it's a
universal quantifier for all I we can
turn an X I into a Y I so we've
established that we've got some notion
of arrow
not between sets but between indexed
sets so the obvious question to ask is
if you've got some notion of arrow is is
it a category right do we have we got
the usual bits and pieces to make it I
mean this may not be it's obvious it's
the obvious question to ask if you if
your office is next door to Neil Barney
all right so do we have an identity
arrow that gets us from X to X well
actually perfectly ordinary identity
function is polymorphic enough to fit in
that hole and if we have an F that gets
us from Y to Z and a G that gets us from
X to Y can we compose them well yeah
perfectly ordinary function composition
well plug those things together just
fine so we've got so ordinary identity
and composition will work for these
index respecting functions and
composition is associative and absorbs
identity same as usual
so we've established that for not our
usual notion of aro we've got our usual
stuff so that's that's good what else do
we have well we've got some notion of
what it is to be a functor between
different notions of indexed set and
that so f maps i indexed sets to j
indexed sets so if we have an i
respecting function from a to b we
should be able to construct J respecting
function from F of A to F of B that's so
that's just the that's what would make
such a transformer a functor and you
note that I and J need not be the same
thing so for example
vectors are numerically indexed but you
can treat their elements is just being
indexed by the unit type and you get a
perfectly sensible functor that says if
we have a map from elements to elements
we have a length preserving map from
vectors to vectors but if we've scaled
as far as functors that's Basecamp
then let's then let's shoot for let's
shoot from on adds and you know I wonder
kind of what sort of weirdness is going
to result from that okay so what do we
have to give to make some sort of air so
now I've chosen W I think I in my head W
stands for world here we're indexing by
some notion of how the world is and
we've got something that map's W indexed
sets to W indexed sets and when is it am
honored well if we know what the arrows
are then we can write down what the
usual stuff has to be okay I have I've
written extend that's flip bind if
you're a Haskell ax rather than bind
itself but you have to provide two
things you have to provide something
that takes P to F of P and if you have a
P to F of Q then you need to be able to
Jack that up to an F of p2 F of Q it's
the same types that you might be
familiar with from from Haskell it's
just I mean the same idea it's just that
we're doing it with a different kind of
arrow in a different situation but we're
doing exactly the same thing and what on
earth does any of this mean isn't all
kind of scaly abstract well I'll tell
you what happened I was sort of staring
at this definition the first time I
wrote it when when Peter Hancock walked
into my office
Peter Hancock he did the first
implementation of type theory in in 1970
and he also wrote the
yes it's amazing how someone with such
terrible teeth can achieve so much and
and he walked in and he said oh poor
logic why did he say that and then I
realized that it was a perfectly
sensible thing to say right if you cross
out set and write proc right if you
think of these things as properties of
the world right what's one of those
it's a condition and then what's one of
these things it's somehow captures the
idea that if P holds there's some
computation which can achieve Q that's
to say to build something of this type
is to write a program which can deliver
post condition cue whenever precondition
P holds that's to say ah you know to say
this program has that type is exactly to
write down a whore triple goodness me it
was going to be scary 21st century
category and it's the 1970s right so
what does the type of retic s-- tell you
it says if the precondition holds there
is a strategy for achieving it right if
huh if that's to say you can you can
satisfy a post condition if it already
holds by doing nothing that's to say
this thing weird retic thing is the
thing you call skip and then if you jack
flies the extension up too closely
composition then you get exactly the
horror logic rule for semicolon
you know if you have a program that can
achieve Q from P and another program
that can achieve are from Q then putting
a semicolon between them gives you the
program that achieves are from P so
goodness me
man adds on index sets not weird just
like how we think about programs at all
and it's kind of fun also so there is a
bind one thing that's amusing about that
I don't like the bind for this because
its type isn't pretty I have to break
things apart but you can see the idea is
if starting from world w we can achieve
P somehow and then in any world where P
holds we can get to Q then we can get to
Q from W but you'll notice that this
quantifier is at rank to the caller of
bind does not get to choose V they have
some V thrust upon them by the world
right all we've done is specify a post
condition for for the first computation
that's P and then the world is free to
choose any state in which the post
condition holds and they can try and
choose that to mess us up as much as
possible so we better make sure that the
post condition says what we care about
and it's that freedom to to let the
world choose a state that satisfies P
that means these are the right thing to
model contingent interaction with a
hostile environment because they
actually model the fact that there are
some things we don't control if we write
a weak precondition we're saying we only
know this much and then the world is
free to satisfy that so this is a very
useful notion there is a notion of laws
but I'm going to skip over that because
they're the usual laws I mean they're
just the category laws let's think about
what a spaceman ad is now that we know
what a monad is well the index in this
case is going to be the perimeter of the
spin
I promised you we were going to manage
the perimeter so we're going to talk
about things that fit with the perimeter
now fit into a perimeter so what do we
need to be able to do with our notion of
perimeter we need to be able to cut it
up so I explain in general what it is to
be able to partition a perimeter you
have to be able to say given a perimeter
what are the ways to cut it into pieces
so that's what this field of the record
is for a given perimeter P there is a
set of ways of cutting it up and then
once you've cut it up like if you were
cutting up a piece of paper or something
then you need to say what pieces you've
cut it up into and what their perimeters
are so that's the idea of of hard to cut
things up you you say what cuts are
possible and what pieces you get and you
specify the pieces just by listing their
perimeters and then we get a notion of
we got a space monad which is a heart of
Bill how to tile the interior of a
perimeter with pieces built from this
thing this of this X is a a set of
pieces with given perimeters and they
are the tiles that we are allowed to use
to tile the interior of our perimeter P
and there are two constructors one says
if you happen to have a tile which fills
the whole interior then you can just
stick it in there you're done
the other strategy you have available to
you if you're trying to fill up
perimeter P is to choose a way to cut P
up and then you have to explain how
you're going
to tile all the pieces that you get from
cutting it up so this all thing
it's a predicate transformer it says if
you've got it a set indexed over X we
can lift it to a set indexed / list X by
saying I would like one of these for
each element in my list so what I'm
saying is I would like an interior
tiling for each of the pieces coming out
of the cut right so that in general is
what is a you know a way of talking
about space with respect to its
perimeter and I realized it's all got a
bit abstract and I need to pay attention
to the time so let's let's without
further ado I should actually have no
not without further ado I forgot this
slide should actually implement the
operations so we can see that the return
is going to be just the thing that plugs
a tile directly in but then we need to
build something which says well if we
know how to make X's into sort of
tilings of wise then we can make tilings
of X's into tilings of wise if you want
to think of it like that
so what do we do we we just get cracking
you're going to get that one no
sometimes you could be too lazy right so
it's my constructor for cutting things
up this should be called exercise
and then this that should be P and P's
those are the perimeters this should be
1x and this should be a bunch of it I
have to chooses terrible names yeah
that's the marvelous thing about it I
mean there was only one thing that would
type checks are Weibull yeah why keep a
dog and bark yourself so right so we can
build so what's going on we're just
digging down through the structure
looking for the tiles that it's made
from and then for every X tile we know
how to replace it with a Y interior
that's exactly the right size to fit in
the space where that tile was so I'm
hoping you got a kind of reasonable
spatial intuition what's going on we're
talking about replacing you know things
that fit a perimeter by structures that
fit the same perimeter right it's time
we had an actual example let's see how
to cut rectangles so I'm saying that if
we have a rectangle we might want to cut
it you know allow cutting it in an axis
aligned way so we might want to cut a
rectangle into a left to right a bunch
of pieces that's to say we should be
able to split the width of the red core
of the rectangle into two components
which should add up to the original
width and similarly we should be able to
cut a rectangle horizontally if we can
think of two numbers two heights that
add up to the original height does that
seem like reasonable ways to cut up a
rectangle and then what size what are
the pieces we get well for each cut we
get two pieces and I hope you can see
I'm just I'm just saying the two
pieces we get from cutting into a left
piece on a right right piece have the
original height but the two smaller
widths and similarly if you cut into a
top and a bottom then they have the
original width and the but the new pair
of heights so that's the same know here
is one one notion of perimeter
rectangles one notion of cutting it up
in an axis aligned sort of way
okay so just instantiating space monad
with that way of cutting things up I can
consider the problem of of how to to
tile the interior of a square so no lead
to whether you terior of a rectangle
that's 13 wide and eight high and the
pieces I'm allowed to tile it with are
squares you can see here I've I've given
myself giving myself some grief I've
said square is the type of rectangular
indexed things where the only things
which exist are squares right you can't
make an element of square width height
unless width and height are equal so the
question is can we can we tile the
interior of a 13 by 8 rectangle with
squares well let's see what we can do if
we make an LR cut like an only type well
let's let's cut it into eight and five
and then my proof that the things are
equal is reflexivity and then I have to
give two pieces and you can see I'm
being asked for an 8 by 8 square and a 5
by 8 square or if I be at rectangle
interior
I haven't had enough coffee so I can put
a square there and then I could keep
going of course I'm glad I left myself
that note Oh too far alright so here's
here's one I made earlier and you can
see I'm busy
cutting cutting up according to the
Fibonacci series to make to make this
this tiling with 8x8 square on the left
and then on the right I've got a 5x5
square on the bottom then a 3x3 a 2x2
and a pair of ones so wouldn't like
check if the pieces didn't fit right so
that's to some extent what's what's
going on here I've got a bunch of
rectangular regions and I'm guaranteeing
that they fit into the current viewport
size but how do i generate a bunch of
text to splat out
right so to do that kind of rendering I
need to be able to paste things together
and to do that I need some extra
apparatus right that here's here's what
we're trying to achieve suppose we've
got an interior of a wreck of a space
made of X's and I want to glom that all
together into one big X right so
remember these funny arrows have to
preserve the dimensions so what I'm
saying is I've got like a packing an
interior made of packing lots of X's
together and I want to smoosh the X's
into one big X with the same size well
then what do I need to be able to do for
any way of cutting up space I need to
know that if I have X's for all the
pieces I can put them together to make
one X with the original perimeter and if
I can do that then I hope it seems
reasonable that I can take interior made
of X's and manufacture one big X so
let's son let's do that for four
matrices right so you might like so if
we actually if our rectangular things
are really matrices of maybe characters
or something like that then we ought to
be able to actually glue these
rectangles of characters together to
make big rectangles of of characters so
so what do we have to do we have to be
able to explain how for any way we can
cut to take the pieces and put them
together so it's just as well we wrote
all those vector operations I think this
one's done with this thing
oh no there's no plus there yeah that's
that and then I think this one's made
with these things yeah that'll do I mean
you know it's the the fact that the
pieces aren't have their sizes means
that they only fit together in
particular ways putting them together in
ways that don't fit one type-check so
you can just say well you know here's a
bunch of staff try and put the pieces
together and then basically but right so
this this this mechanism by the way is
it's a sort of byproduct of quick check
so the people who were working on quick
checker charmers had to do all of this
stuff to generate terms as they as tests
for for programs and then what they
decided to do was plug that into the
type checker right so all it does is it
generates kind of a generate
systematically it's actually small check
rather than quick check systematically
bigger and bigger candidate terms that
might go in the hole and then you get
the first one that type checks it's very
very cool okay time is marching on I've
got one more thing which isn't terribly
interactive in and I'll try to be
interactive but this is this is the key
the key gadget and I just want to point
to to the types that come in and the
types that go up let's let's switch on
the electricity oh no I've copied it
wrong from my that's time to cheat
here's one our NATO
right what's this thing this is the
thing that lets you do those multiple
layers right you can see I've got a
front layer and a back layer and each
layer is a rectangle that fits the
window but some of the regions in each
layer are transparent so what I need to
be able to do is to take two layers
which have some transparent regions and
flatten them into one layer so that you
can see through the transparent things
in the front layer to whatever is behind
in the back layer and that basically
means whatever way the front layer is
cut up we need to be able to forcibly
cut the back layer up that way too so
what's the equipment required to do that
well for a start
whatever type what so here X is what's
in the front layer and Y is 2 X are the
tiles of the front layer and Y's are the
tiles in the back layer so we say well
we need certainly to be able to cut wise
up that means if we have a way of
cutting up the perimeter and we have a
big Y that has the perimeter we need to
get wise for all of the pieces that you
get when you cut the perimeter up for
any way you want to cut it up and
similarly you need to know that whenever
you can cut wise up you can cut up
interiors and get all the interior
interiors for all the pieces that'll do
it for us then we can build this
operation which I call masks so what
what do we have to feed it well we have
to feed it a way of cutting wise up and
then we're trying to achieve something
which takes an interior
full of X's and an interior full of wise
and produces an interior full of zags
and notice that this type says that the
perimeter is being preserved all the way
along right so we know that that these
these rectangles fit exactly they're
ready for a super imposition and the key
thing you need to provide is given a
single X tile and an interior Y that has
been cut to fit you need to be able to
produce a Zed Zed of course could itself
be an interior so how do you do that
well you just by recursion on the
structure of the front layer and cutting
the pieces of the back layer to fit
that's all that's going on there's
there's some fun stuff which so the
business of cutting up one of these axis
aligned things is is highly amusing
right so the crucial thing is you know
how you want to cut it up but then you
see it's being cut up differently right
so if if you've got a you know if
somebody hands you an interior that's
cut here and you want it cut there what
do you do well you cut the piece that's
on this side where you want to cut it so
the crucial thing is is this thing
if you know that you've got the same n
split up as X plus X Prime but you can
also split it up as y plus y Prime
then you can compare the two places
where you've split it and there are
three possibilities either you're dead
lucky and they match exactly that never
happens
or you know that Y is X plus some
overlap in which case X prime must be
the same overlap plus y prime yeah so if
you comparing cutting here with cutting
here then you know the region this side
if this has to be cut here that's all
that's going on and it's just a fancy
version of the usual way you compare
numbers it's just a delivering so you
know you split it into 0 vs 0 0 vs. a
successor successor vs 0 successor vs
successor make a recursive call put the
pieces back together again so that if
you know how you how to compare the
places where things were cut then you
can you can build this cutting up
technology and that gives you the
ability to do super imposition and then
all you need to do to get this thing
working nicely is remember which layer
is in front and then render each layer
as either transparent or matrix of of
character blocks and then splat the
whole thing down to one big matrix and
then when you render it in curses you
can almost watch the cursor move and
it's extremely slow and unbearably
flickery
so what you do instead is just remember
which things change and have a slightly
nicer masking logic where you remember
for each sub rectangle whether its
transparent or full of stuff and whether
it has changed or not and then you get
the right flattening logic that tells
you only how to redisplay what's changed
and then you run length encoding or
cursor movements on the way to the
terminal and you get something that's
almost nice let's have it again
you see smooth as silk right okay where
am I going with all this I can tell I
should shut up it's so small this font I
can't find my slides right I'm not so I
wrote the conclusion oh yeah right I
mean that that so what what what do
types I've shown you literally a use of
dependent types managing the way sort of
geometric objects can be fitted into a
perimeter and that's a sort of rather
visual metaphor for what for what types
do in general types characterize the
ways in which we want our components to
fit I mean a perimeter system II what
that's what types do types manage the
perimeter and they create a structured
space into it inside which to construct
you know well-managed things and you've
seen in the course of this talk how much
how much agricultural machinery we have
for the business of raising programs
inside a well-built perimeter you know
rather than the 20th century practice of
running out into the wild with a spear
and you know throwing it some lump of
Lisp and hoping that when you've dragged
it back to the cave you can figure out
what type it has so you know that's the
types are some kind of of hmm this this
might be a wildebeest it's certainly
dinner you know types us as
classification for wild things that we
do after we've caught them but before we
eat them well I did in order to avoid
that kind of was it something I
experienced you know the this this idea
that they'd like types describe
phenomena types come out from stuff is
completely you know the the wrong way to
use types right types capture our
requirements we push them in and because
we're pushing them in we can do we can
do structured organized intensive
agricultural raising of well behaved
domesticated programs so it's time that
we stopped being hunter-gatherers let's
be farmers and invest in good fences
it's there somebody supposed to be
saying yeah there are some questions I
can see what error messages well okay so
I asked what error messages in for two
reasons
neither serious I mean so on the one
hand the young the whole of the game is
to is to navigate the space of
unfinished programs that tight check so
far I mean one so when you fill in when
you fill in holes each move you make you
can only make moves that the type system
will agree with and indeed you often
make moves that the type system suggests
and correspondingly you encounter errors
in that process relatively rarely those
of course something to something else to
be said meanwhile of course when you
encounter errors in these situations
they well error messages are as good as
the technology that has been invested
into producing them and the people who
build these tools don't often
I mean Edwin and David is that done much
better job of this than the Swedes have
with Agda
it's it's a class of of activity that
that Heinz both remember Heinz full from
Brunel big you know mad hair bald on top
great egg race he used to classify this
sort of research as uninteresting
research into necessary equipment or
urine and and that's the total is that
you know it's really it's really
necessary stuff but
but people don't invest time in it
because it's not as much fun
doesn't feel like really you know
frontier frontier busting stuff of
course what you have instead of nasty
error messages from the type checker is
the realization when you're deep into
some hacking problem that you wrote the
wrong type in the first place
and that you actually need to think
again what the specification of the
problem was you effectively you get
specification errors in some form and
that's where the technology is
completely missing I mean one of the
things so you can see you know I'm there
I'm filling in holes I'm getting the
machine to help for me I've figured out
what the types are in advance because
I've done this before not my first rodeo
and all the time I'm in Banzai mode
right the the subproblems are getting
simpler I'm working towards filling in
the last hole that is maybe 5% of my
packing time if I'm lucky the other 95
percent I've written the wrong
definition I'm wondering what the right
definition is my my Emacs buffer is no
longer managed by a type checker and in
color I'm back in Kansas it's all in
black and white I'm editing text trying
to restructure my definitions to get the
next attempt to work better and there
there is where the is scope for
considerable technological improvement
but it is not currently happening and
Simon we ought to make it happen I was
going to ask a question of exactly about
that so the it was a beautiful
presentation and we saw it was all done
seamlessly but how do you develop
programs
now how did the 95% of us develop
programs using this yes sir I have the
advantage that for like months at a time
I don't get near a computer as I'm
teaching undergraduates so I
occasionally sketch out the next bit of
the plan on the back of an envelope next
in my pint and and six months later I
actually know what the type of that
function should have been yeah so there
are lots of things going that there are
several crucial pieces of technology
currently missing one is refactoring
technology for failed programming
attempts and the other is the gradual
design of more interestingly indexed
types I mean you saw that there were
separate data type declarations in my
file one for lists one for vectors as if
you know I woke up in the morning and I
thought I've an amazing idea for a data
type lists I've learned then you know
next morning I've had another amazing
idea for a data type vectors and I can
say to you vectors are lengths indexed
lists but did I say that to actor did I
say there is this thing called lists
already and we're going to make it
fancier by turning it by imposing this
extra invariant that we think we care
about that was nowhere in the code
disaster so it's partly that we're stuck
trying to use the language designs from
the functional programming of the 90s
which never had to move in these
indexing dimensions or deal with any of
these issues I mean we can't blame them
for not thinking about how to manage
phenomena they just didn't even
encounter but we can ask ourselves you
know if we were just trying to make
something like Haskell but with
dependent types are we really you know
are we really making the best job of
exploiting dependent types answer is
clearly no there is clearly technology
missing here but there's also clearly
lots of potential oh can I ask one
question
sure can you imagine a dependent to time
language without Haskell's kind of
purity so if you like dependent iPod oh
come on I can certainly imagine a
dependently type language in which
effect for programs were written in
direct style and indeed I'm planning to
build one but I certainly think it is
good to keep track of what the effects
are so I wouldn't want just as I don't
want to be able I don't want to be
forced never to know if I want to write
a total program I want to be able to be
sure it's total I want to say this is
the promise I'm making this program's
total i similarly want to be able to say
this is the promise I'm making this
program won't do side effects but but I
don't want that to be the only deal
that's available and it's perfectly
reasonable to consider how to do managed
side effects including of course
partiality okay let's say thank you to
the great doctor</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>