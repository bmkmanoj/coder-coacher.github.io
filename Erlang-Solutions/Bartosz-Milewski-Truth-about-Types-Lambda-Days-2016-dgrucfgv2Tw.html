<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Bartosz Milewski  - Truth about Types (Lambda Days 2016) | Coder Coacher - Coaching Coders</title><meta content="Bartosz Milewski  - Truth about Types (Lambda Days 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Bartosz Milewski  - Truth about Types (Lambda Days 2016)</b></h2><h5 class="post__date">2016-03-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/dgrucfgv2Tw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">okay well let me start by really
congratulating the organizers of this
conference it turned out to be a very
good conference and I'm really happy to
see so many young people who are
interested in functional programming
that means a lot it means that the
functional knowledge is spreading very
quickly and not only in in programming
per se but also I notice that there is a
lot of interest in the theory behind
functional programming and the
philosophy even of functional
programming so that's that's very
interesting I prepare to talk about more
or less very similar topic or a
continuation in a sense of what phil was
talking about in his opening keynote and
I must say we did not really coordinate
this it was like two separate people
came up with the idea of talking about
propositions and as types and curry
Howard isomorphism which for me is a
sign that this might be an important
topic that the time came to actually
start talking about it and spreading
this knowledge among programmers it
might actually become very useful and
and and its really mind opening to think
about that the stuff that we do you know
doing spreadsheets and java code and and
websites that actually there is
something behind it it's really
fundamental and basic that actually
relates to mathematics in such a
deep very very deep way so there was a
little bit of discussion about what what
does it mean what does it mean that
there is this weird similarity or
isomorphism between fundamental
mathematics which is the on the one hand
logic right different types of logic and
programming type theory lambda calculus
and I'm going to add to it one more
thing and that's category theory and I'm
glad that Phil talked about curry Howard
isomorphism so much so that I can
actually concentrate more on what what
my real passion is that's the category
theory so I'll show you that actually
this isomorphism is extended to not two
things but three different branches of
mathematics if we consider programming
also a branch of mathematics so the so
there is this question you know first of
all why are these three independent
independently developed theories why are
they actually converging why are they
they look sort of like three fingers
that are sticking out of water right and
we did not realize that there is
actually a hand below the surface of the
water and these three fingers are just
part of this hand right what does it
mean and then there is category theory
and the kata category theories is sort
of the arm the expanse from his hand you
know maybe the whole body because
category theory describes essentially
all our knowledge about mathematics
it just obstructs stuff from so many
branches of mathematics
six no you can you can do topology in
category theory can do measure theory
you can do logic Banach spaces no it's
all it all has this basic structure that
can be abstracted into categories why is
it well so some people say you know this
is this is a discovered thing that there
must be you know something in this
universe or in multiple universes
writing multiverse that you can't even
imagine how this can be any different it
just we are just digging out and
discovering like you know a lot of
mathematicians are play tennis
they play Plato believe that there is
this absolute truth that we are just
discovering and I thought about this I
because this is this is a problem that
always interests me especially as a
programmer you know how how do we
program we always program and invent
programming languages and write our
programs in a way that's composable
right like this is the most important
thing your programs have to be
composable so that you can split a huge
problem chop it into smaller pieces
solve each of them separately maybe chop
these pieces into even smaller pieces
and so on and then we have to compose
the solutions to these problems into one
bigger problem what one bigger program
right so so this composition is like
intrinsic in programming and if there is
this commonality between programming and
different branches of mathematics and
then there is this commonality between
all branches of mathematics and category
theory then there must be something
be deeper behind it right and what what
is common among all these things and
this is what categories here it tells us
is the principle of composition right
I mean I'll talk about the definition of
category now and you'll see that a
category is really about nothing else
but composition till tells you how to
compose things from smaller things
that's the essence of category theory
so if category theory describes all
these other branches of mathematics and
and then then what is this thing that
all things tend to compose is that like
intrinsic thing about nature that things
have to compose but but mathematics not
really even about nature right I mean we
think we are discovering something it's
more about our minds right we
discovering physicists discover our
elementary particles they are part of
this world right but but mathematicians
discover ideas and these ideas sit in
our brains and we know why we are doing
programs in a composable ways as
programmers we understand this that's
because of the limitations of our brain
we just cannot do this stuff if we try
to solve the whole problem at once the
only way we can deal with problems is by
dividing them and then recombining the
solutions so composition for us is just
a way for us humans with the monkey
brains to deal with reality to
understand it and to develop our
theories so developing theories about
about stuff is really studying
how to make things understandable
through the monkey brains okay so the
fact that we always try to split
everything and then recompose stuff is
really the property of our brains and if
somebody had different kinds of brains
some other civilization in some other
universe maybe they wouldn't have this
maybe they wouldn't have category Theory
categories here it tells us that all
these things are similar why are they
similar because they are created for our
monkey brains
there are things as a physicist I can
tell you you know that we always try to
decompose things in physics and the
deeper we go the less composable things
really are you know like people thought
about atoms ancient Greeks and you know
atoms are these elementary things and
you compose a bunch of atoms any good
substance substances you know and then
we discovered all atoms actually they
consist of electrons and protons and
neutrons okay then we look at protons
and neutrons zero there are quarks
inside and so on now we are trying to
understand quarks and we are trying to
understand the standard theory and we
are thinking you know maybe they are not
really that elementary maybe they
contain something inside maybe the
strings maybe membranes stuff like this
and in quantum field theory so classical
mechanics is really easily decomposable
you know we think of like things moving
in space and hitting each other and so
on interacting and we can we can
describe the movement of each particle
separately and then combine and and get
the whole description of the whole
system right but in quantum mechanics
that's not really true
if we are trying to describe one
particle that's easy but that's that's
just one particle not interacting with
anything else the moment we get two
particles if they are far away and we
can forget about their interaction then
then they can be described separately
one wave function another wave function
well just add them okay and you get a
sum so that's perfectly decomposable but
you bring them together closer and
closer and closer and suddenly it's not
a composition of two wave functions it's
something more complicated it's really a
wave function of a two particle state
which is not a composition of one
particle States and so on the more
particles you add the more this doesn't
compose right and this is probably why
physicists are stuck right now because
they they are trying to decompose stuff
so that we can understand with our
brains but nature is not built like this
nature is not by itself decomposable and
that's like a shock for us right so that
proves once more that that maybe all
this stuff that we are discovering is
not really about nature it's really
about our brains it might be a little
controversial statement but I will try
to prove this in a small small example
so I am let me see what's much my next
slide it's is this truth okay
so I titled this the the truth about
types it doesn't mean that I will
finally uncover the truth but but that
the truth is easily representable in all
these three branches in logic in type
theory and in category theory so you
so true is like one particular value
that describes truth okay and in logic
truth is defined by by this introduction
rule so Phillip may mentioned that there
are these intro introduction and rules
that define things and the statement
that T which is the truth or maybe it's
an upside down thing that's opposite of
false which is this thing right that the
truth is always true okay truth is
always true and you don't have to make
any assumptions in order to show that
true is true because it's an it's an
axiom it's it's by definition so the
definition of truth is through this
introduction rule which says what what's
above the line is or our assumptions and
there is nothing above the line here
right so no assumptions under no
assumptions you don't need to tell me
anything I'll I'll guarantee that true
is true now the same statement because
we are talking about this curry Howard
isomorphism and actually I'm talking
about curry Howard lambic isomorphism a
lambic is the guy who actually found the
third branch
he showed that category theory is also
isomorphic to these things some
particular types of category theory
so in types the same thing is described
by by saying that this
type called unit type is inhabited so
that there it means that there is a
value there is a particular value
available from this unit type and this
is sort of huskily notation which in
which this value is like a pair of
parentheses and the type is also a pair
of parentheses so on the left you have
the value on the right on the left you
have the value on the right you have the
type so value unit is of type unit okay
and that's corresponds to truth intro
now in category theory the same exactly
the same intro is through the terminal
object now I'll talk about what the
terminal object is I just wanted to show
you that these three things they look so
completely different but they are
different notations from different
branches of our knowledge to describe
the same thing and of course in logic we
know we have to prove things right so we
have the proof theory and what does it
mean to prove something in logic it
means to derive it from some other
principles so you make certain
assumptions and then you use these rules
of proofs to finally prove a particular
proposition so if the proposition is a
you know the proof is like what what's
above this this horizontal line so there
will be a bunch of other statements
above this line that's like this follows
from this this follows from this this
follows from this you know your
assumptions you discharge your
assumptions and so on so so this is this
is a very well formalized part of proof
theory
in types in type theory the same
statement corresponds to types are
propositions right so we we know how to
prove proposition a it means that we
have a type a by this isomorphism there
is a type A Okay the corresponds to
proposition the proof corresponds to the
fact that there is an element of this
type there is something in there that
the type is not empty and this is the
notation for this you know we have some
environment gamma which composes all our
assumptions right and in this
environment there is an element X of
type a which means a we proved a by
pointing an element by creating an
element or by producing an element of
this type ok and in production of this
element we might have evaluated some
functions and so on now in category
theory this this the fact that you know
so now an object in a category
corresponds to a type corresponds to a
proposition right so an object in
category theory doesn't really have any
elements inside because in categories
here you never look inside objects right
but you can also specify you know that
an an object is sort of like non-empty
if there is a an arrow coming from the
terminal object the terminal object I
mentioned before I will show you the the
definition what the terminal object is
but but this is just to show that you
know this kind of very different
approach the same thing
so let's go into category theory so far
I've been talking about certain things
that you know without explaining what
they are I don't know how many people
here know some elements of category
theory ah quite a few okay good so for
the rest of you a category is the
definition of the category category
theory is about categories so the
definition of the category is extremely
simple this is something you can explain
to a toddler essentially to a child
because a categories is just a bunch of
objects and a bunch of arrows connecting
these objects and if you ask me what an
object is it's abstract
it's nothing it's it's you know we
assume that there are objects they don't
have any structure you can now look
inside an object it's just like a dot at
point particle you know there's no
structure in it so the only thing you
can divine about these objects is how
they connect to other objects using
arrows okay and and this this picture
kind of suggests that a category is sort
of like a graph whose edges are are
directed with directed edges it's sort
of true there is a little bit more to
two to it I mean it has certain
conditions but essentially it's it's
like a graph except that it may have
infinitely many objects and it could
have infinitely many arrows between any
two objects okay so it could be a lot a
lot of connections between a lot of a
lot of objects or it could be just one
object with one
and that's also a category all right so
so it covers ground from like almost
well actually there is a category that
has no elements no objects and so so
from nothing to infinity of infinities
and so on categories can be even larger
than sets so this is what I said right
notes and we usually call these objects
we give them some names like ABC and so
on right and and the arrows between
these objects are called morphisms but
people call them arrows as well so even
mathematicians will we'll just call them
arrows you probably don't wanna call
them arrows in Haskell because in a
school there is an arrow library that
has nothing to do with morphisms so this
is Haskell notation for something well
it's not really exactly the the morphism
I'll talk about function objects but
it's essentially says a is an object B
is an object and we think of a and B
really as types because types
corresponds to objects in category
theory so I mean for me it's like the
same thing so I don't really distinguish
these things so I might be saying object
might be saying type you know or
proposition because it's all the same
right so we have an arrow between a and
B which we think of as functions okay
that's not all they have to be certain
conditions fulfill and and this is the
most important thing this is why I say
category theories about composition
because the major things that that you
have to be able to do in a categories
compose error
so if you have an arrow from A to B you
have another arrow G from B to C then
there must exist is a sort cut from A to
C there must be another arrow this arrow
is called the composition of these two
arrows and denoted by G circle F that
that's read as G after F you can think
of a function f being perform and then
the result of it passed to a function G
right like in F sharp you actually do it
from left to right with this vertical
bar greater than right so yeah it's kind
of easier for for a programmer to think
from left to right and listen in Western
cultures right so it always exists a
composition of two arrows if they match
end to end right so arrow from A to B
and another from B to C B has to be the
same in the middle you can always
compose them in with a new one and this
composition we wants composition to be
associative that's another condition
right so that we can forget about the
order in which we were doing composition
like we if we compose three arrows we
just compose three arrows and not have
to say well we first combine the first
two arrows and then combine the third or
so these little piggys correspond to
objects right and and this is the
composition of these two arrows a useful
device to visualize these things and
final thing that we have to assume about
about these arrows and composition is
that for every object in the category
for a for B for C and so on
there is a special arrow called identity
that loops goes from this object back to
itself and it's called identity
when you compose it with any other
morphism that's composable with it right
so like if you have identity at a is an
arrow from a to a and if you combine it
like ID after F you get F back right
that's why it's called identity and if
you combine G with identity you get G
notice the different order this is like
two separate sub laws of this law of
identity and and and and this little
piggys to illustrate the fact that there
might be many different looping paths
from A to A right they are different but
at least there is at least one there
that's the identity these other paths
when you compose them with external
morphisms they won't give you back the
morphus they will give you something
another morphism not not the same okay
set is a very good example of a category
and essentially you know people started
with thinking of sets and then they
generalize them to categories so set is
a category of sets so objects in this
category are sets what's what's an arrow
between two sets
what's a morphism peaking to set it's a
function a function a mathematical
function is always from one set to
another set right so set is the category
of sets and functions between these sets
okay there are many different types of
categories set is like a very special
kind that we sort of understand very
well because we have a lot of experience
with sets but the thing is when you look
at sets through it through the
perspective of a category
then there's one thing that you are
forbidden to do you cannot look inside
the set okay all you can you can say oh
this set is different from that set
that's because the connections of the
set the functions are different than the
functions coming from here right like
this set maybe has only one arrow going
outside and this set has ten arrows
going outside okay so we can say oh this
one is a special special set because it
has only one arrow right and when we
describe sets in terms of these arrows
functions right we are not supposed to
look and say oh this is a three element
set no cannot say that so that will mean
that you looked inside the set so let's
start describing objects in a category
with this constraint that we cannot the
objects have no structure inside all we
can say about objects is how they
connect to others and it turns out that
you can define a lot of interesting
objects in a category by just looking at
arrows okay and the simplest example is
the initial object initial object by
definition is an object in a category if
it exists doesn't have to exist in every
category it's an object that has arrows
to every other object in this category
so this is this is called as a universal
construction because you look at the
whole universe of objects you are
describing one particular object by its
property of how it connects to
everything else that's a very very
powerful thing to say about an object
you say something about how it connects
to everything else and in this case
initial object is defined as an object
that has
one arrow to every other object and it
has to have exactly one arrow okay there
are other objects maybe that have
multiple arrows going to other objects
but this one has a single arrow going to
every single object okay a unique arrow
that's the definition of initial object
okay and of course the question is well
what's the initial object in set right
except that's where we get our
intuitions well the initial object in
set so it would have to be a set that
has only one function going to another
to every other set and it turns out that
the empty set fulfills this condition so
what's what's an arrow from an empty set
to some other set a well it's a function
function that takes empty something from
an element of an empty set and maps it
to an element from some other set okay
but but do you hear me I'm saying an
element of an empty set and empty sets
have no elements right so so this is
this is a function yes well okay I'm
just I'm just explaining what it means
in terms of set theory what so like that
we can identify what how would we
describe this set in in using set
theoretical language we would call it an
empty set right but I have defined an
empty set using arrows only I said this
is an initial object if an initial
object in the category so I have a way
of pointing at this object using only
its arrow properties right external
properties but now I'm translating in
the bags like okay so what is this
I mean we know that these objects are
sets so what kind of what's what's it
what's a traditional description of this
object right the traditional description
of this object it's an empty set it has
no elements right and if in fact you can
always create a function from an empty
set to any other set and you'll never be
able to call this function so it's like
a you know a function that doesn't
really do anything but it's okay because
you will never be able to call this
function okay so the second in in vacuum
this is true is you know so and this
function in Haskell actually this
function is called absurd and it
corresponds in logic into saying
absurdum quad Labette right from apps
from from falsehood you can you can
derive anything right it's like if pigs
could fly then something something
they're not you know and void here
represents this on the one hand an empty
set on the other hand it corresponds to
a type void which we know has no
elements right it's an in onion
uninhabited type
there's no elements okay and this is not
the same void type as as we use in C or
C++ that we'll get to it later this this
void existing in Haskell but I don't
know if you exist in any other language
maybe in ml or how about F sharp is
there something that has known a type
that has no elements
now unit unit unit is they actually yeah
okay
good to know okay so in category theory
there's this like you give you you buy
one thing from me you'll get another
thing for free and so if you have a
construction that creates a you know
initial object well you get the opposite
of this for free and what's the opposite
of a initial object let's terminal
object right and it differs from the
definition of initial object by
reversing all the arrows so if if you
say all the beginning of this error is
really an end of it and the end is the
beginning right you can reversing the
arrows then whatever construction you
were doing you get a new construction
okay and terminal objects by
construction is is this object that has
incoming arrows from every object there
is a unique incoming arrow to this
object not two arrows not three arrows
but just unique from every object there
is a unique arrow to this object okay so
it's like the composite the opposite of
the of the initial object and and then
again the question so what is it inset
okay so we can point it using arrows but
but you know you might look on the other
side and say oh I know set theory what
are you talking about in terms of set
theory on in test in terms of set theory
I'm talking about a singleton set the
singleton set has only one element okay
and is there a unique function from any
type to a singlet --an yes it's it's
called in Haskell it's called unit it's
a function that simply ignores its
argument and always returns the only
element
and in in its codomain which is the
single element of a singleton set there
are no other elements in the singleton
sedges only one so this function must
always return this this one element
right so in in Haskell this pair of
parentheses or empty empty tuple is an
element of now here it's a type this is
the unit's type and here it is an
element of this type same symbol but
this means element this means type
because this is a type definition this
is the definition of the function the
implementation of the function so
function unit underscore means ignore
the argument I need one argument but I
will totally ignore it I'm not concerned
about it and I will return the unit
element so that's that's the terminal
object inside a singleton now you might
say okay is there an only one terminal
object is there only one singleton set
were there many singleton set so no
matter whether you believe that there is
one or many if there are many they are
all isomorphic okay so set that contains
one Apple is the same as set containing
one orange you know stay are isomorphic
and you can prove it actually from this
general construction that it has to be
isomorphic so
Universal constructions like this
initial object terminal object are
practically the only way of defining
picking objects in in a category because
you cannot look inside the object so you
have to look how they connect to every
other object in what way or you can
create a pattern of a few objects a few
morphism say how does this pattern
relate to every other instance of this
pattern in the whole category right
that's the only way of defining things
and it's called the universal
construction and using universal
construction you can define things like
products right we know what the product
is in set its a Cartesian product it's a
set of pairs one element from one set
one element from another set make a pair
and you get a set of these pairs and
that's the product okay so that's the
intuition there but now in category
theory we are forbidden to pick elements
right so what is a product then is there
a product in category theory and again
you use Universal construction so the
universal construction for a product is
consist of this pattern well you have
you pick you fix objects a and B and you
want to find an object that is the
product of these two let's call it C
right so the pattern is that you have an
object C and the only thing you can say
about this this this thing is that there
must be a projection right like so there
is an arrow from C to a that corresponds
to picking the first element of the pair
we know this I can tell you in secret
right that's picking the first element
of the spare there is another one Q
another projection that's in C
the second element of despair but we are
not supposed to talk about the contents
of these objects right so the only thing
we know that there are there is one
morphism here and one morphism here okay
this picture that's that's our pattern
and by the way if you translate this
pattern in category theory into logic it
corresponds exactly to the two
elimination rules for what's a product
in logic conjunction and if a and B can
be proven than a is true if a and B can
be shown then B is true right so that
corresponds to a morphism from this pair
a and B to a ok morphism here morphism Q
takes pair a and B and returns B so this
is the secret behind this right this is
how we implement it actually in Haskell
but this is a type a B and again here a
B is here's a type here's an element so
in Haskell people always you know use no
not always but but use the same letters
and same symbols for types and values
you get used to it
but but in the beginning it's harder
you're reading Haskell coloring say wait
a moment this is type right that this is
value or is are we passing types to a
function no we are passing a value and
so on but you get used to it so this is
product elimination that this is
conjunction elimination to conjunction
eliminations they correspond to two
arrows from this product object to these
individual objects right but this is not
good enough there can be many objects
like see with these two projections only
one of them should be the product right
so you can think of a lots of lots of
objects well not in every category but
again set category there's a lot of sets
that have two functions actually every
set you can define two functions for it
to to sum to two other objects maybe
except for the empty set so we need more
in order to pinpoint exactly the see
that corresponds to the Cartesian
product inside we have to evaluate
somehow the instances of this of this
pattern so like we are this is a query
that that we are giving to Google you
know show me all patterns like this in
your category you get lots and lots of
hits and you want just one you want the
top one right what does it mean top one
it means that you have to have some kind
of hierarchy among them you can say this
matches my pattern better than something
else and this one is the best of all of
them and the best one will be called the
product all the others are just
candidates for products you know wannabe
products
so there's the second part to
universality which is the ranking on
these so here I have these two examples
of this pattern so this is my C with P
and Q Q P and here's some other imposter
that says hey I'm the product you know
I'm called C C Prime and I have P Prime
and Q Prime as the two projections no
why do you think this guy is better than
me right and and it is better if you can
show that there is a unique morphism
unique arrow coming from C Prime to see
it kind of projects the C priming to C
and it's a unique arrow that fulfills
these conditions so this is called fact
factorization conditions so like you say
P prime is not really a prime number
because it factorizes as M times P right
and this one is not a prime number
because the factorizes n times Q right
so they both these if you thinking of
them as numbers you know you would say
well these both both these numbers have
a common factor called M except for
instead of multiplication you have
composition right but the same thing P
prime equals P times M Q prime equals Q
times M we have factorized n out of
these guys okay so they are not really
elementary in the sense because we can
pull out a factor out of them so this
guy is better more pure than these guys
so of course no if it doesn't always
exist but if it exists and it's unique
then we say this guy is better than this
guy and so that forms like a ranking
among these things you know maybe
maybe it's a tree ranking of their
separate areas or so on you know and in
these cases you would not find the best
one but in some cases the the ranking
works beautifully and it gives you the
best one and it's it's unique okay
and in that case we call it a product
this is real product not every category
has products for every pair of objects
it's fine we are interested in ones that
do have this and again there is a
connection with logic okay because this
this is sort of the introduction of
conjunction we had the elimination
before now this condition of
factorization corresponds to
introduction right because you can say
okay if a follows from C Prime and B
follows from from C Prime so we have
some kind of assumptions you know and we
can prove a and we can prove B then a
and B is also true right and a and B
corresponds to this object C right
that's a formula and this is an object a
follows from C prime well that's that's
our P prime right a follows from C prime
there means there is a morphism here B
Falls from C prime there is a morphism Q
prime that proves it right so if these
two things are true then then a and B
follows from C prime right a and B
follows from C prime from these
assumptions C prime guarded our
assumptions and that's proven by M right
there is a C follows from C prime that's
that's the morph isn't n okay and and
then going deeper into this is okay but
what does it mean that this is a unique
more
with them right ah all right because
this just shows that the stick of Deng
compensation works but what about
uniqueness and uniqueness of this
morphism translated into proof theory is
exactly the expression of the thing that
that Phil mentioned that introduction
and elimination are the opposites of
each other so if you eliminate and then
reconstruct you get the same product and
one of the Jensens
principles of improve theory that they
are the opposite right elimination
followed by introduction will give you
back the same thing so I'm not going to
go into details of this but just just to
show you that there is like really
really one-to-one correspondence between
category theory and logic and of course
programming so here's another universal
construction that's this is the last one
so bear with me this is this is the
construction of function object okay
because what our functions really in
Haskell right what's the type function
that's not really morphism right more
morphism is not an object a set of
morphisms between two objects sort of
corresponds to type from A to B a
function from A to B right but the set
of morphisms is not an object it's a set
it's like outside of the category it's
called a home set by the way right it's
it's a set of morphism between two
objects but is there an object in the
category that corresponds to the set of
morph isn't if there is it that if there
is one it's called the function object
okay so in order to define a function
object which in Haskell is this a arrow
B that's a function object that's a type
which is an object right you have to
have first products function object can
be constructed only if you have products
in your category which you don't always
have but in Haskell you do right so this
is the function object it's an object I
call it a to B that's maybe a notation
more closer to logic than what we use in
Haskell but you know you take you take a
product of these tools so think of you
know sort of a Cartesian product pair ok
pairs you take a pair of function a to
be and an argument of type a ok what can
you do with this you can apply this
function to this argument and you get
something of type B it's an object B so
this morphism here called eval it just
evaluates a function on an argument
right so this is the pattern this is the
pattern that we are looking at and the
universal construction is that what we
call a function object is really the
best one so like if there is any other
one that says oh no I'm a function
object no ok if there is an object Z and
you make a cross cross product with a
you know and and there is a sort of a
pretend eval here then you can find a
unique function H unique morphism age
that factorizes this triangle okay I
won't go into details
ok now boring stuff and well you eat you
can even find it in my blog described in
more detail and now this pattern it
corresponds in logic to modus ponens
right the basic basic idea in in proof
theory you know that if if it's true
that be false from a
and if it's true that a and you know
this and this then B must be true now if
you can prove be from a and you know
that a is true then B is true so modus
ponens corresponds to this Universal
construction okay and in fact from the
same diagram you get what in Haskell we
called currying so that you can think of
this as a function because this is a
product you can think of this function
of two arguments right what's a function
of two arguments a function of two
argument is really a function that takes
a pair right so a product so a function
from product to B corresponds through
this H to an application of function
from A to B to a which means give me an
A and I'll give you a function from A to
B okay which is kurung but this is just
a side thing okay now the negation so
there is one more operator of that takes
a proposition a and gives you the
negation of this proposition not a so if
a is true then not a is false and vice
versa right so how now we don't need a
special construction for this in
category theory it corresponds to saying
that there is an arrow morphism from a
to void okay now why is this negation
okay so if a is true then a to void must
be false
okay what does it mean that a is true it
means that type A is inhabited right it
has
elements so if a is inhabited then
actually there are elements of a and if
I have a function from a to void I would
be able to create void from nothing it's
kind of sounds interesting but you're
not supposed to be able to create an
element of void right because void is an
empty set corresponds to an empty set is
no element if you give me a function
like this and and there is an object
there is an element of a I can just
apply this function to a and bam I get
an element of an empty set that's that's
not possible right so if a is inhabited
a to void must be impossible so a to
void this function type is not inhabited
in this case cannot be inhabited there
cannot be a function like this because
everything would explode right and vice
versa if a is not inhabited which means
in our case it means false right so if
it's not inhabited it's just void its
corresponds to void right is there a
function from void to void yes it's one
of these crazy functions you know you
you'll never call it because you cannot
provide an argument for it right but but
it exists it's it's the identity on void
you know it maps an empty set to an
empty said that's fine mapping an empty
set to an empty set it's okay so this is
why it's called negation negation is
actually a function object in a category
so combining all these three things
together okay we get a category that's
called cartesian closed it has all the
products that's why it's called
cartesian right it has all function
objects so for any two types there is a
function object that corresponds to
morph is
between the two types sometimes it's
called an exponential and that's that's
the meaning of closed having all
functional objects and and has a
terminal object okay these three things
if it has these three things and not
every category does but if it has these
things is called Cartesian closed
category and you can think of the
terminal object MT tuple it's like the
zeros power of some type right so it's
like you can say it has all infinite
infinite products as well as not null
our products with zero elements so
finally this is the extension of the
Curie Howard isomorphism it's called
Curie Howard lambic isomorphism between
these three branches of mathematics and
and the part that lambic came up with is
that cartesian closed categories are a
model for the simply typed lambda
calculus so simply lambda calculus we
already know is is the model for logic
now it's also M now it also has a model
in cartesian closed categories right and
objects are types morphisms are terms in
in in logic in programming right and
there's also the environment thing that
corresponds to a product of these
judgments about variables in our lambda
calculus okay
and now a little let's go a little bit
to the side and and consider different
kinds of logic like two major types of
logic one is the classical logic that
we've always known from ancient Greece
and so long is the classical logic which
is kind of very strict and says that
every statement or every proposition is
either true or false right this is what
Hilbert was trying to to prove that
every proposition is either true or
false and we eventually find a proof for
this and then good will came and said no
no you know there are some statements
that are neither false or true right so
so this led to this intuitionistic logic
in which a statement can be true
statement can be false or you can just
say well what does it mean is right if
you want to avoid the answer to the
question say well define is so
intuitionistic logic if we want to
describe it better it's it's a logic in
which there is no law of excluded middle
law of excluded middle means that a or
not a is true because either a is true
or not a is true right well in
intuitionistic logic it doesn't work
because a maybe from this gray area
there is a negation of this thing
there's this thing and we don't know if
this is true the or of these two things
is true now or corresponds to to this
some type right and it simply means that
when we look at the lambda calculus this
is not provable in the lambda calculus
okay so lot of excluded middle has no
relation cannot be derived in lambda
calculus there is no function that will
produce this other way of saying the
same thing no Len is that we cannot
eliminate double negation maybe double
negation is not not a well not not a is
the same as a right in classical logic
not in intuitionistic logic so not not a
now going to lambic right would be
translated as a function that takes not
a which is a function from a to void and
returns void right so it's double
negation first we negate a that's a
function from a to void and then we pass
it to negation which is a function from
this thing to void right and this is
something that's not true in lambda
calculus okay it's not the same as a we
kind of think of this as a SSA because
you know if if there is a you know then
if you give me a function from a to void
I will apply this function I'll get a
void so I can return this void that you
gave me an element of void right well we
can't so so the curry Howard part of the
isomorphism says really the lambda
calculus is equivalent to not classical
logic but to intuitionistic logic you
cannot prove the law of excluded middle
using using lambda calculus and or
double negation you cannot prove double
negation right so this is subset so you
might think okay so hey we cannot do
classical logic this is very limiting
right
so we programmers are not supposed to do
this right so
is there something that we can do with
classical logic and turns out yes
the logicians came up with this before
programming right girdle and Genson they
came up with this idea that lo and
behold you can take classical logic and
embed it into intuitionistic logic which
means if you have a proposition in
classical logic that is provable you can
translate it into some other proposition
in intuitionistic logic and you can
translate the proof into an
intuitionistic proof that does not use
double negation does not use law of
excluded middle and you will get
something right so there is a
correspondence between propositions it
doesn't mean that if you get a
proposition from classical logic and you
just put it inside intuition is the
logic that you can prove it you might
not be able to do but if you transform
it put it here the transform thing can
be proven always and vice versa so there
is one-to-one correspondence and the
trick to do this is really really simple
so you take a proposition from classical
logic and you say ok I'm going to invert
everything inside there so that I like
double negation to all my assumptions
right so there is the transformation is
really I'll do the double negation I get
a new theorem right and this the new
theorem can be actually you can you can
apply intuitionistic logic to it and you
prove something and if you apply double
negation to it you get back the result
of this first theorem so every theorem
can be translated using double negation
into
erm and if you can prove it in the
intuitionistic logic then you can do the
double twist here come back to here and
you have a proof of the original thing
in classical logic so what does it mean
to us well it means continuations okay
so double negation looks like this you
know the a to void goes to void it can
be generalized to a to R for every our a
to R goes through our and and of course
if this is true then you can substitute
void for R and you get it but this is
just continuation passing right a to R
is the continuation a function that
handles a right give me a handler I'm
not giving you a back I don't know how
to but I can if you give me a handler I
will call it with a ok that's that's the
idea of continuation passing right so
you if you extend lambda calculus with
these continuation passing things or if
you think of transforming a whole
program to continuation passing style
you to CPS right on a program which
means the same as double negation no
then you get another program that
actually runs so we we have a way of
embedding classical logic into
programming but we have to do this
CPS transform and finally this is the
last slide I know is this one before
lost and I'm really
I'm not going to explain this because
this is like higher categories here it's
called the Oneidas lemma but I want to
show you that this continuation passing
style actually follows also in category
theory from and from like the most I
think this is like one of the most
important theorems in categories here
the category theory is invented right is
it's the Yaya's lemma and you Naas lemma
tells you exactly this this thing that
you know introduces continuation passing
style in a categorical way it says that
if you give me a function from a to X
and this identity functor here that
takes a continuation and returns X then
you it's equivalent to a this time right
so that's the Oneidas lemma and
corresponding the continuation passing
style in category theory so here's the
conclusions okay it's all the same all
these three theories are identical this
is just different notation for the same
stuff you know you have type theory in
lambda calculus and and and the other
part of this Cartesian clothes
categories it's the same as logic okay
and because of this there is a lot of
cross-pollination mostly nowadays you
know we've we've done already this
cross-pollination from logic into
programming right that's something that
that feel explained but there is also
cross-pollination in category theory and
and programming like this is something
Edward Matt would talk about you know if
he was invited here and
if he came here and and finally you know
you might ask you sir the question is
lucky these things are the same maybe
there is like a grand unified theory
behind this you know and and
mathematicians would love to have
something like this grand unified theory
and one attempt that this is the
homotopy type theory which is very hot
right now a lot of mathematicians are
working on it so the idea is maybe
something will come out of this maybe
not we don't know okay thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>