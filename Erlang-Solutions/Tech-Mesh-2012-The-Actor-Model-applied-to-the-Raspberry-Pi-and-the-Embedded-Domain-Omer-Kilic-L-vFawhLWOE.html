<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tech Mesh 2012 - The Actor Model applied to the Raspberry Pi and the Embedded Domain - Omer Kilic | Coder Coacher - Coaching Coders</title><meta content="Tech Mesh 2012 - The Actor Model applied to the Raspberry Pi and the Embedded Domain - Omer Kilic - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tech Mesh 2012 - The Actor Model applied to the Raspberry Pi and the Embedded Domain - Omer Kilic</b></h2><h5 class="post__date">2013-08-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/L-vFawhLWOE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi folks are memo I'm in the middle
sister my engineer at Erlang solutions
and thanks for the lovely intro that
pretty much what I was going to say for
my interest light so we're going to look
at the actor model today and how it maps
to the embedded domain taking Raspberry
Pi as our reference platform and we'll
go through an example scenario where you
might want to control a bit of hardware
and how you can actually employ the
accent model to do that so in the agenda
I'll start with a very quick
introduction of the state in embedded
systems today we already heard about
this somewhat because embedded systems
today is quite an abstract term we
already know about these things by heart
because we read about it every day so I
won't spend much time there we will then
have a again quick look at the actor
model of concurrency just a quick show
of hands who here uses an actor model
sort of based language I can see Joe
raising his hand that's good it's only
going to be a brief introduction so i
won't bore you with too much details
we're involved in a project called
Erlang embedded with the university of
kent so i will give you an introduction
to that and sort of give you an idea of
what we're trying to achieve and then
we'll go through a worked example of how
you can actually use features in the
airline and the actor model up to create
or model and develop your systems using
actors and I hopefully will able to be
able to show you a little blinking
lights demo video and you'll follow that
up with some feature explorations and
sometime questions and answers if you
have time left ok so as I mentioned the
definition of an embedded system is
quite abstract these days so the
original and the sort of definition that
I will go by is a small computer system
that is designed to
is specifically one per thing on purpose
size-wise it's generally a small
computer system but you can argue that a
factory automation system is an embedded
system as well so and be more mobile
phones when it first started out where I
guess truly embedded devices but now you
can draw stuff on them or watch cats
movies and stuff so it's not really a
specific embedded system anymore so
little background embedded systems has
always been well controlled or designed
in C so the lingua franca is C and we
can see that it's actually increasing in
usage so just a outright state that
we're not trying to replace C I think
see is always going to be here for
certain operations but with the
challenges that we have today in modern
embedded systems we can't really do
everything in C so there are certain
operations like raw socket programming
or managing concurrency etc that it's
not really fun to do and see therefore
you can employ a higher level supervisor
or framework to manage the complexities
of these systems and this is what we're
working on um so just a quick slide on
general current challenges that we have
we're dealing with some extremely
complicated system on chip platforms
with quite a lot of peripherals and
different interconnects between these
devices different processor cores
multi-core processors and better than a
single tip we also have this beautiful
thing that's called Internet of Things
stupid about this I will go into too
much detail but everything around you is
eventually going to be connected
together and there are predictions that
we will have billions and billions and
billions of devices that will all be
interconnected somehow so the whole
distributed pneus and the connectivity
aspects of these systems are becoming
more and more relevant and quite
important and we also have live in a
world where we can have 3d printers and
designer products in a matter of days as
opposed two weeks or months now so we
need to be able to do quick iterations
or quick prototypes of our ideas so
having a higher level framework to
facilitate that is we think quite an
important thing or quite an important
step to take um so traditionally there
has been different kinds of embedded
systems so the smallest of devices use a
bare metal approach where you don't
really have an operating system as such
you direct registry manipulations and
you don't you don't have posix or
anything like that usually this is the
eighth to 16-bit processor category the
second category is real-time operating
systems and within our TOS it's a
minimal operating system as you can
probably tell from the name it does give
you certain guarantees timing guarantees
and it also lets you abstract your
application into small units or chunks
of code and quite often it gives you
some form of communication primitives
that you can use to establish
communication between these things as
well RTF it what RT osas are quite
popular for safety critical applications
as well so space programs use our two
aces and that sort of stuff and of
course the last one is embedded Linux
which is pretty much just slim down
Linux with a few optimizations and well
smaller size smaller image sizes etc and
you also have this notion of accessing
hardware within your device as well we
are going to focus on these two
categories or these two or the
applications that we are interested in
we don't really want to go bare metal
just yet but certainly on a list of very
interesting experiments in the future so
our TOS is to have
of certain concepts that I've mentioned
earlier as well they do give you this
notion of tasks so you can encapsulate
your or bits of code into these little
units called tasks and then the
operating system itself does give you
the messaging parameters that you can
use it's generally almost always shared
memory approach so you do have certain
facilities like mutexes semaphores looks
that you use to well ensure that
different tasks are not trying to change
different areas of memory or that are
trying to access the same for a full
physical peripheral at the same time and
so on and again rtos also gives you the
scheduling of guarantees that you might
require in your application as well so
and if you look at embedded Linux it's
really not a new concept it's been
around for a while but it's becoming
more and more popular with the advent of
these cheap and readily available boards
it's usually an easy jump for many
software developers because they're used
to the shell they're used to their
favorite scripting language and that
sort of stuff but there is no direct
mapping as such for real-time operating
system concepts you might think well I
operating system threads tasks that sort
of stuff but you still need to use a
different programming language then
you've probably used to to encapsulate
your applications tasks and establish
communication between them etc so and
also the device linux device driver
framework it's it's really not that good
and the documentation is pretty terrible
all in all it's quite popular and people
are doing some quite interesting
applications with it so it's not it's
actually not that bad so the actor model
is not a new concept it's been around
for a while the original definition was
the universal primitives for concurrent
computation what makes it interesting is
that they don't have any shared state
their self contains and
atomic which makes it really good for
distributed applications and concurrent
systems actor model is not just
implemented by airline there are a
variety of other implementations as well
they'd use a synchronous message passing
to communicate between different actors
and the way these messages are processed
are they are kept in a mailbox and then
they are processing the order that they
receive in actors have a very strict set
of operations that they can do they can
either make local decisions or change
the local state internal State sorry
they can spawn new actors to deal with
say calculations etc and or they can
send messages to other actors so that
they can deal with the incoming command
or data so if you look at a very simple
example we might have this first I can't
find my laser pointer unfortunately so
we have this first day to say a data
acquisition actor which passes a set of
values to our number cruncher process
and depending on the number that you
have received in or the size of the data
that you're processing you can choose to
say spawn three new actors and send a
subset of this data to tree of these
worker actors and then receive the
results back and pass them on to your
original requester or the original
thread that generated this data or you
may choose to send it elsewhere as well
now this means that you can upload this
to multiple cores or multiple nodes so
that you can utilize a distributed
processing architecture and since these
units are all self-contained or
self-contained anatomic it's it actually
works now it's pretty cool actor model
but there also some limitations to this
so the model itself does not define any
inheritance or general hierarchy so it
appears that every language in library
implementation has different notions of
these
and also a synchronous message passing
is not the Holy Grail it's certainly not
the right thing for certain applications
but within the embedded systems context
I can't really see that being too much
of an issue also the abstract definition
may lead to some inconsistencies in
larger projects where you have multiple
engineers working on a single thing so
the whole fine coarse grain thing can be
a curse and a blessing at the same time
um so Erlang embedded is a knowledge
transfer partnership project between the
Erlang solutions of the company and
University of Kent the academic
institution we're looking at ways on how
to use airline in our modem embedded
devices which are multi-core connected
distributed we're doing some design work
on this and creating little use cases
and republishing are in fact we will be
publishing a lot more stuff in the next
few weeks on our website Erlang embedded
com and the reason why we're doing this
that were why we chose our line for the
sake of this talk it implements the
actor model it's not actually a new
language it's been around for quite some
time and it's been battle tested at
Ericsson many and many other companies
in fact it was originally designed for
embedded applications so the telephony
devices at Ericsson had required certain
guarantees that other programming
languages didn't have therefore this was
born out of necessity so while today
it's being used in these massively
distributed messaging systems or web
backends etc originally it was designed
for embedded applications it does
support concurrency and distributed
systems or distributed pneus is that
even a word out of the box and it has
some very interesting features that lets
you create very robust
and resilience hierarchies or overall
systems there are a lot more features
that makes it an interesting language
but if you're interested you can go to
our land at org or we have a fewer
language around but we're happy to have
a chat after the talk so Oh another
extra slide about the high availability
reliability aspect this is probably the
single most important thing in embedded
systems because if you consider that you
might actually kill someone if your
embedded systems you know miss behaves
you say you have a robot with some sharp
attachments and if it goes out of
control some strange things and we're
horrible things can happen blood and
gore and so you do need to have
resiliency and error recovery and
supervision mechanisms in place so the
AXA model gives us this whole nice
isolation since there's no shared data
or possible corruption and you can use
the OTP supervision hierarchies to
structure your system in such a way that
even if something fails you can return
your system to a known state fairly
easily it also has another interesting
feature which is the hot code loading
which gives you the option to
dynamically reconfiguring if things
you're wrong this means that you don't
actually have to stop the operation of
the system or you don't have to do a
sort of cold start from scratch with the
new byte code you can simply swap out
portions of your system that misbehave
so a few little syntactic examples how
do you actually create an actor from now
on I'm going to use the term actor or
and Erlang process interchange of VI
that they mean the same thing in the
context of these slides so let's say we
have a process then we want to do some
more stuff in a different process maybe
somewhere else or maybe on the same node
we simply just call the spawn a function
and give it the module name of the
function name and the arguments that we
want to pass through it and it just
generates a new
actor or Erlang process that we can now
send numbers down to to calculate the
factorial communication happens by a
synchronous message passing oops so if
we want to send some data to process ID
to we can just say press society to bang
and then in this topple I because it's a
synchronous the process that received
the message doesn't really know it comes
from so if I want to response back I
just passed my own process ID and then
the message I want to send so when you
issue that a nice little topple gets
sent to process ID to you can I mean
going back to the error recovery in the
resiliency aspect of it you can create
links between processes so let's say we
call the link function to process ID 2
and now if process or paid one fails
process ID will know about it and this
is this coupled with the supervising
supervising Iraqis that I'll be talking
about in the next minute or so gives you
the iPad the chance to create some very
robust system Iraqis so the ideology
behind all the supervision trees or
nested supervisor accessories we just
let it fail in our line which seems
probably a bit awkward for the non our
language in the room what we mean by
that is we remove the error handling
away from the modules and place it in
higher level supervisors so that means
we write less code less actual
application code less of the whole if
failed to this etc and we let the
supervisors deal with the error
conditions so we can create as you can
see from the DS area you can create
nested subsystems within our overall
system and in case it fails we can have
different strategies to return our
system to known state
going back to the linking of processes
together let's say we have three
processes that are all linked together
and pit a has a problem and when that
happens process I DB or PB will receive
this message which will in turn caused
it to generate an error condition as
well and this will propagate through the
entire chain until it's handled by a
supervisor or simply crash if you don't
have any supervision in place now you
can prevent this from happening by
trapping exits and if you set the
process flagship exit on one of these
processes if it receives this error
condition it simply will contain that
there and you can then choose to maybe
restart the payday or maybe execute some
more steps to again return your system
to a known state etc going back to the
sea and the importance of interfacing
with see etc airline does have features
that will let you that your system
communicate with external see bits of
code so in this case you might have some
hardware drivers that talks to some real
hardware peripherals etc and you can use
nips native implement functions or port
to interface that bit of C code to your
her lying application so with all these
as I say there there are you know a
couple more features that are highly
relevant but I'm running out of time so
I'm just going to skip it so with all
these things considered we think airline
could be a great orchestrator for these
complex systems again you know we have
these devices that are quite capable of
running the Erlang vm and
underlying operating system to support
it and so on and the challenges that we
have the whole distributed pneus and the
connectivity aspect etc those things are
much easier to handle in a higher level
environment or a higher level framework
like airline then in row C so we what
I'm trying to say is we can afford to
lose some cpu cycles for sanity and you
know not losing much hair etc so let's
talk a bit about the raspberry pi you
probably have heard of this it's been in
the news or practically everywhere in
the past couple of months it's the 700
megahertz arm11 processor which is well
it runs linux and now we can overclock
it up two gigahertz I think this is an
old slide on it it now comes with 512
megabytes of RAM it has ethernet USB and
all sorts of other peripherals or sorry
interfaces that you can use to connect
other devices to your system as well one
interesting aspect of the Raspberry Pi
is perhaps well first of all the fact
that it will be eventually sold at $35
which is extremely cheap for such a
platform or let's say affordable for
such a platform but another important
thing that we are focusing on is the
fact that well the poly foundation is a
registered charity and they're trying to
introduce this computer that old
computer system into schools to teach
young people programming and what put
the fun back into learning computing so
these people these little people who are
now working with these devices they are
going to be our future engineers
programmers hackers managers etc so if
they know about if we can present them
with fun challenges to introduce them to
concurrency and parallelism and
distributed systems etc I think we might
see some very interesting results coming
in the long run so to support this
experiment one one of the main reasons
we have chosen Raspberry Pi as our
educational platform is
well simply because of its availability
popularity etc but the fact that we
actually want to get this scary killer
material into the curriculum taught at
schools which would be quite interesting
little people programming Erlang or
concurrent programs that's a interesting
proposal we will keep you posted on our
website so what I'm really interested in
the pie is not the fact that it's a
small cheap computer system but the fact
that they actually broke out all these
embedded peripherals on a little pin
header that you can you know put little
cables into and it's great because
realistically speaking in it's running a
visual sort of desktop environment on it
it really doesn't make much sense
because we have laptops and other
computers that can do that but if we can
actually get people interested in
getting their hands dirty with hardware
or actual physical wires and little
bread boards and stuff like that it's a
it's more interesting and more rewarding
experience because the fact that you
make a little light emitting the blink
is much more satisfying than seeing
hello world I mean I don't know that's
maybe it's just me I really like
blinking light so that sounds wrong so
yeah I think I think they made a sort of
great I don't know if this was
intentional or accidental but the fact
that they included that or they broke
out all these pins to a pin either
that's accessible for you to experiment
with this it's probably the single
greatest thing on the Raspberry Pi board
itself so how do you actually access
these peripherals though in Linux well
they're all memory mapped so and there's
a data sheet on the Raspberry Pi website
that you can get which actually tells
you which regions of memory correspond
to which peripherals so there are two
methods you can use the first one is
just mapping the memory directly and do
some well register twiddling voodoo now
this is fast but at the same time it's
it's potentially dangerous because if
you do some
dodgy pointer arithmetic or if things go
wrong you can potentially kill your
board because again we're dealing with a
complex system on chip device that has
some registers that control the power
aspect etc on board which if written
wrong values too might destroy your
board but that's okay I mean it's $35
after all right this is the fun side of
it this is a system that you can you
wouldn't feel too bad to destroy I know
that sounds horrible but you know it
encourages learning by experimenting
since I mean I know people say that oh
you have to wait weeks and weeks and
weeks but it's getting better now I
think just in the UK plant they're
producing to 2,000 units a day so there
will be a point where we will be able to
just order a Raspberry Pi for next day
delivery and if you're lucky it actually
happens I did manage to grab quite a few
pies for next day delivery so but I just
keep a stock of them just in case so
yeah this this is the dangerous sort of
way of accessing these the other or the
slightly safer method is using the
colonel abstractions or kernel modules
that virtually presents files that you
can read or write a read from or write
to this is a bit slower but you know
it's a bit safer as well so it's a
trade-off and I actually thought it
would be fun to see some per line code
controlling some LEDs or GPIO pins so in
order to use a pin a GPI general-purpose
input output pin you need to first of
all initialize it initializing means you
set the direction to it and you actually
specify which pin you want to use as
well and then there are two operations
or three operations rather you can do
with it you can read from it you can
write to it and when you're done you can
release it so that other bits of your
system can access it and do other things
with it as well so the GPIO abstraction
or the kernel module for gpio presents
you devices in slices /
class / gpio I think yeah so what we're
doing this is pure like there's no c
code or anything like that we're just
opening the export file under this class
VPI oh and we just write which pin that
we want to export so and then we close
the file descriptor for it the next
thing we do is set the direction for it
so once we export a pin it will create a
pseudo full or virtual folder under the
s-class gpio so let's say we export a
pin 17 that path will be says class GPA
GP area 17 direction and depending on I
could have just passed strings to that
function but I just wanted to write less
so that's a bit of just a bit of a case
statement to convert an atom into a
string and we can either set it as an
input or an output and then we close the
file descriptor for it because we don't
need it and finally we read the or we
open the file descriptor for the value
pseudo file which will we will then be
able to write to or read from so that
will be Cisco's gpio gpio 17 if we were
using in 17 value and this function just
returns that file this file descriptor
so that you can pass it to well other
functions or other actors too so that
they can utilize the pin and the write
operation is fairly straightforward we
take that file descriptor rewind to the
beginning of the file the virtual file
and then we just right whichever value
we receive 1 or 0 read is again fairly
simple it reads the file descriptor just
a one bite from the Royal descriptor and
returns it and finally when we don't
have when we're done with the pin we
release it by opening the unexplored we
exported it and now we're on exporting
it and then just close
if i'll scripture after that so all our
line not very many lines of code and you
can this is obviously the lowest layer
of your you know hardware library in
this example this is a video hopefully
it will work so i wrote a very simple
module called led which uses these
functions the file right or actually
yeah so it uses the GPIO functions to
initialize the pin and then right value
suit and so on so what i did here is
created an abstraction on top of the
GPIO by simply doing another actor which
will let me interface with its from a
sort of higher level now let's see if
this worked thus so i'm going to start
in Erlang shell i sped this up i can
type as fast so i compile the GPIO
module i compiled and loaded the LED
module as well now i'm going to
initialize three leds and in a second
they will pop up on on the left over
there i'm just starting it and passing
it a pin number the physical the actual
pin that that that is that the LED is
connected to and then i can just send
messages to so i just said turn the
first led on turn the second daily well
syntax error turn the second LED on for
the third LED depending on how you count
and then independent because these run
independently i can just have a blink
loop controlling the second LED is it
visible that's all brilliant so these
all work independently concurrently in a
traditional embedded system in order to
do something like this you will have to
implement timer interrupts and blow
multiple interrupts and multiple timers
perhaps so this really gives us a very
nice way of architecting your systems
now you may say this is just an LED
wrote a functional program to playing
somebody's i will get to that in a
minute so the graphical representation
of this is we simply have an
axor pin 17 or an airline process that
controls the pin 17 directly and now
he's a send messages to it very simple
the only problem is when multiple
processes send starting start sending
messages to this this may potentially
become very dangerous because let's say
this pin 17 was connected to a
mechanical motor rapid turning on and
off of that mechanical device inductive
device can potentially destroy it so
when many things right to the same pin
at the same time many processes right at
the same time we might have some
problems but we can again using the sort
of layered model that we've been talking
about we can abstract that one level up
so instead of directly accessing the
hardware from all the processes
processes rather we can have a proxy so
this proxy will be responsible for
making sure that we don't blow things up
so we can have predefined sequences that
we may want to disallow or we can choose
to implement some hysteresis or just a
simple delay function so that we're not
rapidly switching it on and off etc so
now these processes do not directly
communicate with Penn 17 they go to the
proxy this gives us also a supervision
hierarchy that will let's say another
server wasn't know that the pin might
have failed or it's not responding and
so on so I guess you could argue that
this replaces a lock in a traditional
sense because it provides access control
and mutual exclusion but at the same
time you can implement much more than
just that basically as I mentioned you
can implement some safety constraints
into these actors as well and again you
can use these actors as abstractions for
creating a secure or safe rather
embedded system so talk a bit about fine
grain abstraction when using fine
grained abstraction
your application becomes a lot simpler
because simply for the fact that there's
less code per module that you have to
read and debug so again it leads to
concise and shortened modules testing
becomes easier because well again you're
the functionality of your simple modules
are quite simple and this is a potential
sort of advantage depending on how you
architect your system you can probably
increase code reuse as well um the only
problem is again architecting fine
grains systems is quite difficult and
everyone's definition of fine grain is
different as well so if you're working
on this on your own then you know it
might be fine it can be very happy with
the sort of models that you have chosen
or the level of abstraction that you
have chosen but when you get to interact
with other designers or engineers that
might become an issue so we have been
working on a layered sort of hardware a
set of hardware modules in which we try
to create a sort of platform agnostic
top layer the components API in the
peripheral API and the platform specific
or device specific lower layer hardware
library or hardware drivers this is
quite an abstract slide so that as an
example i will use a temperature sensor
again this is a very simple you know
device so you have the sensor API on top
which exposes the higher level functions
of the temperature sensor which might be
well get temperature maybe or calibrate
sensor etc and then it communicates with
the actual bus driver the at in this
example this is a nice quidsi interface
or this is a sensor that supports AI
squared C interface the I squared C
interface is a well-defined protocol
it's quite simple so we don't really
need anything platform specific with it
you can just have it as a universal
module and depending on which platform
you use we can choose to implement say
external module and you say surface or
we can just map registers and do fun
stuff with them again going back to the
hole why do we need to write this much
code or go into functional modules and
stuff like that for blinking LEDs well
it's not just blinking LEDs so if you
look at a reference system from Texas
Instruments d this is a fairly standard
system-on-chip device as you can see
there a lot of stuff on this that
requires coordination supervision and
yes I mean you have multiple I scrotie
peripherals different protocol stacks
you have to implement different pins
probably you have to toggle sdram flash
etc so Erlang or this level of
abstraction gives you a very nice
foundation to create very nicely or
solidly structured systems that are
fault tolerant and actually easier to
code as well and at the end of the day
as I mentioned you white or you probably
will use some sea to interface with the
actual hardware but you can certainly
use Erlang for the supervision or the
orchestration of this sort of a system
now as part as I mentioned we are
developing a set of hardware modules for
starting the raspberry pi will be
releasing them fairly soon and we also
have done some experiments with some
hardware projects so the first one is a
little bored called Pont a it's a bridge
between the Raspberry Pi in the Arduino
so you can see the first prototype there
with some horrible hacks and wires
coming out etc this is the second reason
the second reason there's a third
revision coming out which should
probably fix or hopefully fingers
crossed fix all the errors the idea
behind this is very simple and the pie
is a is going to be a very big titis
platform well are doing there is already
a very vicious platform so what and
arduino has this notion of shields which
extend the function
reality of the baseboard by providing
extra functionality so this little
adapter board convert establishes an
electrical bridge between the arduino
shields in the raspberry pi it deals
with level translation and the pie
doesn't have an analog-to-digital
converter so it has an analog-to-digital
converter as well so this will be the
released as open source hardware on our
website when I finally prototype the
final version and I'm happy that it
works I don't want to release some non
working designs now this is quite
unfortunate because I ordered these
quite some time ago and they haven't
they act just arrived today I didn't
have time to solder them but if you're
around tomorrow I probably will do an
all-nighter in solar field e so find me
this is a very very simple demo board
that I developed for the Raspberry Pi
because we will be running some
workshops and some community events and
I needed something simple to demonstrate
these concepts and this board has a
bunch of fairly standard embedded
peripherals like a nice crowd support
expander and or an SPI analog to digital
converter a set of buttons LEDs and so
on so this pretty much gives you an
interface a very simple interface to all
the hardware peripherals you have on
board again this will be released as
open source hardware once I'm happy with
the design finally while I was waiting
for this board I wrote a little hard
well Torben and I wrote a little
hardware simulator that has a visual
representation of all the peripherals
that we have on this board I mean they
look a bit different of course but so
the idea is that you can simulate the
functionality of the hardware modules
that we're developing or you can simply
experiment with hardware modules using a
front-end written in HTML and JavaScript
that communicates with an erlang
back-end using web sockets this is a
very early version so don't never mind
the debug messages um but the idea is
that when you say toggle the value of a
potentiometer that gets in back to the
back end and then you can pass that
a simulated ADC SPI module to a
simulated well temperature gauge or
something along those are that so the
API or the sort of structure of this
simulated framework is exactly the same
as the real one it's just that there are
less chances of blowing things up and
it's actually more colorful than the
export as well so feature explorations
just a splendid second illness we are
quite interested in a number of
different things but I had to choose one
because I'm running out of time so this
new project called parallel ax they have
a very interesting very low-power
extremely low power cut down multi-core
MIPS architecture that they are pairing
up with as I link zinc FPGA which
happens to have a multi-core ARM
processor in it so when we finally
received this this will be a couple of
months i think i will certainly be
running Erlang on the fpga device on the
linux running on ARM cores with and then
look at ways we can write some
interfaces to the hard IP blocks within
the fpga and also the co process of the
mips co processes that we have which
will have 16 cores so this is going to
be fun i'm quite looking forward to it
keep an eye out on the blog I should
really update it um so if you want to
get started you can download a
pre-compiled package for the Raspberry
Pi at the moment from our o-line
solutions packages place we will be
publishing more packages for other
architectures as well but if you just
want to get started on the pie you can
head straight over and download the
package and we're also in the process of
putting together an erlang embedded
training stack which contains an
embedded Linux primer and some basic
Caroline plus the hardware framework
redeveloping this is for the people
interested in doing real Internet of
Things devices
so get in touch if you're interested I
think on that note I would like to say
thank you very much for listening and if
you have any questions feel free to get
in touch and yeah thank you Hey yes I
think there is is that yeah plenty good
the only solid data that we have from
that express an experiment done in Italy
I think where they got some high school
students not technically children I
guess I don't know how the
classification happens but none of these
have none of these pupils have programs
anything before and they get them to do
some distributed chat applications using
your line Georgina much about this so
did the thing is us this code says
things are concurrent in real real world
they communicate using messages so
mapping that to a computer program using
imperative languages or anything other
than sort of concurrency models etc is
actually more difficult than just
thinking okay so I am a process my
friend is a process I have to send a
message to him or her so it's system up
matter of mapping the notion of passing
a message to syntax so um I mean I
thought we haven't run any classes with
students just yet but I think we will
see that actually I don't know I think
we might see some interesting stuff
coming out I'm confident that it won't
be like trying to teach pointers to
little children so I would tried that
once at University just doesn't work
yeah you should well definitely I mean
it in a sense I'm from I completely
agree I mean I'm from a hardware
background so I'm used to sort of black
box model of developing say FPGA blocks
and connecting up using the ACL whatever
and not I mean obviously it's not the
same thing but i can see certain
parallels between that logic design flow
and this because you can now abstract
these things into what blocks and then
just instead of using physical wires to
connect them you just use messages to
communicate between them the only
different thing is it's it's it's a
synchronous so there you need to be
careful with certain things but then
again it's you know is perfectly viable
to create blocks or block
representations of these devices or
gadgets that you have connected to your
system and then create like an overall
architecture original representation
people go wrong you can't be
the fun
Oh in the st then we can the engineering
world there are you know paradigm or
their visual programming in worms that
let you do that like LabVIEW for
instance is a major scientific sort of
visual programming environment where you
have see me link from MATLAB corner of
the company that produces well spice is
a good example as well it's a tad
different to say LabVIEW or see me link
but yeah I mean I also love you people
get it right and you can actually map
labview certain or LabVIEW visual
diagrams to FPGAs directly in my server
so you can map simulink diagrams or
Hardware directly etc so I mean hardware
because of the inherent parallelism in
the system you can quite nicely abstract
these away into little blocks I know
it's entirely different this tidus
mentioned it as an example to visual
programming
not that I'm aware of is there a visual
sort of composure for airline you can
certainly make them you can't you can
see a graphical rip yeah make an html5
web scale app you can see a visual
representation or graphical
representation of your system using the
debugging tools built into the sort of
lying distribution but that just shows
you what you know how the processes are
you know acting etc doesn't let you as
long as far as I'm aware it doesn't
really let you modify it etc so yes
issue sure you should write on I think
it would be a good project in a sense
you're implementing data flow using
actors and message passing actor model
is just a way of abstracting the
complexities of hardware into you know
simpler sort of blocks or simpler bodies
of code that's you deal with you can I
mean if you let's say you have an image
processing system you have a camera you
have to apply some filters to it etc and
you need to do something with the output
so you can certainly you know implement
it in a data flow like model where you
have different taxes 14 image
acquisition one for filtering one for
more filtering etc and you can you know
configure it so that you know you send
the image data sensor data to first
filter and then to the next one and so
on and so forth so it's very application
dependent ready I mean not all embedded
systems require data flow processing
there are certain ones that they do but
most mostly I think the interesting bit
is the fact that you can say abstract
interrupt service routine into just
simple processes so that you don't have
to worry about say Wecht it interrupts
or intra priorities and interrupts at
all you can just you know how
them concurrently running or even
parallel the running on different cores
etc so I mean one of the experiments
that I'm doing at the moment is mapping
hardware interrupts into Erlang messages
and you know bypassing the entire sort
of interrupt structures etc so
for many 30 years college people who do
my preference
both but I think this is going up into
into somewhere where software I mean
so in that case you it's more fun to
reach over dress if it doesn't work you
can just travel in the pin it's quite
satisfied just as a final remark as you
say you can certainly not attach a few
core processors zero system I mean like
in the parallel case I was talking about
earlier there's a 16-core MIPS device
attached to an FPGA at our technically
attached to an arm core so you have this
notion of employing many coprocessors
different kinds of devices which are you
know very good at doing different things
and then just write your overall sort of
system description or the orchestration
of all these different devices in Erlang
using you know abstracting them away
into the little blocks etc I think
that's the interesting proposal because
we have different devices especially
with the whole low-power you know
consumption and let's save the
environment kind of stuff happening we
need to be careful with this sort of
devices that we employ for calculations
so f pjs are great for certain things
but it might be overkill for certain
other things so you might want to employ
a smaller core or for this 16 core 64
chord advice to do different things etc
so on that note I i'm going to leave the
stage and thank you very much once again
for listening
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>