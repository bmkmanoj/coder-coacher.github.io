<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory 2014 -- Sneaking Erlang in Through the Back Door | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory 2014 -- Sneaking Erlang in Through the Back Door - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory 2014 -- Sneaking Erlang in Through the Back Door</b></h2><h5 class="post__date">2014-03-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LD_YXJwqgZE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I'm from shoretel I'm going to be giving
a bit of a bit of a history of how we
managed to get Erling accepted into a
company that had your bait your general
sort of resistance to change fear of new
things all that sort of stuff you know
the kind of company that when you
mention her laying they go but where are
we going to get Erlang developers like
go out and hire a thousand Java
developers tomorrow to which you think
to yourself here and then you'll have a
thousand Java developers and then what
are you going to do now this whole talk
it's not really intended as a how-to but
it's it's meant to give you some sort of
hope that at least this kind of stuff is
achievable if you are looking for how to
thankfully in the last couple of weeks
we've can do the whole thing in just one
slide drop the microphone and walk out
of your boss's office because if they
weren't convinced by that then they're
not going to be convinced of course
leads me to my proposal for her legs new
tagline so I'm visiting here from
Australia I work in a little satellite
office of our company down in Canberra
which exists for historical reasons and
now they can't get rid of as much as
they might like to Australia known for
its beautiful scenery lovely landscapes
and of course friendly welcoming
wildlife so when we first came to
introduce lang I was working for a
company called m5 networks we produce
hosted business phone systems VoIP as a
service this was before marketing a term
the Queen had coined the term cloud but
it's effectively what it is basically
just have a phone on your side and an
internet connection plug into our system
and we provide all the stuff that you
otherwise be paying twenty thousand
dollars for a cisco box and trying to
find your own sip providers and paying a
guy to manage at all and stuff and we
our business model was one of economy of
scale you know we'd have one server with
a couple thousand companies running on
it or what have you scale up to around
10,000 ish phones per physical server
and we did it with a little bit under
100 employees of course technology
companies never stands still we got
bought by shoretel who
of an office down here in Sunnyvale they
sell both they sold premise based
systems which are the boxes that you buy
and put in your own data center and
decided that the cloud and hosted stuff
was the way forward and rather than
build their own stuff they went out and
do what any tech company does and bought
us wikipedia tells me we have something
on the order of 975 employees and some
guy in the corridor told me we were the
third largest business VoIP provider in
the US which is nice apparently we're
behind Cisco and a via by quite some
distance but ahead of everyone else so
that's where we that's where we were in
our business wise terms of technically
speaking when I first when I first
started we had a code base of about a
quarter of a million lines of C++ code
it was massively parallel for some
definition of massively parallel it's
pretty robust when I first started we
were doing the thing where you shut down
the system every night and restarted
again because leak to memory like a
sieve and maybe if you did that every
night it wouldn't crash during the day
when people trying to make phone calls
that's that's that it improved
drastically within a couple of years and
and we had up time in the sort of order
of weeks and months and that tended to
stretch between version updates which
was fine for us had a fast in-memory
database two reasons for that one was
speed if you're doing routing for a
phone call you don't have to go off make
a bunch of SQL queries to find out where
to route it from a database that maybe
someone's got to lock on and it's going
to take a couple of seconds to come back
or what have you so we duplicated all
the SQL data into into memory and were
able to make Neil Locke free requests
from that from that memory especially
for read operations and that gave us
very fast routing on our phone calls and
the other reason to have that in-memory
database was one of reliability we
didn't trust the SQL server we had at
the time which we probably could have
because we never actually had a problem
with it that was my SQL for various non
technical reasons we're now using ms SQL
and it's a really really good thing
we've got that in-memory data
because it's become unavailable for
various reasons during the day numerous
times in the past and given what it was
written in it was surprised it was a
surprisingly scalable system considering
it was based around around a few p
threads and work threads and fsms and
what have you but it was far from
perfect first problem of course was
there was a quarter of million lines of
C++ code and it had been developed by a
bunch of different people as these
projects tend to be over the course of
ten years or whatever and bit rot
setting in fairly hard and of course the
one of the biggest issues with C++ is
when you've got this single monolithic
UNIX process to which all your phones
have these TCP connections you go down a
code path that you haven't tested
properly because somebody does something
weird on their phone as customers tend
to do null pointer dereference blam
whole system goes 10,000 phones suddenly
go can't find server connecting and
everyone has these damn things in their
pocket they call up your support line
and suddenly you're twenty percent
support desk has 10,000 calls in its
queue and nobody's very happy then what
upgrades not even going to happen with
C++ so you've got a certain amount of
fixed down time there to do any upgrades
of your system anyone's ever tried to
debug your crash in the stl you'll know
what I mean here it's not a fun place to
try to figure out what's going on how
concurrency model was based on state
machines because C++ threads are
relatively heavy weight somewhere
between 64 k + + 8 Meg depending on how
you configure them and so basically our
al concurrency system was one of a set
of a small set of worker threads couple
more than the number of CPUs we had and
you've got a bunch of ffs m's one for
each phone or one for each call
depending on how we modeled it for the
various bits and the and when a message
came in a free work for grab that
message find the fsm was to pull that
state and execute the function on that
fsm with that message and then put it
back on the thing go and grab the next
message and so forth that's a nice model
of concurrency except that it comes with
one major drawback and that's that the
operations within those functions can't
block so you've got a every time you
want to block you
to break that state up into two states
one pre Block in one post block and you
could have a message to pull it out of
that blocking state and that's a pain in
the backside to code makes your code
very spaghetti light because you you've
got all these separate separated out
functions where really it's a perfectly
logical flow of control it's just that
you need to stop and wait for something
to happen and yes I threads threads and
processes as we think of the minnow
lying or not a practical concurrency
model in C++ for that kind of stuff but
it turns out someone a bunch of very
smart people one of whom appears to be
seeing up the back of the room had
already thought of this turns out we're
not the only people to have encountered
these problems which was heartening but
of course we were we were to not
invented here to have ever considered
this possibility luckily a colleague of
mine and I boys insist on going to
limits conf in Australia every year
which is an excellent conference if any
of you ever get the chance to go five
days of nerds sitting around discussing
nerdy stuff and it's fantastic and one
of the nerdy things that was discussed
in 2007 in Sydney was Erlang sky talking
about concurrency and thousands of
threads and really simple model for
concurrency and it's got this in-memory
database and naturally we dismissed Sam
as a complete lunatic because Sam my
colleague has a lot of crazy ideas and
just chalk this up as another one yeah
sure another language whatever in front
of fix ml point a problem over here all
the phones are down again but I'm closer
investigation did seem like it might be
a good fit it had the concurrency it had
this focus on robustness it was a nice
high level language so we could do more
in less lines of code and it even had
its own distributed in memory DB which
was kind of exactly what we'd already
written ourselves except this one looked
like it was good come on so in the
interests of giving our lunatic enough
rope to hang himself we found we had a
little standalone project had to write a
tftp server now obvious question is why
on earth would your other tip-tippy
server there's a billion of them out
there already the cisco skinny phones we
use use tftp as their configuration
system which is a perfectly sensible
thing to use when you're using your
phones on a land
and about the worst possible protocol in
history to choose if you're trying to do
stuff over the internet which we were
tftp and furthermore we needed to do we
need to have a different file for each
of the ten thousand phones that made
this request so you can manage 10,000
flat files in a tftp directory or you
can dynamically generate them which is a
far more sensible thing to do the other
problem we had with the stopped ftp
servers is as soon as you put a device
behind a nat TFT ftp breaks even more
than it was before because the way to
ftp works is the phone makes a request
to port 69 and the response comes back
from a different high port which means
that the net device goes what the hell
is that i'm just chucking that away the
phone never sees it so we had to
completely break the tftp protocol send
all the reports multiplexed out through
port 69 but that's ok cuz cisco had
already broken the tftp protocol in a
bunch of other ways before we got to
them so we didn't feel too bad about it
so I compiled this wrote this up in you
know Lange used to use a little bit of
your lanky tipico that was already
conveniently in there and we put into
production and and much to our surprise
it kind of worked but you know where
we're a tough bunch to convince so Sam
went often wrote the first pieces of
what's now known as flim the following
logic emulator somehow we'd got into
this relatively large scale relatively
robust system testing no other way than
plugging a bunch of phones in and having
people hammer away at them which we look
back on now with some horror and you
should be looking at in horror as well
the of course what you really want if
you're going to test that your servers
can handle 10,000 phones before those
10,000 phones were all your customers is
to buy 10,000 phones hire 10,000 Q white
people plug them up now that's a stupid
idea you want a softphone you want
something that can be scripted fire up a
bazillion instances of itself and hammer
the server that way and so Sam found
some spare time by which I mean if you
need spare time for a project tell your
boss it's going to take four weeks when
you know it's going to take
two and then two and then take four and
use the other two to do this spare time
wrote up a sip soft sorry a skinny
softphone in Erlang and this was kind of
where I got a little bit interested and
took a look at the code because it was
pretty short and pretty concise and kind
of even readable for someone who in uni
I hated functional programming languages
I could never get the hang of them but
this Erlang thing kind of made sense to
me I picked it up and I'm like well one
phones nice but I bet we could do more
because this is a concurrent thing sure
enough within the day I had a sporting a
thousand phones on my laptop and now we
had something or at least the start of
something that was usable as a load
tester oops wrong button maybe Sam was
onto something here after all but Sam
and I just two crazy people over in the
camber office and the rest of the people
are over in New York and they think
we're just some crazy Australians have
been bitten by one too many snakes
convenient I was I was going over to New
York so I jumped on a plane flew over
there I prepared a bunch of talks saying
here's Erlang here's what it looks like
we think it's awesome for what we're
doing because for goodness sake Ericsson
wrote it for telephone systems and this
is what we're trying to do here and look
not scary here's your cue sort is you
know Fibonacci sequence and I people
kind of started to to get the idea of it
and demonstrated phlegm and the tftp
server and say hey this is really cool
check out quickly and easily we're
concurrency in zero time because we
definitely weren't working on this
during work hours but of course there
are going to be naysayers there are
always new says these are some direct
quotes from emails i got telling me why
I was insane for trying to do this it's
no inheritance well yes of course
there's no inheritance not an
object-oriented language kind of missing
the point here you guys couldn't no
doubt come up with better rebuttals than
I did to these at the time and I'm more
just trying to give you a feel for some
of the things you might encounter
um no global data at all which is like
killing a dog because it has flies I
think he meant fleas but either way it's
again it's kind of a it's kind of
missing the point it's missing the point
of that this is a different paradigm but
it's also missing the point of why
global data is so bad like half the
problems we had in our sleep less fuss
code will lock problems deadlocks not
locking hard enough locking too long not
locking long enough and the locks of
course would trip over one another when
you because the locks had to be locked
when you were doing those non-blocking
loops so you inevitably introduce some
kind of blocking that earlier
performance the law of leaky abstraction
and heard this one before it was raised
as a as a complaint Joel of joel on
software rotor wrote an article about
this notion and dolphin is absolutely
valid no abstraction can completely hide
that is able to completely hide the gory
technical details of what's going on
below it that's it that's completely
true unfortunately this guy had taken
that to mean we should never bother
abstracting anything at all because it's
just a lost cause which is clearly not
true otherwise we'd all be sitting here
writing machine code and going slowly
mad sku language net bsd has more
websites than knowing which was probably
true at the time i actually checked
yesterday and and it's no longer the
case at least in terms of the number of
hits google gives me but again this is
kind of missing the point and for that
matter comparing apples to oranges just
because fewer other people using this
thing doesn't mean it's not a great idea
it's a great quote from scott adams
author of Dilbert something along the
lines of you know if middle managers had
run the caves back in Neolithic times
none of it would all be shivering and
freezing to death and still in those
caves because if everyone was using fire
sorry if fire was such a great idea
everyone would have you been using it
already so and you know none of our
competitors are doing this well you're
going to follow our competitors in order
to get ahead of them that's not how
getting ahead works this was the best
one if you like the Erlang syntax oh
that's just re implemented in C++
operators oh god don't know I don't
and dude like all I responded to this
was dude you did not just write that
seriously but okay we overcome we
overcame those we managed to convince
people that okay maybe we should start
using it for a couple of bits around
around the edge of our system and see
how it goes of course what we really
love to do is just throw away all our
horrible C++ craft that is currently
supporting a hundred thousand people and
rewrite everything from scratch but
nobody would let us do that which was
disappointing so we've got all this
legacy code sitting around that that is
in fact the entirety of our system at
this point and so initially we're
restricting our line use to new
functionality and picking features that
weren't core so these are features where
if they stop working because we're
really new to Erlang and are making lots
of mistakes which was absolutely the
case people will be upset but not that
upset in the world of telephony nothing
upsets people more than picking up a
phone and not getting a dial tone or
being dialed to or knowing that their
friend is calling them and their phone
isn't ringing those are the only two
things that have to work all the time
everything else call recording yeah
they'll be annoyed if their recordings
don't don't happen or a garbled or
whatever but probably not annoyed enough
to quit CNM is a for those of you who
aren't familiar with it it's basically a
reverse directory look up system so you
get you get your caller ID number come
in you send a message off to a third
party scene and provider and said who
does this number belong to and they send
you back a string identifying it as
either a name or a company name or a
mobile provider or whatever so again
people going to be a little bit
irritated if just an their unannotated
numbers start showing up on their phones
but they're not going to you know
they're not going to go somewhere else
in a hurry and monitoring customs won't
even know if you're monitoring goes down
for a little while unless of course
while you're mutterings down something
far more drastic happens but these are
kind of the non the non-core things that
we started building or laying around and
as a sort of safe way to start
shoehorning it in a little bit around
the ages but of course it still also has
to interface with the old code which
means in our case it had to talk our
binary struct based protocol because all
our C programs they didn't talk
something nice like Jason or sit between
each other now all they did was take a
struct set some values in it write it on
to the socket and then the receiver has
a structure the same type reads straight
into that memory for the size of the
struct and it's brilliant it's really
quick it's absolutely no pausing or
encoding required or anything and as
long as your system is a modulus and you
control the compiler and everything it
works perfectly it's absolutely
brilliant it's a little bit inefficient
if you've got like large potentially
large strings because it'll write the
whole string and all the garbage at the
end of it and so forth but in terms of
coding it's really easy really nice and
really your entire sending and receiving
of messages are those two functions it
doesn't get much simpler unless of
course you need to do it in another
language which has no notion of sea
structs and no notion of the compiler
using so the Erlang side to speak that
protocol is a little bit more involved
read off the blob from the wire and you
use Erlang's beautiful binary pausing
syntax to pull out the 32-bit it signs
little-endian integer at the front and
the 64-bit sign little it's a sign long
long in the middle and the string and
you check them all and it's record and
the strings a little bit difficult
because you've got a you've gotta pull
data off only until the null terminator
because it's probably garbage after the
null terminator that's okay it can all
be done and encoding is basically the
same thing in reverse you receive the
record chuck it into a binary same
things again the strings a little bit
difficult you've got to write the string
itself making sure you don't run over
the size that's been defined in the
struct and then you've had the rest of
zeros if you're a little bit paranoid
like I am so that's not too bad except
structs aren't that simple in their
layout are they because the compiler
quite reasonably likes to align things
on the boundary of the first element
there so this is a 4-byte integer but
this is 12 bytes at the end of the
structure and so we've got a pad out
sorry 10 x to the end instructor so
we're going to add a 2 by padding there
otherwise when you chuckle these things
into an array on the seaside the
indigence and either your computer
crashes entirely or suddenly everything
gets like a hundred times slower but
that's okay because if you know what the
compilers doing you can just add in
these paddings on the encoding and
decoding that's not too bad and so can
go ahead with that oh except are now
we're moving to 64 bit in the compiler
pads things differently dammit so our
long lungs now need to be aligned
because they're there the native data
type on the CPU so we've got a pad after
the after hour for byte integer there
we've got to add another 4 bytes to
align this on an 8-byte boundary and
we've got added a little bit of extra
padding so the whole thing's line or
night by boundary and same down here so
we've got now two bits of padding and
their sizes are entirely dependent on
the previous values and it's all getting
a little bit complex and that's exactly
where you start going insane when you've
got a hundred of those different records
and you're having to in your head figure
out all with all this padding that's
going on and make sure you maintain the
struct as well as the encoder and the
decoder in the Erlang wreck and I hate
changing something in more than one
place when I first started if you needed
to change a database record definition
you had to make that change in nineteen
places in our code it was insane and you
and the compiler wouldn't pick up a lot
of them if you missed them so we very
quickly came to the conclusion that was
not going to fly and we wrote ourselves
the yarn code generator being invested
in tightly now as we were in Erlang it's
it itself is written in Erlang and being
lazy as we were the parser is the Erlang
passer so the code the code that we
write for the code generator looks a lot
like Erlang so we use the Erlang
possibly use yet which is the compiler
compiler
like it's the Erlang vision of yech a
yak rather if any of you who have used
that and early dtl is a templating
language to spit out the final product
and with always stop at why stop at
summer laying encoding and decoding on
the sea structs because we also had a
java external program that we needed to
interface with so i made it generate
java classes and marshals and encoders
and decoders for java as well so we send
stuff over over the interface to add a
node in native or link terms from Erlang
and now java can decode those into
native java types and python and SQL
because when we update upgrade the
database we do that with scripts so we
take the SQL we modify that the code
generator will spit out all that stuff
nicely as well and this means now that
if we want to change the database schema
the the same schema that's read by arrow
lang and i'll see you know java and on
the database itself we make that change
in one place and it just blacks out to
all of these and everything just works
and i am saying again and it's great so
just quickly it looks the yarn code
looks a little bit like this you define
a record you can define constants as
well and a bunch of other things but you
define a record you give it a name and
as I say this looks a lot like Erlang
because it's using the Erlang pazza so
it tokenize is all this beautifully
integer those long Long's string and
then you can have these annotations on
the end of things for things like string
length as is going to be used in C and
SQL you can say whether you want this to
appear in the web editor I actually
missed one in the previous one it also
spits out Chicago boss template files
for each of these tables so that you can
edit Chicago boss edited a Chicago boss
based web editor and that goes through
early detail and spits out a see struct
and the Erlang and the and the pattern
and the padded encoder and decoder as I
showed you before adjusted appropriately
for whatever bit BTW did you're running
on 64 or 32 so that was probably the
biggest interesting technical thing we
had to overcome when merging along into
our existing stuff
but there are a bunch of other things we
kind of discovered as well anyone see my
light and talk and LD last night cool
for the rest of you our existing C++
stuff was distributed within rpms and
started and stopped using init scripts
standard way that pretty much every
demon is managed on Linux so you go
service Apache start service Apache stop
and they all just work Erlang's vm
because of its embedded heritage make
some some of the semantics of that very
hard to achieve clean shutdown is is one
of them if you've got a bunch of sub
applications but also the one that
annoyed us well two things annoy us most
one was that you couldn't output some
output to the console and then detach
the console you either ramming detached
mode which automatically returns success
for guarded regardless of whether your
applications started or not or you ran
in interactive mode which means you
never got your console back and neither
of them are really acceptable for
start-up because when assistance admin
types in service Elvis says our project
is called start hit center and it
immediately comes back to console
success he goes great I'm off to the pub
and they gets a call an hour later
saying none of the phones are up that's
because o it actually failed to start
even though nothing came up in the
console and we returned success and that
makes for unhappy system mins which then
makes me unhappy LD is our little
wrapper program that provides those kind
of semantics and allows you to start up
an erlang VM and then from within that
decide when you want to detach from the
console and return success or will rule
propagate through an error code if
adults before that detaching it will
also provide you seek up operations so
sync up is used in Linux as a low
rotation trigger you take the logs you
move them to the place you want to
archive them and then you send a sick up
command to Apache it closes that log
opens a new log and life continues
Erlang doesn't being largely agnostic as
far as i know it doesn't have any way of
intercepting signals so oh they will
catch the signal translate that into an
allowing function call and you can use
that as a as your log rotation hook can
also use it for other things if you're
so inclined but log rotation is why we
came up with that we learned pretty
early on that monitoring your system is
a really really really good idea because
Erlang being fault tolerant will
continue to sit there failing while
looking like it's continuing to run if
you're not looking closely at it and we
first kind of discovered this with when
one of our message queues blew up as
they tend to do when you're still
learning along and only have three
gigabytes of memory and message queue
blew up and then we looked back at the
logins like man we could have seen this
coming literally two days ago memory use
was just going like this and this
process had slowed right down but we
weren't watching it so we very quickly
learned that that's a really good thing
to be able to do use dialyzer does
anyone here not use dialyzer wow awesome
good stuff I don't need to tell you
anymore then dialyzer is awesome catches
so many mistakes so where have we got
Polly now with with Erlang we've got it
we've got it in there we've started to
use cements and we started to use it for
stuff around the edges well we're now at
the point where the company and and all
management and everything is happy
enough with it but we can use it for all
our major new features everything we
write basically that doesn't require
just a tweak to the legacy C++ stuff is
written in Erlang awesome rewritten to
legacy features in Erlang so parking of
calls which is where you go I'm just
going to put i'm just going to park this
and pick it up in another room park that
down walk to the room pick up the same
call there that bit is now managed by
allaying as of a couple of weeks ago and
the loading and synchronization with SQL
is probably the most important bit
that's now done in Erlang because if
that stops working our whole system
stops working so that's the first really
corbitt that has been moved from c++ to
Erlang because we've got to the point
where we trusted enough now to manage
that data abstraction layer
our lines of C++ code haven't gone down
in fact they've gone up pretty
drastically but you know we've been
writing a lot of new features and more
importantly we've got quite a few lines
of Elaine now 171,000 according to a
quick count I did which makes according
to a metric I made up on functionality
vs lion counts Erlang in charge of the
majority of our functionality because
I'd say you get least as much
functionality from 171,000 Minds billing
as 385,000 lines of c and orleans now
used for a pile of stuff so there's the
stuff i mentioned earlier the hosted
call recording scene am it's also a web
admin UI UI which in a couple of
thousand lines replaced fifteen thousand
lines of horrible horrible PHP that no
one could maintain and what's more now
when we make schema changes they just
because of yarn they just automatically
get dropped into that web api and we'd
have to change anything support for the
latest phone models is the other thing
we're just rolling out this week in fact
when shoretel bought us they have their
own phones so they didn't want to be
selling cisco phones anymore than cisco
being a competitor of shoretel it wasn't
necessarily a good book for them to be
relying on their phones so support for
the shoretel phones is now done through
Erlang throw it through a new Erlang
module a debasing as i mentioned call
tracking the the history of our system
came from a couple of guys who wrote it
as basically a very simple residential
sip service so I call you we talk for
all we hang up that's all there was to
it so the notion of tracking calls
through these complex flows that they
tend to go through and businesses where
you hit IV ours and conferences and park
and pick up and all this sort of stuff
was completely absent and so the best
thing we could come up with for tracking
that was basically to write an erlang
module that has a bunch of probes all
throughout the system and when when a
bit of the call code executes this bit
it sends a message to Erlang and it
sends a message here and there's just a
big fairly horribly complex but
incredibly amazing piece of Erlang that
pulls all these messages together and
orders them back correctly and then put
them all together and gives you a view
of what a call actually did as it flowed
through the system which was something
we never had before it's also great for
billing
she tells you how much you should charge
a custom for that call which was not a
thing we were good at knowing before
tftp as i mentioned park call management
load testing that flim tool is now still
our standard load tester and it's
continually being built and improved on
all our system monitoring is now done
through Erlang via its its SNMP system
and sip director which i can never
remember which all of this guy's and I
think the soup director is the one that
decides which sip provider calls go out
to as you make when you make a call so
we have a bunch of sip providers and
we'll choose them based on least cost or
best quality or whatever how much we
hate or like the customer that's making
the call something like that so
basically the the summary of this whole
thing is when you're trying to build
acceptance for for um erling you need to
start you need to start small he need to
start with safe non core elements where
if they break and if you're new to a
lame they're going to break a number of
times because you'll be making mistakes
probably a lot of the same ones we made
and if you break something really
important people are going to look at
you and go well clearly Erlang's rubbish
stop using it get back to the C++ so
start small start safe don't build
anything critical with it you're going
to make mistakes do it one pit yeah
except that unless you're incredibly
lucky or your company is incredibly
crazy you're going to be doing this one
bit at a time it's not going to be a
matter of checking out the existing
stuff and replacement with Erlang it
depends maybe maybe your company is in a
position to do that but none I've ever
worked at have been you know it's every
program is dreamed to rewrite something
from scratch and it's every managers
complete nightmare because they know
that their programmers will be for all
practical purposes unproductive for the
next year as far as their spreadsheets
appear Oh lying is easy i had originally
had citation needed Mike was kind enough
to provide me a citation for lang being
easy and his keynote on yesterday but
building concurrent high loads too
highly scalable production systems still
isn't so
you can look at erlanger I'll cool it
gives me all this stuff and my system is
going to be so robust and so fault
tolerant and that's kind of true but
it's still not an easy problem it gives
you tools to make it doable it doesn't
give you some kind of silver bullet
that's going to solve all your problems
so that's that's basically my story any
questions anybody yes sure so I'm I can
i can give you some rough ballpark
estimates certainly the we originally
started using it in late two thousand
and seven and the tftp server was sort
of the work of maybe two weeks by one
guy flem on the other hand is quite a
large project it's been worked on by a
number of people we've even got done
some Erlang solutions guys to contract
in to work on it that's been you know I
wouldn't I wouldn't even like to guess
but it's probably been a couple of men
years work on that but it's also
incredibly powerful now it's got full
sort of scripting languages like
language built around it and and it's
distributable over multiple modes so you
can you're not limited by what you can
fire up and what on one machine to
hammer the server and it's it's got to
deal with like our phone call the amount
of different permutations we have to be
able to test is actually very very large
it's not just I call you we talked we
hang up there's all sorts of the XML
scripts calls might go through there's
all sorts of call forwarding rules they
might apply to that they might have
applied to them there's conferences
there's transfers there's all this kind
of stuff so flims able to actually do
and test a lot of that stuff
automatically and report back whether it
worked it's also now got voice quality
checking so it sends down it actually
generates and sends DTMF tones and then
does an FFT on the far end to check the
quality of the link and stuff and so at
one stage we're not at the moment due to
basically lack of resources but once
they were actually using that and
automatically making calls out
over our carriers every 10 or 15 minutes
to check both that the carriers were
still up and that we were getting an
acceptable quality of service off them
so it was quite a quite a big task
getting getting flume to do love that
what were some of the other things I
mentioned the webui was probably about
there was two of us working on and it
probably took us about three weeks to
write which considering it was replacing
you know fifteen thousand lines of PHP
and is way better at it now it's much
nicer and cleaner and users all pretty
CSS things and has slightly pretty
colored dialog boxes and stuff and
considering neither of us web
programmers or knew the first thing
about JavaScript and or anything it
actually went remarkably quickly and and
turned out quite well so that was a
combination of Chicago boss and early
early dtl being able to throw that
together so quickly and then also some
JavaScript libraries jquery and one
other one that i can't remember off the
domain i'll put his boot strap thing as
well so that that was like a few weeks
work the host of cool recording was not
especially big and in fact it has one of
our one of our real success stories in
it because the code to retrieve the
hosted that the recorded calls is come
is one of the few things that's
completely separate from the rest of the
system so it's it's one of the few
things that we've written from the
ground up in Erlang as a standalone
long-running fairly heavily utilized
application and it's like even the sort
of very earliest versions of that were
having up times on machines longer than
the than the period between upgrades so
I found one that had been running for a
year because someone had forgotten to
upgrade it and it's you know ticking
along no problems at all but host a cool
recording as a whole was the work about
five people for three months or
something something of that order CNN
was was was pretty trivial because it's
just a very very tiny subset of sip it
gets a all we had to do with fire
request from one part of the system into
seen am it fired a request off to our
provider they sent back it was a
subscribed notify I think
send back a notify with the answer and
we fire that back so the only
interesting bit of that was that our
lunatic engineer decided that he'd use
that as a chance to experiment with
functor based pauses and so we've got
this cool sip pazza which almost drove
him mad trying to write when he realized
that the spec if you try to implement it
exactly as it's written is internally
inconsistent and impossible to implement
exactly as it's written sip is more of a
bunch of suggestions than I than a
standard I've come to the conclusion the
DB sink was was interesting because that
had to sort of perfectly duplicate what
was what was there already and it had to
do it in an extremely robust reliable
way and that required on our parts and
patches to the Erlang odbc libraries
because we weren't getting enough error
information back about them and stuff
and that that was mostly one guy and
probably took him a couple of months to
get that all really bedded down and
solid and safe but that's that yeah that
those are the kinds of becomes does that
answer your question to a new sent you
our our team at its biggest has been
about maybe 12 people and for the most
part most of the Erlang guys have been
written by a core of that's most dealing
stuff Rather's been written by a core of
about six or seven of us it's not it's
not a very big team at all it was it was
not not wanting to blow my own trumpet
but as a team it was quite it was
actually quite remarkable that we got
even before along that we got the sauce
which running as sort of well and as
large-scale as we did given the the very
limited man resources we had
mostly they've quit know that that's not
entirely true no actually that almost is
entirely true most of them now don't
work for us anymore for one reason or
another like I think I think one of them
left when he decided that he really
wanted to learn C++ and he didn't like
where we were going with this he was
actually the one where most of those
quotes came from especially the
operation the C++ operation one so I
can't say I was too sorry about that
yeah so that's a really good question so
we had we've had a couple of guys join
us from the premise team who are there
like people that were in short old
before they bought m5 and they were all
from a pure C++ background and were
understandably interested in yet
slightly concerned about being put on
our team to to learn Erlang and stuff
and one of them just recently got pulled
off our team and I was talking to him
yesterday he's like so I'm still writing
a bunch of willing at home because I
don't want to forget how to do it
because I want it I definitely want to
get back onto your team and keep working
on because this c++ stuff is doing my
head in now now that I know there's a
much better way and the the other guys
yeah there's been no no problems
training them at all I mean it's you
know it's it's required pointing to the
right resources with I get emails
whenever there's a check in and I sort
of go over their code not in a sort of
formal code review way but to say hey
here's a because he's a cool way to do
this in Erlang like half the number of
lines or whatever there's still a couple
guys who who i think are a bit in the
c++ mindset and as mike said tried try
to write Erlang as C++ but we're slowly
nudging them away from that and getting
to write in a mall in a more functional
way so tre training hasn't really
training hasn't really been an issue and
surprisingly neither has acceptance for
the for the people who've actually come
from one side sort of the fence to the
other if you like they've actually been
quite positive about it and and quite in
some ways disappointed that the the rest
of this larger entity now is still sort
of a bit reluctant to accept it as
idea yeah yeah so so okay so there's
there's kind of two bits of handling the
RTP 11 we do a bunch of just straight
packet forwarding and for the short
answer is for all your all the RTP stuff
we actually have C++ drivers see C C++
level drivers for the for the
high-performance bits because precisely
because yelling doesn't scale well to
just doing nothing but pulling through
masses of UDP traffic and shuffling it
out another port and for the bits where
we actually do media manipulation so
generating sounds mixing conferences in
that kind of stuff that's still in the
legacy code and hasn't hasn't been
ported across yet
we use some okay so there's there's two
elements to store in voice my oneness
store in the metadata the record of the
voicemail that's that's been stored and
that's done in our standard database
which is the the back end of that is now
microsoft sequel server I didn't choose
it it's not a good choice but that that
information though to the Erlang process
is accessible through amnesia because
we've got that case layer there and
threw for the c++ versus as processes is
accessed through the through the memory
through that case from everything and
that's that is linked directly with
amnesia and all synchronized across
there for the actual storage of the
recordings that's done through a very
simple HTTP put and get operation to a
highly available web server with like
redundant disks and all sorts of stuff
that the system's guys assures me will
never lose a voicemail but it's just
posted to http to what's called our
resource server and pulled off that when
we need it anyone else cool thank you
very much for listening</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>