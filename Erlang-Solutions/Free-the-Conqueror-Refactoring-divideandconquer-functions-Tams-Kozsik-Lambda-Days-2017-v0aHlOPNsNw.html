<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Free the Conqueror! (Refactoring divide-and-conquer functions) - Tamás Kozsik (Lambda Days 2017) | Coder Coacher - Coaching Coders</title><meta content="Free the Conqueror! (Refactoring divide-and-conquer functions) - Tamás Kozsik (Lambda Days 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Free the Conqueror! (Refactoring divide-and-conquer functions) - Tamás Kozsik (Lambda Days 2017)</b></h2><h5 class="post__date">2017-03-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/v0aHlOPNsNw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everybody I try to choose a funny
meaningless title for this talk but the
real story is valid is factoring the
factoring tools and in particular
affecting divide and conquer functions
so what I'm going to talk about today is
the necessary tooling for for analyzing
source code while Erlang in this case so
we can analyze along so you'll find
interesting functions and provide ways
to reset your these functions into some
form some particular form using a tool
and the way we do this allows us to
preserve the meaning of the program so
if you choose this kind of Turing then
you can be sure that nothing goes wrong
during resection of course there is some
bounded expressiveness behind is but of
course not everything can be done using
a tool but what you can do with the tool
would be more safe than doing by hand so
I should now explain what divide and
conquer is but after a Kevin's talk in
the morning I should just say that yeah
it's highly morphism ok ok so you can
see this kind of problem solving
structure in many many algorithms like
quick sort merge sort bucket sort
minimax search and current super
multiplication and soul and so forth
these are all very interesting
algorithms and they share common
property the main property is that to
solve the problem yes split up the
problem into smaller ones recursively
solve these smaller problems collect the
results of them the solutions are
smaller problems and then compose these
solutions into the solution of the
original problem so that's the main idea
and if i try to formalize this in a
pseudocode i would say that solving a
problem starts by investigating whether
it is a base case or not if it's a base
case then we can solve it simply if it's
not a base case then we have to divide
it into smaller parts then recursively
solve the smaller parts apply same
function on all items on this subproblem
list and then we can combine the
solutions to result of course the main
idea behind functional programming or
one of the main ideas behind functional
programming that current patterns should
be abstracted into high order functions
so if you want to write it properly then
you would define higher the function
which expresses this specific recursion
scheme so in this case I could just
define solve as an application of the
high audit DC function which takes four
functions and argument and then produces
a function assault function and the sole
function captures the same behavior as
we have seen on the previous slide so
what is my motivation of course tourism
everybody is motivated by their lesson
lamb nowadays so Kevin is interested
about me Gawker computers that that is
this term I think equine this term
nikkicole computers and I am sure that
programming this this kind of sneaker
crore computers you need very nice days
to describe for ilysm high level
patterns would be the best for this
purpose so i was working together with
kevin and others in project paraphrase /
patterns for adaptive heterogeneous
multi-core systems and in this project
we have developed the tool for for
refactoring Erlang programs for pell
ilysm so there are various sorts of
standard patterns and moans and there is
divide and conquer so let me show you an
example in your line for instance I have
a
short which sorts an empty list very
easily sort of think the list also very
easily the trouble started a non-empty
list for non empty lists you split the
list into two halves then recurs on the
left horror from the right house and
then you can merge the sorted list yeah
this is a divide and conquer it doesn't
contain the map function as we have seen
on the canonical example but everybody
can see that this is a divide and
conquer function it's not written using
a pattern but of course we can
restructure this code into into
navigation of the DC function the
high-order pattern so I could you write
this function in the following way while
I'm using a special library here scale
hlp is a library developed in the the
paraphrase project and it contains the
great mix skeletons for a lang so inside
this like really have an implementation
for dividing contract so we can all the
necessary constituent functions to
desire the function and it will return a
function so we can apply this function
on the input list and as you see this is
how we decide that we have visas base
case this is what we do identity when we
have reached the base case this is the
division and this is the combined
function well of course you can you can
you can find out how to implement this
DC I don't go into details this is
sequential implementation of the DC
functionality let's actually a Mac
function call I apply a function to each
item in a list sequentially but you can
turn it into a parent implementation
very easily by by using a bar map or
something ok of course you could add
some more knowledge into this pattern by
by limiting parallelism for instance by
saying that I allow this and this amount
of processes to be launched you
in the computation or by by using
variant of DC which can switch from
parallel computation to sequential at a
different condition so what we are doing
now we provide tuning I think we have
been really far in this we can find
divide and conquer pattern candidate
this is what I was talking about last
year here in ananda days so maybe you
remember this talk I'm not going to
address this issue today and then I
don't talk about assisting the
programmer in making good realization
decisions what I will focus today on is
refactoring candidate refactoring
functions which behave like divide and
conquer into the application of the the
higher-order function is seen and all
these steps are actually implemented in
party party stands for perforated factor
into four Erlang and well it is actually
based on our previous refactoring to
Accord refactor all so if you try to
download the two what I'm talking about
now while you will have to look around
at the de facto side so the central is a
static source code analyzer in
transformer which has been developed in
the last 10 12 years at a university it
can be a lot i'm going to use only a
small part of it in this industry search
suppose this too has standard
refactorings implemented already
renaming definitions and moving
definitions around introducing and
eliminating functions variables that's
quite standard again generalization of
function you're doing the parameters the
functions or toppling the parameters of
functions plus many other interesting
refactorings mostly specific to the
airline language but now we would like
to see what we can do for divide and
conquer functions
so once you have found divide and
conquer function we would like to apply
small meaningful transformations on the
code smart programmer probably should
know what sort of transformations to
apply in what order to reach eventually
to an application of the DC pattern so
for users we start out with the other
than the most short implementations
implementation we have seen so far and
then by applying certain transformations
we can reach so-called canonical form a
canonical form is exactly the same
structure that I showed you in the
beginning of the lecture so it's if is
based on these of the base case if it's
not is base then we divide the problem
into smaller ones recurs and then
combined solutions of the subproblems so
if we have this canonical form then the
last transformation will change code
into the application of the DC
higher-order function so this is how we
expect our tools to work so what is a DC
candidate yeah it's not i'm not going to
talk about haylor morphisms I would just
say that a function that's cause it's
recursively in a very tricky way yes you
or require that the function calls
itself multiple times on the same
execution path I'm not going to define
what an execution policies you can use
your at work definition in your mind so
it's just what you think of course and
there's one more important requirement
the disk or should not depend on the
result of each other so that they can be
executed in parallel so this is how we
try to characterize divide and conquer
function but but this these are the
functions can be written in many many
ways there are many semantically
equivalent synthetic forms that can
capture the same
concept or you can even split up your
function definition into multiple
definitions and have mutual recursion in
your code this wow we can care we can
take care of all these various synthetic
forms and find interesting functions for
you but now what to do with them how to
refactor them so let me show very simple
example that the current super
multiplication it's very easy to see
that this is a divide and conquer
function it calls itself three times the
parameters that do not depend on the
result of each other so it's fine or you
can have a most sophisticated example of
a minimax search where min max max cause
minimax mean multiple times as you can
see this cool occurs syntactically only
ones but it is in the head various
comprehension so it is probably a
multiplicity and behind it and mini max
max cause min max min and relaxing well
it's quite symmetrical relax max again
multiple times in the same have this
list comprehension so we should
recursion we have to detect this and we
have to show now that makes two to
restructure this sorts of function so we
have introduced mobile refactorings to
our system some of them are actually
quite generic others are really really
divide and conquer specific so like
transforming function closest to case
expressions or vice versa I think that's
a good thing to have it it's not only
good for 4 divide and conquer
refactorings but for many other purposes
then looping case branches oh that's
another story I think that's that button
makes sense and where else but
refactoring divide and conquer functions
bindings to list introducing list map
merge function definitions this is how
we try to solve mutually recursive
functions moving in mount expressions
from kays expressions so there are the
factors which you can probably imagine
i'm not going to present you all of them
now because you don't have that much
time before lunch before no dinner we
have already dinner okay so no I don't I
don't tell you all the details about
this well maybe I can show you a very
simple a few very simple example like
here we have the original definition of
mergesort and then we have function
closes with pattern matching and we can
turn it into a case expression very
easily so that's one simple
transformation it's trivial
transformation but all our
transformations are quite trivial quite
simple so you can see that they are they
are probably sounds while we have not
believed that they are sound not yet and
we need to find the proper PhD student
for that but yeah we have really high
confidence that they are sound another
interesting one we can group creates
branches as I said this is really really
specific to divide and conquer because
this is where I introduce the
distinction between them the base case
and the recursive case so here I have
the red branches and the blue revenge I
want to replace this single case
expression before case expressions for
case expressions first I would like to
separate the blue branches from the red
branches so the first one we'll just
have two or four depending on whether i
am in a red branch or blue branch and
then inside those two cases i will
introduce more cases so let me show you
the result so i have an expression which
computes valuer i am in a base case or
not so that's just computing a boolean
value and then i'm using this boolean
value in the second case expression then
I I have the two branch Villechaize
expression VD two branches with the
the base case branches and the second
last case expression covers now the
single recursive case if I have more
recursive cases than of course I have a
proper phase expression here this is a
you know kind of strange case expression
which can be reduced to inoculum to form
by it by just dropping the case
expression then we can introduce
function or eliminate function and
animates variables are not going through
all the details after a while we can
reuse the canonical form and now now we
can introduce the DC function in the
last step so that's that's how we
proceed with this simple example it's
very easy I'm not going to talk too much
about this mini max but the main idea as
i told you is to to collapse the two
functions the mutually recursive
function to one function and then you
can try to do the same tricks as with
the corrected version okay so let me go
to the conclusion I'm in favor of using
pattern based pluralism and of course we
need to as we need to us for everything
of course for paralyzing programs we
need even better to use them for others
so you need to which is able to discover
pattern candidates which is able to help
us to refactor the code without without
losing or changing the meaning of the
code by plying step by step refactoring
small refactorings small meaningfully
factoring so that the programmer can
keep them in mind until you reach to a
canonical form and then we can
restructure this canonical phone into
the use of a high order function there
are many many open questions here of
course we have not proved the
correctness of the small steps but this
should be relatively easily easy because
these are small of course we should find
out Combinator's to combine these small
steps into larger transformation the
compound transformations that's again
one interesting research idea where you
can use for instance a I methods to find
out which is the best combination of the
set and of course you can always
intervene with manual refactorings in
the process so if you can't do it with
the two of you can do it with
manufacturing I think that's combination
of to support it is factoring and manual
refactoring okay thank you very much and
if you are interested I can show you on
my computer how it works sometimes so I
have an implementation not all
transformations I can implement it yet
some of them are already implemented
already implemented and sometimes they
work perfectly sometimes I great of
course because this kind of Vita version
but but I'm ready to to show you if you
if you are interested thank you question
one question in what way you measure how
the refactoring you're told does and
improve the cult how do you measure this
improve improvement in this particular
case we don't measure how the code is
improved in this case we provide no
recipes for the programmer written
document that okay if you want to
introduce the divide and conquer
function and probably you should apply
these sorts of transformations in this
order or in other order but it depends
always on the programmer he looks at the
closure and see that yeah this should be
done since it's not it's not ultimate
eyes here at all here we need a smart
programmer who knows what to do you just
want to avoid copy and paste errors and
release all errors to be able to help
the programmer to perform the factoring
we don't tell him in the other dis
transformations to apply
extortion would you do with comments in
court why when you transfer making it
the right comments no we don't see like
comment and we are proud of our layout
preserving the factoring techniques so
the infrastructure behind our
refactoring engines is really smart it
takes care of lexical information and we
have nice algorithms on paper on how to
preserve layout but I don't know what
happens sometimes it really really
exposes I it tries to be so smart that
it in the end it is terrible yeah but
the main idea is not to too pretty print
with the standard pretty printer all the
time because in that way you lose lay
out the information and comments and all
interesting stuff instead they try to be
smart and preserve the layout the code
as much as possible it doesn't work
perfectly it works sometimes even
audience fashion how many users or our
application use cases you have a for
your tool can you say something about
well this particularly factoring we
don't have any users yet I hope you will
be the first one in general we have used
to in multiple domains if you have a
strong collaboration erickson hungry and
they used our code for various purposes
for for for discovering bugs for
restructuring modules in a big project
like millions of functions requesters in
a module in a system and some of our X
students who might work for Asian hungry
in the remaining small number of our
land based projects they do user to for
information sharing and
Cody investigation called the
comprehension I'm going to abuse my
position and ask you a question tell us
how do you do your approach compared
with atoms that we saw earlier what was
the difference between them and why is
your better do you think I'm not sure
and my approach is better than atoms
especially that one of the quarters as a
veteran is coming so yeah they are
equally good we have to we have to go
into details to see what what the ideas
with the ant unification are and how we
can apply and I think we have different
appears because you represent 30 grams
as grass recalls the semantic program
graph and we try to perform the
discovery process on these graphs using
graph searches and this is differently
the term based and unification
approaches of atoms but maybe we can
find balance between the two maybe we
can improve our search using that either</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>