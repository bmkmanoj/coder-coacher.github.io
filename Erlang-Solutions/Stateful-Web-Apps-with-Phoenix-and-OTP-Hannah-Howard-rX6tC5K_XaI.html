<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Stateful Web Apps with Phoenix and OTP - Hannah Howard | Coder Coacher - Coaching Coders</title><meta content="Stateful Web Apps with Phoenix and OTP - Hannah Howard - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Stateful Web Apps with Phoenix and OTP - Hannah Howard</b></h2><h5 class="post__date">2017-03-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/rX6tC5K_XaI" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yes working oh my god um this is great
because like you gave a great intro to
my jaw hahaha that's what we're talking
about we're talking about synergy wow
that's a fuzzy word okay
all right so this talk is called
stateful web applications right just a
brief intro to Who I am this and this is
actually it starts with a picture of me
that you might find on the Internet I
have this logo everywhere my name is
actually though Hannah Howard and I am a
programmer I'm not particularly somebody
of any note but I do know how to write
some web app did not create overlaying
not create or the actor model but uh but
that I know something about web
applications will tell you that that's
my email and that little handle at Tech
girl wonder is a me on the internet for
the most part including the Twitterverse
okay oh and sorry one more thing which
is wait oh I lost the slide oh well
there was another slide that said that I
it was like a personal anecdote about me
that had a really cute picture of my dog
so just imagine there's a cute dog and
then I actually like dogs and now you
feel comfortable with me because I'm a
human being
okay okay okay alright so this this is a
talk about elixir in Phoenix and it is
it is somewhat geared towards folks who
are switching languages away from one of
the other traditional web programming
languages such as Ruby or Python or
maybe even the PHP right um so that is
who it's sort of geared towards but big
caveat the goal is to give all of you
who are in that position a very
different perspective on why you want to
switch to this new language to this new
language right and there's like many
slides missing in here oh oh yeah well
what in any case I'm going to continue
onward I apologize I think I've got an
old hmm sorry can I just give me give me
one sec cuz I'm like missing serious
lies here and I didn't do anything and
this is
making me feel awkward okay what
happened to the other slide yeah okay
you know what I think that's remote see
there's the dog so you look at the duck
you know what what yeah no more no more
this fancy remote that time yeah that
was those a fool's errand to try to get
that okay yeah yeah so just this clock
is going to go in a lot of different
directions but generally a few things
that we are going to cover are first of
all why you why people put in those
other web worlds are now switching to
electron Phoenix why they're doing like
why they're doing it as it is and then
we're going to talk about in much more
broad terms about how you build web
applications how we traditionally built
them versus the kind of Erlang model for
building any kind of an application and
finally we're going to look at how you
can use the fundamentals of Erlang and
OTP to enhance web applications you
might write in elixir or Phoenix okay so
continuing on when I wrote this talk I
didn't check the speaker list first so I
didn't see that like Joe Armstrong was
on there and like all these folks who's
like I'm going to be talking about the
history of Erlang and the actor model
and I didn't imagine that those folks
would be in you know geographic
proximity when I was doing that so if
you're coming from the Erlang world you
just keep your mind open in this talk I
think you might learn something about
where I'm coming from and other folks
are coming from in the web world right
so just keep an open mind okay so let's
get into the meat of the talk which is
and start with essentially the
perspective I hear from a lot of folks
who are switching to a lick sir and
Phoenix right and I'm going to use a
specific example of Ruby because that's
kind of the biggest vector so this is
this is what I hear I hear somebody say
I want to use elixir and Phoenix because
it's just like Ruby on Rails but faster
right and that's that and and that's
kind of like it's like oh I just want
the things I always had but just a
little better right that's cool right
that's that's that's alright I mean the
lis
it is especially if you're coming from
like Ruby yeah elixir or Erlang is
generally faster because it's a compiled
language and it's you know it's going to
be faster but if you were to ask like if
your simple goal was I just want speed
right like and you're especially if
you're thinking in terms of like being
able to just execute a linear process
really quickly like you could do a lot
better than elixir in early you could be
I mean you could be and see if you are
really serious about like being
SuperDuper fast in terms of your
processing power right so um let's
rewind a bit and ask like why don't we
write our web servers and see because
dude then they'd be like super fast
right that'd be awesome you know well so
here's the thing right faster has a what
is faster in the context of a web a web
application or web server right it
actually has some very unique properties
right so faster in the context of a web
in the web server primarily means being
able to serve many people who are
visiting your website at once right so
you you know when you write a web server
your goal if you're you know
particularly you're in a start-up hoping
to grow is to eventually be serving you
know millions of people per day and be
getting all of these you know web
requests and your server has to
coordinate all those and essentially be
able to handle them without getting
bogged down so that's being able to in
some ways manage doing many things at
once we call that concurrency right um
so that that's a unique aspect to to how
how web applications work but there's
another aspect yeah so Web APIs I
apologize and that is and to answer that
let's rewind a little bit further and
ask ourselves a slightly more broad
question which is what is a web
application so web application is an
interesting thing right your goal in a
web application is you're actually like
running an application that serves
millions of people at once and the way
you do it is you use lots of computers
to do it right you don't just run a web
application on one computer even if you
only have one web server right your web
application has
server and then it has everyone else
who's viewing your website is using
their computer and they're using their
web browser to view your website if
you're delegating some of the work even
in a you know in an extreme case to the
users computer so you essentially every
web application is a application that
runs across lots of computers and
they're all connected through the
internet over a network right so there's
this computer science II term for that
and that's a distributed system the
distributive system is a program that
runs across many computers connected by
a network right so this is interesting
because there's a really important thing
about distributed systems they're hard
or probably they're not hard to ever
learn at this conference but they're
hard to like most people yeah yeah for
most folks are pretty hard they're hard
to think about they're hard to reason
about right and they have some really
unique challenging properties right so
the first one is that they have to be
able to scale meaning that if your your
program is you know using ten computers
to serve a hundred people eventually if
you're lucky you're going to be using a
thousand computers to serve you know
hopefully a billion people right well
here's the problem with that right you
might have this idea is it like okay
figure out how many people do I need to
serve and based on some constant number
I can just multiply that and get the
number of computers and servers I need
to run right and it will just grow
linearly well it doesn't really work
that way right actually what happens is
you're essentially as your users grow
you're a number of machines grows can
often grow geometrically I mean
exponentially or even geometrically or
it just doesn't work at all you get to a
point where no matter how many
conservers you add because the
coordination and essentially they they
end up all waiting for each other in
some fashion right you actually are not
able to serve more people no matter how
many machines you have so that's the
problem of scalability so there's one
more big problem right and that is how
do you manage state so to answer that
question I want to rewind one more time
and I want to ask a pretty pretty almost
philosophical question which is
to state okay so so state is like I use
it probably every day in my job as a
programmer very rarely do I stop and
think about the actual definition even
though I kind of have it in the back of
my head so I want to give you a quote
that will hopefully illustrate the
nature of state okay and this quote is
is from a book okay so the quote reads
all that you touch you change all that
you change changes you the only lasting
truth is change and God is changed so
that's from a book by someone named
Octavia Butler in a book called the
parable of the sower which this may be
the moment in the top where you're like
what topic I just come to this is
getting a little existential I'm going
to bail but I want to I want to like try
to illustrate why use that quote right
so I'm going to define a staple
application as an application that
essentially the way you interact with
that application changes as your
interactions influence the internal
condition of the application so
essentially as you change the
application the application changes in
the way and that results in different
ways of interacting with it right and so
we take we call that internal change in
condition of the application that is
what we call state state is the internal
condition of an application right so
there's a bummer thing about state as
well which is that managing it kind of
sucks
a managing state is really difficult
particularly if you let it get spread
out over just sort of like over the
coast over all around your code base
because becomes really hard to track and
really hard to like figure out like
who's modifying it in any given time so
almost all the solutions that have to do
with managing state have to do with kind
of like isolating the state manage of
the the sort of storage and changing of
state in two different parts of your
application it's becoming more and more
of a thing in the web world I even
originally had a slide about how state
is like very passe these days in the web
world even though obviously it's
necessary but some but so that's so it's
kind of hard
and then it gets extra hard when you are
talking about a distributed system right
managing state a distributed system is
really different well now give you a
good example of why you could argue that
managing to the state and the
distributed system is why marriages fail
the state of the marriage is spread out
across to people and they're constantly
trying to sync up their state right but
unless they've got really good
communication then they're going to get
super far out of sync and then you know
things are going to go poorly okay so
that's bet state let's talk about what
the rest is talking about right so we
have defined distributed system as
essentially we define distributed
systems as these difficult things to
build and so what I'm going to talk
about for the rest is talk is two great
models of distributed systems that are
concurrent that scale well and that
managed state well okay so the first
distributed system I'm going to talk
about it says what we've always done and
that would be what we've always done if
you're a web programmer some of you may
have another thing you've always done
and you make you'll you stay tuned you
will get your turn
so anyway so there's what we've always
done right and and and this is the thing
in a lot of web programmers don't even
know that we have this system right
they're kind of working within it so
it's like a system you may not be aware
but when I illustrate kind of the
constraints of it you may understand
that a little bit more clearly about how
it works right and this is um this is
something you've used if you've done any
kind of traditional web framework type
programming Ruby on Rails Python and
Django PHP and whatever people are using
these days in PHP so the first
constraint of the system is HTTP right
so HTTP they say it is a stateless
protocol and what that means
specifically is that essentially when
your server gets an HTTP request from
some browsers somewhere it actually
doesn't know anything doesn't have any
information about what that browser is
actually doing other than what is
contained in the HTTP request so it
knows nothing about the browser and
meanwhile the browser really knows
nothing about what the server is doing
and other than what gets sent back when
once the server processes the request it
sends back a response right so there's
really there's essentially no knowledge
about the other the other party so we
say that protocol is stateless there's
another part that we make stateless in a
traditional web application and that's
the server code itself right sometimes
we actually call like this model
stateless web applications what we
really mean is the application code of
your server it's essentially stateless
in the sense that when you get a request
in from a client you do stuff you
process that request you might set some
in some variables you might put some
stuff in memory and then you produce a
response and then once you're done
everything that you have that you put in
memory all of the state you've created
gets thrown out for the next web request
so each rubb request it's like your code
has no persistent state of any of its
own right well so obviously you still
have to have state in order to like
write you know cool web applications so
we have a solution for how we manage the
state anybody you like have a guess as
to what that pollution is wait I heard
in the back say louder the database yes
yeah so like basically like the big
solution is we're going to punt on state
we're going to hand it off to these
relational databases which to be fair
are really good at managing state right
on the whole they've been around for a
long time and they've gotten really good
at managing state there's one other part
that one other thing we use to manage
state that's the little this little
add-on to HTTP which is a unique call it
a cookie essentially a little bit that
you send back and forth in the in the
actual request response cycle and that
and the cookie usually contains some
unique information about the person
viewing the webpage namely who is
viewing the web page because that's
often very important to be able to
provide a unique experience based on the
user who's logged in right so those are
those are kind of the state solutions
and then the concurrency solution
essentially is to delegate to the
operating system right the idea is if I
need to process two web web requests at
once I'm going to you know and I'm
writing a Ruby on Rails application I'm
going to
not to ruby processes and you know and
then they'll just class you know when
the requests come in no process and
we'll hand it off to the operating
system to figure out who's going to run
it at any given time because operating
systems they're actually really really
good at switching between processes
right it's something they've gotten good
over several decades so anyway yes so
that's that's great and it works because
our server code is stateless you can run
them both at the same time and just rely
on the operating system to handle it one
other thing that we tend to do in this
model is when we need to do something
that lasts beyond the request response
cycle we'll use some sort of mechanism
to create some kind of a background job
in Ruby you might have used something
called psych hit a rescue so that's
that's another sort of tricks that we
use and then the law you know the great
benefit of all this is that you know
with all these things in place you can
scale your server to a large extent
because your server code is completely
stateless you're getting stateless
requests and so you if you need to serve
more clients you spin up more processes
on your machine and then when you run
out of processing power on that machine
you just spin up another machine and add
more processes right and that's great
but there's a bottleneck in all this
anybody know what that bottle nut might
be the database again yeah so there's
this problem right because you're
throwing everything everybody has to go
to the database so eventually you're
going to max out the database and then
there's a bajillion so so solutions to
try to deal with that you know database
sharding you know all kinds of people
have you know people have a whole job
title based on this the database
you know DBAs yeah yeah so because this
is such an important part of the
application there's one other kind of
like bottleneck in this which is it's
not particularly good for real-time
stuff you're tied into this request
response cycle and anytime you need any
state your server has to make like a
round trip out to the database which is
technically actually a network call even
though it's often on the same machine on
so it is not super fast so yeah so
that's so that's another constraint
right and I would argue that
all of this system which is pretty well
architected has an underlying constraint
right that it's so much hidden and that
is it's all set up to run for a
traditional programming language right
so traditional programming language you
essentially your program you know your
program boots up reads the first you
know instruction of code and it goes and
executes them sequentially and it might
jump around because it might have a loop
in it or might split off on one path but
it's essentially one one interpreter
moving linearly to the end of the
program you have a couple of soar
workarounds that operating systems
provide in most languages supports which
is threads right if you want to try to
run two things at once within the same
process but they're generally extremely
difficult to work with because your each
thread they share memory which means
that you all kinds of problems come up
I'll just sort of keep it is that right
okay
so that brings us so that is the model
for web programming right
so then there's this other model which I
realize in retrospect could also be
titled what we've always done and that
is the Erlang VM and OTP right so this
is a totally separate model and again
there may be some stuff that I'm coming
up on that sometimes are very some of
your line guys are when guys and gals is
yeah this is old hat right but just stay
with me right so let's talk about the
Erlang VM and OTP this is particularly
targeted towards those of you guys who
are really hard basically web
programmers right okay so to talk about
this we have to rewind a bit and go back
to the 1980s and and so this is before
the web even existed right sir well I
mean you know there was a research paper
probably at some points but for the most
part there is no world wide web right
and and so you know the telephone
company ericsson again this is like all
based on the assumption that the people
involved in this are not going to be
sitting in the room and that might be
cheesy
so okay so there's a telephone company
cook
there's cellphone company called
Ericsson and they had this problem which
is we've got lots of telephone switches
I'm sorry we've got a huge telephone
network and there's all these little
routers that
the telephone calls all around and we
need them to work and we need them to
run really well and not fail and also be
able to route all the telephone calls so
it's a distributed system right you know
it's a program that runs over lots of
boxes and and and so their solution was
we're going to write a new programming
language right and that program is that
is really well suited to this problem
and the basis the very underlying basis
of that programming language is this
thing called the after pattern right
so after pattern is a new model for
building computer programs right so you
know it's an alternate model to
object-oriented programming or
procedural programming and the way the
active pattern works is essentially an
apps and applications is built out of
several actors right and you can think
of these actors as like little units of
code similar to the way you might use
objects within an object-oriented
programming language and actors are but
the thing that's unique is actors are
completely separate from each other so
your program is made up of all these
independent actors that know nothing
about the state of the other actors but
what they can do is they can send
messages back and forth right between
the different actors right so I can I I
may not know what you're doing but I can
send you a message asking you to do
something right another thing that's
really unique about this is that the
message passing is not it's not
synchronous when you send a message
you're essentially giving up control and
the other you know after may process it
immediately they may not we actually
pass messages if you've done
object-oriented programming we pass
messages quite a bit but you may not
even be aware that you're doing it
because the way you pass a message in
most object-oriented programming
language is you call a method meaning
you expect that code to run immediately
right so it's not it's not like that in
the after pattern you send messages
who knows when they'll get processed
right you essentially give up that
control right and the one guarantee that
you get is that from the standpoint of
the person processing incoming messages
they're going to receive those messages
in the same order
they're going to receive the one that
was sent first first and the one that
was sent
you know last last right it's actually
somewhat similar if you just think of it
as an email system right there's there's
a lot of similarities right your your
inbox you know if I send you an email
that's the point at which I'm giving up
control and saying I hope that person
likes me enough to respond to my email
right so so it's a similar type of thing
right and arguably this theme came up
once before which is it like the after
pattern if you look at it and you look
at the early sort of like
object-oriented programming theory like
in some ways it's it's closer to what
the original folks who define
object-oriented programming we're
talking about and there's lots of snarky
remarks that go along with this but I
don't have the quote on this well in
this presentation look at some of your
other speakers for that okay yeah so
that's that's kind of the model but how
does it all work right and that and the
way it all works is with the Erlang
virtual machine which is platform on
which all of your problems your programs
run and it has this thing called a
scheduler and the scheduler is the thing
that is responsible for figuring out how
all these actors are going to run in
what order they're going to run right
and switching between them right because
essentially your program is no longer
like a program it's a whole bunch of
programs that are just wanting to do
their own thing right so you have to
have something to kind of like manage
between them and essentially the way the
scheduler and Erlang works is it's very
similar to the way your operating system
works switching between programs so in
Erlang the word that we use for actor is
just a process right because it is each
actor is like its own computer program
right in many ways and then the thing
that coordinates all those is the
scheduler but to do but before we get
into that I wanted to a quick digression
into the difference between pre-emptive
and cooperative scheduling I find this
particularly interesting just because
I've been around long enough since when
this was an issue in operating systems
but there's two different ways you can
manage multiple programs at once and and
one is called pre-emptive scheduling the
other is called cooperative scheduling
the best metaphor that I have for this
is if you think if you ever
like walked into a classroom that with
like small kids and a teacher who really
has no control over the classroom right
the kids are just doing what they want
that's like very similar to cooperative
scheduling right the model of
cooperative scheduling is basically like
a process of doing its thing and when
it's like I think I'm done now it's like
hey operating said you can switch to
someone else right so the court the
operating system is dependent on the
program giving up control pre-emptive
scheduling is if you've ever seen a
classroom where the teacher is in
control and they're like no you're not
talking now that one's talking right now
right now they can even interrupt you
like while you're talking right because
they've established that kind of like
very like intense control so in a
pre-emptive scheduling model the
operating system can actually just
interrupt the running program at any
point do I stop I'm going to do
something else right so that is and not
actually that evolution is something
that happened over the course of 20
years in the world of operating systems
right so why replicate it within the
virtual machine of Erlang well you can
actually get some great advantages by
doing this and not just delegating the
operating system the problem with
operating system processes is that they
take a while to make and then they pick
up a lot of memory once they exist if
you have ever used a chrome and Chrome
is famous for running each of its tabs
in separate processes and you keep
adding tabs on to the point where you
have 50 tabs open at once and not to say
that I do this a lot but I do do this a
lot and then and basically what happens
at that point is your computer grinds to
a halt
right because you've used up all the
memory on your computer because each
process takes a lot now chrome also is
just terrible in terms of not managing
memory but that's a different issue
versus in Erlang in the Erlang VM you
can create a process almost
instantaneously and it takes a very very
little memory so it's not uncommon
usually as a tech demo to spin up like a
hundred thousand processes in Erlang and
show that you can do it in a second in
the memory of your computer is not like
completely consumed right so that is why
to do that now interestingly this is not
what not the first attempt you could
argue at a kind of scheduling in a
programming language so I've all top
which is what programming language out
there that probably everyone who's done
web programming has used implements what
I would argue as a form of cooperative
scheduling anyone node
well yeah the language yes yeah
JavaScript right so JavaScript they call
it an event a synchronous event loop
because it sounds really cool but what
they really mean is that when the per
way that your program does it sting and
then when it's when it's like gets to a
stopping point it hands back over
control these are the browser or to the
node platform to essentially do whatever
has to happen next in this sort of
asynchronous event loop and if you're
lucky if you're into like the like you
know whose framework is better fights in
inevitably someone in not that's a
valuable pursuit but just just to say
like it traditionally the way that like
the elixir person busts out like this is
how we win this is if you do a you set
up a web endpoint that essentially in
the middle of that web the request
response cycle you put a five-second
sweep and then you make could sleep as a
blocking call and then you make a
hundred requests to that web to that
endpoint and you'll find that in
JavaScript it'll in a node platform that
will take about 500 seconds because once
that once your code is processing the
request nothing else can happen versus
if you look at but if you do the same
thing in an elixir or Erlang platform
the you know as soon as you sweep the
sket the scheduler just going to like i
think i'm going to switch to someone
else because other people are waiting so
so that's that's a great that's that's
really a great advantage of the sort of
preemptive model there's one other
advantage if anyone in here old enough
to have used Windows 3.1 or like a Mac
OS seven Mac OS 8 yes lots of people I
was I did this question in LA like a you
know a young little hit people web
meetup so uh there were a lot left hands
anyway so anyway but you know so I use
these and these days you use your
Microsoft Word and you're like you know
you're going along and then like it
shuts down you get this unexpected error
or a program quit you might have lost
your work you're like super pissed off
right but just to say you've actually
got a good because it
remember what might happen if that
happened like back in the days of
Windows 3:1 or like math ah what's that
what's that what's that mean yes your
whole computer goes down you don't close
the little like quit window you reach
down you touch the power button to
restart your whole computer because
that's where you're at basically if
you're a cooperative scheduling and
you're your you know program truly locks
up then you can essentially prevent the
operating system from ever taking
control again so yeah so those those are
those sort of like really fundamental
parts of of the sort of Erlang model and
I want to talk just briefly about how
early and some additional stuff the
Erlang does to manage states right so um
Erlang is a it's a function you know
it's a functional language I imagine
everyone here it's like pretty
up-to-date on this stuff but and so that
so essentially nothing is you know your
state can't get mutated you can't change
little parts of it you have to
essentially copy it and create new
versions but because prophecies are
essentially they can run for as long as
they want they can have their own
internal space and even though you can't
mutate state you can essentially mutate
it by having loops of functions that do
some processing and then produce a new
value for state and then just feed it
back in right so those are the so you
can actually that you kind of have all
the building blocks right there but you
could use maybe a little bit more help
right and so Erlang gives you the OTP
which I described is a standard library
on steroids right it's essentially like
if you use any programming language it
has like some libraries that are built
in usually to deal with like math
functions or string functions and but
Erlang does lots of that maybe a little
bit less on the strings but like B it
does uh but it gives you some really
cool tools to work with concurrent
programs and in distributed systems and
to manage state within that so what
means what these are is really all they
are is a few patterns that developed
over the course of like twenty years of
folks programming and Erlang some of the
folks did that programming might be in
the room but in any case then over the
course of twenty years building these
programs out of these really
building blocks they notice some really
cute patterns for how you can manage
states in a process and how you can you
know manage data in a distributed system
right um and so essentially they codify
those patterns into these little
abstractions that you can work within
right if it were to be marketed in the
future it would probably the marketing
slogan would be something along the line
of will supply the abstractions you just
write your own custom apps
implementation within it right so I'm
going to talk very briefly about what
those abstractions are this is not like
a let's dive into OTP talk so I just
want to give you a sense of them if
you've never touched them before and and
I'm going to and essentially these these
abstractions we call them behaviors and
they're essentially ways of writing
processes that handle state and I want
to talk mostly about one particular one
which is kind of a building block one
that a lot of people use more than any
voice well I don't want to save more
than other all the others ground I'm
programmed enough oh yeah
so so there's a thing called the Jen
server and a gem server is a process
that Kate did it's a model for a process
of maintain state over time right so
it's a process of running it has
internal state and there's basically two
things you can do to it you can send it
a message saying essentially like
sending a message and say I want to
report you you do what you want and then
I want to reply back on the results or
you can send it a message up and
essentially give up on on knowing what
there was the results are you can send
in a message and say you do whatever you
want to do with this and I won't I don't
really care what the results are the
middle of that is almost like sending a
command to the gem server right so then
the gem server itself essentially to
implement it you just have to implement
two different functions right and those
functions the first ones called handle
call and as the name might suggest this
is essentially to handle when someone
sends you a message expecting a reply so
yeah this is so we call that a call and
the call essentially gets three you get
three things in it gets the it gets the
message that was sent to you it gets an
ID for the person who sent it and it
gets the sort of current
state of the oh my goodness I'm sorry I
have to pause because I realized that I
do not have this plugged in and it's
about to run out of power and that would
be awkward okay
sorry for the delay I thought this was
pumpkin yes any any power cables it
works with a MagSafe - yes no sorry
apologies yes I covered took a a
40-minute trip to Best Buy to get that
adapter that didn't work but I did not
plug my computer and so I don't know
what that counts for yes thank you sorry
what
yes yeah I'm like a process I can go
down I get them right back up in fact
let's get going yeah we're back up right
somewhere there's a supervisor watching
over us it's like a philosophical
supervisor
I got like 10 minutes right 10 minutes
like before I'm a bad person who's going
over the limit okay all right
core core core yeah been especially
annoying okay so anyway so the end so
you got the message who sent it and the
current state of this gem server as the
third parameter to your hand will call
and basically inside the function you do
whatever processing you want to do and
then you send back you essentially send
out back this object we call a tuple
with three different properties one is
the type of the replies that you're
sending its usual essentially the status
right which is usually either something
along the line of reply or error and
then you can send back any kind of
additional data to the person who sent
the message to give them more
information about your gem server you
could even send the entire state of the
gem server back if you wanted to and
then lastly you send back as a third
parameter a new state or the gen server
and then when it loops around again
essentially that third parameter the
next time you get a handle call this
current state will be whatever you
returned the last time you ran that you
ran the handle call function or the
other one which is handle cast right
handle cast is essentially the same
pattern but simpler because you do not
have to deal with the reply so you just
get a message in the current state you
send back a type of reply which is
really usually just no reply unless
there's an error and a new state for the
gem server so um yeah so state so the
cool thing is with all this state can
kind of persist in a gem server as long
as it's running there's no limitation I
mean this is totally separate from a web
request response cycle so we can live
around for as long as you like but
there's probably there's a question that
probably comes up which is like what if
it crashes what if something goes wrong
that causes the process to crash well
essentially Erlang gives you one
additional behavior that's a special one
and that is this behavior called a
supervisor and the supervisors basic job
is to manage the other the other
behaviors and restart them if necessary
right
and so supervisor you essentially when
you create it you just give it a list of
the little workers it's going to manage
and then you give it a strategy for how
it's going to restart those workers if
they go down or if they just end right
um supervisors themselves can actually
have children which are supervisors so
your application ends up consisting of
essentially a tree made up of a
supervisor at the top potentially more
supervisors as children and eventually
down to a bunch of weed leaf nodes which
are the actual workers right just a
caveat about this this is not
necessarily solve the problem of
recovering State and it's probably
important to think about if you want to
start throwing lots of states in your in
your gem servers and you expect them to
last indefinitely there are one other
nice thing about OTPs it does give you
these tools that are specifically great
for this type of fit it gives you
actually two databases right there's a
really simple one an in-memory database
called Erlang turn search and there's a
more kind of like traditional but really
well built for distributing a
distributed system across many computers
called amnesia and yeah and so you can
actually use those too you know in a
worst case scenario save the state as
the process goes down and provide it
when it spins back up and essentially
keep it around indefinitely there's lots
of other tools not anything about I
think I'm just going to go through this
because I actually do want to end on
time and but like static code analysis
like you're you there's all kinds of
crazy tools in the OTP
I don't even I forget it okay so yeah
there's like like I said it's a standard
library on steroids
but anyway we now finally come back to
the original question right which is
what we started to talk with why would
you use elixir and Phoenix what our
elixir and Phoenix in the context of
this earth sort of Erlang ecosystem
right well elixir um hopefully this
slide won't be too controversial you
could describe a Luxor is essentially
like the marketing slogan would be to
the young to be well not young but to
the essentially
to those who've gotten accustomed to
like web conveniences like a package
manager and a specific type of syntax
that that people are usually it's kind
of somewhat shared between Ruby and
Python and all the other web languages
well so you could say that you know
essentially elixir is Erlang updated for
the web generation right so then what
about what it will so what's Phoenix
right well so Phoenix is a web framework
that is built on top of a lick sir and
the Erlang VM so it's a web framework
built on top of this really crazy
amazing distributed system model of the
Erlang beyond that we've been talking
about right now
if Phoenix had a marketing model it
would be like basically the same new
language same patterns you love it would
place like you you come to a new
language and you already have like the
Matt Damon of the language it's really
reliable you already know it really well
and you can just keep programming the
way you've always programmed if you're a
web programmer right you can use the
tools like HTTP in relational databases
and all your stateless you know all your
request handling can be stateless right
it's wonderful right but you could
easily miss something and this is the
heart of the top and this is
particularly directed towards your web
to the web programmers right and that is
that's not all you have you have this
immense toolset with amazing powers
right you've been ignoring it for so
long but you know you never know what
could happen well yeah it's just got a
lot of power in any case so it's really
amazing because like what is better than
one great distributed system model is
like two great distributed system models
right so let's like what that's great
okay well in the abstract it's great but
we in reality we're actually entering a
really interesting uncharted territory
right this is getting back to like my
intro which is like synergy right this
is like is it I don't know if there's
ever really been a time when these two
giants sort of like distributed system
models have come together to sort of see
what happens right so the question then
becomes like how do you mix them how do
you mix a standard web distributed
system within it with the kind of Erlang
model so
couple of answers couple of these this
is a little bit on the speculative side
these are my own answers to some extent
so first of all if you're using Phoenix
you're doing it already even though you
may not know it right Phoenix under the
hood is built upon a couple of
prophecies and you know essentially the
Erlang model particularly in this case
you're actually using it quite a bit if
you're using any of the fancy new
features and Phoenix there's um you know
this new thing called channels for doing
WebSocket based communication there's
another thing called presence for like
tracking you know a state across like
multiple systems and over time and all
those things are completely built upon
OTP primitives right there's another
answer which is like you could do the
things that you might be doing in
another language like super easily right
there is no reason to kick off to have
like a background job process for in
Erlang because you already have one the
gen server it's much simpler it's much
easier do you really need to do a
background job you can just essentially
spin up a you can spin up a gen server
to handle that right or there's even
simpler abstractions within the elixir
right the well sure answer is I'm not
100% sure but here are some life ideas
some thoughts of like ways you could do
this right first of all if you're doing
something real-time maybe you let go of
the database for it right if you're
tracking state that changes rapidly over
time and isn't really that permanent
there's no need to use a database so
actually going to give an example from
this this thing that we're doing in LA
with the LA elixir meetup we've been
building a group project together to
essentially simply simulate the werewolf
game it's like a party game right and
ours are ideas we're going to build like
this server that people can log into
enjoying game rooms and then within the
game room though essentially in real
time you'll start a game and all the
players will be updated and they'll take
turns and all that stuff right so
interestingly we are not we are storing
one thing in the database which is the
game rooms existence themselves right
we're throwing a list of game rooms
because game rooms are going to last
forever but the game itself once you
start the game it's it's completely
within a gen
the process including which players have
joined that game room and as it happened
you know essentially evidences happening
and I think it's an interesting model it
seems to work well so in that case the
game itself is a very real-time thing
versus the examining thing is the
existence of these game rooms so that's
an interesting way to divide it up
another another rule is like if you're
taking something like database e that
has to still have to be distributed
across multiple computers and scale
maybe like this is your opportunity to
step out of the relational database
framework right obviously I've already
mentioned that there are databases
database tools included within OTP there
is also like this other giant
independent database solution called
react which I believe there was a talk
on earlier that's you know really
amazing for storing a highly distributed
system across you know lots a cross lots
of computers right you might also want
to consider other solutions like Mongo
but you might also not want to because
why would anyone use Mongo anyways so
yeah so so that's possible rule number
two possible rule number three this is
just another idea which is like you've
got this great like in-memory store way
of tracking things use it as a cache for
your database right like if you're going
to read something from a database lots
of times right and it's one big table
you're just reading in and out of like
you can actually create an in-memory
store as a way of essentially being an
intermediary and then you only go out to
the database when you haven't read it
before now there's obviously you know
cache and cache invalidation it's not
always an easy thing to deal with but
you know that's that's what it's a good
it's something you could do right a one
other thing that actually is a yeah oh
sorry there's actually this one you get
the link and you actually if you visit
this presentation online that's a link
to an article about how you would
actually implement this another another
thing that was interesting someone in in
LA came up with this really crazy cool
mixing of the database in OTP right and
what they were doing and so my this rule
would be like essentially use databases
what should for what they're good for
which is like crud type operations in a
web server and then
use OTP for everything else so what they
did is essentially they were building a
build system tracker to track builds as
they were half the jobs of a some kind
of program as there were as they were
going and they would essentially kick
off a build and write an entry to the
database but then they would use an OT
gen server and actually a backhoe some
other things to do all of the tracking
of that task and then updating it in
real time right so there's this it was a
really interesting solution that's also
a link to that one other thing you can
look into is using OTP to do stuff in
the web you've never done before so one
of the amazing things that Erlang offers
is the ability to deploy parts of your
code without taking down your entire
program so look into it so you're out
how you can do that within your web
application so I'm going to get to two
final cardinal rules which is the wind
outlined down of this talk of I know
where we're about it time and and
basically the cardinal rules are these
right if you are coming to this world
from the wet as you're coming to Alex
and Phoenix from the web programming
world or and you don't know that much
about OTP or if you're one of the folks
who's like coming here and you know OTP
but you know this whole web thing seems
pretty weird new go ahead and spend some
time to learn the other model right
don't just stay within your lane explore
what's possible and then the other
cardinal rule number two which is number
two is one see of a familiarity with
both like be creative try come up with
new solutions this is actually a really
wide open world and we're all going to
discover new rules right when I started
this talk I intended to answer this
question which was probably indicative
of an intense amount of overconfidence
and but as is but I'm comfortable not
answering it because I'm really only now
understanding what is possible and what
this problem is right and so I think in
it as it turns out we're all going to
have to figure this out together
right and so in closing I'll just say
good luck and you're going to need it
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>