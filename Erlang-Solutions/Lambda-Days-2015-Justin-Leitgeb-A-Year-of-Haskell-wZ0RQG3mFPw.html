<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2015 - Justin Leitgeb -  A Year of Haskell | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2015 - Justin Leitgeb -  A Year of Haskell - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2015 - Justin Leitgeb -  A Year of Haskell</b></h2><h5 class="post__date">2015-05-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/wZ0RQG3mFPw" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">can everyone hear me yes is this better
yeah okay so this is I didn't realize
when I was coming in here today that I
was I was stepping into the the grape
chute out of pure purely functional
statically typed languages but this is a
good set of topics to be close together
with a discussion on oh camel and
Haskell so before I get started I'd like
to ask you how many of you are working
with something like Co Campbell or
Haskell right now basically those those
two languages so we have a few people
it's great how many people are working
with other functional languages of
different types like Scala closure
Erlang sorry I feel like it committed a
great sin here by not mentioning early
that's that's great so how many people
are frustrated imperative programmers
and other languages JavaScript Ruby
Python so there's there's quite a
contingent of discontents in the room as
well and so I think that this probe the
stock is relevant to two people from a
lot of different backgrounds I started
thinking about this maybe a couple of
years ago and when I initially started
using Haskell and I wrote a blog post
about he actually lost exactly a year
ago about how we're how I'd like to be
using more Haskell and it was pretty
well received and but at that point we
weren't really doing much Haskell in our
company I run a consultancy called stock
builders and I'll get a little more into
the kinds of projects that we do in a
moment but we were mostly doing Ruby
projects in fact almost 100 percent of
our projects were in something like Ruby
combined with JavaScript of course and a
little bit of closure on the side as
well but we embarked on on this this
journey of starting to switch the
organization more to
school and and that was about a year ago
when when our company had twenty five
Ruby developers and we've changed quite
a bit since then now we have about
twenty Ruby developers and five to six
people doing Haskell full-time and I
think that's a great change I think it's
been very much success
and I wanted to talk a little bit about
how we how we did that and and how we've
been able to transition some of our
projects to Haskell
so how many people know about how many
developers there are in the world
anybody want to take a guess
five million it's good guess why ahead
20 developers the rest are just amateur
happy for 20 million good so these are
these are pretty good guesses there are
11 million professional developers
somewhere around there and maybe another
seven and a half million or so hobbyists
and how about how many Haskell
developers in the world well I can I can
tell you there are about five or six in
Ecuador we have our office I I think I
don't really have any good numbers on
this I've been talking with some people
at other consultancies that do some
haskell work and we think that you know
maybe around a thousand professional
haskell developers and maybe that's even
optimistic so not very many people doing
Haskell right now maybe we're talking
about like one point zero one percent of
all developers doing something like that
if we added in the ocala people then
maybe there's like point zero zero one
five or something I don't know not not a
huge not a huge community but we like to
change this and and this is part of what
this talk is about in in the end I was
joking a moment ago about this being the
the great statically typed language
shootout and but I think that in many
ways it doesn't really matter so much to
me I think that I would like to see
people change more towards languages
like like Haskell or like oh camel but
in the end I think that you know it's a
positive direction in general and
and whatever happens you know if has to
died out tomorrow then I'd probably
happily switch to a camel but I think
that uh so so going into a little more
about hostels popularity it's not it's
not kind of a distribution of just
Haskell programmers all over the world
there are places where there are more
Haskell programmers than other and I
think that in the city that I'm from
originally and the city where we started
our consultancy in New York it's
actually a pretty vibrant Haskell
community and a pretty vibrant community
for purely functional statically typed
languages in general and when I talk to
people from San Francisco in in Silicon
Valley a lot of the time they say hey
you know I wish I was in New York
because they have more more of an FP
community at least in in Haskell and ml
tradition and so I'm very lucky to have
been from the city where we've got you
know 60 80 people at a Haskell meetup
and and so that's a that's a very strong
community on on the other on the other
hand you've got I was I was meaning to
switch the slides before so let's talk a
little bit about about why we would use
why we would be as Haskell and and this
is what I'm gonna talk about in this
presentation first of all why we would
use Haskell over things like Ruby and
I'm going to give you some case studies
of what we're doing with Haskell and I'm
going to talk about some of the good
aspects and some of the bad aspects
apostille and then also how are we
selling Haskell and I think that a
particle reviewing a software developers
even though it might not be our favorite
role is how to how to sell languages
like Haskell and how to sell things like
processes and then I'm going to talk
about the future what we're doing and
and what high school is doing so a
little bit more about our company so you
have slightly more context we started in
New York and number
from western New York a place that
probably has similar cold and snow - to
Poland at certain times of the year we
started our consultancy and in New York
City and and then I moved with my wife
to taquito which is in Ecuador and in
South America right along the equator
we're about 10 minutes 15 minutes south
of the equator and this is one of the
the views that we have from my office
sometimes of cotopaxi volcano so it's
one of the highest active volcanoes on
the way in the world not our head no
we're we're not we're not located on the
volcano but yeah it's about 5,000 897
meters and even though it's on the
equator it's it's a snow-capped all year
because of the the altitude and so as I
mentioned there there were no hospital
programmers in the entire country before
we started and so I think that this is
what's that well no they do have several
academic programs in computer science
they tend to be quite applied and
focusing on on development tools you
know especially Windows platform tools
things like Java and Eclipse but they
have a decent enough amount of theory
and another background to be able to
pick up Haskell and I think that this is
a really interesting case study for
adopting Haskell because you don't need
to you know have these these academic
programs that emphasize category theory
and everything to be able to grow
productive Haskell programmers but I'll
talk a little bit about that in in a
moment
so what are the kinds of projects that
we do we we essentially have medium to
large scale web-based systems and this
puts us in even more of a distinctive
position with respect to languages like
Haskell and ml in that most people who
seem to be using these languages at
least to me are doing things that are
you know computationally intensive AI
things data processing things and what
are we doing all day I mean we're
basically just talking to a pis and and
so you know this puts us in
and rather a select group of people
using Haskell and I think that even
though we're in a relatively small niche
it's actually a language that really
helps us out a lot so we're doing
systems currently in Haskell that are
related to real estate so kinds of
content management type systems where
we're doing systems that are related to
finance and to banking
especially for for clients in New York
so that tends to be a popular industry
there but it's not something that you
need Haskell for you know it's something
that we're basically building systems
that are kind of like what you would do
in Ruby on Rails so I want to I want to
spend a little bit of time justifying
why we're making this kind of change and
and I think that I should say a couple
of words about what what I was doing
professionally before this after college
I started doing web programming and even
though I kind of had a background in in
Java I started doing work in input in
Perl and at that time there are a lot of
people doing web applications in Perl so
I picked it up to to escape some of the
boilerplate code and and that kind of
stuff and in Java and and I got jobs
doing a professional Perl development
and this is a picture of has anybody
read this book when I started doing web
development in the late 90s this is a
Phillip Green spawn and he wrote a book
on on web publishing kind of earlier on
and have a lot of cool pictures it was a
you know kind of an introductory guide
but it had a lot of interesting pictures
and that was kind of at a time where you
know web sites were talking about oh you
know it doesn't just have to be static
it can be database backed and all that
kind of stuff
and I think that things have changed
quite a bit since then you know then
maybe you kind of scraped by on doing
things in in Perl but as we've really
started to scale out Software Systems
there have been more pressure points so
I went from doing Brill programming to
doing Ruby programming and I started
doing that about seven or eight years
ago and you know I had a good run of
several projects there but in many ways
a lot of those experiences directly led
me into looking for something that would
be more maintainable so will some of the
good stuff about
about parole as I said there was less
boilerplate you know you could have a
couple of API endpoints or whatever or
web pages that were all backed by
individual Perl scripts and you know
that kind of worked out okay for for
really simple systems and you know Perl
is has changed since then but you know
back then I lost track of the number of
projects they would come onto and you
know you would learn about the object
relational mapper that people were using
in fact you would learn about the
object-oriented programming system you
know since like inevitably if somebody
on the team rolled a row no appeal layer
you know and you kind of had to figure
out the the nuances of that and
hopefully the guy is still on the team
but if not you've got a whole other set
of problems and you know the same kind
of thing with interactions with the
database you know everybody's kind of
writing their their own interfaces for
that but it got a little bit worse and
into things like this I don't know if
anybody here is seeing this before but
this is a valid Perl program that prints
out 99 bottles of beer on the wall what
you can tell that just by looking at it
yeah it is it is so this is this is kind
of the Perl version of isomorphic
programming you know people talk about
that with I don't know they wanted this
to make it represent the fact that who's
gonna print out 99 bottles of beer on
the wall so try it out and it actually
runs I think I did it once about 10
years ago so you know Ruby like like
Perl had some had some good things going
for it and it still does you know coming
from a Perl community where everybody is
kind of rolling their their own oh yeah
I think that's been resolved to a good
extent by five standard libraries that
people are using
but in Ruby you you approach the the
language with with okie already built in
you know it was pretty consistent you
knew how to do things like inheritance
and and all that kind of stuff and it
worked pretty well unlike Perl it didn't
have quite so much
so many special characters and and so it
didn't lend itself as immediately to
things like obfuscated code contest that
were popular in certain parts of the the
Perl community and and you have a
culture that's really really obsessed
with best practices and and I think that
this is a really important part of Ruby
and as something that cultures and
communities like Haskell can actually
adopt from Ruby to but I'll get into
that in a minute
now the it's also got some bad parts and
this is a transformer and so everybody
here who's into functional programming
knows that things like mutation can can
lead to programs that are more difficult
to maintain and and this is certainly
the case with with Ruby in many ways
Ruby takes the ability to mutate things
to an absurd level how many people have
have programmed in in Ruby here okay so
quite a few people and and so you know
about the the types of things that you
can do you can not only mutate variables
that you initially set up as as
constants right the ones you explicitly
say and kind of put in a part of the
code where they shouldn't be changed
usually you can mess around with those
things but you can also mess around with
classes right so you can say you know
one moment this class has these
functions and then a couple minutes
later like it lost one function it
gained three others and you know all
this all those other sort of stuff is
happening and and this actually occurs
you know you would think that nobody
would ever use this I've actually been
on projects where you know you you get a
an exception and it says oh that method
isn't defined on that class I'm like
well it's getting defined over here well
it's only defined you know halfway
through running your program in the
course of loading a web page and then
you know somebody goes in and
dynamically add some method and the the
presenter gara this morning was talking
about you know these moments where you
kind of want to slap another developer
and i don't think that you should do
that but i think in these cases that you
can just sit back and watch while the
developer slaps themselves right
but all that kind of stuff is is
possible and and done and in Ruby and of
course this makes for really really
unreadable programs in many ways I was I
was tweeting about this a while ago I
think that Ruby is the language that
perhaps embraces post modernity the most
so in a post modern social theory and
philosophy what I mean by this is that
people philosophers talk about fluid
boundaries they talk about identities
that are able to shift and and these
things are really useful for talking
about things like race and gender and
things related to personal identity and
Ruby it's kind of okay with all of that
you know it kind of tries to model the
the postmodern world and you know it's
it's it gets pretty pretty crazy at
times the the fundamental fact is that
in in systems of software where we're
really writing things that modules and
components that communicate with each
other you need to have some basis for
for stable communication you know you
you can't just depend on sending
messages down the pipe and and something
else receiving it if you've got this
other thing that is changing shape in
the middle you know it'd be like on my
my ride to my taxi ride to the
conference center this morning and I
don't speak any spell any polish I can
get by and in Spanish and I speak
English as well of course but um I you
know it's a safety net I had a map of
how to get to the University on my
iPhone and the kind of stuff that Ruby
does would be like you know I'm trying
to communicate with this taxi driver who
only knows polish and I hand my iPhone
to the driver and in the middle of
handing the phone to him it turns into a
turtle or something you know so this is
the the kind of development that the
Ruby allows you to do so you know
there's a quote from this I don't know
if you know the the country singer Kris
Kristofferson he's not a programmer he's
got
like like some program list but he's a
country singer and he said freedom's
just another word for nothing left to
lose right and the the incredible amount
of freedom that comes from with
languages like like Ruby also come with
a huge amount of need for constraints
and discipline right and I think that
you know that this this quote really
captures some of the the problems there
and so this is the the idea of Ruby on
Rails that you have a language where
there's there's only the the essential
and you know you've got a kind of a
declarative syntax you know it's almost
functional in some ways for for
constructing a web application but due
to things like immutability
and also the fact that usually just the
crud operations you know the database
operations your application those aren't
really the most difficult part about
what you're doing you know you really
want to focus on this business domain
that's going to take a different shape
anyway so in in a sense things like Ruby
on Rails you know they've got these blog
posts with like the 20 minute the 20
minute rels web blog that you can make
and that kind of stuff and it seems like
you're really productive off the bat but
what they're really doing is kind of
making the simple things easy right but
that's the stuff that's that's already
simple in the application so we you know
it's helpful it's good to get to what
you're doing but beyond that there's
there's still a lot more that can be
done so this is this is kind of a more
similar to what we what we encounter
sometimes in rails applications and you
know it's not that that dream of
simplicity and and the clear railway but
you have a lot of focus on on the in
essential you know by by stripping away
things like types assertions that the
compiler can make if you don't come into
a project with a huge amount of
discipline then this is sort of what you
end up with and and so what do we do to
prevent this well I looked up some
statistics on one of our projects
and this is a project that doesn't have
much of a website it's it's got
primarily we're looking at a back-end
the communication with a lot of api's
and we have eight thousand lines of code
regular production code and 23 thousand
lines of tests and and this is actually
something that isn't that unheard of you
know having a one - in this case a 122.8
test ratio have you guys seen that on
projects like that yeah I think there
are quite a few and you know I think the
testing is a great thing and I think
that Haskell needs to do more of it in
the community and there's been
discussion about adding more tests to
popular programs in Haskell but you know
when the the idea behind testing and and
what people experience in testing will
will tell you is that you you should
only test what you're worried about you
know tests can become a liability as
well as NASA at code base and the wrong
kind of testing or were too much testing
can lead you down a path where the the
code isn't more easy to change but it's
much more difficult to change and this
is a heck of a hard task you know the
the talk the keynote that I'm sure a lot
of you are in this morning Mike Garrett
talked a lot about patterns and and how
we try really hard you know programmers
spend years learning these patterns
reading the Gang of Four book and and a
lot of that work is because you have
languages that that don't impose very
much structure on you they let you get
away with a lot of things so you need to
manually apply a lot of patterns and
practices to try to resolve that tension
and I also don't think that we should go
overboard of patterns and I think
everybody's been on on projects as we
said this morning where people did go to
the world of patterns but people go
overboard with with testing this way too
and and so in this sense you know
everybody thinks of Ruby as being this
really really simple web programming
language I think it's actually
incredibly difficult and in in my
experience after working with it for
four seven or eight years I wouldn't
really trust a programmer
who's new to Ruby on a project by
themselves for at least a few years and
until they've gotten that much
experience you know after having cleaned
up so many messes and thrown out so many
code bases where where people didn't
have the experience to really do this
you know it's it's an incredibly
difficult thing to do so now we're back
to Haskell because based on on this
perspective I really think that Haskell
isn't the the tough language to learn
you know people say that Oh Haskell is
is difficult to learn and you've got to
be a math genius to use it I actually
think it's a lot easier than Ruby and
and I think that's that's very much the
experience that we have as a as a
company as well so things the Haskell
does right are that there's there's been
a lot of work done on distilling the
core concepts and abstractions in the
language and I'm not going to go into a
lot of these in significant detail but
things like the type system and the way
that you start thinking about problems
in that way really solve the the problem
of this this postmodern ruby programming
language right you know you're not just
sort of hacking stuff together and
saying okay you know I'm in the repple
and you know I've got this function that
talks to this function and kind of
shaping things as you go you start out
with a set of basic assumptions through
the type system and you say okay this is
the way that something is and I'm not
going to change that right now and and
by starting with those basic things that
that allow your community your program
to work together you don't have a lot of
the same problem so you have been in
more dynamic languages in my experience
so this has really been working out very
well for us in the last year and and
I'll give you a few examples of the
projects that we've taken on so the
first project that we took on outside of
some internal training exercises was a
project we did for a client in finance
and Equador and I think this is I'm
pretty sure this is the first
professional software project and
Haskell it was written in Ecuador and it
actually went great we we started this
application that basically takes in some
some data from different
and and mash this it up a bit
and show some pretty graphs and most of
the about half of the work was in the
back end and we used the the Haskell web
programming framework snap which you
might have heard of and that works great
the front end we used amber and amber is
is probably familiar to a lot of you who
have experience with with web
development it's basically a
model-view-controller framework for the
the front-end of web sites and the kind
of does for the you know the increasing
complexity on on javascript application
to a trellis and similar frameworks do
for the backend and so this might be
kind of interesting decision you know
using this purely functional language on
the backend but using something that is
more more like rails on the front-end it
actually worked out okay for us it
helped us to keep development velocity
up we were using something that was
really supported by the community and it
was it was kind of a good trade-off and
a good point of division in the project
to make sure that you know we had
developers who were comfortable enough
with working on it while they were
getting some of the the backend exposure
and Haskell that we needed so we we
surely picked up another another project
and this one is done for a client with
an existing code base and I think this
is perhaps even even more interesting in
that you know we were we were stepping
into we have had lots of situations
where he stepped into legacy Ruby
projects and one thing that that kept
happening to me is I would pick up Ruby
topics is that you know the the client
comes to me and he says hey I've got
this code base in Ruby I want to add on
features you know it's got to talk to
Facebook and you know read read from
Twitter or something like that and
usually things a little more complicated
than that too and he'll give you the
code base and I'll say well you know
it's gonna take us at least a few weeks
of working on this to set up the best
practices to start setting up a test
suite you know to sort of continuous
integrations so that we've got the the
build happening and then being deployed
out to the server automatically and and
there are other cases where the the
client comes out this is why
something that you know is more or less
complex and we've we've said no we're
not going to do it and you know we're
we're consultancy that does pretty well
with business coming in and so luckily
we can afford to do that but I'm sure
that you've been in situations to where
you've had a code base dumped on you and
you've said I have no idea how quickly I
can start developing on this right if
ever and so we had a lot of projects in
in Ruby where we would just tell the
client no you know we can't really give
you any kind of prediction on this we
probably could rewrite it you know that
that would be actually quicker than
going in and acting on this code this
because we just don't have any
confidence that we can deliver features
in a timely manner so this project was
was very interesting because it was
actually coming from a team of
Electrical and Mechanical Engineers who
didn't have a ton of experience in
software and there were really smart
guys they taught themselves Haskell and
but the code base didn't effing eat us
you know it didn't have continuous
integration setup and you know so I was
little bit skeptical at first but it
turns out that our developers were able
to pick up working on this project and
and be productive the first week which
is something that I never would have
anticipated in Ruby
you know they were able to look at the
application they learned about the
domain from the type so we're defined
and they tried breaking stuff and and
seeing what compiled you know it's kind
of a group horse approach but I really
think that you know this is the the kind
of project that didn't adhere to all the
best practices that if we had received
in Ruby we might have been like well you
know we don't really want to take this
one on right now good luck with it so so
Haskell really had a very tangible
effect on on this project this was done
half by a developer in New York who had
a lot of experience with Haskell and
also partially with with developers in
Ecuador we have a couple of developers
of Ecuador now who came from Java
backgrounds fresh mountain university
and within a few months you know they
were they were very productive and
including at applications like this one
we recently started as well on an
internal product and and this is to gain
some more experience in Haskell to keep
trying new techniques you know maybe
play around with with some front-end
components and we're reusing on our main
stockholders website we're using hackage
which is a web programming framework and
on most new products we're using snap
and and in some of the internal projects
we're also thinking of experimenting
with Elm but I'll mention that in in a
moment the other web framework that I
should have mentioned a moment ago is
yes ode and you Lua tries to be more
like browse that has like all the
batteries included and the the one
external client project that I mentioned
is is using a Soviet and then that's
been working really well to the the
author is really prolific and in the
hospital community Michael Simon and
he's really produced a lot of great
libraries so what are what are some of
the good parts about Haskell it's really
stable it's been around for 25 years
it's an older language in that sense
it's got the pretty active community
hospitals started early on with a large
community and started out with them all
relatively early so from what I've heard
I think that Oh camel took longer to
formulate a common pattern for
contributing libraries and the fact that
Haskell to bed early really helped out
and so now we've got about almost a
thousand packages I think or something
like that on half-baked when I was
looking and they're rapidly increasing
cabal and hackage worked pretty well for
for package management now this is still
quite a bit less than something like
node I I looked in a node this morning
and there were I think a hundred twenty
eight thousand packages so you know
you've got these communities with with
all this stuff and all of these
batteries and food and frameworks and
Haskell isn't quite there yet
and I think that's something that will
continue to improve but at the moment
it's it's not it hasn't been a huge
barrier to have a lack of a lack of
libraries Haskell is really getting
better too so there there are things
like cabal and the the previous speaker
was mentioning you know how cabal and in
Haskell was perhaps more more developed
than things in the oak animal community
and I think that's true and but it also
has this pain points a lot of people
when they they talk about the difficult
parts of Haskell do talk about the
tooling and how you know you try to
install dependencies and all of a sudden
it's saying you know max back jumps
reach or something like that and it
couldn't work out the dependencies
internally that stuff has really
improved a lot over even over the last
year or so
Cabala ended the notion of sandboxes
where you can basically install the
dependencies per project and that's been
a huge help the and you know as with any
other one of these community is this
open source so if you don't like it you
can jump in there and start fixing
yourself and this is actually something
that I did with with cabal recently I
looked at the issue Crocker for cabal
and it had almost 700 open issues and so
there's obviously no no deficit of
places to start working and I just went
from the the back all the way back to
2008 or so and and started picking off
some of these issues and many of them
weren't even related to ticket ball it's
related to hackage or some other project
and just nobody had bothered to clean
them up so you know I started doing that
and then shortly after the really cool
thing is that other people in the cabal
at Haskell community started doing the
same thing you know other people sort of
picking up hold tickets and cleaning it
up so you've really got a great
community of people involved in Haskell
and committed to making it better and I
think that's really a lot to me to be
said about about Haskell because in the
end this is a quote from
my friend Michael Bernstein he said I
wish we could all acknowledge that
Haskell is kind of a boring language and
and so this is boring in the good sense
Michael likes Haskell and I think that
you know in in many ways we want to
language this foreign language is a
stable a language where you know we can
go in and usually things just work and
that's really the case with with things
like COBOL you know with the language
itself and we just happen at a whole lot
of surprises which is fantastic we've
been very productive in it so let's go
on to the selling Haskell and these are
my my two kids down in Ecuador they have
a festival that's called carnival like I
have in Brazil and it's basically a
bunch of kids like spraying each other
with this the silly string this this
foam kind of stuff and so you know we
haven't had all successes in selling
hassle we've approached some clients and
they basically just said no so there
there was one large client that we had
and we had a part of the system that was
that was pretty easily able to be
decoupled and we said hey we'd like to
use Haskell for this and we actually
wrote a prototype on our own time in a
couple of days turned out to be like 100
times faster asleep in the Ruby version
it was clear to read you know kind of
the stuff that we expected worked out
great went back to him and they said
look we've got 500 c-sharp and Java
programmers and nobody knows Haskell and
so no and you know this wasn't totally
unexpected it was it was pretty
disappointing but you know this is
something that we do all all face and in
trying to push our our favorite
languages forward so you know what what
do we do to get around this we tried a
bunch of different approaches you know
we we set a bunch of things and I'll
kind of share some of the the selling
points that we used but at the end it
wasn't it wasn't effective and and
they're not gonna go with it you know
turns out not only do they have dotnet
and and Java programmers but nobody's
even doing f-sharp so we didn't even
have that going for us so we just got
permission denied and tried try B using
the you know the pseudo use Haskell
which which in this case meant going
back to our own internal projects of
some of the Haskell developers and
giving up on that front and planning on
trying again later so how do we sell
Haskell and I think this is this can be
applied to other languages too you know
whether you're trying to sell Erlang
trying to sell languages like oh camel I
there are a few things that I have tried
to pick up here and one of those is that
I think that a lot of people come out
and they say well Haskell was just safer
I don't know if that's necessarily the
right selling point and a lot of cases
because people think of safety and they
say oh that means you're gonna be really
slow right and and that's not the
message that we want to convey it is
safer in many ways but but really the
reason we use that is that it's more
productive right
you know we get immediate feedback from
the types we figure out exactly where
something is calling something with the
wrong arguments or the wrong type so
that's why it's great you know safety is
cool too but that's not the only thing
and it's it's not just for geniuses some
people say that Haskell is really hard
to learn actually I think it's for
programmers like me programmers who make
mistakes right if you've ever made a bug
you know that caused some kind of a bug
in in a program you know that's Haskell
really excels it doesn't just excel for
the geniuses and the people who can
teach themselves 10 languages in a week
it excels for everybody else who makes
mistakes like a normal human what about
maintenance issues this is something
else that a lot of people will mention
and I think that a in Haskell you know
they might say well you know who's going
to take care of this application after
you leave and I think there are a lot of
strong points that can be made that
Haskell is perhaps actually easier to
hire for than Ruby you know at least in
communities like New York City a lot of
the best developers have left
communities like the Ruby community and
recently we haven't had a lot of luck
hiring for Ruby programmers in contrast
I think there are lots of people who are
really passionate enthusiastic about
about learning things like Haskell and
and as I've said too it's not even that
hard to pick up to begin to be
productive
so I think that sales is is part of all
of our jobs in software you might not
like this and and perhaps you even went
to the University in engineering to
avoid doing sales that might have been
one of the reasons that I did it
initially as well but in in the projects
that I've been on in the course of my
career you know what happens you get
onto a new project with a client they
give you the 200 page specifications
expect you to go off and build it so you
have to convince them to use agile
they've convinced them to use a
reasonable process you know they want to
use COBOL or they want to keep
maintaining this legacy system in Ruby
that doesn't have any TAS and you have
to convince them to to build in a
different way so I think that we can all
become better at doing this and and we
can create more effective systems if we
better some of these skills so there's
there's a book by Robert aldini and and
I think that it's actually a pretty good
sales book if you're interested in
getting better at this because like I
said this is this is about software too
and he states a bunch of principles that
I won't go into in detail due to lack of
time but things like reciprocity you
know totally till the client hey you
know maybe we don't want to go in this
direction but let me try doing some some
haskell development for a couple of days
in my own time if you give somebody
something there's a very good chance
that they're gonna reciprocate and and
do a favor for you so maybe you'll just
get Haskell or Oro camel or lying on the
door that way
committing to Haskell N and saying
you're going to go through with it or
anything else is is really useful social
proof so saying hey you know there there
actually is a community of you know
people doing Haskell it's actually big
in New York and a lot of financial
institutions being likable and
presenting yourself well coming from
from authority this actually isn't a
problem for Haskell so I don't know if I
would recommend using this I mean
they're already tons of academics you
talk about it all the time which is good
but I don't know if we need more clarity
in a lot of cases or scarcity this this
is my personal favorite you know with
languages like C sharp Java adding
lambdas see look you know we're almost
out of lambdas you gotta get to use
Haskell all the top so
let's let's go on to the future and then
I'd like to open this up for a
discussion - there's lots of cool stuff
going on in Haskell and pure strongly
typed functional languages for the
front-end - and even though we've been
using things like ember they're really
cool frameworks like Elm which is a
functional reactive programming
framework for the front end and pure
script and ultra also GHC Jas so this is
an example of Elm
and if you haven't played with it you
really should go out give it a try
you can type right into the browser you
get immediate feedback so this is a
Mario game that simulates gravity and
all that kind of stuff and it's
functional reactive programming so it's
actually pretty you know it's
declarative you basically put all these
events input events through a foal and
go over and modify those so this is a
game that my kids like playing and when
they get a little bit older I'd like to
teach them how to do some programming in
it as well there are things like pure
script as well which I haven't used but
that seems promising - and in the same
kind of pain and finally you can just
use Haskell and this is a newer project
called GHC Jas but basically it's a fork
of COBOL right now that'll probably be
integrated into the main COBOL repo soon
and basically all of all the prelude
compiles most Haskell programmers just
compile unless you you're using some
like native extensions and you can you
can start using it and go to hear your
program so there's certainly some
limitations but it's it's a very
promising direction so finally a since
this is we had a head of this slide
while I was listening to the previous
talk and not - not sure if you thought I
think that Oh Campbell and Haskell are
both great languages I know we're
probably used oh camel if we didn't have
Haskell but there's I think that you
know some people mentioned things like
syntax extensions in Haskell and how
things change based on which ones your
brain man I don't think those are
necessary to be productive and also done
wrong with them so I don't think that's
something that you should be scared
about I think that you know it's got
great support for concurrency in control
doc and Cara I was
to be productive in writing simple
concurrent programs in Haskell in a
couple of hours after I already had
experienced the language and that just
seems really elegant simple to me
they've got things like Google and hi
you where you know unlike the the
scenario where you go into the clues
your IRC room and say hey what function
does this you just type in a signature
that you want into one of these tools
and it tells you what functions line up
with it
it's got cabal which is pretty good
package management even though it s some
rough edges it's already there and it
works in a lot of cases things like
quick check and one of my personal
favorites is H stack so this is kind of
like rubies r-spec and and similar
syntax s and other languages really
elegant you can just make a describe
block and it block and then you found
essentially would our unit tests with
just a little bit more syntactic and
concise syntax and so in each pack is
really nice smelters Auto discovery of
specs which is useful and finally it's
supported in Travis this made it is this
one thing that is got up on oak ammo at
least for the moment you can just type
in the language GHC and then it works
for a P different PhD version it's like
seven four seven six and seven eight and
pretty soon seven ten which is coming
out and and I think that you know it
actually seems like Oh Pam and in
Campbell is catching up really quickly
to haskell so i don't know how much of a
difference this is anymore but you know
cabal has been around for a while and
there are lots and lots of packages so i
think that in the end that future is
really bright you know there's a lot of
stuff that we can do with with haskell
who can be productive today but i think
that this isn't all just about teaching
people haskell and using haskell i I
think that the important thing is that
we continue to experiment as software
developers we have a responsibility not
just to write systems for our clients
reliably and and in a way that we
deliver them and they'll work but also
to push the industry forward so even if
you're using something that isn't the
most popular if you feel like it's gonna
help make better software then let's
push it out there and Haskell is ready
to use today
so that's that's all that I have I don't
know if we have a minute for
yeah yeah it does I I wouldn't I we
haven't done closure script we've done
some closure back end
I really like the statically typed
direction since I think they have a lot
of benefits but I would agree that GHC
jss is not there yet if you really want
to give something like that in the in
the front end you're probably better off
whistling like yeah well to tell you the
truth I think that cabal hell has has
gotten quite a bit cooler it's it's not
quite as it's not quite as bad anymore
with things like COBOL sandboxes you
have to start by using a cabal sandbox
which is an isolated set dependencies
for every project and once you do that I
don't think it's so bad
deployment we have a couple of different
approaches that we use there's there's a
really hacky cabal program or a really
hacky Asheville program that I wrote
called Capistrano which is based it's
pretty bad code if anybody else wants to
take it and fix it up let me know but
it's out there on hackage and and
basically does the same thing as
Capistrano since the code out there does
the dependency install since
installation can take quite a while it
just does a symlink at the end and
points to the new app so you know pretty
simple you can also do the same in a
timeline bash script which we do on some
projects do we have Macs and Linux a
mixin in the environment there's one
more thing there there there's also a
package this supposed to be really cool
by this guy named me tech named Halcyon
and I haven't tried
they're supposed to be really
sophisticated Nicole so just a shout out
to this package that I would suggest
people try to show me so if I could it's
kind of a skill you know I think that's
a good question I mean I don't want to
start a religious war I think that you
know we can get better we can do a lot
better than Ruby and I think that even
though Ruby can do better than Ruby
you know because Ruby is doing things
like adding gradual typing perhaps you
know or at least the the author is
talking about that I think that Scala is
probably more maintainable in some ways
and it's got its own complexities to I
think the Haskell is pretty elegant
pretty simple as far as I know they
never added a an object-oriented system
that's the stuck on top of it you know
so you kind of got like one one paradigm
there that their works and and it seems
to work pretty well but you know I think
Scala is good too but I encourage you to
take a look at we've got this pick thing
in the office called the the fireplace
where you toss people into it no we
there are some books that I think a lot
of people use there's learning a school
for great good real-world Haskell which
is a little bit dated some people who
are really into Haskell learning like on
the the Haskell beginners IRC Channel
recommend a different set of resources
but there's lots of good stuff online
that also brings me into kind of the
musical language pretty quickly
but I think just a real-world experience
you know like I said most people are are
productive in a few months coming from
Java and they get that way not just by
reading both by being tossed into the
fire
well if glass use possible but what
these developers do then because I have
not know their important piece of box
five I'm sorry yeah yeah yeah yeah what
are we gonna do I mean I think we're
gonna have an unemployment crisis so at
this point the the largest applications
we have in production are Ruby ones
where we've got you know clusters of ten
or twenty servers doing different things
the Haskell applications that we have
are more monolithic kind of just you
know sound a little web apps using yes
Oh d'Or using snap and you know but
honestly we're we're Ruby programmers so
if we're going to hassle it's already a
hundred times faster so usually we're
not that many problems with things like
scale so we haven't we haven't had a lot
of a lot of scaling Haskell problems
we've been really happy with the
efficiency as an immediate and pretty
much free speed up into the runtime</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>