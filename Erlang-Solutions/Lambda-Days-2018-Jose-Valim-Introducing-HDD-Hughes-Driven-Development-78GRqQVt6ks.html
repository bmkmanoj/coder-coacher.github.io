<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2018 - José Valim- Introducing HDD: Hughes Driven Development | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2018 - José Valim- Introducing HDD: Hughes Driven Development - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2018 - José Valim- Introducing HDD: Hughes Driven Development</b></h2><h5 class="post__date">2018-04-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/78GRqQVt6ks" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">all right good morning everybody so this
talk is introducing hdt it's a play on
words with TDD test-driven development
and similar kinds of things as we will
see they are we have been continuously
improving galaxy programming language
and two of the major features that are
coming in the next selector releases the
word inspired and improved on the exact
continuation of work done by John humans
which is actually here and the event he
gave a keynote presentation last year as
well okay so it's a player words in the
sense that you know a lot of people say
Oh operating trance driven development
we write the test first and here
the joke is that if you want to have a
new feature your programming language
you wait you wait for John Hughes to
write a paper about it and then you add
it to the programming language and
everyone can enjoy better programming
languages at the end of the day alright
so before I get into the talk per se I
wanted to talk a little bit about Alex
see where we are right now and what we
expected the future give a little bit of
context so we just released a new area
this year we released Alex 0.6 and we're
really proud because we crossed the 700
contributors mark we are the active
system could use to grow we are almost
reaching 6,000 packages and over 175
million downloads and we and we have a
lot of exciting features but the big
feature that came then 0.6 also a very
controversial one is the code formatter
right so what is the idea of a code
formatter is that it formats code ok so
here's some code it doesn't matter what
this code does but what matters is that
this code is inconsistent sometimes you
know people add spaces after comma
sometimes they don't sometimes they add
the X from the line sometimes they do
not so the idea of a code formatter is
that we are going to get an input file
and we are going to discard almost all
of the
that is in there and we're going to put
it with very consistent style a
consistent format ignoring almost
everything that you wrote in terms of
style
okay instruments of format so that's
there it's released you can use it today
in your edited project and our
experience with it has been really great
so far we're going to talk more about it
soon and our goal also is in alec 0.7 so
releases every six months so the next
release is going to be like 0.7 it's
likely going to be in July this year and
we don't know how many contributors we
have we don't know what is going to be
the state of the ecosystem but we know
that one of the features that we want to
have in Alec 0.7 is the addition of
something that we call with stream data
and the stream data has two
responsibilities it's okay so the first
one that it has is that is of data
generation so Alex Siri we have
something called strings which are lazy
collections right so you can generate
anything lazily the idea of stream data
is ever going to get the same concept of
lazy generation okay and apply to the
data types that we have in a language so
for example here in this code which I
hope you're seeing it yes so here in
this code we part this from data mojo
now have something like an integer
generator that can generate random
strange lazily and infinitely okay so we
say hey give me ten and then I can get
the same integer generator and ask for
more ten and then it goes and goes ten
more okay
and they one of the reasons why we have
data generation want to have this from
data generation in the next year it's
because it will allow us to add property
based testing okay so here for example
we are going to explore what is property
based testing throughout the talk okay
but the idea here is that instead of
coming up with examples for testing our
functions or testing our software we
rewrite properties and let those
properties generate the different
examples so we are thinking now or
nothing about how this code should
behave under this particular code
example but we are thinking about the
general property that
cold should emit okay and and the reason
why I said introducing HDD it's exactly
because those two ideas the code
formatter and properly based testing
it's built on papers and on ideas
introduced by John Hughes which is
sitting right here
thank you for coming John and and John
is Welsh right yes I got it and he is a
professor at Chalmers University and
what we are going to do for the talk
today is that we are going to exactly
see how those two features the code
formatter and the stream data they are
implemented and I'm going to talk a
little bit you know about the papers and
introduce them and how those ideas they
change it and we're developing for all
time okay so let's start with the code
formatter so what is a code formatter we
know that a code formatter formats are
called the ecosystem style and the goal
is the code formatter
is to help you focus on what matters who
here has participated in a style
discussion in a code base please write
almost everyone have had such a
discussion right which way is better
okay
and we have been able to ultimate eyes
those things to certain extent so we
have things like linkers that will check
if your perk quest you know if you are
being consistent if you're being
consistent if you're adding in space
after the comma if you're not adding
extra lines so we have to so check for
that but why is the computer telling us
right what to do and why doesn't it go
and solve the problem for us right well
if I'm not supposed to use to space if
I'm supposed to use one space after
comma why it doesn't do that for me so
that's the go to the code formatter and
the thing that enables imagine for
example you are in the project you said
the perk is send a prayer quest and then
there is a link there that review your
code and you know in a place it says
well the line length here is 82
characters but you've configured to be
80 right and then you have another
comment that says well the cyclomatic
complexity of this function is high you
should refactor it which one would you
like to go to tackle first right
about the complexity that's why we want
to focus on so the code formatter
eliminates a bunch of those issues okay
we can just focus on the cold pile is
packed and not about this style per se
and it's a very good tool for newcomers
because when you're joining a new team
when you are learning a new programming
language one of the things that you want
to do is well I want to write this code
as everybody the company does or I want
to write this code like everybody in the
community does so usually have a friend
you have a co-worker or you get somebody
else repository and you try to replicate
that style right but that's a slow
feedback cycle which therefore matter
when you are learning you just run a
command in your anchor for example and
you get that feedback immediately oh
that's how the code should look like
fantastic and we wanted to unify the
code written by teams in the community
right that's the other goal so just as
an example right add an extra community
has pretty much any other community we
have style guides which is a very long
document that says how you should style
code okay and for a long time people
asked it for us to add for example a
style guide to that if your project but
I never liked the idea because I don't
like the idea of imagine that someone
wants to contribute to the language for
the first time I don't like the idea of
say hey read this document with a
thousand lines before you send your
contribution okay with a thousand lines
of text before you even think about
sending your contribution right that's
not very welcoming okay so now that we
have the code formatter one of the
things that I did is that I picked up
one of those style guides and I set up
requests showing all the rules that we
don't have to worry about now that we
have a code formatter and we reduce the
the style guide size to half right so
now you don't need to worry about any of
those rules when you're writing the code
when you're reviewing the code and so on
the code formatting the elixir is built
on top of three principles okay so the
first one is that it does not change the
code Thanks okay and that's because well
if the formatter can break our code or
change your code you're not going to
trust it and then you're not going to
run it so it's room right it doesn't fit
its purpose we also want to minimize
configuration
because we provide a tool that has a
bunch of configuration instead of people
now by chatting over this tile they are
going to back shadow for the
configuration
oh this configuration is better than
this one look how this code is better
right and then we're not going to be
productive and no special cases alex
theory was designed to be an extensible
language so we don't want to have a -
that knows constructs that are part of
the language right so we don't want to
add those specialties need to be general
rules for everybody is the same concept
that we apply for the compiler even Paul
when we are building electrics in the
library we have direct access to the
compiler we don't like anything special
cases in the compiler because it means
that the tools that we have to create
the language they are no longer
available for everybody and we don't
like that right we want the tool that we
use to create the language to be
available to everybody and that's why we
are able to write a lot of that experien
alex here itself so how do you use the
formatter
okay I imagine your soul so how do you
use that in Alex here you just run mix
format but usually you have integration
with our editor that's going to run mix
format for you okay so what is so what
is the ideal which probably are trying
to solve here so let's talk a little bit
about implementation so imagine we have
this code or even this data structure
memory okay so it's the list here where
we have the a key and the value for the
a key is another list with three
elements and then we have the B key
which the atom okay as value there right
now imagine that we want to render this
code or rather the state structure and
we have a line length maximal here of 25
practice so a maximum of 25 columns
because this cold fits there we can just
render it inline right we just render it
straight however what happens if you
have only 20 columns right it doesn't
fit anymore okay so now we need to break
it we need to render it like this so we
need to break it apart now break over
multiple lines well and what happens if
now have only ten columns right we need
to break it again right and you're going
to render it like this at the other day
sure if you break if you make it smaller
than at some point it's not going to fit
and they're going to go over the
the the line links that you have
specified but assume have reasonable
space we can break the document over
multiple lines and have exceed that
limit okay so to soup allow us to do
that with really something that we call
document algebra which is an idea that
was introduced by this paper from John
Hughes which is called the design of a
printing printing library and what I
really like about this paper is that at
the beginning it does not only present
the idea is that the question that makes
the beginning is well we have a problem
which is pretty printing how can we
tackle writing a pretty printing library
using a functional language using a
functional concept what are the basic
functions the basic types that we need
to have to express that and that's how
so it's a very elegant way of
approaching the problem and solving that
problem and coming up with the
properties that we expect when we derive
the functions and types that we have in
our code right so the idea is that so
for example if we have a data type or if
you have some code they don't want to
format it we are going to break into a
bunch of documents and I'm going to show
the documents that we have and here
there it's a regulation from the paper
to how we implemented those things in
annex here okay so we have a couple
documents so the first document is the
text document itself which is a string
that is going to be rendered as they
string itself
okay so text and then we want to have a
nesting document which says well I have
this document and if this document by
any chance there is a line breaking it
we want to nest everything after the
line break okay by the number of spaces
by the number of columns and then we
have the line document that introduces a
new line between two other documents
okay we have the concat document that
concatenate two documents and then we
have the empty document okay so how we
are going to render our data structures
using those constructs so for example
imagine that we have a list 1 2 3 and we
want to render everything in the same
line what do we do so we first start
with the opening bracket document and
then we are going to concatenate
the first element of the list which this
case is one which the comma and then the
second the third fourth fifth if we had
it okay and then we do the last one we
skip the comma and then we put the final
concatenation with the closing bracket
okay well so that's one way to render
this document but we know that we also
want to sometimes have the same list and
which don't have enough space we want to
render it like things we want to have a
line between each of these elements in
the list right so how are we to write
that so very similar construct we start
with the opening bracket and then we
introduce a line between the bracket and
the first element the second and so on
and then after we add the last element
remember that we want to mask everything
we have so far all those lines break the
elements we have so far we want to last
it by two elements so we have a last
call here right before the last line
okay and then we have the last line and
we introduce the closing bracket okay so
all right now we know how to print this
disco day structure in two different
ways but then it comes the question
right how we're going to choose between
layouts because we don't want to choose
at the front if it's this way or the
other way right we want to be able to do
that as we are rendering the document
and we know how much space we have left
okay and if we look at this those
documents they are similar but there are
some differences right so for example in
this one when everything is in the
single line we don't have a nesting okay
but well if we have a line breaks then
we need to consider the nesting so we
need to come up with the properties that
are going to allow us to render those
documents similarly and express those
documents in a similar way and the idea
here so one of the property that we can
think is that well for a document that
there there that has no line breaks we
could actually call nest okay because
you know if you have no line breaks nest
is not going to do anything it doesn't
matter doesn't make any difference and
when we do that those documents they
become closer to each other right the
difference here is that one calls
Coquette and the others calls line okay
it
and when we do chose to implement these
to answer this question of how we're
going to choose which document to render
the state of the art at the time was
outlined in a paper by Philip water
called a prettier pink printer and I
don't know if it was Philip the first
one who started too so we have a bunch
of papers about printing printing and
with eventually they started to have
only very smart childlike very smart
titles like a prettier printer sticker
printer so it's also a very distant part
of the company the whole development of
prairie printers but the idea of a
prettier printer was it provided a way
to solve this problem that was more
performant and requiring less code than
the previous solutions at the time and
so the idea of how we get flexible
layout and how implemented it in Alex
initially is that if you have a list and
that list can be rendered in a single
line or broken apart we would say that
it is a group right so say hey we have
this group of things that they are
they're either breaking apart and
rendered of multiple lines or they are
rendered all together and how would
implement group would be with a function
similar to this and that's how implement
it initially would have choose that
would be able to choose which format
okay and we say well I'm going to
receive a document and I have to choose
between three two documents one of those
documents is when I get all the lines
right all the line documents that
construct and we place it back on
catenation which means I have a document
that may break over multiple lines right
but I take off the lines and use a
direct concatenation so that's what a
document that I'm trying to use and the
other one is the document itself we've
all of the lines okay so basically we
need to choose between those two
documents if the first one fits in a
line completely okay then we are going
to choose that but if it doesn't then
we're going to use the other right so
what we do is that we wait to pass to
the group function we're going to pass
the second document the one on the right
side right and it's going to convert to
the first the first document by
replacing all lines but to concatenation
and then it's going to choose that
because if it fits on the on the current
space that we have left or not okay and
that's how implement it so someone set
up
it has been almost five years ago okay
because when we started doing this
analysis it was not for fermenting cold
it was for pretty pretty data structures
okay so someone said a prayer request
with which had all the work and then he
says well we are implementing the Higgs
waddler document algebra and so on okay
and then and we started using this code
someone said well actually the
implementation we have here it's very
very slow so I think they had a document
if 80 megabytes document with a bunch of
data types and when we were pretty
printing it was taking like 30 seconds
or something like that and why is that
right because the papers they were
written with has my mind and Haskell has
lays evaluation and Alexa has a strict
inner evaluation so what would happen
here that every time we define a group
we would at that moment go and get the
document and replace all the conk all
the lines by concatenation at that
moment we wouldn't do that lazily okay
so we have to solve this problem let's
try to understand this problem a little
bit better right so imagine that we have
this data structure here right so we
have this list with another listing sign
and then we know when and we have 25
columns here we know that when we go to
10 columns it breaks it like that how
many groups do we have here right we
have two groups right we have the outer
one that when it doesn't fit it breaks
once and then we have the and then we
have the inner group right so you can
see that as you have complex data
structures that are nested the number of
groups they are going to grow and what
would happen when we have this cover and
this context here is that we would every
time we call and two more considerations
we would duplicate the documents and
then duplicate again duplicate again it
would grow exponentially and to be super
slow okay luckily somebody has solved
this problem as well which is a paper by
Crystal Indyk which I assume is not here
and it's called strictly pretty and
basically it gets the ideas that we had
in in Walters paper and huge paper
before it and convert that to a strict
language that's why again the
title is strictly pretty right which was
okay mo
so stoppable although he got that we got
the initial request converted that to
use Linux algorithm okay and we got very
good performance out of it okay so how
does that met algebra works in Aleks
here it is implemented by a module
called inspect
algebra and we use it initially to
inspect data structures right so every
time you are in the terminal galaxy and
you get a data structure back that data
structure it's just ones and zeroes
right in memory going to get us back we
get a format and we are generating this
format with the help of this packed
algebra so we use it to inspect the new
structures but we are now also using it
by the code formatter okay because the
problem is the same right it's not that
was the code formatter instead of having
data structures we have codes like
function calls right and we need to do
the same thing if it doesn't fit on the
same line we need to break it apart once
we need to break it apart twice and so
on okay
the difference however is that to
implement the code formatter
use inspect algebra the algebra that we
had there it's not enough because the
code requires more complex rules so for
all time we did extensions to the
document algebra library that we have in
annex C so one of those is to have this
we use for colorant printing printing in
the terminal so is the idea of adding
colors okay that's one of those we also
read the support to nest base it on the
cursor because the previous nesting
would always nest by two spaces for
example have to say how much had to nest
so this is just a convenience where they
say well nest to whatever the cursor is
the pretty pretty when it's rendering it
knows how many columns you need to
restart so nest by whatever the cursor
is right now okay
we also had another document called
first unfit and a couple others right so
just as an example of usage of one of
those new documents so how does for some
fit words so here's some attic surcoat
imagine you're calling a function called
code and it's we are passing three
arguments so the first one is the atom
okay and the second argument is a here
doc string is a string but syntactically
we
we break it because it's going to have
multiple lines we use the here
documentation okay and then we have the
last argument so mark right this doesn't
look nice right because we have because
the truth is that this thing that it's
not being rendered in a single line we
have something there in the middle that
breaks over multiple lines so we force
unsee it what allows us to do is to say
look every time and we have a pure doc
we say that it is unfit every time have
a here dot inside a function call or
inside another data structure we just
want to consider that the whole fee
needs to break apart even if it never
goes over the line length the line
length doesn't matter anymore we just
want to break it okay we want the
surrounding group there to break and so
on all right so that's how we got code
for a matter working with Alex see that
exterior just building on top of papers
implementations and ideas that appeared
throughout time and the second feature
that is coming the future an active
version is this from data right and as I
said at the beginning of the talk one of
the goals of stream data is actually to
help us to write properly based tests
and before we talk about property based
tests let's talk about the issues that
we have we have an example based testing
right so example based testing it's
likely the kind of tests that we write
every day right most of us write every
day so what is the so how does those
tests look like an Alex series something
like this recall assert and we call the
function that you want to test so I
imagine here that we are testing string
that contains we want to test if the
string that is given a second argument
is concerned if the string that is given
as first argument contains least rain
given a second argument okay so that's
so when we are testing section ality
what we do we come up a bunch of
examples we need to think about a bunch
of different examples in case I said wow
I have a string foot bar so I want to
test with the beginning of this training
fubar which is true so it does that with
the switch bar with us with something
that is in the middle of this string
right we touch with something that does
not exist so we come up with a bunch of
tests okay so the questions that come
from this is how are we to find corner
cases because
since we are the ones coming up with the
examples how can we be sure that we came
up with all the other fun examples that
we don't forget something crucial okay
or more importantly however even when we
think about the earlier cases right how
here of them how we are going to know
well for this particular scenario should
it be true or false right we need to
have a good metal model to answer those
questions so for example a string
contains right with a string fubar and
an M string should this be true or false
right
what about design other one the second
one is a bit either I I string cannot
contain something that is bigger than
string itself right but we need to
remember to think about those cases
right and about them string that the
empty string contain the empty string
right we need to remember to think about
those and we actually struggle with this
in Aleks here so so when we were
strongly to people how should string
contains behave Tamas arts he would come
and he said look for string contains
this is the simplest property that I can
think for this function so in this case
we're not even using the property based
test if the property based as an
elective but thinking about the
properties was helping us on this
promise would say look the simplest
property that I can write for this code
is this one and according to this
property this particular thing should
return true and this should return false
one right so it was giving us this metal
model and as we used it so sometimes
would have questions with being comments
like Thomas which property was right and
then you would tell us the property so
eventually became clear that we will
have a bad result library if we were
writing property based tests or company
that's why we decided to introduce at
least stateless properly based testings
tests to Alex here so how it would look
like in Alex it look like I say so I say
hey I want to check all okay and then we
are going to ask this string generator
to generate a bunch of strings that are
going to have on the left side we're
going to ask another swing generator to
generate a bunch of strings that go on
the right side okay and then we could
cut any two of them you never want to
assert that the string contains the
string on the left
and good thank this string on the right
that's a very simple property that
expect this code to obey okay and
eventually when generating random data
it's going to generate four empty
strings which are going to test the
scenarios I was just talking about okay
so property based testing is often
described also the narrative testing
because we are now generating data
instead of coming up in with with
examples from our mind okay it's useful
to describe the invariance the system
things that should always be true right
and it leads to for all the tested
software that is designed with intent
right sometimes our using a library or
your using a function say as well if
this function is passed the left string
it behaves like this if it passes and
the strength that is not emptied is
going to behave like that right and oh
it receives an empty list so even for
things of the same type it behaves
differently and when you see a code that
is like that that is documented like
that is because nobody about the
underlying properties that code should
exhibit and we see that to leaky in the
documentation which is going to leak
which is going to leave when you're
using that API as well right you need to
have all those kids you need to handle
all those kids because there's no
underlying property and the paper that
introduced this is the quick check paper
by John Higgs and concussion and a quick
check the lightweight to foreign Anthony
of Haskell programs okay and we decide
between plummet that in a lecture as
well except that now we've learned our
lesson right it's right there in the
title it's for Haskell programs do there
any day the lazily in Haskell it's going
to be different from generating data
lazily in Alex here so instead of
finding out that we're implementing the
wrong thing along the way so we said
well you know we don't discipline tation
the the electric bondage is going to
have to be different so what we did was
also to check what other communities
were doing and one of the politicians
that was really helpful to us as a guide
was the test check implementation that
comes from closure okay and the focus of
the permutation property based testing
eats the generators right the focus are
the data generators so let's talk about
them so what are generators
okay so generators as we saw right so we
have a module that's going to be called
strand of data that we're going to
import it and it's going to add a bunch
of generators for different data types
that we have knowledge here and here we
are saying that integer generator okay
so we have the intergeneration it n
values and we can see that it generates
random values right and they are also
not unique they are not anything so I
can say duplicated values in there as
well but you can also say hey generate
me a bunch of ASCII strings right so and
which properties do generators have
generators are lazy okay so when you
call just the integer
generator it's just going to return a
lazy data structure we don't get values
from it at that moment just say hey this
is something that knows how to generate
integers and now that's only way to say
hey give me 10 there give me 20 that is
going to spit those values out we need
to be careful because they are infinite
so if you say hey I want to get this
into the generator and convert it to a
list so we want to make the generator
concrete okay all the vatican great
that's never going to finish right
because it's going to keep on generating
values forever as we said they are
random okay so every time I call the
generator the same generator it's going
to return different values and they are
not unique and another interesting
property from generators is that they
grow in size so you can see here that
they are all at the beginning they are
always amazing in small numbers okay but
if we say hey I want to drop the first
100 elements and give me the rest right
when we do that we can see that it's
generating larger numbers now because as
they generate values okay do those
values they they have pure amplitude
frame teachers for example and that's
how we write the property base test
you're just leverage in generators and
say hey I want to generate all this
bunch of strings and I'm going to use
that in my string functions okay
so property based is really beautiful of
the generators and and leverage
everything the generators have to offer
you to go check the stream data library
in elixir which is we right now is not
merging into a lecture itself to the
separate library you're going to see
that the core of the work is all in the
data generation the property base
testing
wrapper around it it's super small okay
so it would write those tests like these
right we write those properties and
but there is more or less property that
was from our generations one last
feature that we want for our generators
that is very very important which is the
last one I'm going to talk about it's
also that generators are shrinkable okay
so imagine that you are there you're
writing your test now using properties
are very excited about it and are
getting better code better test code as
well with it and imagine and imagine
that we have this test and this is a
test that is going we're all ready to
fail on purpose okay but imagine we have
this test just as an example so we want
to check that element is not a list so
we say well I want to generate a list of
integers and I want to assert that the
number 22 is not in the list what is
going to happen here is that this test
is eventually going to fail because
eventually we are going to generate the
integer 22 that is going to be in the
list and that's going to make a test
fail okay but when this test fail it can
be when you know when the list has 30
elements 25 40 elements we don't know
right so what would happen is that we
would be tackling this code right and
and so I said look when they generate
this input this list with 30 elements
these cold fails right and then you need
to look at that input and say oh why is
this called fail failing when I have
this list
what is the characteristic that is here
in this list that make this code fail
for this sample code it's really easy to
find that out right it's when you have
the number 20 28 when when you're
testing your own code that may not be
that obvious
so the idea that generators are we can
shrink generators is that when there is
a failure we are going to try to
generate smaller list possible in this
case that can make that test fail
because we already have the condition
the fainting condition so we tried to
find the minimum point which is
something that we do a lot of practice
right if you're Montaigne a project
someone reports a book what we asked hey
you have a minimal test case ever
produced the book right
the generators are doing that
automatically for us so generators are
shrinkable so here's an example of a
error report that we
Yeah right it would say well I pride i
generate 29 values right and my 20 names
try I got an error and here's the error
and disrupting our value is the list of
22 with China join it
okay and how they're implemented the
generator selected there they are very
simple so they are functions okay that
receives two arguments the first one is
the seed that we use for random
generation and the second one is the
size because we want them to grow with
five right as our generate more values
and it returns a couple of two elements
the first element is the element being
generated right now and the second
element is the function that knows how
to track that value if eventually we
want to shrink that okay so that's it so
a string data provides the regeneration
primitives to elixir bring the
stateliest property based testing to
xunit right but what we are doing here
so our goal here is to get people into
property based testing because the
discipline go way beyond what I just
showed here right so what we have next
year
it's just stateless property based
testing but there's a bunch other stuff
ways of testing seen the testing systems
that we can explore for example with
more robust tools like quick check right
big check provides more advanced
features such as model checking 6 -
checking coop it allows - they have
something called polls which coordinate
how the processes are scheduled in the
VM and so on so if are interested on
more advanced testing tools even how
recommended to go to the Quebec website
Joan Humes and his team they are working
on those tools directly and improving
them and it's not only for an experience
for Erlang C C++ and so on right well so
that's it that's the end of the talk of
human development as I said in the
beginning it's a play with words
we've test-driven in the sense that
people say well you should write the
test first and the joke here is that we
wait for John Hughes to come up with an
idea and then ten years later we add it
to our programming languages and
everybody's happy but taking the joke
aspect out of
I think it's a very interesting way of
showing how you know industry and
academia and they are working together
so sometimes have an idea introducing
that academia itself refining those
ideas often implementing that into
different programming languages those
ideas are what we build it back and then
somebody takes them improves it a little
bit or somebody takes it to a whole
different set of programming languages
improves them more and it's a very nice
way to see how those things come
together at the end and especially its
property based testing for example that
we see now in all different kinds of
languages and different Montaigne errs
writing and maintaining those all right
and finally I want just to last note so
first I want to thank plataform attack
which is my company the company behind
elixir a lot of the work that we see in
Alexia is being driven by plataform
attack and also to the Elector team so
in particular the code and Daleks a
community as well so Louis is here he's
I think he's the first one to write a
code formatter for elixir and he helped
us get this final version on and andraia
we he is all electric Alex a team as
well he's the one working on string data
mainly so I want to thank everybody and
especially thank John Hughes all right
thank you very much
do we have time for questions or should
I pick them up we have plenty of time
for questions so if the audience shouts
us out we also have microphones but it
might be a little difficult to sort of
rush across the room and get those to
you but we have plenty of time for
questions so if you raise it hand and is
it okay if you choose sorry is it okay
if you choose from your doing yeah okay
great all right thank you
wait I think there is some other sorry
I'm not really familiar with elixir or
its libraries but you mentioned test
check and so I am familiar with closure
infrastructure a little bit and what
makes it strong in closure that's you
can data that you're using and it kinda
can generates all the streams that you
test with itself is there anything
similar so that an elixir or
a new place for that so just so you
mentioned closure is back or yes
yes so we don't have something similar
to closure is back right now but closure
spec was one of the was one of the
things that also helped push over us to
to have property based asset at expiry
because they showed that with a single
construct you can generate you can
leverage a lot of features out of it
right so out of this pack you've got
data validation it got data generation
you get documentation so so yeah I'm
familiar with it we don't have that in a
lecture right now but I think it would
be super nice somebody to say start
exploring that and integrating with the
tools that we have today thank you thank
you for the question
hi you presented a stream generator is
it possible to nest generator nest
generate of slits yeah do one of things
like this yeah so the question is it
possible to not generate is that so the
one off buying all those constructions
that are common to daily generation and
property based testing the Aeronautics
air as well okay great
thank you someone has got a question
down here as well yeah
so much is coming
you can ask I'll repeat this Oh
excellent question if you use property
based testing how for how long do you
test the Dafoe is 100 tries but there
are ways sorry to customize it - they
say well I want to test for 5 seconds I
want to test 1000 tries and so on yeah
so are there any resources that you can
recommend for transitioning from the
example based test to property based
testing that can help me identify the
properties of my own code oh yeah so
anything that I recommend to musician
for an example based testing - property
based testing so you don't tradition
actually because the example base
testing they are two very very useful
and so far as a polity they like to do
is that when a property goes wrong I
write an example base testing an example
base test out of that error for example
so you actually want both two to coexist
I believe there is I'm not going to
remember the name of the book but there
is a very good book right now by fred
ebberd which is prop check con or
something like that which is a very odd
book for early it's using different
tools but the concepts they are the same
and it's recently out and it's really
great as his previous work so yeah
that's really nice like i find it very
useful too but and especially sometimes
to test the corner cases right so my
question would be some corner cases
seems to be more like more interesting
than others say I don't know an empty
list or an empty string or I don't know
thank you so ha how do the generators
make sure that they generate more of
this kind of like hot
common corner cases rather than just
random data assume it's not like just
completely random right because so the
question is how the generators stay
there are things that are prone to
errors right so so how does the
generator handles that so it depends
it's going to depend on the property
based s in library and it's going to
dependence generator as well so for
example for an integer you want to
testing like zero minus 1 and 1 and
because it grows in size the chance that
you're going to get one of those
eventually it's very very high right
specially over multiple runs
so for that integer generator we may say
well I I'll let it be I know that
eventually its way to be correct but
there are other generators like imagine
it could even be the integer or imagine
that I have a big integer generator
where you want to test the boundary when
the thing doesn't fit in memory anymore
it goes to another representation or the
same thing will float numbers you want
to test a different boundaries in there
so far those cases because the size
would not allow you to get there the
library may say I'm always including
those when I run the tests I don't
remember in particular in that extreme
which approach are taking for a
generator but those are the what some of
the ways of tackling this problem ok
there is question here as well
ah is it easy to write your own
generator is it easy to write our own
generator these doesn't know so if
you're writing your generator from
scratch which is what we did in the
library it's a little bit there are some
concerns you need to take and so on is
not super straightforward but for us
that are going to be consuming the
library
we are always building on top of the
existing generators it's very likely
that you are we need to write something
from scratch because unless you the
amount of data types that we have there
are ticks so as long as we know so
everything that you need to generate is
going to be something that you come you
build on top of next 15 data type so we
are going to get the data type from that
generator and then we are going to map
over it for example and get something
different so we're not so building is
not super straightforward but you
wouldn't be building you would always be
composing that's kind of the short
answer do you think that with property
testing there's a point at which a given
tests has exhausted its value like do
you think that keeping these tests
around for a long time continues to have
value or is most of the value of
property testing upfront when you're
initially trying to look fresh cases and
corner cases that's a very good question
I've heard from so because they take
sometimes some time to to run I heard
people that they keep that separately in
the suet and they for example only on CI
and they don't have run it on the
machine so they get they still get the
the the assertion of the properties but
not every time they run the suet and
probably the reason why they are doing
that exactly because they did the
trade-off and say well I don't want to
put development time every time I'm here
but there's still something to leverage
from the property even if it we are
talking about in terms of regressions
right so I would say that so maybe one
way to look at it is that if at some
point being properly based as they're
not used for anymore
they're still going to be as
useful as an example based testing in
when it comes to it's going to help you
not have regressions but I think this
balance it's not going to change from
from team to team and and in your
experience because because the other
thing is that the properties they are
also very good for documentation right
and we need to remember that so if we
erase them completely from the codebase
right that that property that is how the
code should behave which you can be used
to explain that code to other developers
it's going to be lost as well so the
trade-off of moving to the side may be
useful for us for some I know that some
they actually don't mind right if I have
a library that is the test they're
running in two seconds and you're going
to move that to one second because
remove property based stuff like my
mother so yeah I think it's a very good
question the answer is going to probably
check is going to change depending on
the project another teen you ask now we
have more questions here it's a good
exercise
all right hey so you just mentioned
documentation and that the proper tests
are good documentation which I very much
agree with but are there any ideas of
actually connecting documentation and
property based tests so that they've
actually will be the documentation yeah
that's a very good question should we
actually think I just said that the
property is good for the commentation
maybe Alex we should have a way where we
can get the property and showing the
documentation page I think that's the
idea really worth exploring yeah we yeah
all right thank you very much for the
questions for attention
I will also be out so if somebody still
want to talk about and discuss things
I'll be glad to hear about it thank you
very much
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>