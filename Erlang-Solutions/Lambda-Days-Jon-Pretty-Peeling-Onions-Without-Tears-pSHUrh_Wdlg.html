<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days - Jon Pretty - Peeling Onions Without Tears(...) | Coder Coacher - Coaching Coders</title><meta content="Lambda Days - Jon Pretty - Peeling Onions Without Tears(...) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days - Jon Pretty - Peeling Onions Without Tears(...)</b></h2><h5 class="post__date">2014-04-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/pSHUrh_Wdlg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right first of all thank you many tura
file for inviting me to speak here today
so it's real pleasure to see so many
people of you coming to this talk
instead of the other one today I'm going
to talk about abstractions in in in a
very very general sense also in some
cases very specific sense I'm going to
work mainly with examples in scarlet
because that's what I know I'm sure a
lot of you probably don't know scholar
as well as you know some other languages
so you might have to do a bit of
translation and and glossing over some
of the specifics and I did a quick run
through this talk before I before I came
here this morning in it it fitted nicely
in 40 minutes but I've only got 30 so i
might have to be a bit bit Pacey and i
would i'd normally invite you to ask
questions throughout but i think we
probably won't have time so i'm going to
say if you've got a question ask me on
twitter and I'll make sure I reply at
some point during rest of the day so to
get started a philosophical question
we're all programmers but what is it we
actually do what do we spend our time
thinking about so you could say we do
coding we write code but you could say
we earn money or try but but what we're
what we're actually doing is is
something a bit deeper than that so and
anything anything can write we bill I
saying what what does it mean to write
English you can get a you can get a text
generation website to write English for
you but it doesn't make it Shakespeare
or Molly air it's it's actually a much
more complex thing we do where we are
analyzing the real world and the things
we see in it and where we're trying to
systematize them to methodically work
out models that represent those things
that we see in the real world and this
is this is finding abstractions and I
think
as program is one of the most it's one
of the most challenging things we do and
it's it's where the talent in the very
best developers lies in in picking good
models and good abstractions of of the
world we're trying to model so
abstractions are absolutely everywhere
in our industry if for example I was
implementing some sort of transaction
processing system I might decide to use
acker actors now they run in Scala
scholar has a type system which is kind
of a metaphor for the real world that
sits on top of the runtime type system
in the JVM so the JVM is virtue shine
that sits on top of the operating system
we're using and the operating system is
probably written in C whatever it is now
c is itself an abstraction over assembly
language assembly language is a human
readable version of machine code which
is interpreted by a cpu and the cpu has
several cause now another abstraction
that occur actors are providing is an
abstraction over the threads and
consequently the cause that are in that
CPU and the CPU itself is just a
collection of NAND gates that are
implemented on on silicon and silicon
works by virtue of the the various rules
of electronics and the laws of physics
ultimately determine how they work so
we've got layer upon layer upon layer of
abstraction and this is this is what I'm
calling our onion this is the Grand
onion of computers we we have multiple
layers and we normally work with in one
particular layer that seems most
appropriate for our particular task but
it is always unless we're working at the
most fundamental level of physics which
we don't it is always built upon another
layer beneath it
so what what makes a good abstraction
okay what makes an abstraction at all so
for something to be an abstraction it
must be first of all abstracting over
something there must be some underlying
system which is which is providing all
an alternative explanation for and it's
not just any alternative explanation it
must be simpler in for some to some
meaning of simpler which I'm not going
to define so those those the two key
criteria of of what makes an abstraction
its building upon something that already
exists and it's simplifying it and it
doesn't doesn't matter how we interpret
simpler Simpson trees is subjective it's
up to you to decide what simpler so
could we could be for example consider
this this is the the periodic table of
elements could we consider this to be a
simpler version of the system it builds
upon the the Standard Model of particle
physics which has 16 or 17 17 elements
and and looks a lot more symmetrical and
more pleasant to work with well it's
simpler if you're trying to work out how
say an oxygen atom bonds with two
hydrogen atoms you wouldn't want to have
to use the standard model and all its
details of quarks and leptons and bosons
and so on to work that out so simpler is
subjective and it's it it's not
something I'm going to to decide upon
here it's up to you to decide but it's
only because this this model here when
when physicists were were analyzing all
the the chemistry of these elements that
they they discovered there are a few
things that didn't quite add up and it
was only this leak in the abstraction
that led them to discover there was
actually something but
leave that the the standard model of
quarks and and all these things that I
can't really pretend to understand so
there's an important point here this
like any other abstraction is leaky it's
a fundamental aspect of abstractions
they leak and and and there's always
some dark corner it might be very rare
that you encounter it but there's always
some dark corner where the under
underlying model becomes becomes visible
and you can do a lot of papering over
the cracks to try and try and avoid that
underlying an underlying system being
revealed but an abstraction will always
have its leaks if it doesn't have leaks
then it it's basically the same system
you start with or it's nice and morphism
of it which contradicts my definition of
what an abstraction is it's got to be
simpler now some things like the Java
Virtual Machine or class hierarchies or
mon ads these are very obviously and
unarguably abstractions I think nobody
would disagree that these are
abstractions over something but other
other abstractions maybe less well
defined so for example as a programmer
you may come up with your own ideas as
to what it means or what patterns you
see and you may you may deduce your own
personal abstracts you don't don't tell
anyone but but they lead to you forming
ideas as to how you should go about
coding now I don't know if you don't if
you've seen any of the criticism of
scarlet recently there's been a couple
of presentations mainly done by by a guy
called Paul Phillips has anyone seen
them oh not many of you okay what watch
them that they're worth they're worth
watching he raises some interesting
points he's been negative but he
he does does raise some good points and
a lot a lot of the points he raises do
stem from a general lack of
understanding about abstractions not not
not on paul's part he understands them
better than anyone but it's because
everybody else is making their own
abstractions as to what what it means
for how the collections library and
scala works that they're coming up with
wrong answers and they're getting
confused and it's it's because the
abstractions that are involved in in
encoding collections and scala are leaky
that these problems are occurring and
yeah maybe it's a program you have you
have a model of the collections library
that that's based on use cases now use
cases are a feature used in document
documentation in scala that allows you
to give examples of how a collection is
used now that might be that might be a
very simple way of mapping over a list
say it's not it's not the reality of the
situation and it's it's a particular
problem because the reality is actually
much much messier and the abstraction
and this is this is this is Paul's point
the abstraction isn't working as it
should anyway it's about time we saw
some code right this is some scholar
this is some scar low which will find
the meaning of life if you give it a
list so here we have the the method
search for meaning you give it a list
and it matches on that list if it finds
an empty list well it's failed to find
any meaning in life tough and it returns
this message there is no meaning if it
finds
meaning of life now meaning of life here
is to find to be 42 and the rest of the
list it doesn't bother looking the rest
of this because it's already found the
meaning of life and it prints it out
there okay otherwise it just matches or
binds to the the head of the list Andrey
curses on on the method so this this
will terminate it's no problem there but
it doesn't do what I just said it did
does anyone know what the problem is
correct so it's very easy to assume if
you use scholar that case whether
whether an identifier begins with a
capital letter or a lowercase letter is
irrelevant now most the time classes
have capital letters objects have
capital letters constants have capital
letters and the sort of things you bind
to like for example the head of the list
here they they start the lowercase
letter so you don't encounter a problem
where for example here you are actually
creating new identifiers here called
meaning of life and you're returning
that identify you just found in your
response completely ignoring this one up
here there's this this this meaning of
life identifier up here is not used at
all in the method and in fact this this
one here is shadowing the one we
actually want so if you were to give
this a list of say 1342 9 it would say I
found the meaning of life and it's 13
that's not everyone knows it's 42 so
this is this is this is what it ought to
look like spot the difference it's it's
this subtle capital letter on the
meaning of life identifier
so why why is this so surprising why is
why is it that a subtle I mean did this
this fails the the principle of least
astonishment how a very subtle change is
actually having a dramatic effect on the
code so i don't really want to say that
in ninety percent of the cases or ninety
nine percent of the cases or 99.999
percent of the cases this sort of thing
doesn't happen but it's it's a
reasonably rare occurrence because most
of the time the things we're matching on
do start with a capital letter by
convention convention only and the
things we're binding to a new identifier
start with a lowercase letter so this is
this is an instance of leaky abstraction
it's it's it's a myth that capital
letters aren't important in scala the
the reality is they're they're important
in a very very small selection of cases
and this is this is one of them so we've
we've seen a corner case and it's it's
kind of reveal to us that our
abstraction our abstraction that capital
letters aren't important is actually
leaky so back to the original question
what makes a good abstraction now I'm
going to claim without proof that there
are three things involved in in a good
abstraction so if we call capital a a
measure some measure of how could our
abstraction is then the factors are the
mean time to failure so the time from
when you start using that abstraction up
to the point where you hid the first the
first leaked the MTTF and see which is
the complexity some measure of how how
complex it is to understand and the pain
in dealing with it with a leak when it
occurs now I'm going to claim
that the the goodness of the abstraction
is inversely proportional to to all of
those so in the example of the example
of the myth of the capital letters here
the complexity value is low it's a
really really simple model it's wrong
but it's it's simple so our value for C
is low so that's that's good it's it's
kind of painful in that you you don't
know where start looking when when when
you when you hit a problem like this so
the the p-value is kind of middling and
M the mean time to failure so it happens
not that often so you can go a long time
before you actually realize whether
whether realize that the leak exists in
in your abstraction now you might have
noticed something a little bit odd with
this I've put I've put em on the bottom
so what's counterintuitive about this is
that I'm claiming that the more
frequently a leak happens the better the
abstraction is or conversely the longer
it takes you to discover a league the
worse the abstraction now that's that
may be a little bit controversial and
maybe maybe my maybe my model here is
actually just a simplification of the
reality it certainly is but think think
think about this if you've gone weeks
months years without discovering a leak
you're I've lost I've lost my notes
failing everything I do know what I'm
saying yeah you can go months weeks or
years without actually encountering a
leak with your particular abstraction
now after all that time it becomes very
difficult for you to actually challenge
the fundamentals of your of your
abstraction it's very difficult for
someone to actually think well maybe
maybe my ideas about how this system
works which I've held for 44 years are
actually wrong you just don't consider
it usually whereas in the first week of
working on a and a new idea working with
a new kind of abstraction you're you're
you're very ready to to think that
actually I need to understand this
better and and and make sure you do and
look in all the all the places you would
you would generally go hunting for for
clues as to why why something isn't
doing what you expected to so it's so
the the counterintuitive claim here is
that the longer you go the more hardened
your ideas get about about how an
abstraction works and actually it's a
worse abstraction that has a pain a pain
point a long way down the line so yeah
unfortunately these variables aren't
entirely independent of each other so
changing one could well have an effect
on the other but what I'm what I'm going
to do the rest of the presentation is
try to try to minimize each of these
values and look at a few ways you very
concrete ways in which you can improve
the abstraction to you as a someone in
the role of a library designer how you
can improve the abstractions you create
in developing a library by by minimizing
em
c &amp;amp; p so let's start by trying to reduce
the pain that gets incurred whenever the
abstraction breaks down now there's a
load of obvious suggestions here and you
can you can use the type system to to
encode various aspects of your abstract
let that's all that all helps to to
translate your your pain points from
runtime failures or or may not even run
some failures but but errors in the
behavior of your software convert those
into compile-time errors and that that's
that's been well documented so I'm not
really going to talk about that too much
what I what I will say is when you're
when you're debugging the process of
debugging a failure is an awful lot
easier if you know where to look when
you don't know where to look what you do
you start you start progressively
challenging more and more of your your
your preciously held models and
abstractions until you find the one that
actually you were wrong about so this is
a this is a common criticism of scholar
but it has this this magic or less it's
magic until you understand it fully
magic concept of implicit who's familiar
with implicit since carla or aware of
them okay what and aware of them in a
positive or in a positive sense aware of
them in a negative sense okay we're
about half and half ok so the right
there are negative and positive 2 to
implicit I think they're amazing but
I've spent 10 years programming scale
right now I understand them so if you if
you were to make false assumptions about
how they work then you could quite
easily get into trouble but one thing in
places can do is they can they can allow
you to take an existing instance or
of a class and add new method stirred
and this is this is generally called the
pimp my library pattern in that you can
just add add methods effectively to to
any object you have so if if you were
debugging some code and you saw that a
method was being called on an object you
might ask the question where does that
where does that method come from what's
providing that method now if we were
using Java we would know that well
actually there's a class hierarchy and
it's one of those that chain of super
class that contains the depth of the
definition of the method so that's not
so hard to find where it since carla it
could be any of multitudinous implicit
that are in scope that could be pimping
that that method on to your on to your
class and if you have to stop debugging
that you you well the problem is you
don't know where to look so you have to
look everywhere and has anyone noticed
that the Scarlet compiler is quite slow
it's compared to java the java sea for
example yeah so it's Chloe it's it's
slow because what it's doing is doing
that search the one you have to do when
you're trying to find that method it has
to look through lots and lots of code
through lots of packages and and classes
to try and find the particular
definition of the of the the method
that's being called and you're basically
doing the job of a compiler when you
have to debug that and if well tooling
will help sure yeah well it's it's
people's assumptions about the I'm
looking for a way to help people
possibly without salling tolling is one
approach
yeah that can help a lot but I'm about
to suggest an alternative yeah yeah
abstract the the documentation might be
to blame general education of the
language might be to blame there's
there's lots of lots of causes anyway
this is this is one of scholars great
contradictions that you get the you get
the magic of implicit and all the power
that gives you but you have to take it
with with the the confidence that I
roads in how your software is working
it's just sometimes seems a little bit
too clever so how do we mitigate it
start by working at the laptop yeah how
do we had to admit agates problem well
what I'm going to suggest is make sure
when you're writing a source when you're
writing source code in in Scala make
sure that your context is well defined
so make sure that the first few lines of
every source file you work on specify
the context now when I say context i
mean the packages you import the the the
classes not just within that and
specifically the implicit so you you
might need to now that this is this is
destruction both for both the developers
of the light of a library and also the
people who use it but if you're a
library developer you saw organize your
packages objects so that each import
declaration of so eat import is a
declaration of the context for that file
so for example if you have a if you have
a package which provides additional pimp
my library operators on say a java date
put that in a package called Java date
operators and import Java date operates
that underscore now when you see a
problem with with understanding where
the weather methods on day
come from you as the as the person
viewing the code you know exactly where
to look it's in the Java date operators
package because that's what it's called
so there's a few a few ideas that you
can you can apply to it to improve
things this this is this is one of them
and I can see I'm running out of time
already that this is what it might look
like in encode this is this is something
I've done with my my Raptor library I've
made it such that if you're if you
import this thing called strategy don't
throw exceptions that defines the
context of the entire file of your
return type strategy now I won't talk
about return types rashly because it's
I've already done a whole a whole 40
minute talk on that in London last year
but it's it's something which determines
the how the result type of any fallible
method is is handled now my times up and
I'm about halfway through there's a
couple more ideas which I will I will
happily talk through to anyone anyone
who's interested later I have completely
completely run out of time so I'm afraid
I will oh ok ok well ok hit so I'll skip
I'll skip 11 section and and and and
probably found another five minutes so
if I if I jump forward to back back back
to this
one other one other thing we can do is
to simplify simplify our abstractions
now we just finding my place sorry so
let's take an example of the Scarlet
type system I think this might be an
example for the section i'm skipping out
there within a second right ok so a way
of a way of simplifying your your
abstraction is to try and leverage the
features you've already got in your
programming domain so to find features
in scala that very closely match the
problem you're trying to represent the
abstraction you're trying to develop so
here is an example of a bad abstraction
abstraction acker actors they use a
combination of closures and well though
they represent message handling using a
closure now a closure can very easily
capture mutable state from the outside
scope and that that breaks down the
whole the whole purpose of actors that
they're trying to help you with
concurrency not cause new problems or
give you a false sense of security so
this is this is a this is a case where
the the features we're using are not
particularly congruent with the the
problem we're trying to solve or the
abstraction we're trying to provide I
saw this quote on on Twitter recently I
need to be liberated by constraints so
constraints don't normally liberate you
they normally constrain you but
if your if your constraints very closely
matched with your your problem domain
then that allows you to that let that
allows you to be more confident in what
you're doing that you're not going to
risk doing something that that's not
consistent with with with your
abstraction I was going to show an
example of how I've used this in rapture
Jason but that probably isn't time so
I'll go straight to the summary so to
summarize three things you can do to
improve your abstractions declare your
context context is very important it
contexts will help people reduce the
pain they have when they have to debug
failing early this is the this is the
point I didn't didn't discuss but if
your abstract is going to leak try and
cause it to leak early because it's only
the first occurrence of a failure that
will that will be problematic after that
you know that you know the the failure
points and you've been educated you can
you can work around them and finally
that constraints can be liberating so
use use features of scholar or or any
language which which fit well with your
problem if if you see cases where you're
having to kind of work around the
problem work around the feature to
implement your abstraction then it's
probably a bad choice of feature or
features to use that's that's about it
or at least it's about three-quarters of
it thanks thanks for coming
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>