<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2018 - Dawid Dworak, Jakub Bujas - Scala(ble) High-Performance Computing | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2018 - Dawid Dworak, Jakub Bujas - Scala(ble) High-Performance Computing - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2018 - Dawid Dworak, Jakub Bujas - Scala(ble) High-Performance Computing</b></h2><h5 class="post__date">2018-04-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gl8o1Tq2C_s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone I'm David and this is
kuba we're students at AJ Asian
University of Science and Technology and
we're also developers I work as a scale
developer in the telco industry and kuba
is a creative designer in the games
industry and we'll be talking about our
success story with Scala in scientific
setting particularly in a
high-performance computing environment
by which I mean that top 100
supercomputer and if there is one thing
that we want you to take from this talk
before you head off to lunch is that
Scala is perfectly viable for research
particularly with akka and the ways you
can really distribute your scientific
logic into into such a cluster but let's
take a step back in history to a year
ago we are attending a course on systems
modeling a simulation which was led by a
doctor Turek whose presence here in the
audience and one thing that you have to
know about him is that he's very keen on
herring and well he proposed a project
to run a simulation about in large scale
about quite small but complex creatures
called the foraminifera
and as asked Oliver I thought that it
was my duty to challenge him with a
skull implementation of this project so
we ran two projects simultaneously kuba
helped me of this and we had a set of
goals that we wanted to achieve with
this project we really wanted to run on
a high-performance computing platform
because that was probably our only
chance to do this in our students
lifetime and we also wanted to hit the
grid size of order of line because the
previous research that we found with
similarly complex creatures was on
around order of nine cells other five
cells so we wanted to be so much better
than the previous people who did this
and we wanted to manage concurrency with
actors by splitting the grid and having
worker actors perform computations over
a part of a grid
we wanted to distribute such actor/model
over a cluster and also introduce some d
synchronization mechanisms that would
allow us to perform even better in such
setting and also what we wanted to do
better than the airline group well it's
not that we don't like airline I
actually work in the taco industry so I
have some professional experience with
furlong as well and it's a beautifully
designed language but it has very
specific design goals and these goals
are not exactly CPU intensive
computation over large in memory data
set
especially when single node performance
is also very important and so we decided
that we're going to use Scala and showed
who's the better in this so in a true
student spirit we took a very lazy
approach where we could really drop out
at any point and say that we just want
to pass the course and started with a
very minimal viable implementation and
that implementation was a single actor
in an actor system and this actor only
sent a message to himself whenever he
finished an iteration so this was
obviously a single note implementation
it was highly sequential we only had the
single biological model implemented
which was the farming affero but we
managed to achieve our first goal for
the further steps which was this signal
propagation algorithm will evaporate on
further but the main thing that you need
to know at this point is that it allowed
us to reduce the complexity of making a
decision for itself because we only had
to traverse the grid once per each
iteration since all the information
about the environment was already in the
south and we understand on an order of 5
cells which was basically replicating
the previous results for similar models
and our main design decision at this
point was to use Scala and this decision
was have had two major contributions the
first one was to use the JVM which has
well known performance characteristics
the jeat is a masterpiece in its own and
we know it well and the platform itself
provides enterprise grade tools for
monitoring profiling and deployment of
any apps it's it's so widely used in the
industry that it was very easy for us to
find hot paths to do micro benchmarking
basically do anything that you want when
you want to create a highly performant
app and on top of that we wanted to use
Scala and force come out the name says
it all it's language for scalable
programming but one of its biggest
advantages is that it's the mix of
functional and object oriented
programming is very expressive and it's
also a very general language in the
sense that you can make proof with Scala
you can do type level computation you
can write your general business logic
you can write the DSL like in SPARC and
obviously this power comes with a great
responsibility but in the hands of
proficient programmer it can be
extremely efficient and especially when
it comes to concurrency whatever level
of abstraction you pick whether it's
parallel collections futures promises
tasks streams actors there's always a
way to decompose your logic from the
execution and sensibly reason about it
and also multi-platform so any code you
write purely in Scala can be tricked to
the native it can be taken to the native
environment of Scala native and also can
be taken to the JavaScript environment
this is called yes and if you want to
explore more about the Jas part you
should look at the you - framework
that's something that we develop at my
current company and it leverages Scala
on the backend and Scala jeaious in the
front ins for a single seamless type
safe environment for development of web
apps so if you're interested in that and
that's that's really something they
should look up and also the second most
important points from this presentation
is the giant Gosling also of Scour and
there's much more under this link
if you had to look it up okay while
coming back to the simulation we decided
that we're not so lazy after all and we
can do a concurrent computation for this
so we implemented a way to split the
grid and then make the workers inform
their neighbors whenever they would
finish an iteration and this point they
would just send the result of the the
whole result of the iteration to the
other worker so he could just apply the
changes that related to him as soon as
he got the message and this was running
in concurrent it was the synchronized in
the sense that whenever a worker got
full information from his neighbors he
could start next iteration and it made
us implement conflict resolution because
it was highly possible that the unit's
migrating from one part of a grid to
another would collide and it also was
the same for the signal values and this
we were able to run this on an order of
six cells which was already an
improvement but once we took a look at
the mechanisms that are available there
in akka it made sense to take it to the
distributed world so we use the ARCA
cluster charting mechanism which is a
very simple way when you just have some
workers to put them into shards and let
akka manage these charts migrate them
between between nodes spinning of actors
on the nodes in a way that's transparent
to your logic and using this we made our
computation basically in from concurrent
implementation to distributed
implementation took us a day and the
only thing that we had to implement was
custom serialization because we know how
well JVM does with this and also we had
to reduce the protocol a little bit to
make sure that we only send their
information that's relevant to a worker
and not the whole grid because we didn't
need that and when we were only in a
single JVM we didn't need to worry about
that because it was a shared memory and
this all has to hit our goal of order of
nine cells but
just a few words about the cluster
charting mechanism that we used it's
really simple to implement that's that's
basically the whole implementation that
we need to do there are just a few
functions one results the charts and the
other results the worker IDs and you
tell the cluster charting mechanism how
to spin up new actors and then you
receive the single reference to such a
region and for the actors within that
region it's completely transparent they
can reply to each other the shots were
migrated between nodes and it also works
with a cup resistance so if you want to
do something that's more failure
tolerant that we did at this point then
that's possible and that was the point
where we decided that maybe it shouldn't
only be a master series maybe we could
do a research paper and not do a
master's thesis at all which is the
lazier way to do it at the age age you
can actually graduate by defending a
research paper instead of a master's
thesis so it since it's shorter it only
makes sense right we decompose our model
from the execution logic so now when you
define your cell types and their
behavior you can just run in the cluster
there are ways to gather the metrics
there are ways of post-processing these
metrics we got a performance metrics at
all levels of the stack and all the
conflict resolution and signal emission
mechanism that we did are it's possible
to statically or configure reconfigure
them with code it's also possible to
reconfigure them at runtime and in two
months we hope to open source this so if
you follow me on github it will make
sure to let you know when it's done
we're mostly working on documentation we
want to make the distinction ization
part more configurable as some of the
results from the paper that working on
for strong scaling we had fixed grid
size which was order seven and that's
around three hundred gigabytes three
notes on Prometheus which is the
supercomputer here in Krakov and we are
able to reduce the average computation
time from 8 hours and 22 minutes to 11
minutes
that doesn't tell you how much overhead
we were introducing so we also did the
weak scaling experiment and we had a
fixed problem size per core here and
even though the solution time increased
by 44% the grid size was reduced to was
increased to 14 thousand percent more so
we believe that this is a good result
taking into account how much
communication there had to be between
the notes and we hope to improve that
result even more once we make the the
synchronization part more configurable
so we allow the workers to maybe wait
free or even more iterations to before
they actually have to apply changes from
their neighbors and the monkey source
okay so the mic is mine but
unfortunately I've got only five minutes
and I thought I'll get about twelve so
let's go straight to the implementation
I'll do my best as short as possible so
we implemented a few mechanisms that I
think make our framework special the
first mechanism is signal propagation we
are basing on the smell propagation
model from the article at the bottom of
this slide dynamic assignment of tasks
to mobile robots in presence of
obstacles and how it works any unit in
the grid can emit the signal the signal
is propagating in each iteration to the
whole grid it means that if all units
are propagating are emitting the signal
and it's propagated in the whole grid
and the single unit can base in only on
his own state to predict where are other
units and additionally where are the
tasks the second mechanism is buffer
zone the buffer zone is basically like
this picture on the right to workers and
they're communicating between each other
by this buffer so we can we can make an
analogy like we've got two islands and
two islands with different government
and different law and the guys from one
from one island wants to migrate to the
other zone if they are migrating they're
using the boat of the buffer zone and
they are traveling to another worker
zone then there they've got different
love different governments so they have
to they have to settle down there and it
depends on the worker the gray one what
he'll do with this thing so we've got
the third mechanism conflict resolution
conflict resolution is the special
mechanism that allows the worker who
retrieves the information about about
the buffer zone and what to do with this
and how apply the changes as we can see
on the left with that we've got the
pseudocode of example of conflict
resolution for foraminifera habitat
simulation as david mentioned before
farm if our small single-celled
creatures and we've got the pseudocode
for three cases well for a my fara is
mediating to our buffer to our zone and
it meets in the destination cell another
forum if era we provided a small
mechanism like cannibalism one for a my
fara it's another and grown in energy
the second case is one from Ephraim it's
empty cell it's pretty easy it's just me
grating and the third case is when
foraminifera meets the algae then it
consumes it and drown in energy our
configure solution is pretty easy to
implement by the user because it has a
strong type system of course it's fully
customizable and configurable on the
runtime so it can he can provide his own
strategies and implement this and of
course swap during the simulation and it
should still work then the pattern
mechanism a pattern matching mechanism
you know it skies
pretty easy to implement this it's nice
looking and additionally we are assured
that we covered all possible cases in
our simulation so let's go to
experiments because when you get
paralyzation we've got of course process
of this but also cons so did robots and
the drawback is that they seem with the
result of the simulation and can have
can have errors or sounds like this and
we had to check if the paralyzation have
any major impact on our results from the
simulation so first specimen was to take
from me very happy that simulation and
implement this it was nice because we
had multiple papers and previous
research but unfortunately we are not
biologists so we needed something
similar but L to be simpler so we've
decided to make our simpler version from
available simulation it's rather like
predator-prey rabbits and let use
simulation on the Left we've got our
first 150 iterations of the simulation
of the simulation for a single core at
one worker the green ones are all gays
the brown ones are Foreign Affair and as
we can see after the first state they
are crystallized and then pulls in it's
pretty characteristic for predator prey
all girls on the right we've got our
main configuration values and of course
user can specify his own configuration
at the bottom we've got the table of
four experiments that we've done for
four different cases of foraminifera
simulation experiments here we've got
four charts for our experiments the main
aim was to prove that we've got no major
and impact of the polarization so two
charts on the left
are the most important ones because the
lines are overlapping so it means that
we don't have any errors those on the
right it's like what because line since
it's really big mess but trust me it's
pretty common for a predator prey and
lotka-volterra a model that's placed are
oscillating and the populations are
balanced what was really important for
us because we wanted to make performance
experiments and there are really
long-term so we wanted to be assured
that our populations won't extinct
what's next serve the photo for the
future plans we'd like to extend our
buffer zones
what's implicating the configurability
synchronization we'd like to allow our
user to specify his own
desynchronization and where is the limit
of it what's more smart hashing function
for cluster shorten mechanism to make
our communicating between nodes even
better and I guess that's all thank you
very much for your attention and maybe
do you have any questions and you can of
course catch-up us later and ask
anything what you want thank you
so one question please anyone thank you
very much
you're probably familiar with the
Conway's Game of Life which is a tiny
set of rules that produces very much of
complexity but what it's is very
interesting about it that it sometimes
produces like repeating patterns of life
and death of cells did you manage to see
this kind of patterns in in your much
larger scale simulations or no well
later in our work we're working on March
larger scales or not really looking at
any visualizations but on the smaller
scale some patterns are the repeats and
you can really see the scope I mentioned
on the smaller animation that they
oscillate in a in very specific patterns
and you can see waves where they move
across the whole grid so it would be
pretty interesting to see what patterns
we could we could visualize on this yeah
we've met up to five thousand iterations
visualization and yeah they make at the
behavior of a characteristic for the
life cycle yeah we mentioned
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>