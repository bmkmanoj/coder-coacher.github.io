<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2015 - Jamie Winsor -Building And Releasing A Massively Multiplayer Online Game | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2015 - Jamie Winsor -Building And Releasing A Massively Multiplayer Online Game - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2015 - Jamie Winsor -Building And Releasing A Massively Multiplayer Online Game</b></h2><h5 class="post__date">2015-03-28</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/_i6n-eWiVn4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm gonna tell you a story today
about how we built a game and a company
from being a single player on single
player xbox live game company - turning
into an online game company about the
last two years this is taken and we've
used some great technologies that I
wanted to talk about today and a little
bit about the process that we went
through and doing that a little bit of
backstory for me I've dedicated the last
nine years of my life or 10 years to
building and supporting thank you
so I've built spent maybe the last 10
years or so building and supporting
online experiences I've worked on games
like Guild Wars 2 Dungeons &amp;amp; Dragons
online Lord of the Rings online legal
legends and Terra and now I work at
undead labs we were founded in 2009 by
one of the founders of a rune in it I
joined in 2013 almost two years ago
it'll be a couple months two years I was
a round employee 20 and now we're up to
around 50 our first game was stated okay
it's a xbox 360 Live Arcade game it's
the most successful Xbox 360 Live Arcade
game except for minecraft in it being
the most successful original game we
were very surprised by that and I wish I
could say that I contributed to it but I
came in right after the development of
it was finished and we're releasing it
actually on Xbox one it's called year
one state of decay year one survival
Edition and it has updated graphics and
it's for Xbox one it's a gonna be out on
April 28th funny thing is the original
game was completed with just those
twenty employees I was the first hire so
right after the game was done and I was
brought on to work on what now has
become a game called moonrise originally
this was code named kaiju and it was a
supposed to be a completely different
game
but its original intention was to bring
a triple-a console or PC like
experienced to mobile devices we later
shifted focus to work on PC Mac iOS and
Android and we took a step back and said
this is a this game could work well with
controllers keyboard mouse or a
touchscreen when you switch from working
on a single-player game to a multiplayer
game there's a lot to it especially when
you're trying to organize a company from
20 people you need more people and you
look at what you're thinking about and
you're saying okay well we need to not
just engineer this game that's maybe 40%
of our time or artwork is maybe 40% of
our time the other 60% is team building
and communication I kind of tricked you
guys into coming into this and saying
it's a tech talk but actually about 30%
of this talk is gonna be about culture
and how the story works in the remaining
70% is going to be cool tech so the main
point here is that software doesn't
solve problems people do it's because of
this that I try to include that human
element into a technical talk you know
you really like the engineering bits of
this and you know that's like the
marshmallows of your cereal and then the
culture parts like whatever the
that is you know like I don't need that
part either
or that culture is like trying to eat a
meatloaf which is gross look at that
people eat that so a little bit of a
disclaimer when I'm talking about better
it's within a context if I tell you that
something is better it's an opinion but
it's an informed opinion and it's not of
my own typically in this talk at least
it's my experiences over the last two
years trying to bring an unfinished
technology which is now an amazing state
to an organization so let's talk a
little bit about the problem that we had
the problem that we had is that we're a
single player game company 20 people
basically indie game dev studio and
we're trying to make a massively
multiplayer online game with a triple-a
experience to mobile devices piece
Mack you know like this is a large
undertaking so what we want to know is
how do we not become a publisher through
this as well how do we stay development
focused how do we transition from making
that single-player game to a massively
multiplayer online game and while we're
doing it we need to build a positive
relationship with our publishers because
we don't want to become a publisher and
you know we also want to develop and
maintain a strong company culture when
you're ramping up from 20 people to 50
people that's doubled the current
population that you have and if you had
a successful game a lot of candidates or
a successful product a lot of candidates
are going to come through that you would
have never had the opportunity to speak
to you before both good and bad so you
need to develop your company and not
just your software you need to do
yourself a favor and hire engineers not
programmers hi hiring engineers means
that you're hiring smart people that
solve problems hiring programmers means
that you're gonna hire people that they
can solve problems they can do a thing
but their main focus isn't looking at it
with an objective standpoint and saying
that's a problem I know about this tool
I'll go learn that tool I'll go do this
I'll figure out the problem you don't
need to worry about it producer you
don't need to worry about it publisher I
got this problem and here's that my time
estimate another thing that you can do
to try to stay small is don't be afraid
to contract work out if if you have a
thing that you need done work done like
IT work or operations work you're not
ready to hire one of those teams or you
don't want to hire one of those teams
contract it out but most importantly
never ever hire a maybe if you're hiring
somebody and you're interviewing
somebody and you are not 100% sure this
is a person that you want to hire
contract to hire them or just contract
them for a little while or don't be
scared to say we we don't need to hire
for this position right now we'll
postpone the schedule maybe a little bit
and then inform your publisher that
you're having difficulty finding the
right people to do the job when you're
interview you should interview for three
things
IQ EQ in personality these are the three
these are the three things that make up
a perfect employee it's not just good
enough to be smart enough you also have
to be emotionally intelligent enough to
understand why the reactions that you're
getting from your co-workers are the way
that they are you're never gonna learn
how to work on a team if you ignore the
fact that people have feelings
so you got to develop smart you got to
be pragmatic and iterate and you should
definitely leverage open source
you only have 20 50 people there's no
way that you're gonna be able to build
your own language your own framework
you're not gonna reimplemented C++ and
enough time the these are just things
that you cannot live for you have to you
cannot you cannot do you have to live
with the game but the way that it is and
provide an experience that's iterative
and you can do that by using the right
tools and the right patterns so for
example are we building a distributed
system well guess what Erlang is really
really good at building a distributed
system I know I'm familiar with Erlang
an OTP I wanted to give this talk not
just to you guys I'm sure that you're
familiar with Erlang and that it's great
for building distributed distributed
systems but this talks also for game
engineers that might not be in the room
that aren't familiar with Erlang that
are trying to re-implement OTP in C++ or
Erlang in C++ so when we started out I
knew this but some of the co-workers I
worked with might not have known this
and especially the people that we're
hiring on Earling is sometimes
considered a fringe language people
don't really know about it so we had an
anguish evaluation we looked at what
technology should we adopt should we
adopt C and C++ C sharp and mono we
weren't going to use net because we had
to run on Linux and I'll get to that in
a second we cannot afford to run a
Windows servers should we use Python or
Ruby or Erlang a lot of game engineers
are really familiar with C C you like
languages are super popular in game
engineering so one of us is that we
would want to look at is mono mono could
be a great choice for instance game
servers it could be a good choice
because we happen to choose unity for
our game engine which it's scripting
languages c-sharp and and that ties in
really nicely and if you have some other
programmers than already know C like
languages it's really easy to bridge
that gap so we chose c-sharp in mono for
a small subset of our technology
specifically the client and a couple of
the different servers that interact
directly with the client the other thing
is that Erlang has OTP and I evangelize
the
brought it at the team and said we
should really leverage this we don't
have the time to rebuild a distributed
system in the backend that we can just
pick up by easily adopting or laying an
OTP why would we want to rebuild that
that would be like rebuilding your own
web framework would you go rebuild rails
right now if you're just trying to make
some ecommerce website probably not you
might want to start with it and then
maybe later on figure out it doesn't
scale well Erlang luckily doesn't have
that problem at least in my experience
but you don't want to rebuild it just
like you want to build your own game
engine so we use unity I mean you could
do all those things but some of us have
 to do we can't be sitting there
rewriting rails because it makes us feel
good about herself so Erlang an OTP
specifically saves time a lot of time
especially when you're building network
applications some of the perks that
you'll get and I know that a lot of you
know this basically you can easily
encode and decode binary messages so on
a protocol layer you can form messages
super easily deep and super easily
deconstruct what that code looks like if
somebody else wrote it and it just it
tells you exactly what it's saying and
I'll show you an example of that in just
a little bit you can monitor and
subscribe to open sockets so if
something closes you don't have to set
this like thread up that's going through
and making sure the socket closed or set
up these different callback and handlers
you actually describe a call there for
mine scratch that
but subscribing to open sockets is
really easily easily done and then
routing messages between nodes is super
easy as well we have the system built
into Erlang called pidz and the pit
tells you what node it came from and
what process it came from we also have a
same threading model and it's crash
resistant but what I get told a lot is
that Erlang is not very approachable and
I'm talking to a roomful of people that
really like Erlang so this is a really
difficult slide to read I'm sure you've
heard this too the thing is that I like
her like I already knew or lane before I
came into this space but showing this to
my co-workers and saying hey OTP is
great or laying is great and then
showing them what it looks like they're
like not really sure man I don't think I
want to learn that so elixir had been
hit had been on the scene for just a
little bit I evaluated it when it was
zero seven or zero eight really early on
my friend Pat and I were looking at go
rust Erlang a bunch of different
languages just for fun to see what what
was out there
and the thing is that elixir was pretty
approachable and it has the same
concepts processes mailbox super trim
supervision trees pattern matching tail
recursion these are the things that are
difficult to learn or that they should
be considered more difficult to learn
and elixir has these same problems that
Erlang has all these same hurdles that
you have to get over but the thing is
that it's easier to get over it if the
syntax which doesn't really matter is
not a barrier so we started using elixir
0 9 0 and we asked herself is this is
this a risk and you know it's an
unfinished language it's created by some
really smart people but it's not done
yet
is this a risk well not really because
it has solid two-way interoperability at
least we didn't think it was much of a
risk you can use elixir code in in
Erlang and Erlang code and elixir this
is elixir calling early that's just the
syntax for it and then this is early in
calling elixir it's super super easy you
can call them both exact ways and I had
never personally worked with a language
that was as easy to interact with the
parent language so like closure into
Java yeah you can do it and opposite
yeah you can do it but this is super
super easy and you know syntax really
doesn't matter you know it I don't
personally think it does but the thing
is that it actually does to some people
so elixir syntax makes a little bit more
sense you know the it makes that Erlang
ecosystem more approachable for certain
types of people and when you bring this
to your colleagues and you want them to
be passionate and interested in
technology you don't want them to
immediately be repulsed by a thing if
they look at I don't personally think
Erlang syntax is a problem but some
people do and since this is about having
emotional intelligence and identifying
why your technology is not getting
picked up and why somebody would look at
like this amazing thing that they don't
need to write and I'm just turning ahead
to it like I don't need that I'll just
rewrite that and C++ you have to wonder
why would somebody do that you need to
have just a little bit of compassion
I don't mind ending all my sentences and
periods and semicolons but some people
really have a problem with it I don't
know why it's not that bad
there's also dev tooling in elixir which
is absolutely great come into a new
project you want to break make a new
project use mix it's a build tool
it creates compiles and tests projects
with for you the unit tests work unit
testing suite works really well you can
describe tests just like you could with
similar testing frameworks in Ruby or
c-sharp which both of them work pretty
well and there's a little bit on just
how to make a new project in three lines
you can make a new project as the
simplest of tasks should be done with
the simplest of commands and elixir also
has hex so we adopted this two years ago
about hex didn't exist but this is a
great reason to look at it now this is a
package manager for a lick sir kind of
like Ruby gems has I'm sorry Ruby has
ruby gems hopefully this can be extended
to Erlang as well I currently pull up
and you can see them right there most
downloaded cowboy cow lib ranch pool boy
Hackney those are the most downloaded
packages and those are Erlang packages
this would be amazing if this just
became erlangs package manager as well
so once we get past our technology
choices we have to say we only have like
20 people right now how are we gonna run
this thing we don't have an Operations
team we don't have an IT department the
only conclusion that you can have is to
live in the cloud and this is why we had
to stick with mono
because yeah Azure works and it's it's
pretty good but automating Windows
servers is a little bit harder
especially if you're using some of the
open source technologies that we used
and I'll get to those in a second but
with you live in the cloud you have
on-demand test environments and if
you're building a game and you want to
rebuild something that you're trying to
figure out like what the bug is or
trying for a performance and you want to
keep costs down you can build this test
environment in the cloud run whatever
tests harness it is that you want and
destroy it or you can expand and
contract while the game is running this
lets you stay small and then
evangelizing patterns was something that
I was talking about so DevOps is huge
you want to make operations every single
engineers responsibility doing that
helps you protect your culture helps you
to control your own live service I'm
making the game if somebody called me
right now I might get offstage and go
fix the game right now
it's that important to me I want to
control that I don't want to have
somebody else doing that I made the game
with a bunch of my colleagues but it's
very important and you don't become
beholden to a service organization with
the monopoly which sometimes is what an
operation is or an IT team can turn into
you get to operate with that lower
headcount so no operations who's going
to build our machines well it doesn't
really work like that anymore there's no
such thing as physical Hardware almost
anymore we have things like terraform
terraform is an open-source tool that
hasha Corp made same guys that made
vagrant it's basically an abstraction
for cloud providers just like vagrant
was an abstraction for a virtual box or
other virtual machines it allows you
describe your network and server
resources in code and then Bergeon
control those you can make security
groups of EPC subnets virtual instances
you can do a lot of things you can
control
Amazon easier with terraform then you
can control Amazon with Amazon's
interface which is not good so we got
the machines who's gonna configure them
chef is gonna configure them chef is a
great configuration management platform
basically you build these little modules
they're called cookbooks they describe
what your infrastructure looks like on
the node and then it turns the note into
things you want into it allows you to
describe resources of the node in code
so files directories services users
things like that so with terraform and
chef you can provision and bootstrap
those nodes and you did it on your own
you can do it at a single command you
have a brand-new test environment very
important though there's no such thing
as a DevOps team you need to evangelize
this technology to your fellow engineers
and bring them on board if they think
it's hard figure out why this is super
important to build the engineers that
you have to understand not just how to
build a software but also how to operate
this in a live environment especially if
you want to have a small focused
development team you need to foster
adoption for your technology choices
make on-ramps those team
and create a safe to fail environment
create and evangelize patterns and
standardizations and allow for that
collaboration I supposed to delete
illusion of choice there's there's a
choice
maybe whoops and then code reviews are
huge right everyone in this room
probably knows this but these are there
to assist with learning try to keep a
positive tone in those code reviews stay
away from an authoritative tone you
already know that you know this
technology you really don't need to look
at a brand new engineers chance at
making some addition into Erlang and
immediately telling them where the
spacings wrong and where he forgot this
thing and didn't test this just help the
guy out get him make an on-ramp get him
on board he's gonna improve you can help
him clean up later make issues in the
issue tracker but definitely do yourself
a favor and avoid anything about syntax
or style in these discussions those can
be had later on no one is trying to
learn cares about your syntax of your
style so that's the end of the culture
side of this the rest of this is all
about technology we can now have the
marshmallows of the shitty bowl of
cereal so this is about architecting
architecting an online game service so
there's three components to an online
game typically you have a game client
you have game server or servers and then
you have something called a service
platform the game clients job is to
render the game basically for you and
communicate to the servers it's an esky
double on your device like an exe or an
app draws an image every 30-plus frames
per second that's what makes you think
that you're playing a game and it sends
and receives the data from the game
server then there's game servers those
simulate the game they negotiate
connections the clients typically the
servers or authoritative so that way
clients can't hack server tells the game
clients yeah maybe I believe what you're
doing and then you kind of negotiate and
they also communicate back to this thing
called the platform the platform is
typically game agnostic a good platform
is game agnostic it needs to be highly
available so multiple games can connect
to it and it's basically the extinct
so when you think you're playing a game
and you're connected to a game
you're not connected to one server and
as you transition between different
zones in the game or different
experiences you might be transitioning
between different servers that are
simulated in different parts of that
game and the platform usually provides
services like off chat presents
leaderboards guilds player profiles
there's a bunch of them and I'll
actually go over a bunch of those at the
end of this talk so our platform at
undead is called tubes which is a great
name it's basically a giant distributed
platform that sends data and
communicates the game servers so when
we're written when we were writing this
we were deciding on the technology
choices this is mostly written elixir
mostly meaning 90% there's three servers
or so that are written in c-sharp and
they were really early on when we were
deciding is are we gonna be able to
foster adoption for elixir or Erlang or
do we have to stick with a C like
language to make sure our colleagues or
our are able to contribute as well the
good news is that we were able to foster
that adoption and there was no problem
at all I will get to that in a second so
we're explaining we were exploring
different language choices and mostess
is elixir so then you figure out where
do we want to start this is a first
online game we just got done with a
single-player game you know we need to
manage our relationship with our
publisher we need to figure out what
what are we gonna what are we gonna come
up with to show them that we're on the
right track you know you need to
basically come up with something called
a proving feature so we know what the
architecture this game is gonna look
like they're pretty they're all pretty
familiar when you're making a mess
winged multiplayer online game it's a
couple different architectures you know
now in 2015 we know the mistakes that
people made in the late in early late
90s early 2000 so we don't architect
games like that typically anymore but
it's still hard there's still a lot of
things that you need to do and normally
people are not open sourcing and not buy
normally nobody open sources their
platform they either sell it and it's
maybe not very good trust me I would
have gone and bought one if I didn't
have to write it myself because I'm in
the business of trying to make games not
in the business is trying to make cool
technology they can be the same thing
but it's not just making cool technology
for the fact that making cool technology
so the proven feature that we wanted to
use is
as you guessed a presents presents
updates and chat and things like that so
basically you want to send president
updates or whispers from one play or
another this is where actually most
people start when they make an Erlang
application for the first time I
actually set next to Kevin Smith a
little bit ago in an in a in a talk and
said hey Kevin I think I've told you
this before but you taught me how to
make how to write Erlang by writing a
chat server this is like the hello world
of an Erlang application but it also
happens to be the hello world of a game
platform this proves that you have the
ability to send a message from the
client through the game servers through
the platform route them all the way back
out to the other person's game server or
whatever they're connected to and back
to the other person's client so this
doesn't sound super cool you know like
when you talk to your publisher they
probably like great chat mmm-hmm yeah
we're trying to pay you to make a game
here not a chat server I have a AOL
Instant Messenger and that sends chats
just well but the thing is that this is
a super defining feature that you have
the platform right and this lets you
test scalability at least on a small
level where you're sending messages you
know small messages so you want to make
sure you set those expectations with
your publisher and help inform the
milestones so they might say we need the
to know the game's fun in a month well
that's probably not gonna happen
especially because an online game
because we can't even connect to the
game servers at that point so you build
things in pieces so when you're building
the platform what we basically started
with was four main players the protocol
the route server the lobby server and
the chat server and I'll explain those
in just a second then there's a
supporting cast of servers as well
it's called spawn matching version err
and they all need to exist before you
can kind of stitch together a platform
I'm gonna hand wave this slightly
because when we were developing this I
obviously things have to come in pieces
only to server to network server
programmers were working on this so we
had to build things and fake it as we
made it
but I'll describe it as the way I could
I didn't keep a journal unfortunately
I'll describe it the way that I remember
it so we started with the protocol layer
mice
self my friend Pat who's another network
server programmer sat down decided how
our undead server was gonna talk to each
other well we knew they were gonna speak
TCP on the platform at least game client
speaks reliable UDP and we were gonna
send binary messages either you know we
were like are we gonna send JSON are we
gonna send oh maybe we're gonna just
talk HTTP you know how are these gonna
speak so we'll go over a little bit of
the undead protocol server message
anatomy basically so every message in
undead labs server communication has a
32 to a 96 bit message envelope it also
has a message ID that has a fixed max
length that describes what message this
is that you're getting and a variable
body say variable variable size body
with a fixed max length so you can't go
over a particular size of a message as
well the message envelope is in three
parts they're 32 bits each you have
header intro routing info which is
optional and transaction info which is
optional as well the header information
contains one bit for routing information
which says you're about to get a message
that you're about to get another part to
the envelope which contains 32 bits of
routing information another bit that
says you're about to get 32 more bits
that contains transaction information
four bits are reserved for whatever we
need six bits of the message length
message ID length which is how long to
read for to figure out what message this
is and then the body length is 20 bits
will tell you how long the body the
message is going to be so this is what
describing a header binary looks like in
a lick sir
just like Erlang it's super simple and I
actually wish I put the c-sharp code in
here to show you the difference but it
probably wanted to fit on the slide like
this is super easy even non-technical
people can look at this and say okay on
the left this is pattern matching by the
way I think everyone here knows but for
viewers later on the left side is
describing a 32-bit message header field
and the right side is packing in a
routing info one bit transaction for one
bit the reserved bit for basically what
I just showed in the last
this says clearly in one line in my
editor that offer is way more than like
what at 40 40 character lengths on the
slide that's the binary pattern matching
it's so much more intuitive and bit
shifting to me and when I show this to
non-technical people they're like I
understand exactly what that says
especially engineers who don't have a CS
background you don't need to see us
background to be a good engineer and
engineer solves problems you need to be
a smart person that can work well with
other people and not knowing how to do
bit shifting is not a prerequisite to
right protocols if you can do binary
pattern matching and you could read what
was in that last slide you can write
complex server programs that communicate
with binary data so the next thing is
the routed messages if one of the bits
was set in the header info you'd be
getting routing information this is how
the routing server figures out where to
send the message so it just gets the
peak at the envelope so the routing
information which is optional for only
servers that support routing contains 22
bits for the route hash and then 10 bits
for the protocol ID the route hash is a
key it's the thing that we figure out
how to how to where that thing should go
where that message is supposed to go and
we'll talk about routing a little bit I
don't want to spoil it and the protocol
protocol idea is what service this is
talking so chats like protocol one-off
is protocol to whatever right each
service has a different type of protocol
fortunately these words are a little
overloaded I didn't this is actually
what they're called in the code and we
all kind of know what it is but they
could be named a little bit better too
especially because elixir has protocols
as well and this is what a routing
binary looks like just like the last one
super easy so the last thing a part of
the envelope was transactional or
non-transactional messages the
difference is basically transactional
messages complete when a client receives
a message with the transaction complete
flag set so this is when I'm sending you
a message I'm a client and I'm saying
login and I want to know when I'm done
logging in so I'm telling you this is a
transaction you definitely have to
respond to me
so the client either gets a message back
with the transaction flag complete set
or it gets back a message that says this
is partial this is part of the response
pull this up this is part of what I'm
going to send you and the client will
automatically time out for long-running
transactions as well so if I send you a
message and I don't have a response a
partial or full or this thing called a
transaction extension then I know
timeout that guy's dead to me like
forget that maybe I'll issue it later
and like I had mentioned the client can
receive a partial message to build a
complete response so part of login would
say I login and you send me all my
friends from the chat server and then
you say oh now I'm done and now I've
logged in with a pretty complex message
the transaction post optional one bit
for response one bit for partial and
then transaction ID is the last which is
30 bits and it looks just like that also
super simple again something that's one
line would be much more if we're using
bit shifting so the key to this is to
make it easy make it easy to find and
handle new messages all the protocol
messages right they were really easy to
understand even for non-technical people
and one of the things that's really neat
about elixir is that we have this nice
macro system macros for some people are
taken right leave it but this clearly
tells me and this is pseudocode well
it's actually it's this is real code is
what the final protocol message looks
like but it's taken out of a real
protocol file that we have and this is
defining what it is to send a whisper
within our chat server say chats
protocol ID one whisper ID a whisper
send is the message ID that we were
chatting about and then those are the
fields and bodies and then encoding and
decoding has a little bit of validation
around that as well
all this this one message gets all that
just because of macros which I just
talked about so the next vid is the
lobby server so we talked currently
about protocol this is what I was
working on along with a routing server
while my friend Pat
working on the lobby server which is
written in c-sharp and we are trying to
figure out which technology we should
use this could have been written in his
licks in elixir as well did not matter
and he was writing the protocol
implementation in c-sharp the lobby
server is common to a lot of different
games this is the thing that holds a
persistent connection for a client so
when you connect to our service you hold
this the entire time this is the thing
that says that your clients still there
and then you use this to negotiate with
core platform services core is like off
or chat or presence it's things that you
need regardless of what server you're
going to be connected to it's kind of
like a nebulous term and this
communicates directly with the platform
gets a connection that's suitable for a
game server so you're like I want to
join the moonrise and I'm joining a
combat server this thing will figure out
how to get you there another thing about
lobby services they're multi tenant so
this has one connection back to the
platform but multiple people are sharing
that connection so you need to keep that
in mind as well and this connects to our
routing server as a client
the routing server is a ranch listener
and basically it's job is to peek at the
first part of the envelope the first 32
bits that it gets and it says is this
routed message no throw that out this is
around a message yes and then it peaks
at the next fit and reads the routing
information it says oh do I speak this
protocol I don't know what part of call
10 is so then it'll throw that away but
if he knows what rep chad is it'll say I
know what that is and then it'll look at
the message ID and say do I know what
whisperer send is yes or whatever the
other one is and know it'll throw it out
once it figures out a message that it
understands it tags a message with the
acceptor Pig for the listener sorry the
connection handler the listener starts
connection handlers and that gets passed
through the entire system so at any time
when you want to respond to that message
any node in your entire cluster it's
super easy with our leg or elixir you
just send a message back to that Pig and
Erlang for you is going to route the
message all
way back to that except there and then
send the message back to the client in
the router also does things like
disconnecting misbehaving kind
misbehaving clients that are assigned to
tune too many messages or like
connecting and then hanging on but not
doing anything you know like flooding
the connection pool this is the route
listener it's super basic this
demonstrates the interoperability with
Erlang I didn't need to go right branch
I didn't have time to go to right ranch
trying to make a game not right ranch
and you get to the leverage it in elixir
it's super easy you just start a brand
new listener you pass the route
connection handler you give us some
configuration information and you're off
to go the ranch documentation is perfect
so I'm gonna talk a little bit about how
these connections are established and
how they work so the client connects to
the lobby client connects to I'm sorry
this is client connecting the lobby of
what the lobby does client connects to
something called a version ER the
version who needs to identify for you
where the appropriate lobby for your
client version is so version er talks to
a thing called match server this is one
of the supporting these are some of the
supporting servers I was talking about
earlier they match for the location in
the appropriate lobby match spawns or
finds you a lobby server that's already
existing and these are c-sharp instances
that are spread out through the cloud
and then the version ur gets a response
back and caches it if you already had a
cache response somebody recently
requested one the version already knows
how to send you somewhere
the version ur tells the client where
the lobby's addresses the client
connects directly the lobby this is how
we can do things like allow you to not
update your game and connect to the
cluster and still play but you're only
playing with people on that game version
and when we want we turn that off if
anyone in here played Guild Wars 1 this
is how the game worked and if anyone
here has a chance to play moonrise which
is in closed beta right now this is also
how the moonrise works and then once the
clients connected in to lobby how do we
get into a game so the client talks to
lobby lobby ask match says I want to
join a game match says ok I'll spawn you
one of appropriate game type if one's
not running
and for your appropriate version match
we'll talk to lobby with the address of
the game server and something called a
reservation token which is your security
token saying yes he went through the
appropriate channels to now join this
game lobby will talk to client with that
and client connect the game server with
the reservation token with a secure
message so lobbying game of both clients
of the platform specifically both of
those are talking to the routing server
that's how we're figuring out where to
send messages to the different services
so let's quickly look at logging in and
whispering in chat this is not a super
awesome feature to chat about but again
this is this is a proving feature this
says dead platform works and it's
scalable first thing we have to do is
route the message this is the animatic
the anatomy of a protocol message this
is vlog in a couple slides back I showed
you whisper sent so we're gonna
formulate a message which is basically a
map or Swizzle iya struct in elixir
which is a name type of map it's
protocol ID 1 message ID of login the
except there is what connection handler
you came in from the router your account
ID my account name and account tag name
and tag or the way that we can allow you
to call yourself Jamie you know 9999
times you know there can be many
different versions of Jamie on our
cluster and we use that to send to any
known chat server and the chat servers
have these things called dispatches
dispatchers on them so the routing
server gets a message
Ford's it off to the appropriate chat
server the chat server has a registered
process running and it has a handle
message callback which matches towards
the login message that we sent it and it
does a little bit of work this is not
exactly how login works it would
unfortunately it's a little bit more
complex to show on the slide
but this is a pretty good basic example
of what it would look like to login a
user and respond with yes or log it
respond with something
your band and netdispatcher is nothing
but our usable behavior so I'm gonna go
back a slide really quick to show you
that but use netdispatcher
that's giving this module some specific
amount of functionality and it's giving
us access to or saying we're gonna
implement handle message callbacks all
you need to do is use net dispatcher
this is gonna create a register during
process when you start it it wants you
to implement message handle I'm sorry
handed message one callbacks matching
protocol messages you can define as many
as you need to and what this does is
quickly dispatches to worker processes
which run the matching handle message
callback I showed you that in the last
slide I glossed over what net errors
were a little bit there's a success in a
band message net errors are actually
kind of named poorly they actually
should may be called net response but
both myself and the other network
programmers worked on a game that called
them net errors so we called them net
errors over again but their best
basically just a special type of
protocol message that contained two
parts a code and a message this is
something that will propagate to a
client if you ever played a blizzard
game or Guild Wars or moon rise
basically you have this code and message
that help customer service figure out
what went wrong when you were doing
whatever the thing that you requested
for was so this is the login and
subscribe hand in it and handle info of
the user process so basically all we're
doing is going through taking that
message starting up a president's feed
saying oh this is the user that's
logging in i've emitted a little bit
information here like we use ecto for
example to store the user information we
pull it out of there I just wanted to
fit this on the slide and give you an
idea and then we immediately timeout and
then we try to complete our login and if
you recall I said well sing you down
some information well here we're
broadcasting our information we're
broadcasting our presents to our other
friends we're saying hey I'm online and
it's important to notice that I'm
sending self to everybody else once
during an ur langland you get to use
pidz
and I get to say I just came online and
I get it's so much easier than dealing
with protocol messages but which are not
complex either but you I could say I
came online and then wherever that guy
is in the cluster I'll we'll get to
routing he knows oh this pig came on
this is what I do with it I monitor it
if that person goes offline I tell the
client that person went offline or he
came online
I tell the client that person came
online and if you ever lose the
connection to the lobby because in the
previous slide we're monitoring that
socket you get this down message and you
can immediately tell everybody oh yeah I
went offline no big deal
terminate so presences is that's how we
implement presences so you add a
presence feature to the user attempt to
broadcast when you come online handle is
removed at the process is shut down and
shut down the process to promote the
primary connections turned off the
primary connection is the route handler
that we tagged all the protocol messages
with so prior when we were logging in
and completing our login transaction you
can take that acceptor off and monitor
it and that's how we figured out in the
previous slide if that person lost their
connection and remember that multi the
lobby is a client to the route server
which is multi-tenant so it's just one
case that somebody could go offline you
could go offline without the lobby
server killing your connection too so we
have to handle that case that's not in
this line this is what setting up
residence notification looks like pretty
simply you're encoding a map or one of
those strux and we encode it into a
message and we cast it off to using
polymorphism whatever the handler that
we got which was from the con handler
I'm a tuple that says hey I'm replying
or I'm sending you a message and we just
cast them off like this
and this is forwarding that presents
notification in the client so this is
the con handler that got a message to
say oh I'm sending this message it does
a little bit of information to record
how long it was taking to respond to
messages it sends the data down to the
client and then at the very end we
figure out a time out based on the last
time we heard somebody because the
client pings and says I'm available and
then if we have a hanging connection
week we kill them so this is really
heavy stuff and I'm sure that going
through the slides later on will help
out to digest it but this is the best
representation of a complex code base
that I could show you written an elixir
so that's the beginning of what we had
and now you have to figure out how
you're gonna distribute this all out so
when we first start off we just have
everything running on one node it's kind
of sudo like I'm routing this message
here I'm just kind of like sending it to
a process on the local node I need to
figure out how I'm gonna get that
message to somebody else and with a
massive amount of players how am I gonna
have that much data we do that through
something called sharding sharding is
taking data and putting it into buckets
so we pre shard our data into a X amount
of buckets the buckets are basically
Postgres schemas and ecto sits on top of
those in a literature application
services shards a buckets and then it
broadcasts those shards to routers and
the routers are like whole application
server X knows about shards 1 through 10
and then we can internally route
messages just as easily as we can rest
it routed is with the route the route
servers con handler because you get it
for free with Erlang almost we route
messages to an application server
servicing the desired shard and we can
hide the complexity from other engineers
with something that we call neck call
and net cast basically we were
piggybacking on these net dispatchers as
well so if I neck call or net cast I
will spawn a brand new process on a node
to service the thing for me and this is
what the gist of what the interface
looks like for net basically we're
making a call our casts are telling what
protocol what the route
is what module function arguments that
we're trying to run so this looks just
like Jen server call or cast but what
this is saying is that I want to route
this through the routing server and go
to a particular type of server and tell
me and do the work and then come back to
me or cast is you know just like go
ahead and do it
this was super important to do by the
way because connecting over a hundred
Erlang nodes together they're fully
meshed and you can't you can't go over
maybe a hundred nodes or so with this
model the only nodes that know about
each other
our route servers and then all the other
nodes connect to their out servers as
hidden nodes so a chat server doesn't
know about the other chat server if a
chat server wants to talk to a chat
server or an auth server and has to
route a message through the route server
send it there and then come back and we
can piggyback the dispatchers just like
we had the c-sharp servers or something
else connecting in this is basically
what whispering somebody looks like with
net cast or net call the net library is
not open sourced we're looking to try to
figure out how we can make it more
generic so with spring you're just
sending the cast to this module that
function those arguments and actually
that function lives on the exact same in
the exact same module all the chat
servers know about the code but they
don't all know about each other in tubes
we have two types of routing we have
deterministic routing and that's we know
what shard the message goes to then the
other one I'll get to in a second
basically the message is either gonna
the the route key either contains the
information and in this case this is how
particular entities in the database have
an ID that contains the shard ID
this is Postgres function which
basically 64-bit integer 23 bits of it
is time sense whenever to our current
epoch time now to our epoch 13 bits is a
sequence ID and the last 10 bits or so
is the shard ID I actually think I
counted that wrong but
doesn't matter so this allows us
basically to generate a thousand 24 ids
per second per schema or per shard and
we actually took this from Instagram
this is how Instagram generates content
on their servers as well and in Erlang
using binary pattern matching you can
just rip the shard ID out extremely
easily you don't need to screw around
with with bit masks or like super easy
just with pattern matching the other
type of routing that we have is called
randomly deterministic basically we
don't know what shard the message goes
to but it's always going to go there so
if the piece of content that we're
routing on the route hash doesn't
contain in the last 13 bits or whatever
the ID the shard ID we can just figure
out what it is by hashing and modding
the value so this is a very basic hash
in mod function that takes whatever the
value is and it's incomplete I've ripped
this out of some code but this is
assuming that you're always gonna pass a
binary down casing it and then using
that if you want a hash function to hash
a binary and then modding it and
figuring out figuring out what shard
that's supposed to go to because we have
a fixed number of shards which is the
divisor 128 which could change the
messages is always gonna go to that
exact same place I don't know what what
server it's gonna land on but I know
that it's going to land on the same one
every time this is a fill evie one a
implementation it's not very interesting
but that's what it is
you could read a little bit about it
basically F and V one a hashing is super
fast and pretty reliable against
collisions so when you support when an
application supports these shards it
needs to tell somebody about it
he's a tell the router and say hey I'm a
chat server and I have 20 shards shard 1
through 20 and we have this thing called
a shard directory that runs on every
router and when we go to try to route a
message we peek into our shard directory
and we say which node service is that
shard
and that application that brings us to a
thing that we open sourced as Undead
called discovery and discoveries job is
to automatically discover nodes and
connect them together
Erlang nodes we automatically discover
nodes using something called console
which uses a gossip protocol to tell
each other oh I found this I found this
this is where this person is this what
this person is with a little bit of
metadata discovery is broken into four
parts
a polar a polar event handler and a
heartbeat the Polar's job is to ask for
a particular type of service from
console all the application servers are
like I want to know where the router is
polar event when I find that thing what
do I do the handler is what do I run
once in a particular type of event is
hit and then heartbeat tells console I'm
still alive I'm still alive so that way
the router knows to route messages to it
or to tell us there's a problem this is
what the supervisor looks like for chat
or any one of our applications start a
worker it's a polar we're looking for tu
route which is the representation of
whatever out server looks like and we're
gonna make sure that we run the route
connector handler if we get a node
connect event when we get a route
connector and when we run that we're
gonna tell the route server what shard
IDs we support we're also going to
register a heartbeat route connector
when connection is made registers
registers the service shards that you
particularly service with that shard
directory and it fails it'll continue to
try to registration continually try to
register eight register itself if
somebody already says they service that
shard then a much bigger failure happens
and that's that connecting node is
basically told to stop it discoveries
made in part specifically because of
console but it's a huge thanks to Erlang
because when nodes disconnect we're able
to monitor them and then automatically
reconnect as well so if there's a small
service blip we don't have to go through
all the console again basically we
monitored that node and then we
reconnect and we say we're back together
and again these are all hidden nodes so
we're connecting into these routers that
only know about those each other and we
don't create a fully mesh network and
the last bit of this is our game servers
game servers are instance in distributed
the game servers are done dead right now
on moonrise are written in C sharp but
they could be written in any language
and these are again clients the platform
we have two types of servers right now
one is the world server this thing X is
the town or the quest hub this is where
you see other players in the game that's
my actual character that I just took a
picture of it's pretty attractive and
chat and store our services that this
world server it would be servicing the
other one is a combat server this is
basically whenever you get into combat
so you player versus player or play
versus AI and again you don't realize
you're changing between servers like
this is all pretty seamless you just
think you're connected to a game that's
because you have a persistent connection
to the lobby and then the match to spawn
servers figure out we're gonna send you
for combat or or world when you're
switching between the two and then this
is super quick these are some other
services that we have I know that I'm
running out of time and we kept your
hair pretty long but basically tubes is
a back-end that supports things like off
chat a number of different services and
these are some services that common
games have that again our game agnostic
you'd want these for a lot of different
games we have an admin tool
it's powered by Phoenix ecto and ember
Jas it's basically in Miss trade of
console for game masters allows you to
gift items kick players band players
look at how much gold they have look at
some of their metrics it's basically a
view of what a player looks like you
need one of these in almost every game
that you make other thing is called a
catalog this thing basically just looks
at data that came out of the build
server gets stored somewhere continually
downloads it and says these are the
things that we have available for sale
that should be in the App Store or in
steam or something like that last and
then we have fulfillment this is the
thing that actually mediates the
purchasing from the client to steam or
iOS or Android or Kindle all
transactions are item potent this is
super important that realize because as
we send messages through
film it and say I purchased this we
don't want to retry that I'm sorry we
might want to retry that but we would
want to replay it if we replay something
then we might charge somebody more than
one time or we might give them too much
like that they did not actually purchase
well we do with this as we deliver their
goods to something called a mailbox
mailbox is an asynchronous message
storage if you were played World of
Warcraft or a game like that you've seen
what mailbox in game it has attachments
it allows you to deliver goods to
players we use it in gifting purchasing
and in the future if a game wants to do
it sending messages and items between
players we have a notification server
this is the thing which allows you to do
push notifications on mobile devices a
vault and the vault is basically what
all the players storage is the
persistent storage this is completely
game agnostic but it control it stores
your player data your basically your
persistence layer storage for your
character your inventory and then
eventually shared storage for guilds
when we implement some guilds and all
these services are exposed to the same
API that I described today these are
some fun additional problems we had to
solve like building OTP releases for
elixir two years ago or a year and a
half ago it's still not the best
experience but it's way better than it
ever used to be and once you've got it
you never have to touch it again
the account name and tag thing was
actually really cool
I brutally hacked schema support and
ecto data laughs that'll eventually be
there for real and then game agnostic
item fulfillment was actually pretty
cool too this would be a huge list but I
just wanted to in case I had time give
you some talking points and then what
we're gonna do next is basically
automatic ID migration allows it
expanding contract and then seamlessly
move shards to different nodes that way
player we don't experience an entire
service outage when we want to add new
machines automatically shard V rekeying
or rebalancing which will allow us grow
the shard from 128 shards if we need a
sharding from 128 if we need to we
probably won't for a very long time and
then additional features and then this
is my contact info so that's about it I
know I went over a little bit thank you
so much everybody for being here
do we have any time for questions all
right so I'll be available absolutely
thank you so much everybody</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>