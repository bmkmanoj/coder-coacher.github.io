<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2015 - Lars Hupel - Functional Mocking | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2015 - Lars Hupel - Functional Mocking - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2015 - Lars Hupel - Functional Mocking</b></h2><h5 class="post__date">2015-04-15</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/kHEriteFMb0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thanks for that introduction and I don't
speak Polish
but as a little gesture towards our
local accommodation here I've chosen
some color set representing the city
colors of Krakow I think it's a little
bit more darker the blue but I need to
have something readable so I hope you
can I hope you I hope you can excuse
that a small mistake all right
let's dive directly into this topic so
functional mocking presumably all of you
know what mocking means in
object-oriented programming picture of
hands so it's not about making fun of
the code also sometimes it feels like it
but what is the actual definition of
mocking so here's what wikipedia says
about mocking in object-oriented
programming mock objects are simulated
objects mimic the behavior of real
object in controlled ways and that's
kind of funny because it's some sort of
overly specific definition because it
already says object or any programming
right here so what Who am I to talk
about functional mocking I mean there's
no such thing with various before little
so what does smoking actually look like
so I've chosen some example from the
front page of Stahl amok which is a
popular mocking framework in Scala I
mean walking is not that popular in
Scala but the most popular one with
Scala mode and let's let's say you're
writing a class for turtle graphics and
now you want to now you want to check
whether your function which uses the
turtle would use this turtle object so
this raw line function is supposed to be
implemented on top of turtle and now you
want to test whether this draw line
actually works correctly then you would
create a mock object and tell it well I
expect that I'm this function called set
position then calls forward and then
calls get position and then you say what
I am expecting these arguments I'm
expecting that argument I'm expecting
that return value and then you call that
function and Scala mock will actually
try to figure out if all these function
calls happened in the right in the right
order in the right way and that's
sometimes you can see it as a
generalization of unit tests and unit
usually test the return value and here
you can also check some intermediate
results or some intermediate calls so
that looks quite nice in theory but why
not why don't we mock so here's what
Martin Fowler has to say about it have a
look and this is a very fundamental
problem of mocking because it is tightly
coupled and once we change the
implementation of the mock of the object
you're mocking then you have to rewrite
all your tests and you have to rewrite
and significantly for example consider
your making some optimizations in your
code which drastically reduces the
number of calls you're doing then you
have to go through every single to every
single test which use that function you
have to rewrite and you don't have to
just change two values in there so just
tweak them a little bit but you have to
rewrite the whole set of function calls
and what's even worse if you look into
the implementation of these kinds of
mock frameworks you can look at Scala
mock you can look at a mojito and
whatever they are called and if you
actually open the source code you will
find yourself like this it's kind of
like an adventure game with finding new
meta programming facilities on every new
file you're opening and so that's why
that's why in the functional world this
concept of mocking is not really popular
we don't do that much reflection we
don't do that much meta programming we
just try to do it was functions so back
to my original point functional mocking
there's there's no such thing really so
I was in the during research for this
talk I went through a couple of Google
searches and typed in like Haskell
mocking framework functional mocking and
there were a couple of Stack Overflow
questions on that and basically for
every single of these questions jaws was
don't do that like there's no mocking in
functional languages just use a high
order function or something like that
and I mean that's kind of ok if you
already know functional programming but
if you come from somewhere else and
don't know how functional programming
works that's not really good explanation
because I
I mean if I thought if you asked me how
do i do mocking in functional
programming I answer well don't do that
there's no such thing then you still
don't know how you would achieve the
same result without mocking so instead
I'm going to talk about a couple of
techniques which are unique to
functional programming languages and
these techniques combined avoid need of
mocking altogether so basically these
are techniques to reduce the coupling in
your in your program so the stock could
as well have been called functional
decoupling and not functional mocking in
that sense so what are these set of
techniques so refer today that
functional programming will be fine in
another talk I don't quite agree I think
there's actually a good definition but
not everybody agrees on the definition
so I'm giving going to give you my
definition here and I think this is
these first three points are very
important for functional programming and
the fourth one is kind of a corollary to
that so the first half is separation of
data and operation so we can define data
types in a different module somewhere
else and the operations can be
completely independent of that so we can
have them in separate modules and you
can swap out operations you're not like
in a knot like in an object where you
have a fixed set of methods you can just
always extend your operations every time
and we even have ways to deal with
extension of data so we can even add new
cases to data types in several languages
and in other languages we are tricks
together also we have parametric
polymorphism you sometimes known as
generics so abstracting over types it's
really a pervasive in functional
programming so it's not only in Haskell
but also in Scala and in all those other
languages that we always try to write
the most general type for function and
during that we actually notice that we
don't care about the type of the element
in list it's just for any type of list
also high order functions so what no
matter which source code file you're
opening there are chances that you will
find a high order function in there
because it's still tremendously useful
and as I said as a corollary from that
we have lightweight interpreters and
this basically means we can define
domain-specific languages all the time
and in
operating these domain-specific
languages really easy so if you have
ever written a parser for something you
have already done that it's lightweight
interpreter you're passing something
into a data type and then at the end
you're doing something else with that
and actually parsing and you're having a
data type for some expressions it's
going to be my running example today so
here is a data type for arithmetic
expressions those really simple if you
don't greet if you don't read Haskell
syntax don't be confused by that it's
just you can just read it as an
expression is either literal with an int
value or it's a variable which has the
true name of the string or it's the sum
of two other expressions so there's
really nothing complicated here and once
we have a value of the type we can ask
the system to evaluate it and of course
we have variables so we need to assign
some values to variables and we do read
loosen map so we just say we have a map
from string to int and we get back not
and plain in but maybe in because the
map might be undefined so if you're
using raw real calls that and the map
does not provide the key was called
which is called said then you would want
nothing back or maybe an error or data
type or whatever but doesn't really
matter just not a plain int so that's
the basic idea so this was really more
in this cat is completely unimpressed by
that you're probably written that a
thousand times over and over again so
let's leave that up a little bit so
first the first thing you should ask
here with that code is why are you using
a map
I mean map is a pervasive library in in
Haskell but what if I'm having what if I
want to specify another function so what
if I want to specify something which
computes while you're on the fly like
the length of the name of the variable I
mean go crazy do whatever you want
so in essence a map is just a function
from a key to maybe of its value of the
associative value and we can just
replace it in the first step so we can
say instead of taking a plain map we
just have a string to maybe end and
that's a higher-order function over here
and this is really one of the first
steps you should do if you're writing a
library and you're taking a map from
someone else and your library's not
really about maps and you should ask
yourself why am I using a map here it
could just take it as a function and
that's all nice but we're still not done
so next thing you should
why am I talking about integers here I
mean those are the Machine integers
that's not really useful they overflow
and why am I not letting to use a decide
which kind of literals I want
so let's generalize so now we have our
first Prometric datatype in this talk so
we say we have the B Givaudan type
parameter which gives the type of the
literal and of course we have to add
this a every time we use it and for the
evaluation what we're saying now is we
can evaluate any expression of type a as
long as we know how to deal with it as a
number so numbers the type class and
Hasker which specifies the common
arithmetic operations like addition
subtraction multiplication all that
stuff and convert different conversions
and what you're saying here is that we
don't care about this a we just care
that we can add it and that's really all
we need because now we can know we can
now the use you can just use floats or
the arbitrary size integers or whatever
and basically up until this point the
code has not changed at all I mean it's
still exactly the same code we had
didn't have to change anything between
here and there because the plus
operation haskell is already earth
already generalized to or anything
numerical okay one step more why are
variable strings
I mean string is a data type which
contains an infinite amount of values so
you could have any string for example
the empty string but no sensible
programming language would allow an
empty string variable name or whitespace
well unless your program in whitespace
but you usually want some different type
for your variable names you want a
simple type which only contains
alphanumeric characters or whatever it
doesn't start with and doesn't start
with a digit whatever and you don't
really want to have represented as a
string you want to represent it's a
different type because it's also what we
do all the time we take we have a whole
set of values like integers and then we
partition it into different spaces or we
take a subset and put it into new type
so that we don't confuse the whole
values and that's what we're doing here
as well so we're saying
okay just generalize it here as well so
we give a new type T for the name of the
variable and replace all these string
occurrences will Steve and we also
didn't have to change any code here it's
naturally already there Jesus we didn't
use anything specific about strings just
the way we didn't use anything specific
about integers here okay one more step
why are we always even using maybe I
mean we could just write it with any
kind of monad because let's assume
you're having your variables are in the
database and you want to call your
database to get to Nate with the value
of the variable so you wouldn't have the
maybe there you would have an i/o of
something because you're using Haskell
so your functions up here and the
important bit here is that also you
don't care about maybe because that
maybe just came from here that's why
that's why you got the whole maybe in
the end here but you are not using you
do not you do not return nothing by
yourself you just take whatever this
function gives you and return it so we
can just generalize it to any monad and
this cat is totally confused now because
like we started with simple design which
everybody could read who has no idea
about Haskell and now we have something
which uses donate and whatever like why
are we even doing that so here's my next
slide why does complexity why are we
even bothering to do that I mean the
first thing already works I mean if
we're with the only thing we're working
with int and strings we could have just
used the first version and then
generalize it and there's this acronym
called yakhni you ain't gonna need it
and here's the definition by Ron
Jeffries always implement things when
you actually need them never when you
just foresee that you need them and we
just did exactly the opposite we just
felt like what could you possibly want
about this library and let's just get
general eyes in a way that we can
actually that user can actually do that
so from this point of view it was a
terrible idea but it's actually a good
idea because we also gain something by
abstraction or num we have actually
assurance if we don't mess around with
the value so we can't just insert a null
or an a.1 or whatever in the
and the caller knows that only the num
types of influences the behavior so we
do not fiddle around with develops
ourselves we just take that back with
the num type class gave us and it's the
same for the abstraction of ammonia so
we get uniform data access we can use we
can plug in maps there we can plug in
the database lookup and we can't even
read from standard input
I mean who who stops you from doing that
you can just put an arbitrary operation
as long it gives you as long as gives
you some IO into whatever I all flowed
or don't care and if you take the status
v we have just defined with these two
parameters and you register some more
instance of course for example you can
make it reversible you can make it a
Monat itself and you can even gain some
more from that so for example let's say
you have to write these three functions
and these are really common if you're
writing some sort of small DSL something
sort of expert if you're dealing with
situation so for example this function
it takes an expression gives you all all
variables which appear there so example
if you want to make that code analysis
you want to know if the variables are
even XS so you have a set of variables
and you want to check whether the in the
words of units in your in your
expression are subsets or if like which
relationship are tied and then you want
to have a function which have which
takes an expression a and the variables
are maybe undefined because I know they
might be you've spelled them wrong or
they do not actually exist or whatever
and you want to get back maybe of an
expression T values or they've defined
and you want to get nothing if any of
those variables are nothing or you want
to substitute variables we have an
expression a tu and you want to splice
in some other expressions for your
rivals for example if it's a function
call you want to do substitution and if
you look at all these functions they are
all some sort of traversal so you want
you would write a case analysis on your
expression here which reverses that
stuff and here it's worse again and like
seriously why am i repeating all that
code and if you register your data type
as foldable and monad you get all these
functions for free basically so you can
just use them as we use them from the
haskell library and I'm not kidding this
actually compiles if you make your code
if you if you register to correct
instances
then you get all these functions for
free dresses for example just magnetic
bind it's just the Monad you can just
bind something into the positions very
variables are and you can just use two
lists for its unfold a bill to get all
the variables all these positions and
this is this is obvious just a small
example but you basically have the whole
power of the data foldable data
reversible library in high school and
every single other library in Haskell
which is abstract over foldables so you
get this complete power and it's like at
least 20% cooler than your old code and
you can even do aspect-oriented
programming with that so for example
what if you want to log the variable
access in evaluate M so let's say you
want to check the performance of your
valid function and you want to check
whether each variables only exist once
or maybe I don't know whatever you can
imagine you want to check something
about the number of variable accesses
how would you actually do that and the
way we extract a tall monad it's really
easy to do that so let's see some demo
code so this is just this data type I've
defined earlier and this is the evaluate
M function as you can see it's not
really that difficult and indeed it's a
little bit like an imperative program so
this code if you just look at that code
you can kind of see what it does so it
reverses the data structure and do some
operations and this is the most general
type you can give that function and then
we have I have predefined a map which
assigns X to the value 0 and Y to the
value 1 so it is just just a sample
default variable assignment so let's run
this and we can not just you say
evaluate M with this more tab and let's
let's define an expression first
expression equals the sum of x and y
and let's just evaluate that with the
more tab and we get just one on the
other hand if we had a set here and you
would get nothing because the Y is not
defined there just let it define anyway
so what if you will now want to know
what if you want to check these variable
excesses and there's a Monette in
haskell for that it's called the writer
monad and the writer monad is something
which is kind of like a logging
framework just that it's really simple
and it doesn't beat five megabytes of
dependencies and I've written a function
which takes this here this bar tab so
it's it wraps an excessive function and
calls a function which is called tell
and imagine telev called log and then
you will know what it does
and I can just wrap this function around
and it will just work so let's define it
again and stay well yet M a blog bar tab
this expression and now we get quite a
huge error message because I have not
actually specified what kind of writer
Monnet I want so I just force it to a
specific one but that's just a technical
detail and if you look into monitor and
foremost you will get that explained so
there's this is all loanable so we just
run this and now we can get back our
original value of one and additionally a
log of which variables have been exist
and this all without changing the code
you just had another function called
wrap log and put it in there and the end
you chaired that the part was this run
writer thing and that's that's basically
it so that's really nice and with if we
had followed the yakhni philosophy we
wouldn't have been able to do that
without abstracting early in your design
process many abstractions and concepts
actually stay hidden and the yakhni way
of thinking is actually a limited way of
thinking so I would kind of advise
against doing that and it's specially
important if you're building libraries
so next time your
writing an interpreter or whatever these
l think about generalizing your types
generalizing the operations over monnet
along numbers or whatever don't give
concrete tiles because then you will
maybe find a library if you find
yourself wanting to write a function
about that you will most likely find out
this function already exists and you can
use it because your type is so general
okay let's have a quick interlude here
let's go back to one of these pillars of
functional programming namely immutable
data structures and I've hidden a little
Java code in here so this is one of
these popular Java beans so it's a class
for persons and it's very simple because
it only has a name in there so if you
want to update these objects what you do
in Java is you can just get your root
bean get go your use this kind of fluent
interface go all the way down and in
control call set and if an asset you
have a nested you have a nested
basically a nested data type and you can
just use getters and setters to update
some bits below in your hierarchy now
what does it look like the same code in
Haskell so let's see find some data type
so we have a company and it has an IT
department and it has a human resource
department and every department has a
boss and head of budget and every person
his name so this is from the Java code
earlier I didn't write that as Java code
because it wouldn't have fit on my slide
but you get the idea so let's say we
have a company value and we want to
update the name of the boss in the IT
department right so we want you have
something of that and we want to update
this in this in that so in Haskell you
could write it like this and this is
horrible because this is like crater
attack if you go even if you go even
deeper you have to repeat yourself quite
a lot and yeah this looks this looks
horrible you don't you don't want to
write that luckily some clever people
have come up with a way to
work around them and this concept is
called co-state como net coiled around
I'm just kidding
but it's the highly theoretical variant
of Java beams so what is the essence
here
um this concept is called lenses and
what lenses tools basically allow you
they give you a way to focus on a
specific sub for of a data type so let's
say you company it's the whole thing
it's a and B would be the department and
then you can obviously specify a
function which takes the company and
gives it back the department and it is
also possible to write a set function
which takes the company takes an updated
department and gives you an updated
company so these are really this is
really just the essence it has a getting
a set function and you can already do a
lot with that for example you can
compose them so if you have a lens for a
company or for a department inside a
company and you have a lens for a person
inside the department you can merge
these together and get a lens which
gives you the person in a company so as
an exercise you could just think about a
little how you will write the compose
function it would look a lot like if the
type would look like a lot like the dot
operating has to like function
composition and but this really this
this formulation already gets really far
but we can take that even further we can
throw a table mat on it and what will
happen you will get this formulation and
I mean look at that it doesn't really
look like that anymore but it's really a
more general version of that and you
don't have to understand that I don't
info I mean at least not in full you can
see here kind of that it's a function
which takes the whole thing and have
wraps it into some effect or whatever
and then you get something back or
whatever so it it is some sort of
updating function which is wrapped here
and what can we do with that what does
that give us well it gives us a function
composition so we can just use these
lenses as plane all functions so this
was really actual code which works so
you can take have if you have a lens for
the IT department you can compose it
with the boss of this department and the
name of that person an interest call set
on it
and give it a new name and it will give
you an updated company and this is
regular Haskell function composition so
with the old formulation which is not
really generic you couldn't use the
regular function composition you would
have to use a different operator and
with this with this new this is a better
version you can just use regular
function composition and that's really
nice because that's another example of
the more you generalize the better
libraries you can use because now it's
just a plain function and all the stuff
working on functions all the works in
you type you can you can just I mean it
works also for the naive version but the
point is you can't use function
composition for that you have to and so
did the composition function call this
it looks a little bit complicated it's
like three lines of code and here it's
just one line basically yeah and also
you get mocking for free so back to
topic because lenses are ordinary
functions so you can swap them out let's
say let's say you have your dealing with
a module which gives you all this data
types for function for for companies and
then in the next version you decide you
want to have additional layer of
abstraction so for example departments
are organized in department groups and
now you have old code which looks at the
ICB department and now you would need to
update that code because you have now
the IT department is in the
infrastructure group or whatever but
with lenses you can actually give a kind
of intermediate version of that which
just composed these two things together
and it works like in the it works like
in the old code so you can easily adapt
to changes without affecting user code
at all because now it's kind of
virtualized version of member access and
the user of the fence doesn't actually
care whether it's an actual field in an
actual record or if it's a database
access or whatever the client just
doesn't care I have another I have
another picture here this is what
sometimes people think about when they
say you should practice agony
so you
both on stuff on top of other stuff so
that you get the fragile composition but
I'm actually arguing in favor of pausing
thinking hard about your problem
generalizing and then you don't even
need to think about tacking on because
it will be one whole thing basically
okay calculator I get I hope you still
with me with that I'm going to update
this example now two different syntax
who have you're familiar with G ADT's
okay good that I have an additional
flight for that so this was just the
same data type I had earlier and let's
have a look at these constructors and
in-hospital
constructors can be used just as
ordinary functions so you can for
example ask the type of the some
constructor and you will see it's a
function which takes two arguments and
produces another one how it does that
internally you don't care it's just like
a function and you can actually rewrite
your data type in that way so you can
give explicit type for your constructors
and here's what it looks like
and it really reached kind of the same
way so you say literal the literal
function which takes an A and gives you
back an expression a T and the variable
is a function which takes a T and gives
you back an expression a G so that's
really not complicated I have the slide
because I'm doing some advanced type
hackery and you can't express it with
y'all today
so here's the new syntax so far
expression a T so if you have value of
that type you only have literals of type
a so there's no way you can have in
spend floats in the same data type the
type a is constant in the whole
expression you can't even change it and
some is a nice operation because it
takes two A's and gives you back an A is
homogeneous but what if you want to eat
your genus operations like even even
takes an some integral value a so
something which is an int basically and
you make a bool
you can't model that because it can't
really you wouldn't need to change this
type here and actually it was GA TTS you
can
so let's simplify that a bit get rid of
variables because we don't need them
anymore for the purpose of this example
so we just have a data type which has
literals and sums and now we generalize
we add we change this a here and give it
this num constraint explicitly and then
we add another constructor which
surprisingly somehow changes to result
type in here and this is actually a
Haskell syntax so you can do that and
what it means is for any a if you have a
value of expression a and you have prove
that it is somehow an integer then you
can get an expression bool and you can
read that as if I have an expression of
type a somewhere in my code it will
produce an a alright so how do you even
this actually works and then just for
the fun of it we can add another
operation for example a cast operation
so now you have wolf here what do you do
with these bulls you can't add booze
wither but you can add another case
which tells you how to cast a bull to
something else so for example if you
want 0 for false and 1 for true you can
just wrap this even call in to another
call of cast give it the function which
translates your balls into integers and
then you get back an integer and then
you can take the sum of it so this is
really nice because now you have kind of
a strongly typed calculator at your
hands so by construction you can never
produce type incorrect computations so
this is really important if you're
building a compiler or something like
that well for DSL which is a little bit
more complicated and you don't need to
care about failures in your day in your
evaluation you just give these
additional types and then by
construction you always have a valid
expression in your hand so we now have
the data type which represents these
arithmetic operations what can we
actually do with that
apart from evaluating it so I have some
ideas so we could print it you could
count your operations in there and you
could optimize it so for example if you
if you know how to if you if you know
how to fuel some operations together you
could just do that and let me tell you
we're just going
to do that so here's this data type and
your valued function
I've told you down a little bit again no
more debt anymore here because I don't
want to cram all different things into
this small example and we can now write
an optimized function here and basically
the most trivial implementation you can
do here is you could say optimized x
equals x this will always work because
like you can always do the identity
transformation let's just do a simple
one here so for example if we have a
cast of literal what can you do with
that of course we can just apply that
function directly to the literal and now
if you'd know a little bit about GHC
then you know that it's already quite
heavy work going on there because you
have this cast f and it is some
non-standard data type so you have some
changing types in here so the compiler
will actually try to come up with new
type variables and try to figure out if
that's all still correct and but the
good thing is if it compiles it worked
so we can just try it you have an
expression let's say cast and let's say
I don't know lambda X if X then one else
zero and then you have literal true oh
I'm not writing Scala I'm writing high
school so we now see we have a cast of
literal and if you just call optimize on
that we get just a literal bang and this
transformation is actually typed correct
by construction so we can't make any
mistake so just go crazy with the
optimizations here the compiler will
check that they are correct okay so I
still got a little bit of time for my
last point and last point I'm going to
make it's about I own my hobby asking
has co-developers about the meaning of
IO and just eating some popcorn well
that
information because I are deeply magic
in GHC so you can't really you don't
really know what's going on you are at
the mercy of the compiler implementers
and it's kind of funny to see because it
could have been different and how could
it be different so what is actually a
sense of IO what do you mean if we say
IO in Haskell and IOA is I like to
imagine that and I also like to explain
it to students io a it's like a recipe
fry so assuming you have a recipe for a
spaghetti with tomato sauce then if you
open you if you open this recipe in your
book you don't actually have spaghetti
with tomato sauce you still need to
follow some instructions and then you
get a society effect you get your
spaghetti with tomato sauce and it's the
same way if you have IOA you don't have
an a well view at your hand you have a
recipe on how to create an A and
basically it's just a representation of
this computation it's a representation
of how you produce your spaghetti and
this the the the point of I always said
this at some interaction was real work
so instead of fetching some ingredients
for your for your cooking you fetch some
data from a database so that's kind of
the same thing and the important bit
here is that it's a representation so
the compiler implementers can choose
whatever they want here in Haskell
Iommi's that it can contain all sorts of
effects it's kind of this super super
monad which has all sorts of things in
there
asynchronous computation network access
terminal IO
whatever you name it additional entities
OPEC and not inspectable
so if you if you're calling a function
of type IRA you can't really introspect
what's going on in there you just can
execute it but as I said a better world
is possible so we can actually make it a
DSL so we have this calculator example
which is a data hub with one constructor
for operation and we can also define a
terminal application which is the data
type with one constructor preparation so
can we do that what kinds of operations
can we do in the terminal application so
we can read from certain input we can
write a standard output we could open
files
read from files and yeah whatever what
the terminal application even does and
I'm going to focus on this bit here and
if you go to marital ruin ours talk he
might talk about how to combine these
effects into so if you write something
for this how you can combine these
together are you talking about that okay
then you have to look a true not all
thoughts because he talked about that so
we have just a small data type here and
this is really similar to this data why
we've seen earlier we have something for
terminal computations it produces some
value a and what can we do here you can
read the line which will give us a
string and we can write the line which
takes a string and gives us some unit
back and this is really that's really it
now we just need to do something well
that I mean this data type by itself
doesn't do much so more ml code so I am
importing some pretty fancy stuff in
here you don't need to know about that
I'm just I'm just showing you the result
here and if you want to look at the
sausage factory I can give you some
hints about material you can so here's
all data type it's just copied verbatim
from the slides and I've added the type
alias it which basically wraps our
terminal a into something else so that
we can use it and then we also write
some convenience functions which do some
heavy lifting it's not really that
habitable and now just by writing that
we can already use it so let's say we
want to have a function an application
which read something from the input
input and immediately writes it out okay
read line and then write line
immediately after that
and this already compiled so this is
already a monad and you can ask for its
type we can see that it's some weird
thingy containing a terminal and
producing a unit value but of course you
can't do much with that because we
haven't yet specified how to actually
execute it but just from writing down
the definition you can already compose
your operations and you could even have
a match on that if you want to so how
would we run that of course the first
idea would be to compile it to actual IO
alfresco so if you see a red line
constructor we would actually call the
gate line function which is primitive in
Haskell in jhc and if you have a right
line contractor we couldn't call put
string line of s so just work so we
define the same app and now you say
what's run free aisle
so if they run free il and then we give
some we say in which direction we want
to run it so what do we actually want to
interpret the to and we give our app and
now it will execute it in GHz I when I
can type in ABC and get ABC back okay
let me just try that again
top of the screen so having getting
something back and this is our a
completely abstract representation of
our computations and this is a way which
tells this interpreter how to interpret
it and we can even define something else
so assuming your runt want to write test
for your foulest code for your terminal
applications and you don't want to
actually run it with standard input and
standard output let's just say you want
to run it with some fixed input data and
want to check if you get some fixed
output beta back and you could fork a
new process and intercept the Senate in
and send that out in some way and then
check if it's compliant but you don't
need to do that you can actually write a
different interpreter so if you can see
this function below here is structured
in the same way as this function here so
we're taking some terminal value and now
we don't interpret it to i/o we
interpret it into a state monad
so this says if you want to read
something let me get the input here and
remove that input from my buffer and if
you want to write something just add
that to the buffer at the end and so we
have us basically a value of which is a
tuple where the first element is the
input which is remaining and the second
one is the output we have written and
now the very same code we wrote it still
works so if you define that application
again and so this is the this is really
the same application we defined
previously and now if we say run free
i/o and now we say console IO to state
let me use an app we can get a different
interpretation and of course we need to
run that somehow it's a state monad so
we can't execute immediately we have
look type so there's some state going on
so we have to give it an initial state
so we use run state T
oh I have to give it another okay let's
give it some input so we say we have ABC
as an input we have an empty output in
the beginning and now we can see the
input has been consumed and your output
has been produced and we can try the
different example so if assume we
already have some output then you can
see that this output is preserved and
appended to that and we have some if we
have some additional input which is not
being read then this will still be there
so this was completely so this is using
exactly the same application you wrote
using a different interpreter and you
get a completely different result so you
can easily test your code you don't have
to do some jump some hoops to intercept
some process communication you could
just specify different interpreter and
that's really all there is to it and you
can turn that even open up a notch this
is code from one of my colleagues which
is used for testing homework and
basically he has defined a completely
own definition of i/o with some internal
data like how many files are open in
which directory or MI and all these
things they are completely virtual they
have no relationship to the actual
system whatsoever and if you now wrap
this into this free monad which I've
shown you which I've told you to ignore
and deployed before then you can
actually come generate a completely and
I also stand which stands completely on
its own which is completely independent
from the IR resonation in Haskell so
conclusion FP provides a set of
techniques for abstraction of evaluation
use them and as download news not said
premature evaluation is the root of all
the other questions
yes yes so the question is if I if I
execute some my my my-my-my code with
different interpreters I end up with
different ways I have to call them so
that question so the way I mean the you
still have to space you still have to
write the code for the actual invocation
so if you're running in production you
have another module which also you have
your module which defines your
application and then you have a module
which calls it in one way for production
and you have another module which calls
it in another way for testing so
basically that's the idea yeah it does
add some boilerplate if you have
multiple invocations but in the end I
think the benefits are worth it because
you you save toad in other places
basically so that's how I would present
yep
so it this myth future it's actually a
good point because if you if you
remember this evaluate M of this
calculator which took an arbitrary monad
you could if you have a suitable moment
for parallelism you could just plug it
in there and you could get a parallel
evaluation of just for free and this is
xxxx exactly the point by abstracting
over monads you can just swap in a lot
of different functionality I mean the
basic idea is still the same you have
some addition or some variable access
but you can always swap out the precise
means of how to perform that computation
so that's really the big value on
abstraction alamo net more questions
alright then thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>