<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlesy - Visualizing OTP State Machines by Paweł Antemijczuk, Nicholas Gunder | Coder Coacher - Coaching Coders</title><meta content="Erlesy - Visualizing OTP State Machines by Paweł Antemijczuk, Nicholas Gunder - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Erlesy - Visualizing OTP State Machines by Paweł Antemijczuk, Nicholas Gunder</b></h2><h5 class="post__date">2016-10-03</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/ofvEYrVkbrY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so um today I guess some of you have
probably done some modeling in your work
maybe with a show of hands how many of
you are actively modeling and your work
daily just out of curiosity okay so not
so many that's not a lot yeah well i
guess it was quite popular to do this
maybe in the 90s but why would you want
to model i guess you're probably
modeling in in some form because you
have to write up a design and typically
you're going to have collaboration with
fellow developers or maybe with an
architecture group that's probably
designing the system so you're going to
want to model at least in some form so
that you can communicate what your
intended design is going to be that's
probably pretty good engineering
practice and typically it's done on a
whiteboard somebody will have an idea we
draw it up have a discussion and it will
go and translate to code you could do
more formal modeling where you actually
use tools for this motorola where I was
working before with Pavel right now
actually we were working on a gateway
which connected two countries together
and basically this gateway was
responsible for handling calls between
these countries very simply put I think
it's more complicated than that but each
of the processes that were in this
gateway in erlang we're representing
individual calls and these calls had to
be modeled the state machines that were
responsible for handling those calls had
to be modeled so we decided to use tools
for this so two things not everybody at
Motorola is an erlang programmer so what
we don't do is we don't just show some
skeleton code to developers that would
like to see maybe like a working
prototype or some way of visualizing
what we intend to do in the state
machine so what you're not going to do
is be able to sell people to read your
line code so we want to have is we want
to have some minimates intermediate
visualization tools at least like the
whiteboard and it's difficult in this
way because it's difficult when you
don't really have an idea of what you
want to do so different they mean design
in general is very difficult but it's
more difficult if you're alone in design
so what graphics are going to our graphs
models are going to provide us and give
you a quick overview and feedback
vism so there is a real need for doing
this there's some problems in general
that come out of you know having very
complicated systems especially you have
very large requirements sometimes very
very thick documents it's kind of
frustrating if you get some of these
things in the documents incorrectly and
you're interpreting them incorrectly
personally I don't like to read a lot of
documents and it's very difficult
sometimes to stay awake so it's nice to
have graphs for me I like to read graphs
it makes a lot easier for me to
understand and translate to code what I
need to do and it in fact some of the
work that we've been doing is is kind of
frustrating in models because if you
want to maintain models it's a pain in
the butt so this is to say it as simple
as I can because modeling is something
you do in design phase typically and the
next time you go to play with the code
again it's typically already out of date
with what's in the code so the other
thing we have with modeling the serial
difficulty is people have an opinion
about how to do it and typically it's
not uniform and the agreements are
always very difficult to get on how to
model and it's also difficult to map to
code depending on the language we're
very fortunate to be using are lying i
think erling maps to certain modeling
tools quite well one of them is one that
came out of telecom the the sdl I don't
know how many of you know sdl okay well
as scale was introduced in 76 and
there's a graphical representation a
version of this they also have a textual
version don't think many people use a
textual version anymore but the
graphical representation still used in
motorola we have some older components
that are using this design the other
thing we used sdl for and our
development is we had a lot of standards
we did for instance accused signaling
which is on e 1 channels they had very
very thick documentation on how to do
that and I skipped a lot of this text
based documentation and went right to
the appendix which were beautiful graphs
showing me exactly what I needed to do
in the code which made development of
very old but very well developed a
documentation or i should say the
standard for for cucak very easy to
implement and we were very successful
meditation because we had those models
when we actually connected to our
competitor systems in
an integration testing we had an
implementation that we had developed an
airline using this documentation that
was developed let's say probably in the
80s and the system that was developed
our competitor system was made by at
that time Nokia now Airbus they have a
circuit-switched Network that's ancient
and they haven't changed their acoustic
in a very long time so it was really
nice to see you develop this stack with
two developers and the course of well
about a month and a half plug this thing
into code that's been running for years
and years and years and a telecon system
that's extremely stable and it just
works so graphs have a lot of value sdl
has a lot of components in that graph
but there's only a few things that map
really well to Erling this is an example
of the actual q6 standard i copied some
code that we actually used from our
limitation and try to map it here so you
can see exactly how easy it is to map
for instance estate definition to the
events that are being translated and
then you have actually the timer stop
timer that was put this T 303 for the
cue stick and then there's a release
message you can basically follow this
quite easily in the code to the graph
then all of a sudden things changed a
bit we got larger we had 25 engineers
and so just five and a lot of engineers
had had a lot of experience in UML so we
started to develop more components newer
components that was very difficult to
get everybody to agree how to do that in
STO because people did not have that
steel experience so we went to using uml
for this but you know it's just a tool
and actually it's very similar in
structure to stl you just have to get it
to work for you or your need your domain
UML can be used to almost anything which
makes it also very dangerous but in
general mapping it to earl and koda's
i've also just shown here as an example
is relatively trivial if you have some
structure that you agree on in the UML
implementation the other point that
we're going to demonstrate today is not
just that you need models but the other
problems with models we'd like to
eliminate so me and Paul will we came up
with something outside of Motorola
because the problem of having these
models in motorola basically is very
difficult to solve without some tools
that work for us
and we actually came up with this idea
of actually having a way to take
existing erling fsms and generate some
digital representations of these fsm so
we can show our non erling in engineers
what we've actually done implemented so
we can get quick validation that that
was exactly what was intended and that
sounds much easier than it really is but
in principle I mean when you make these
designs and then you make changes of the
code and then somebody comes in and says
oh wait this is wrong and then you go
and change this again and do you really
go back to that model you did and redraw
all the arrows in the little states and
maybe add something ah maybe sometimes
maybe not and actually our experience is
that the not part is the most common so
people don't really want to go back and
then re-add it all the models once
they've been done we've actually had
this one major effort where we had to
take our existing code and map it back
so that the system architects could go
in take a look at that and validate
whether this is actually correct this
took about three days to go through a
single early module and draw it back on
to uml it's a very taxing process and of
course in the process we found that
there's a lot of things that are wrong
and they have to be corrected and now we
didn't really feel like going back and
spending another three days on updating
that diagram again so now we have this
huge diagram that's worthless because it
doesn't match the code at in any way so
the main thing here is to generate this
thing automatically so that we don't
have to go and by hand drag these labels
I mean there's a lot of tools to do you
ml or I guess sdl as well and I'm you
know you have to go into this Windows
program drag these little arrows direct
this little boxes here and there type
some things it's kind of painful you can
also do it an in textual format but once
your model gets really big this this
will be very painful to do so what we
did is it kind of a little tool that
will actually read an erlang source file
it will need all the include files you
have there so that it imparts it it'll
use the inbuilt airlink map parser and
transform this into the very well-known
absolute abstract syntax tree and then
we'll go through that tree and trying to
find out what are your states and the
states we know that the gen fsm behavior
is very well defined we know exactly
what a state function has to return
there's only so many possibilities that
the state function can return so if we
detect that oh this actually returns the
next state double oh this is probably a
state and going back that way we can
figure out what the states are of course
this is a much more complex problem when
we have case statements inside the the
state that change how the transitions go
when we have the state actually being
computed by another function and maybe
returned when we have I mean there's a
lot of crazy things you can do there
which are much harder to analyze so
currently we support the kind of like
the most basic model where if you have a
function class also with case and
they've statements inside and you have
some next state tuples in there we will
find all these transitions we are
working on that on that that now you
could if you have a state transitions
inside a case clause we can actually
infer what is the condition to go to
that branch and that branch so we would
I mean we're not exactly sure how to
represent this yet but the current idea
is that we will just make it's kind of
like an abstract sub-state or or
verdicts that is the case itself and
it's basically becomes like a decision
block in UML or or sdl the other the
other point is that it's actually being
basically the abstraction strategy that
we've parsed and we put this into a
direct diagraph so digraph also module
yeah the diagram module that comes with
OTP we use that basically the tool
really what it does is it takes the
abstract syntax tree and builds a dick
digraph and out of that it doesn't
really matter we've made we've created
two implementations that one that goes
into dot and one that goes into a JSON
but it's really up to anyone because as
we as neg already said everybody likes
the diagrams with a little bit different
flavors so everybody can just make their
own drawing or use their own drawing
tool whichever they prefer and the main
difficulty is really making the diagraph
itself not visualizing it um let me show
them something yeah I will we also
support all state events that we have in
OT p and there's a github link here if
you would like to take a look but just
so we prove to you that we're not just
making things up here and pretending we
have something so we we've made this
example state machine so this is a very
like the most basic state machine that
you
right it has a couple states they take
some events they make some transitions
there is a state here which has some k
nested case and if statements that do
some weird things here but there are
also different principle transitions
there's some transitions that go back to
the same state they came out of and of
course there's some handle event and
generally Allstate events that also self
loop actually so what I'm gonna do now
is I'll start the application can you
see that is that big enough up oh yeah
oh alright I can do that and we just say
create graph and we have to provide
where the where the source file is
there's no includes for this one and
let's say we want a dot file so that
just worked I'm going to open it up now
and let's take a look we have this tool
here an online tool that takes dot
there's little thing I need to change
here but otherwise i'll make a graph and
here is so all these state transitions
that we've had in that code are now
visualized and we have a state machine
diagram for that code we just had I mean
you can have different visualization
tools that use dot I mean there's quite
a lot of them I think this is just one
example of them it was quite nicely
you'll see you later but what we also
have is you can see that we saw that in
the Allstate events case we just passed
the variable of the state the state name
back into the next state double and our
program kind of inferred that and found
out okay so each state actually can do
that so we have these handle event
events in every state another thing you
can do if you don't like that you could
do JSON and I will need to copy this to
my web server
and if I ranch now I've made this little
utility in d3.js you may be heard about
this this is just something that I
whipped out real quickly to show that
you could also take a JSON and use some
kind of other utilities to visualize
this is not the prettiest it wasn't a
lot of time spent on this but you can
build something out of this later
that'll be a bit more nice but okay this
is all fine you can say all right we
have this example fsm we've made this is
some very simple code we've we've
tinkered and made sure that our program
actually runs for that and then great
but now I would like to use this and
what guarantee do I have that this
actually runs so how about instead of
instead of showing the example fsm i'll
take some motorola production code and
draw it up for you so this is a state
machine that is responsible for
maintaining a link to another entity in
our network this is kind of a link
that's always supposed to be up if the
applications running this link has to be
up if it's not up then nothing is really
working so this is not something that
can be closed or opened this is just
links up and then it stays in that state
until you explicitly shut down the
application and kill it and there's a
little complicated I guess link up
procedure that takes a while there's a
few different messages there but let's
take a look at it so I'm going to make a
dot out of it and I'll take this into
the web ravaged
and all right so this is a this is a bit
bigger it looks something like that this
is a much more complicated state machine
that has a lot more transitions and a
lot more different things can be
happening there so but we can still see
a few things here so for example here we
have the initial state so we always
start in this state wait connect when we
are waiting for something and eventually
we will get this message connect I don't
know if you can see it here this
transition then we'll wait for the grant
message that the link is actually
granted and so on so forth and as I said
this this is never supposed to not try
to connect this if the link goes down
we're supposed to keep trying and
reconnect this link but if we explicitly
want to close it then we have this stop
all state event so all these stops go to
this terminate here on the right so
there's a force the limitations where
somebody does some weird stuff like
computing the state out of whatever
fields that came in the event or
something like that or if there is an
actually a sub function instead of the
next state at the end there's like a
function call and that function returns
the next state and things like that
those are a bit more involved but i'm
pretty sure it's possible to do think
for us it's actually going to be a huge
benefit that we can give this in a few
seconds to somebody so then we don't
have to be bothered to walk them through
the code they can at least look at this
get an idea of what's going on and and
proceeded to ask questions and we can
have a dialogue like papa was saying it
would be really good to have the
conditional statements we hope to have
that for you today but we're going to
probably working on that quite soon so I
think that wraps up the rest of our yeah
I mean this is all on github so we
welcome anybody who feels like tinkering
with this and one last thing I would
like to say because everybody seems to
be saying it today is that motorola
copenhagen is looking for an erlend
programmer so if torbin was asking if
anybody likes to have a startup
experience and i'm asking the opposite
if anybody is tired of startups and
maybe would like to do something
different for a change
you never know any questions we have
time maybe one question I have a
question will you update your rig me
fight on yeah oh yeah no information ya
readin yep we actually wanted to make
sure people actually wanted to use the
tool first before we go in and put the
value into the tool but yeah we were
kind of afraid that we're gonna come out
here show this and everybody will be
like that's what is this crap of who
needs those if people would like to use
the tool we will of course be happy to
provide that information so okay okay
good good great thank you we will be
happy to provide that and end
conditionals soon a good 10 total now
nice job guys and will you be able to
generate stl from the code yes so the
idea we were trying to put this you know
when you have the diagraph actually
complete the idea would be you could
write your own yeah maybe I forgot to
mention that when we built with building
diagraph and the edge data has actually
all the information has the event it has
the guard but it also has the body of
the function class so if you need to
figure some take something out of inside
the code you can do that it's just our
visualizations don't do that right now
and I think somebody lives a snippet of
code that does almost that somewhere in
your repose just kissing okay we'll talk
set it all right let's thank speakers
once again
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>