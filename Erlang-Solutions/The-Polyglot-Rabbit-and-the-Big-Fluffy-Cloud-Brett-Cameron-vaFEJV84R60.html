<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>The Polyglot Rabbit and the Big Fluffy Cloud - Brett Cameron | Coder Coacher - Coaching Coders</title><meta content="The Polyglot Rabbit and the Big Fluffy Cloud - Brett Cameron - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>The Polyglot Rabbit and the Big Fluffy Cloud - Brett Cameron</b></h2><h5 class="post__date">2013-05-09</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/vaFEJV84R60" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hopefully we can get through this in 45
50 minutes so I have a bad habit of
either having too many slides or not
enough and in this case I think it's the
former rather than the latter but we'll
see how we go so catchy title for a talk
that is hopefully going to be of
interest to some of you first of all
just survey the audience a little bit
how many people our RabbitMQ users or
thinking about using rabbitmq okay
there's a quite a bit in the in the
presentation really that talks about
what rabbit in queue is that talks about
the amqp protocol I'll try and get
through there quickly before I get to
the other interesting stuff but I'm
guessing the reason you're here is that
you will have read the abstract I
essentially what this talk it came from
the fact that a late last year I put
together a blog that discussed that the
polyglot nature of remedy in queue
everybody who's familiar with rabbitmq
is familiar with its ability to support
the amqp protocol specifically North
Point North Point 91 variance or 81 and
90 variants thereof i should say it also
support one point north as well but
somewhat less known fact about rabbitmq
is that viet's what is a feeling
powerful plug-in architecture it has the
ability to support other protocols like
MQTT stomp and a few others that will
talk about as we as we make our way
through the presentation very briefly
background about me the strange accent
is because I live in New Zealand down
the bottom of the world you can't go too
much further south unless you want to
get to the South Pole and it's not
really very nice down there but it is
nice in New Zealand and you know please
come and visit our wonderful country my
introduction to early and came I don't
know maybe 2008 2009 something like that
really as a consequence of playing
around with RabbitMQ and investigating a
and QP and I got interested in Erlang
primarily out of some work I was doing
to port erling to an old HP operating
system openvms that some of the older
members of the audience may or may not
be familiar with so out of that work I
kind of got to know a little bit about
the inner workings of beam and various
other bits and pieces of LA and I've
kind of been trying to enhance my
knowledge of a sense
anyway so as I said before basically
what we're going to talk about here an
esper the abstract is a brief overview
of rabbit in Q&amp;amp;A mqp the advanced
message queuing protocol it's primarily
used by revit in queue the reason rabbit
exists we're going to have a bit of a
discussion about reberty and cue plugins
why would you write a plug-in what are
they good for what can you do with them
what can't you do with them things like
that talk about the plug-in architecture
we'll talk about things called RabbitMQ
boot steps which are fairly fundamental
to the operation of rabbit when it
starts up and things like that it it's a
fairly complex beast when it when it
boots up there are a number of
subsystems and interdependencies between
those sub systems that need to be
managed and the developers have done a
pretty good job of implementing a rather
cunning mechanism which the rabbit in
queue boot steps to handle that
complexity being going to talk more
about the polyglot nature of RabbitMQ
and because i work for HP is an
architect in HP cloud.com i'm going to
talk about just a little bit about
setting up RabbitMQ clusters on HP Cloud
and things like that ok so amqp am keep
these things for advanced message
queuing protocol this is as I say it's a
message queuing protocol and it's an
open standard protocol much like TCP or
HTTP or smtp things like that it
encompasses all the aspects of any good
message queuing protocol that you'd
expect to find reliability queuing
security scalability all that good stuff
one of the key things about amqp however
and where hopefully it will succeed over
perhaps earlier attempts at such things
is that what it all boils down to is the
wire protocol you can go out and write
your own amqp implementation as long as
your code in terms of how the bits and
bytes end up flying around the network
as long as your code implements things
that conform to the wire protocol as
specified by the amqp standard you will
be interoperable with any other
implementation it's a very key point
that the standard doesn't necessarily
say that thou shalt have this set of API
functions in any amqp implementation
what it says as their shop conform to
this particular
protocol okay so i must admit as I was
listening to Joe's talk this morning I
couldn't help but think of some of the
aspects that I'll hopefully remember to
raise in this talk amqp was originally
devised back around two thousand four
2006 time frame it was the brainchild of
a man by the name of John O'Hara who
worked for JPMorgan Chase in london at
the time and he had been through a lot
of pain and suffering with a raft of
message queuing technologies over the
years and thought there had to be a
better way of doing things so he
solicited help from an organization in
Belgium I mattox many of you will have
heard of zeromq I'm sure and Peter
tensions I Maddox's beat his company so
Peter and his team worked with John
O'Hara to design the initial draft of
the amqp protocol and put together the
first implementation which was a piece
of software called open a and Q that was
deployed throughout bits and pieces of
JP Morgan very successful project as
time went on and the protocol matured
they decided to essentially throw it out
there to a working group and today the
working group comprises the
organizations that I've listed there
well january two thousand thirteen i
don't think there have been any new ones
may have been but it's probably fairly
accurate i would imagine what you will
notice is that that working group
comprises the number of technology
companies and a fair number of what
looked like financial services
organizations and that that's kind of
makes sense because amqp has its its its
heritage it was born out of financial
services as reg on a higher work but
it's finding applicability all over the
place today and we'll talk a little bit
about that and subsequent slides as we
as we move along there's another
organization that I'm not going to
mention because this is being broadcast
and they'll probably get twitchy if they
hear their name mentioned on the
internet but I would speculate that
they're probably using some a and keep
the implementation for something
otherwise just keeping an eye on what
these other organizations are doing a
short timeline of message queuing this
is QX been around for a long time way
back as far as 1983 there was some
rather crummy but quite interesting
message queuing implementations in q
series kicked in late 1990s microsoft
mid-90s with with their msmq and like I
say amqp an open standard kicked in
around the 2004 time frame and there's
been a lot of activity on the internet
it's almost like there's been some sort
of resurgence and interested message
queuing as demands for a massive
concurrency massive scale need to sort
of D couple in some way the production
of data and the consuming of that
information so the whole new generation
of users starting to develop the
starting to realize that the virtues of
message queuing amqp was born out of
frustration like I say John O'Hara in
his role Philly senior technical role
within JPMorgan Chase they had one of
everything they had you know in Q Series
and just about anything else that work
you messages and probably a few a few
things that didn't and and all of these
things came with considerable license
costs and more to the point was that
they spoke proprietary protocols there
was no open standard protocol spoken by
these pieces of software so every time
you in doubt and did a new project for
some reason a rather a particular
business unit might end up buying
another middleware product that would
have to integrate with all your other
middleware products they didn't speak
the same language in any way shape or
form and you would expend a lot of time
and energy a lot of money would be spent
developing gateways adapters whatever
you want to call them and then of course
I'm going you need to provide support
for those so you've got additional cost
in terms of supporting multiple skill
sets whole raft of factors it just gets
really really ugly so John had seen this
within his own organization and figured
they really had to be a bit away which
is where the whole idea of the amqp
protocol came from and he wanted he you
know big vision here basically his
vision was is that amqp would become the
solution for enterprise messaging okay
from a protocol perspective this is
maybe a slightly old slide but it may be
gets the point across if you think about
these these somewhat older protocols and
the use cases that they support well
amqp one way or another can accommodate
those use cases and it can switch
between them okay it's quite a broad
protocol in that sense flexible key
components before I talk about this
slide what I should say is that this
presentation really focuses on a and
keeping naught point 8 and North Point
91 amqp one point naught the
specification was recently maybe four
months or so five months or so release
signed off by the working group there
are some differences between one point
naught and the earlier iterations of the
protocol what I'm talking about mostly
here is those earlier iterations and
within that framework that the model is
basically as I've described here you've
got an entity of central entity which is
the message broker its job is to receive
messages and make sure that those
messages get disseminated to the
relevant parties within the messaging
layer within the broker you've got
things called exchanges queues and
bindings within amqp for those who
aren't familiar with it you publish
messages to exchanges exchanges then by
virtue of bindings and routing keys know
how to deliver those publish messages to
one or more q's okay relatively
straightforward concept published two
exchanges exchanges route messages into
queues based on certain matching
criteria another thing that John O'Hara
was aiming for was a and Q people so it
should be useful to everybody it
shouldn't be you know you shouldn't have
to go and cough $50,000 for a license or
something like that I mean this is this
this should be free stuff open source
source you can pay for support if you
want it and so on and so forth the whole
concept of no job too big or too small
so you can go all the way up to your
your JP Morgan Chase type market data
trading with several hundred servers and
who knows how many topics and messages
per second and things like that or you
could just be some guy who happens to
need message queuing for as his local
pizza shop or something because he's
using a raspberry pi to take pizza
orders I don't know
just going to very quickly go through
some of the usage patterns that you find
within these amqp implementations some
of the message queuing usage patterns I
mentioned exchanges exchanges can be of
different types within amqp they can be
direct which is essentially
point-to-point messaging found out in
topic exchanges which is essentially pub
published subscribe so for a direct
exchange principle is pretty simple the
publisher publishes a message to the
exchange the exchange basically does
point-to-point messaging and routes that
message into the target Q based on
routing key and blinding information you
might have one or more consumers
slurping messages from that Q and the
a.m QP implementation will typically
round-robin the the delivery of messages
to those those consumers be more
complicated to found out exchange the
concept here is that any Q which is
bound to a fan-out exchange will receive
a copy of all messages so publisher
publishes one message in any two to the
fan-out exchange any cues that are bound
to that exchange the exchange will pop
messages into all of those cues in this
case Q is one two and three get a copy
of every single message because those
cues are bound to the fan-out exchange
again you can have one or more consumers
dangling off the end of those keys no
big deal topic exchange a little bit
similar to the fan-out exchange accept
delivery of messages by the exchange
into the queues is based on some
filtering okay so the the routing key
that comes into the exchange will be
matched on a regular expression to
determine whether a particular Q should
receive a copy of the message and again
of course you could have multiple
consumers off of each of those cues so I
could have say a routing key that
contain information about stock quotes
and I could say that because i work for
HP i'm only interested in HP's share
price which thankfully is going up and
those messages might end up in q3 other
people who are interested in perhaps HP
and IBM shares perhaps they would have a
binding pattern that
it on those two and they would end up
getting their messages in q2 and so
forth okay really really quick overview
there of AMQP RabbitMQ RabbitMQ has been
around for a while like 2006 first
version was released and it's estimated
today that there's something like about
30,000 plus production deployments of
that software around the globe doing
doing all manner of interesting things
with an HP Cloud we're based on
OpenStack and all the messaging or the
nervous system with an OpenStack all the
messaging with an OpenStack is based on
rabbitmq for example so it's getting
used all over the show and some pretty
impressive ways so revered in queue was
probably the second implementation of
the amqp protocol and it's written one
hundred percent in early I've said there
it's the leading and arguably the most
popular at acting there's too much
argument about the popularity key point
100 percenter leg really nice there's no
3gl code or anything like that in the
air it is literally one hundred percent
early nothing more nothing less as far
as the actual product itself goes the
key components that the remedy in queue
guys have with a broker of course and
they provide several client
implementations Erlang java.net one or
two others and they also provide and
support a number of plugins in addition
there are you know pick a programming
language and there will be something or
other some of you mean someone will have
written something that will talk to
RabbitMQ speaks the amqp protocol there
are client implementations in just about
every language you can think of so as I
see it basically rabbit was around about
the second implementation following
behind open amq of the amqp protocol
since its inception it's it's incurred
very rapid adoption I'm not sure why
it's good product it's well supported
goes to an excellent job there it's got
a catchy name and they've also actually
done a good job I think over the years
of incremental e adding new features in
2010 they were purchased by
VMware but now you may have heard that
enc vmware spinning off a company that
will do things like Cloud Foundry and
RabbitMQ and a few other bits and pieces
an organization called pivotal will be
formed soon and grab it will be part of
that company so I think it's 60
something around that for seeing honed
by being weird but it's essentially an
autonomous entity okay a few more slides
about rabbit and then we'll start
talking more about plugins rabbitmq gets
a lot from Erlang if you look at the
code base between rabbitmq and open amq
for example there's about an order of
magnitude difference Farley's code and
rabbit in cube because it does a very
very good job of leveraging all the good
stuff that Erlang provides ok this
includes you know facilities around
scalability through clustering I mean
obviously you've gotta write code to do
some work here but early and gives you a
pretty damn good head start high
availability various other bits and
pieces I should have wore my rabbit
t-shirt but then everyone would think I
work for them or something which I don't
I can't quite remember when clustering
was introduced fairly early on in the
piece really because it's it's something
of course that facility that Erlang has
largely out of the box rabbitmq
clustering allows you to well basically
cluster multiple brokers as many as you
like reasons for doing this might be
around availability can also be around
scalability and some in some instances
key point however is that the cluster as
a whole really has a common view a
shared view of messages of the
configuration and so forth accu might
reside on a particular cluster node but
if you publish a message to another to
another node and the ques not on that
node doesn't matter it will still end up
in the right place and similarly with
consuming ok so the cluster as a whole
has a nice unified view of the entire
configuration but of course you know if
your publisher number one here and you
publish a message to q3 and and this
particular server goes offline you've
got a problem so what the guys did there
was they introduced high availability
where you can actually have Haq replica
so you can say that I want this
particular cue to be replicated across
one or more of the cluster nodes in
which case if a particular note on which
a cue resides goes down one of the other
nodes can take up the slack and start
dealing with the processing of messages
associated with that cue obviously this
includes across the wire with the nodes
talking to one another but it's a pretty
darn useful high-availability feature
rabbit from quite probably three years
back maybe introduced some fairly nice
monitoring tools originally it had a
somewhat crude but very effective
command line user interface for
administering the rabbit in queue broker
a little while back the guys put
together quite a good GUI based around
moshe leib in a bit of javascript and
bits and pieces like that that allows
you to have a look at what's going on
within the broker to quite a low level I
might say in terms of connections and
channels that are running over those
connections exchanges queues you can you
can administer in the sense that create
delete modify settings via the interface
or you can use it as a tool to try and
diagnose problems and things like that
one thing that I always point out to
people is little button down the bottom
of the UI which actually allows you to
export your configuration so if you've
got some complex configuration and
you're terrified about things blowing up
and a puff of smoke you can actually
export that as a JSON file and if the
worst comes to worst you can rebuild
your environment and reload that
conflict there's a command-line
implementation of that tool as well it's
basically rest-based right so you could
write your own administrative tools as
well that utilize that restful interface
security it's been too long on it
although it is a fairly important topic
obviously RabbitMQ has a notion well
amqp has this notion of virtual hosts
and that's kind of the first level of
security you login what virtual hosts do
you have access to that's the first line
of protection I suppose and then users
and permissions you can get quite fancy
here you could actually give somebody
permission to create resources like
exchanges and cues but not give them any
permission to read or write messages
alternatively you could have somebody
who could write messages so they could
be a publisher but they couldn't consume
you could give somebody read permission
they can consume messages but they can't
publish and so forth and you can get
quite granular by applying regular
expressions to to apply those settings
across sets of queues and exchanges and
other resources okay just to be
completely non biased here just some
other amqp implementations open a and Q
I talked about unfortunately the I
mattox guys for various reasons that we
can discuss over a beer pulled out of
the amqp working group some time ago
cupid and and red hats offering
essentially fairly closely intertwined
and there's some organizations like
stormy and q and swifty and q that offer
amqp as as a service there's another new
one was a cloud amqp based out of Sweden
which is entirely remedy and Q based
amqp cloud offering okay rabbitmq
plugins like i mentioned earlier well as
per the abstract RabbitMQ supports
plugins it's a very powerful feature
leverages and capabilities of erling
that we'll talk about soon and it allows
you to do some pretty cool stuff to
extend the broker what can you do with
plugins well this is probably not a full
set by any stretch of the imagination
but the key things you can do is you can
incorporate support for other messaging
protocols and it'll be the focus of the
next section of the presentation really
you can you can create plugins that will
provide alternative authentication
mechanisms like LDAP or Kerberos this
and people working on that at the moment
all them for me no alternative message
stores at the moment essentially
RabbitMQ uses pure Erlang
tables and various other bits and pieces
for message stores if you feel so
inclined you could write an alternative
message store if you decided you didn't
like the way the guys have done it and
you could run that up and and cross your
fingers you could add extra
functionality to the broker the
management plugin is an example of that
and there are plugins like the shovel
and Federation plug-in that allow you to
move messages around in different ways
between revit mq instances shovel for
example is a good way to move messages
across wide area network lengths that
may be a little bit flaky at times or
otherwise constrained last one I've got
there is you can define other exchange
types i've highlighted the react one
simply because there's a lot of react
guys here it's also when i've been
playing with a little bit recently
essentially with the react exchange any
message published to that exchange in
addition to being routed to one or more
q's will also be pushed off to to react
why would you write a plug-in well
because you might have no other way of
implementing the functionality that you
want to implement would probably be the
most common one it with the plugins you
actually have some pretty low level
almost too much i would say access to
the internals of rabbit you can tap into
whatever functions are lurking around
within rabbit to leverage them within
your plugins if it makes sense to do so
obviously it has some performance gains
possibly in some instances you might be
able to write equivalent functionality
that lives outside of rabbit but by
packaging it with rabbits you're not
only going to get performance gains
because it's it's plug straight into the
vm near it might also simplify things
from a deployment perspective you can
create a kit that includes all your good
stuff along with the core product like
i've said there i mean this is this
would be a workshop session if we wanted
to learn how to write plugins and key
points really are you know if you're a
skilled Erling developer you're probably
going
relatively straightforward and the rabid
mq team do provide some pretty good
documentation around all of this for
writing plugins and you know my favorite
hobby of course is well what can I steal
or borrow from what other people have
done a usual story really it is however
pretty desirable to have some level of
knowledge or understanding of the
internals of rabbit when you start
writing plugins some of that knowledge
may I guess come from studying what
others have done be wary some of the
stuff I've done in this space I did some
work a while back with the rabbit hub
plugin that we'll talk about basically
provides a restful interface into rabbit
within certain constraints but Tony
Garnock Jones who originally wrote it
hadn't had an opportunity to bring it up
to spec and what we were finding is we
were working through the issues was that
you know we were being impacted by the
fact that rabbit had evolved as well so
do be wary of changes to the internals
of rabbit they can have a flow-on effect
into your plugins if you're leveraging
the internals to too much although that
being said that to be honest that the
core rabbit API if you want to call it
that is pretty stable these days and
doesn't change too much you're going to
spend a little while on these things
called rabbitmq boot steps because
they're fairly fundamental when you're
dealing with plugins and it's there some
interesting stuff here around using
features of airlink comes into play
rabbit comprises a number of core
subsystems these core subsystems have
interdependencies which can be fairly
complex and Tony who was one of the
original rabbit developers and also a
fairly fellow countryman came up with
this whole notion of the boots dead and
basically boot step relies on adding
custom attributes into your leg modules
and analyzing those boots debts to
figure out what all the
interdependencies are between the
various subsystems and ensuring there by
that all the subsystems are spun up in
an appropriate order okay
so for example just a really simple
boots tip here that you'll see within
the rabbit in Q code the recovery boot
step they're all they all look pretty
much like this sort of structured as a
description module function arguments so
that's what's going to run for that
particular boot step there may be one or
more of those requires so this boot step
recovery boot step is not going to do
anything until the empty DV check boot
step has successfully completed and once
the recovery boot step is successfully
completed then the routing ready boot
stick can do its thing okay wait seems
simple enough so you know why why go to
all this trouble why not just have a
sequential list of boot steps and you
know everything will be fine well you
probably could do that but it does get
quite complicated boot steps can be
separated into groups and one group of
boot sticks can be enabled by another
and you can also have boot sticks that
that don't enable others they're just
kind of like markers to indicate that
it's safe to go for the next step and
things like that it like I say we're a
bit it's quite complicated process
spinning it up and although there's a
diagram I'll show the next few slides to
illustrate the the various subsystems
and interrelationships and things like
that between them that will give you a
feel for the complexity associated with
the boot process boot boot steps are
important to plugins for example I've
included one here from rabbit hub that I
mentioned earlier the rabbit hub plugin
cannot cannot do anything until routing
is ready okay and routing ready itself
will depend on other boot steps and so
on and so forth the rabbit hub boot step
also has quite a sequence of module
function argument things that it must go
through to spin itself up and kick
itself into life one of which
interestingly enough tax right under
rabbit internals to kick up a supervisor
process
how does it all work I've kind of
described it already your orderly and
programmers see so I'm sure you've
pretty much figured it out I'm early
modules can have attributes you know
these can be exported functions behavior
declarations whatever you like so hyphen
rabbit underscore boot underscore steps
is just another attribute okay so when
the broker starts basically it spins
through all the modules that are defined
in the loaded applications looks for
rabbit boot steps and out of them that
builds a tree a directed acyclic graph
okay and the graph the dag is used to
basically figure out from there what
things need to be spun up in what order
to make sure nothing trips over itself
according to all those dependencies now
this is described by by alvaro in his
book on ribbit ribbiting q rabid mq in
action if you're a revenue and Q user
and you haven't got that book you
probably should go out and get it it's
it's very useful good book so alvaro put
together this diagram it's it'll be a
little bit out of date now in terms of
current rabbit versions but it gives you
some idea of what that that that graph
looks like in terms of all the boot
steps within rabbit I know you can't
read it that's not the point the point
is there's lots of little squiggles and
circles and subsystems and all that sort
of nonsense in there okay I think I've
covered most of this already booting up
a sophisticated application like rabbit
is not a trivial task boot steps make it
a lot easier they make it easier to add
new stuff like plugins and things like
that okay right where this talk started
was as I said right at the start today
was I put together a blog that looked at
all the different protocols well looked
at the different protocols that rabbit
is able to support in addition to my own
QP ok so the next few slides the rest of
the presentation that's really what
we're going to be talking about
multi-protocol messaging why should you
care right via Revit in cuse powerful
plug-in architecture you can implement
this multi-protocol messaging
that comprises a whole pile of open
standards message queuing protocols why
would you want to do that well
flexibility you know this this whole
notion a in QP is pretty good but the
whole notion of having some sort of
singular unique ubiquitous message
queuing protocol that's going to
properly satisfy all your message
queuing needs is a fundamentally flawed
view of the world some messaging message
queuing scenarios you might be happy to
trade speed for message loss for example
when you're dealing with with stock
exchanges and quotes you know quotes are
coming along every few microseconds idea
if you drop a quote or whatever it's not
a big deal because there's another one
coming down the wire when it comes to
actually do a trade you know you're
actually swapping some money there you
probably don't want to lose those
messages so you might want to use a
different protocol or change some
characteristics of how you use your your
current protocol amqp will actually
handle that scenario reasonably well so
probably a bad example but the key point
is that all message queuing protocols
good message queuing protocol share a
lot in common but some of them are
designed specifically to operate beta
for particularly use cases okay like I
said here the world is not uniform just
as there would be advantageous for me
visiting a foreign country and being
able to speak their language the same
goes for message queuing for a
particular scenario that you might find
yourself in needing a message queue one
protocol might be better than another
any attempt to accommodate all possible
scenarios is going to result in
something losing out somewhere you're
going to have to make some level of
compromise okay adaptability as well
okay whilst most good message queuing
protocols share a lot in common some as
I've said are better suited to a
particular task than others adaptability
is also true with something like rabbit
its ability to support these different
protocols tomorrow you might decide that
you've come up with a particular use
case and there's no good message
protocol that supports it so you come
out with a new protocol chances are we
could write a plug-in for rabbit that
would do the business and leverage the
framework provided by rabbit and
erling to make it work pretty darn well
so some of the other protocols that are
supported by rabbit in queues is not a
complete list but it's most of them
stomp MQTT message queuing symmetry
transport reasonably new one zeromq it's
not not too much activity on that
particular plugin lately HTTP rest in
HTTP is not a message queuing protocol
it's I mean HTTP is being twisted and
contorted to do things that it was never
ever intended to do but still whatever
we've stopped I think as a talk probably
after mine that talks more about using
remedy and cue with WebSockets and point
down the bottom of their that like I say
most good message queuing protocols have
many characteristics in common okay and
what this means is that you can match
certain features but one thing they have
in common teens to beacuse so there are
characteristics that you can Matt and
that's what rabbit does with these
various plugins it's not perfect so for
example can RabbitMQ plugin for MQTT
implement everything that MQTT provides
not really it's not a perfect mapping
but it's more than adequate so just for
those who aren't familiar stomp simple
simple or streaming text oriented
messaging protocol really really simple
protocol activemq uses it there are a
few other implementations if you want to
write a client you've got a spare
afternoon you shouldn't have too much
trouble creating one it really is very
simple protocol it's designed as its
name suggests for sending around textual
data and it's pretty slick and nice and
lightweight for doing that sort of thing
stop Maps really quite nicely to the
amqp 091 model so the stomp plugin for
rabbit and cue you're getting pretty
much full or close to stomp coverage
there n qtt was originally devised by
some some guys with with an IBM and IBM
have put that out there for the world to
have fun with and it seems to be
becoming very very active I'd have to
say the MQTT plug in forever D and Q is
reasonably new
maybe a year I suppose the idea of MQTT
so this is a classic case of where I
said that not all protocols are created
equal MQTT supports some bits and pieces
that make it a really good choice for
devices that have to operate in high
latency or otherwise constrained
networks okay some other protocols like
amqp you might have some issues there
MQTT has some characteristics that make
it a better option in those sorts of
environments number of clients available
someone's written there's actually I
think there's two or three erlangen
plement ations and various various
states of condition rabbit hub as an
interesting interview basically a
web-based pub/sub mechanism that
provides you with an HTTP based
interface into rabbit in queue so you
can publish it messages into rabbit via
HTTP and you can consume messages via
HTTP essentially you specify you
subscribe to rabbit hub providing a
callback URL when there's a message for
you rabbit hub will send that out to
that URL one of the key points that I
haven't really mentioned but I hope is
reasonably obvious is that it's not just
you know you don't just necessarily use
the MQTT plugin you can publish a
message via one protocol and consumed at
via another or you can consume it via
multiple others if it's one of those fan
out or topic exchanges for example
there's no restriction in that regard so
I could publish something via in qtt
into rabbit and within certain
constraints I could consume that via
rabbit hub or via a stomp consumer or an
amqp consumer or link utt consumer okay
so you might have some people out there
in the field with the you know
constrained network access or whatever
with mobile devices MQTT might be a
great option for pushing data into into
into your enterprise and within your
within your corporation or whatever
within the local area network that
information might be disseminated by RA
and QP all of these protocols are open
standards right and one of the key
motivations that John O'Hara had was
what he describes as middleware hell
where you've got all these proprietary
protocols that just don't work together
and the point of trying to make down
here I think there's a significant
difference between developing gateways
and adapters to bridge proprietary
message queuing technologies and having
a core messaging technology such as
rabbit that can readily extend via
plugins to facilitate multi-protocol
communication between the seat of open
standards protocols okay it's not you're
not comparing apples with apples there
like i say i work for HP cloud www HP
Cloud com that's our public cloud and my
job there apart from knowing stuff about
revenue and Q is to work with teams and
development of services that we can put
on that cloud and and offer to customers
it's entirely openstack-based cloud
implementation which as I mentioned
earlier relies fairly heavily on revered
in q4 successful operation for just to
put together a few exercises for the
blog post I wrote last year on this
particular topic I put together a six
node reberty in Q cluster and I took a
few risks here just to see in part how
good our cloud walls but because it
seemed like a fun thing to do at the
time I set up a six node RabbitMQ
cluster spending three cloud
availability zones now this is a risky
thing to do when you're in cloud because
there's always the risk of getting
getting a network partition which
confuses the heck out of your cluster
you know if a z1 dropped off there it
would probably end up becoming an
autonomous cluster and we'd have a full
node cluster over there and that will
cause total confusion for people trying
to publish and consume messages of
course but that was what I set up just
for fun I also made a point of
installing different plugins for the
different protocols like stomping MQTT
and rabbit hub in different availability
zones so I could publish a message into
into one of the nodes and AZ one via
amqp and I could receive it out the end
of AZ three via another protocol ok
doesn't matter
it's a few notes about configuration if
you're a rabbit in queue user a few if
you've set rabbit up in the cloud before
then great if not then hopefully some of
what I'm about to say will be useful key
points I can't really comment on Amazon
although I must admit I have helped
people to set up revit in queue clusters
on amazon but i can't claim to talk
knowledgeably about it but certainly
with an HP Cloud and I would speculate
any other openstack cloud implementation
key points listed here ensure that these
ports are open particularly for 369
otherwise your EPM DS aren't going to be
terribly useful to you and also you
probably want to instead if you don't
want to open up every port on your
firewall you might want to use own it
just listen min and Max to constrain the
range of the range of port numbers on
which into inter-cluster intracluster
communication is going to occur okay
you've obviously got to open up 5 6 7 2
which is the default amqp port and the
different protocols that I've listed
there stomp MQTT and rabbit hub which
uses HTTP anyway you've obviously got to
have those ports opened up few other
points to consider everybody knows
they've got a copy there cooking files
around the place will have a common cook
shared cookie etc etc and no big deal if
you need some notes on setting up
clusters on on on Amazon then thats
that's probably quite a good like in
fact I think it's probably got some bits
from me in there just thought I'd put up
a few a few notes about remedy and cue
performance with an HP Cloud it's it's
really pretty down good so this these
results were obtained here I don't know
if you can quite read the numbers from
the back these results were obtained
within HP cloud using a six node cluster
obviously the sorts of results you get
vary as a function of message size so
the graph here essentially is message
size and on the x-axis and rate of
publication and so forth on the y-axis
the primary y-axis so for small messages
we're hovering around 30,000 messages
per second mark which is pretty darn
good and obviously that collect rocks
office message size increases
whole raft of other variables come into
play one thing to keep in mind that i
should mention here when you're dealing
with these multi-protocol scenarios like
i said not all protocols are created
equal and it's going to be particularly
true something like HTTP which is
inherently request response it is one
hell of a lot slower than amqp it has
one hell of a lot slower than MQTT it's
slower than stomp right so if you've got
yourself in a situation where you're
publishing messages flat out via and
Kewpie to an exchange which is going to
route a message to a cue that's going to
be served by a rabbit hub then you might
have a problem because chances are
there's going to be a buildup of
messages it's like at Joe's talk this
morning when he was talking about
plumbing if you're pouring water into a
huge sink faster than it can drain away
it's going to overflow and rabbit
includes a lot of facilities to save
itself and make sure that messages don't
get lost and it's going to start
applying a lot of back pressure to the
person pouring water into that sink so
be aware of the limitations of the
protocols in your mix protocol
environment in that regard cloud impose
throttles are another one for example in
HP Cloud depending on the size of the
the computer instance that you purchased
and set up there will be a throttle
you're not going to get the full 10 gig
or whatever out of the out of the neck
that's that's sitting in the host you're
going to get some percentage of that
okay so be aware of things like that as
well otherwise you might be disability
disappointed at the rate of message
consumption or production just very very
quickly how we go next time five minutes
I think I can probably do five minutes
if I have more coffee I'll definitely do
five minutes examples of motive
multi-protocol messaging I'm just going
to very very quickly blast through a few
really simple examples little bits of
code snippets of code the slides of the
app on the on the site I'm sure so you
can help yourself and have all sorts of
fun with it end and there's like that my
blog site down here key point though is
you can publish by one protocol consumed
by or another etc etc okay so real
trivial examples of nearly in conference
we've got to have some ln code so here's
here's new lang
an early in client that's going to
publish a message this is a direct
exchange stuff essentially actually
we're using the default exchange so it's
basically going to message is going to
go straight into the queue which is
called stomp and we've got a little
stomp consumer down here again written
an erlang that will consume messages
from that queue like I said before you
can have fan-out exchanges so you
publish a message to the exchange and
the exchange is going to route the
message to any Q that is bound to that
exchange okay so it basically just
changed the previous example to specify
the exchanges am kien out which is a
default rabbit exchange we can now have
a couple of consumers consuming messages
from that exchange here's one in Python
and it's an amqp consumer oh here's one
and hurling that's a stomp consumer it
doesn't matter that it's stomp and it
certainly doesn't matter that it's
written in a different language that's
completely irrelevant but this one is
talking stomp protocol this one is
talking amqp protocol they'll both get a
copy of that message not a problem
doesn't matter what protocol you
published with consume less you can mix
and match add in an HTTP consumer just
to be just to be smart here's a totally
trivial little piece of Ruby Sinatra
code which essentially gives me an
instant web server facility sneaky
little curl command to register this
this guy with rabbit hub and I've now
got myself an HTTP consumer which is
going to be bound to the inq fan out
exchange if I now publish messages in
this guy this guy is going to start
receiving them as well this particular
method here the post method is going to
receive those messages okay published by
a stomping HTTP seems to carry on you
can publish fire different protocols
really doesn't matter publish something
here using a simple kill command to the
a and Q phonetics change simple curl
command with rabbit hub and anything
anything any q's bound to am q dot fan
out there going to get a copy of that
message MQTT again similarly we love it
okay so I've complained to the guys
in q that they don't make a big enough
fuss about the fact that their software
supports multiple protocols I reckon
it's a day and good feature it's
something I use all the time it really
is very useful allows you to handle a
multitude of scenarios using the most
appropriate message queuing protocol for
the job at hand that's pretty much it
indeed lovely picture of home any
questions either no one was listening or
I covered everything
yes yeah yeah look I mean I've in
addition to rabbit hub I mean it's like
an afternoon's work to write a module
for Apache I wrote one a while ago
called it Marv a and Q P or something so
I can i can do HTTP POST request to
apache and my day and QP will slug those
messages off to rabbit you know those
sorts of things are not difficult to do
what I recommend it well I need to
understand the entire problem before I
made any comment in that regard
okay yeah i mean i can't really really
call me but what i would say it's you
know if you're familiar with using
rabbit it's pretty darn easy to set
these things up and play around
consistent hashing exchanges is kind of
nice and the guys are also working on
another variant of that which will sort
of allow you to specify ranges as
opposed to sort of small specific values
with the hashing but I yeah I can't
really answer your question I'm sorry
okay thank you very much no problem</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>