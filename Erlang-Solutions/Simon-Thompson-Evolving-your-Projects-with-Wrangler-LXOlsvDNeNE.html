<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Simon Thompson - Evolving your Projects with Wrangler | Coder Coacher - Coaching Coders</title><meta content="Simon Thompson - Evolving your Projects with Wrangler - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Simon Thompson - Evolving your Projects with Wrangler</b></h2><h5 class="post__date">2014-07-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LXOlsvDNeNE" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so this is joint work with my colleague
who qing li who's been developing this
work with me for about seven seven years
or so so i wanted to start by telling
you a bit about what Wrangler is and
then I mean not to overstate it but
first of all it's a tool it's a tool for
doing refactoring and I'll show you some
of that a bit later on and it lives
inside emacs and li de but it's not just
that so another way of seeing it is that
it's a toolkit so we provide you with
certain facilities and you can use those
as you wish yourselves so for example
you can use it from the Erlang shell you
don't have to use it inside ally D or E
max and we got an open API for you to
define new refactorings and we've got a
domain-specific language for scripting
when scripting sort of on steroids for
scripting more complex refactorings so
you don't just have to use what comes
out of the box you don't even have to
use the box as it were and I'll show an
example of that using of how you can
migrate from from one API to another
well what we've done some work in the
past of migrating from reg ex to re
which is the old and the new regular
expression libraries for a lang but what
I'm going to do today is show you how
you can migrate to maps which are in
release 17 from dicked okay but as well
as being a tool kit it's a tool set so
in the box as well as the tool itself
are some other tools for doing things
like clone detection arm detecting
module bad smells and it also
interoperates with other tools like
quick check and and II unit so that it
plays properly with those if you doesn't
allow you to refactor your tests in a
way that will break the conventions of a
particular testing framework and it's
sort of a laboratory for trying out new
things I have some students at the
moment working on using the rewriting
facilities of wrangler to build a
symbolic evaluation
tool partly for teaching partly for
doing refactorings on top of that we've
been playing around with slicing and
doing some concurrency refactorings as
well so there's a whole lot of things
out there in the box so let me show you
some of those but first of all I
realized that not everybody knows why
Wranglers called Wrangler so I thought
I'd just explain that it's an erlang
tool so it does refactoring so we could
have called it our Erlang or rural lang
but we sort of reflected things a bit
and came up with Wrangler so it's an
anagram of Erlang refactor but also a
Wrangler is somebody who does long and
complicated things it's also somebody
who's good at doing mathematical
manipulations so we thought it was a
nice name so just to set the scene there
so Wrangler is a tool arm what we do in
refactoring is we change how a program
works without changing what it does and
it's part of a programmers standard tool
kit that's what we that's what we intend
and some of the things that the things
that typically you do in a refactoring
tools are things like renaming functions
variables modules or whatever extracting
extracting functions from from sections
of code or generalize your function you
already have I've put those up there
because those are the things that people
use the most not just if you're doing
refactoring an erlang but if you do oo
refactoring those are the things that
people those are the things that tools
get used for um why do we build a tool
well the phrase is it avoids the tedious
and error-prone if you've got a large
project and you want to rename a module
then every function call to function in
that module has to change if you rename
a simply a function then every call to
that function across the project has to
change so what we do is implement the
simple refactorings like renaming but
get all the tedious for bureaucracy
right so we cover the whole language in
the case of our language ever whole
project and we play properly with tests
so I was going to do a number of little
demos as we run
through the run through this so let me
start off by so you're going to see this
inside this is aqua max is that can you
read it at the back is it everything
visible a little bigger I can if you
insist you don't really need to read
what the words say but anyway that's
what was I going to look at I was going
to look at this one right okay so what
do we got here we got a simple I said
something I pinched off Francesco it's a
simple ping pong program but let me just
show you the sort of thing we can do I
can rename this function here we've got
a menu or wrangler I go to refactor and
this is a collection of refactorings
that we've got let's rename let's rename
this function it's called NSA let's call
it start a just for the sake of argument
so we need to rename the function and
what will it do it allows us to preview
but let's just commit the change and you
can see that it's changed its change the
name of the function but it's also
changed the name in the export list and
change the spawn there because that Adam
the use of that Adam there we're clever
enough to figure out that that's
actually it's not just the atom in it eh
it's the atom being used as the name of
that of that function so we can undo
that you can always undo and I hope that
that sends everything back to where it
was so that's an example of armed whoops
of renaming but we can do function
extraction so we select some code we
think we'd like that to be a function
let's call it something like which we
call it function that should be all
right and let's commit that and then
what you can see is we've extracted the
function out there and we've got we
replaced the code that with the the
original call was to bye-bye call to
function and then finally what we might
want to do this is doing a number of
things by hand but what we might want to
do is think actually that function i'm
not
he bothered about that message being in
there I quite like to generalize over
that so I can call it with a different
message and that's one of it again one
of those standard factoring so we've got
is we give a new name here let's got msg
oops it failed why did it fail because
we've already got something called msg
so let's do that again and what we
should see is whoa what am i doing
generalize let's call it string and
commit and then you see what we've done
is we've now got a three argument
version that function and it's called
its passing that extra argument there
okay so we can do and let's just we can
undo those things just in case we
decided we didn't want to do that and
we've got those and go back to the
status quo as it was before so that's a
simple the simple sort of refactorings
that we can do inside the tool let's go
back to the the talk so what we've seen
is renaming and function extraction and
generalization so what could we do with
Wrangler is a toolkit well it's written
in Erlang it's just an erlang
application so you can extend it
yourself so situation like that but what
we've tried to do is tidy things up a
bit so we present a nicer view of the
internals to the world that is that is
you so that you can extend it more
easily an hour I the key idea is that
you this is I give you search for image
of Erlang this is what you get or
airline people might be some people in
the audience I don't know um I don't
know what Elizabeth Taylor is doing out
there that anyway she was clearly a an
early adopter of Erlang um you know
Erlang so the assumption is you know
that but you don't really care about
learning and a whole new language for
manipulating airline code you don't
particularly want to learn what the what
the syntax tree is like so what we want
to do is provide you with an abstraction
layer that makes manipulating makes
dealing with Erlang programs that much
easier
so what we've done this is provide two
things and these are complimentary we've
provided an API that allows you from
scratch to define new refactorings so
you can use airline concrete syntax to
say I want to turn this sort of thing in
Erlang into that sort of thing now this
is for refactorings but you can actually
use this for doing more thoroughgoing
translations transformations in that
sense it's quite like the work that
Ricard Carlton has been doing with Merle
I think ours is a bit more cheap and
cheerful probably not as jet not as
general I think but it allows us to do a
lot of the lot of the work that we want
to do so we've got the API we spent a
lot of time thinking well we should be
able to just do one thing but realized
in fact there are two quite separate
tasks going on here one was to define
new refactorings from scratch the other
was for doing putting together existing
refactorings in new and different ways
and what we've done there is build a
little domain-specific language I'll
talk about that a bit later on and
that's embedded itself in Erlang so you
can use Erlang in in working with that
dsl so what have we got in the API what
sort of things will be asked to do
typical cases that people say we wish
you could implement this sort of thing
you have somebody working on your
project they've contributed really a
nice code to your project but they use
the wrong sort of naming they need they
build their names like this with a
capital letter instead of the good
old-fashioned Erlang way having an
underscore you've got a whole lot of
things you want to convert in that way
we can easily do that for you back to
naming of battery naming of modules we
did some work for cubic of transforming
their their their property based testing
models in a particular way they had them
instrumented and they didn't want the
instrumentation in what they shipped so
he gave we put together a refactoring
that supported that and also this this a
PAPR migration which I talked about so
what does the API look like what it's
worth thinking
a bit about what happens when you do
something like generalization if we do
that it's then clear what we need to do
in order to build the API so here we've
got an example of we generalize a
function it was the example I showed you
earlier in fact where we generalize over
that string ping what do we have to do
in order to effectively to describe that
implementation we have to be able to
describe expressions and we have to be
able to describe what they are
transformed to so we have to be able to
say take a pattern like this turn it
into a pattern like this so we need to
be able to describe fragments of the
concrete syntax or fragments of syntax
using lankan concrete syntax but in
order to make sense of this we don't
we're not just doing rewriting we're not
doing the search and replace we have to
do more than that we have to think about
the context and the scope there might be
a whole lot of other modules sitting out
there so we have to be able to describe
the the context of what we're doing and
we also have to be able to do things
like a check here if I said I want to
generalize this function over that
expression I'd like the the refactoring
tool to say no you can't because that
involves a variable that's it's a free
variable effectively so we need to be
able to do check preconditions of of
these transformations so we need to be
able to describe bits of syntax get
transformed to other bits of syntax in
this context with certain conditions
being satisfied so we can't generalize
over over an expression with free
variables or or use the same name as an
existing variable so we need to know
variables in scope we need to know a
number of things like that so we have to
put that sort of information somewhere
available in our in our API and so the
way the API looks if we if we build it
up is we have templates bits of early
Earl and concrete syntax involving
variables that range over expressions
what you might call meta variables
describing expressions
got rules that describe transformations
turn this into this context for
describing preconditions and we have we
also supply traversals foresight to say
how a transformation should be applied
should be should it be applied to a
whole tree or just a portion of a tree
or all the trees that belong to a whole
project we can describe that so the
scenario I wanted to talk about was maps
are in our 17 as somewhat experimental
but one thing we might want to ask is
can we use maps in our project can we
take a project for example that uses
dicked and turn that into a project
using maps well the question we can ask
is are there any non map like uses of
dicked in our project because there is
something that doesn't maps don't give
you the same interface as dictionaries
and so what I've got here is a little
piece of art I've code from our library
you can see it's running top down its
traversing the whole of our project it's
collecting things of this form where you
have a function these are meta variables
they're actually Erlang variables you
can put these in but we treat them as
meta variables it's a function applied
to some arguments and we we want to
check that the function definition info
for that that function is whether it's
in this this list that we've put
together of the things that are non map
life and this is obviously we had to
write this we've examined the API and we
do it over these particular search paths
so that tells us that will search a
whole whole project so that's what we
can do and if you do this on on say
RabbitMQ server we took that a date as
an example we get arm we get these code
fragments and let's go to that and let's
try it live it's always a bit scarier
doing it live oh oh no
I thought I switched everything off
platy Java right okay how do I want to
do that really so in spec X norm for us
so this is a code we've got a module
which has some code inspection
functionality and we want to find we've
written this already it's just got the
code find non math like dick oh oh oh
it's this something funny with it let me
close that if we try it again I don't
know why it does that okay so now it's
checking checking the whole of this
RabbitMQ server and if I turn on sorry
this is a bit compile mode o.o what
compiler sorry this is compilation thank
you others aren't gettin off my
confirmation mode oh he's done our help
should be in here right okay calm down
its capex
there we are so nice thing about Emacs
it will give you live links in here so I
can now click on these and this will
take us to where if I just turn their
size of that down a tiny bit you can see
here we've got we've got a dict merge
usage so we can look across our our
project and see that we've got 10 places
where we might have some problems in
that we have about 170 uses of
dictionary which are fine so the chances
are it would be reasonably easy for us
to migrate our use of dictionary to use
of map if we can sort out those those
particular fragments so and that we just
wrote that it's a few lines of code that
are given us back that that report okay
and yeah 163 fragments which are Matt
like so what we can do now is we have
built into angular a tool that will help
you migrate from dictionary to map what
we do there and it's nothing it's very
nice it's automated but it's not it's
not magic what we have to do is describe
we've got for example a client here of
dicked author and there is dicked itself
we modify that we've got a different API
for for map so the things don't fit any
longer what we do is produce a we define
an adapter dent an adapter module and
what you do that and what our
refactoring to do is fold that adapter
into the client code so it pushes those
changes so your client now looks like a
client of the new code lamely map rather
than the old code namely dicked so this
is the sort of thing we have to write
and it's pretty straightforward at least
on this slide so is key / dictionary you
can implement using the is key
functional maps and simply for two lists
and from lists and size but it does get
a bit more complicated because the api's
are not the same
if you want to see if a dictionary is
empty you have to check the size of a
map and then check whether zero fetches
get fetch keys is keys erases remove
stories put an update has a slightly
different slightly different interface
we can deal with all those things and
fold them into into your client code and
of course you can ship this with your
updated API and we will automatically
generate the refactoring to do that so
you can change your code automatically
so you right or the author of the the
library writes that stuff and then you
can apply the refactorings and that will
turn that into into that which is
written obviously to to deal with the
the examples we've got there now of
course we've also given you the report
about the things we can't translate and
those you have to do yourself but at
least you've only got to look at 10-10
uses of the API rather than 173 which
you would have had before so ship the
adapter we will generate refactorings
from the adapter and then you can apply
those refactorings to your code and I
could just show that in action if I was
feeling brave let's just show you so let
me explain to you what I'm going to do
so we we or you write this adapter then
Wrangler can generate from that adapter
rewriting rules using our language we
compile the rules and then from within
our refactoring tool or from the command
line we can apply those two to do that
adaptation so let me show you that in
action so what have we got so here are
the adapter functions let me just turn
the size of that down a tiny bit you can
see these are the things i showed you
before so and these are the thing you
can see at the bottom those are the
things we couldn't so easily couldn't so
easily translate so we need to think
more about those
or look at I think in particular we need
to look at how you how you've used those
in your project we could write some
static analysis around those but for the
moment we're just thinking about the API
level okay so we've got that and what we
want to do is what we want to do here is
API migration we want to generate the
API migration rules so this generates
the refactorings from our let's call
this reef back which we call it dict to
map right so that's generated and you
can see that's generated a set of rules
that are relatively straightforward here
but you can see what they've done is
that they're matching in a particular
form so it's generated those rewrite
rules from that that file and then what
we can do is I guess we should compile
that just do that inside the shell okay
and then we can take I happen to have an
example here we've got this example file
and then what do i do I go to API
migration I plight the current file and
then i have to say which module i'm
using and that's reef ack dicked to i
want to commit ha yes oh that's relief
so that works so the effort was there
the developer of the of the the API of
the changed API needs to produce the
adapter module we do the rest and you
could just ship the refactoring as part
of the the Wrangler tool okay so that's
that I just put in a slide about how you
can use wrangler outside emacs so that's
there it's documented in the in the
documentation the tool is on github and
there's documentation there about how
you can use it from out
you know if you really don't like using
emacs or Earl IDE we'd love to encourage
you to move it into your own favorite
editor but if not if your favorite
editor is the Erlang shell you can use
it from use it from there okay so
finally saying a bit about the toolset
what we've got in there is clone
detection so we can parameterize because
you think what is a clone what we're
looking for when we're looking for
clones are two pieces of code either
expressions or sequences of expressions
which you can generalize which have a
common generalization now if you've
walked far enough away from any two
expressions they're both generalize by X
so everything in that sense is a clone
but we need to set a number of
parameters when we're looking for clones
and I'll show you that when I do the
demo we've also got an incremental
version of this so you can run over
large projects you can just check have
any new clones been introduced since I
lasted a check and then we've got
automated support for removing clones
using the domain-specific language which
I done talked about yet we've got some
other stuff on on developing on spotting
bad smells cyclic exports and so on in
inside project but let's see what we can
do okay so let me another bit of demo
let's go back to here and let's say what
we want to do is it looks to me like
there is a clone in here lupe and Luke
be look pretty similar but they're not
the same you know they lupe calls with
very loopy course would be they've got
different messages there are and so on
they're not the same code but the shape
is similar so we should be able to we
should expect that we can probably find
identify those as clones let's see if
that works we go to similar code
detection we can either look within a
buffer or we can look across a whole set
of directives let's look just within a
buffer for them
now what do we asked for when I'm sorry
I don't know any way of blowing this up
I'm not enough and remax expert we are
asked for the minimum length of an
expression sequence how big no do you
want to be 20 expressions or could it
just be one we've got a default value
here of five but actually in this case
I'm going to say one so it's the lowest
possible minimum so we're being very
liberal about what we accept as a as a
clone minimum number of tokens so just a
general estimate of the size I'm going
to stick in five here because this is a
small example i'm setting the thresholds
relatively low minimum number of times
it appears just has to appear twice the
next question is perhaps the most the
least obvious maximum number of new
parameter new parameters introduced when
you do the generalization that's
effectively how many places these things
differ what I'm going to say is let's
say four which is the default and then
we've got so we do a measure of
similarity so we measure how similar the
generalization is to the to the
instances of which it's a generalization
I'm just going to say the lowest
possible value not point one here Oh
actually I'm going to close that oh and
let's do this again sorry this is
something going on here which I didn't
quite understand which is e Maxie let's
just do that again detect coded some of
the buff similar code in buffer so we
want to have one we got a five default
default and no point one and you can see
that what it's done is it's detected
that this receive statement one
statement remember it's big that it's
only one statement is it is a clone and
it's found its generalized in four
different ways over that variable there
there's the message it sends their the
target of the arm that message send and
oh yeah they do final the final output
in that in that
time out so what we've got there is a
new so this gives us if we want to
eliminate a clone we simply cut in place
we can cut and paste that into into our
new into our new library now what we
could do then is manually we could we
could aim to eliminate that but in fact
we've built using our dsl we have built
batch clone elimination which we trot
what they supposed to do is any sorry I
needed now what this does is lead us
through the workflow of what you do when
you eliminate a clone so first of all
what we've done is we've introduced a
function called new fun not very helpful
but so let's will leave it as new fun
but it's allowing us to its allowing us
to do that that renaming it allows us to
rename the parameters because those will
be things like message or whatever so if
we say yes we'll go into an interaction
of arm of using those of renaming those
I just say no again for the moment so we
know to exporting it and now what it
does is it runs through every instance
of that clone in the module and it says
so we might say yes to that one and we
might say no to that one and then if we
commit what we should see is that the
first one has been replaced by our new
function and the second one hasn't and
all of that we have a behavior for these
new refactorings we define that allow
them to be done interactively that allow
you to gather information interactively
and so on so we can describe these in a
very compact way using our dsl and so
get that behavior just built on top of
the simple renaming variables renaming
function folding a function body against
a function call and so on so we've got
all those those facilities there now let
me go back to my talk so we've seen that
um
and as you can see I've got an example
here and what we did was run through
renaming the functionary naming
variables week and you're given the
option to reorder variables if you wish
then you can add it you can choose to
export that cloned function and then you
fold interactively decide which clone
you want to replace which you don't now
at the point to make is here that what
we've written is not just a script we've
got to do something in the dsl what we
write is not just a script we have to be
able to do some other things for example
if we're changing names of things we
need to be able to talk about something
that was originally called foo when it's
been renamed to something different and
that new name may be generated by a bit
of program so we have a way of tracking
by their original names things entities
in the program we can generate
refactoring commands so instead of
saying for example we want to rename foo
to bar we can say because we're in a
functional language functions are our
data objects we can say here's the
function for operating over strings that
we use for renaming and here's a
function which will operate over atoms
for example which will tell us which of
those atoms we should apply that
renaming to so we can use these
functional abstractions for generating
refactoring commands we have a high
level description that says rename like
this in everything that meets this test
and then the system generates the actual
refactoring commands for us we have to
think about what happens when a
refactoring suppose you're doing a b c
and you've refactored quite happily with
a and B fails what you do do you back
out of the whole thing or do you carry
on and do see anyway the answer is it
depends so we have to allow for that
control of whether a collection
refactorings is dealt with is a
transaction or it or not that's a that's
with the user and just to say we're
dealing with pragmatics of how you build
these things there's a huge amount i
think what got
completely sidetracked when we first
started thinking about this was Oh what
happens if we do refactoring a and that
enables the precondition of B and all we
could have to do that precondition again
I don't care about that I just want to
do the refactorings and I don't care if
I check a condition twice it's better
than checking at no times so we
definitely wanted to deal with
pragmatics not not theory about enabling
one in refactoring enabling another so
and mentioned this earlier we can use
conditions to to say when you refactor
it when you rename and generate a new
name that's what we did with a camel
case example we have a function that
identifies those camel case identifiers
and another function that transforms the
names and we can track track names and
then we've got this idea of things being
a transaction and this is the
description of what are the the
refactoring you just saw the composite
refactoring for clone elimination looks
like we call things atomic what i mean
by atomic is it's a transaction so the
whole thing is a transaction each of the
components has to succeed for the whole
thing to succeed but you can have
components that are not transaction so
if for example when we're replacing an
instance of the code by a call to the
function we fail we don't care just
leave the instance there it doesn't make
the whole refactoring wrong so this can
be non-atomic and this will so something
may fail in there the whole things that
stage still still still succeeds and the
whole the whole sequence succeeds so we
need that fine grained control of
transaction ality and for example we're
doing at the top level we do an
interactive renaming we say we want to
do this renaming you've got to and de
dum the way we describe the refactoring
is this is enough information for us to
know to put the hooks into our
description the refactoring so when we
passed that behavior to when we execute
that behavior
we know that it requires us to do some
interaction inside emacs relatively and
you've got there repeatedly
interactively so for a swapping
arguments you might repeatedly want to
do that and you allow the user to do it
repeatedly until they're fed up so we've
got that sort of level of control so
it's a bit like a tactic language for an
interactive theorem prover but has some
slaves slight differences on that I mean
the other point to make is that it's a
DSL so the dsl bits are are often
realized as as Erlang macros but what's
nice is that we can because it's a DSL
that's embedded in a functional language
we can use functional bits like this bit
of this closure here and that using a
list flattened so we don't it's not a
separate dsl saudis little dsl embedded
in our line that's a nice it's one of
the nice things you can do but i just
thought is worth showing that slide to
point that out if you want to find out
more about refactoring tools we wrote a
sort of epic thing which just got in on
the ref issue we know yet if this means
anything to you it's it's we just got it
into the ref which was a a research
evaluation thing in the UK the other
nice thing is his is we had a great tour
of of Stockholm yesterday and we
discovered that Rangel skypalace which
was so people have been Wranglers in
Stockholm since the 17th century and
they didn't built palaces more
information is available it's about 10
minutes walk from here so if you're
interested to count wrangle constructing
his palace and I'm sure it's been
reflected over the years
so if you want to get involved we're
very keen to have people who contribute
contribute to development contribute
your own refactorings to our github
repository and we acknowledge support
from from the EU in through the release
project and under protest project so i'm
going to terminate thank you wants to be
brave and ask the freshman so with his
clone detections are you have to think
of these various numbers to begin with
well we provide you with some defaults
you provide some difference but wouldn't
it be nice if you just had some sliders
that you could drag and see clones
appear and disappear that is if you
could do one run of the analysis and
find the whole space and then maybe tell
the user there are clones with the
parameter nor point seven at least and
let the user explore I know that would
be really delicious that's that's a good
idea I don't know how you do sliders in
Emacs right for your eyes yes we could
do so we could do some guessing and ya
don do you guys have a public library of
refactorings young people can contribute
you can put them in here in our yeah
just send you a pull request yep that
would be fine mm-hmm definitely yeah so
whenever I do refactorings with Wrangler
it changes I had a float and it changed
from 3,600 point zero to scientific
notation why and can I stop it that's a
good we use a pretty printer so yes we
should talk about that yes we should be
able to stop that because it was there
for a reason before hands okay after
I've used Wrangler have to go through
and change a couple of parameters or
like one I'm sorry about that send me
the code and we will we will look at it
yeah I'll do it yeah do definitely
down the back of never want ask
questions for the people of the baccarat
they're always event the bad guys switch
on the back row they're reading their
email or sleepy yeah so you're
refactoring of the lupe and loop be
luncheons looked a little bit funny
actually and I think the reason is that
you were your clones are sequences of
expressions not function definitions so
when you have a recursive function you
end up turning the recursive call into a
parameter don't you do something about
that yeah that was a bit yes yeah do we
should potentially be able to do that
it's unusual that you have a single
expression a single expression body
there so yeah that was unusual yeah i
probably had set the parameters slightly
wrongly i'm not selling this parameter
thing am i know you're right i mean it's
old because there's zero argument
functions as well i think that changes
things maybe not no so this pretty
printer is it configure belt because i
noticed that it for example put a lot of
statements on the same line and stuff
like that and it's once code smell for
some people it is configurable yeah i
mean we're using a standard one but it
is configurable yeah send me an email
with the examples that would be good
would it be possible to use Wrangler to
enforce coding standards yes definitely
is it possible now tell us what your
standards are I mean that's that's what
the we have it what the code inspection
functions do what I showed you with the
the finding the non non dicked uses of
non map uses of Dave that's precisely
what we're doing there so you can
traverse the whole of a project matching
doing quite complex matching so you can
do you can do purely syntactic matching
but you can do semantics a way of
matching as well so you could do that
yes so it's only a matter of it's an
iterative
you mean if you can express your coding
standards in it in a reasonably
comprehensible way no and if they are
reasonably coding standards i'm sure we
can we can enforce them we did some of
that we had a project with Erlang
solutions of doing of using their
angular code inspection to give feedback
on on exercise solutions so you can look
for certain sorts of things there but it
you wouldn't you if you can Co if you
can explain them I'm sure we can code
them but it will be good to send me an
email and we'll be interesting to see
what what sort of things you're looking
for yeah yeah so a follow-up question on
the cooling sterner stuff what about
records since they are pretty processor
stuff and we do we do look at things
before the preprocessor afterwards so in
principle we could do that yeah going
once going twice I have one question are
you doing another talk am i doing
another talk yeah this conference yeah
what are you going to talk about I
talked about the release project I'm
doing an overview of release and then
I'm doing a tutorial on Wednesday about
a tool called percent to write is
anybody not familiar with the release
project give us a quick summary willing
for picture talk I think it's okay um I
mean the aim was to take the Erlang
model of distribution and use that as a
way of dealing with massive multi-core
systems so it involves doing things that
the vm level at their language level
some infrastructure and building some
tools that's why wait talk is tomorrow
talk is tomorrow I think same time
tomorrow yeah it's important talk all
right thank you very much okay thanks
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>