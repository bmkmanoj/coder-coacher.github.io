<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2016 - Garret Smith - Here Be Dragons  Charting Parse Transforms In Erlang | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2016 - Garret Smith - Here Be Dragons  Charting Parse Transforms In Erlang - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2016 - Garret Smith - Here Be Dragons  Charting Parse Transforms In Erlang</b></h2><h5 class="post__date">2016-03-10</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/BRi2rDOlPcc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">sorry so parce transforms one of the
more difficult parts of or lying in
particular and it's a rather interesting
feature you don't see a lot of languages
that have this but quick background I'm
a software engineer it to panduit what
we do is build a lot of physical
infrastructure so lately we're doing
some of the software infrastructure runs
data center so the cabling the
networking and lately the software that
ties all this together helps you manage
it and we're using Erlang to control
data centers the buildings and the
mechanical infrastructure in that if you
look at a building like this you've got
vents bringing air you've got
thermostats on the wall and you've got
uh some central computer it's really
running this entire building and the
central computer is directing where it's
pulling air from how much cooling it
needs to put into that air just need to
humidify it and then which rooms it
needs to put that air back into so I
think it's another talk today about
using Erlang as a central nervous system
for the home we we have our application
is very much like that but specifically
for the data center and so managing the
physical infrastructure there I had an
opportunity to write about parse
transform for something that we do and
it's one of these areas that is somewhat
unexplored and so we can go right to our
Erlang manual and figure out what it
tells us about how parts transforms
right it's extremely helpful but what
they do is let you transform a knurling
program during compile time so you can
insert yourself your program in between
the source code and the generated beam
code so look at some examples of how to
do that what's possible if you're going
to manipulate a program you have to
represent it as data you know you don't
want to just manipulate text right
that's not extremely interesting so the
abstract format is how you do this in
Erlang this is the format that your
program takes on as data as it's going
through the compilation process
we'll look at some tools that let us
work with this abstract format it's it's
as you might imagine rather complex so
there's some tools that can help us deal
with this and then we'll look at what's
possible there's there's a number of
parts transforms out there some that you
may actually be using and and not
realize it or not realize how they're
working we'll look at some of those and
some of the implications so that at
least you understand what they're doing
behind the scenes and lastly let's kind
of a fun when you're talking about meta
programming a parse transform is
something that's outside of your module
right and it's transforming your module
during compilation what if you could
bring that inside the module and have a
module transform itself and so we can
have a parts transform with a parse
transform so kind of fun start off what
is it typical compilation process source
code run it through a compiler you get
your your executable or your beam or
I'll see nothing nothing crazy there
unsurprisingly one of the classic texts
on compilers and how they work also has
dragons because they're rather scary
subject but here's the steps that you go
through you you expand macros some
languages like Java don't have these if
you have if you you come from a sea
background right you know there's a
there's a macro processor that you go
through Erlang has the same or similar
macro processor for expanding includes
for defines things like this then you
Lex it so you break up this giant string
of text into smaller strings of text and
then you start to put these together
into this string of text looks like a
function call this one looks like a
variable and you start to build up
what's called an abstract syntax tree a
representation of your program but
without all of the the syntax anymore
that syntrax is AB the syntax is
abstracted away you know you don't need
it it's represented in the the tree
structure lastly you want to optimize
this maybe you can do things in this
compilation step manipulate this parse
tree
to hopefully make your program run a
little bit faster and then finally very
last step you generate the bike code
this is what your your beam will be
executing or your CPU if you're going to
native code this is what the parse
transform does we're going to insert a
little step right in here after we
generate the abstract syntax tree and
we're going to take that entire syntax
tree for a single module pass it off to
your user function you can do whatever
you want with it including completely
clobber it and then return it back to
the compiler the compiler takes that and
continues on through the process just to
get things going this is what an
identity transform so this does no
transformation it just says whatever AST
the compiler gives me I'll give it right
back to the compiler we're not going to
do any analysis on it but you see the
basics we have forms is is the abstract
syntax tree the the way the compiler
gives it to us is not really a tree it's
actually a list of trees and that's just
because of the way the module format
works and options as a compiler option
so now you have access to all the
options that you your your user pass to
the compiler we're going to invoke one
of these we want to run this parse
transform in our code first got a
compilot it has to be executable and you
need to have it on your Erlang path here
you give this parse transform flag to
the compiler if you're doing this in
rebar to quite a bit simpler so you
probably have one of these in your your
rebar comp for logger right parts
transform logger transform you can also
specify the module in line so you don't
want to run this parse transform for
your entire project you just want to run
it for a specific module you put it
right there in the header of your module
all right so what is what is this
abstract format look like we know what
we have forms now how do we start to
transform these forms do something
interesting with it well we'll take this
back from a very very simple example and
then then work up quickly so if you have
this text a plus B times C you're going
to go through break this up into the a
the plus 2b
star the sea and they're still just text
but now they're just smaller pieces of
text then you start to recognize a as a
variable plus as an operation be a
variable operation variable and you
notice even though that the text was
flat the tree is now nested so I'm
representing some of the operator
precedence in my tree so I
multiplication has a higher precedence
this goes lower in the tree when I
evaluate this tree I'm going to do it
bottom up so I'm going to take B times C
and then I'm take the result of that and
add it to a if I changed my operator
precedence put some parentheses in there
so now I want to add first there's no
more elements in the tree I don't put
the parentheses in the trees is the
abstract part of abstract syntax but I
change the shape of the tree so in this
tree now my a and a plus B is evaluated
first the results get multiplied with C
so if we're going to represent this as
data we want to be able to manipulate
this tree how do we do that so not uh
not very complicated here we have a two
pole the first element and the two pole
is the operation that we want to do then
the next two elements are the operands
so we have some very simple
representations in Erlang of how a parse
tree could work let's look at some
examples now real parse trees they get
get quite a bit more complex so here we
have a extremely simple module here we
want to see what this looks like in
abstract format and this is what we'd be
starting to manipulate in our parts
transform as i said the forms is not a
single tree it's a it's actually a list
of trees we see all these module
attributes let's go through these one at
a time so we have the name of the module
here this dash anything that search
through the dash becomes an attribute in
your abstract abstract form we see we
had some options here in this in this
compile attribute but they got removed
and that's because the compiler already
acted on this compiler flag it treats
this inline flag is just like a flag
from the command line and since the
compiler already acted it on it by
calling our parts transform which
happened to print out the subject syntax
listing we don't have it anymore it's
already been dealt with we have a list
of module exports so we're exporting the
hello function of air d1 and now we have
a single function so this one large to
pole represents the entire body of the
function and for every function we have
in the module we'd have one of these
these tuples representing one of the the
internal functions we can start to pick
out from the source text how this
translates into the parse tree so the
name of the function is hello we see
this right here there's all the numbers
these are these are line numbers if that
wasn't apparent so we can take this
abstract syntax tree let's say you know
there's a problem you have this access
to this you want to generate a error
message with where that problem occurred
is part syntax tree your syntax tree
helps you do some of that you can even
regenerate your source file from the
abstract syntax with once you have this
line number information we pick out more
parts of this so we have we have the
variable who we see this in our parse
tree as a variable you can have much
more complex things in your function
call right you can have bindings you can
you can match on a record find out
variables and so we would see instead of
just variable who here we would see a
lot more complex syntax tree for
matching that out and then feeding those
variables into the function body if we
had a win clause this function doesn't
it would go here and we'd see a whole
lot more forms this is the body of the
function it's a list you know and
there's only one expression in this
dysfunction body stealing one item in
this list and it's a call to the iof
right function so we can see where we
can start to pick out the pieces and
correlate between our program and our
syntax tree these are the the arguments
to the the iof right function
so okay we've got a very simple one
let's start start transforming that how
do we how do we do this so we'll work up
a hypothetical application here of a
parse transform let's say we know we
have this at stable and we're having
some contention on it will call it
contentious table because it's very
literal and every time our module code
accesses this at stable we want to fire
off a message to a tracker process and
so this tracker process is going to
collect all these messages and give us
some statistics on how often this table
is being called and maybe even some some
details about that call we could even
include the process ID of the caller so
that we could track not just how much or
how often this table is being accessed
but who's accessing it and how
frequently so we want to find calls to
this let's insert contentious table and
then some arguments we want to insert in
this tree some new code we want well
we'll have a named process at the
collector and we'll tell it we're doing
an insert and who's doing the insert
here and this this becomes a lot more
difficult because we're now matching
parts of this insert call and putting it
in our generated code but what if we
could we could put in that message that
length of the number of objects were
inserting we can insert more more than
one object at a time and that would be
be interesting how do we do that we
don't quite get here but hopefully we
will see some of the tools it would
would let us do this so the first thing
is well if I'm going to match this tuple
from the abstract form at what's going
to look like what do I match on there's
some really great tools from Erlang the
standard library that lets you generate
do some of the tokenizing and and syntax
tree generation so we're using some of
those here Earl scan
generates your your list of tokens so
it's going to break up this string as if
treat it as if it was it was a snippet
of Earl encode give us a list of tokens
we now take those and we pass this to
Earl parse and this gives us a parse
tree excellent we can print that out we
know exactly what this is going to look
like so here's here's what we need to
match on we want to match on a call to
ats module insert function and only this
specific table if we're accessing
another table we don't want to match on
it this last bit here the VAR objects
gets tricky removing might have a inline
list comprehension here and that's
insert it might done just be a variable
might be something really complex and
and this is very general right I mean
you can even have a case statement right
here in this argument position so you're
not going to have this nice variable
variable name here potentially so once
we find this once we match on this what
do we want to replace it with so go
through the same process we get some
summer line code lexa parse it we have
our syntax tree here this is what this
message call looks like in an abstract
format not too bad here we can we can
pick out ok we're sending to an atom and
we're sending a tuple with insert and a
function call to self so here we've got
our transform function we match match on
a sin tax form we're going to actually
pick the line number out here so that
when we generate code and put this into
our parts transform our generated cone
code just happens to be on the same line
as the code that we're matching on so if
you ever try to reverse-engineer this
parse tree back to source code you could
you could do something intelligent with
that once we we match this we insert our
replacement code if we see anything else
in the parse tree we just pass it
through completely unchanged
okay but there's a couple problems so
where we've completely clobbered the
original let's insert code and we've
just replaced it we haven't we haven't
added anything we've just done a
replacement so remember we want to turn
this into two different two different
expressions you different statements but
we don't want to change the shape of the
parse tree we're taking one node out we
want to put one node back into the parse
tree otherwise we've got to get a lot
more information about the shape of this
and we have to rebuild it a lot more
carefully and it becomes extremely
extremely difficult possible so what if
we did this we now have a single node in
a parse tree so we can do a direct
direct replacement with the original
that's insert call and importantly we
have the same expression value so what
if somebody assigned the results of the
ettes insert to a variable wanted to
save that do something with it we don't
want to change the value of that
variable so if we had you know variable
equals this begin end we wouldn't change
the semantics of the program that that's
pretty important and it's one of the
most difficult things to get right when
you're doing the parts transform is do
it without completely clobbering
completely covering the code so here we
go we can complete this now same same
basic process with that begin and end so
you can take that begin end run that
through the tokenizer a parse tree
generator and you can start to see what
the abstract syntax would look like so
that begin and end turns into a block
node in your abstract syntax tree we
have the line number and then we just
have a list of forms so right what does
it begin and end will it begin and an
end just has a whole list of expressions
in it not not terribly complex so we
insert our new code our new ast node
this send operation here
and after that we execute the original
form in whatever it was so again that
it's a nets insert could be be a lot
more complex it have a lot more logic in
it and we're just going to preserve
whatever was there so now how do we how
do we apply this we're matching on a
single form in this ast node some
example code completely hypothetical so
you want to change a username we have a
user ID and the new name is if the user
ID is 0 you're an admin user we're going
to reject you you can't do that
otherwise we're going to look up your
user record we're going to see what
group you're in if you're in this L user
group you know you can't do this you
don't have the privileges otherwise
you're a user and admin no problem we'll
go ahead and change your username for
you so we've already seen got something
much more complex than the original
examples got multiple function clauses
here we've got a when clause we don't
just have a simple variable name here
we're actually doing a record can record
manipulation in the ettes insert so
let's try and see what this will look
like in abstract syntax so here's here's
what we get and wow that's a lot more
complex I I really really don't want to
go through that and figure out a way to
to match on this so so let's take a step
back for a second is there I mean do we
really need to go now go write a
function to walk that entire tree and
just find what we're looking for so just
like that scanning and tokenizing the
standard library comes with the number
of tools they're really helpful for this
standard lib which is where the scanning
and parsing came from it's got it got a
couple of great ones and they all they
all follow this this kind of classic
pattern of how you parse and generate
compile
so epp Erlang preprocessor this deals
with doing your pound defines handling
include files and basically compiling
the one piece of text that then gets
scan that's your next model is how we
turn a block of text into a series of
elements in our language then we take
those elements we go through Earl parse
we build that into the syntax tree
there's a really really handy module
Earl pretty print and so this can take a
syntax tree and go right back to text so
we can now have this complete loop and
especially debugging right you pick out
some of the abstract syntax node and you
pass over Earl pretty print and you can
see exactly what that syntax node would
have looked like in in source code
there's another really handy one Earl
eval and we can use some of this later
that says instead of compiling this ast2
to bytecode or beam I just want to run
it right now which is really fun for for
some other programming woke up a parse
transform that uses that later this last
one this isn't something that you would
use in user code this is more like a
template that you could use to write
your own parts transform and it's the
Earl identity transform unlike the one
that I had earlier this identity
transform actually does walk that entire
syntax tree so it has a function to
match out every different form whether
it's a you know a clause and if a case a
function call ascends whatever whatever
those forms turn out to be and this one
will walk that whole tree and then just
return it verbatim but you can then see
where you I i take this function I want
to match on a function call i'll just
create a new clause for that function
that matches on my specific that's
insert call and i could do it that way
but it's it's an incredibly verbose
especially if you just want to pick one
thing out of a syntax tree and transform
it there's another application part of
the standard distribution that's in tax
tools this is kind of the next higher
level of working with syntax trees that
standard load unfortunately it uses a
diff
a syntax tree and standard load we just
have to deal with that there's there's
no way around it luckily there's some
functions to convert back to the
standard lib format so anything that
standard lib considers to be a syntax
tree syntax tools also considers to be a
syntax tree but not vice versa so if you
do any manipulation listen tax tools
standard live who's going to choke on it
can't can't handle any more until you
revert it back to that that simpler form
at these last two Earl syntax and syntax
lip are probably the most helpful here
Earl syntax has functions for helping
you generate a st nodes so you could of
course just generate the tuples yourself
but you can do this a little more
functionally and then the idea is if
that syntax tree ever changed slightly
the format of it changed you're using a
function interface and your purse
transform is not going to break that
doesn't mean you're insulated two
additions to the language right maps in
an erlang 17 completely new feature
there's going to be new syntax tree
forms to represent all the different
things you can do with a map so and
again if you were using that ID trans
here to write your transform that isn't
going to work anymore once knew new
forms are added to the language and the
syntax tree changes so some of the tools
that that syntax live gives us insulate
us from some of those underlying changes
in the syntax tree so there's a there's
a common pattern to this right we want
to find an ast node of interest we have
an idea what we want to find within the
code we extract some some context some
detail about that we create a new ast
node with something changed in it put
this we want to replace the original
node do this for we want to find all
occurrences of this in the program and
they give it back to the compiler and
the compiler keeps keeps working with it
Earl syntax lib has is exactly what we
want we just want to map we want to
from this ast node to that ast node pass
it in AST we pass it a function and our
function gets called with every single
node in the AST and we have the
opportunity to return a modified ast
node if you just want to do something
like look for patterns within source
code you don't necessarily have to
transform the tree you can do a fold
operation so again you have your
function gets called for every node in
the AST and you can store or accumulate
information about the the nodes that
you're processing there's even this
really really fun beast mapping fold all
at the same time in one pass through the
AST your function now has the ast node
and its accumulator and it has a chance
to both modify the ast node and update
the accumulator for for every every node
in the tree so now okay we've got Earl
syntax lib we want to we want to map
because we want to change something we
can use our transformer function that we
worked up before you notice that we're
not directly passing forms to the map
function so when we get a module it's
really a list of trees it's not not a
single tree so we have to go through
every individual tree in that list and
map it by itself but this bottom part of
ms is fantastic we didn't have to change
it at all this girl syntax lib map was
exactly what we needed this is that
different parse trees I was talking
about so everything that we have in the
bottom we got this tuple format from the
Earl scan and Earl parse which means it
was in the standard lib ast format so as
soon as we pass these forms to oral
syntax lib it's no longer in standard
lib format so before we pass it to our
match function we have to revert it back
to standard lib format of course after
our function Maps it it's still another
under the control of Earl syntax lib so
we have to remain
fit-again back to standard lib form
before we hand it back to the compiler
so that's fantastic right we're done but
why not and-and-and I mean you can you
can start to see all the possibilities I
can take any source code and I can
change it and I can do this for every
module in my entire program this is
fantastic and now I don't have to go
through and manually instrument calls I
can enable it and disable it with a
single line for my my entire application
i mean that's that's awesome but why
wouldn't you want to do this we we just
scratched the surface of the abstract
syntax the abstract format it once you
get started I think it's not as scary as
it as it first seems but it's still
fairly complex and you need an
understanding of the airline grammar and
when you're looking at source code what
abstract syntax does that that parts
into what what structure does it does it
really have I mentioned this before the
liquid the introduction of maps the
abstract syntax can change so if you're
using something like the Earl ID trans
approach where your manually walking
through the entire AST and that AST
changes your code is going to break use
something like Earl syntax lib you're
going to be insulated from some of that
insulated quite a bit it's actually a
really good approach but there's still
some potentials that the language is
going to change in ways you didn't
necessarily for see when you write your
parts transform this is the big one you
have a little bug and it's very subtle
you forgot to account for some
particular use case you know you assumed
that for example let's say we import it
that's insert so we just have our source
code is just insert we didn't have thats
insert would that be the same abstract
format maybe maybe not maybe we need to
match on both of those but that would be
very hard to hard to detect we just
tested it that's insert we didn't test
somebody in
sporting the insert function and then
just calling it like a module local if
we have that bug that just now became
became a compiler bug since we're hooked
into the compiler you know this this one
may not be a huge issue but it could
slow down compilation you now go from
your compiler has to go find your module
load it in past the abstract forms into
your module get it back that can be
quite expensive and there's often often
parts transforms they're already running
so you start to run multiple parts
transforms can slow things down this
one's probably the most important if
you're significantly changing something
which is kind of the point of the parts
transform it can become very difficult
to reason about your code the last thing
you want to do is create mistrust
between what I'm writing what I intend
how I intend my code to work and what
it's actually doing am I am i changing
the the semantics of it in a in a
possibly harmful way so sort out with
those warnings let's let's look at some
parts transforms that are out there
people who develop for various purposes
actually really really fun and they can
get you to think about completely
different different approaches to
solving problems this was the the one
that I I wrote myself so the idea is
we've got some great tools to go from
Erlang to JSON we've got jsx jiffy many
others but they just go back and forth
to things like term lists they can't do
anything with very complex earling terms
and they certainly can't do any kind of
type safety whatsoever everything you
get from json is completely suspect and
potentially dangerous this doesn't
change that it's still potentially
dangerous and suspect okay anything you
get it from the outside is but this does
one thing for you which is really help
you get
structure right I mean let's say you've
got some earling records and you want to
map those back and forth to JSON she'd
be really nice if you could go from my
erling record just to a JSON object none
of the JSON libraries were willing do
that in any way you have to give it a
tuple list or something like that so
this Aeon fills that gap it doesn't do
the JSON parsing it says take your JSON
run it to jsx then hand it to yawn and
yawn will translate this back into an
erlang record and it could even do this
for a type you can say this early this
JSON object try to make it into this
Erlang type and so you're going to do
things like make sure it's got all of
the right fields make sure the fields
have the right basic types you know so
integer integer float conversions that
kind of thing another one is strings
right so jsx just decides everything you
get from json will be a binary well I
wanted a string so do I have to convert
that myself and he on says now if you
say in your type spec that this should
be a string off convert that to a string
for you it can even do atoms and it does
these slightly safely so if you have a
type definition that includes atoms as
part of that type definition then oops I
think I left that out here so privileged
is another type that should be above
this and the privileges or you know
login create delete grant something like
that so these atoms are defined we're at
least protected against creating new
atoms at runtime that's one of the you
know big nasty things you never want to
do is create new items at runtime so
these e on will protect you from that
says if you want this JSON string to be
an atom i'll do it for you as long as
this atom already exists in the early am
no problem so here's what we get what we
have created user record here convert
this from Eon we take the the user
record we give it the module name so the
module name is so the eon can find that
type definition up above and it converts
this to the tuple list that jsx is
expecting now jsx convert this into json
then i want to do the reverse
so I've got my JSON ID code that into my
tuple list and then I say I want to try
to decode that tuple list as a user
record and hey they match at the end
that's pretty awesome so we have we have
an exact round trip back and forth and
then at the bottom this is this is what
the the JSON would look like so you can
see user record JSON looks pretty decent
we've got some fairly straightforward
translation between Erlang atoms and
JSON strings not bad here's what that
looks like as the parse transform I mean
you would think so a lot of the magic of
aeon is not in the parse transform
itself that's that's being done at run
time to convert your tuple list into
into the record but what we don't have
access to at runtime is all of those
wonderful types heaven was just talking
about that in the in the keynote about
about type systems and making them work
for you so once you compile the early
encode all that information is gone you
don't have any access to it it would be
really nice if I could at runtime go ask
hey what was the type of this record or
I defined a user type let's say you know
birthday here right this is a two pole
with year month day and they're all
integers be nice if I could just say I
want to make sure that this JSON matches
this Erlang type so we have to pull that
out of the parse tree luckily it still
available in the parse tree and we
create a new function that stores that
and then can return it on request so
walking through this here I'm pulling
par strands well we'll go to this in
more detail this is a fantastic library
for working with parse transforms
interestingly it uses parts transforms
to accomplish some of its measuring
we're going to delegate the
transformation to this parse transforms
function and it's going to call us so it
handles some of this some of the
reverting for us and the
translation back and forth one of the
biggest things is error handling I mean
your precious transform it's going to
break you're going to have problem
you're gonna have to debug it parse par
strands really really helps with that
and finding out where things failed know
what they failed on syntax lib analyzed
forms this is kind of a way to say I'm
going to take the whole parse tree I
wanna get some summary information about
it what this does is I want to find a
specific attribute in that in that
module and specifically what I'm looking
for where did that go so yeah yeah so I
want I want to pull all attributes out
of my module so that's anything that
starts with the dash I want to pull all
those out I want to process them and
because that's everything that's my
records it's my types all the stuff that
I'm that I'm interested in and I'm going
to pull those out and I'm going to
transform it so that's not here but
really what I'm doing is saying and if I
want to store this for for a run time I
don't care about lying number so I can
get rid of all that information let me
simplify that type type stuff down and
I'll just store that codegen this now
says remember with the the message send
we actually had the abstract forms in
our parse transform what if I could just
write the Erlang code and have that beep
in my generated code that'd be really
nice it's kind of a code Jen does it
says I'm going to create a fun it's a
fun name is is the name of the function
i'm creating and the body of this
function takes a variable returns a
variable attributes and so attributes is
bound outside this this fun definition
here so I'm saying is taking all the
attributes in my module all the types
all the records flattening it into a
list creating a brand new function that
then returns that flattened list and I'm
going to then insert these whole new
forms this whole function that I created
from nothing in back into the parse tree
I have to export it because I want to be
Alexis externally so have to create an
export attribute and then pass it back
to the compiler done
not terribly crazy I mean for something
or something like that now I have access
to every every record and type
information at runtime par strands as I
mentioned before so this is just a not
just this is a library for working
working with parse transformers tons of
convenience functions for almost all of
the common cases error handling is one
of the biggest reasons to use this code
Jen that's what I was was using in that
previous one helps you generate the
syntax trees very simply without
actually going down into the abstract
syntax format and this one's kind of fun
in the previous one we created a new
function but you can create even entire
modules so just completely make up a new
module out of nothing and compile that
there's another part of this library is
x prix i think is how you pronounce that
and similar to eon it says well i have a
record I'm during compilation losing all
the information about that records
becoming a tuple what if I want to
access a field by name at runtime you
can't always you can't you can't do that
with a record syntax so Xbox gives you a
way to take your record definition and
create access or functions that are
exported from your module logger so this
this is probably one of the widest used
ones right now I know we've been using
log very extensively and this uses a
parse transform I was talking to one of
the authors of this last night the
reason for this parse transform it
speeds things up by I think I'm order of
like 30 to 40 times by not logging when
you can so logging in general is is it
very very expensive part of your
application and if you look at any
logging library from from you know Java
Python Erlang they all go to great great
lengths to do everything they can not to
log anything whatsoever
especially not to format your string
because Wow string formatting is
expensive so taking this you know s and
interpolating my variable if there's any
way i can not do that i'd like to not do
that and that's what all of this code
down here is is really doing it says
where's this log message going to go
what's my current log level and is there
do i really really really have to do
this ok then I'll do it that's that's
all that's a lot of code there and
there's another example you see a lot of
intermediate variables you have to be
careful not to clobber those so if
you're creating intermediate variables
in your purse transform you want to make
sure that you know a previous
application of your parts transform
doesn't create a variable that your next
invocation does so all of the variables
you create should probably be unique you
can see although like six is down there
this is kind of a fun one this was been
this was couple years ago the idea of
this one was just to experiment with
different semantics so let's say I have
these these three function calls at the
bottom right ABC there's no dependencies
between each other so I can reorder them
and I you know as long as there's no
side effects it's longer pure functions
I should be able to reorder them just
fine i should be able to paralyze them
just fine what if i could just put it
atom in my list of expressions there and
i have a parse transform just
automatically say run all these three in
parallel and then you know block until
they're all three done because maybe i
need the results of a and the next line
something like that so this parse
transform is is doing that so i can give
it like parallelized next two parallel
eyes next five it's going to find this
atom use it as a marker and then go
through and basically spawn all of these
calls in separate processes collect the
results and then then continue on a
sequential bind this one done by spawn
grid so you might have seen code like
this you've got one variable you want to
do one mutation to it and another
mutation then another
mutation so you've got this like
variable named one variable name to very
low name three and then gee I'd like to
insert something between one and two and
just come on it's a pain sequential
blind was designed to solve that problem
so I give it this @ symbol at sequential
by knows that is special and now every
time i see at on the left side of an
equal sign I increment this internal
counter by one every time i see at on
the right side of an equal sign i just
use the previous value of that that
counter if you go go read some of that
there's a lot of caveats I mean it looks
like it's doing a really cool thing and
it is but you have to be very very
careful that you don't do something like
you know maybe you want to match on V so
V is a record so it it's not not
completely a general general purpose so
okay we've we've built up a parse
transform we've looked at something's
definitely not to do some things are
really cool ideas and kind of fun what
are some of the takeaways the logger use
case right raw speed obviously if you if
you look at what that parks transform
did to one single one single message it
took a lot of work to get that right and
it's only in something like logger where
you have a lot of widespread use where
performance is is extremely critical
that efforts really got going to pay off
the experts use case where you have
extremely repetitive code generation and
I've got a five different records with
10 different fields each really don't
want to create an accessor method for
each one let me just do a write of parse
transform and have it do all that for me
the EON use case I'm losing type
information losing record information
during compilation incidentally I think
logger does something like this so if
you have
record definition it it will pull that
in so it could pretty print your record
so very very similar thing this is lost
during compilation and we want to
somehow preserve it we can do that with
a parts transform sequential blind we
want we want new custom semantics we
just really really don't like this
language feature enough and we want to
go change it the the pair use case so we
have completely different language
semantics and this is really kind of a a
research application it's a lot easier
than writing writing your own compiler
from scratch and and the last one
metaprogramming metaprogramming is
always just fun and makes you think
about things in completely new ways so I
think in the last few seconds here we'll
work up an inline parse transform which
is a parse transform that lets you write
a parts transform that transforms itself
so not well a lot itself but but at
least its own module so this is this is
it I mean this is the entire parts
transform so what I want to do here I'm
going to look for a function in a module
and we're going to say that function
will be called inline transform not a
parse transform has to be arity too so
it's going to have forms and options and
I'm going to pull that out so after
compilation this function won't exist
anymore and then I'm going to take
everything else or so so once i get this
function definition i just want the code
I don't want I don't need to know the
variables oh the wine clauses or if
there's multiple clauses we're just
going to assume there's one so obviously
this is this is not complete this is
this is a minimal for demo but I want to
go into that whole function AST just
pull out the the expressions there now i
want to transform this so this is that
early valve this is where i can just
take an abstract syntax tree and i can
execute it right now without without
compiling it so what I get I have to
manually bind the variables so if you're
in line transform has like a st as the
fur
variable instead of forms this will
break we could pull that out of the
function clause but you know just for
brevity I didn't and then finally you
know last we want to revert the
transform forms back so now our inline
transform doesn't have to do that that
nasty bit and so here we go this was the
example that we worked up before now
it's not an external parts transform now
it would be running as an inline parts
transform within within the module the
the big one here is before we had our
match function external we had as a
separate function but because the module
that in line transform is in isn't
compiled yet we can't call other
functions in the same module they don't
exist so everything here has to be
completely in line so ask me in line fun
but not terrible we still have to do the
revert internally because we're still
doing a map over the forms but not bad
about it's a completely in line module
transform and so now we have a module
parse transform enabling more parts
transforms got a couple minutes any any
questions thanks for coming yeah
um dialyzers working at a different
level yeah sorry thank you the question
is does dialyzer support this just I or
does it does it cry and the answer is
dialyzer doesn't know because what
dialyzer sees is the transformed code so
the transformed code is the source code
that dialyzer dialyzer sees I'd have to
go back and double-check that but
because that transformed code is you
know you know I have to compile your
module debug to get dialyzer to work the
final version of the AST after all the
parts transforms gets stored in the beam
code in debug mode and so dialyzers
working off of that so that tells me I
dialyzer all it sees is the final result
that never sees the original original
source code Yeah right right okay so the
questions about list macros you list
macros have capabilities to solve some
of the problems like variables if I have
two parts or parts transform that I'm
may be executing twice in a row within
the same function and I create a new
variable in the first one maybe that
variable is going to bleed into the
second one and that could be very bad or
it could be intentional right but you
have to have a way to control that in
Lisp which embraces macros much more
heavily than Erlang has great ways to
deal with that the parse trans module
does have some limited ones for things
like generating a unique variable within
a function but your it's gonna be a
little bit more painful than it would be
in something like Lisp Thanks good
question yeah
right no no okay so the question is how
could I change some more basic elements
of the syntax in our line and because of
where the parse transform inserts itself
in the process the lecture is already
run so you can't introduce a new
operator because the lecture is going to
the lecture can't understand that and
the lecture has to run before your parts
transform so you're you're never going
to get to your parse transform and and
the answer is no parce transforms just
can't do that right the way it is in the
in the process now you can take Earl
scan and you might extend that but now
you're not talking or I'll see anymore
you're talking something radically
different than the standard early like
probably a custom distribution over
length something like that other
questions yeah
and core so I'm not not expert at this
but core Erlang there's a is what the st
i think compiles to so the question is a
relationship between a sts and quarter
length so quarter lang is like a
simplified Erlang and it's part of the
the compilation process I think you go
from from a ste to court or Langan and
quarter linked to beam code and so the
the parsed transforms our are right
there at the original ast and that the
court would be generated from are
transformed EST alright fantastic yeah
mm-hmm
yeah yeah so for the video we have the
offer of Earl syntax here and as
missioning Merle is sort of for the next
step after you you understand abstract
syntax dealing with it Merle can now do
this much much more succinctly and
hopefully also insulate you further from
changes in the in the abstract syntax
format so definitely something to take
out if your take a look at if you're if
you're going to be doing this in any
production tech forum thanks for coming</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>