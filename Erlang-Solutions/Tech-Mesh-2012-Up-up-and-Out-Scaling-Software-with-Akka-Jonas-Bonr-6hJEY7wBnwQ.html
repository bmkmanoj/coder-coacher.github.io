<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tech Mesh 2012 - Up up and Out: Scaling Software with Akka - Jonas Bonér | Coder Coacher - Coaching Coders</title><meta content="Tech Mesh 2012 - Up up and Out: Scaling Software with Akka - Jonas Bonér - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Tech Mesh 2012 - Up up and Out: Scaling Software with Akka - Jonas Bonér</b></h2><h5 class="post__date">2013-09-17</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6hJEY7wBnwQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">great conference I'm really excited to
be a amazing line-up limbs for example
of assignments work has also been such a
big inspiration to what we do not go as
well borrow the lot of things from those
house skill in Erlang and a lot of good
stuff out there when we're designing and
building acha a lot of come from closure
as well so so it's a big mix of good of
good ideas at least some of some of the
ideas that i think are gated so I'm the
CTO typesafe types if it's company
behind behind a scholar programming
language the acapella where we also have
a web framework on chops or for do
rest-based mmbc style things called play
to the play wherever I'm sure you've
heard of it so we try to put together a
solid stack like a fool developer
experience but so in this talk today I'm
going to focus only on the icon middle
of our soul away so without further ado
acha i sexually the name comes from from
from this beautiful mountain up there I
was up there hiking and got this got
this so I saw this light and then
there's realized that they had to go
down and build a car so I named the app
available anguish or they the run time
after this is mounting up in the North
amparo Sweden pretty good skiing down
actually as even though it takes takes
about two to get up there so whereas i
can use people who has asked that so i'm
going to start with it just with a slide
showing you some of some of our
production users and as you can see you
leave you go through all of these logos
you might recognize some old some of
some of them at least is that it's a lot
it's a lot of diversity it's a lot of
different industries different domains i
means telecoms we commerce or gaming
betting it's it's
their routers and stuff like that in
investment banks and all kinds of stuff
but the common theme throughout all of
these is that they have this high need
for high-throughput low latency with
extreme high levels of SLA right so so
and the third and the third one should
not be ignored i think that's one of the
most important things that i think i
could try to bring to bring to the table
is the reliability role if you went to
joe armstrong's keynote the rich chick
is keynote earlier as well we talked a
lot of a reliability and for me in with
all actors for many different things and
not guys way more things in its toolbox
than just actors I think that's one of
the key things the way that we have to
think the model enables to write really
resilient software so ARCA is the actual
act actual core libraries is fairly
small as fairly small / has peed so
people are using it all from Android
devices all the way up to like
multi-core boxes all the way up to to
cloud computing so so I acha can really
scale both up and down which I think are
important and it's a platform that you
can use in many different parts of your
system no not not just running in the in
a big cloud but can write it on the
client as well their efforts now that
creating in JavaScript sort of bridge
you can use our parts of it from
JavaScript running in the browser on the
phones and stuff like this there's a lot
of interesting things going on there but
one of the things that give us a choice
of summarize what I can be really tries
to do is manage system overload I mean
when we have too many users to minute
transactions per second that needs to be
we have all the too much data too much
to anything that's that's a really hard
problem that most applications are
facing today and and I think acha and
the ideas that we have there or is it or
something is something that's really
up for the job to deal with these
problems in an efficient way so same
thing like the doing at replication
engaging distribution for fault
tolerance so it really gives you where
your programming at a higher level I
think so what what I mean by that is
that if you look at it started looking
in from from a concurrency standpoint
right we all have have multi-component
phones now and computers etc but i think
that the default way of doing
concurrency in Java C++ C sharp etc is
completely broken is the wrong way of
abstraction I think sometimes you
actually need to go down to that level
if you're rewriting operating systems or
something that you were to really have
to work close to the hardware but other
than that the hardware semantics and for
the primitives the hardware is using to
manage memory should leak all the way up
and into the programming model that we
see a lot so there's a lot of clumping
going on right and we don't want plum me
want to build stuff that useful for for
for our clients of Emperor and for
customers so by by lifting the
abstraction level we instead program and
when we program with messages in an
event-based fashion all this plumbing
becomes workflow okay so instead of
dealing with these low-level constructs
we think about how how to events flow in
the system how the components interact
and since all that is is is managed by
the runtime as it lock less event-based
asynchronous non-blocking events message
passing you get concurrency a really
good skill build a really good resource
utilization as a side effect of that
right but you don't need to think in
architect around that fact right so you
lift the abstraction level to become
workflow I think I think I think in and
as I said I think also on top of that I
think going to talk about later but i
think the actor model has a ver superior
way of dealing with failure test really
makes failures first class but it's part
of your ABI actually it's not an
exception that you might fail is
think that will happen especially to
start running on in in a distributed
environment destiny's instead of dealing
in dealing with it as something that's
exceptional you make the first class in
the programming model and that helps a
lot another thing that I think is really
nice this is that actors really shined
when when it went in when you don't know
if you need to constrain yourself to a
single box or your application might
need to grow across multiple boxes
running in cloud computing etc I don't
think there should be distinct this
distinction between if you want to scale
out on multi-core quad-core 12 core
machine or if you want to scale out on
multiple machines I mean they are all
driven by the same need they're all
driven by the same demands from the from
it's basically just a deployment
decision should i deploy on a single box
you to deploy on four boxes on tan on
100 and that can change as well during
the applications lifetime sometimes
you're perhaps needed for Christmas you
might need about 100 instances that will
you on ec2 but you should also be able
to like scale down and so on so i think
that's elasticity spring is very
important and then I don't then I don't
like the programming model that's or
constrain me in that in that sense and I
could tries to try to do that before
embracing the network embracing the
distributed computing at the at its core
which i believe is message passing and
anything that that is synchronous serve
on the network and RPC and all the stuff
we've seen all them in a long time ago
that's attempts to solve that problem or
fundamentally broken because I mean as
long as you use something on another
machine you will send the packet over
the network so it's essentially message
passing and by making message passing
the program involved that you use your
prepared for that world without having
to do anything then then you write your
system in a way that you can just take
it and start spreading it out to
multiple machines
if needed yeah so you get scale up
multi-core and out so free as part of
the model say it becomes a deployment
artifact and this is another as I will
show you later it's not visible in the
code it's actually something that you
configure how the hard Howard topology
should look okay so you're gonna get all
these nice things are talking about you
Clark unto the elasticity dinama city
and fault tolerance and self-healing and
all that stuff right also gives you way
of writing extremely loosely coupled
model systems since all your components
are well-defined interface is they just
completely reactively consume messages
and and talk to tritter to each other
that means that you can easily swap them
in and out and then there's no just
really no no no strong coupling anywhere
in the system not in the not on
subsystem level not on one individual
component level either which i think is
a big strike so how can we achieve this
yeah innaka we use actors as I said so
what is an actor is it sort of a death
right to it is taught by the way I'm
talking mainly about concepts i will
show you some code but trying to explain
what the actor thinking right what actor
is really different beast as you will
see it's not and it's not a function is
not an object it's it's really something
something special so we use it as our
cast unit to code organization you can
say so we all know this and they
actually help to arrive concurrent
scalable software in a way they look a
little bit like like gaed servlets or
session beans separating the way that it
agri code and you have declared your
policy decisions that are down outside
okay so we don't tangle those things and
as we all know probably as well it's not
a new concept right he will see was
first defined in the paperback call here
with 1973 is picked up by Oh cam Russell
Rock 83 I think Erlang picked it up 84
and so on so it's really proven proven
technology it's just a test in the Java
world around the JVM or in the
enterprise in general except from the
Erlang community I don't think we really
learn to appreciate or everything that
actors can give us so if I not try to
take an actor interactive map to
something that we know okay well you can
see how actor can be used in various in
that scenarios so in one way actor can
be seen upon as the thread right it's a
let's reserve a very bad comparison but
he knew in anybody in a way the actor
serve gives you processing that runs on
a thread while is sexually doing
something but an actor is not bound to
22 or thread you can look beacon you
look upon it to say that it has a thread
while it's executing it can be an object
instance or a component or course great
component and you can use it as a call
back or a listener to something so it's
very common it can be a single ton we
can be a service it can be a router it
can be a load balancer or a pool as well
and as we as we will see it can't during
load actually transform himself into a
router if needed to be able to fan out
and if the load decreases you can become
back to its normal self etc it's a
little bit like JT message-driven beans
you can say but they are very in a way
also very different you can represent an
outer process service that you talked to
they are very often state machines so an
actor is not really something that we
can just map to to the Java world or to
function in Haskell or something like
that it's really something something
different and then and and it takes a
while to to get the feel of working with
actors to appreciate all the benefits of
it if so now we want us just take a step
back first and then see what is the
actor model so that the definition of
the actor ball according to Carl Hewitt
by the way this is a very
great discussion so roll for the fun
discussion on chat on channel 9 or at
work Carl Hewitt and Eric Meyer that are
discussing the gist of the actor model
so something that I can recommend you to
watch if you like so according to Carla
to crawl hewitt an actor is a
fundamental unit of computation that
embodies three things processing storage
and communication so the processing
storage is a little bit like like like
an object right but you also have
communication that's a first class thing
and when when and when an actor missy
receives a message we have three
different actions right that the things
that can that can happen when i receive
a message i can do either create new
actors i can send messages to actors
that i already know where i can also
redefine my behaviors i can designate
how i should treat the next message that
arrives that is something that is
fundamental to the active all is called
a big big become right so if we feel if
you not look at at archive through the
lens of these these sort of three core
primitives and i also added a third one
go supervise because i think that's that
really belongs into the fundamental
model of actors ok so if i start with
with with sorry step zero define an
actor before we can start looking into
the semantics of actually housed how
they behave so the first thing we do is
that we create it's probably its public
API this is scholar code by the way I
guess java api scarlet VI serosa
bindings foreclosure and JRuby and some
other grouping movie so you can consume
it from there more they're more or less
fun and feature-rich but but basically
Russell JVM it can basically consume
sumit from any JVM language if you want
but we support Scala and Java has faced
first class II ok so the first thing you
do is you need to create a public API of
the actor and that is either message it
can receive in this case we we create a
greeting actor and just a message who
we're supposed to greet and then we
create an actor and in scala actress or
classes right there defines classes so
we say we create a meeting accurate
extend actor then we also are now mixing
in the login trait there's nothing that
you'd have to do but if you want to get
get the logging subsystem and that
should be nice and then we have to do
one thing and that is implemented
receive method the receive method in a
survey give he gives you sore a switch
on which messages it should dispatch on
history dispatch table so here we here
we say okay if I get the greeting
message here that I'm k like peek into
it because Carla's pattern matching so I
can doesn't use DD structuring to go in
and fetch whatever is inside the object
and I can just greet that guy hello and
who is a stranger so that's how i can
define an actor now if we want to create
this actor now act then you should know
that actors are extremely lightweight
they are around 300 bikes it means i can
easily create and build millions of
actors on it on a single workstation
depending on how much RAM you have have
of course if you add state to the actor
i mean you have to go through add to
these three hundred bike the stateless
actors are about 300 bucks and this
gives you a way that you can so you can
model things that you can't model with
threads easily see threes if my threads
has a cap over a few thousand right
actors they run on a thread pool as we
will see later they that's abstracted by
what we call the execution context or
dispatchers in a better but one thing it
also worth not noted thing is that
actress they have extremely strong
capsulation a must strong encapsulation
than you have in objects in in in java
for example so they encapsulate state
and behavior but there's really no way
for info on actor to peek into the state
of another actor this is without juicing
some some some funky hack right through
the reflection or other stuff like that
one limitation the job the JVM and one
benefit and sees that we have one be
shared heap in Erlang
or have their own heap so so that's good
in terms of safety it is bad in terms of
performance because it's a lot of coffee
needed to go on so sokka's really really
fast but you have you have to make sure
that you always send the immutable
messages around like values that doesn't
probably heard more than once in this in
this in this talk always using immutable
values okay but but but but that's if
you live within the actor model there's
really no way you can peek into the
state over than other accurate the only
way you can check what kind of state he
is in is by asking okay and then he
might tell you or he might not then the
third thing that an actor ask is is a
message queue alright so so each actor
has this message queue and if you want
to ask an actor or something just send
him a message and it ends up on his
queue and in eae sees later these
letters are scheduled to to process that
message so now if you want to create an
actor the first thing we do is we create
an actor system that's sort of the real
application context you do that we give
it a name names are important in acha
then we then we say system actor up and
then simply sending the props law bit
props the object just like the constant
the configuration here here I'm just
saying what type it should be but you
can you can configure a lot of things
through this prop zombie and those that
maps also well-to-do could the
configuration file so you everything you
can configure there you can configure in
the in the configuration file as well as
you want to do look outside or
application the hero so we give it a
name the names are important here so out
here comes an actor but it doesn't it
you don't get the instance here reading
actor it's not a greeting actor object
that comes out here instead we get a
reference to that greeting act or
something will act to ref and that
decoupling is extremely important first
in terms of safety right so you don't
have public methods and cold acting like
bypassing the whole actor model but even
even even even more important this
decoupling enables you to do things like
like network transparency like location
transparency probably is a better is a
better word it doesn't matter where this
actually used to running it's all
configurable
you can see here I'm creating this thing
but out here comes a reference but the
instance my life writing process here it
might be configured to run on another
machine that's something that the user
of that doesn't have to know something
that that you did the sysadmin whoever
like the rice deploys things besides so
actor form hierarchies that's very
important it ties into due to the
failure model but it also ties into 222
like the which is the way you design and
look up actors by net by it by name so
each each actor each actor system has
like a top-level Guardian actor okay so
if you create an actor from the system
then you create a top-level actor out of
the system guardian okay we named it
fool here you can see then if I then who
inside this actor use the context in
said what's going to happen then then
I'm creating a child with this actor
okay and and so on so on Oh home actor
applications are always trees always
hierarchies okay infirm form for many
reasons if we will see especially when
it comes to the failure the failure
model that's very important but also for
the perfect form for naming convention
because as you see this looks very much
like a file system and and we actually
query actors and look up factors based
on this so so this is / fool this is /
true love /a these are actually names
that that the actors are given in the
world and the way you should you
actually use them okay so the second
primitive is sent if I'm not sure that
we want to send a message to an actor
I'm doing that in an asynchronous
non-blocking fash you know I'm not
sending a message to an actor and then I
go and sit down by my mailbox and it's
wait until the mailman comes and give me
the response right and just send off a
message and I go off and do more useful
stuff I might get a reply later I might
not depends on the applications behavior
of course but I never wait so everything
is completely non blocking your reactive
that also means that is not fully
asynchronous
and then extremely resource so we
utilize the resources burger very very
well so an actor if it doesn't receive
any messages it doesn't do anything it's
completely passive okay so in a way you
can say that that the messages are like
the kinetic energy in in in the actor
system so if i send off off a message
then something's happening with act
actor and he can perhaps start sending
messages to his actors and like behavior
still trickling down and whenever and
when everyone's done is that goes down
to pass it again okay so actors are they
can have a lot of buffered potential
energy but nothing happens unless
something someone is told to start
triggering to my source or start acting
upon that so everything's happening
still a silly reactively which it which
i think is variant is very nice it gives
you this very nice event driven model we
have a premium typical tell we we also
have an alias just this bag ! what's
called the bank operator in Erlang but
we call it tell it's just this is just
an alias you can say greed or dot tell
and pass in this or you can just say
creator tell scholars are flexible and
syntax it's all it all means this is the
same the same thing I'm telling the
actor to do something and I returning
immediately what's going to happen is
that message ends up on his mailbox and
it will later be processed according to
how the scheduler things it should be
processed right so here's a full example
of some running code okay now routers is
another interesting thing they are also
the usual glow balancing and stuff like
that so if you want to create a router
you get you can do it in two different
ways you can do it in code if you know
that you will always want to have a
router so then you can you take some
accuracy with router and then you pass
in mechana rap we should be round robin
and the configuration for that etc all
right i'll share comes around present
then they will spawn up and number of
instances when the message see century
me alone
a round-robin fashion than delegate to
all these and these can be running on
different machines or in the same
machine or that can also change at
runtime you can also add a pools or the
resizer with not for a lower bound if
you want so on it can also do this all
from all from the configuration file so
you can and here you can see here we use
the names again fubar and then the child
of that right so we use names we're
going to configure actors from the
outside that's why I names are important
the third one I want to talk about is
become my become this is the thing that
it where I can so I can change how I
should behave to the next message I
receive and you might ask me why should
I use that it sounds like a very
esoteric feature but it's actually
something that when you get into it you
use quite a lot and you perhaps more
used to that thinking it become from a
functional perspective right with we're
really consent functions around and so
on but from objects you have when you
have static interface it feels really
weird because in a way it's really like
if you take a look at you look at it
from a type system perspectives really
like if the if the actor actually
changed type completely changed its
interface and change this implementation
so so so it will really completely
become something different right and how
and also these behaviors they can be
stacked or pushed or like or
compare-and-swap that's something you
can configure the either it's like push
and pop behaviors so you can go back to
where you were or you can just say I'm
just more replace it okay so the
question is why would you want to do
that here I here are some some some
examples / I where I tend to use that
for example I might have it very very
highly contended actor that can keep up
with the load then you can say now okay
I'm out of here and I don't have to die
what i can do is i can actually become
something else i can transform myself
into router with it with the pool with
after and lower bound for example and
starts spinning up instances on it on
other machines if the cpu
to CC selected turn this attorney to to
become into heart on this on this single
box and when the load goes down we can
like to just just just pop the stack and
go back to normal and of course then
first shut down all these actors and
then go back to normal other other
examples is that one way of you I'm
young I'm implements like finite state
machines is using this I might have for
example in an initial behavior that
except one single message that is start
without going when when i do that i'm
becoming running and when I mean running
state i might do have a lot of messages
i can i can respond to depending on what
i should do for work one of them might
be suspend when i receive that i get
into third state perhaps where I can
just receive oneness it would act upon
one met one message pity that is pursued
then I'm back to running and one hair
might be stopped and then go back to
like the dead end I mean or then I'm so
addicted and garbage collected and so on
so and this makes it very very clear to
implement state machines because for
each behavior there's no tangling
between the different states each one is
extremely clear done in its one specific
function and I can also pass state along
these so it's a very nice way to
implement state machines in otherwise
mple is graceful degradation my crepes
don't want to create a whole bunch of
routers yet they'll be just perhaps just
add to the problem actually might want
to say that the conduct that producers
you just back off I might want to submit
them starts dropping messages I might
want to throw an exception up to my
supervisor it was telling I'm out of
here I can't yeah I can't deal with this
or I might want to do some some
something else and then I can serve when
I'm doing that thing is transformed
myself into that behavior the dust that
start start throwing exceptions to are
dropping messages or or something like
that start like feeding them into the
dead-letter actor sink or something like
that okay I can also do things like
spawning up a whole bunch of empty
workers are running on multiple machines
right and then and then a worker can a
master can come in and you cannot just
are sending out the workers and then
when they're all out there it starts
work when the work was performed the
result disaggregated back he just shuts
he doesn't shut them down because of the
pulp the stacks Joel they will become
empty they still running there for the
next master to come in to start throwing
his workers out and then like these are
pushing up the behavior so that's a very
also nice way of dealing with that so
and I've seen other examples as well so
I think it's a visit a very interesting
way and as to the dine the dynamic feel
of actors even though we run them in
schol or we built them install or java
there static the typed languages they
really give you a lot of field for like
a feeling of being extremely dynamic the
loosely coupled and a lot of things can
can you can do a lot of things that you
can't possibly do using static oh of the
existing and the way you do it is just
to say context of become and here you
pass in your new partial function and
you can also a pass take and become that
pass estate so you can elect actually
take your state and pass along Chinese
cheese into this new closure it's going
to do whatever you want ok so how I'm
doing on time see 20 minutes left right
so failure recovery unfortunately a lot
of clients during my my career I've seen
something like this right if there's
really no way of dealing with faith
failure is something that shouldn't
happen and if it happens yeah ok and we
just restart them box or something like
that right but I think there's a better
way of dealing with this but first let
me start with Iran to I think failure
recovery in Java C to C C++ and so it's
completely broken and I think the reason
is that you're giving a single threat of
control that you do you're working right
so you are giving a single-threaded
world control right is that you let me
do your processing in now if something
goes wrong what if you don't have any
and it's like failure management
mechanisms like which in Java is try
cash guess what you get as a stack trace
although up to your java executor
service and this dead silence no one
knows that ever is something even went
wrong so the only though the only tool
you have is is likely sir is to add the
failure management right where you do
the processing in that single thread
okay which i think is has a lot of
problems because at least you're very
defensive programming it leads to
programming or where the error handling
is really tangled with your business
logic if you just look at any job app
bigger job app off the rack make an
exception handling all over the place
it's a big mess right and i think i
think it's all due to the fact that that
exceptions don't propagate across
threads there's really no error
notification mechanism it just Justin if
it goes through runs through the stack
and that's it right so I think we can do
a lot lot better than this and that's
what actors give you the gives you like
it well defined mechanism to to to deal
with failure okay it's also something
called sometimes go let it crash okay
your embrace failure is really about
making failure a first class citizen in
the programming model is about it's as
important in your actress interflora
components interface as as what it can
do right you might have these these
messes ease methods you can do a B and C
but also the exceptions that is a throne
should be part of that sort of
interfaces as likely that the ticking or
something you can go wrong as it is that
something can go right and then we need
to wait and in to deal with that so this
the fourth sort of the primitive that I
want to talk about in the African baller
is supervision okay and with supervision
you get these notifications schemes you
can have one actor observe
another actor and if they're that extra
this absurd through the child fails then
a notification will be sent up to his
parent and he can react on that and the
nice thing is this according to to the
weights is implemented in both Erlang in
a key and a lot of a language actor
systems is that it's all declarative
it's not about your code that you're
right here instead you declared able to
say this is the way I should react to
this failure and this is the way I
should react to that failure and and so
on okay and this gives you a very clean
separation so the guy doing the
processing he's only doing that he
doesn't care about failure if he dies he
dies no big deal because indicated so he
delegates failure management to his
parent okay there's no like tangling or
or scattering of the of this instead you
instead of having this try casual over
the whole system you architect your
application using a non and you can say
so the way you do it is that the most
important critical state that you can't
lose right you're the essence of your
application you put that in the center
of the awning or in the audience and
then you and then you serve that that's
what we call the error curve by the way
it's just a name for it okay that can't
fail possibly if that fails i am out
basically but what i do then is that a
layer levels of defense around right and
as soon as i'm supposed to do something
dangerous in here I never do it myself I
creates I spin up another actor sort of
a little minion that I can that can run
out on the mind feel that if he feel
like blows up that's fine I can just
create another guy try again and that
mean Ian might say oh wait a minute was
this parent doing I'm not going to do
this he might he might I should spin up
yet another guy so it says that it was
in that way you get layers of Defense
and eventually someone has to do the
dirty work right and he might fail and
then so so and then we have a
declarative mechanism of dealing with
with that failure so you get a system
that looks something like this right we
push down dangerous work
our downwards and so this is what this
means that this guy is apparent for this
he has created him using context a crop
that's all that's needed then he's
managing this guy here okay now if this
guy blows up it's going to happen is
that a notification was sent up and he
can act upon that perhaps restart this
guy and have him try again okay it might
be that that these actors together
implement some sort of service they
might be implicitly coupled then the
supervisor you say I'm not one of them
one of them dies all of them have to go
he used to restart all of them since
notification have to restart yourself
and he and the system can try to
continue okay it might be that the guy
over here actually doesn't happen have
the serve the information you might be
Bobby's pay grade basically to deal with
the error then the arrow is escalated up
thinking of the worst case it might be
in out of memory right there's not
really feasible for any of the layers to
deal with that then it will be escalated
all the way after effort all the way up
to the error kernel and dealt with there
what's going to happen then it's because
you're going to blow up and what's nice
then is that extra system span machines
right so if even if this thing out of
members of guess I'm getting you getting
out of memory error here and
notification will be sent across the
wire up to this guy then he will get
notification see how that whole machine
went down I better do something about
that because you can never build
reliable system just missing one box
right you need at least two or three or
or so and then this might look like a
Singapore point point of failure by the
way but it's not because they will see
in the act in the last part when try to
conclude with the actor clustering which
actually solves this problem okay so by
just creating actors like this context
actor all baba then I'm becoming the
parent of something that I only guy I
create and the default strategy is
usually sufficient for a lot of cases
but you can also of course create your
own source strategy how she reacted
failure and that is something that we
really recommend first the first thing
you should do is you really think
through your failures and you give them
proper types and proper names right so
no not two not justified I'd are through
a runtime exception that's useless how
can you react upon that should be very
specific names well that's actually I
don't have here such a change there
probably but that's where that that is
very important right so you do some
you're the guy that created he might
actually be able to deal with it but if
something because excavated all the way
up to the third layer might not be that
he's prepared to deal with that error
unless really knows how what it's all
about but we have this this relief dsl
so you can say I want to supervise a
strategy in case I get an automatic
exception I want to resume if I get a
null pointer for sample when i restart
the acura forgetting something they also
want escalate up to my parent and so on
and there are more getting more
directives and more things to this but
this gives you the idea you can also say
things i'm not to accept more than 10
number of retries within one minute for
example that something's really wrong
right then i did i'm just the external
service out depending on might not be
there that's why I'm just failing
failing failing it's no use doing that
then I can react differently upon that
so the fuller example here is that I I
over are the supervisor strategy here
and I creating my actors using the
context that I'm become to care then I
become the parent and then I can use him
and if he fails i get a notification and
i'm dealing with the error according to
this the way i have declared it okay and
from the supervised actress perspective
there's a bunch of callbacks that you
can that will be cold right 11 be when
the actor is started like post start
priests priests are post stopped and all
these also pre restart post restart if
the supervisor has to kill the guy that
thing will be called priests are people
call right before so you can clean up
resources can post restore be called
right after you can reinitialize himself
open up a socket or whatever he was
doing right so now going over to
remotely so this was like
if you do if you don't feed this with
any configuration file all run in
process right but now now you can take
everything I've shown you so far and
make it remotely available by feeding
its specific confi configuration about
so the only thing we need to do is say
for this breeder act for example /
greater that's a name of the reactor we
say I want that to be remote and I want
it to be instantiated using the aqha
protocol that's our default protocol you
also have a cluster protocol talked
about just in a second and you can say
okay I wanted it to be running on my
system that can be an IP address or dns
resolver will host name no sorry this is
my money this is the actor system sorry
this in this machine is the IP address
or the hostname min I around some this
port or example what's going to happen
now whenever that guy's created Google
he will be created here right and every
guy that asks for him will get a
reference to the guy running here okay
no no so it's really no code changes at
all okay remote look up looks like this
as well you can say okay I want the Aqua
protocol the acronym of my system in on
this host bubble bar and the user is
actually a user space because we're
different spaces their system space and
the letters and all kind of stuff so so
this all these looks all good no it
doesn't actually this this actually is
not an optimal right why because we have
fixed heiresses like we buy even though
it's been outside in the configuration
file here when we do look up question we
have to know where the where the guy is
right and that's where we sold with like
a cluster that that's coming now and I
got to one that's going to ship in a
week okay so what we add there is first
cluster membership so you can just add
notes on the fly because you get the
elasticity so you will get notifications
when those common leave and we have a
whole bunch of features that take
automatic advantage of that you also
have leader determination of saying
determination because there's really no
election process going on it's really it
can old all the speed statically
determined by every node in the cluster
the leader is but this really what we
call leader election in whatever
zookeeper whatever you write we have a
failure detector and using these things
we implement things like cluster did
Death Watch for example you can monitor
other actors supervision works across
machines even a machine goes down etc
like this we also cluster aware routers
so you can define a router to start
taking advantage of the cluster I want
to show you how in just in a second so
the first the only thing you need to do
to enable clustering is to say I want to
load the cluster extension and then I
have we don't shoot mal use multicast by
the way so we had we need to have an end
and an entry point into into the cluster
so we adopted the same ski in ski masks
you have with with Cassandra but you
have the secede nodes right we perhaps
later do multicast version but multicast
doesn't work on on ec2 cloud
environments for a lot of our clients
run-up stops oh so you needing some some
contact points basically that's the only
thing you need and and and these notes
just take that role in the hatch initial
handshake and then there's nothing
special about them right so you really
get this fully peer-to-peer a masterless
system in which you can actually point
to a lead or if you have something that
needs to be done a bit by specific
leader sometimes some some systems need
that but that's basically everything is
completely masterless and now if you
want to take advantage of this for
example in begin in in the routing you
remember the we could we could configure
a router like this for example say
ecosystem hash and blah blah blah and
then we can just add this did this thing
here seem now should be clustered router
and I can say for example i won't i
won't i went around around this whole
bunch of configuration things here but
this do this shows to that you will
allow to run to round Rowdies on the
local machine in the guy that actually
using the routers have the router
reference and you can see i want mad max
number of instances like three on the
node you can
saysay mekim say that I want maximum 100
instances here what what means by that
is that if I if I have three nodes of
around nine actors right they will
continue to spawn up three new actors
ratties / know the joints until I reach
the calf maximum 100 and there are
different ways you can you can slice the
cake as well but the nice thing is that
the routers are cluster aware so you add
you know they would start using them
remove the nodes they will move over to
the to the to the current running hosts
etc like Susan and stuff like that
another thing that I can also mention is
that we also have the typeset console is
actually currently just the Aqua console
boo and supports rather stuff like play
later but it's a really good way of
introspecting things and we use this a
lot will be developing acha you can get
a lean-to unity get like miscibility on
the node level if you can see the full
system over overview you can sue may not
on a specific dispatcher and see it
seems to me no specific actors and see
like Mabel's mailbox ice and throughput
and stuff like that that's pretty
spreads pretty nice if you want to try
it right now use and go to console
yesterday and other types if calm to see
it in action so that was well basically
what I had in mind talking about i could
give you some you think either we take a
few questions or it can give you what
the next steps with the clustering is I
don't know it's up to you but I just
want to conclude by saying the doc is
much much more it has a lot of lot of
different things for example we in doing
we we interact with with with with us
call STM soccer transactional memory so
you can get to transaction letter actors
I could really composed of a transaction
message flows and then have full full
message flows like roll back with David
data for concurrency we have agents
that's just almost 12 one's completely
stolen from closure say you have the
same semantics which is also very nice
we're dealing with
currency more functional in which we to
send the function to the state instead
of saying state to the behavior in a way
sir ian birds that live it for the nice
ceramic you integration with camel
integration with ain't GOP integration
we have already implemented an event
bastard you can use writer and pops up
on that because and we have abstracted a
lot of things that you need to do in
pattern so it would be pretty nice
parents cattle or for more reliability
durable mailboxes for durability and
cetera so if you want to learn more go
doc of the diode this is our blog or
team blog there's a lot of nice material
there we had a summer a blog where a lot
of people that were using acha i wrote
the blog were blocks over the summer and
if you want to know more about typesafe
latasha calm so that was almost
basically everything I had in mind from
covering so there are four minutes
either we take a few questions where I
can just give you like a glimpse of what
we're working on right now I don't know
what's what you prefer the questions
yeah
but part of me the things that we
provide an API you which you could plug
in we saw abstracted the mailbox into an
interface and we have try to abstract it
as much as possible so you do all the
heavy-lifting but you have to plug in an
implementation we provide one single
implementation that is a file-based if
it's a transaction log on disk on the on
their own and that's on the disk on the
machine that act around song right we
used to actual have many more durable
mailboxes for all kinds of no sequel
databases and stuff like that but it's
true but since we're commercial company
became really hard to support all of
these specially lifted them out but
there there are a lot of community but
community created once the latest model
was gone guy doing interval mailbox
based on a QP for example rabbit so it's
very easy to do it's just a few lines of
code actually to plug in your room but
we provide a sort of file based one
that's the reference
yeah it may mean the guarantees of the
actual dribble mailbox is up to the to
the backend right but we have a bunch of
patterns that tries to build things the
building blocks around that for example
we have peaking pop packing for example
you can first peak it and if you have if
you if you finally actually successfully
executed you can you can you can pop the
message we also have something over the
reliable proxy that that tries to do
redelivery if the myth them if the
network goes down and and so on but but
since all these things has a cost and
sometimes a very very high cost we try
to like provide mean that the raw things
with acha right the thing that's with
the common denominator you can say
provide really really fast message
delivery and all the guarantees you know
that you might need you can collect like
into modules or through patterns that we
have right so that's our for design
philosophy people might ask why don't
you do guarantee delivery on by default
and that's really minden than I asked
every what he want they're like your
most wounds once and only ones I soon
and all have different guarantees right
and honestly I don't believe there's
anything anything like get guaranteed
delivery right thickness and actually
might shut himself down before the
messages even risk mover seed right I
mean it's all it's the ties into
semantics of the application even so
it's really hard to guarantee something
like that Jenner Gin Gin Gin generically
is very much in the hands of the
application developer which we try to
help with tools and patterns yeah
you
yeah you there's the DISA sort of tricky
because he might actually fail just
because he was in the state that that
that he was here I see it's not it's not
that easy that you should just
reinitialize the state he bought and
sometimes that's the right answer
sometimes it's not but with but we since
we have these these these callbacks
right that allow you to that actually
take to the thing the exception we allow
you to actually when things fail you
like past state for the context top to
supervisor and that will be passed in
and you can reinitialize himself with
witness with the same state right or we
can he can be right before he's killed
in a store away state in the database
and read it up or to pay to buddy summer
and then ask for it again there are many
ways but it's hard to say that that's a
good idea right because he probably
failed for a reason and that might very
much differ so so so that's why the
default is just to kill the actor and
have him restart himself into the into
the initial state and then finished
something more he needs to go out and
fetch it so that's that that's just a
default you can you can slice it the
problem in any way you want really so
I've seen any all of the approaches that
I just mentioned I've seen in practice
yeah that is depends on the exception
right if it's a hardware failure you
mean those usual extends air or right so
so then so then it doesn't make sure may
need to make sure that you that you to
take account for that but the default is
it's just terminate is escalated all the
way up and terminate the actor system on
on error so unless you do anything
specific that's it one is going to trace
or terminate
thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>