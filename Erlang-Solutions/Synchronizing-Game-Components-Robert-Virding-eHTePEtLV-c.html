<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Synchronizing Game Components - Robert Virding | Coder Coacher - Coaching Coders</title><meta content="Synchronizing Game Components - Robert Virding - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Synchronizing Game Components - Robert Virding</b></h2><h5 class="post__date">2015-11-05</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eHTePEtLV-c" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so synchronizing game components these
are some ideas I've had on this problem
around round games and getting gaming to
work with getting games to work in more
modern systems so a little bit about
well the classic way of implementing
games internally but we're just talking
the very basic structures hear about it
and some of the problems here that
slightly improved classic way and just
looking at the problems some of the
problems around scalability how you can
get these things to scale and what the
problems are I will then talk a bit
about a way of solving the problem and
give some examples of that of how they
work and don't work and then just a
little bit about talk a little bit at
the end about some problems are doing it
this way which you can run into if
you're not careful when it's actually
very easy to run into these problems so
have some examples around this and i'll
be showing some examples of a very
simple spaceship thing i have which if
you missed the Apollo's but the Apollo
spaceships Brian's spaceships are much
more impressive than my spaceship sir
but they are much more impressive than
mine are you will see you will see okay
so a bit about the classic way of
implementing games how games tend to be
implemented got the right classes won't
know so classically what you would have
you would have 11 loop you get input
into the loop it will then run through
all the objects it's managing and Purdue
whatever is supposed to do with each
object and it will read and write from
the state we're doing these type of
things and when it's done at the end it
would render it will then display the
changes have been made and so on for the
rendering in the input here are in
quotes because you had basically the
same model if you were in a server doing
this in the game server and then of
course you wouldn't be displaying
anything you're rendering in this case
might be sending out information to
players saying what
they should see what's happened from
their point of view but you had this one
one loop going around and in many ways
this was very nice what is very nice if
you're still doing it it gives you
complete control of the state the state
is all yours you are managing all by
yourself no one's going to come in there
in there and fiddle with it you don't
have any timing problems I'm just
stepping through doing one thing at a
time I can access my state as I said
nothing's going to change while I'm
doing these things I'm the only one
who's managing it and that is very nice
when you do run into problems the
execution time of course the more
complex your game becomes the more
complex more work you have to do in each
in each loop here of handling your
objects and the longer time is going to
take or the more powerful processor
you're going to need to handle this and
this is irrespective of whether you're
running the game doing this on your
machine or you're implementing a survey
run into exactly the same problems of
timing and after while your game against
your system becomes too complex and you
won't have enough time to do it in every
loop you want to do or you won't have to
wait until the next generation of
processors come out which are slightly
faster and you can do these type of
things for and you can see this I mean I
used to play World of Warcraft and you
go into some cities in the wrong time
wrong time of day and basically
everything would stop right you jumped
you jump forward and five or ten second
hops we're doing things because we're
just so much going on in the town the
system could not could not keep up with
it now it's basically unplayable the
only thing you could do is just get out
of town basically do that and you run
into the same problems I mean there are
things you can do you can try and be
smart here in perhaps not process every
object every loop but go around to every
other object or something like this but
you will still run into this basic
problem this another problem with this
is while it's nice it doesn't really
scale to parallel systems I very much
like to run this on parallel systems but
it doesn't scale properly there are a
lot of difficulties doing this and
what's happened or what exists now you
get a slightly improve classical way
here so i still have my central
processing loop go
through the objects and doing things
with each object in working with the
states but i might have parallel threads
as I'm running on a multi-core machine i
might have parallel threads doing other
specific stuff so maybe i can move the
market where i can move the graphics out
of my main loop into another core and
let it handle the graphics rendering and
the same thing with AI and physics
they're quite common things to move out
of them out of the main loop so I'll do
less things there in my main loop I can
move these things out and they can run
more or less in parallel but I can do a
lot of smart things with here that's
good because I can now use my a few more
cause of my core machine or 16 core
machine I did before it still gives me
complete control because I'm there's
only really only one thread only one
loop here managing the state I might be
communicating other things they might be
reading things backwards and falls but
I'm still in control of the state which
is very nice control is very nicely I
will still get problems with the
execution time yes I've now moved things
out from my central loop but I still
have this central loop that what you're
doing most of the work but I can't in
this model I can't move as much as I'd
like out because then I'll lose the
central loop which is what I'm after so
maybe the input and the render now have
moved out but there are still processing
all the objects going on down there and
it's only very limited parallelism this
is number of things I can think of
breaking out but I can do these things
for and some of these important I mean I
mean if you look at today's well games
the last 15 years and look at the look
at the graphical interfaces how much
better they're getting and that much
work goes on in doing that anything I
can move out is fine can you we have
these problems you have these systems
today that do that but it doesn't get
you really very far it does helps a bit
but not as far so is that this the
scalability that's a problem we would
like to scale so what we'd like to do is
to take our simple system here basic
system with us with a single loop here a
single thread of execution and yeah by
the way this thing
problem with the thread of execution
it's all about Amdahl's law which if you
go in and look about look read up about
it the math is unfortunately is very
simple and even more unfortunately the
result is very depressing so what is
going to affect if you go back one slide
here what is going to affect the system
the timing of this system is a thing
which takes the most time which in this
case is our central loop I cannot make
it go faster than that loop I can move
things out to try and improve it but it
still is that loop that decides it right
so what I'd like to do I like to take my
system here and i like to make multiple
loops of course so why not have two
loops here working on this then i could
have that basically with bit of luck I
could have the load on each one and now
the system will go twice as fast down
spreading it out onto multiple cores or
multiple parallel systems a problem with
a single rupees of course our processes
aren't getting faster today if anything
they're getting slower we're just
getting more of them so being able to
push things onto more cause is that's
the only way to make systems go faster
whatever you're doing this not just gave
me this is anything wrong so I'd like to
be able to do that I'd like to go on
even a bit further I'd like to have
another call here I like to have another
call with another loop and spread things
out even more and get better processing
like this but trouble is now I'm losing
control of my state because now well in
this simple case I've got through I've
got three three loops all accessing the
same state and working on the same state
so now I'm losing control of it I can't
be certain on the one on the left that
what I'm looking at something someone
else isn't fiddling with it doing
something else whether they're accessing
or changing it or someone else
processing that thing I can do that I
can lock I can put locks around things
this is perfectly feasible it works but
locks slow the system down and they
don't scale the more cause you have the
more threads concurrent threads you have
working on a lock the slower it gets I
can give you some examples afterwards of
examples of this you don't want to do
that and so the more parallelism I
put in here the worst this is going to
get either I lose control or I'll slow
things down by needing to lock and then
I have another problem now after now
when I had a single loop it was easy
with synchronization because there was
just one loop synchronizing I'd run
through one lip and then I'll be done I
could do something else will do whatever
I want to hear i'm now got three loops
in this case so now i have
synchronization problems they have to
synchronize with each other to do these
type of things for then again that runs
into more problems what happened to you
what's the exactly the same yeah well no
there's a little dots at the end saying
yeah I like more I wouldn't just don't
want my 3 i'd like boy i've got y 14 i
want a tie 116 why I can't have 16 on
them I've put an awful lot of money into
buying my 16 core machine i like to use
all my 16 cause when i'm playing my game
so yes then the problems just get worse
than what i do it and the main
probability problem is scalability right
and the basic problem here the way I see
it is that shared mutable state does not
scale okay this is what we're doing
before we had one state and all these
these loops these threads cause however
you want to say it we're all working on
one state and working without and
accessing that mutable state and that
does not scale when you start doing
things on on mutable data when you start
writing things in you have to lock to
make sure you get consistent data in
there it's very easy for everyone just
to read and write right however they
want into the state but then I'm no
guarantees of any forms of consistency
and things might when I started reading
i might get garbage out probably will
get garbage out eventually these type of
things which i need to synchronize you
should put a lot of effort into
synchronizing it and yes as I said you
can do it you can do locking and stuff
that works that's the problem is not
that you can't do it the problem is you
can't do it efficiently
and mutable state is the worst if we're
an immutable state it would be easier it
still has scalability problems but it's
easier to work with and you can get much
further with that if you have immutable
data but then we've suddenly changed the
way we hand we how we write our systems
which is another problem do this so we
need another way and we still haven't
sold the synchronization in the
communication problem between the lips
yeah we yes of course we can synchronize
by writing into our state but that gets
quite difficult to do that to do that to
make sure thing how you synchronize that
to ask you out and poll to see if
something change or not well if it's
changed do I know it's changed properly
how can I tell if I how can the person
writing till I've now read the thing so
they can go and rewrite new value in not
destroy the value i'm reading etc and
you can always be certain that you're
going to run into these problems in your
system I think someone who has talked
this morning about it once in a million
occurs very often right so yes it does
so how are we going to do this we need
another way to communicate and
synchronize and I say the best way to do
this is through messages you send
messages between the various things to
work on this team that's that's that's
how you communicate that say you send
data that's how you say synchronize when
i'm done with something i'll send a
message to those interested in say now
i'm done now it's your turn and where
that then when they're done they can now
say message say okay well we want some
more now this works and it scales as
well too but how we going to do it with
the messages we could do like go does
well at least I've read at least that I
go say that they should they should do
it they're using messages for
synchronization but they're using
they're sharing memory for passing data
so i can write something in that i can
send a message and say now the data is
done here and when they're done that can
send a message back saying okay now read
it and so on and yeah this works
it can be difficult to get right because
it's very easy to break it for example I
can I can forget to reply and say yes
now i'm done with the state now you now
you can modify the state so the process
doing the modifications sitting there
just waiting for it and nothing happens
right I can forget to communicate I can
just some process can just go read data
without worrying about the communication
the messages and just read stuff and
sometimes it might be okay but there's
then you have no guarantees you getting
consistent data out of it putting it as
well too and that can give you very
strange results you don't have to write
many words of data many words at one
time of data to get real consistency
problems for it's very easy to get
garbage I can use something like an STM
which works again the problem is not not
that doesn't work it doesn't scale very
well with mutable data although can
scale quite well with immutable data but
now you're okay now we're getting other
problems as well too so now when we
again this is a problem that share of
sharing a data as well which one says
the SCM does is now we get problems with
locality of reference right now we might
have multiple threads or multiple cores
sharing data they have to access that
and they and then the machine will get
requirements of being consistent and put
things on this especially gets hard if
you're doing well if you look in the
cache because now we've got cache
coherency problems they come in here
because now all the caches in some level
have to be the same the system estic do
this for us and that is not cheap
another problem is well for running a
system with garbage collection or
mutable woman memory management we have
a garbage collection problem so now we
can't just go out and garbage collect
our state because then while other
things are working on it because then
they got what the garbage collector does
of course is mutate the memory so if
someone else is not really prepared for
that we can get a lot weekend a lot of
bad things happening so when you're
doing garbage collection on shared
Murray then you have to synchronize for
which makes the garbage collection much
more difficult and especially if you're
doing something like a game you don't
want the game to stop every minute or so
while it's garbage collecting I think
your users will get very depressed if
you do that which means you need a
real-time garbage collector and that's
no problem I can go look in the book and
I can find a description of a number of
real-time garbage collectors and they
will work but if you're doing sharing if
you've got multithreading doing sharing
then you will have problems with the
consistency in the garbage collector and
you have to synchronize doing the
garbage collector so we're back to the
synchronization problem again right and
I would say the only solution that
really scales is pure message copy
you're sending messages you send data
over messages and that's how you
communicate data between things we don't
share we avoid sharing and we copy data
and yes you you have to pay the price of
copy which is not always cheap but it
gives you a lot of other benefits as
well too you're not sharing there's no
no it cuts down the nut need for
synchronization which if you're really
smart you can want to get it wants to do
the message copying without
synchronizing it can be done or very
limited synchronizing I don't have the
problem of having global garbage
collection because at least on each in
each thread I'll it will have its own
memory so it can quite happily garbage
collect that without having to
synchronize anything else there are a
lot of benefits doing this I get better
locality of memory because everything
the thread has it in one little block of
memory and just working on that I'll get
better locality which improves
everything I'll get better cash usage of
the cash because I won't be sharing cash
they between threads or between cause
they'll be each one over time so I'd say
this is a very good way of making
something that scales so my solution
here is go fully parallel
don't don't don't try to go half step go
to halfway for go fully go fully
parallel pay the price and run
everything in processes so what do I
mean by process in this sense I'm not
necessarily talking about operating
system processes here I'm processed
talking about process in the sense that
there are isolated things they're
running on their owns their their their
own thread of execution their own memory
and things like this they're isolated
and whether these are operating system
processes or green processes wear
whatever you want to call them that's
this sense that is irrelevant and we
communicate and synchronize with
messages that's how we send data that's
how he is synchronized for it this works
right okay we still need some former
central state the thing is we have to
try and do here is to try and minimize
that as much as possible because central
state is a problem and we can do smart
things with it but if we can cut it the
more we can cut it down the smarter it
is the more less work we have to admit
to manage this state and this scales
quite well to be honest it can scale
very well and your problem what limits
the scaling is your shared mutable data
you do need it occasionally you can't
get around it i mean i have one system
which is there might be many processes
but they're working together so they
need to share some things and it's the
shared mutable state that limits the
scaling of it this is where you've got
problems like synchronization ingredient
problems with locks and stuff like this
in it this is what limits it and it
hasn't had the benefit here which I
think's interesting I like implementing
languages so I thought fund this very
interesting here is that the processors
are isolated they communicate with other
processes by sending messages backwards
and forwards so in one sense what goes
on inside one process is completely
irrelevant to what goes on another
process because all it seizes the
message is being sent backwards and
forwards which means it's quite nice I
can implement
processes in different languages I don't
have to implement everything in one
language I can implement the processes
in different languages maybe depending
on who's written them what they're doing
and this type of thing for as well too
it's the only way they interface with
other processes through the
communication through the messages so
what goes on in process is really
uninteresting for other processes just
as long as the messages are right so if
I do a message messaging scheme which
can talk to multiple languages I can
implement things in multiple languages
this can be quite nice because some
things of course much better say written
in c++ if I'm doing the graphics I much
prefer to write that in C++ in then in
say a line unfortunately but other
things logic you lured a I game logic
you might want to write write another
language in doing it this way is quite
easy to do that interface for because
the interfaces through the messages so
now i have a little example i'm going to
bore you with these are my space ships
okay as I said Bryan's with much nicer
I've got many of them that's the only
difference here so I got many spaceships
here and I'm using our lang to implement
this but this is in one sense not
hour-long specific as such you could do
this basically any any language you care
to write the underlying system in and we
do communication using messages this
example it's very simple it has a very
limited shared state and in this case
it's space ships going around in space
and going through passing through
sectors and I can ask a sector which
spaceships are in you do you have in
your sector and that is the only shared
state actually it's also managed by a
process so I'm accessing my shared state
by sending requests to a process so I'm
not actually sharing the state between
the processes there's only one process
managing this state so what when I want
to know who's in which sector I'll ask a
process to do this as well to the simple
logic the ship logic here I'll show some
examples is written in law so which is
quite nice
nice language some of its written in a
line and everything behaves like
processes everything behaves like
processes and all communications through
messages so when you get input from
input from the outside from the user
from outside that's by messages being
sent to various processes when you want
to communicate with the outside world
for example there is a process which
manages display and you communicate by
doing that by sending messages to that
display process basically this we'll see
an example here just telling telling
display what what am i andwhere am I
then the display handles that and the
same thing well I don't have sound but
if I had sound here well be managing the
sound exactly the same exactly the same
way there'd be a sound server you send
messages that sound server telling it to
display so you end up with a system that
looks something like this right so I've
got a big bunch of ships here in the
middle and they're all separate
processes running through here now they
course can communicate with each other
by sending messages which are the green
messages here they're getting input from
the left here being sent into the
various ships about what's going on and
the ship's processes those input when
the ships need to access state for
example it will send request messages
across the state sets telling me give me
this tell me when it in this case which
ships are in this sector and the state
will reply by sending a message back
we're sending things to output down here
by sending messages to the output
devices I've only got one here but you
have multiple ones of course depending
what you're doing if we're talking
server here of course the output when in
this case would be sending messages out
to the client machines running on else's
server but from our point of view is
exactly the same thing that's what
output is right we're telling the world
what what's going on in our system here
and large is going on here and the same
thing if we running on a server input in
this case wouldn't be from our keyboard
or from our mouse or whatever it'll be
coming in from the outside world with
infamy
messages saying what's going on in the
outside world this guy has now pulled
his sword and start hacking for example
fun getting back to warcraft so yeah I
have a little demo of this working and
I'll just show some examples of this as
well too so yes now worth to see if this
go so just start up the system and I'll
show so show some ships and I can also
show we can change code on the ships on
the fly which in this case becomes very
simple because each ship is its own
little state so i can change things for
one ship without affecting in the other
ship and i'll show some interacting
ships as well that's the others goes
shall we yeah now to stop this one up
where are we we will do yes whoa what
happened now typical
sorry
now will do yes now we're running okay
now we'll start up the system here I
don't know how big the screeners will
see we can make a bit bigger than esses
airy and we'll run a thousand ships on
it and then we world how big does this
become ah we could we got to run much
bigger sorry we'll run a bigger
that's a bit better that's a bit better
so this is our world with the chips
actually all right up up and create it
now but now we can just start the clock
and we'll set that 75 so yeah so now but
we've got how many ships first up we
have a thousand ships running around
okay and yes as I said they're very
simple ships I'm not really into
graphics okay so yes before but there
are thousand ships and these are these
are very simple what I think we can do I
think I'll move this over here as well
do you think I dare duplicate soon yeah
do I dare do that we'll have a go if a
crash is all just restarted again we'll
see here this place we can mirror do I
say weird or do other show mirroring I
don't see anything for mirroring here
arrangement mirror displays okay here we
go now we'll see what happens yeah
that's better we'll go back afterwards
where is it display there well yes that
was tiny okay so the screen over on the
right here that's where I'm controlling
the system so i'm now now started up on
a 500 x 500 universe i start up a
thousand ships and they were just
running around and these are just
running they're very simple they're
running in a straight line when they get
to the edge of the universe they just
bounce and come back again right so
we're not doing anything special here
but even they that they are displaying
here so if we go back here and see if
against can we see that can we see the
editor at all who's a visible yeah we'll
see how it goes so for example here if
you look where the cursor is this is
where this is where this ship process is
talking with it with the world they're
not getting any input so these are very
simple here they're just calling the
universe to say where they are so when a
ship moved from one sector to another it
calls universe
REM sectors say I'm no longer in this
sector and it calls universe add sector
so now I'm now in this sector so that
that's that's that's how that's how the
ship is telling the world where it is
and that's just sending messages across
to the universe to the universe server
there and it's doing display here
sending a displays message display
server saying which type of ship it is
which color it is and where it is and
then it's the display during the dots
this is all very interesting as well
because the clock tick for the ship has
got nothing to do with the clock tick
for the display I don't have to worry
about my shipping process fast enough
for display because the display will
just go in every tickets doing which is
every 20 milliseconds and just writing
out what it has so every time I could
change in the next time the display
comes Randle shot the clock ticks now
there were the 75 there that there are
every 75 milliseconds for the ship clock
ticks so now we decouple these by
sending the messages to them and if a
ship moves very slowly does something
very complex well I'll send fuel display
messages it'll take longer time to
change so we can do things we can do fun
things here we can we can change the
type of ships on the run here so we can
take type ships and we will make a run
ship which has different logic and we
will set 500 of these to run ships and
if you look here now if you can skin see
that some ships are becoming green they
are now run ships and they're still not
communicating with the outside world but
they're changing their logic so now
instead of just going in straight lines
and bouncing when they get closer to the
edge of the universe they're going
around now they'll start going around in
a circle for that's doing that this is
just the logic for other it's just how
they move right nothing strange you for
doing these things and again each ship
is one process you can also see the load
down here on the machine if you look to
work right down on the right here we can
do some more we can we can make some
ships that actually interact with the
outside world these are bit difficult to
see the first crop but we will
we will sew these so we're setting will
set the ships and we will set too timid
ship will set 200 loose I think so we'll
go 5 0 1 2 700 that should be right yes
so now if we see some ships turning
yellow now they're getting difficult to
see they're timid ships right so what
happens is they're still moving in there
straight line but if they see another
ship in front of them very close by they
get scared they go yellow and they turn
the other way and they keep going the
other way until they hit the edge of the
universe which in this case they when
they do get that far they turn white and
go back up again and keep going so that
this is just a very simple example of a
timid ship and this is if so the green
ships aren't interacting with the
outside world the timid ships are
they're going out and checking for it
and they do this very simply by weight
we go here and we have two min so here
so this is what this is what this is how
they're doing it they're saying okay
they'll go out again where the cursor is
they will say I'm going to sectors it
I'm going to the sector in X and then
why you asking is there any ship there
that's just what it's saying I mean that
this is sorry if I said this for those
haven't seen this is lower so the ship's
logic is programmed in law the other is
the system is running alling the ship
lodges in lower and this is just asking
is there anything in that sector is
there any ship in that sector I don't
care what it is just asking what it is
right if there is one there if there
isn't nothing will happen if there is i
turn the yellow i turn yellow and I just
flip direction to DX dy is which
direction I'm going x and y is where I
am right so i'll just change direction i
still have the same thing at the top of
the bouncing which for example looks
like this this is the balance very sick
all this code is very simple as nothing
complex here in the code so it's just
checking if I just check where I am
where I'm how far I'm going if I'm in a
new sector the valid x value I just
checks if this is a valid universe
sector if it isn't I just flip
directions
so yeah that's it so yeah okay so got
some interaction now this is a game okay
and the most important thing about games
have to kill things we're not talking
about gambling games here we're talking
about computer games we kill things
right even Tetris you kill things
sectors if they work so so we will set
the ships now to attack ships sorry
correct so we'll make a tech ship so now
these are going to start interacting
with soul state all set we'll set the
last nine hundred ships last 100 ships
sorry 12 to be attack ships right now
they're going red and what attack ships
does is moving in a straight line if
another ship is in the sector in front
of it kills it zaps it and those little
yellow things popping up there
explosions okay I'm not graphics right
nada I don't do graphics so we're
so the red chips are going around and
killing things I'll kill other red ships
as well we're pretty indiscriminate this
is will kill anything that's in front of
us and what we see on the side here is
that well we see the sound so when a
ship dies it goes boom I don't have a
sound server well I have a sound server
just writes boom and then we'll see
later when the ship dies so what happens
is it goes boom then 15 seconds later
the ship dies and if you can follow
these things so now now we see us going
going down we also see the loads
decreasing there so we have these
interactions and the zap ships they're
also the attack ships are also very
simple here and yeah this is the exact
this is a Jap ship zap ship function
inside the attack ship code so it just
just checks where we are if it's if they
find something in the same sector which
is not ourselves before I put the second
check in they were kill itself
it's absent and then it goes and looks
in front is it in the sector in front
one to left the writer kills it was what
another level does that is absent as
well to this is what zapping ships and
it just goes in and ask the universe is
there anything in there what's in there
if there's anything there it kills it if
there's not nothing it does at them so
the whole thing is very very simple the
zapping is just sending a message to
that ship saying you've been zapped then
the ship will receive that and depending
on type of ship it will decide to die or
not this case everything dies when we go
on for we're in discriminant here so
yeah it guess keeps on going and if we
now go back to the talk bit so yeah so
this is just showing this this actually
works for so this is the demo for and I
don't okay yes I could show you one of
these ships nowling as well too so I
could run one of these ships now hang
for it just interacts because it's just
interacting through the messaging
messaging so there's no problems doing
that yeah we saw the attack ships
communication and we saw that we're
sending out put messages for the video
in the sound everything goes through the
messaging there in that sense there is
no real central data even the universe
is actually sending a request to a
process saying tell tell me what tell me
what's there and we'll send it back and
it's managing it yeah this is great it
works however everything is not rosy
here and there are some traditional
things that cause problems amongst other
things synchronous communication that is
a real killer you cannot do synchronous
communication in these types of systems
it just doesn't work you can you cannot
go out and ask something and sit and
wait for a reply because what you might
be asking might be blocking and doing
something else right it blocks the
caller so everything here has to be non
blocking I've just got a final simple
example to show that as well too it's
some depressingly simple so we'll go
back we'll stop the system here and
we'll restart it
and we'll do our what do we take 500 x
1000 this is just saying I'm starting a
universe that's 500 x 500 sectors bigger
I'm putting a thousand ships in it
that's what this is doing and now now
I'm just starting the clock here we can
probably we can bump up the clock if we
want to we'll say will particularly 50
milliseconds except except for every 100
and now things move much faster if you
look here so yeah synchronous
communication so now we will type these
ships and we will call them a flock ship
now what a flock chip is trying to do is
to find other ships around it and try
and move in a flock like a flock of
birds so we will set all these two flock
and try this many formal see what
happens and when a flock ship tries to
go it finds other things it goes green
right to a third star soft brown and
then it goes green when it finds other
things and it starts requesting other
things other ships for it and yeah if if
you ought to look at the stack trace of
all these 1000 processes they're all
waiting for their sent out a request and
are waiting for a reply and it goes
depressingly fast for everything to
block so yes this is just a show that
synchronous communication is really a
killer I'll just show the very simple
code that does this there is a flock
ship nope no one no wait sorry
and we will go down here and here that's
the problem because it goes out and
looks it does happen a ship in front in
the sectors in front of it if it does it
tries to ask it get your position give
me your position and give me your speed
and of course the chances are that ships
already discovered me it's asking me
exactly the same things I'm just sitting
waiting for each other or they waiting
for everything and as we saw on the ship
it goes depressingly faster on so yes
this we don't have time do we run one
more demo yeah we'll do a quickie you
can take questions while running so yeah
so we'll just start this up again and i
just want to show one thing that this
actually does scale right so we'll start
our 500 again and and we'll just run the
ships will just start we'll just to
start running here and we'll start 75
and we just run it now i just want to
show this this is this is a bit of a
line but this is nothing really this
sense they've got nothing to do what
we're doing here so we can we can start
up on a line minus s name ops and i can
start up something in a line called
observer to look at systems and that
should work yes we pop this up hopefully
won't crash now I can look here I want
to look at well this is I want to look
at this node the node which is running
the the simulator here so now I'm
looking at this node here amongst other
things we can see we're running a
thousand 45 processes there the memory
but also as possible possibly it has a
facility to look at dynamic load shots
so we can see the load on the system
here and this is an eight-core machine
so it's running eight or a line call
schedule ism okay I was trying to keep
the load balanced we can see the machine
how it goes near things like this for as
well so now running on eight but let's
see if i can find that screen where was
it this one that's the one I want I can
never remember these
one of the things you can do in there
quite a lot work very well on the
airline system is control the system
while it's running so this this is a
this is our sort of the ad time trailing
okay without now we're doing a bit of my
ailing marketing here no do that sorry
bump bump so what I can tell the system
now is not to use all the cause that's
what it's got but use four of them at
the moment and if we go back and look
here we will see that well four of them
now been turned off and now everything's
moved over to the other for the
remaining for the loads still about the
same we have an effect of the major load
will remove things over so yes we are
scaling we're scaling for we can drop it
even further week if we want to do this
we can do whoops there we go we can do
too so now I can put the two note 2 2
cores here so we are scaling we're
actually moving processes among among
these calls now for it we're scaling and
the whole system keeps on going and if
you notice that nothing happened to the
system while I was moving things around
that's a better for the Aling Aling
system this is a better the fact that I
I am scalable now for and I can go back
we can go back to eight and we will just
see what happens now and wonder then
we're done so we go now we're now we'll
see it's going to move things over to 84
because it's came so things are just
moving between the course so yes this
way of building the systems is scalable
it does work I don't have more than a
well for four cores on my machine so I
can't show you more but I could
otherwise so it actually does work this
way of doling it works and this this is
sort of an hour long detail for but the
basic idea is actually a long
independent if you don't wanna use a
line for if I now start to run attack
ships and started killing things here
would see the load would be going down
because number of ships are dying and
the process of dying the total loads
going down whether I move them or if I
don't that's about it so we'll just wind
up the final slide and we're done
yeah so yes everything you have to be
slightly careful what you're doing you
it changed doing this type of way
changes where you work things and from
unkar things you cannot you have to be
very careful when you're doing
synchronous communication after a while
it becomes completely natural to do this
but two way of rethinking it's very easy
to make things block as I said that that
code I showed you those three lines very
innocuous but they're the ones I've
blocked the whole system because that's
what they were doing before and this was
a final one year the Allen concurrency
model scales and that's me thank you so
any questions 1-3 have fun I don't know
if we have questions and time for
questions but maybe if we just keep
asking until they kick us out then we
will do that any super fun question okay
that real lure or what do you mean we're
you lure lure in luring lure I mean
Lewis has lu f or was another airline
lua that's why that's my implementation
of lure allowing so what was that
cheating with the concurrency because
you weren't actually talking to Lueth
you were well talking to Lord become
more difficult than that sense so now
what this is an implementation I have of
lure in a line it's called the world
it's on github like everything else and
so every every process here was a small
lower machine running lua so the code
the code was real lure but it's running
in allen pro will is real low its lower
code you could you could load that into
a lower system yes well yes I could talk
to I could I could have an interface
which talk to external or lower systems
running those and doing the same code no
no no it it uses it uses the underlying
process is perfectly right you could
talk you could have it you could have
you instead of having your state could
be a number of lower machines and you're
sending requests over to lure and ask
you do this for me and give you back a
value that would work just as well I
just
found this much easier to do before yes
last question I was Joe I was thinking
of doing one in Prolog as well to just
my general critique of the so I think
there's I think there was a nuance point
there about the state management because
you said at one point like you send
messages do you read and write to the
state right so now the problem that
existed in a single node with shared
memory now you're serializing messages
an actor that's doing state management
right so I'm wondering ahem in the model
where you have shared mutable state that
cores are accessing sometimes you can
actually read that state right like if
you know that some portion of the state
is not going to be modified you can do
read only access to that without locking
yeah we're in the model we you have to
send messages and wait for a reply your
if you use something like the gen server
abstraction in Erlang you're essentially
serializing your reads with your rights
and maybe certain game applications
actually don't need that consistency
criteria that's yeah well I mean yes so
in this sense of this demo is very pure
in that it always sounds message so
there's nothing stopping you if you know
you have static data I mean for example
you've got graphical data you're going
to be using the whole time then then you
could put that in some central place
where you're accessing it but then then
you're sharing immutable data and that
that's much easier it's still
problematic in some ways but it's much
easier it's the shared mutable data also
most of the state here of the ships was
in each ship itself so the only shared
data was the universe saying I could ask
it which ships are in it in this sector
and saying I'm now here I'm now I'm not
now no longer here that's the only
shared state under the whole system for
him but yes if you got shared static day
if you have a static data yes you could
share depending on how you do it
different ways of doing that so this
since I'm being very pure
ok</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>