<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Sequential Erlang II by Simon Thompson | 4/13 of Erlang Express Course | Coder Coacher - Coaching Coders</title><meta content="Sequential Erlang II by Simon Thompson | 4/13 of Erlang Express Course - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Sequential Erlang II by Simon Thompson | 4/13 of Erlang Express Course</b></h2><h5 class="post__date">2017-10-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UREGRvK96e8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">in this section what we'll do is talk
about some
structure the gelling provides so we'll
talk about the Biff's which should be
stands for built-in functions we'll talk
about the libraries that Alan provides
we'll talk a tiny bit about the manual
pages and other sources for
documentation okay but let's begin with
the bits so these are functions which
provide either something that is
impossible for you to write yourself or
they provide more efficient
implementations of things that it's
possible to write for oneself like the
function length which works over lists
we'll see a demo of these in a minute
but just to give you some examples you
can get date and time which gives you
day because you date time because you
much more accurate time you can ask for
length of the list size of a tuple and
there are various functions for
converting between different sorts of
types items to list lists a tuple and so
on these are mostly written in c4 for
fast execution and conventionally
they're regarded as being in the Erlang
module so if you call one of these you
don't you have to get tough to name the
module as well as the function so you
can simply call them by writing seven
like date of birth assist those
parentheses rather than having to say
name the Erlang module there are bits
for a whole collection of things Erlang
is a concurrent language and some of the
bits cover process handling port
handling and so on so for communication
others allow you to construct and
destruct complex data structures you can
do some meta programming we'll see an
example of that can convert between
types and gather system information
rescue commands for the operating system
you can deal with distribution in our
like so in each area of our line there
are corresponding built in functions to
allow you to do what you want to do the
manual page gives you for the Erlang
module gives you a complete list of
these we'll have a look at that in a
minute
also there's a list of a number of they
could be
more important ones in the airline
programming book it's important to
realize that Biff's have a slightly
different behavior from other
user-defined functions as as we'll find
out later on airline processes are
concurrent they are executed using a
scheduler and what will normally happen
is that process will be allocated a
certain amount of resource and after you
consuming that resource will be
suspended until it's it's resumed if a
process is executing a Biff it will run
to completion
so it's possible then that a running
bifs inside an airline process can mean
that that process will hold more of the
resources it would were it to be where
it not to contain bits so other
processes will be blocked while the Biff
complete so that's something one needs
to be aware of ok what I'd like to do is
just give you run through some examples
or some examples on the slide and what
I'll do is give you some more examples
in the Erlang shell so what we're
looking at here is some of the examples
of airline bifs the date the time so we
get facilities like that we get
facilities to access lists so we can
take the head of a list we can take the
tail of a list using head and tail we
can take let's just do an assignment so
I don't have to keep writing it down we
can take the length of the list I think
- so on so we've got those those those
structural devices we can also take the
size of a tuple
we can ask for the size of that tuple
just as the two fields and we can ask
for the element at a certain position
and we get the elementary position one
coming out of that so that allows us to
access to access particular elements
from a tuple using using a function
rather than using pattern matching so
those are all built-in we also have a
number of functions which allow us to
convert between so for example if we
take our list we can convert that to a
tuple and we can also convert a tuple to
a list and these would be impossible to
write as functions with Erlang
definitions so we're there we've got
those conversions so we have a number of
it's possible to convert between many of
the types and many others so those are
that's the the general sort of thing
that we can do with Tootles
literally that's the general sort of
thing we can do with built-in functions
so one particular aspect of built-in
functions is that there are certain
sorts of meta calls so it's possible to
call the function to invoke a function
not just simply by applying that
function writing function parenthesis
the arguments between parentheses but
it's possible through some Biff's by
passing atoms to some bits to call
functions that way so there is the Biff
apply particularly weight to which one
passes three arguments module function
and arguments it's the function in that
module is invoked in that way with the
arguments however many there are passed
in as a list now this it's possible for
any of these any of these components to
be evaluated at runtime so it's possible
for you to collect a set of arguments at
runtime it's possible indeed to
like a modular function name which is an
atom at runtime in a similar way so what
I'll do is I'll show you this in action
in the shell let me just show you an
example of a function here it's the list
reverse function you can see what that
does is it applies takes a list and
returns a list with the elements in the
reverse order let me show you that we
can get this in a similar way
by typing the the apply phone by
invoking the apply function with the
arguments lists for the module reverse
for the function and a list containing
the 1 list 1 cover 2 as its list of
argument remember there is one argument
which is itself a list it's a common
mistake to omit those parentheses you
can see here we've got the same we got
the same effect if I show you what
happens if you omit the parentheses
you'll see we're getting aid and an
error there because what this is
equivalent to is calling this reverse
where the arguments won't come or two
and that gives us precisely that same
error so you can see what's happening
there is we've called the list with two
arguments which are numbers rather than
a single list but as you can imagine I
could for sake of argument do something
like this and I could hear pass in an
argument which is itself can compute it
so I don't know what this argument is
without doing some evaluation
and what we see there is that we
evaluate that that final argument and
that becomes the argument to the to the
function so you can't always tell in
advance what those function calls are
going to be and we could similarly
create those atoms list and reverse by
converting from a string which itself
might be computed so that allows us to
do this this dynamic programming by by
constructing arguments or indeed
functions or module names dynamically at
runtime and this is a very nice
mechanism for doing generic programming
in Erlang so we've talked about the
built-in functions which conventionally
live in the Erlang module what we're
going to talk about now are some of the
libraries which are Lang provides four
very important ones are listed here
io dot L gives a collection of functions
which provide input-output functionality
reading characters reading lines and so
on
io format is one of these traditionally
the function that's used for for
producing textual output from Erlang
programs files dot L gives an interface
towards the file system allowing YouTube
to interact with the file system
programmatically lists dot L is a
collection of a huge number of standard
list processing functions we'll take a
look at that in in a minute and code dot
L provides functionality to load test
and manipulate code beyond that there
are libraries for data structures like
arrays queues and so on there are
libraries for protocols so there's a
whole collection of libraries what we'll
do in a second is take a look at the
online documentation where you'll get a
sense of what how many libraries there
are what variety of libraries there are
and these are distributed as part of the
standard Erlang distribution let's just
take a look here are some examples of
functions from the list library let's
just take a look at some of those in
action so what we'll do is take a look
at some examples of the library
functions in the list library let's just
set up some example this first of all
what we can see there is l1 and let's
take it to to be okay so there we are
we've got two example lists what can we
do with them well we can append them and
we know in fact how to append excuse me
we know in fact how to append to less we
can do use plus plus but you can also in
fact use the list append function
oops there we are we've got the same
results as we got using plus plus we can
take the last element of a list we can
delete an element from a list and you
can see here that's that's deleted the
first occurrence of of three in the list
l1 what could we do if we wanted to
delete the last well we could do this
what we could do is reverse l1 we could
then delete three from that that list
and then we could reverse
for what we should see there is we've
got that original list where we've
deleted the last occurrence rather than
the first and you can imagine writing a
function which way you would say delete
the ends occurrence so you'd pass in an
argument where you would you would want
to do that that just gives it a flavor
of the sorts of things that we can do
with lists what I would suggest you do
is look at the documentation for the
list module and in fact what we're going
to do presently is look precisely at the
manual pages and see where we can find
more documentation about Erlang so we've
got the list library how can we find out
more about it well to find out more
about the Erlang system in general we
can look at the manual pages if we're in
UNIX we can use the man pages facility
there in if we're in a browser we can
access the documentation for the
particular distribution that we have
mounted on our system or indeed we can
go to the Erlang dog web page to look at
the the most up-to-date documentation we
could if we're in Emacs we can access
the documentation that way and I believe
we're in L IDE we can do the same what's
most useful is the documentation for
each of the modules and what that gives
us is an overview of all the
functionality that's available in the
Erlang system what I'm going to do now
is show you go to the the home page and
show you some of the documentation
that's available so here we are at the
the home page for Erlang wwl on org and
you can see that this contains
up-to-date news about Erlang and in the
main column information about books on
Erlang in the left-hand column and these
are the Damned here we see the crucial
links that we get for Erlang how to
download the system fa Q's announcements
and documents um getting started
material let's click on documentation
now what we get here again is a whole
selection of of links but the most
important of the links is is right at
the top this is the early OTP release 14
documentation and what we see here this
is as you see the documentation on your
desktop
for the the your dumb the system that
you have mounted there's some basic
documentation at the reference manual
links to some books but where we really
get to see the there was useful
information is in this left-hand column
here information about applications
which we'll be talking about later on in
the course but for a start let's click
on modules and what we get here is a an
alphabetical list of all the modules
that are available so for example you
can see there's an array module and what
we get in here is a an index of the
functions and the functions have a a a
type associated with them saying that
you pass in a function an array and get
back an array so you get documentation
for all those functions there let's move
back to the reference page and let's go
down to the erlang module itself because
that's the one that this gives us a
description of the airline bifs earlier
so we have abs which gives absolute
value of a number down to binary part
down to decoding packets so you can see
that they're a huge collection of
element which which extracts an element
from a turbo tuple to give you a term so
a huge selection of there's a conversion
function for float to list but these are
described with their and it with an
example with a type and so on so this
documentation is really very very
helpful very accessible and gives you a
guide to what you can find in the in the
Erlang distribution if we go down a bit
further we should get to the lists
module again you can see if you look at
the they index down here we have a whole
number of functions to merge to map to
deal with lists that are keyed on
certain certain elements and so on so
again these are searchable of course
using a search function in your
so you get a lot of very useful
documentation they're just taking us
back one level you can see that we do
have there's more a number of other
links there which I would encourage you
to to explore but if you like the
applications menu here gives you the
standard applications inside Erlang and
the the modules particularly are the
things that really help you get started
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>