<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Believe in Erlang in Games - James Mayfield, Mario Izquierdo, Noah Gift | Coder Coacher - Coaching Coders</title><meta content="Believe in Erlang in Games - James Mayfield, Mario Izquierdo, Noah Gift - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Believe in Erlang in Games - James Mayfield, Mario Izquierdo, Noah Gift</b></h2><h5 class="post__date">2013-05-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/SFZV_-Ozyis" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi my name is Noah gift
speaking with a couple other developers
at linden lab this doesn't represent
anything to do with Linden Lab at all
but we just happen to work at linden lab
our talk is going to be on the game
industry and how Erlang fits into the
gaming industry one of the cool things
about this talk is that there's going to
be three people talking and so it's you
know three in one special if one of us
is really bad like maybe I'm already bad
there'll be two other people that and
one of them might be good so that's and
a little bit of the kind of top the
table contents here I'm going to talk
about just how we're able to use early
in a company and what other game
companies or other companies might want
to do in order to advocate or laying in
their company Mario is going to talk
about how he's used rabbitmq in one of
our products and James is going to talk
about how he's done erlang development
inside of a game that's in the in the
iOS platform so the first thing I want
to start off with is that I know a lot
of people say you can't get fired by
using some technology you absolutely
could get fired by using your leg so
let's just get that out of the way a lot
of times people and I've had this a
couple companies that you know this
ireland's functional it's complicated
and a regular programmers wouldn't
understand how to use it you know
pattern matching is very complex and I
think that that's a typical argument
I've heard I've also heard people say
it's just much too complicated another
reason why if you're trying to get early
it to your company that that they may
not want to use it is that it's not java
it's not Python it's not Ruby it's not
C++ it one of the thing is really
surprising is that I've been programming
python since 2000 so it's like 13 years
and I remember when that was people said
that about Python it was like all Python
oh it's this evil you know it's a
scripting leg and I think some of the
same things I think people will say
about her leg the other one too is that
is that you your boss might be an
and I think I think you know I think a
lot of times people aren't you know like
truthful about that and like you you may
just have a dumb boss and or your boss
can't code and it's if you report to
somebody that doesn't write software I
just don't get some of these things like
the nuance is lost on them and so if you
if these are some of the situations then
then you might actually be fired so but
the good thing is that you potentially
can just get a job somewhere else where
there's actually a smart boss and you
know you can work on interesting things
and one of the other things is is that
if you've kind of gone down the point
where you've wanted to kind of fully
commit to using or laying and you think
you can get it moved into your company I
mean I think the number one red flag
that that's somebody that's that's
confident in management would would have
is that you know your first day of the
job you say i'm going to write the
billing system in high school and I
think you've then labeled yourself you
know as potentially somebody who is just
bringing out all these weird ideas and
that you know you can't be trusted to
get things done and so I think this is
actually a really weird strategy that
that I think is a good strategy for lots
of things in life but if you want to get
our laying in your company in your a I
don't know Java programmer and it's day
one or your Ruby programmer I think if
you show up early you stay late you
under promise and over deliver you do
that for three or four projects people
will trust you and you could say hey
this next project we're going to do it
or delaying so it's kind of weird
actually being really good at your job
and some other language potentially is
the reason that you could get the chance
to user laying in a company but I just
like to strongly point out that that's I
think a really effective strategy one
other thing is really interesting in
having lived in the scripting world for
quite some time is that if you get into
interesting problems like distributed
computing a lot of times you you have to
deal with an event loop and and there's
all this you know talk about how event
loops are great and you know you can
handle thousands of requests a second
and I've had this issue with Ruby have
had it with
with Python I've had it with node where
where you you write this thing like at a
previous company we wrote a syslog ng
clone in twisted and Python and it I
think it was like seven thousand
requests a second like awesome right and
and what's what's great about that is
that you then install that event loop on
a ec2 instance and that ec2 instance has
four cores and then that that that ec2
instance starts to heat up and all of a
sudden you then go boy I think I
actually need like four event loops
because we're spending all this money on
the server and three of the cores are
just going to waste and then I also you
know need to make sure that i can easily
distribute the load across all the nodes
in the system I think I think this is
the thing that is really why why
scripting languages are potentially not
the right tool for distributed computing
is that is that that is a very tough job
it's not impossible people do it but the
you kind of get yourself into this state
where you've solved this you know fairly
complex problem by writing an event loop
that handles thousands of requests a
second but then you've now got this
other problem which is that they all
need to talk to all the other nodes in
your system and you would like to
efficiently use all the cores and in its
in its tough and one of the things was
really funny is is that i was looking at
Guido the guy that wrote pythons keynote
speech for the pike on conference and
what was really fascinating about it was
that they were talking about that
they're doing a lot of the async they're
building in a sink into the Python
language and I think it's great and I
pythons great language Ruby's a great
language and what's kind of interesting
is then I looked through some of slides
and I said async multiprocessing TBD and
and I think I think that's one of the
things that's that's like kind of
fascinating about that is if you've if
you've done this now like multiple
companies and multiple languages like
TBD that that's the real world like
distributed computing problem like so
basically for real-world distributed
computing problems
and I mean that's fair enough I mean but
but but i think i think that's that
right there is why you potentially
should look at or laying in your company
is that it isn't TBD right like that's
that's what it does it does like
distributed computing and you know this
is kind of what i was talking about
before is that is that once you get into
these these problems in these scripting
languages it real really chant prevents
a challenge because it it is a very
complex problem to solve another another
really interesting fact in the this
whole you know why to use Erlang versus
a scripting language for a distributed
computing problem is is also energy
efficiency and i don't know how many
people are have been following things
like carbon footprint and you know high
high mileage cars but but another issue
is that if you have this same event loop
and you've now virtualized because
virtualizing saves energy and you have a
fork or box that you've rented from
amazon and you have this one processor
running running hot and then the three
cores are doing nothing you're just
you're basically you know using up all
of this energy that that and you're
you're contributing to global warming
you're increasing the carbon footprint
of a server and it's not necessary and i
think that that's a really interesting
thing that I've not heard many people
talk about but but it's a real problem
and actually this kind of brings me into
the next slide where one of the really
interesting things about this you know
the whole event loop thing is that is it
a lot of these talks that you'll hear at
a conference they'll talk about the
world's biggest X right world's biggest
Django or world's biggest rails server
one of the really interesting things
about it is that there's always the
secret ingredient and and I on Jenny 12
like look back at this if you look at
the world's biggest whatever scripting
language there's a very strong
possibility if you look inside there
that Erlang is is actually the secret
ingredient that no one
about it they're using celery or they're
using in Python or they're using you
know event machine that also talks to
RabbitMQ and I think this is kind of one
of those really fascinating things that
that scripting language is kind of just
kind of punt around is that is that that
there are really hard problems and the
really hard problems are not actually
being solved in that language the really
hard problems are being solved by using
something that someone wrote in her leg
and then forklifted into the data center
when the project was potentially failed
and and I I think I would be curious
about some of these really big sites you
know to hear the backstory about when
they actually introduced you know
RabbitMQ in thurs system and like what
happened and to give you an example I
know from a reputable source that one
one of these big sites they did a
profile where they looked at all of the
cpu usage of one of these giant you know
world's biggest data centers and there
was a six percent utilization of the cpu
across the the farm of servers they had
and so you know if you kind of look at
that and from from you know the world's
biggest website uses six percent of the
cpu on i don't know how many machines
they had and that's that seems on the
surface a problem and not that any of
these lanes are bad languages but it's
just something to think about when
you're building something big we're
building something small maybe doesn't
matter I'm set that brings me to the end
of my section I'm going to now hand it
off to Mario who's going to talk about
kind of the real world how we took in
forklifted or laying into one of our
projects and and saved it ok so my name
is Mario Chiodo thanks and not for for
this introduction and I'm I'm not really
an errand developer I'm ruby developer
especially javascript and all these
fancy hipster stuff and yeah it's
definitely easy easy to star in you can
write like very beautiful code but then
when you enter in the in the real quotes
like oh man we've been developing for a
year and we only support 30 concurrent
users what are we going to do and then
is when we're going to start using this
secret ingredient so let's see how when
I can help you even if you don't go
dinner on
and that is not what introduced as to
like is this one example of other tools
you can use like maybe amnesia or other
things but rub it in queues are very
easy-to-use tool and it's a huge
distraction that you can build on top
and it's is language agnostic so this
you just use it like an API so this is
what rabbit in queue is I'm pretty sure
some of you guys who knows what is
rabbiting cured use it so yeah I can go
pretty quick into this so that doesn't
need to to explain this stuff so we're
just going very quick is a service for
messaging that implements it n QP
protocol and there are elinoz running on
an application so it must be good and if
if you never know for a fact that most
of Ruby people and Python people don't
really understand what is certain we we
always think sorry airline and rabbit
and Q we always thing is some kind of a
queue system for for messaging or just
for for holding message scenic you and
stuff like that for workers but it's a
lot more data so for us an easy way to
understand is like a service like my
sequel but you can open a connection and
you instead of defining tables and
indexes you define exchange queues and
bindings using that connection and then
you send and receive messages using to
using those those cues so this is the
first part of things that you can build
on Robbie thank you and it's about the
cues and the consumer so that the
consumers here will be your your workers
or your application and the thing is
that if if you put multiple workers
listening in the scene in the same q a
rabbit and Q will do automatically round
robin so you can use just the same q and
putting multiple workers dissonant
subscribed to that q to you to the
automatic load balancing this is simple
one is not like a big house but but most
of the times just work then the
exchanges and the producers those are
other products processes and whenever
they talk to rub it in you sending
messages publishing message says they
are called producers so basically
intermittent huger published to exchange
you just define some exchanges they are
like
outbox for sending message and then
finally do the find your route is that
connect this chance with the with the
Q's and bindings have like different
rules so you can build a routing system
into this you can send a message that
gets the river to disk you and then it
gets load balances with different
consumers or different different routing
so this gives like a very very flexible
scheme to build your messaging system
and that supports a lot of different
possibilities and then the types of
exchange combined is you basically be
has like four but I'm gonna just
described to the dealer exchange you
just have a message with a routing key
and you have different bindings with
different routing keys so the message
gets deliver to this queue and then the
sku can have multiple subscribers where
r on robbing will be done and the
finality just multiplies the same
message this can be used for for pops
off like Twitter style things what you
just publish to whoever is listening for
it and it's very well sweet for
real-time sending and what all these
nice things so typically use rabbit in
queue do you connect to rub it in queue
the finance chains and start publishing
message to that the sense or define a
queue and his mind is and then subscribe
to the Kuhn start listening to whatever
meses que no order as more consumers to
the same q-connect applications within a
different language and that is the best
thing and especially is good for things
like center forget like for example when
you have a login system that you and
synchronous loot synchronously same
message to it and rabbit think you will
handle it with the cues and stuff and
will be processed by by your login
system or whatever so this is a real use
extreme example and this is the project
me and some other workers were
co-workers were working in the last year
and a half and we build the this is life
already is in the beta version and it's
a web application built on Ruby but it's
optimized to support multiplayer
experience in real time which is kind of
a text-based experience but still still
have flame whenever someone enters in
the rules someone picks an object
someone drops an object do it you are
all connected so in the in the back end
it has the rails application but then it
has the game server which is
is like an MMO server where things are
running in memory and so we decided to
build this in group is probably not the
best idea but we started with that was
worse quit was to start and so a place
that is a wall instance with running
memory on one of the available game
servers and that is what the scalability
problems can kind of start so
architecture is is basically a process
and HTTP requests to rails then we have
connection servers that will push
notifications to the process and then we
have gained servers that in the
connection service that needs to talk to
each other constantly because their
gains erase the one that's running the
logic in memory this is as our
architecture before rabbitmq so we this
is what we start building here just
whatever we needed we start adding the
route we need this we need like a
connection server and so we build this
system then we need the game servers
over here we will desist and then we
realize okay so we need to to scale this
up so we have multiple instance of
connection servers and they can push
notifications using html5 push events or
sin in our case but could be what
sockets as well but then so then here is
is how basically works is that the
browsers will send up an HTTP request
that will go to a race server that will
respond with the HTML Javascript and all
the stuff then browser will connect to
one connection server event source to
get like an appt connection back so once
it's connected is when you start
receiving notifications in real time and
the connection server needs to say okay
so this is the user one that wants to
connect to work one and where one may be
running in memory in one of those game
servers only none of them if it's still
not boot up so he's booed up on on
demand so then with we would have like a
deal brokered that we call that is the
one that these connections ever asks
using this socket connection here a I
won't connect this guide to this to this
world what is that were running and the
deal brokered is smart and he knows
everything that's going on and he says
like okay he's running in this game
server and sensei
the idea identification and he said ok
so i connect to this one and start
sending message with this guy now the
connection is open and then here and the
problem is that the deal brokered also
was homemade and maybe it's not a good
idea to build a homemade system that
knows about everything that is going on
and basically if I worries if he
believes are what is running here and
you have a problem and it's not working
here then you're screwed this message
start breaking I think is there it is
not so this is this is what I maybe you
guys can identify a pattern here
something that would build without being
constant and this is basically what we
have built their we have made a
pentagram we didn't realize and we we
cast the devil on us so at this at this
point we have a system that that was out
of control and cooling scale it was just
too many connections and stuff so this
this guy was messing around for a while
and well but this is what we always
thought like okay maybe we need to keep
working on on keep improving this idea
you know the broken is not smart enough
he needs to synchronize a sense and I
synchromesh cinq-cinq messages to the
game servers and every five seconds
check if everything is right so just
okay the only per centum omnipotent
broker will keep develop wait but that's
never never happened it's always more
and more problems you keep reacting to
these things and you also have more
problems you have kind of a withering
hear that because these this socket
connections here were so complex there
was no way it's time I don't know like
from the race a process you want to to
send a message to a war let's say you
change the world name the one that were
to change in real time and we didn't we
didn't know how it was so impossible to
get a connection open here so hard then
we have kind of a master game server
here that just send the message in there
and this will talk to the database and
those guys receives us just a mess and
as in if you want to put like another
admin tool or whatever that is talking
to it just so so hard so yeah this is
what we will be
in here and I don't say we've been using
yet this is the pentagram anti-pattern
just want to make a note that now that I
found it and I realized so just just to
generalize you guys when you build a
complex system with a lot of
interruption seas and things that are
connected to each other you're going to
cast the devil do you just have to
identify that beforehand and when this
happened you're going to have the
dependence on black magic and this is
not only for networking systems is also
in size objects and inside whatever you
do you do depend you want to have
dependence on the prius that I call this
the guy that this isn't the only one
that knows how this thing works and
improbably he don't even know that so is
this do depend on the prius to like idea
we'll fix that and then yeah multiple
Global workouts like you have a lot of
systems they all know about everything
and they they are very smart but they
never work fine they they complete with
each other that's God's fight so the
only way fixing this is fixing with
signs like yeah you have to study the
pronin do you have to talk to the priest
and say like guys this week we cannot
continue this this way and try to find
the right tool for the right problem
which is well this is like a list of all
the problems we have building that you
know like I'm most most of people think
about me that I don't like 0 and Q but i
like seeing hugh is is is good is like
an instruction on top of sockets it's
for it for every language and it has
this kind of magical continuous
persistent connection that never gets
close it and that is hard to manage
easier for shoe system salt from one to
another is fun it's fine it's great but
if you start adding like here and
they're gonna build a pentagram so it's
just hard to scale too many circuits and
also Steven Q has very bad supporting
Ruby and limited communications then the
broker is too complex that is our God so
better to remove this and well the
solution was you guys grin imagine this
is the X ingredient here spotted rabbit
in the middle of all and just systems
connect to him define cues and exchange
inside and then told to each other but
how can you model all these complex
things like for example if I was running
over here how can you wrote the message
to to the right game servers it's very
easy just been a queue and create an
exchange for words and buying basis and
the war ID so then private link you will
route immediately to your tool into the
world and the game server don't even
need I mean whoever is publishing into
that world it doesn't even need to know
in which again server is running it's
just published in there dang is a little
more complex when the world is not
running in any place so we we still
thought we probably need like a fully
aware broker than me are everything to
say okay this word is not running we are
going to decide where to run it but but
we also found a way to solve this using
routing and it's basically the idea that
every game server that has a computing
power can subscribe to an another Q that
is like we call it that the non loaded
words queue and so whenever someone
tries to publish to a world if the word
is not a valuable then publish the same
message to the non loaded words and then
some some game server will pick that up
based on round robin and that actually
works very very very well so yes we
start with this team and we just remove
all these things like go to hell with
with all these guys now we have a new
growth that is a maybe a problem because
we still have a new piece of our system
that everything depends on like he's if
he goes hell we all go her but well do
now to make it have to make a decision
who would you prefer to worship like the
rabbit in queue God which is supported
by a big community widely used has known
practices written in Erlang if you now
the problem for us was like okay so
every message will go through rabbiting
q what happened when we have more than
million messages a minute what haven't
want to have 10 million message is this
scaling and yes that the answer is yes
this is billionaire land you can reach
up to 34 nice books of how to scale it
if you if you need to have the spin
nodes and it's much better than
depending on their cane goals that were
defined by some dudes in a reactive way
remove fee
the people of their time they keep
adding stuff and no one really knows how
to scale that stuff so that is a good
choice because rabbiting he works and
deal I agree with that he is very happy
with that decision so now now we have
this advantage ladies people is happy
Pope and now we have consistency because
n kopie is going to be our protocol for
messages more for messages a new
developer games is like dunno what is
Hank you please just read this website
and we don't need to explain you how it
was it's more flexible there is a this
is a very very important one visibility
it's actually like before in the
pentagram that we have what happen if
something goes wrong like one day our
service don't connect servers they are
done the only solution here time right
two minutes okay the only solution we
had theirs is we have to kill a chicken
and throw Bluff in the pentagram and run
and start placing like maybe black magic
will make this work and the next day
like our systems are up again that's
awesome and no one you really why so
with rub it in queue you have a lot of
different monitoring systems and one of
them is is very nice it's web-based and
it can also draw like automatically
draws a graph based on on this changes
your cues everything you have you can
see all the bindings so it's like if
something goes wrong you just go there
and look what is what's going on don't
depend on on that black magic and as
Lazarus tissues become now because now
any system control we don't have that
kind of guy they're just connect to it
more support more a lot more features is
routing and this is very important 12 we
don't need like a complex broker in a
nice hustle traumatic a load balancing
for it so this is what I explained
before but if you guys want to see real
quick how the game messes can go in rub
it in queue is those are the connection
service in the game servers it's of them
has a queue and this purple thing is
defining insider and rub it in queue so
if you have this avatar one and avatar 2
you have those buildings bindings here
so whoever wants to talk to this avatar
it just needs to pull this open a
connection to rub it in queue publisher
messages to this avatar clanks direct
and this is going two routers
automatically here to the connection
server which going to push and the same
thing for worse this game server is
running war one as soon as he's running
it creates this binding and from now on
you just send a message here and just go
automatically to this world and load
loading a Warren instance is a little
more complex is what I was talking about
of the non loaded Wars fan out and every
game message game server that is
available to support new traffic will
subscribe to this Q so let's let's see
for example we have the avatar for that
wants to play in war two and so as soon
as this gets connected this new binding
is created here to be able to receive
message then the message canet world is
been sent to the war instance but then
gravity and you will bounce it back and
say that i was just sorry this war is
not not running so what we do is send
the same message to the non loaded fan
out and this that has one single queue
and every single a volleyball game
server will be subscribed to this one so
in Rome robbing will send to one random
game server that will we still need like
a global lock which is not nice but
booting Wars is not something you do
constantly so it's okay you just lock it
for avoiding race conditions like maybe
avatar 5 also wants to work to check to
to towards you and this was maybe the
most complex tease but once it's loaded
it creates a new binding here and
response back to the to the to devatas
client that will go back to this so they
both don't need to know each other they
just send them respected message and
once this kinetic is is received then
from this point this connection server
will send message to this one instance
and we'll get routed to the right kind
sir in game server another great thing
is for example how do you make more
complex load balancing what happen if
you have one game server that is
overloaded with with the staff do we do
we still need a system that knows every
game server and which one is loaded
which one is available in reality not
you can still make them self-aware and
just for something
this guy gets busy he just can't remove
this description and say I don't receive
more words for now and whenever he
becomes available again it just
reconnects so really you can build your
your system being independent and yeah
position questions on the end I'm gonna
let my my friend James go to the next
part and it's time for Mike chance right
so my name is James Mayfield I work at
linen with the previous two speakers and
I was going to say while Mario gave the
perspective of someone who uses their
language I'm going to be sort of not
only introducing you to the project that
i work on at linden lab that is is users
are lying directly but also just from
i'm relatively new to the language this
is my first reading relatively large
project in erlang so it's sort of theirs
that perspective is it as opposed to
someone who doesn't use it at all oh
yeah that's right so i'll start with
introducing the product it's called
versu this from the tag line it's is an
interactive storytelling platform that
builds experiences around characters and
social interactions that's really just
sort of an elaborate way of saying a lot
actually but more particularly what the
game is it's sort of a text-based
interactive fiction game that has a
simulator underneath that drives these
things it's not a traditional sort of
choose your own adventure these things
are happening with each event that a
user adds into it changes the next
outcome so it's a whole lot going on so
the components of versio there's a
simulator and that is written and see
all is it's yeah it's ready to see one
of the issues with it is because it's a
long-running see process that
and because it consumes a Content that
it's potentially written by users there
is that odd chance that bad things can
happen and we need to manage that the
other component is the sort of business
logic layer and that is written in
Erlang and it uses a port to talk to the
sea process it maintains a lot of the
state of what's going on it actually it
sort of duplicates the state kind of of
what's going on in the sea process just
so we have some access to it so it
tracks the players and games that are
playing in any given simulator and also
it does some transformations of the data
the information that's flowing in and
out of the simulator nothing really I'm
super complex but there's there's that
and then of course there's the web
application component of it they're
actually you see the trademark it's
supposed to be slightly sarcastic just
got moved so because you know it's a web
app anyway so its job is to expose a
slightly rest like interface to the
simulator functions underneath and to
expose the the interface there to drive
the interface on top of it all the user
interface the other component of it is
we need some sort of data storage for
things like saved games and as I alluded
to earlier user-generated content so
those those are the sort of primary you
know the big the big swath components of
the system and now I'm going to sort of
show you so when i started i started at
linden lab little less than a year ago i
was brought in to sort of be the erlang
guy taking over a project that was
written by the guy who wrote the
simulator he sort of fleshed it out did
a prototype in Erlang and I inherited it
it was roughly this and these these
diagrams are incredibly simplified but
it was roughly this we had a middle teen
web server
component that talked to a a prowling
process that had all of the logic for
everything and then inside that has
spawned another process for that
maintains the part that talked to the
sea simulator and it was um it worked
really great as an instance of one and
so this was an interesting thing at this
is so this is like I said prototype code
I walk into it my first really large
Erlang Erlang project from the
perspective someone new to it it was
wonderful to come in and look at this
you know somewhat size will bit of code
but everything in nice little digestible
functions didn't take me long at all to
sort of digest what's going on how the
pieces were interacting with each other
and move on to sort of basically started
moving towards an OTP design I don't
know why the simulator is red i think
that's more awesome than formatting joy
however so i moved it to a web component
that seemed to be a bit more supported
so i chose cowboy and this was just the
very first step it was just how can we
make it to where things will restart
should something really bad go around go
go wrong and just created a little
supervisor now we have an erlang process
that's that's managed and a simulator
the simulator interface really is just
it it creates the port and does any sort
of logic for consuming the inputs and
outputs so that was just first step just
short of sort of step into I suppose a
more proper early design but from there
it didn't take much at all to move it to
so now we want to scale right we want to
have more than one simulator each
simulator can handle a certain number of
games so we wanted to move to how can we
spawn how can make use of all the
corazon on a machine spawn multiple
simulators and still brought traffic
accordingly
from that first step it was real easy to
move to something like this where we
have you know things managed we do have
so the simulator because these these
states need to match the state of what's
going on in the simulator we built this
the supervision trees such that these
guys can can start and restore their
state and completely independent of the
simulator business whereas this guy
crashes this is one for all and they all
go down and restarting it's it's less
than ideal when you have more than one
game on the simulator these are future
issues to resolve however we move to
this it was really great now we can spin
up how everybody how many however many
instances of the simulator we want
traffic gets routed accordingly
everything works great the next step
then was to now now let's just been at
multiple notes we can now create as many
it's the st. the same deal but just in
and on a machine or an early note of
whatever however that manifests itself
behind the load balancer cowboy on each
of them they can all they can all
consume requests and everything just
happens in an increased awesomeness sort
of manner and then to add for the for
the storage component we increased our
awesomeness by adding using react which
works well for our needs and it is it's
wonderful in terms of being able to
again scale out however we need there
yeah oh and in this case so what we're
doing is traffic's comes in there's a si
all right it figures out where the witch
simulator a particular game everything
is keyed off of a game ID figures out
which thing later that's running on and
it uses RPC call to find whichever notes
going just to just get to where it needs
to happen again I think it's pretty
pretty straightforward but it was it was
great for me having come from spending
years of if Python and other otherwise
and and some of these problems were a
bit more challenging to to implement so
my takeaway from from having gone
through this experience was that it
makes developers happy when you have a
really great elegant way of expressing
some of these potentially difficult
difficult things it certainly made made
me happy so you have to take away that
assets it's true or perhaps only if we
take away the assets drew I don't know
but I I'm assuming that a lot of people
are happy by use am for the chance to
get to use our lane and the operation
the Ops guys love it it's like we can
produce this nice here here's our
release there it is just untie it and go
and everyone loves it and adding more
machines taking down machines everything
happens with with with them great joy
and and personally I like the fact that
having taken my first big dive into
Erlang and realizing there's all this
incredible stuff I've got so much to
learn part of the reason I'm here part
of the reason I'm excited to move
forward continuing to just shove to make
sure the Erlang has a good presence in
the company that where I'm at but so
that was my sort of quick dive through
Erlang and a newbie's experience with it
now I'm not at the moment we're at a
pretty early state we haven't released
user-generated content to the world when
we do that we'll have some more complex
needs for querying and whatnot as it is
now we're just it's really simple it's
just saved games I'm so it's really easy
to do direct we can always do to sort of
key base access we also do the success
of this project that's right we're
that's right yeah we're going to
hopefully that okay
what was what in the old days ah that's
true I mean I'll take this one to the
very beginning there were there was I
think the pentagram was the best
description was there is a prototype
that was written and this is what you
get into it with like Ruby and Python
object is that you write this prototype
and then you run it on your laptop and
then four people can use it and and what
happened was as we're trying to get it
ready for launch we really saw some
massive bottle and it's one of the first
things that we that we did before we
complete architecture of it was to take
some of the chat on to basically take
the chat functionality out and put it
around them Q and so it was it was this
happens a lot of game companies is
there's a lot of pressure to ship things
quickly and so you have to give these a
kind of partial solutions where if
you're working at a
for commercial software house you would
actually never have to do this you would
just from the very beginning design
subsystem scale horizontally with with
game companies or film studios a lot of
times you'll you'll have some solution
that's you know you have to do
incrementals pieces so it was basically
this was phase one of fixing all the
problems of what the original
architecture was was just to take some
of that
okay I can tell you that one so you yeah
you're asking about the then the
transition was not that easy as in the
Darrin let's just take those guys away
and replace with a nice thing of course
so they the strategy here was a first
learn more about rabbit and Q because we
receive me we were juicing for for chat
for a while and then once we kind of
guess try to figure out how we will do
this routing theme and once we got there
we still need to to validate if we could
work so with we did a prototype that
that was basically 2213 connection
server the one fake gay server and they
they did did I like a fake logic and
only send the message in the same format
that was supported so that was within
one week and after one week we had this
prototype work do Cole will be like a
cloud of services so we we have like an
instance of Robbie thank you and each of
us in in our laptops cool star game
server a connection server and they will
connect automatically to rub it in
Houston routing message and once we saw
that was working well I got this working
world wonderfully then we fix some small
button things in that small brother died
but it was actual weeks and we validate
that the thing was working and then we
saw how could we scale that we look at
an Internet ok so the day we need these
we are going to have a an answer for
that thing and then was maybe 12 months
doing the moving day the prototyping
implementing in our real system without
a lot of small details broken things
right but yeah the only work then I
maybe 2 11 month and a half two without
the new system working was was much much
better
right I believe so the guy who wrote it
as Richards at Richard Evans he's
written simulators for what Sims the
sims and black and white and so forth so
he as I he wrote it I think he did
originally start down the path of
writing it in Erlang I think it just
came down to performance issues and he's
he likes his see and so he just wrote it
in pure c and actually that's really
helpful for us now cuz it sort of gives
us a bit of portability that gives us
options but yeah so he made he shifted
tracks and wrote it and see and with
with the sort of Erlang layer on top of
it rapid prototype phase and it was a
web app and then lab and the fact that
see if now it's actually going to be
fact that sees actually a huge advantage
because then we could take the c and
then just run it locally inside of my
less alright thanks guys</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>