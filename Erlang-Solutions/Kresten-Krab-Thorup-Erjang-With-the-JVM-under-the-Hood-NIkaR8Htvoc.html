<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Kresten Krab Thorup - Erjang - With the JVM under the Hood | Coder Coacher - Coaching Coders</title><meta content="Kresten Krab Thorup - Erjang - With the JVM under the Hood - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Kresten Krab Thorup - Erjang - With the JVM under the Hood</b></h2><h5 class="post__date">2013-12-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/NIkaR8Htvoc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so I'm trust them ah today here I'm just
a hacker because I'm pretty much
introducing you to my hobby project over
the last four years my daily work I'm
miss eto try fork where I do its own
internal consulting and run around
hacking on various projects internally
Leslie and then I work a lot with our
conferences we do to calm conferences go
to conferences and dis conference so
it's a part of my day job is finding
good speakers these kinds of things and
meeting with people are talking with
them about what you're doing anyway so
couple years ago I was working on on a
project where where availability was
really important and I did some research
into availability and I realized I had
to learn early at to figure out how
what's the stick with juice in Erlang
that makes it so nice and for writing
highly available systems so that was
really the trigger for me to try to do a
language implementation myself because
those you know if you go to a language
implementation then at least you know
that you understand the language so ur
Jan is at the m4 for early just like the
beam is the official really the only
real nvm in widespread production use is
beam which comes from erickson so it's
exactly four years ago today like to
come to this announced this project and
what happened how can use and there's
all things about those just reviewing
these questions today
days when I was them people asking these
questions to call me a skeptic but this
project ditches Erlang's awesome via it
takes only two chunky language syntax
that puts it on whatever I wonder how
things like process isolation will work
out and then the next guy says do you
beat me to it my first reaction was to
wait how is preserving election text me
losing to the intricate a good thing and
I'm here to talk about other projects
that are also their language is going
the other way compiling to the Erlang
VMs we'll talk about it was a lot of
skeptics and actually all these skeptics
just only only tickled me even more I
wanted to do this even more because
they're the guys that told me would even
be possible to do it so the highlights
of this thing the single swipe that
explains it all is it's a pretty much
full earl and implementation once the
most current Earl nvm or real any
language and libraries I runs on a
recent Javed also present 07 Ordo 8 the
core of all this is uh is it jit
just-in-time compiler that compiles
Erlang our language by Proform at being
to JDM code so it does this on the fly
and from the program's point of view you
can't really see a difference they'd
have to be very careful to figure out if
you're running on / chang and not the
bean because in it all the specs like I
tried
like that fact from the program there's
a special system information erlang gets
system information or whatever where you
can ask is this end this is a virgin but
other than that I tried to hide that
fact totally except there's some time
integration work and call out into Java
so you can leverage success in Java code
I'm various ways and it runs all brains
very expensive think samples you come up
them today including necia distribution
networking a CHP packet parsers and I
fear into Erlang it's pretty much the
full circle I recently added support
dips so you can quite contrary to what
would make sense for sure Java ecosystem
you can actually load native modules but
it turns out if you want to run anything
significant in your life space you need
to be able to load these native modules
or like tomato modules which is kind of
a pity and a side effect off the fact
that Erlang itself really isn't that
fast whenever you need will the for me
to push it out push it out just a native
vote and then just kind of overall it's
a full line person essence so the I want
that's like saying why I can iterate a
rehash why I'm doing dizzy as I said
philly at the start it was just learning
her life but then I got him treat you
know by people saying include could be
done I got intrigued by Erlang the
language and by the community and on
people that are working on this it
turned out was really a lot of smart
people in a Reliant space or to talk to
the head
experience so I did more or Jenny and
now it's actually at the point where you
can actually run something something for
real but this is for years down the line
from the beginning so this talk you know
i'm not going to be offended if you walk
out or anything I tend to explain how
all this is possible at least the major
things and if you have questions along
the way with most welcome to raise your
hand and ask questions so I'll talk
about some of the some of the things in
Erlang video or in the Erlang language
that are that are difficult to translate
so if you if you look at look at the JVM
how this works and see now I can't see
the next slide over here that's and one
thing because they want to be able to
switch later anyway so the plane
wouldn't normally run an airline system
is right you have an erlang program
running on top of ocp framework it all
compiles to being files and then it runs
on being emulator which interprets beam
and it hasn't built some built-in
functions bits there didn't see and you
run all this on your favorite eos and
that's fine and ended up so what would a
high level view of what this is it it
replaces the beam interfere with urging
which is this java components in the
bill reimplement all the built-in
functions in general to all the built-in
functions
network yeah the building functions are
growing language like things like
opening ports and communicating with
ports and doing all the basic
transformations between various data
types in various ways that are operating
the data types and also all the drivers
for accessing network file systems etc
etc and urging all these are we
implemented in Java so there's a fair
chunk of the code to the boxes should be
the other sizes / chairing the the vm is
actually the smaller part and all the
tips and support functions around
prepare the bigger punch this on all
drugs on a Java Virtual Machine and the
benefits I'd say from from doing this is
with the Java Virtual Machine at least
once things quite fast it has you know
by now almost 20 years of engineering
effort going into it and making it run
really fast I don't know where line also
has 20 years of engineering effort but
it's not towards making probably the
fastest best towards making really
stable allowed so it's interesting to
see would you can get out of trying to
make things run fast so if you look kind
of high level of two of the pros could
also be a GM bae systems as may be more
socially acceptable or easier in some
cases to to get into production
deployments exist some people told me
today that it would never have Java and
their injured players but you could
easily be at least as many IT
departments where did much rather have
some Java code reading there could
integrated with all kinds of third-party
libraries that it's just out there and
and it's facts that I can't you know the
interesting time technical perspective
for me is how do I make this one fastest
at the end of the day it's really
interest
case for lang or oj is this a bit run
significantly faster than be so the JVM
has lots of sophisticated up to my
station techniques that it that is used
to make me run fast and there's lots of
published research and how they do this
but the most important thing is that is
to understand that JB I'm actually does
profiling of your application is it
running and based on that it decides
where were the best places to put the
effort towards making the system run
faster so where does it make sense to
use the few cycles to optimize the code
so it finds the hot spots and then you
can do in lining and arbitrary points in
the code across modules our many levels
deep in lining and this kind of adaptive
optimizing in lining is really the
secret sauce of the JDM that makes it
run really fast so that's definitely
something that this and beam and it
could be really interesting to see the
effects that come out of that another
difference is the garbage collection
Erlang's garbage collector is nice and
it's really simple I need to understand
because it all runs a single heat every
process in Erlang kisses on heap and you
can apply priorities and different
processes running garbage collection
whatever priority that process has to
get there with the process whereas in
Java garbage collection is the global
kind of semantically at least a global
phenomenon that just happens in the last
five years garbage collectors have come
much much much better by demand because
because people complaining of course
every once in a while I've seen these
global GC losses so it has a really fast
garbage collector I'm going to interest
it's interesting to look at whether the
debut of garbage collector how that
compares Air Canada up perform the beep
so on day on the counter you could say
it's cons or stuff like you know really
it's really challenging to implement or
learn I really this there's a couple of
things that make it really hard one
thing is all the code has to pass
through a load time type checker so so
you have to feed this beam code on cyber
lion code and figure out what the types
are because the TV I'm also really nice
attached to make Cobra fest so then you
must generate some code that actually
passes this verification so that's
definitely challenging there are some
challenges and that functions in
Airlines but in java space are limited
to 64 kilobits code which is a
limitation I've been reading into the
whole times it's very easy to generate a
lot by code and then run into that limit
there's a simple Java that can generate
more than 64 k bytes of code especially
for auto-generated code of various kinds
stuff coming out of tyler's or macro
expansion stuff tend to get really large
instead limitation is not present in
early in being and then it's really
tricky to encoder life's process model
this really has a super super
inexpensive processes and can we repeat
that in java space so to just kind of to
set to say i don't know if you can read
this all the way down this is a this is
our numbers that show how much faster /
Jang is
compared to being the most recent being
running on my my macbook so if it says
one hundred percent somewhere that means
it or jen was twice as fast and this is
a is a little performance test suite is
hidden in the Erlang standard standard
library test setup but it's kind of
constructive to weep down the list see
what things are really fast and just to
know what are the one of those huge
advantages of running java is a year ago
I ran the same tests and numbers were
significantly worse just by doing
nothing over the course of a year the
damier comes out and is like ten percent
fifteen percent faster and I didn't have
to do anything that's wonderful anyway
so so one of the interesting things that
you'll see is float Eric methods if you
run real number crunching or join is
significantly faster it's like seventy
percent faster or seventy times faster
and as you can imagine this because I
can figure out dual using type inference
that chunk of code that was being tested
here is actually really floating-point
expression so it turns into almost pure
Java but other than that you can see
kind of shows that the nature of thing
sending messages we're not really that
much faster but if you said big messages
and that means sending a message that
has
structure it somehow that's a lot faster
than I checked because we just just send
a pointer to that shared data because in
or jack everything is on one big heap so
sending a message from one process to
another it's just a matter of passing
ponder from one process to another
allocation de-allocation is really fast
Damien super optimized for for the local
allocation and getting rid of data
quickly again local calls to these
built-in functions because the built-in
functions in urging are really just Java
functions and the code calling it is
religious Java there's no special
context switch that have to happen in
urging when you call from the compiled
beam code real airline code into the
virtual machine there's no context which
going on it's just a Java function call
just like everything else so that's
really fast binary handling I'm not
really that fast ex isn't that really
that much faster small integers are not
really a bit faster but not
significantly so overall but overall the
seeds everything except one here our
Jang is actually running quite a bit
faster than B and the one where we
loosen here is generic servers that this
is actually contacted is one of the weak
points of the current implementation is
this group implement roofer improvement
one of the week's boxes the scheduler
that I'm using their just need some
I know I just need to copy from somebody
else are used somebody's schedule a
library for this so so context switching
isn't really super super much faster
okay but nevertheless here's how if you
want to hear it is a single micro
benchmark that you could try to run
absolutely code for this if you're going
to kind of a classical micro benchmark
for for scheduling multiprocessor thing
is a ring of 10,000 processes and pass a
message surround this ring on this
particular case it was running a passing
around a mrs. believe 10,000 times and
this graph shows the the number of
nanoseconds permissive sent so so the
smaller ones here are our better so 11 /
changes and 20 million messages per
second and beam is like an order of five
or six million messages per second but
again this is my foot benchmark numbers
now you never know what's going to
happen if you up if you blow up just to
real size of the features so saying this
is creating 10,000 processes obviously
these processes are not they can't be a
job with threats or it could be but
they're not there there's something
something better than that their java
processes or java java thread operating
system through it then
completely different league here much
much slower because you couldn't do
probably a million context switches
machine like this per second so here's
another example up let me try to brendas
it's just a small program that just
creates 100,000 processes and then send
one message along that chain of 100,000
processes so when it when it comes out
in the other end then then it figures
out how much time it took so here it
shows you the code maybe just
so it's a small tiny program that just
what it does is when we run in with a
certain number here it will create a
chain of processes and then send a
number to the end of that chain of
messages and wait for the N to send back
a message so it's just really simple
it's not even so if we try to run disz
let's see here run our 16 so this is
kind of creating hundred thousand
processes and sending a message to along
that change it just takes like 13
microseconds per step of the way there
there's thirty eight microseconds to
create a closest and sent the message
now if we launch virgin this just take
herbal then it's not quite as fast to
start up notice that I could do that
again takes a little while to start up
this is start it's loading on the Java
code java isn't really known to be that
fast to start out and you can say Shane
it's eleven microseconds per iteration
but the thing with Java is it gets
faster is to try to get the next time
you run the same program you answered
eight microseconds for three
there's a7 meza garbage clicks and hit
it oh that's annoying and if you're
lucky they know got slower those carbs
probably most likely garthe flexing
happening again there those for Marcus
Simmons so let's try the erlang again
here you know might be slow but it's
very very consistent you know so that's
typical that's kind of thing that you
will observe in all these queries test
wheelchair so I dislike showing this so
as you'll notice what actually when you
start it up it kind of prints almost the
same thing as or lend us some
configuration options set here it says
I'm picking up the Erlang installation
in this directory so it's actually you
slipping all the beam files from there
so the knows where to go pick up the
default it just runs off underline
release you just told run this airline
release it'll grab the last spring so
the JIT kinda the high level view of the
jet is basically it needs I need to
figure out how to load a beam file that
was pretty difficult because nobody had
written really specification for how
these being fast work I could go into
their code for the beam virtual machine
but that so that took a while I figure
ideally two guys do that then I'm doing
some flow analysis type inference um
pretty hairy stuff actually to
reconstruct not only structure of the
Erlang program but also to to decorate
it the types as precisely as possible
and also to decorated with a little bit
later information about which which
parts of the code could could suspect
because as well get back to go back to
that so does a pretty complicated on tab
analysis and then cogeneration and then
of course there's in all these you have
to keep in mind how do we generate the
best code to be able to leverage the
kinds of programs that the JVM are
optimized boy do you want to take this
bag of beam code and turn it into
something that looks like a reasonable
decent java program because of course it
has patterns that is that it works
better for than others and then some of
the tricky tricky things that you know
people were saying can't do this I
encoding tale coughs and coding blocking
operation basically possible thanks in
essence in Erlang only real blocking
thing is doing a receive in in the
middle of a deep stack implication of
functions you can say you've received a
message and if there's no message
available to block and you don't want to
have to block the the thread that this
is running honors or this if you either
do right where you want a mechanism that
allows you to d schedule that process
and just dance so as you do that so the
way this all get started is um you know
there's there's legit over here beam
reader some analysis coach I'm used to
be fed up being filed and then it just
admits for every module and Erlang
system it emits something that's the
module name and and a hash code after it
then I can stash those in a cache and in
greet them faster because it it is
somewhat slow to show you that
how slow it is so the way that this
bootstrap is erlanger she hasn't a
notion of it's called an error handler
so it's assistant property that you can
set on a process basis that defines what
to do if you encounter module name when
the vm encounters a module name that it
hasn't seen before so do you can call
out to a module that figures out where
to go in front so actually because what
happens is then this code will go and
read the file and pass it off to this
built-in function called load module
movement really load modules and passed
basically a bag bites thing low despite
this bag of ice and then what does is it
just hashes figures I'd I a hash code
for that backup bites and say we already
have that file called this name and this
hash code then that case which is gloat
that jar file by there otherwise we'll
go through the lengthy process of doing
all this so I'll try to show that you
know you started with slopes to start up
before but now it's really slow if I
remove my stash of cached files and then
just start their poop the shell and see
every time it turns an ankle Darius
actually compiling beam module and
loading it a little indicator now it's
done there and in order to say something
interesting it also needs to notice
again the low simmer some more modules
to be able to print it was the printing
logic or it should be able to compile
this is
input invoking the compiler these too
low to compile the Erlang compiler
written in Erlang to load it there come
on but then if you do all this again
next time much faster now all my modules
have been compiled to job again it takes
a little while to compile it the first
time it's full file but if we compile it
again and if a few times of course as
you know this at the speed or faster
than be okay so let's look at some of
the artifacts that come out of
generating code and we look at a couple
of things which are tail calls how
they're encoded into this trampoline and
so here's a piece of code is a piece of
airline code but it does is a module
toolbar has two functions this is the
first function and that's a second
problem first function has two cases of
classes if if the first argument is a
non-empty list we do this or if the
first argument is an empty list and B
which are there so if you just take that
first function and then compile it into
beam code first it looks like this so
this is bean cook that's the kind of
material I had to work with this beam
code and printed out of those tools
slightly and enhanced readability from
real being code but since there's a
function here says it has two arguments
first thing it does is so a test for is
not into list of x0 that's the first
argument otherwise we jumped
265 which is down here and then we
extract the elements of this not into
this X from x0 into x0 and y0 we call
foo to function are two argument
function then we rearrange x and y here
so that we can make tail call is a
special call instruction for tail calls
that just means go to the top of this
function so this reorganizes in local
variables so this is really just kind of
symbolic go to the top gear so that was
it local tell then otherwise it's not a
non into this that's the second class of
the return function well test is it no
that's the same to list and if it is we
just move stuff around in return
otherwise we generate an exception so
turning this into Java this actually
reasonably straightforward and it looks
like this after it's been turned into
java bytecode and then d compound with a
java decompiler and then pretty fine a
bit since will we get a function that
has named encoded here saying how many
arguments a test and then in turns into
a loop the way the first the first class
is uh is basically just a loop that it
continues back here the first thing is
it tests if argument one is anonymous
and that's encoded Oh Chang is something
that either returns something of the
right type namely an econ cell which is
an honor to list or interns knowledge
it's not an honor to list the other case
here if it is test this didn't know if
that's different from null then it
wasn't no end
see it turns into something where
destructuring Cantus he'll call a head
and a tail method here to get the head
into town and kala looks pretty much
like another call see notice here up
here there's an extra argument because
this was a two argument function it gets
an extra argument here which is a
pointer to the local process so that's
the process abstraction they get carried
along through all the cops here so those
pretty straightforward now here's a
slightly more tricky this one has an
external call so it caused a function in
another module and here this is actually
also an external call the plus + pitch
the plus cost function that lives in
tooele so to encode this scene I'll show
this 5 person so I cut this in whatever
context this is being generated we
import these two functions so I've
important to the list reverse function
by basically declaring Andy fun static
variable that has this special
annotation Java ionization and then
another one for the plus + gets
generated static member here naming the
module and name and area two of the
function as a worse in town so these are
excellent annotations so in so urgent we
actually generate the exit generates the
java bytecode direct click there's no
java source code intermediate step and
the slides seem to indicate but the
annotations are there because then right
parts of built-in functions
by using the same annotation so it's
really convenient through writing some
modulus and where it can easily and
create an import take these are
essentially just import preferences then
when this module gets loaded these will
be filled in with things that act as we
were solved at long time have some real
value when you run it so that's what we
will use here the first will invoke
Erlang colon + + S Pen function so that
it looks like this will just take that
static variable and calling vote with or
process news ornaments and then to the
tail call we're calling this reverse in
tail position that happens by basically
you just the process argument here has
the current tail call stored in some
variables one is that tail is the
function that should be encoded as the
next telephone and a bunch of instance
variables for storing arguments so we
say we want to invoke this with temp as
the argumentative we instead of
returning the normal value which is
returned this Monica tell marker and
then the code actually calls this is
just a loop so this is the one this is
if you want to actually invoke fool you
need to invoke first retail component
and then as long as that's a tail marker
we just run the loop here because
whatever because list reverse could also
be returning something cell position so
it effectively turns all this tail
calling into just a loop at the top
level you can always extract the value
of the ultimate and tail invocation by
putting a loop somewhere if you need to
if you need to value that comes out of
that so this encoding actually this is I
tried several different coatings and
they've been
several research papers and other in
coatings this turns out to work really
really well and the good thing is you
get really nice locality because that
area of memory where the fastest effect
is storing function founder and
arguments it's probably going to be the
local cache is if you running this it's
local access Ibaka sex with local
memories only access to the local thread
the downside is to lose the type
information for the arguments with all
the arguments get turned into the
objects and then get it turned back into
whatever the argument position needs so
for tail calls lose the ability to
really do efficient cross invocation in
line in lining into itself all for inter
module so so all this is based on us on
a set of types it's a big hierarchy most
of these programming language so if you
look at me closure for instance closure
doesn't have a big fancy hierarchy of
types it really makes them makes an
effort to use the existing Java taps so
closure integrates much more natively
and nicely with a job because closer
types of religious java types in urging
i decided to make a separate domain of
java types because it lets in line and a
virtual method dispatch
which work too fast so as you can
imagine sirs that er pick is any urgent
object there's numbers integers big and
small things can tell us up is uh is a
pair sequence is one that where you know
that it's a proper list so take the tail
position can only be also a proper bust
essentially or no so this kind of mimics
the way that its enclosure there's only
proper lists you don't have these
arbitrary time cells and then there's a
whole different method of going to do
today but there's a whole bunch of
different ways of optimizing list
representations to make lists
representations fast because you can
avoid conversion in lots of different
cases and it allows you to do some lacy
lists and invite of nice places so
there's atoms which are these constants
drinks that are in her tank or length
references pits and various other
building types so this big world of all
types so a couple special cases tuples
are is generic each level but every
every particular area T of triple gets
turned into its own java classes tuple
of zero elements tuple one elements of
this it's it's own job class so if
you're in a context where to make a tag
test to validate given thing is the
total of two elements actually accessing
the triple elements is just instant
variable access as super efficient
there's no symbolic something symbolic
things that need to be dereferenced
there and i really haven't run into
issues with people
having tools that are bigger than
preschool in that case we could decode
something like if we have more than 20
elements in your triple will turn it
into an array and then there's functions
we already saw a couple of different
uses of functions functions essentially
happen there's it one also an e fund for
every number of arguments and what
differentiates them is that they have an
invoke method has the correct number of
arguments so you don't have to encode a
call to a function in the code knows
that this is a true argument function
which is college and it looks like a
real native java indication to the JVM
so again it's a case of trying to make
things look like real Java code so that
actually what happens when you export
something it looks like this so the fool
assuming this food to function that we
defined before what's actually also
exported from this module then we
declare essentially an export and export
entry groups's in by means of this
static variable here that is dis punch
to to this constant object from a new
fund to subclass that has an invoke
method that knows how to invoke the
correct implementation phase and then it
also needs a go thing in case it's
called in tail position that's what
triggers that if this is haven't called
intel position and just go so this is
one of them one of the point where i
hope to improve significantly in going
forward because actually it turns out
that more than half of the generated
java bytecode that comes out of
compiling airline code is these kinds of
little function wrappers that just go
out and call the right foot and as it
happens in Java 7 8 I don't even know
exactly
the new instruction java 7 there's a new
instruction that allows us to get away
with this because the JVM introduced the
notion of function pointers directly
into vm so haven't had the time to dive
into that i did a lot of work to just
get up to java 7 level because that was
a complicated enough in itself so so the
type of flow analysis you have to do a
nap essentially it does an abstract
evaluation of the time mottrot on to
infer types and it kind of propagates
type information if you have functions
that are only called from them the
module you can propagate type
information into those other functions
and then it also just like propagating
types it also needs to propagate
knowledge about which functions can be
call detail position and which functions
could do something that can that can
suspend and that's them the last part
I'm going to talk about is how to handle
suspense because I have a couple stores
I'll skip this ok now that's this is the
floating point I'm there's so much time
how am i doing on time OB I have three
minutes ok ok so I like to explain how
this floating punch that was really fast
so the tie perfect let me let me start
here so the type inference as you can
assume the imagine it doesn't an
abstract interpretation instead of
carrying around values and
interpretation it just carries around
type information and to get the most out
of this type information you want to
know when some stuff like when you plus
2
+ and not something and a double it also
returns a double right so all that
built-in functions like plus to this how
you describe a built-in function
interject here we can even allow these
to be overloaded so plus actually in
this I've just shown three of the
implementations of costs that match if
it's you always need a base case that
always matches for any kind of two
objects and then if one is a double then
it knows to return to the return value
is also double if the first one is a
double then it also knows return values
a double and you know when describe all
these versions versions of these
operations you can get pretty specific
information also flowing through all the
built-in functions and operators so you
know if you do something that it has
doubled with one of their opponents the
binary operator typically a double comes
out of that so that's that's really what
adds up to being able to infer and get
down to generating code that is
essentially just playing java code that
does confused double numbers and that's
the reason why this it's like under
order of 17 times faster so if you try
to take one of the language shootouts
examples this is I downloaded that
anybody example
the language shoot out running a million
iterations here how long does that take
on theme and height and an oj so it's
just an example I don't know so the
trapeze this could be an argument for
picking up urge angus and floating-point
stuff but you know if you really really
want to do for himself faster probably
not even looking at birthday or landing
in the first place so the last part is
encoding processes and that's I've been
tricky because in Erlang because in Java
there's you can't like suspending the
process and then what we need to do is
reconstruct activation records so let me
show so you have a sequence of
activation records so just assuming this
is a real Java stack it has some frame
objects at every frame every day in
every method invocation your function
invocation you actually called the next
function so for each of these oh it's
not always the same function being
called in this it was the function at a
given offset into the function that we
called the next here and here was one of
the function calls it was towards the
end so I'm kind of showing that every
function has different call sites that
can cause other emergency so when
assuming that would block in a receipt
here what we need to do is basically
generate code in the generated code to
save the pc or the call site index and
all the local copy of all the local
variables we save that off and then we
return and say that off and then we
return save that off in return say that
off and return and then we wrap all this
up in a fiber object that then we keep
around so when we invoked this again we
can start essentially a bottom frame
here and voc a function that we encode
it at it at this particular level we
don't actually we don't restore the
state would just figure out which this
location and dysfunction take
is it that we're we need to call the
next fashion so we basically just call
up to the point where we are in this
receive and then restore the local
variables so that's what happens in a
context which actually roll off the
stack saving the state of local Barrett
is unroll it better goal to create an
empty set of activation records I don't
have local variables initialized I also
pop up to the point where we actually
suspended and then good local variables
we story and then it turns into some
pretty hairy coat you actually when you
move then suspend again now we can
observe that OD assuming we just suspend
it right away we received one message in
a loop and suspend it right away the
interesting thing is that images to
stash those local variables that we
modify here but these ones are all the
same so actually the coat Jen knows that
so just ask this and then we don't need
to do anything whereas okay whereas if
you return this was the next line if you
return you just when you return to
actually pleased store the frame
variables on return so it turns out that
there's there's four different ways to
return to coat Jennifer for something
which can suspend a Foo function that
can suspend go something like the city
again it gets added an extra variable so
what which call site it always starts
with say a fifth a piece of which call
site are we act and then if it's not
zero then we have to go to some call
site and then there's a cochin around
the original function call here we need
to munch with the stack of exhibition
records and when we go up there's four
different ways to return
saving local variables just a plane
returning because it was already saved
we're in a return situation with far as
with returning normally but we don't
have our local variable so then we
execute some code restore the local
variables from that tip abstraction
always to do a normal return so this
adds up to like five sometimes 10x the
original code of course so we need to do
some flow flow analysis to only do apply
this transformation encode they can
suspect so that's a significant part of
the also type analysis to try to reduce
Monica to brendans so recently I took
the time to actually make elixir work
that will heal more about tomorrow
tomorrow morning and I spent a couple
days working on this most most of it in
September and it you know the state of
affairs is that whenever I tries to run
something significant chunk of code you
need I'd run into some educators with
corn cases that you know it didn't
support before and is any significant
chunk of airline how I'm going to run
into this so in its here just really
quickly you know it's well it's one of
my hopes for a goblet for people
adopting this way you could say like
Syria is kind of a better ruby is that
Ruby's like language it looks like
movies and technically buns
yeah and i think the Ruby community has
pretty good vibes from JVM based
language from jruby which says at least
some success in the room spaces and its
really back-end kind of language that
can wait could benefit from long running
processes that can get optimized and
stuff like this so I had to fix some
bugs fixed name mangling to exit be able
to let's see it generates these module
names that are very uncommon in her line
space I had to do some work to extend my
analysis and reduce the code stack size
so not generate suspend stuff in places
where it's not necessarily you did and
then you know it's wonderful because
alex is test suite it's actually quite
but good testament corner cases of
earlier behavior and it really easy to
pinpoint exactly thing Biff's that it
didn't return to write error code square
plus or stuff like that so so yeah
vergennes now in ninety-eight percent of
the electors test suite and it needs
some improvements and some file system
stuff and few unicode things but it's
really nothing essential so think we'll
stop here few minutes overtime I was
looking to come and ask questions
afterwards the public to take questions
are fine
with its eric sister you should have
stopped but at least giving a good round</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>