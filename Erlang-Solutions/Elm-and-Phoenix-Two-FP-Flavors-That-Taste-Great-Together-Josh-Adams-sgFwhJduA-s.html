<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Elm and Phoenix Two FP Flavors That Taste Great Together -  Josh Adams | Coder Coacher - Coaching Coders</title><meta content="Elm and Phoenix Two FP Flavors That Taste Great Together -  Josh Adams - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Elm and Phoenix Two FP Flavors That Taste Great Together -  Josh Adams</b></h2><h5 class="post__date">2017-03-25</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/sgFwhJduA-s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello
in here we only a little bit okay I'll
try to speak up so I learned a new
German word last week I think I think
maybe this is torture lust panic but I
don't know someone speaks German maybe
anyway but it means um the fear of time
running out and the reason I learned
this word is because of this tweet right
here so 15 days ago I realized I was
still like on the fence about exactly
what I was doing for this talk I knew
broad strokes right and then I realized
right oh that's not very long so this
gentleman helped me learn the German
word Joe didn't know a good word but he
had a good solution which was just waste
14 of the 15 days of course I'm a very I
tend to like plan pretty hardcore for
things but this time this time that's
basically what I did
so I've missed most of this conference
because I I finished my slides like 30
minutes ago but like the the talk was
mostly done three days ago like I do
wise anyway so in this talk I'm gonna
walk through a brief introduction of
Phoenix and Elm intro to the firestorm
forum which is an open source
phoenix-based forum and sort of how it's
built I'm gonna discuss how Elmen
Phoenix interacts in this particular
case or in general and I kind of found a
neat communication style that I don't
know if it's novel that's new to me that
sort of came out and it's like a
simplified way of interacting with my
back end and so I wanted to show it off
and talk about a few consequences of it
mmm so first off brief introduction to
Phoenix who is familiar with Phoenix
here this will mediate how much time I
spend here who's really comfortable with
Phoenix okay so we can zoom through this
mostly so here are some reasons I think
that people ought to care about Phoenix
if you have like data in a database of
some sort ecto is really nice it's not
technically part of Phoenix right but
it's relevant and then change sets which
are also in ecto and maybe shouldn't
necessarily be they're nice for modeling
your data whether or not it's in a store
and
describing how to like turn it into
something for the browser or turn it
into something from a user it's very
nice even if you're not like in the web
piece actually Phoenix 1.3 is like in
the process of coming out we're like
release candidate 1 or something
two anyway second release candidate I
think and it made things a lot better it
adds these context things I won't go
into them too much but it's sort of the
domain driven design bounded context
idea so that your controllers basically
shouldn't be doing database operations
anymore for the most part this is nice
because it like you're modeling your app
and you're modeling like your web piece
and they're different and that's a thing
that it bothers me that we don't do
enough anyway so it's great the Phoenix
is making that good it also added first
class umbrella application support which
is also nice because less fiddling and
then a Phoenix also gives us channels
channels are amazing they're really good
abstraction for real-time communication
they don't have to be WebSockets so
don't confuse the two but and they also
give you knowledge of presence on a
given channel whatever that means
they're given topic by particular users
somebody go through some basic Phoenix
code examples here's an example schema
so if you haven't seen Phoenix before
and this are ecto before and this is
maybe the smallest font on any of my
slides so I hope it's not terrible but
basically this says you know it sort of
lays out ultimately a struct for
category it says it should be backed by
the categories table and you can do
things like find child categories or
find the views of people have viewed
this category certain number of times
this is not exciting this is just nice
like it's this is not breaking new
ground one thing that is kind of fun is
these two virtual fields children and
ancestors that just makes it easy for me
to like get the data and put it onto the
struct before I hand it somewhere so
that it doesn't have to do math later
their database access I'm sorry this too
basic but it's just nice and this does
not interact with the database that's
what the repo does this describes how to
do the interaction with the database and
there's an example of like a controller
action so again this is just very quick
intro to Phoenix in slightly not hello
world examples as an example of a
controller action
it just takes in this case an ID or a
slug figures out which how it looks it
up prepares this tag category thing
which is just like a command
can add a tag to a category and then it
tries to get a category and if it found
it it'll show it it's not it could be
tighter like there are things I could do
to make it make it smaller but in
general this is pretty pretty clear so I
like this it's it's good
and then here's like a view in this case
we're dealing with API right so I've
just said when I render the fetch views
index JSON I have to give it all this
stuff or else I don't pattern match on
this function and then I basically
delegate all of them to this other view
that knows how to render the entities in
my in my data model and then there's the
router so like this is almost all this
stuff except for channels that you get
with Phoenix this is the router this in
this case says like we have a browser
we've had all these plug things
everybody what plug is plug is plug is
awesome plug is what this is built on
I'll talk about it momentarily but all
the plugs in this case say like okay
well let's fix this session out of the
HTTP connection that knows all the stuff
in HTTP terms and put it into this like
place that it's easier to look at get
the flash protect from forgery put
secure browser headers these are all
tiny little functions that are plug
functions that you can like put into a
pipeline and then I've added my own
which says hey go ahead and get the
current user out of however we happen to
have it because I have to handle up
complex case if I want to do some
squirrely wrong stuff with some tests
anyway so that makes that's a place I
can hide that complexity and then we
have this this thing right here that
says like here's what the web piece
looks like you have all these routes
they map to these controllers
potentially these particular actions and
then that's it so like it's your basic
routing I just wanted to show it as the
intro thing and then in terms of plug
this is what it's all built on top of
it's an abstraction for web servers that
at the very least support scow boy I
think it supports other web servers but
I haven't ever used anything but Kowboy
because it's pretty good anyway but it
gives you the ability to plug in
behavior like you saw before so like
just slot these things in and they
happen on the connection anyway it's
it's nice for building like for modeling
what a request handler ought to be so
that's like super basic intro to Phenix
stuff we'll get into it more but now I'm
gonna move onto Elm who's who's heard of
Elm before who's used it a little bit at
least who's used it a bunch
okay I've used it for like a year and a
half or so now I've used it in
production doing different sorts of
things and it's awesome and I love it a
lot and I want other people to use it
because you're gonna write software I
have to use and this way it won't be as
buggy that's one reason it is in fact a
delightful language for building
reliable web apps I've had maybe two
runtime errors at all since I started
using home one of them was already a
known issue I think and a runtime Aron
Elm is a compiler bug so that's like
pretty freaking cool in my opinion like
if you get a runtime error you're
supposed to file it as a bug against the
home compiler that's awesome anyway so
reasons you might care about it it's
functional elixir Erlang or functional
it's very functional it's strongly typed
there are no runtime errors and it uses
the Elm architecture also it has the
nicest error messages you'll ever find
it like just hold your hand and walk you
through making that change you tried to
make but didn't quite finish it just
does that um
I on another slide deck have a tweet
from John Carmack so John Carmack
tweeted about how every programming
language should try to have errors as
good as Elms so he probably knows things
anyway so this is what an elm
application looks like this is the Elm
architecture that's sort of that last
thing I talked about so the way that
this works just to give you a broad
understanding of a Elm this thing in the
middle think of it as the home run time
so every application ships with the UM
runtime that knows how to do certain
things
notice how to talk to all the browser
api's knows how to do anything that's
impure and like do that for you because
when you're at an emperor game you write
a pure program there's no side effects
at all so what you start off with as you
describe kind of like what your model is
or there's various ways to start but
your model is like the data that you
need to show the stuff right that's all
that means
so you describe what that is and then
you would describe messages messages or
like the things that people can do so
those are both really easy concepts to
understand and so you literally just
make a union type like a list of the
things people can do and that's it
that's all the things people can do in
your app
you have to handle all of them from
there you start off with like this in it
so in it would like give your initial
model so maybe it's just like one in the
event of a counter and you just want to
start at one all the time but maybe it
looks maybe before you load up your L
map you look into local storage and like
fetch your serialized version of the
model and then you like decode that and
that's what your hand to the init model
so anyway that's the sort of thing you
can do up there anytime something
happens in your application update gets
called and so again all the green things
you are describing these are functions
that you define these you've built an
elm application so update it gets the
message and it gets the current model
handed to it from the runtime anytime a
message is emitted and you just return a
new model and then there's a two tupple
of a model and then a command that is of
type message and so basically the if you
ignore the second part of the tupple
this is like just any old gen server
with handle cast right this is a thing
and cast messages and if it knows about
the messages it does stuff and returns
the new model this is exactly gens de
gen server the second bit though is the
command message part that's the cool
part because that's where you say like
you described all the stuff that like
gosh would be nice if somebody make this
API call but you don't do it because
that's impure right so you just kind of
like bundle it up and like I somebody
would just do this thing and then tell
me how it went
using one of these two functions like
that'd be super cool and then the armor
on time like takes it and then it goes
and does that because it'd be cool of it
and then it gives it to you so that's
where all the impurity lives as you hand
it to the runtime and it does stuff so
the benefit is you get to write pure
pure programs and then we have the other
two bits there's the view again this is
a function that takes as an input the
model and it produces some HTML that
could or could not produce messages and
so this is just a function you just get
some data and then like you omit one
structure and you're done and then you
have subscriptions there's anything in
the outside world that might happen so
one would be the ticking of time right
again remember we're pure so we can't
say like do this function and like in
the middle of it go get the time because
that's impure right so impurity if
you're not clear just means like if I
call the function with the same
arguments I get the same return back
right there's like you can't do anything
that doesn't involve the things you were
handed
anyway so then subscriptions like that's
another part of the run time where the
run time can like tell you every second
you can tell the run time like I'd be
nice if you told me when time happened
and the run time would be like I got you
but you can also do other things here
you can do things like WebSockets or
channels that Phoenix and that's
actually very cool and we'll come back
to it and maybe I'll come back here for
this for this image when I talk through
it
or maybe I'll yeah I won't talk through
it now okay so this is like how Elm
works in general you have any questions
do do talk to me later I know there's a
million different ways to try to show
this diagram this is the one I like the
most so let's look at what Elm actually
is though right
we'll build a basic Kellam app there's
apparently a shortage of counters and
the UM community has set out to correct
this wrong so we're gonna make one also
it just happens to be a really good
example for a null map so I mentioned
before we define the message in the
model that's kind of how I start so I
define my model it's just an integer
it's a counter there's a number done and
then things you can do right you can
increment or decrement it you can
imagine being able to increment by three
or something right maybe that's a
different message maybe that's a message
for the parameter but this is the
universe of things that you can do in
this application so like increasing the
font of the number is not in the
universe of things you can do in this
application and if it were you'd kind of
see that right here so here's our update
it gets our message in our model and
this is a slightly more basic version of
an elm applications that doesn't do
anything that side effects so you don't
return a two-top well you just return
the new model so now it very much is
just gin server with only cast and no
side-effects and so here we get a
message if it was decrement well we turn
our model minus one
it was increment return of model plus
one right that's it
one sort of neat thing to note every
Ellen is a single expression so like
it's not like you give it these three
functions you want to run one after the
other you give it an expression and then
there you know ways to to do the things
that make you think that you need
imperative stuff and then this is sort
of the view right so our model remember
it's just an integer so we have a
function that takes an integer and it
produces here I'll show like what LM
HTML stuff looks like so you have like
an HTML tag like do
or button and each of those takes two
arguments its function that takes two
lists the first is a list of attributes
and the second is a list of children and
they both have to be parameterized on
the same thing that this thing is or
mapped appropriately so in this case we
have a div and then attributes are like
no class no ID inside of it we have a
button when you click it it'll decrement
so that's one attribute it's like an
on-click and then it has one child which
is a text node that has a minus sign
then we show the number then we have the
increment button right I think it's
fairly easy I think I spent way longer
explaining it then it took anyone to
read it and sort of figure out what was
going on anyway so that's kind of the
intro to elm and phoenix at a very high
level for both of them and we'll dig
into some we're gonna skip the
intermediate and move on to just showing
like this neat thing but if anyone wants
to talk about like the intermediate
stuff there's there's other stuff I'm
glad to discuss brief marketing aside I
started I dropped out of my consultancy
a year and a half ago because I wanted
to like focus on this thing which is
whether I'm good at it or not I want to
help people become better developers
partially out of just goodwill but
honestly I'm a super selfish person and
there's some software developers gonna
write the software for my pacemaker and
I would prefer to do whatever I can to
have that not be written in JavaScript
so that's part of this the other part is
I think that it's just fun and I think
that if we can help other software
developers get better it's gonna have a
bigger impact than any one like thing
that I might spend three or four hours
doing so that's done at daily drip com
where we do daily continuing education
for developers we have a lot of elemen
elixir content react native our ember
swift 3 lots more stuff coming and if
you want to get better at like building
software or at least tell us why we're
not good at teaching people that then
like you could check us out for either
purpose and also we're actually going to
be we've just now switched to doing a
thing where we're kind of becoming like
am research and development arm of like
fun things to look at for our
subscribers so we are now like community
driven so we have a section of the site
where people can propose an upvote and
downvote things so like people can just
aside what we're gonna do episodes on
and we've already gotten like a couple
of interesting ideas and we hope to get
a lot more from that then just like
here's the cool stuff that I want to
show rather be like here's the stuff we
all agree is very cool anyway so that's
daily drip that's the end of the
marketing aside let's talk about
firestorm firestorm is the open source
Phoenix based forum with an elm
front-end we did a Kickstarter for this
and it went very well very very happy
about it so we raised $23,000 issue
slightly under which means that we hit
our first stretch goal which means that
this forum is also after it hits 1.0
we're gonna have a like a slight pot for
it so you know the lawn production forum
though the dream is like the whole idea
behind this thing was a few things we're
gonna build a production app just like I
would have done at my consultancy for a
client we have a professional designer
working on it sherry works for us and
she's not she wasn't fully busy so it
seemed like a good thing to do we're
gonna do continuous integration
continuous deployment and honestly it's
it's just hard to find like an example
application that's out there in the wild
that is doing all this stuff just
because typically that you know most
open source projects are doing
continuous integration because I
probably not even host it right it's
just some software you can use so we
have an alpha release we've been dog
food sorry not at alpha we're almost at
all for at least two features left we've
been dog fooding it at this firestorm
dog food Heroku app calm I don't know if
this green is legible and then we're on
github.com slash a daily trip slash
firestorm if you want to see the code
another part of the Kickstarter was
we're producing five weeks of free like
elixir content so intro to elixir like
intermediate elixir or not intermediate
but like hey processes rather than
syntax OTP ecto and phoenix so like a
week on each of those things we're
producing those and we're about to start
week four I actually backed off a little
bit because it turns out that Phoenix
1.3 was gonna finish like shortly after
I finished doing a week of episodes on
Phoenix 1.2 and that seemed bad anyway
so that's sort of held us up but then
after we're doing that we're producing
videos that are you know premium part of
our thing that walk through building
firestorm so like building from scratch
essentially this thing that becomes a
production application so that if anyone
like has questions along the way we
should have something covering it so
anyway so since it was an open source
project part of the Kickstarter involved
us getting our designer to work on
professional designs for the project and
weekly meetings to discuss the progress
and like feature requests and stuff with
our supporters so we did ten of those an
hour moved on to like just sort of open
ones every week so if you want to join
like a firestorm fireside chat you can
do that and as we talked about the the
thing anyway
but here's the design so this is like
not all implemented here but this is
like a phoenix app right you can login
it's kind of like an email client or
whatever for drilling and it looks an
awful lot like like what discourse is
that the name of it but we'll you know
try to not be a clone anyway so that was
just the basic design walk there just to
show you how that went but now let's
talk about the architecture of the
actual application so it's an umbrella
app and it contains three applications
inside of it
we have firestorm data a firestorm web
and firestorm notifier and they all do
different stuff right there's the data
piece is literally like the application
right this is what it means to be a
forum and how do we store that stuff and
then the web is literally just like how
do I talk to people and like then
interact with the application for them
and then the notifier just listens to
some stuff so we'll sort of talk about
that again very briefly this thing has
the actual application logic it has the
datastore knowledge and it also has a
pub sub right now it's a gen stage
producer that's probably not the best
idea but right now that's what I'm using
maybe I use Phoenix pops up in the
future anyway but so that other
applications can know like what's
happening in the data layer because you
want to be reactive right you want to
say like oh this thing changed let's do
something and so pops up then we have
the web piece as I mentioned it just
turns user input into stuff into
commands and turns like data into JSON
or or an HTML view or something and then
we have the notifier and it just it's a
consumer of the gen stage so it's
literally right now all it's doing is
listening for new posts that come
through the data layer events thing and
it'll just email anyone that's following
the thread right it's not super smart
but we do expect to put a lot more
smarts on there for things like batching
up emails right for people that don't
want an email every time there's a post
but the point is it's going to be a more
broad OTP app right it's going to have
like little processes that live that are
like gathering up emails and then you
know four hours later they die and send
their emails or whatever and then the
next a little bit is the part actually I
end up spending a lot of time chatting
about I don't know what to call it it
started out as an API and then like the
way I've made my own map work and now
it's channels but the L map mostly
didn't have to change so I want to talk
about this because I think it's neat and
it gave me a lot of insights and you get
to see exactly how like the Elm piece at
least works so it's kind of like JSON
API meets graph QL and then doesn't do
anything reasonable so before we get
there let's just look at like this Elm
client for firestorm so we've seen basic
element basic Phoenix we don't really
see like the advanced phoenix part but
i'm glad to show code if anyone wants to
see it but let's look at how the home
client interacts and before we talk
about how it interacts here's just how
like the view for this more
production-ready thing looks so it's
just a function it's just bigger than
the other function we saw for the
counter right it's not it's the same
idea you give it a few more arguments
but it's the same deal but here you can
see like if you're looking at it we have
all these like classes layout content
thread header item metadata they're
clearly like things but we're just kind
of making them ad-hoc as we go and I've
always hated this about templating
languages because in some cases it's
very hard to like encapsulate little
pieces anyway but Elm is not so much
that way so like this worked perfectly
fine but it didn't read that nicely so
we've refactored it to this which i
think is better and L makes this super
easy like literally I just pulled a bit
out and like gave it a name and then did
that a couple more times and then like
you're done and if it compiles you did
it right and if it doesn't compile it'll
tell you where you did it wrong so
that's really cool I should have an
example slide that shows an error but I
don't pardon
yeah so basically we have this layout
content we have this thread header
that's this big section in the middle
then we have this post list and so then
like cool we have names for those
already there anyway and so the point is
when we extract the layout content here
we wanted a function that takes a list
of HTML things and produces an HTML node
so I could just take a list and then
produce a div and then put that list
underneath the div right that's a read
way to do it but Elm provides like
automatic currying so really layout
content take our div takes two arguments
right it takes the attributes and then
the children so if I want a function
that takes children and puts them in
this div I just don't complete this
function right I didn't give it a second
argument and so this is a function
that's waiting on that last argument
that's all this is it's very
straightforward to anyone that's that's
sort of dealt with carrying right but in
other languages I might would like take
the argument and then pass it as the
third argument because it's easier than
this and because of that I don't
refactor as much in languages like that
because it's like I gotta make like a
wrapping function because there's no
Korean and so it's just not convenient
and so I just put up with it and I say
now you know what this is good enough
but if we weren't for that I could get
to this which is better anyway and then
here like I like this little function
right it's a we did it slightly
differently over here we did let's top
map and then we give it a function that
it'll map through and then we give it
the posts that it's gonna use and in
this version I take the post I mapped
them through the function and then I
pass those to this oh L that already has
its attributes and they're provide as
the children did the same thing I just
like this because it's a transformation
the whole way down right it's you have
posts you turn them into HTML and then
you turn them into you know broader HTML
anyway and then thread header like when
in the process of doing this you'll
notice everywhere we have like this
class thread - header this is like a RS
CSS component RS CSS i/o if you if
anyone like likes that CSS is a thing
but has never been comfortable that like
their methodology with scale or like run
into things and you have like oh these
two things are like conflicting and it's
inconvenient fix and I didn't figure it
out till too late anyway if anyone's in
that boat I was in it for a long time or
s CSS really really cool it gives you
just a couple of small rules and then it
turns out that stuff is awesome so these
are both our CSS components but like
I've got them all in this one thing so
at this point this last night I was
looking at this and I was like it's kind
of stupid that I haven't ripped that as
a function either but like I'm in the
middle writing my slides why would I do
it but it turns out that Elm is really
fast so we just broke it out into a
component because it took like a minute
and now we have these components and we
can reuse them everywhere and they map
directly to like my CSS which is very
neat this is not so exciting maybe but
maybe it's useful to see like the
evolution of like view functions in Elle
like they go from the basic to like
functions that you can compose they're
nice and anytime you do something like
this the compiler helps you so
refactoring is really nice in Elm was
the point and that made it trivial to
get to something like this I changed it
slightly like while I was in the process
of writing the slides and so now we have
like this whole components layer in our
application that we didn't have 20
minutes before I started this and it's
just nice and that's like every
experience in Elm is like this for me
like I have a thing and I'm like I
should do that but it's probably a lot
of work and then I remember that I'm
using elements so it's not a lot of work
and so then I do it now my codebase is
better and previously I would have just
been like gosh that'd be nice to do but
let's not yet anyway so the data model
for this thing is this is a part that I
wanted to talk about because I it just
makes me happy I know that there's at
least one person in this room who will
say you know there's research on this
then you should not do it that way but
maybe maybe not but this was neat for me
so basically the way that it works is we
have this local database deliver so we
keep a section of the data model that
you care about sort of now right now we
haven't I haven't finished all of the
stuff so when I say a section you care
about I mean or that you ever cared
about so it grows hugely like it's not
smart memory wise yet but it's easy to
do so anyway it's model as a record
containing a field for each entity type
so we know about categories threads
users and posts so we have like think of
these as like local databases right so
you have a dictionary with an integer
key and it only holds categories so like
you can never get a thing out of there
and have anything that is in the
category and then the the key is just
its ID so we have a dictionary of things
we can look up by ID locally that
represent the things remotely and then I
have this wants thing and I though I get
into that so what we do like if I have a
category you might imagine that a
category that has subcategories has like
a subcategories field that holds a list
of categories or a dictionary of
categories or whatever their cup
problems on this first off if category
is an alias then you can't actually do
that because it would be an infinite
type and then there's a way to get
around that but then it's kind of more
wordy you have to like wrap everything
in a module and add a bunch of functions
plus I don't think it's better in this
case because what I really want to do I
don't I don't want a tree of categories
I want like a category and I want a
database and that's what I have so
categories know their foreign keys
essentially right even though it's
modeled differently on the backend this
category knows all of the topics that
belong to it and so if I want to show
the category I can just look up the
topics in my local database and if I
don't have them I can have a thing
that's constantly getting data that I
need that I don't yet have so I get a
new category and it's like oh it turns
out there's these three threads that are
underneath it and like I don't know what
I'm going to do when people ask me to
show that so let's go ahead and fetch it
before they do anyway so that's that's a
cool thing that's easy to do with this
layout with this whole like flatten out
graphi layout and then have this wants
thing and this is a I call it a
replenish request I think I show it yeah
sure right here so this is just where I
give for each type of thing I give a
list of ID's that like it would be nice
if I knew what these were like someone
mentioned them or I have reason to
believe they exist because someone went
to a route that like ended in seven so
it's a category with a d7 but I don't
know what that is so I can just put
stuff into my model into this the end of
this wants and then I have a thing that
looks at it and says like do I want
anything because if I do let's ask for
it and so just by virtue of putting
stuff into the model like I get my local
database updated without what you've
wired the pieces together which is
really nice it's like it's declarative
rather than like making a request rather
being imperative and being like hey give
me that category I just happen to tell
my like layer the store it'd be cool if
I had this and then I get it and so
that's nice like the declarative versus
imperative makes stuff way nicer that's
one of the reasons that do we do the
functional programming thing I think and
then we have the store update so in
general like with an API like a REST API
you might have like a categories
endpoint and it gives you just like your
category or a list of categories or
whatever you might have like a threads
in point you know give you a thread and
are like a list of threads or whatever
so all of my endpoints are all of my
anything that I get from the backend has
this so it'll just give me
anything that wants to tell me about
across any of these entities so I might
you can imagine me asking for a category
and it knowing well you're just gonna
want those threads as soon as I give
this to you because I know that it has
these two threads and I know you're
gonna ask me for them so you can like
just write some application logic that
says go ahead and give me those threads
and then you'll never because it's
imperative you'll never hit the request
for those two threads because you
already have them when you go to look so
because of that this this one little
change in how I do my model gives me all
kinds of flexibility because it's
imperative and because I can like give
it more than it asked for and I know
that it's going to act right because of
the because the imperative thing
ultimately so this is cool this was like
part of my little realization it may be
stupid I don't think so right now I'm
very happy with it anyway and so yeah
that ultimately like we send these two
types to the API but how do we get them
to the API like how do we actually
interact with an API so we use this HTTP
module and sorry here's a function this
is like the home index function and it
says get the API base URLs home path
expect to get some JSON that we can
decode with the store update decoder and
if that worked well whether it worked or
not go ahead and send that out so up
till now it's what's called a task so
it's like a description that's still
malleable of what you'd like to do so
you can chain more stuff at this point
syn turns it from a task into a command
so command is just you can't do anything
more to it you can hand it to the
runtime at that point so you can defer
this and not do it in your API or you
can do it right here but you lose
flexibility
maybe not important to tell don't like
it anyway anyway so at this point it
sends it and then we have this handle
get home complete that if we got a store
update decoder like if all the h-2b
stuff worked out fine and we received a
thing that we could decode as a store
update then we call this tagger function
which takes a store update into a
message if any other problem happened if
h-2b error happened or if it wasn't
decodable we had this air tagger which
turns an error into a message and so
then when we call this API like at the
call site we can say in the event of
failure do this and even a success to
this and by do this we literally mean
just here's a message that you would
emit
anyway oh this is also really nice are
important if you're doing an API you'll
notice that this is like lowercase
message so this means like it can be
anything but it has those three
instances have to be the same thing
right in type unification terms like
you're not restricting it to the types
of messages that this function can
produce that's really nice with your API
is because you will find places that you
didn't think about and if you've already
hard-coded it to like a particular
message type that it produces you end up
having a bad time so if you have a
module like this or find yourself
building a module like this just do this
give it taggers and give it this sort of
generic message anyway it gets nice when
you have to deal with errors more than
anything so let's look at like what some
requests look like in this style from a
typical single page app so we have this
client somebody requested they loaded
like slash get categories or slice
category slash one so it knows like oh I
guess there's this category without he
one I'm a client I don't know anything
so maybe we'll ask somebody about it and
so I say server get this for me the
server is like cool we look in the
database hey I got it I'll send it back
to you we decode it now we have it so
this is cool but I'll get to another
point momentarily and then we'll
probably come back here and look at a
few things and then there's just another
API example this time we're sending
something this the only reason I wanted
to give this so we are we have a JSON
body and so we have like this we give it
this replenish request as our first
argument which is like the stuff we'd
like and we have an encoder that knows
how to encode to replenish requests as
JSON and we just call with JSON body
give it encode replenish request and
give it a replenish requests and like
that'll always work so that's nice just
again just wanted to show it so I'd like
to show you how freaking fast this thing
is in practice because it makes me very
happy so here first off is the Phoenix
just the Phoenix application running
hopefully yeah it's all awake and then
I'll go to the over here and refresh and
this is an elm application so a Phoenix
application is cool this is like you
know the dog food oh it's not up no no
this makes no sense I need a mirror for
this period
thank you for telling me but if you
hadn't told me you would have been so
rude also wears mirror arrangement
mirror displays I know there's some
keypress I'd anyway okay so back to this
this is the Phoenix application this is
the Ulm application you can tell them
apart because I didn't put the logo in
the application properly so Phoenix
application we can kind of like troll
around click on things it's pretty fast
it's not instant it's um not like it's
doing too much it's just you know it's
not instant so we click on things look
around we have some nice things in here
like emoji somewhere let's see here I
guess actually this is probably maybe
the neatest thread because we have like
pictures and code and the code in this
one here's the code anyway so this is
just me showing it off briefly just
because because this is an open-source
thing right that's good here's the L map
so you've seen me clicking through the
Phoenix app and you've seen the speed
and it's pretty good I got to be pretty
happy with this as a website so here's
the owl map though like I click and then
it's there there's like no load time
right because we have everything because
we know the graph so we know the things
that we could care about later so we
just get them already and so this works
you know fine on mobile or whatever
obviously it uses a little bit of memory
to store the stuff locally but it's fast
this is like the fastest single page app
I've ever built and it just makes me
happy and it's not that not that
surprising because we have all the data
but like this took way less time than me
doing something like this in angular and
also you have to write JavaScript and
angular and all sorts of other things so
anyway I just kinda wanted to show it
off because it's just real fast it's
just extremely fast and it makes me
happy but we're not using the HTTP API
right there so I almost tricked you
using something very similar what's
happened here okay in theory I have a
see here go away fucka dick back to the
slide deck okay so it is fast there are
a couple downsides one of them is that
we might be too memory-intensive on the
client right because we're just like
gobbling up anything that anybody
references and we're never getting rid
of it so you can imagine that like for
some use cases this doesn't matter
you're just never gonna have enough
memory for it to matter and some use
cases like it's pretty stupid and it's a
useless client slack is a good example
right it uses all the memory anyway so
there's some downsides there also with
the HTTP API a downside is like because
we're gradually kind of walking our way
through this graph and of entities we're
making a bunch of requests so like that
was my first implementation was like it
used HTTP to fetch things and so that's
kind of broadly fine but like often
times that means you're opening up a new
TCP connection to the server which takes
time and often times that means that
you're sitting about your headers not
often times like basically all the time
except for HTTP - you'll be sending a
bunch of headers and they're just like
connection teardown stuff that takes
time so like if we want to be the
fastest thing in the world we don't want
to do that stuff so there were solutions
one of the solutions is the API could be
smarter so like you could track this
session and know about all the entities
that the clients know about and then
only send them so one of the ways you
could be smarter is to send less stuff
right even if I ask you for three things
if you know that I already have those
three things or if I were gonna give you
some children but I know that you
already have them once I actually get
ready to send them to you I can like
reduce bandwidth by not sending them to
you or reduce database access by not
asking for them so you could do this and
like keep the all this knowledge on the
server of like what everyone knows about
but that's like also gonna be taxing
when you have a lot of users right
you're gonna use as much memory knowing
about that stuff you're gonna use a
bunch of CPU like running through it and
even if we did all that and like got all
these neat optimizations we could get
we're never getting real-time like push
notification stuff from HTTP so we moved
two channels we can use channels to make
things a lot nicer without changing very
much at all on the old side so let's
look it through our how our data is
loaded first so this is my little graph
of like how we find stuff out so
remember we did get category slash wine
so like cool this is where I got that
and so now I know about category one but
I also know about these foreign keys
that it has like thread ID one and two
and so now I know about these
relationships and I think like I'd like
to like know what that data is
and so I goes through this function that
map's basically my model into things I
wish I knew about and now we make more
requests we get them they have foreign
keys right so cool now we know new
things we want to know about so each of
these might be an HTTP request and it
could conceivably walk your whole
stinking data tree right you don't
really want to sink your entire database
all the time probably but still it's
it's pretty neat so this is like where
you end initially doing this with a with
HTTP as I mentioned is all those aren't
lined up as I mentioned is not a fast
it's like okay but it's way chatty so
the interesting thing is this design on
its own though gives you lots of ability
to optimize so among other things you
could imagine setting a threshold that
says don't go more than two layers deep
in the graph from where I are per hour
where I am to fetch new stuff right so
that's just a new piece of data you put
on your on your store thing and then it
knows like oh well I want to know about
this stuff but it doesn't come from
something that you've asked about
recently so like I'm not gonna go ask
for it yet that's one way to do it
there's a lot of optimizations you can
make I'll get to that in a bit
one of the really interesting
optimizations you can make and here I'm
talking about really thinking about
garbage collection on the client like
making the client not take a ton of
memory you could encode so we have like
routes there types in our application so
we have a type for each possible screen
in the application we have types for all
the types of entities you could encode
from a given view which other views you
could see right like you can just put
data like make a function that given
this view returns a list of three views
right with potential like entities
entity IDs from a given view you could
also define what pieces of data it needs
right so this is where you like have the
graph QL thing because views tend to
like co-locate with
they wanted that's what they're the
graphical query is but you could just
like define for a given view and like
its arguments what pieces of data you
would need and from there you could say
like okay well here's actually this
universe of all the stuff that I could
possibly need for anything that has
three clicks away in the application
like if you just add those two things
and so now you could literally like
prune your database all the time and
just have stuff that is at most three
clicks away so like you're just carrying
with you this database slice that's just
barely big enough that you never have to
make a request when you make a view
that's really cool but it'd be a bunch
of HTTP our HTTP request is my point we
just wanted we did it with channels and
what ends up happening is if I come back
here I said I was going to come back to
this okay hold on the own thing oh
goodness I should have skipped there we
go
okay so back to this thing done so the
way that the phoenix channels work in
our app is you have you describe all of
the like the things that you care about
the topics that you want sorry so you
can map subscriptions takes a list of
your models our phoenix channels are
handled in subscriptions so not a list
of your model your model is argument so
my model has my story in it my store has
all the stuff that I care about like it
knows all the entities that I know about
and so from that I have a straight
mapping all those entities map them to
channels right and I feed that into this
piece that handles all the teardown and
and tear up of our set up of topics on
my Phoenix channels on my socket and so
now just by putting stuff in my store I
will get updates from Phoenix over
channels just by a virtue of them being
in my store that means that this will
function from my model to my channels
will just update right because that's
how it works and then the what's called
effect manager on the home side just
handles it all for me so like literally
by putting things in my local sliver of
a database I always get updates like as
long as I broadcast them from the server
anything my local database is just like
updated so like again I can do another
example I did have done this one I was
earlier
but I didn't remember so I was
mentioning it being fast let's do this
let's go to the trolling let's go to the
test thread and they're in different
orders but that's not terribly important
so again this is the Phoenix app is the
L map I'm just gonna reply to this
thread and say Erlang factory demo ok so
I'm gonna click reply and click it now
and so it you know it updated on the
right side instantly in this particular
case they came up about the same time
outside of this Wi-Fi basically you
always see the website the channels
version before the one that made the
request ever comes back it's just fast
and I didn't have to do anything to say
like tell me about this just by virtue
of knowing about this thread I get
updates and one of those updates is
there's a new post in the thread and so
that's that was very cool to me this is
the pinnacle of why I think that took a
long time to get here this is why I
think that element Phoenix worked really
well together because I've I've done to
clear I've done imperative set up of
channels an awful lot and just
straight-up JavaScript does anybody
channel stuff right now
has anybody got it to the point that you
can have a declarative description of
the channels you care about and then
like you just get them I don't even know
how I would do it without building
something complicated sounding so the
fact that I can just do it and not have
to work through that is really cool so
this is like why I think that Phoenix
and Omer are so good together it may not
be what you were expecting from the talk
but that's it there's a few more things
to go through so let me do this quite a
bit again how long do I have left
how long do I have left two minutes a
few minutes okay so I'll go through
really quick so we can have questions so
somebody asked me why not use graph QL
and the best answer I had was I dream of
one day building a company that gets
sued by or sues Facebook and their
patent grant means that they can take
graphic well at least their software
away from you if if you sue them so
that's enough
anyway dream big so I was talking with
Oliver Shoals Barnes he's a friend of
mine on the Elm he's also on the elixir
slack and we were talking about he's
building something very similar to this
we sort of came at it independently but
we ended up with something we're similar
and I just was mentioning to him like
the decision on how I stored that slice
of the database and how to do the store
updates like was like led to so many
things that I just realized we're very
cool designs just by their simplicity
and I could optimize around and he said
this he said Elm is so simple that it
guides you to solutions and this is sort
of what he's been saying about his own
solutions right because as he just comes
up with a thing and like right to one
piece of the function he wants the
compiler kind of is like just hold your
hand and if somebody else has said
something very similar like to that says
although a language can never teach a
programmer what constitutes a well
design program it can guide him into
thinking about the right things this is
from the early 70s from Barbara Liskov
we just had a papers we live remote meet
up if you like papers you should join
those with us every month ish but this
is like the reason that I like them as
much as I do but it's hard to remember
this off the top of my head when someone
asks me I'm just like a parody you're
carrying but it's this it's the fact
that like it makes me build good
software anyway so you zone with Phoenix
it's a good guide and that's all good
the sliver of the database no it's just
a word like a small piece and a sliver
yeah sorry yes I'll show it very very
quickly I can I can do it super quick so
on the Phoenix side we have the channels
so we have channel and actually that's
not right hold on a second so in this
case we can look at like the store know
is it's a store Channel so basically I
just have this channel you can join
called store fetch if you ask to fetch
the home data it does some stuff and
then it sends it to you that's it and
then on the Elm side I think I'm running
over so we have the release and the
update we have this thing down here that
says home channel and see home Channel
there we go no that's not quite it
anyway somewhere we have our channels
they get mapped that'll be an app sorry
so I have this ant channels so I say
like get the channels for the model
these might be some other channels I
tell it about and then get entity
channels so these are any channels that
correspond to any entity in our database
just map all of them to their channel
and then like connect with Phoenix and
then you're done all of them had met the
store message which is just like that
generic store update so I don't have to
do anything really smart
like as long as all those endpoints emit
the same thing then all I have to do is
wire them up and I'm done
anyway so that's that and that's that's
literally yep</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>