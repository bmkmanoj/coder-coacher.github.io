<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2016 - Panel - Designing With Passion Panel Discussion Designing With Passion | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2016 - Panel - Designing With Passion Panel Discussion Designing With Passion - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2016 - Panel - Designing With Passion Panel Discussion Designing With Passion</b></h2><h5 class="post__date">2016-03-12</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/yhit4YykcLQ" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so it's interesting that we have we have
three language creators and we have one
guy who wrote a couple of books right
before languages exploded I think it's
partially the reason that the languages
exploded in the United States that's
that State Thomas so give these guys a
hand so as you said minutes ago the
purpose of this talk is to basically
understand from the language designers
themselves how people build languages
that people are passionate about I think
that one of the one of the things that's
often critical for me as a programmer is
how I'm able to organize ideas and in
the language and the language of my
choice and I think that before we get
the perspective of the language creators
I'd like to give get the perspective of
a programmer yeah I'm the official
parasite nug of my oh I see yeah right
yes I'm the official parasite on the
panel here because I get to use all of
these good people's work for which I
thank them all very much so the question
was how do I organize my thoughts and
the answer is I don't necessarily what i
do instead is that i try to use
languages that do that for me or at
least lead me in particular directions
and for me the choice of a language is
one that is has the lowest impedance
from where i am to where I want to be
and all the languages that I love have
that facility they have that sense to
them that they actually help lead me
through the organization and the choices
that I make and so for example I do
about the elixir and transformation
you think in terms of transforming as
opposed to commanding and so that's the
basis I can group of everything I did
and Joe when we were talking about
erlang when I interview you for seven
languages in seven weeks one of the
things that you said was that early
might be more hochet oriented than
object-oriented languages no it's the
only object onto the space it's the only
object or just a glitch with mb but that
was the question the question was how do
I organize my thoughts and so on and I
don't know that my clue I mean it's a
mess basically well you heard the little
book I holiday yeah well that's yes I
have my little book writing and one
thing i do is i right with my when ideas
are unclear I try to write them down and
writing has two benefits football once
you've written it down you've removed
this clutter from your head so you don't
need to think about it anymore and I
think I think about the kind of process
of producing a book because when you've
produced when I work with David and at
the airline book what I deliver our 1212
xml files or 15 x no part 1 per chapter
and editor the directory structure it's
a total mess with all that you know but
what you get are the chat you know that
my mess isn't checked into your archive
you just see the result and how I get to
that is a complete mess and after it
although I just throw them all away I
don't check them into github of stuff no
I just throw it all away there and then
I've got the final bit and then I read
that later and so if I'm writing clears
my head actually but the other key of
thing there is throwing things away
clears your head absolutely yes I think
Davis but that's really cool because I
can throw things away once I've written
it down properly and then the second
thing i do is the other way i remember i
worked in the computer science lab
whenever I got stuck I went in there and
you know maybe a nebula surely he been
there a bit longer than me and I go into
his office and say well I had a problem
i go into nabeels office and so I've
gotta put on the stand this problem now
being would always do exactly the same
thing he would go up to the whiteboard
and he would draw a square and he would
on arrow going into it you draw an arrow
going out you'd write the word e on the
arrow going indeed write the word out on
the arrow going out and and he would say
a program is a black box it has inputs a
new point of the input and then you'd
have outputs and then he would take what
are the inputs to your program and I
would go something over and then he was
it what are the outputs to your program
and i would say something then he would
say what is the relationship between the
inputs and the outputs and i would say
is and at some point in that
conversation i would suddenly rush out
and go Nabil you're a genius the room so
i think this thinking about what the
inputs and what the outputs are and what
what the relationship is and when you
can't program or you can't do this
because you don't understand the problem
so you have to think and you have to
write it down so just distract me that
we've basically described a function
yeah great set out for jump yes so i
thought i would answer this question by
talk about how i like to what i like to
do is identify some hard problem but i
want to solve and then look for a small
api of combining forms that will enable
me to solve it and a really great
example is the pretty printing
operations that i talked about this
morning and so they're an important
first step using Haskell is too
invent the tights of the API so just
coming up with the times is very helpful
start and then the next question for me
is what is the semantics of these
operations going to be we find it quite
helpful to define a completely
inefficient implementation just to pin
down the semantics so for example those
those documents I was talking about I
started off using a list of possible
layouts you can't implement it that way
they get exponentially large but you can
get your thoughts clear and understand
the semantics that way once i got the
semantics or an idea for the semantics
of the API that i want to know what are
the laws that they satisfy and i'll try
and formulate those CD terms of true
when I develop the pretty printing
competition so I didn't have quick check
but nowadays i would of course write
down the laws test the quick check make
sure they really hold to the semantics
if they don't fix the semantics probably
and then finally use the semantics to
derive an efficient implementation and
that paper that i refer to this morning
that's not really about the pretty
printing functions is about this process
that i've just sketched going through
the design by thinking about this man
takes yeah guess it strikes me that's
also the hassle way yes so we've got
this this lazy thing where you basically
described the world first and we draw a
box around all the internet
possibilities to limit your books plates
to something interesting yeah and so
Evan as you wore dunelm one of the
things that
you've done to help your readers
actually or your users their approach
functional languages is to kind of put a
box around the features that you have in
the language itself right can you could
you could you talk about that a little
bit yeah so I'm sort of bending
benefiting from lots of great work so I
do most of my program in the hass home
before that was using a standard amount
of campbell so so once i started using
languages like this i found that you're
sort of pushed into a process that has
good results you first have to say like
what what am I even doing here right
like what would mean to talk about the
data that I'm working with and so once
you sort of understand what you're
working with doing stuff with it becomes
crazy easier so a lot of a lot of my
work is also more library focused of
language weapons which isn't quite the
same as what my users are doing so my
process for writing code may not be
helpful for everyone who's more library
creation in that realm we really do want
to start like what does it what is the
essence of the thing apartment so one of
my co-workers is working on that
LMK CSS where he wants to represent CSS
in a way we can generate stuff and he
sort of coming at it from a more
JavaScript d perspective which is how
can i make my API work nice and like
what tricks are available to me such
that my API seems nice seems minimal and
then do whatever hacks we need to do to
achieve that API and sort of what I do
and I think what Haskell in development
all these sort of type of culture
languages encourage you to do is start
it from the other direction they like
what would it mean to represent the CSS
and sort of from that the answer kind of
falls out and I think once you sort of
get used to this process you can see
what answer happened to fall out this
time and be like pleased or displeased
so a lot of my practice will be like
alright here's my understanding of the
problem let me see what comes from that
now that i have an unsatisfying I'm not
like proud to show this to someone and
then you do another efficient okay maybe
I didn't understand the problem quite
right maybe I can teach a little bit
does that kind of match your yep very
much and and really I think that comes
from the language and I don't know I
don't know as someone who I didn't
create that bad it's been really
valuable I don't know if you can speak
to the extent to which that was sort of
in the ether or so I think that was
that's the kind of software development
that all of us working on house
it was
limitation which is how we make
rendering or pretty quickly and I just
got to a point where in the jobs were
paralyzed and everything was wrong like
a calexico fundamental just wasn't going
to work and like refactor much but in
JavaScript it is like what is that what
is that RM minus RF and so instead of
just continuing this sort of like that
especially analogy but just like Baron
on and hoping that it's going to be nice
eventually I need to often that can work
in this case I hit this bear I was like
okay this is just broken as I went to
notebook and so I've said okay what does
it really mean to patch my virtual Dom
okay its business businesses and it's
exactly the process I would have done in
Haskell and L in one of these languages
because you have to you have to say what
is my data as opposed to inventing it
haphazardly as you go through that's
really cool I mean so we just heard Evan
say that you know sometimes I'm plow on
before things were beautiful and that's
not my experience with your software at
all my experience with your software is
that you
are not satisfied until it's beautiful
so a lot of us talk to talk to people
without the things that we've built with
code and we've asked those people how do
you make this thing beautiful well Evan
does the same thing with the own
language krytus oh you think of
usability so actually there's a question
on their syllabus that our syllabus or
the program I said you know how do you
think about usability when you design
your language so yeah personal life
struggles to listen languages that I
love right so I my process so it was
starting with Java doing some see seeing
PHP ending like oh god I'm glad this is
only a week of course work and then and
then doing a lot of scheme getting into
a camel getting into standard ml finally
getting the Haskell and so I was very
lucky in that I had great instructors
all along that route but things were
still difficult particularly when I made
the transition from o camel to Haskell
and I made a couple mistakes making that
transition but I there were certain
concepts that I struggled a lot with and
when I finally understood them I was I
was frustrated that they were simple and
I felt that something had gone wrong
that I had to work work so hard or like
be confused in this way and i also had
this feeling delight i think i'm pretty
smart like why is this so hard you know
like that
there was a sort of gut feeling that the
essential piece here could be sort of
presented in a way that that was more
accessible and that that's really what's
tripping a lot of work on elm is this
just like how can i as quickly as
possible get people to see the beautiful
thing that just was there before me that
for some reason wasn't cool or was it
wasn't instead of catching on yeah
that's an amazing way to say it and you
know it's interesting to see that the
back and forth you know as you're you
know sharing the story and looking at
John and recognizing that a lot of a
haskell leadership came right here and I
want to ask you John nothing says
beautiful like designed a committee
right let's go survive then yes so I
think one thing that is quite important
is that although there were many
language silent and language
implementers on the House Committee we
were explicitly not trying to fit
together everybody's language so that it
would be as easy as possible to just
adapt the content of everybody's
compiler so it wasn't the case that
everybody had a feature that they wants
to get in and we kind of stuffed
everything into a box why don't we start
with a clean slate and I think that that
was important the other thing but I
think probably helped was that all of us
where and we were working in university
circles and all of us we're teaching
functional problem
all enthusiastic about that so one thing
that was in our minds the whole time was
is this going to support the kind of
ideas that I want to teach our going to
be able to teach these features to my
students I think that's a good
respective to have you know a negative
you want to avoid unnecessary complexity
and keep stuff simple enough that you
can teach it I security there's only so
wrong could have gone like the craziness
couldn't have gotten so out of hand does
that how does that hold up to you end on
the hospital committee there were a
number of fairly crazy ideas that we did
well one of them was the semantics of
pattern matching so if you got a number
of function clauses then in high school
today you matched them you try them from
top to bottom and you match each one
from left to right and that order really
matters because of lazy evaluation so
you know the the order in which you
match the pattern drives the evaluation
of of the arguments and it might be that
you know if you evaluate them and lift a
different order then a function call
will raise an exception instead of
returning a result and for some context
of camel because it's not lazy doesn't
have to be super strict about it
ordering you can do sort of trickier
testing that's wrong Elam actually does
trickier testing as well because can I
yes yeah in a strict language you can so
there was a proposal in Haskell that we
should adopt a pattern matching order
that would be determined by the compiler
fairly hard to predict and support
parallel matching and so there was quite
a complex proposal for what pattern
matching should mean and this is this is
one of the contributions that I may I
got that I said we can't do this it
doesn't have a compositional semantics
and then other people in committees well
we just haven't thought of the
compositional semantics yet go home John
and think of it so I spent an awful
evening or maybe a whole weekend trying
to come up with a semantics for this
this complicated mechanism that we were
going to introduce and when I came back
I said it just can't be done and luckily
I would had enough credibility on that
point we decided we would drop it and we
kept with a simple top to bottom later
item so is the trouble mixing laziness
with the parallel matching I'm talking
to the mics and people yeah yeah what
was the trouble mixing parallel
evaluation with laziness or was it
something else just for my own personal
so the problem was that there's no
really well-defined unique order in
which you might want to match so so you
get a rather complicated or you might
make maybe wouldn't be able to predict
it and that would affect the meaning of
your program so you was amazing with
laziness yes laziness is a key element
here if you don't have laziness you
don't have this problem but we had
laziness we knew that so that's just one
of the things there were a number of
things that came up that never survive
to see the light of day thank God while
you guys were talking that was kind of
implicit in what we were saying but to
me is incredibly important as a consumer
of the stuff you're producing and I
don't I be berry interested in 0 for all
three of you guys just how much you
think about this as you're doing it and
to what extent it's simply a byproduct
of all the other things you're thinking
and that is for me a programming
language is a way that i express myself
right at a very deep level because it's
actually it's a very personal thing
right now to some extent my success or
failure depends on my ability to
to communicate both to the machine but
also to other people through these
languages so I value the ability to
express myself in the languages that you
create to what extent then because you
kind of touch on that indirectly before
you went down the lazy rabbit hole to
what extent do you actually think about
that so what is sent to you think about
not just a purity because sometimes
expressiveness involves ambiguity right
expressiveness involves not being pure
but giving people a choice as to how
they say something because that choice
indicates what they're thinking about
that thing so what he said to you think
about that when you're creating a
language maybe it's joe returned for a
second okay can i yeah you think about
it a lot actually because it's you're
creating ways of the earth I don't think
programming own designs actually
philosophers because this is a practical
philosophy we are creating things that
the influence how people think and that
sort of philosopher does but I want to
go back to the real question and so
because their looks different to how
school and things in that sense and I
started work on that in 1985 at ericsson
and and our job there was to try and
make something that's fault tolerant and
to me the stuff should not just fail so
the first observation about that was you
can't do it on one computer you cannot
make a fault or listen to on computer
just because the entire computer might
crash so you need two computers at least
100 computers that and that means if one
computer can might crash you can't have
shared data structures and if you've got
two computers it means it is concurrent
and if you got to compute it is parallel
and if you've got to get to keep it if
you can't break the laws of physics
because I used to be a physicist right
so so so here's a starting point and
what about it is parallel and wait a man
with the world is parallel and the world
does consist of millions of things all
working away in power and Carl Hewitt
sort of coined this term physics
programming so I had this because I
wasn't physicist and I think don't break
the laws of physics
and then I see all these programming
languages which break the laws of
physics every day they they assume you
know two-phase commit doesn't mean to
say you've got the same data in two
different places it means you don't know
it's changed yet you know it is
absolutely absurd so so there are some
fundamental truths you don't know how it
is now you know how it was the last time
you told me that's not how it is now and
so I thought hang on let's make let's
make languages which accurately reflect
reality and then I thought well hang on
this is the fundamentals of his
messaging I mean I remember thinking I
loved email emails great you can send
email to anybody and I was thinking at
one stage I thought so why can't you
send email to everything so how would
you write a remember thinking I had to
write a room booking system Ericsson and
I thought wait a moment the obvious
answers you send email to the room and
it knows when it's booked you don't put
it in a database and that's not breaking
the laws of physics because there's not
going to be simultaneous information in
two places and unfortunately can't send
email to a room yeah but wait am I
internet of things you will send email
to a room and that's actually called
object-oriented programming we send
messages to things and and it's yet the
model workers the calculors came up with
and you're not breaking the laws of
physics and the world is parallel and
something we've made a programming
language that's a parallel concurrent
programming language and it's in this
funny thing because the world is
parallel programming parallel problems
to get everybody doing it in sequential
problems languages and then you get this
artificial difficulty because you have
chosen the wrong paradigm it becomes
artificially difficult and then we were
very acutely aware of the combining
forms you know in our case it was the
process and the link Dover those were
the combining form from which you could
build everything else and that took off
four or five years to get right and we
we try umpteen different ones and
through a malaika so they didn't combine
properly and and no so the third the
guiding think don't break the laws of
physics
and right parallel programs from the
start because the world is parallel so
it's not like the lazy evaluation or
math so you know it's that's how the
world is rays of light and sound sorry
oh and a doubt answer your question
didn't know we don't answer but now I
forgotten what it was so so so it seems
to me sir in neither the case of
erlanger Haskell dude wasn't necessarily
that someone sat down and said things
need to be immutable people said that
and said other things that implied
things had to be immutable is that a
fair thing to say in the ones if you're
in a setting where you have laziness and
mutation like things are going to be bad
but the driving force was late laziness
and early as well as today that's that's
not really true okay so Haskell Haskell
was designed to kind of unite the work
and lazy functional programming all of
which was with pure immutable languages
so that so that was a given from the
word go right right but the motivation
wasn't I think immutability is good but
it was I think laziness is interesting i
think the motivation was immutability is
good and blaze mrs. interesting
okay okay okay yeah yeah you didn't like
the answer well the geography answer you
didn't like the answer well sit in some
ways it feels like a lot of languages
made in the past couple years so just
look at laziness as a tool for
reliability right so in a lot of ways
all elva's are mutable it's because I
experience what it's like to program
that way it's really nice and i don't
know i would have liked the story to
have been that by thinking about effects
and like interleaving of effects you're
sort of put on this road in a way that
maybe wasn't really the message the
intent it was this question of how do
you start interleaving things and that
sort of necessarily puts you in a place
where your data is immutable but yes
that's wrong so I think of course in a
sense you're right if you have lazy
evaluation and you have mutation going
on you also have a bad less then good
well you're screwed basically yeah
you're not going to be able to predict
where mutation happens so that you are
forced to be pure if you have a lazy
programming language but of course it
might have been tempting I suppose
because hey everybody needs mutation now
and that so it might have been tempting
just to snuck it into high school as it
snuck into ml did it sneak in did sneak
into em out there is mutation and I well
I don't know what the timeline was
though my understanding was that that
was sort of a core pieces yeah okay so
references and a mutation word ml from
the start but they're there you can't
you can't tell from the type 4 ml
function whether it has side effects or
not it might have been tempting to put
to have treated it in the same way it
Haskell except that lazy evaluation
would made that nuts right
just one sec let's bring this a little
bit so I'm gonna test I'd like that
state so dates on the panel because he's
basically seeing two languages explode
before they were going to explode my are
you that that the second one exploded
because they started writing about he'd
never mind that I absolutely think it's
true but I have a question for you Dave
what did you see really early on that
tipped you off that these languages were
special so with Ruby all that was
special is I liked it honestly and out
of all of the languages I had been using
up until that point it had the right
combination of it may be happy you know
had the right combination of features it
wasn't overly strict it wasn't overly
sloppy it just kind of like it was
comfortable you know and to be honest it
was it was something where I really
really loved it but also didn't trust it
it felt too slow a tilting 2 lakhs at
times and it took me a year or two to
get comfortable with the second of those
years was spent writing the book so I
got very comfortable with it but I
wouldn't have done that had I not got
some degree of yes this is good this is
right the edge of a story though is kind
of like not quite as not quite as ideal
as that because it started out because
Andy neighbor came across so i came
across Rudy and I really loved it we
wanted to write a book on active
specification which nowadays would have
been caught with a spec or something but
and we need a language let us express
requirements if you like in a language
and the meta programming in Ruby would
let us do that so we started right in
that book and we discover writing more
about Ruby than we were about what we
wanted to write about and so we kind of
like gave in to the inevitable and just
around a robbery and that's how came out
elixir was different I've been looking
for a language for many years maybe 10
years that would allow me to talk about
transformative programming right and I
going to be very careful what I say not
that far away from people that I might
offend by mistake I found it difficult
to I liked Haskell but I didn't feel I
could use it as a basis to explain to
the average working program and that was
a failure on my part and I didn't know
really how to express my the ideas in a
kind of clear enough way to make to
popularize it with a lick sir I came
across something that had many of the
features that I wanted not all but many
of the features i wanted wrapped on top
of a fantastic virtual machine which
meant actually have some benefit it
wasn't just an academic language it was
actually a language where I could sit
there and switch whatever 2 million
requests a second or something so it had
a lot of benefits and the closer that I
just I just felt this was right you know
this would actually but we did at the
same time it's pretty clear to everybody
that the world is becoming functional
that you know the the old ways were not
they're not working right i mean moore's
law has not stopped its change and we're
no longer just throwing mips at
something and so we have to find
different ways of making these these
things work and so it just it just a
sweet spot just a perfect storm of all
these different things which is
attractively added to which I mean the
community should all community shows a
and now everybody else it's just so nice
to work with you know that that matter
pleasure so Joe we've talked a lot about
the functional languages earlene was one
of the early commercially successful
functional languages but it didn't take
the approach that everyone else did took
an approach that was much more
concurrent you know based on based on
the beam that had the
error the error channels baked in from
from the ground up so why do you think
that people are so passionate about the
Erlang language of the program's just
work and it's because they're not
breaking the laws of physics and also
figure what he said to me one day said
you know it's a funny thing about air
like why didn't we just rightly said
they just work remember and then he then
he asked me why and I thought it's to do
with concurrency and modeling thing so
so in the first airline but I came up
with they're still my favorite example
of a lift control system and in the book
there are three lifts television what
about those three elevators and ten
floors and I want to describe an
algorithm that schedules a lift and I
thought so how do you do this so you say
each assume each lift doesn't know
elevator doesn't know about the other
ones I'll do the sign language of the
site okay right you do this on it I'll
just call them lit k okay with me
calling them lifts yeah good right so so
so just assume each lift has a stop list
so it knows where it's going to go it
knows if it's going up or down because
it's not going to suddenly change
direction and it's gotta stop list and
each floor is a process you know and so
when you press the up button you send a
messy you send a message to each lift to
all three of them and you say how if how
long is it going to take you to get to
me with your stop list and they compute
that and they send the answer back and
then you choose the minimum and say
reserved that one and you send if you'd
attempt to temporary know how long's it
going to take and the next message you
send back is you send to one of them
stop on my floor into the other two you
send you know forget it right now if
you'd think if you model that you would
say how many processes do you need the
answer is 13 three lifts and 10 floors
right it's
cannot be any other number it must be
that and the algorithm is completely
trivial and really easy to explain to
anybody and really easy to understand
and I never saw that in object modeling
you know I never saw these if there are
cars and bikes our class of wheeled
objects and goodness gracious you know
is it and I've never seen but physical
modeling when you observe the universe
and you're right now I mean if we were
modeling this panel where there are five
concurrent processes in it if we're
modeling you there are as many processes
are as there are people and we have no
trouble understanding this with all we
don't have we don't have a common memory
we don't have a shared memory we each
got an individual memory and we send
messages and we might not listen then we
might miss them so just if you program
it just like that it just works because
that's how the universe works yes and if
you program in any other way you will
get artificial difficulties and if you
program it in a sequential language you
will run into problems and if you
program it nodejs your brain will melt
banana calculus so the question is what
do people love about Haskell right yes
so I think there are four things one
thing is the notation people often say
hassle is a very beautiful language yeah
it's very concise very elegant and
powerful something else that I think
people love is purity when you stage a
law in Haskell it's true when you stayed
a law in air languor ml you often have
to mumble into your beard a little bit
you know it's true hard a bitch provided
there are no side effects
but when you say the law in Haskell it's
true no ifs no buts provided you don't
use on tape before but that mumble is a
much less important one more oh so
people really like the purity I think
because it gives you a much more
confidence and using those laws and
reasoning about your coat something else
that people really love is the type
system so people often say you know
what's it type checks it just works
there are even t-shirts you can get them
say that say it type checks ship it
which is maybe a little extreme and you
can see this because the type system has
been extended further and further and
further to make it more and more
possible to capture what your code is
really supposed to do in the types Simon
Peyton Jones says adding things to the
type system is like throwing red meat
two hyenas people just pounced on those
stuff that and they really want to use
it so that's something that people love
and I think finally one thing that I
would think people love is using quick
check for testing the Haskell quick cook
is very powerful if you look on the
packages on package it's by far the
dominant testing tool there is an H unit
library but it's used about half as much
as quick check is so that that's
something that has really been adopted
very strongly in a school community oh
it's amazing so Evan when when when I
wrote about Elm in in the 71 languages
that's the language that people kind of
light up when they see in the book and
so in a very short time you've got this
following of fanatics and
those that comedian language what is it
about all so so I think if the root is
this like you feel good when you write a
program and I think that's sort of the
connecting thing that by sort of
independent of the particular details
there are things like make you feel good
about what's going on and so essentially
a lot of things that are nice but I'm
are are what John said but but i would
say them different right and i think one
of the crucial did you do that's
important and why people really get into
elm is because I say slightly different
so a lot of the emphasis is sort of
recognizing that you know over the past
I don't know how many decades we've
developed a way of writing programs
whether that's in Haskell or a no camel
or standard developer or allegorical or
sort of the precursors to those things
now it's really Pleasant and so what Elm
is about is is finding that essence and
like not trying to be too creative
outside of that right like what was the
core part that made it really really
special and then just saying no to
basically everything else so the longer
i work on elm sort of the more i filled
it like just the basic feature is
algebraic data types just like the
ability to think about and model baby in
a nice way and I think really sort of
emphasizing those because I think we
forget how great like how crucial that
is you know there's so many other pieces
that are amazing and pleasant and nice
that we forget that we can like ninety
percent of programmers will have their
minds blown by using algebraic data
types and I think
at least what I've been trying to do
without this sort of get the joy that I
felt learning languages like Haskell and
make it so people aren't afraid to go
down that route you know as if the it's
dangerous there's like what's going to
happen I don't know but yeah so yeah
guys let's give these doesn't this has
been amazing</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>