<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory 2014 -- Thursday Keynote -- What Programming is Really About | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory 2014 -- Thursday Keynote -- What Programming is Really About - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Erlang Factory 2014 -- Thursday Keynote -- What Programming is Really About</b></h2><h5 class="post__date">2014-03-06</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/tmRdy9rRV3w" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so anyway I was saying I came to
California I've had a few days vacation
and I'm here I hope this is going to be
the most enjoyable part of my visit to
California this time now when Francesca
asked me had to hold the presentation I
immediately said yes as I said then the
next thing I still thought I wonder what
he wants me to talk about and the next
thing I asked Francesca what you want to
me what you want me to talk about and he
said well find something interesting to
say now the problem is as I said that
I've been working in management for 25
years and as you know the first thing
that happens when you're going to
management is they amputate half your
brain so that was a bit of a problem and
then I actually haven't actually done
that much programming during the time
I've been keeping my hand in
I wrote a tutorial of about air lying
but I haven't actually doing any logical
programming so I thought what can I talk
about and I thought well I know what
I'll talk about how talk about the
esoterics of how you design mobile
cellular radio base stations and I
thought maybe not no I don't even want
to hear about that and then I said well
just having retired maybe I should be a
bit philosophical and talk a bit about
history and I thought well I'll tell
them all about paper tape and punch
cards and that sort of thing I thought
no they don't hear about that either so
I felt like oh oh what do I know about I
said well actually what the lot I do
know about is how you manage software
projects and how not to manage
self-reproach because they've had some
successes and I've also had some
disastrous failures so I thought I'd
tell you a bit about that in my view
about how that well I spent 20 years
working as a programmer both in the
computer science lab when we invented
airline and prior to that they just
worked a norm programmer I actually
started programming the first time in
1967 which I regret to say is probably
before most of you were born but 20
years programming and I used to wonder
when these people these managers that
hang around here they don't seem to
understand what we're doing they're
completely nuts through there there's no
idea and I wonder why they don't
understand
so I decided the only way to discover
why programmers that don't manage that
don't understand programmers has become
a manager so we did
so I spent 20 years working with manager
and I wondered why programmers didn't
understand managers good either there
are several reasons for that and that's
basically what I'm going to try and talk
about today I'll try and make it be
there long at the end but as they work
with all sorts of things from assembly
language to C++ to Java to even horrible
things like UML don't do that but they
work without sort of thing I thought I'd
try to be a broader perspective and sort
of zoom in a bit on air like towards the
end of my talk so what's programming
about and why is managing a program
programming projects so difficult I mean
it should it should be just like some
building a house or or construction
industry or whatever I mean what makes
programming so difficult and why are so
many programming projects totally
unpredictable in the sense that they
never get very seldom under run they
said it very seldom used less than their
budget we very frequently use 10 times
more than their initial budget what's
gone wrong why can't we predict what
goes wrong why are things late and the
reason books are I bought a book not
long ago I'll go to disastrous
programming failures there are more
books I think about programming failures
than there are about programming
successes so let's start with I've shown
some of these slides before so some of
you may recognize them but I great
believer in reuse so I've done barely
begin that there are three fundamentally
different types of programming project
when you're doing something the first
time that's how you're building
something new I'll get back to a bit
more about that and that is a really
that's what everyone wants to do that's
what all good programmers want to do
they want to do something new and then
unfortunately if they want to earn any
money they have to go to stage two and
make a product
they you don't sort of make much money
from wild ideas hello robert
yeah then when you actually got a
product if you want to continue making
money you actually have to maintain it
and these products these are these types
of of a project are fundamentally
different from each other and this is
the first reason that managers get
things wrong they don't understand that
there are three different types of
projects they tried to make a product in
the same way as you would do a sort of
you try to develop something the first
time in the same way as you would
actually try and make a product getting
onto that and what are they well the
first type of project developing suing
the first time this is bold wild
experiments testing our implementation
testing architecture throwing away code
you know something that managers hate
the programmer says oh I didn't get that
right I'll throw it away do it again
well doesn't it work why didn't you get
it right the intent there's a blame game
for trying to get there for people who
want to throw away code people don't
like that at all a money just don't like
that told programmers like it was you
have to get things right now you're
making a product well when you make your
product you hopefully you've got a sort
of fairly good idea about what you're
doing and you're filling out a testing
architecture implement and you know the
hopefully you've got a good idea of the
about implementations or sometimes you
have to go from making a product to the
first type of project backwards and
forwards a few times and this is
difficult because maybe you started the
first stage with five or six people
doing something together and then you
start making a product and you scale up
to 50 60 maybe maybe as some projects
I've been involved in 600 people and
then you said gosh we've got that wrong
and you can't actually go from a 600
people back to the five or six people
very easily that's telling 595 people to
sit around what
twisting their thumbs for a few months
for each area where carrot again is not
generally popular then you actually get
to the other stage for maintaining a
product now this is a people who
maintain products are a very special
sort of programmer because they're the
sort of programmers that really enjoy
finding bugs most programmers hate
finding bugs but enjoy finding bugs
messing around with things trying to get
things correcting things it's a very
special skill and I think it's a very
underestimated skill that some of the
best programmers are actually maintained
errs but that's something which is not
generally recognized and unfortunately a
lot of good programmers they want to do
the first thing we want to develop
things for the first time so it's it's
difficult to get good people to do
maintenance but it's very necessary ok
difficulty well what's it about well
there's a little sort of her for boxes
you suppose you know how to do it and
you know what's wanted well that's easy
it's easy to run that sort of project
there's no problem at all but on the
other hand if you if you know how to do
it and you know what's wanted that means
someone's done it before so why the heck
you doing it at all download it from
somewhere or steal it from somewhere or
whatever you're going to do but you
shouldn't really need to be doing that
sort of project and then you have the
type that you know what's wanted but you
had don't how to do it well that's
difficult that's sometimes so you need a
good example for that of that is when
you have a nice system which is running
on a non multi-core system and you want
to make it run to a run on the
multi-core system of course that's
trivial in airline but on the other hand
try and do that and C++ well you're in
deep trouble if you try there you really
have to work out how to do things again
from the start you haven't got
concurrency in your system and you're
trying to put concurrency into the
system that's difficult sometimes you
don't know what's what
and there's always a people who think
that they can make nice beautiful
specifications and get it right but it
doesn't work that way sometimes you
actually have to start programming to
work out what's wanted and then of
course you've got the state ok switch it
happens very frequently that you neither
know what the customer wants or what
you're trying to do or you know how to
do it that's very difficult and a lot of
projects come into that sphere but don't
think that you shouldn't be doing them
because that's the sphere probably where
you can make most money working out what
to do and working out how to do it I
think that is where a lot of the real
innovation comes in so don't knock that
idea then predictability that well again
that a if you know what's wanted and you
know how to do it then it's fairly easy
fairly predictable how to do it and you
don't really have to think about that
and as I say hopefully you can download
what you want from the net anyway
because someone's done it before you
know what to do
and but you don't know how to do it well
that's not too bad it's fairly
predictable because hey you do have to
do a lot of experimentation but you can
work out roughly what to do and then you
get the state of affairs that you know
what how to do it but not what's wanted
now that's very unpredictable because by
the time you start doing things you're
going to find you're doing thing you're
not doing what the customer wants you're
doing something different different and
you have to go backwards and forwards
and then of course you get the final
lead you don't know what you're doing
and you don't know how to do it that is
highly unpredictable and it can take you
years and years and years of work or you
might do it quickly you have no idea
what's going on but there again that is
a very important area now I go back to
management the difficulty is that said
if you look at these two matrices I
don't think most managers in the
software industry actually understand
these matrices they always think that
you're actually in square one you know
how to do it and you know what's wanted
oh we've written the spec
they said oh yeah you've got a
programming language go ahead and do it
it's not easy but a lot of money just
think it's that way and that is one of
the major reasons for the programming
disasters we have today and things that
don't work that people haven't realized
what sort of project they're doing what
sort of team they need or although they
don't they can't predict it
well how what it's all about it's all
about well there's the fundamental this
is where I start trying to get
philosophical the I'm getting older and
I retired about two years ago and I do
you get the more philosophical you get
so I saw what's programming about well
program is about trial and error and if
you don't believe that let's just think
about the most trivial thing you do when
you write a program you put it through
your compiler and let the compiler spit
out the syntax errors you don't actually
spend half an hour looking at your code
to sort of a to get rid of the errors
you put in the compiler and that's trial
and error you put you correct the syntax
errors and off you go and then when you
start running it it crashes and you just
find out where the crashes that's what
programming is about try that error and
if you don't know what's wanted trial
and error is the only way of finding out
just try it out is this right show at
the customer if you don't have to do
things trial and error again again win
it often knowing how to do things is a
question of optimization making your
software run fast enough and again the
only way to get things to run fast
enough is to have theories about how
things work to make measurements find
out where your bottlenecks are and go
ahead go ahead and do things
experimentation
now trial and error is unpredictable and
there again we have a question why
managers don't like it the if you sort
of said go go and tell your manager I
don't know because I haven't tried it
out yet they said the manager somehow
thinks well you should know and at the
same time you go to managers who said
well tell me how long this is going to
take
I don't know I haven't tried yet and is
there nothing a programmer really hates
is being trying to predict the
unpredictable and that's one of the
basic reasons that programmers don't
understand managers and managers don't
understand programmers well this is a
sort of waterfall model which we've all
seen it we also done done and this is
the way some people think that things
work and a lot of managers who have
probably written a few sort of lines of
C or Java at school and then have never
done anything else think this is the way
it should be because when you do things
by yourself in a one-person project it's
very very different from multi program
person project and a lot of managers
still think you should be able to run
the project by the sort of waterfall
method
I'd have thought that one thing which
has come in nowadays which is helping
this sort of idea is the idea of agile
programming things like scrum that when
I first heard the scrum I thought the
idea of putting a lot of yellow sticky
labels on a whiteboard and trying to
work things out from that sounded crazy
but then they actually looked at it in
prior practice and it is actually a very
good idea and I think that scrum is
really an agile programming is really a
way that programmers are finally getting
their revenge on stupid managers that so
I hope the term predictability well I
know no really good model to be able to
predict things I don't these good model
to predict things if you're enhancing a
existing product then you know roughly
what's going on let them I can give an
example there when we first started
making radio base stations we had a
small team of people doing things and we
didn't really know what was happening
but nevertheless we knew that especially
when we were doing the 3G systems we
knew had to get things out there fast
and it was a typical sort of normal mess
at the start which was right it should
have been a mess
lots of people working lots of people
doing things in parallel until we sort
of finally fleshed out what needed to be
done then the latest stage when we've
got a 3G system working we had a team of
I think that I think about 600 people
working with the software of radio base
stations and people don't really realize
often how many people work in the in the
mobile telephony and the cellular
telephony program you probably one of
the largest programming projects in the
world well all those 600 people we could
actually when we'd actually got the
framework we could predict things fairly
well it was only when we were trying to
do something completely new that we
finally found that the things were going
wrong the first generation of of 3G
could manage fairly slow data speeds and
then we introduced packet data and that
really revolutionized things and that
caused a major hiccup but when you're
actually doing things like sort of
changing things like well very simple
bits of software about how you tilt an
antenna on the top of a radio tower
that's easy to predict you worked that
out fairly well because you know roughly
what's going to be done it's been done
before there again a lot of managers
don't see the difference between new
development and enhancement to projects
but one of the most disastrous projects
that I was involved with which spent an
awful lot of money you're not Robert
about that he knows about that - yeah
they the first generation of telephony
made by Ericsson was made successfully
by a small team of people which was
scaled up to about a couple of thousand
people when it was a when it was a at
its height the people who are says after
bit said we need a new system we need to
make things a bit better so the way they
did this was they started off by plying
but by employing about a thousand people
to do the system and that was a complete
mess because you cannot start a new
system with that number of people
I think it probably is one of the majors
most major programming disasters in
Erickson's history I can talk about
these things now as I'm no longer
employed Berry says they can't fire me
but I'm not going to talk about India in
detail but say it was incredible it was
we sat at that time developing airline
the computer science I was scratching
our heads and said well are these guys
doing about in fact they've produced
more word the documents though I think
is probably Frey making the use of the
time there's more documents on paper
than they actually produced lines of
code which did anything useful it was
amazing there are thank goodness a lot
of sensible managers like me of course
but I have to demolish mother modest
occasionally there are unfortunately a
lot of managers who have very funny
strange prejudices and a lot of managers
who have drifted into management of
software that know nothing about it that
and these are some of the observations
I've had over the years about
programmers that Tim and their art and
managers and the attitudes managers that
one of them is that bugs are evil the
sign of lazy sloppy programmers the
people who were
right code with bugs in it should be
punished there are people that really
seriously think that I think they sort
of don't realize that maybe the program
mother was doing this bit it's got a
hard bit of code these doing the
difficult bit and that maybe it's quite
reasonable to think that there are more
bugs when you do the difficult bit than
the easy bit another one and this is
I've heard very frequently is that
programming is a very small part of
software development software technology
and programming languages are irrelevant
we've heard that said lots and lots of
times all right coding is only 5% of the
time we do the code doesn't matter what
language we use well my answer to that
is very simple well if that's the case
let's all go back to using assembly
language programming it'll make life
easier for everybody we won't have to
have compilers and things like that but
a programming language and programming
technology is fundamental to getting
things right and I think that is one of
the fundamental things about airline
when we actually worked with there and
we knew what application we were trying
to make do it we knew that we needed
distribution we knew and you needed
concurrency we knew we needed a fault
tolerance we need wanted things to be as
concise as possible so we were very
fortunate and we've actually be very
lucky because the application area that
we had way back for nearly 20 years ago
now the application area we had then
actually matches very well to the
current a modern multi-core and
applications that people do today so we
were yeah I think that airline got it
right was more luck than judgments we
actually happen to be working on the
right thing and I was I can't say we I
don't say we cut any credit for
predicting the future but the future may
be predicted us instead so quality is
now obtained by testing don't
that programmers spent too long time
coding I've seen that before we have a
cell
code stop as this time if you haven't
finished by then you'll deliver whatever
happens we will test it and test it and
test it and until it works that happens
all the time and they it's also a
disaster because he if you've got a
badly designed system to start with
you've got badly designed code no matter
testing he's going to make the bad the
bad design go away you have to get it
right to start with and if you haven't
got it right you have to redo it testing
is very important don't not testing but
don't think that you can actually tell
programmers oh it's about time you give
up now and start testing your stuff make
it work another thing that I found at
one stage and this was another disaster
from Ericsson at one stage they found
that a lot of programmers were leaving
all the time going somewhere else
well it was quite naturally going
similar they got better paid somewhere
else but that was a sort of philosophy
the management didn't understand so they
got the idea well let's employ a lot of
mediocre programmers now we're going
back now 20 years so I can say this sort
of thing and
I can save quite frankly that
management's in the Ericsson it's a lot
lot better nowadays they've got to get
things right but twenty years ago the
idea was let's employ mediocre
programmers programming is a very
unintelligent job you don't have to
worry about that and if we imply
mediocre programmers they won't leave
well if you employer if you employ
mediocre program as you get mediocre
systems and that was actually thank
goodness a very short phase in Aris in
their history but caused a lot of
turbulence later in their action this is
the problem is how do we get rid of all
the media two programmers yeah another
one yeah we also had have armies of
systems people and systems people oh
okay they don't have to sort of an
understand safe their technology they
just low log bubbles with errors going
between the bubbles on
I remember one systems person divining
something incredibly object-oriented and
his object actually had to be suddenly
realized it had to be divided into two
programs on why each and one pair what
one processor that suddenly dividing
something and producing concurrency
without realizing you have concurrency
can be a major problem and I did the
product the assistance person didn't
realize that this is why again I think
that something like scrum when you
actually mix together the systems people
the testers and the egg and the people
writing error code into one group and
hopefully into the same person the same
people that's why it is so very
important and it's the only way to go
for the future a lot more stupidity I
could go on for four hours now if I
maybe later and I'll tell you more about
it
well oversimplified the idea about how
it works this is very much
oversimplified that you notice this is
not really waterfall because all the
boxes sort of a go into each other first
thing you do is specify as much as you
can and you can't specify everything and
then you find out more detail as you
design there's nothing wrong with
starting programming on day one before
used to before you've before you've
actually specified anything there's
nothing wrong with that at all as long
as you realize you're probably going to
have to throw away what you've actually
done it's a good way of finding out what
needs to be done in a lot of cases well
as you go down the ladder you and you do
more program you find out more and more
you progressively adding more and more
to your specification no specification
is perfect in the beginning and no
specification has got all the details
and at the end of the day you hopefully
get feedback from the customer telling
you if this is what you wanted or not
but there again you shouldn't leave that
to the end of the day so why is this
oversimplified well you need
experimental programming to work out how
to do difficult bits and quite honestly
the best thing to do if you've got a
difficult program is to fight it guess
what are the difficult bits what are the
algorithms that are very hard and these
are what you should be working on to
start
because if you can't work out those
right you can't say Oh what size we will
do the easy bits first and then the
difficult bits later because you might
find you can't do the difficult bits and
you have to change change things around
so programming early but you have to
prepare prepare to scrap that what
you're doing on the other hand you also
sometimes need to start programming and
produce something very rapidly to show
the people that are paying you you're
actually doing something which they want
and some sitting down specify for days
and days and days and then sort of
finding out that's what you want is the
ease out so there again it's sometimes
essential to program at the beginning
produce a system produce a prototype and
then the important thing is throw away
the prototype and do it properly
the number of times I've seen prototypes
turned into products and not very good
products is it's considerable testing
people not testing people forget about
testing and they sort of find that you
have to work out from the very beginning
how am I going to test my system because
I don't know how I'm going to test it at
the beginning then it's going to be very
difficult to work it out later so
testing is very very important we've got
that long wrong a lot of times we found
that if you get that wrong you can
define user planning yourself a lot of
time testing and you're going to find a
lot of bugs that you don't find user
interfaces you have to do that by
prototyping there's no other way that to
make a user interface show it to the
customers say is that what you want does
it work is it usable test test it and
they can get it right we look at sort of
a I think the people that sort of
originally designed a Emacs probably
didn't know about user interfaces on the
other hand that what emails once you
actually learned them they obviously
wonderful I hate this modern version of
Enochs it's got also the poles to push
down menus and all the rest of it I mean
why can't you just not normal keystrokes
like the sensible people but but that'll
but I'm old
let's forget that rework rework rework
you have to be prepared to rewrite your
programs and you have to make sure that
you you go on doing so until you're
happy with it okay so you got Rob but
you can rework things for
but this is a dream that some people
have had I've seen people actually give
lectures about this if I call this the
specification dream that you make a
complete specification you do an
automatic code generation and then you
deliver it to the customer and
everything works in every Oh everyone's
happy there are people that really
believe this and it's very strange I
won't quote names I have some people
that I know very well that have this
idea
the main reason this doesn't work is you
cannot define things in detail you
cannot write a complete specification in
the beginning and if you could write a
complete specification it would be the
program you wouldn't need to and that's
the way the whole process did this is a
fundamental thing which people believe
and it's fundamentally wrong and it
always will be wrong and it never will
be right the idea of formal
specifications the idea of generative
code of specifications is fundamentally
wrong because that's not the way people
we work and then we have the modeling
dream oh I hate the modeling dream that
I had I had about 60 people working for
me at one stage that sort of made that
made models in UML and they sort of a
made all these boxes and funny symbols
with arrows and things going in between
them and they saw the program the
program program and they forgot the
little detail in the boxes some of the
boxes you actually have to write some
code because UML is basically flawed
because I you cannot have something
which is two different paradigms we are
writing C++ code or Java code in boxes
and a completely different semantics and
syntax for the UML it's completely
horrible
you can't generate a complete system
from a modeling language if you could
divide if you could it wouldn't be a
modeling language it'd be a programming
language and
if you're going to use modeling the
question you have to ask is is the
modeling language easier to work with in
the programming language and my
experience is that it usually isn't it's
usually harder to work out what the
modeling language is supposed to do that
it is for example starting writing the
airline code to start with and in that
case why are you why are we bothering
while we're doing that the other problem
with modeling is that you have to go
backwards at the end of the day when you
have a system which is again nearing
completion you're going to make changes
in your code and unless you can actually
go backwards and make corresponding
changes into your model automatically
then the model is going to become
out-of-date and totally useless a
high-level model can be good some form
of model other or boxes and things to
explain to people how things work it can
be a very good idea so high level models
don't lock them but remember it has to
be a high level model and remember
you're not going to generate anything
from it because that's a bad idea
the other important thing it remember is
that people who make the model should be
the same people as the people who are
actually doing the programming you
shouldn't actually try and have modelers
and programmers in separate groups I
tried that teams how do you make a team
well going back to my original picture
again that developing something for the
first time small team excellent domain
knowledge excellent software knowledge
doing again several small teams software
technology ability is the most important
part of the of that stage get these
teams right make sure you're right and
again as I said earlier if you start
with number team number one go to team
number two and then find you've got it
wrong and have to go back to team number
one
then you're in deep that
maintaining a product small team again
and then you need these special people
with funny minds to get it working
starting with the wrong team is disaster
adding more people doesn't make a
project or later it would go faster a
bit about programmers again that's what
I really hate when I look at when I look
at the paper is to see the fact that
people actually put advertisements in
the papers saying oh I want a Java
programmer I want a programmer than
those this technology I know that
technology or something like that and
that is fundamentally wrong a programmer
is a programmer a programmer who can't
learn they're lying in two weeks don't
employ them because you can learn early
in two weeks it's easy
okay the syntax sucks but but Alex here
maybe will do something about that let's
hope so yeah but syntax isn't everything
right I think Robert went out the
ability of programmers is hugely
different
at one stage that's how I was involved
with the HR department you know HR
stands for human resources I came to the
conclusion that the HR department was
neither human nor were they resources
that the I was involved with them to try
and devise a test to
get a programmers to impart what we
should use to get good programmers and
we employed some psychologists and all
sorts of people and that they tried to
say what does the character is a good
programmer what's that we actually have
to ask them what's the question you have
to ask interviews and the only
conclusion that these a group of
psychologists came to was the
programmers are usually a sort of
the most common characteristic of or at
all is there usually bascially minded
and bloody minded individuals who want
to do what they want themselves that was
the only thing they could do the most
program is good progress individualís
some program is good at doing things
some programs are not a fundamental fact
and it always surprises me this is the
majority of people in this world today
aren't programmers and never will become
programmers and cannot program its it
requires a special mindset to become a
good programmer and you have to realize
that most people can't do that it's just
like advanced mathematics so playing
good chess the most people can't become
a sort of excellent chess player most
people cannot become a sort of an
advanced particle physicist and all the
mathematics involved icons but most
people cannot become programmers and you
have to remember that so if you're
sitting here and I'll show you're all
good programmers feel immensely proud of
yourselves so you've actually managed
here so write one line of code and get
hello world to work employ good
programmers okay err Lang is easy a boot
programmer can learn there long in its
environment a couple of weeks I think
that's one of the best things about our
lying is in trying to be simple language
that people don't realize that it takes
you months to understand how or how what
what ampersand c++ actually means that a
in see the programming so probably
probably program more c than they're
programmed airline but every time i go
back to airline I sort of say sort of
think I'll thank God for that I mean
every time I try to work out what
pointers do in C it requires a sort of
mental
revision which takes about five minutes
before I get a little C programming mode
again but I find that in some program
and I'm fairly fluently usually
understanding the application domain is
actually harder than understanding the
programming language that is the
difficult bit the real difficult bit
about programming is finding out what
you're supposed to do and how it works
and that's really if you want to employ
Pro people who know about various things
don't put advertisements saying they
want they want to know I can tell them
they what you want to use airline in the
advertisement but that's quite important
but you make sure they actually know
that the main that you're working in
that's actually most important and if
you actually want to test for someone
writing a to employment program just ask
him to show some code that they've
written themselves and ask them to
explain it that's the best tester for
employing programmers if they can't
explain their own code then they're in
trouble
maintenance I said this there again many
programmers prefer to do it do new
things the software maintenance isn't
cool but it's very very important so if
you're employing a programmer that use
your junior programmers for maintenance
it's a good way to introduce them but
make sure that you have experienced
programmers watching over the junior
programmer so they don't mess up the
system that you're a you're going they
get they get it right don't let them
change things on their own account and
make sure you the review what you're
doing or else they'll mess up the system
for you and there again if you're going
to be able to maintain your code you
must insist that it's properly
documented and commented programmers
that don't do that don't employ them
however good they are whoever they can't
explain their own color their own code
they can't document their own code don't
employ them because you're gonna land up
with a mess if you have them around very
strange though that people don't realize
that actually writing comments and
explaining your code is about five six
percent of the job and it's easy to do
so don't employ non documenting program
babies are natural parts of programming
you should be happy when you find the
bug you should say hooray I found a bug
this is great fun and wonder how that
happened if there a lot of bugs in one
part of the system don't start blaming
the programmers find out why maybe
you've got a bad program on that part of
the system maybe that's a very very hard
part of the system that find out why and
look into it don't start by sort of
blaming the programmer now why does that
like help why why say I'm good for all
this because I've been talking a lot
about some programming have been talking
about about airline
well that's because software is
programming is an iterative program
process it's a iterated iterative
process is a better way than the saying
trial and error because it is a name for
intelligent trial and error
Elleni actually suits an iterative
development process very well it's a
shorts expressive code you don't need to
change a lot for each iteration dynamic
typing is actually very good a lot of
people would say that we don't like that
but it certainly makes life easier for
you without having to write a huge
amount of type declarations when you
change things changing code in running
systems that actually we did put that in
because we thought that was needed
because we were making telephony systems
and telephony systems can't go down but
in point of fact if there's other
applications you don't really think
about the changing code and running
systems means that if you're testing and
you find a bug you can correct that bug
and put it right without having to roll
things you don't have huge
build times it means that you have a
very much faster turnaround time between
your find the bug correct it and do it
again
simple concurrency and distribution
there again we did that because our
application needed them at the time that
we needed them and that's come in today
that I think one of the most best
compliments that we've actually had for
our line with Scala which they use the
airline's distribution ok the lot of
other things which they don't like about
scarlet but both the scarless
communication mechanism copies air long
and I like that I think that copying is
probably the sort of best form of
recognition there are a lot of good
tools nowadays when we first started
there weren't but there are nowadays and
the let it crash philosophy has
separating failure failure recovery code
from application code makes life a lot
easier now that I just made this last
line this morning was I thought that's
better talk a bit about my experience of
the Erlang decoder let's see when you
start people on there and you start a
new project the first thing they said is
why are we not using C++ Java or
something like that and they don't
really realize that so the reason we're
doing that is big simply because we have
a better paradigm and people don't like
change there's also resistance to change
people believe that functional
programming is difficult that if you've
been brought up with a iteration and you
actually have to go into a recursion it
requires a mind shift but it's not a
difficult mind shift
syntax is weird we know that but if
you're prologue programmer you're all
right if you're not a prologue program
your problems that what happens after
that in the first stage where we were
moving which started projet the first
thing happened is some people run away
mister say don't like this do something
else well I say if they run away and
they don't like you wave bye-bye thank
you your paycheck is in the corner go I
get out
some people try to program and the
majority of pre-program is do it well
there's some people that still try to
program C++ an airline that's a bad idea
that I had a group of people once upon a
time actually weren't I wasn't managing
them that changed airline to be
object-oriented and changed the error
handler to be able to or have some form
inheritance in the system that was an
awful mess but then the majority of
people and maybe a goodly number of them
actually enjoy it and they find that
airline is easy and fun to work with and
see that time and time again that when I
visit old friends working verax and a
lot of people that were using doing
something else maybe they're doing DSP
programming or maybe they're doing
something as herring isn't suitable for
come before they come to me and they say
oh we did enjoy that airline project I'm
looking for a new one a lot of people
really when they actually start
embracing our like really liked it and
want to go on using it programming what
why how this summer programming
iterative process a large amount of
trial error to find out what needs to be
implemented why does it need to be
implemented how should it be implemented
and I found the airline is actually very
suitable for this sort of iterative
development especially in when you have
concurrency and distribution I'm
struggling for the normal time when I
retired I decided I take a bell on
programming again they to a large extent
and I decided the one thing you had to
do is organize all my digital
photographs thousands and thousands of
them and instead of using Picasa or
something which exists already I said I
have write that myself I've gone gone
quite well I just go man easy was a bit
strange I had not used mini-z as much
before but I worked out but I've gone
onto the graphic programming I find this
if anyone really would like to do me a
good service they can write little
manual about how you actually use W
Eric's widgets you know like because I
can't figure it out airlines fun if you
don't think our langston why are using
it
and if the people you're working with
don't think that airlines fun you're
working with the wrong people
so airlines fun enjoy yourselves and
have a nice conference</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>