<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Where are we on the Map? - Kenneth Lundin | Coder Coacher - Coaching Coders</title><meta content="Where are we on the Map? - Kenneth Lundin - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Where are we on the Map? - Kenneth Lundin</b></h2><h5 class="post__date">2013-04-26</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/nyPYQ7LaEWA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">yes welcome I will tell you where we are
on this matter right now in the Ericsson
OTP team I can say we are working on it
right now and i will present our current
ideas about this so we can start with
why introduce these maps of course they
are have been proven useful in other
languages Swamp Thing in a line I think
we can give an extra edge where we
combine them with pattern matching we
want an alternative to record to dick
skeet Reese prop lists and it can be a
compliment to record in some places or
even replace records so when we approach
this week thing from two different
directions you can come from here you
think you can have any term as a key you
can have many keys meaning that yes many
keys in the same map few instances with
exactly the same keys and if I am today
you can use dick dimitris prop lists for
that the other approach is here we come
from from the record and you have the
frames suggestions from Richard O'Keefe
which we are heavily inspired from in
this direction that you usually have
only have atoms as keys have few keys
usually less than 32 or at least less
than 64
you're many instances which could share
exactly the same set of keys and we try
to map this too common syntax and
semantics that's the ID so the girls
done is that we should find set
providers at the mappings between keys
and values so it can easily be
constructed and manipulated and exists
you should distinguish this as a data
type the first Clause data type in the
runtime system and the well-defined
order of keys means that even if you
construct the map in a different order
with the keys they become the same if
they have the same keys as no compile
time dependency and you can print a map
and you can take the printed output as
input create map so then the syntax the
many many opinions about what's the best
syntax in in this presentation I have
chosen to represent it like this that we
have curly brackets we have in hash mark
here and we have this arrow to share
actors key maps to value there have been
other suggestions this is the frames
suggestion from Richard O'Keefe
should be his idea was that it should be
symmetric simple symmetric here the wrap
around and he found another character
single Shang character Tilda was
available personally I don't like that
one it's very hard to write on a Swedish
keyboard I think it requires two or
three key presses and it could be also
it could be hard to distinguish from a
dash in some fonts here's another
approach we already use the equal sign
in the record syntax but I think when we
allow general terms on the left side it
will be hard to distinguish the meaning
so then you can create a key value
mapping like this you can have many
associations in the same q ation you can
create an empty map like this you have
examples here also on a key as an atom
key as an integer mixed one integer one
after here is the key is at Apple
and then next syntax is update it's
similar to the creates in text it's just
that you have need to have an expression
for an existing map in front so this can
be a variable it can be an expression
evaluating to a map there is some
examples pattern matching them here is
an example in a function head here you
are matching that it should be any kind
of a map bind s2m any map you don't care
about the keys and then you use s and
you update the key state with the value
start and doesn't matter if state exists
or if it's a new key and here is another
when you match and in this case it must
be a map with a key starch value key key
state and the value stored otherwise no
match and then it's updated here
bit more about pattern matching them
here is a example of a function
calculating the frequency of terms in
this input list so here you can bind the
first element of the list too I and then
you can use this I as a key into the map
and and binding this variable C and then
you can update the frequency of this I c
plus 1 the certain rules about this but
this is a new kind of matching that is
not allowed today but as long as it
doesn't mean it the search so it must be
that you can unify this the same time
and it doesn't matter if it's this one
comes first we could just at least have
been this argument of the dot form
should work anyway
a little bit more about pattern matching
you match for example if we change this
file read filing for which today returns
record change that to a map returning a
map with the same keys as the record you
can match it like this and you will only
match the keys you are interested in and
if there are other key value
associations in this map it doesn't
matter you don't have to say something
about them so this is very similar to
how you can match the record a single
value access I think we have discussed
this and it's rather open question if we
need it or not in Richard O'Keefe's
suggestion about frames he argued that
it's not needed but I think it is and
this example here we create one map here
M which has actually another map as a
value for the key see here and if you
want to fetch the value from see you can
do like this and it matches this exactly
the same as here you can also do a
nested well you can pick up why if you
have here by doing like this and then
you have this this first is an
expression
evaluating to the value of C which is
this map and you can apply single value
fetch from this map you can also do an
nested update like this where you have
also here you are have the expression
pointing to this map and then you update
why map comprehensions is another thing
you should possible to have and in this
case what distinguishes the generator
here is that you have this notation the
same as inside the maps and it works
like this that you similar way as
converting the map to a list and you get
the keys and values that's the meaning
of this syntax and then you have these
curly brackets and you have the double
vertical bar just in ordinary the same
as in ordinary and list complete
compressions and you are creating a new
map for this
another thing that you must think of
when you introduce maps is that you have
to have them covered in the type
specification so but this is very
preliminary and we haven't discussed
this with Costas yet I mean I don't
think it's possible today to set
specific properties inside a couple or
so maybe you have records you can
declare records but here it would be we
suggest any way that it should be
possible to declare that this function
requires a map with the key and the key
C and the key C must be a type integer
the value of ki c and another example
here could be that you just say what
types of keys and values in requiring in
the map but I said very preliminary one
thing that we have thought a lot about
is this ordering thing and we finally
came to the conclusion that it's
absolutely best to follow the current
part of a line that we have everything
ordered so for example if we implemented
maps as hash tables underneath the order
will not be guaranteed so you would have
to sort them before printing for example
if you or not or sort them before
comparing them because I still think
that if you have two especially if you
come from the record side of thinking if
you have the same set of keys with the
same values they should compare to equal
and they should print equal that's our
idea anyway so among the fundamental
data types maps will be sorted off to
topple and they will be sorted in a
similar way as tuples also bit with the
first of the size and then secondly
after the key value pairs so it works if
you have two maps m1 and m2 could work
like this
of course you need functions for maps
done and we propose to God functions one
is map to see if it is a map as you so
you can also do that with syntax and
then one another one map size to get the
number of key value associations other
functions for converting to and from a
list we are fetch this function names
currently from the dick modular they are
not calling stone those not not the
number of functions are not the names if
you have the same
it will happen that only one of them is
helping and and it is actually oh it's
person I had a note about that doesn't I
think it was a load I didn't like it so
I didn't mention it it was I think it
was mentioned that it was the first
occurrence that was the one that was
taking notice of and the other one was
kept but I don't think that was very
good it's a matter of discussion I think
you'll have other functions here for
creating a new one but you have the
syntax for that as well you can test
this certain key exists in a map and you
can get the value from a map that you
can do that with syntax as well and you
can put the value into a map and that's
also possible with syntax and you can
try to find the value of a key the
difference between that and the syntax
is that this will not crash if it
doesn't exist
you can delete keys and there is no way
of doing that with syntax as we have it
today and you can delete many keys the
list of keys yes they don't exist or do
exist no default values in the current
you can find out what keys you have and
get the list of only the keys and you
can fold with the fun / map and you can
map over map
example here take all the values and add
them it can be argued here if this
function should return key and value or
just value and you can also merge maps
put together two maps and if there are
conflicting keys some of them will
persist I think that that's why I didn't
mention it because I thought my input to
this speech was inconsistent in this way
we have to be consistent with Marge and
the other one internal representation
the nap put on current the map is just a
value you can have in the process
dictionary or you can have it as a key
as well as suppose it's nothing special
about yes there's nothing special here
but as i present it now and if you have
suggestions of what we have forgotten
you are free to suggest things the
internal representation we think that we
can have two different representations
depending on size so if the size is for
example less than 32 or less than 40 you
have a linear representation of the keys
you can do some kind of search here and
we know that break even for that is
about 40 keys or something like that and
in this way you can also share the keys
between instances of maps with the same
key set and by this you could achieve
something that could be close to to
record performance and close to the
memory footprint of records as well
yes they must be in the sorted order
here you have to rewrite this one I mean
they could be shared if you have for
example a function creating these
certain type of maps if you want to
simulate the use of record for example
if that function kind of factory
function for that kind of map then that
this key description that could be in a
constant pool yes it's exactly the same
but you can end up with another one
being exactly the same and not shared as
well and with a certain break point then
it goes over to be some kind of tree
structure and then you cannot share keys
in the same way you can of course maybe
shredder value of the key but if it's
the complex value and it will probably
not be this simple type of dream
but it will require more memory if you
have the tree representation and you
also need an external representation and
we have to use a new tag for external
form and then some size indicator and
then the keys and then the values as
individual terms in the ordinary coding
and maybe in this case also try to find
some way to share keys if you have many
identical sets of keys I'm now thinking
of the record replacement porch the use
cases for maps them as we see it you can
use it for different kinds of mappings
between XML JSON ace and not one in at
least XML and a Senate one we use
records today it would be very much more
convenient to have maps the yeas and
mapping would also be much more
convenient you can replace the use of
property lists in many places and it can
be used in API 54 return values from
functions and get rid of records and get
rid of include files and it can be used
to have the state of the process and
allowing for less problems in upgrading
for example the JSON mapping could be
very straightforward think this is the
current mapping in machi Jason and you
can map it like this this is one-to-one
mapping except for a arrow in a bigger
example this is jason and this is an
ally map it's identical and by that it
could be quite easy to manipulate the
JSON data for example if you try to find
the ID from the current example it's
nested for four levels down you can
either use the matching approach or you
can use this single value access and and
in AP ice you can change or of course we
will be compatible so we will not change
this one perhaps can introduce a new one
in that case
maybe yes it's opens up new
possibilities we have a lot of open
questions of course and i mentioned i
think most of these should we have a
syntax for single value access and in
how should look like i have presented
one suggestion when to change the
internal representation I mean the
programmer doesn't need to know but it's
a matter of performance here is one
thing that we take for example each
other keeps suggestion about frames he
said yet because he is focusing on
replacing records he suggests that you
create this thing frame or map with all
the keys from the beginning and when you
update it it must be an existing key
otherwise an error because you can have
misspelled the key so he suggests you
have a separate function for updating
with the new key yes this is just always
up late because he only focuses on
record but in my examples I have allowed
updating the new record with new keys
so I think that's an open question if if
you use it as a replacement for records
then it makes sense but if you use it
for other uses it doesn't make sense if
you can also have an alternative to have
a different syntax for adding a new key
down for update an existing key in that
case or you don't differentiate or you
have a nasty syntax for creating
different types of maps from the
beginning one which allows new keys and
another one that doesn't lock your keys
in an in an easy way but yes secure maps
and unsecured map
also this type annotation is very
uncertain today have to live with the
risk of misspelling them so in summary
done yes maybe I was too quick we have
this working assumption that maps are
ordered you can have any term as key
even if I think it is quite useless to
have a map as a key in a map but you can
because it's no extra work for us to
allow it pattern matching as I said map
comprehensions some open questions and
we intend to to publish a more detailed
description with much more discussions
and more detailed descriptions of
everything and your feedback is very
welcome we intend to to have this in our
17d and that's about one year from now
but hopefully releasing experimental
versions of this before that you can try
out just
is the same as map size is a function is
no but it's a god function just like for
any other data type ok now it's damned
of time for questions currently we don't
have any fixed plan for that but I
foresee that we cannot break the
compatibility that easy but it's as I
know of it just a few places in our of
the P code that uses records us in the
api's
yes yes the syntax is very similar yes
but the data that comes is just a couple
yes
maybe it could be possible but I don't
know if it's worth it yesterday it's not
constant time it depends on the size
actually it's low gear what intention is
that this simple representation should
be a better performance than the other
one you can even have a binary search if
they are sorted if if it's worth it i
don't know but
i mean the the gb gb trees that we have
today instead of maps i think you would
use maps for almost everything if you
don't have very specific requirements
that could wear another data structure
could outperform maps in that particular
case i mean even if issues remove issues
another representation than gb trees and
it's inside the vm written in c with
possible shortcuts that you don't can
take in the add-on code that jeep Teresa
I suppose we can be quicker than gb
trees in all aspects
yes
it will work in the same way us with
tuples today I mean this this one is a
separate thing this one is a separate
thing so if you change this one replace
it with in something you it you can
still share this
we already have this case with binaries
for example heat binaries 464 up to 64
bytes you could also also for example I
mean it could also be a matter on but
that will be trickier I think if if you
just have simple values in the keys like
atoms or integers but I don't think it
matters you can have another
representation done then you have to
keep track of that is it only atoms in
this one the size is the easiest way and
it seems to be overkill to start a tree
structure for very few keys and I don't
think it's strange to do like that
this
I think you can find out like that no it
is not my suggestion but it might be
changed yes so it's optimal yes they
guarantee it's the same order as you get
from maps to list yes yes if you should
create a new map with just new values
the same keys or both new keys and new
values
mm yes it could be very useful</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>