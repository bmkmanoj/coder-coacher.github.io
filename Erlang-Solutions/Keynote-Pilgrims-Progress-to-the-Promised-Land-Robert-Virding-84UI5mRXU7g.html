<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Keynote: Pilgrim's Progress to the Promised Land - Robert Virding | Coder Coacher - Coaching Coders</title><meta content="Keynote: Pilgrim's Progress to the Promised Land - Robert Virding - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Keynote: Pilgrim's Progress to the Promised Land - Robert Virding</b></h2><h5 class="post__date">2016-10-04</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/84UI5mRXU7g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">so we're going to make a pilgrimage to
the promised land and unfortunately when
you're making these type of pilgrimages
you will run into will call them issues
instead of problems right issues they're
to be solved so we're making the
pilgrims progress the promised land and
we're going to start off here with that
you've heard the prophets and their
followers in extolling Alexia as the
true path to the Promised Land the
Promised Land of concurrent fault
tolerant and scalable systems right
you've heard this and you listen to them
you believe them and you've decided to
make this bill damaged you want to get
there that's what you're all about to
doing so we're going to discuss a few
things that just might come up along the
way and the first one is well first
question is are you following the right
prophets there are a lot of prophets
pushing a lot of different things and
are you following the right prophets and
note I am NOT saying there lie or
anything like this they're not but the
question is have you chosen the right
path is the alexia language and the
system the right thing for you does it
do what you want it to do the types of
systems now to try and answer this we
have to go a little bit back in history
a bit so now about 30 years ago and we I
was working Erickson then in the lab we
started looking at the problem of
programming telecoms which seems like
something completely different here and
this list of properties of that problem
was written by our boss then beyond the
DECA you see in his thesis and if you
notice if you go through that look
there's absolutely nothing about
telecoms in there there is not a
telecoms thing they're the closest might
be you want to talk with hardware that I
guess nothing specific like the robots
and the parrot right but some of these
are more interesting others than the red
ones are more interesting ones you want
to be I have a handle lots of concurrent
activities you were actions need to
perform a certain times you need
distribution because the last one says
you need fault tolerance and if you want
to build truly fault tolerance
since you need at least two computers if
we need some distribution mechanism
rather you need continuous operation and
so on and so on and the interesting
thing about this is which we discovered
later was that this of course is not
just telecoms we were thinking telecoms
with these problems these features
properties are common in other systems
so getting back to are you following the
right problem the right profits the
Aling OTP and then Alexia the system is
designed for building systems of
specific properties you want like
lightweight massive concurrency you want
fault tolerance you want timing
constraints you have timing constraints
in your system you have to follow these
for example low latency and things can't
wait etcetera etcetera you want
continuous operations have a long time
of course I've built my system I don't
want to take it down once a day to clean
up with something like this for I used
to play World of Warcraft and it would
go down about three hours every
Wednesday morning at 3 o'clock or
something like this know doing things
for which was very annoying when you're
sitting there playing so you want
continuous operation induced and you
need distributed systems so this is what
the alexia the language and the system
is all about is to building these type
applications with these properties so
but there are things is not good at all
right very embarrassed to put them at
mention this but it's not good at things
it's not good at doing heavy number
crunching we can do it but you don't
want to do it trust me we're not doing
good at doing things where you got
global shared data we don't like sharing
stuff so we're not good at that and
there are other things as well
however it's not that bad because one
thing we are good at is talking with
other systems so if you need to plug in
something else for example we're very
good at doing that that's something
we've been doing from the very beginning
and we just got it doing that topic and
that typically comes up I mean if you
still are designing large systems or
building large systems you'll find a
different parts of the system have
different properties so having one
language to rule them all in that sense
is probably not the right
to do anyway so you want multilingual
stuff will be we can do this we've been
doing that so it's not all bad and you
could use for example Erlich SIA just as
some form of concurrent glue to keep all
the other bits and pieces back together
again and it's been done with that so
it's nothing strange so this is the
first first stage you have to get over
am I going the right way is this what
I'm doing or am i doing weather doing
weather weather forecasting which case
I'm probably going there very much the
wrong way but you work these things out
so yes we've decided this is what we
want to do this is the right system for
us is the right type of applications the
next thing that could happen is you'll
get to the joy of the first experiment
okay so you've downloaded the system you
started using the tools and you've
written your first simple thing it might
be simple Alex your server it might be a
Phoenix webpage or something like this
web page written in Phoenix and it works
right and you're happy because now
you've seen yes it actually does work
nice the next stage will come well you
want now you're going to keep on going
and work with more things in the
developer system and write something
serious in it and you will pretty
quickly end up in the village of
confusion this in the next two points
all fit very much together here right
and what's the problem here
well your what your system sort of
working but it's behaving strangely
right it's not doing quite as you expect
this problem is more typical I'd say
more common if you're coming from a ruby
background it just doesn't quite work
right now the question is then we're
getting back did you really listen to
the prophets when they were describing
their system because one thing they very
much say very strongly is it may look
like Ruby and by design it does but it's
not and they will tell you you go ashore
say is this Ruby on the beam they'll say
no and it's not and if you assume it is
you'll get into problems it's not
object-oriented you can do
object-oriented stuff in it but it
doesn't quite work as
as you expect it to if you can talk more
about that later if someone comes up on
our staff to talk it's got a strange
handling of data and it has a strange
way of building systems if you're coming
from different Wales so if you're not
careful you'll get into the village of
confusion and you just have to go on and
get out of that and go on to make good
stuff right so the first thing place you
will arrive at is the hill of functional
and this is something again this and the
next one are things you cannot avoid and
the quicker you get up you climb the
hill the better the lower the hill is
the longer you push it the more problems
you're gonna run into and the thing here
is we have to understand this to have to
climb this hill to understand the
language properly it's not high again
the longer you delay the higher it gets
because then you have more things coming
in and become much more confusing and
the basic problem is Alexia is a
functional language and if you're not
used to functional languages you're
going to run into things that are
different for example we have immutable
data and this is not something you can
choose or discuss about all change or
anything all data in the system is
immutable
I cannot mutate data at all the system
basic system all the way down the model
will not allow me to do that so I have
to get around this problem I have to
work with it that's it this will change
the way I work with data and the quicker
you get into this the better the faster
it is get over quickly and the same
thing there's this fantastic thing
called pattern matching which truly is
fantastic but just a completely
different way of working with data
it's very declarative than the style of
it I use this both when building data
and when looking at data so when I'm
building data I don't say tell the
system how I want to make something I
write it down and I let the system do it
build it for me which is very different
if you don't use to it it also ties in
with immutable the same thing with
patterns but with pattern matching I
have patterns so I die I don't write a
lot of code saying what this data should
look like and test for it and extract
values for it I can just write down a
pattern and the system will do that for
me it will do that
it will do the extracting of the values
and stuff like this for and it's
fantastic once you get used to it you
sort of you sort of wonder how could how
could I have survived without it but the
first time you do it it's really strange
right because I'm not doing anything I'm
just writing down a structure and
suddenly something works what's going on
type thing and these are type of things
you will hit get over get used to it get
on with it and then you can start doing
proper stuff right the next one is
recursion there are no basic looping
constructs in the language there are
libraries that will do the lot of them
and typically you'll use those libraries
but at the bottom it's recursion and
sometimes you just have to do this
yourself this is no way around it and
there are a number of other things that
come from the functional language
environments it just is a functional
languages language features they are
strange and different the first time but
after a while you get used to it and
it's just not a problem
but the quicker you can make sure
they're not a problem the better so
that's the first one and the second one
is the mountain of concurrency right
this is actually a bit higher this is
how you use in building systems okay so
it's about understanding in building
systems it's not high really but the per
might think it feels very different the
path through it feels very bit different
about how you structure systems and what
you it can be very different from what
you used to so how do we structure
systems we use processes for we
explicitly use processes everywhere to
do things we don't share data processes
are isolated by design they're isolated
we don't share data we don't have any
global state you might think you have
global state but you don't want all
communications just by sending messages
that's it if you've got two processes
that's how they communicate but we
aren't scared of creating lots of
processes the system allows us to do
this right so a thousand process is
nothing child's play 10,000 still not
not really worth interesting to get
around 100,000 processes now we're
getting somewhere
now we're standing millions of processes
and that that is interesting and there
literally are systems put in production
running millions of processes okay I can
argue whether that's a good design
choice or not but the system will do it
it's just a completely different way of
building systems again it takes a bit of
getting used to and you eventually you
have to do that and the quicker you can
get around this the easier and again the
final one which also can be very strange
is we aren't scared of crashing things
right we'll see more about that later
but we aren't scared of building systems
where processes keep crashing all the
time that again is a very strange way of
thinking but you'll hit these problems
in the far the faster you can get around
accept them and get around them the
faster you can go on and doing some
interesting stuff right so we have these
three at the beginning for
the next one we're going to come so we
built our system our first experiment we
did our first experiment we've looked a
bit we're now understand a bit about
functional languages we'll understand
about the concurrency and now we're
building our system but it's crashing
occasionally right things are going
wrong which is nothing strange things
always go wrong in your system that's
nothing strange but the system is
crashing it's not quite what we expected
because we had this dream of making a
fault-tolerant systems so what's going
on here so we now have to cross the
master of fault-tolerant systems we
cannot do anything about this we have to
understand what is going on and how we
can work with these things and there is
a big marsh we need to get through for
building fault and we can only where you
can get through this marshes by being by
understanding and learning to build
fault-tolerant systems this is a problem
and there are many paths through this
there are many ways doing this you just
have to find the right path or the best
path of what you want to do and one very
common one of course is OTP is the OTP
path right this is a natural choice for
many for many reasons it was originally
designed to support the building of
fault-tolerant systems there are a lot
of tools in there for using things and
you can many things you might
already used one for example you want a
server so you just used the gen server
to build a server that's nothing strange
in that but OTP was designed in such a
way that you can plug the things
together in the right way to bet it to
build fault-tolerant systems that's what
is one of the things that was all about
really for and again you've probably
used a lot of things from this anyway
it's quite natural to do that well even
if you think not thinking about the
fault-tolerant systems and well another
reason is natural is that the underlying
system is built on top of it when you're
running start running alexia it's built
on top and using OTP it uses it
extensively it's used in the underlying
system for the airline part of it it's
used in the LXE a part of as well it
uses it everywhere whether you see it or
you don't it's all there
you're all using it anyway it has
extended it so one of the things
sometimes people don't get about OTP is
that it is extensible and Alexia has
used this an extended OTP it's ad OTP
has this concept of a behavior which is
something that implements a design
pattern an OTP Alexios extender OTP by
adding new patented for example the
agent and the task to to ask her to two
new behaviors added to it and this is
nothing strange the OTP system allows
you to do that in extended and they look
she has taken this
so yeah it's used it is used everywhere
and this is generally the best path
through the marsh you can't do it
yourself for some reason they might
there might be a reason you can't use
OTP and you might want to do it yourself
you can do it most people don't
so getting to learn OTP and
understanding how it works and how it
works with the rest of my system is
another one of these things you just
have to attack right and when you do
things will become much easier
so yes so now we're going on here but it
does have one one property feature how
we want to see if that might be very
much feel strange if you're coming back
so we're handling using errors and the
classical way of error hat doing error
handling is putting tests everywhere to
see if everything worked then try to
work out some nice way if something went
wrong right this is not what I this is
basically not how OTP works you can use
it like that but the whole idea is not
to do that so what it means is that you
have to sit down and think through your
system and decide what should the system
do when things crash and no we say when
because things will crash I don't know
if you thought about but the first rule
for building a fault-tolerant system is
accepting that things will go crashing
it and go wrong you cannot build a
fault-tolerant system if you don't
accept that because it will happen it
might be hardware it might be your
software might be a library it might be
something but something will go wrong
what do I do when something goes wrong
and so the idea behind OTP is you sort
of sit down here think of your system
and I've got all these processes running
doing things that are working and I sort
of think well what happens if this
process crashes what should I do
well this type of process crashes what
should I do
maybe I can just ignore it just let the
process crash I don't care the system
will work anyway and all someone else do
the right thing that is not very common
you have another class of processes
which say yes this process or this group
of processes has to run the system is
not can't do what it's supposed to
unless they're running so therefore I
have to make sure that if that process
crashes it's restarted I just have to
sit down and do these things for and I
have to make certain when it restarts of
restarts quick clean stuff like this
there is support for doing this this you
know TP you typically use that another
group another class is yeah this process
crashes and I will let it crash because
it doesn't make that much difference but
I have to make sure I can clean up
afterwards because the process might
about
cager resource or something like this
and if it dies fine I'll accept that but
I have to make sure have to clean up
afterwards so getting back to original
telecoms world yes you might lose a call
as long as doesn't happen too often it's
okay but I have to make sure the system
continues afterwards and does not crash
just because I lose one call the switch
should not go down it's the same thing
if you're writing web server yes you
might lose a connection because
something goes down but that should not
take down the whole server then you've
got something seriously wrong in your
system right but this takes a lot of
planning thinking through the structure
of your system of working out what to do
when things go wrong but it does mean
that when you've done this I can more or
less ignore errors in most of the rest
of the system and surprisingly it works
right this is where you get your things
of five or seven or nine lines of
reliability it's based on this basic
thing is we're not talking here about
sit the system crashing but we're
talking about things inside bits inside
the system crashing the system design in
such a way you can handle those crashes
and keep on going the system should
never die down they should never go down
and that's what's called the Ln let it
crash philosophy and not everyone
understands what we're talking about
there was a discussion on Stack Overflow
about three years ago I think they were
getting into discussions about the
Erlang clever crash philosophy was good
or bad and one guy there was getting
very worked up about this because he was
writing well how can he just let things
crash if my system was to crash it cost
me a few hundred thousand dollars every
time it happened so how could we have
just let a crash and the problem there
was no one had explained to him we're
not talking about the system crashing
we're talking about little bits and
crashing in the system surviving that's
the whole goal but anyway yeah so this
these are things you have to think about
and think about when you're designing a
system and when it works things can
quite happily crash and you will
actually find systems that people are
very happy people are using and pretty
happy about it then they go start
looking in the logs and the things they
see the things crashing all the time
it's
recovering from the crashing keep on
going so no one notices it now that's
good but also bad because it means that
you don't fix the bugs yeah but yeah
this is something well sometimes they
don't even know that something is going
it true I'm not lying here you have
systems where people have not noticed
that things are going wrong in the
system the whole time because it's
recovering and restarting the whole
thing we're just working on surgery they
just don't notice it and yes fantastic
but yes okay
so this is the marsh you know you don't
have to cross this mush otherwise you
will not get to building fault-tolerant
systems at least not the Alexia way of
doing it right so now we go on and this
is a difficult one it's a double-edged
sword or meta program so you've been
wandering around and you've been
carrying the sword or metaprogramming
with you all the time okay from the
first time you wrote IEX to start the
first system you've been carrying that
sword with you and you've actually been
using it all the time although you
haven't realized it and often you
haven't realized its power it's a very
powerful sort it's a power to both do
good and to do evil and to do really
evil evil okay so it's there so what is
the sort of meta programming
well macros you can write macros in the
system you can buy a book describing how
to write macros in the system I am an
old list program so macros are
completely natural to me and I realize
all the things wonderful things you can
do with it but I can realize all the
what bad things you can get into it so
if you use it wisely it is a very
powerful tool and it can be really
helpful for describing systems if you
use unwise unwisely you can write you
can read the code that is totally
incomprehensible you can understand it
because I understand this McCarron seems
very natural for me to do this but
someone looking at your code so I'm
looking at your code has actually no
idea what's going on I've written this
fantastic macro foo which does ten
different things in it they're all had
coupled together and I'm very happy
about this and someone else looks the
currencies of fluent says
what trust me
this happens the thing is you're already
using macros a lot of those things
you're running in Alexia has standard
things are macros and some of them are
quite complex but the trick is making
sure they're conceptually simple so for
example def for defining your function
is a macro and it's pretty
straightforward what it's doing is
defining a function but it's doing some
more stuff it's making sure that the
system will now say that this function
can be called from other modules and a
few other things going on as well too
it's doing these things and you're built
in there but it's been designed in such
a way that all this feels very natural
same def piece lightly different make
sure things aren't visible from the
outside wall but begin defining function
def modules of mode is a macro so a lot
of macros in the system you're using and
a good macro is very clear what it's all
about
this does not mean has to be simple but
just has to be very clear what's going
on in the macro and if you write a bad
macro it becomes extremely confusing
again I'm as I said I'm a lisp
programmer and Lisp is all about macros
and it's very easy to write bad macros
that do things you don't understand so
yeah be very aware of this a problem is
macros are a lot of fun I cannot I
cannot hide this it's a lot of fun
writing macros I write this fantastic
macro bang out pops code I want okay I
skipped over one thing here yeah macros
that they run a compile time a macro
when you use it you get something that
looks like code and the macro transforms
that into code and then passes that on
into the compiler that's basically what
you want to that's the basic idea behind
a macro and again you can do a lot of
it's fun doing these things right and as
I said there's a there's a book
describing how to do it how to do it
next year the issue is not to get too
excited about this nothing go too far
this is a known problem so this is not
something new I'm saying here but it's a
known problem and there are a couple of
suggestions for that macro
and one is don't do them okay and I
think that's a bit hard to be honest I
think it's a bit hard macros do have
their place place in the system
I would another one which I think is
much more correct never use a macro if I
can use a function a function has the
benefit you see very much what's going
on there if I can if I can just you
if I just have a function doing
something this that I should not use a
macro instead to do that just
replaceable there are a couple of rules
but so yes if you use macros if you want
to write macros in your system think
about what you're doing think about
think about if other people can
understand will you yourself I also have
had this rule I try to write code that
if I come back in six months time I will
understood what I've done and that's
sort of if I can't understand what I'm
doing after six months no one else will
understand what I'm doing anyway right
so that's a bad thing think about other
people have to look at your code and
again that's getting back to it
macros are both extremely powerful tool
for doing good and bad learn make sure
it's for good really yeah now we're
gonna hit something which we have
avoided so far the language heaven we're
working a promised land and we have a
heavens and up there containing various
layers contain languages and Alexia is
part of the language heaven and what we
find as we keep on working that the
language heaven is actually multilingual
there is not one language is not just
Alexia we hear we hear these tales of
things going on here that it's multi of
the play multilingual and they're
squabbling between the various language
gods and their followers and things like
this fighting between them and stuff
like this
don't despair it's nothing to get worked
up about seriously and it's extremely
easy get worked up about this but don't
it's not worth you it's not worth
putting your effort into it so what we
find is that the language heaven is yes
it's multilingual but what's actually up
there is something we call the ailing
ecosystem okay it's a collection of the
languages that run on the
typically it's not bill 14 okay but you
can have them and they're all parts
running on the beam Airlines there of
course Alexia has its natural place up
there for so this is where you're at
this is where you actually this is the
actual the language heaven you're using
when you're designing your system and if
you choose to use here they you can use
whichever one you can mix them and the
power here is that if these languages
follow the rules which they do at least
these two you could they can interact
with each other they can openly interact
to each other and support each other it
means yes I am running Alexia to build
my system but yes things will be written
other languages and I don't have to
worry about this it's not something I
should care about and it means that the
whole system becomes much more powerful
than any language in it because they're
interacting with each other because
they're talking with each other and
doing these things and this is something
you're using you might never see it but
this is something you're using you start
this so some of the system you're
running Alex here will be written in our
line summer will be written Alexia and
fine because they work together and you
never have to notice this that's very
common a you might use libraries that
come from the Allen world and yes they
interact there's no big deal just do it
so mention the Alexia system itself is
built on top of a lie
it works with it extends it and does
more things for its there you don't
notice it you don't have to notice it
anyway the same thing if you're using
phoenix phoenix is written in Alexia and
you'd program it and Alexia but
underneath it happens to use as a
package I suppose you'd call it call
cowboy for handling connections those
cowboy that's doing the connection
handling for cowboy is written you know
like and it just works right so this is
actually not a problem and if you get
squabbling between the groups I would
say just ignore it don't get worked up
about
I have personally by mistake started a
bit of that squabbling it's not much
because I was making a joke and people
took me seriously yeah just a quick push
is getting on Twitter is not a good
place to hold an argument yes discussion
yes you've been told this and but unless
you actually get into it you will not
you will not believe it but yes so I
tweeted a joke what I thought was a joke
because other was just too ridiculous
take seriously but some people did take
it seriously got a discussion about this
thing yeah so avoid these discussions
they're just not worth the effort okay
and there is there is no real cause for
doing this you will use them you are
using the multiple languages whether you
whether you know about or not a question
that often comes up is okay so I'm
building my system in the next year and
I've heard of it
I know our lines there do I have to
learn Alec and I think the best answer
is that is No
most of the time you will not have to
learn a line you might sometimes don't
you have to realize is there
occasionally you will run into it you're
using a library that's written in our
line are you calling it direct from
Alexia which is no problem doing it and
I just have to look in documentation to
find what this library does and the
documentation is written in a line
that's obvious usually not a problem
because at that level the the difference
between the languages the mapping
between them is pretty straightforward
and there's usually no problem
understanding what's going on and a lot
of times you'll find that in the Alexia
environment you will have Alexia
libraries that are mappings between you
as an Alexia user and the a Lange
library below not always to do that but
typically you will do that for example
we are talking about the gen server
before yes there is a gen server
behavior implemented our line the Alexia
gen server layer is built on top of that
and provides a mapping to a perform
alexia into that chance over nothing
strange about this but it's just there
so get over there get over the problem
get over the thing about
there multiple languages there and if
you see these discussions you can follow
them and have fun with them but don't
get don't get worked up about it it's
not worth the effort to be honest right
and yeah which is the better language
the one you like that's about it but
this has a lot of benefits because
anything what this means is that you're
in the ecosystem and anything that's
been done that can run in the ecosystem
I can use from any language so I don't
have to use the language is written into
act to use these features I can use any
language in here so for example yeah we
have a Java system over there which you
might have to access for something and
yes there are mechanisms for accessing
that so I can talk with these two the
whole system the systems could interact
with each other now that happens to be
written in our line but that doesn't
make a difference I'm running I'm
running in the ecosystem I can use that
so if I want to talk with if I'm writing
my legacy a program I want to talk with
the Java system fine just do it it just
works right this is the benefits of
these things be just bid they come from
one language I can use them in the whole
system now talking with the JVM has a
slight as a as a nice little backdoor
here because you see something there
called err Jiang which is actually an
implementation of our line running on
the JVM okay and it's a very good
implementation running it there as well
too so therefore we can talk from the a
line system we can talk with Joe with
JVM through the air jiang system and
actually run distributed stuff all over
that and a works one I have not tried
running alexia on it but I can't say
there be any reason not that it
shouldn't work again from that point of
view LX is not doing anything strange
right it's giving you a different syntax
a different set of libraries a different
way of working with many things but just
running on basic system for it also
means in one sense you cannot make the
wrong language choice about that later
so yeah so I just want us to I mean
sometimes you'll see some very heated
discussions about this ignore them get
over it as I said look at the joke in
them it's all it's a big joke treat is
that it's not worth treating anymore
so the next thing you've probably seen
these are a number of these around the
pool of introspection you've been
wandering around and building your
system you've seen these pools here so
what what is this all about so the pool
of interest it it's a pool you can sit
by the pool and the reflections of the
water you can look inside your system
while it's running you can introspect
into the system and look at thing what's
going on inside the system while it's
running and gaining understanding of
what's going on now depending on your
background this is something quite
natural or something quite strange and
fantastic and how do how the hell do we
do this for but the basic system gives
you support for doing that looking in
systems and currently well there are a
number of tools that do these currently
they're work they work in Alec but again
I was I was saying that the interface
the interface between them is very
straightforward in that sense yes it's a
bit of a lying syntax but the mapping
from that Aling syntax and the Alexia
straightforward is there's no problem
for a typical world the number of them
are standard more or less standard
there's observer which comes with the
basic outline system isn't very nice
graphical interface for looking into the
system and seeing what's going on in the
system I can for example trace loads
memory usage I can look at things I can
look at processes in the system I can
look at my applications which is a an
OTP complex for building things put
together for I can do tracing I can turn
tracing on/off of processes and look
what's going on for example I'm sort of
bit surprised something seems a bit
strange on this bit suspicious that one
process might be what one process is
doing I can turn on tracing for that
processing so I can see all the messages
sent to and from that process I can see
is it getting sent what I expected to
get it will expect to be to be sent to
it is it sending back replies which I
expect and these things I can do at
runtime dbg is again part of the
standard release it's a text-based
version text based in this sense means
you can run it from the shop so one
quick push here so one of the things you
can do with running the assistant I can
have my production system and I can
start up a shell
while it's running and look at the
system while it's actually working
which again depending on your background
is very strange or or quite natural and
I can plug observer into it if I got a
graphics interface or run distributed or
if I can't maybe I'll main bure can just
start a shell on that and start using
tools in the shell through the shell and
DB G's have common one it's got a
slightly strange interface people
designed it like short function names so
they're all one two three or four
character long names which can be quite
confusing but it works a common tool
from the well to common tools from
third-party tools recon a red bug again
these are tools designed to be run from
the shell for just looking at the system
itself while the system is running so
for example in recon I can say okay are
over the next five seconds return the
process of the five processes that have
done the most load and all sit there and
after five seconds of combing these are
the processes that did the most load I'd
get information about process a lot of
things about the system going on while
the system is running similar with red
bug the benefit of these is I can do it
both on my test system what I'm testing
it I mean I'm running my testing
environment I've built up my test
environment of course and the test seems
to work but I want to see what's at
what's actually going on in the system I
think I think things might be running a
bit slowly why is he running this slowly
or why is this speed changing why is
that sometimes I run the test it goes
quickly and sometimes I run it go slowly
so something is going on in there so I
can look at them so I can use these
tools look at test environments but I
can also use them to look at my
production environment so my systems up
and is up and running but sometimes
things go strangely so I can use these
tools to go look at the system while
it's running and not take it down that's
fantastic I have to mention wombat okay
I come from our lang solutions and this
is a product we have
and it's also a tool for for inspecting
looking at systems it's more complex
than the other tool so I can do more
things it's pluggable so I can put I can
write my own handles look in specific
things and what I hope we can work out
andr push this as well
that a severe een ice deal for systems
with small numbers of machines in there
I hope I hope we can get something up
with that to get out it's a very nice
tool if you do that otherwise but yeah
the thing is these all work in our but
at this level interface is very nice get
get used to work look at this it's quite
fantastic looking at the system what's
going on what's doing there I can show
you some simple examples later on if you
want is interesting and the wombat has
has this feature I can write my own
plugins if I want looking for my
application I want to do some specific
looking at that I can write plugins
which I can then numb for looking just
that and get information out of the
system for the other ones are more
generic or they are generated way so
that's the pool of introspection you
will hit it you look at it get used to
it user it's a fantastic it's a
fantastic way of thinking about the
running systems for testing is fine you
must do testing of course but it cannot
all tell you everything this help you so
after all this you've got the joy you've
hit the joy of arrival right you have
made your system your system here you've
built your system it's a real you built
your first real system here and it works
right it does what it's supposed to do
it can handle all the load you're
expecting it to do it can survive errors
and just keep going as what you hope for
it just works right and yes this is
where we want to get up with this is
where we where we're going you can do
this and the path of getting there it
has a fuse has a few issues along the
way and if you should yes you should
watch and rejoice about this of course
but realize the path actually wasn't
that difficult as it first seemed the
first
you have these issues and you got the
idea of pointing these out these issues
is to make sure they don't become
problems and they honestly don't become
problems and two unless you start
ignoring them they won't go away right
the functional nature of the language
will not go away it's there once you get
used to it it's gone the problem is gone
it's not a problem same thing with the
concurrency with with building the
fault-tolerant systems you have these
issues attack them then they're gone
they're not there the second time you
make the system it'll be much to make
another system be much easier because
you know all this already and the basic
ideas have say using OTP that's
irrespective of what you're doing
they're all the same once you learn them
you know it you know how to sit and
think about those systems you know how
to solve the problems that might might
occur if this process dies I need to do
this how's the best way of setting up
the system to do that fine I've done it
it's great and it is not as complex as
you would think
- once you accept the fact that they're
there make sure your whole idea is make
sure you have these issues make sure
they don't become problems and trying to
ignore them that's the guaranteed way of
making them turning them into problems
and yeah that's basically and this is me
so do we have time for questions I don't
know okay
are there questions we can take anyone
not you all did right yeah yeah I'll
repeat the questions obviously either
I'll just repeat the question ypz thank
you very much Robert it's great to hear
you talk I'm desperate to ask you a
question about exceptions one of the
things I love about languages is
actually more about the philosophy of
them rather than the syntax that's
intact detail but yeah one of the things
that we get from Erlang is this lessee
crash not it's something I've not seen
before and if I'm really interesting but
I wonder I then I'm writing Ruby I'm
writing C++ and I wonder whether maybe I
just didn't understand exceptions in the
first place because although there's a
lot of building blocks around it you
know usually when we write a function we
write a system call in indices say we we
return the result code and then if we
really want to make sure someone looks
at the result code we return an
exception and then we build our language
we're desperate to catch the error as
soon as it happens but really what
you're introducing here is something
like well maybe we should have caught it
somewhere else and only that's what
exceptions are all about all along I
think you're very much how you handle
exceptions or errors I mean from from my
point of view they're the same thing it
very much depends on what the system
allows you to do so if you're running
say something in C++ you might have one
process you cannot let that process
crash okay you have to you have to catch
the exception to handle the exception in
some way well I mean if you like yeah
you let the process crash but then that
then the whole systems gone down and
you're not gonna be like they're not
gonna like you for that right so the
reason we can do it the way we do by
just letting processes crashes because
we have so many processes we're
designing a system I tend to think of
it's much more it's not as much not so
much a language with concurrency it's a
system with a language we working with
the whole system and our goal was from
the very beginning that yes there
will occur so what are we going to do
when an error occurs and typical case is
I'm doing something and I have a bunch
of processes working together doing that
thing and if one of the processes you're
getting there in one of the processes
maybe the only logical thing is just
take them all down
I cannot recover from I cannot recover
from them so therefore you let the
processes crash and you make sure that
the processes that are working together
they all crash because the thing they're
doing is just can't go on in our case
was a call that can be anything it can
be a connection into your server or
whatever and then okay so now we'll let
things crash and we can make sure the
process of working together crash using
links now I have to clean up after that
so therefore I have to monitor that
these processes or one of the processes
Union and then so I can when they crash
I can clean up afterwards so if they've
allocated resources I can free the
resources or whatever it might be when
inform someone else that crashed and so
then you need to monitor the process and
then you have work out well if this
thing crashes I actually have to make
sure it's still working so now we have
supervisors so that's based around that
and often you will find okay there's
some very much my interpretation you're
less interested in why it crashes than
that it crashes why is for looking
somewhere else afterwards later but not
so much at one time but a quick push or
a quick back there sometimes it is
actually relevant to handle that
exception inside the process and then
you do it it just basically where's that
where is the best place to do it so you
have a try if I need to catch an
exception in the process I can do that
inside of try and the try will catch
that for me and I can clean up and maybe
go on depending what I want to do or
maybe I clean up and die anyway because
I still the best thing to do but you
have to sit and work with this there's
support for doing either way I've never
quite answered your question but that's
that's that's the logic behind it and
that's also the fact that you have a lot
of these more lightweight processes so
crashing your processes in one sense is
no big thing again it's a very much a
rethink
final comment about that is when you
think about building these systems and
alexia think about structuring like
operating systems so an operating system
you have a bunch of processes and if one
of these processes crashes fine the
other ones will keep going I can pop up
lots of shell windows and if one of them
crashes the rest the system will just
keep on going right that that was our
sort of design goal we had Ford for
doing that things will go wrong the
system must continue so I had another
question one thanks for mentioning that
it is an operating system because really
that's what the rolling VM it feels like
to me that's a good thing I like it yeah
my question is you mentioned that
sometimes OTP isn't the right thing
sometimes you have to go outside that
can you give me one example in your your
career where you've had you said okay
OTP is not the right solution for
building some system well maybe this is
not so much baby drop building the whole
system but sometimes the way OTP
behaviors work is just not what you want
it they just do do the wrong thing and
you might have to write processes that
aren't that aren't behaviors that are
part of your system and you have to
handle that in some way you have through
the handling of those outside OTP any
chance you have a short story or example
of that I've managed to avoid it yes so
yeah no well then a lot some ways you
can get around to that I mean as I was
mentioning OTP is extensible so I have a
process that I cannot fit into a
behavior one of the original ones while
they lick their behaviour or some other
behaviors come someone's written which
is Buffy doesn't and I cannot fit my
process into that babe what if I do it
says so much effort doing it becomes
ridiculous so I have to write my own
process to do that you're just doing
something there is support for baking it
and plugging that into the HP system so
I'm actually I'm writing something which
is not a behavior but fits into the OTP
system anyway that that's not uncommon
do that
it's actually difficult not to use OTP I
mean not just because of the practical
nature of it it's there anyway right you
start up the system and you're actually
running OTP you can go in look at the
applications what you're running there
OTP application see everything's part of
an application but you can do it but I
mean do you consider spawning a process
directly still within the bounds of OTP
or is it only within the bounds of OTP
fusing behaviors and and again it
depends what you're doing
so sometimes yes I will spawn processes
myself and sometimes they're not part of
the OTP so I don't care if they crash
right doesn't make making difference
but yeah that's one thing I that's one
thing I've thank you I forgot to mention
that when you're using OTP you can write
enormous is massively concurrent
fault-tolerant systems without ever
explicitly creating a process or sending
a message at receiving message because
it just goes through the behaviour
interface it's all there this is nothing
this is nothing wrong it's just proof
that the behavior interface works right
the problem that can be if you're not if
you're not don't realize this that you
are creating processes you're going to
get in a lot of trouble I'm creating a
gen server and I do a start I'll do a
startling function to that gen server
that is actually creating a process and
if I if I don't treat it as a process I
will get very strike and get strange
with and get confused so you can write
these systems literally you can have
hundreds of thousands of process and
never explicitly start a process
anywhere because the behaviors are doing
it for you and you're communicating with
these processes sending messages
backwards and forth but I never see it
because the behavior is doing it and
that's fine there's nothing wrong with
that if I'm aware of it does the
question if you shout I can rely
can I was just wondering on a personal
level how does it feel that after these
decades there's new mindshare coming to
something that you started all that time
ago and you know was it inevitable in
your mind that this would happen or is
this just a heavy circumstance it's not
inevitable I mean there's a lot of lot
of good ideas that get lost along the
way they'll never adapt it will take a
very long time adapt of course I think
it's fun I think it's great I think for
a certain type of solution I'm sorry
sorry certain type of problem this is
the best solution so that people using
it I think is great and whether it's our
lang or alex year or LFE of course which
is better than both of them but it from
my point of view it doesn't make any
difference they're all the same basic
ideas the concepts are working they all
work together anyway I don't see you pom
so yeah I think it's great I think it's
some it's a real I think it's a
realization by the rest of the world
that the type of problems we were
looking at we're much more general than
we first thought and I'll be quite
honest the first time someone wrote a
web server and our Linus was wondering
what the hell are they doing right now
why would anyone pick how long to write
a web server it's for doing telecom
stuff for and that again we just hadn't
sometimes realized how general our
problem actually was and the yes has
taken a long time to get out but better
late than never and I can say one thing
how many people know what OTP actually
stands for yeah you do yeah and
hopefully you haven't been scared off by
that by the T in the OTP which stands
for telecoms because if you look in OTP
there's absolutely nothing about
telecoms in it the closest I think can
get is an ASN dot one compiler that's
about it right so don't get don't get
scared about that so yeah it was very
general it was more general than least
I realized from the very beginning for
it I'm just happy that people have
adopted it and whether you do it through
out on the LXE I don't care it's from
one point view it's the same thing
pick the interface you like the best
user that's we're getting back to our
talking about these language arguments
before it they're pointless right yeah
syntax is in one sense is irrelevant use
the one use the one that you feel happy
with it works and work with everything
else as well so I think I hope that
answers your question anymore but before
we get kicked off yeah
gently asked to leave</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>