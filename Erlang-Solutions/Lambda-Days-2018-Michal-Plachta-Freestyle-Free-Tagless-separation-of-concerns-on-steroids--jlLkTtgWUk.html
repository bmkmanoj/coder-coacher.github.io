<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2018 - Michal Plachta - Freestyle, Free &amp; Tagless: separation of concerns on steroids | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2018 - Michal Plachta - Freestyle, Free &amp; Tagless: separation of concerns on steroids - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2018 - Michal Plachta - Freestyle, Free &amp; Tagless: separation of concerns on steroids</b></h2><h5 class="post__date">2018-03-21</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/-jlLkTtgWUk" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is me how I work at a cutter
technology and I want to show you some
non-trivial example to when you can use
a functional programming tools to
separate the concerns in your software
and I will using free Monat and then
freestyle library from Scala and that
for all of you who doesn't know Scala
and let me know who you are okay so some
of you doesn't don't really know Scala
so the concept is what's important in
this talk so what what I want you to
take away from it is the concept itself
how can we separate the concerns and I
will start by defining the separation
concerns but by defining what what when
the separation of concern is not there
what is our intuition behind behind the
separation of consent so probably there
was a time in your careers when you
wanted to do a quick fix or do a very
simple feature and after some hours of
of coding you ended up with the git
status like that already changed files
and and many many failing tests so this
is this is something that was bothering
the whole industry the the programmer
industry for many years so Edgar
Dijkstra wrote the paper in 1974 about
just that about separation of concerns
and he stated back then what is the
intelligent thinking approach to our
software so when we want to really think
intelligently about the components in
our software we need to be able to think
about just one aspect in isolation and
then another one and then another one
and in isolation we need to be thinking
about the connection between those those
things so this is kind of approach that
he he proposed had suggested back then
and we still don't really have the tools
to do that and we always know how to
separate the concerns this is like
obvious thing for us for example when we
have a simple feature like a higher
level logic low level logic and we can
draw the diagrams around and say that
logging should be separated from the
metrics gathering and DB access should
be over here right something like that
and all those aspects will be isolated
and separate and of course when we and
I'll be using a diagram like that
throughout the whole presentation
so the blue ones are the technical
concerns and and the gray ones our
business concerns and this little arrow
is that this one component knows about
the other one and look the question for
us and for you is what are we aiming for
what do we want to achieve we want to
achieve separation of concerns and that
means on this diagram that we want to
achieve no outgoing arrows at all so for
example in this example you see this red
border around some of those components
that means they they don't really know
about anything more than themselves so
they are truly separated so this is kind
of thing holy grail for us we want to
achieve something like like that as many
concerns as possible need to have this
little border so no outgoing arrows at
all and then we will be able as Edgar
Dijkstra said to think intelligently
about some of them those red ones for
sure because they don't know about
anything else and then they don't need
to okay and this this is kind of obvious
and for me it was very obvious
throughout all those years but recently
I had an epiphany this is not so obvious
anymore because we can't really see it
in many many code bases so imagine that
you are a landscape designer right so
you design parks and you and parts are
for people recreation so people need to
tell it to walk and talk and you know
have have fun and relax basically and
when you design a park and you design
this little spot over here in the in the
center and wanted to have some grass but
then real life kicks in people are in a
hurry they want to take shortcuts and
they just go through this little Center
so the park experience for the whole
community deteriorates because this from
out from from the up perspective from
the top perspective you just see lots of
different shortcuts and and you know
people are just running around and no
nice green fields and the same happens
in our software so we can design the
whole thing right so layer after layer
and this DB axis is right here so you
you need to go over here so that the
software from the top perspective looks
nice right and clear no shortcuts no if
different roads to achieve the same
thing
but people are in a hurry developers are
in a hurry and here you here goes your
obstruction so we currently this is
still a problem so we need to be
thinking constantly about developer
experience and developer experience
means our experience a software
developer that is currently writing a
bunch of lines of code and the future
selves and our colleagues in the future
so developer experience is very very
very important even under pressure we
need to be still consciously thinking
about those things and we won't if we
don't have tools for that so we still
miss some tools and three more that is
one of those tools so this is not a lot
Superboy again but this is one of the
tools that can help us isolate the
concerns separate the concerns in our
software so I will using free as a
concept here but remember there are
different tools you can you can use they
are needed in order to for us for the
developer experience to be enhanced and
so that our software looks better from
the top perspective even as the time
goes okay so three what is three who
knows what three monitors and they said
like a half a room maybe maybe Samuel
wrote that okay so free is a value so
when you see something like that in
SCARA free F and a freezer value free
describes a program so this is a value
that describes a program and this
program will use F as an instruction set
algebra instruction set and a will be
the value returned when this program
gets executed at the end right so
whenever you see free effort a from a
sorry it means that this is a
description of a program which will
return a and the journey for the
presentation itself I will show you an
example and I chose a non-trivial
example to show you some very more
advanced things than you know adding and
and ping-ponging or saying things like
that we need to have a better approach
and this did those tools help us when we
get into more advanced example so this
kind of is a more more advanced example
so I will do a short introduction and
then we will implement I will show the
implementation of three applications for
this particular problem and there will
be 15 overlapping concerns some of them
I will talk in detail some of them I
will just mention slightly but the whole
concept is what matters
so we will use cats in freestyle
libraries from Scala ecosystem then I
will talk more about freestyle and the
different approach and and Douglass
final so prisoner's dilemma again very
simple problem we have two prisoners and
they are both separated from each other
so they don't really know about
themselves and they are questions
interrogated and in isolation so they
can answer one they can answer in two
ways either they can be silent or say
that the other one is guilty so in this
one game we have four possible outputs
so if both of them say that the other
one is guilty they just get three years
in prison if they both are silent they
will just get one year so it's better
one and and of course when one of them
says that the other one is guilty and
and the other one remain silent then the
one that said guilty wins it he walks
two walks off freely and the other one
gets three years in jail and of course
the the other way around so the best
strategy unfortunately when you want to
minimize is to say that the other one is
is guilty and this is just one game and
there are many many researchers around
the world word about how can we use this
as a model for more problems that we can
see in society for example the game of
trust is one of them one of them so that
there are two to two people that are
playing there are two BOTS
there are playing number of games and
over the time the strategies can change
right so when when I say that the other
one is guilty or I remain silent and and
my friend also remain silent we get one
year but what happens in the if in the
next death game I say that I'm silent
and the other one says my friend says
that I'm guilty so he gets 0 years and I
get 3 years so what should be my next
move what should I choose in the third
round right
so here's the here's the strategy based
on the previous ones we need to somehow
develop a strategy of our own to
minimize the number of years that we get
from the those different from all those
years all those games so let's try to
create a whole infrastructure for this
kind of multiple games of prisoner's
dilemma and first one will be a hot seat
game so we are sitting at our computer
we are bored we want to play a game so
we we play with with computer right
sorry on one computer with our friend
and we of course in some kind of blanket
to do not show what we are typing into
but this would look like that in the
console because the console is what we
can use in this simple example so how
Adam and then the hello Jane and of
course we need to ask both of them about
their decision in this particular one
game so this is the whole game that we
want to implement in this in this
section of the talk so how would it look
like if we just use planes call support
we will need something like mid prisoner
yeah read line from the console returns
the prisoner then get prisoner decision
is the next one which is just also
reading from from the console and
returning a decision then we need a
verdict function based on two decisions
we just return a verdict and give
verdict at the bottom is just print
lining the decision for this particular
prisoner so this is the summary on one
slide with the implementations taken off
and we and the whole program is at the
bottom so we are meeting the world both
prisoners we are getting the decisions
for both of them and then we are just
giving them the verdict right so this is
kind of very very simple implementation
in playing Scott and my question first
quiz for you guys is what how many
concerns do we have in this in this
particular program that you can see at
the bottom so for as a kid hot seat game
is one of the concerns so the whole
algorithm of meeting
two guys then been checking the
decisions and then giving the verdict
how many concerns this is one of them so
I don't get it okay
my slides say four four blocks of code
sorry for blocks of code so we can see
that we have hot city logic and then we
need to be able to compute the verdict
so this that the whole thing the whole
verdict computation this is a pure
function which I'll show in a in a bit
yes this is a pure function so this is a
computing verdict and this is the only
one that is separated because there are
no outgoing arrows we just we don't need
need to know about any module at all
what we need to know is we we are
getting as an input both decision
decisions and the output is there ever
sorry the verdict so for concerns one of
them is separated the pure function and
the other one is the player interaction
so that we need to get a decision and we
need to give them a give a verdict and
the implementation of this interaction
which is print lining and redlining so a
technical concern and a business concern
all right and when we even for this
simple example if we use free we can get
rid of toast those two arrows and we'll
get player interaction as another
separated concern so we'll get one just
by using a different two so this is what
I meant at the beginning so this is
maybe a more advanced advanced one but
it makes us makes us to think about the
whole architecture of the software and
maybe maybe creating a new separated
concern so let's try to implement the
same thing but using a free approach so
verdict will stay the same this is just
a pure function so we'll just leave it
without the same implementation as
before and then player interaction so
this is when it gets crazy this is where
it gets crazy so this is how we encode
free operations free algebras in a
skaar using a Katz library so this the
simple functional programming functional
programming library first color so we
have a trade player this is the name for
the set of operations and final class is
we have three final classes that are
implementing this displayer operation so
this is this is jack those are just
classes and you can read them as the
name of the class is the name of the
instruction one particular instruction
and and the player is parameterized by a
type so this type in this player the
prisoner in this player means that the
whole MIT prisoner instruction when it
gets executed it will return the
prisoner okay so we have three
operations MIT prisoner get prisoner
decision and give verdict and give
verdict as you can see extends player of
unit that means that the instruction
when it gets executed will return unit
because this is a kind of sign that
side-effect under neath but this is just
encoding that is those are just pure
pure pure values all right and in scala
don't worry about that but i need to
tell you that we need to get some
boilerplate in in in scala and we'll
talk about it in in a bit
the more important thing is how we
encode that so this is what we really be
using the boilerplate is is not really
important right now so how will the
program look like so will not call the
functions as before me to meet get
prisoner that prisoner decision get
presenter decision and give her the gift
verdict we need something different
because we are not now creating values
we are not creating the values so the
same program will look like that so
we'll need to use for comprehension just
the same as in house do in Haskell for
those of you who don't don't really know
Scala so the like do notation so we are
creating just meet prisoner MIT prisoner
get prisoner decision the same kind of
structure of the code is there but right
now we our function returns free of
player of unit that means it returns a
value that describes the program and the
program is based on the player 3
player unit means again the player is
the instruction set and the unit is the
value that will be returned when this
program gets executed finally so that we
are using for combinations that means
there are pure no effects because this
program doesn't really run it's just a
description so now what we need to do we
need to create an interpreter for that
so we know that we have three operations
meet get the decision and give verdict
in our player operation set so right now
what we need to do is we need to kind of
transform that natural transformation
into something that will that can be
executed because for now until now we
just have descriptions this prisoner is
just the descriptions it's a case class
right so we need to be able to interpret
each of those operations into something
that will get executed and be side
effect he enough to have a game working
game using the console so we will
transform that into IO and IO in SCARA
and Cassio is just something that that
we can wrap the block of code in and the
block of code will not be executed when
we created it will get executed at the
end of the world which I will show you
at the end so this is one of the
techniques that that we are using in
order to have like pure functions and
pure transformations without the side
effects so let's try to implement this
this interpreter player into IO so
player operations free operations again
into IO so each of them we need to
implement i/o pattern match if it's a
preemie prisoner then we can twin time
to Incline get line things like that in
in an in an i/o so what I owe of a means
is it it is a description of a side
effect II kind of block of code which
will return a at the end of the
computation so that's that's the whole
whole thing so again we are using types
in order to describe the values the
programs the computations sorry
so connecting the dots again we can
consider same the same application hot
seat game two players playing at one
computer and that and those those for
concerns are now implemented using the
free approach
so we can see verdict is a pure function
hotseat logic is this program in for
comprehension which returns a unit and
the player interaction is our our free
free or player program which can be
interpreted into io and that's that's
all so we can now run it finally so
let's run it program this is the
function that we created using the four
conventions it returns free of player of
unit so when we run something like that
nothing happens the program exits and
that's all no game at all because this
is just a value so we need to fold my
bit and fold map it it means interpreted
in using our player console interpreter
so we are interpreting that into i/o so
if we run that nothing happens program
exits and no game at all what we need to
do is we need to run this i/o so we need
to unsafe run synchronously and we'll
get unit at the end this is what what we
really wanted to achieve and there's
some side effects which were also very
important right so the other side
effects is the game in the console that
we that we get the practical problems
were free again the only one is that the
boilerplate is in in Scala and of course
some additional thinking that we need to
do in order to create those concerns but
this additional thinking is not the
problem because this is what we really
need this is what makes us think about
our software more often but the good
news is that the freestyle library for
Scala which is pretty new it came out
last year for the first time it's based
on the what I shown you so it's based on
the cats library first color but it it
does some additional things to eliminate
the boilerplate for example so let's see
how it illuminates the bullet late this
is the same set of operations you so and
few slides back but using the free style
so as you can see we have this at free
chart player that means the player
instruction set and those free
operations but right now instead of
doing final case classes we are doing
just methods right or functions
at free in Scala is a macro which will
what it does it creates all the
boilerplate in final place classes I
will show you in in just a minute so we
have those three operations we need to
do exactly the same because we are
reimplemented the hot seat game again in
using freestyle and we'll use freestyle
toward until the end of representation
so how the interpreter looks like before
we had like case pattern matching and
cases right now we just we just need to
implement those two methods for this
particular interpreter so this the
implementation is the same we are using
io as our target type to interpret into
but as you can see it looks more natural
right for many of us so so this is our
application right now we can play on one
computer using two players we need to
cover ourselves to in order to not for
the other one to not see what we are
choosing so maybe it's not a good game
but but we are having fun so we all know
that when we create the first version
the infinite stream of new features are
coming into the software and we want to
simulate it right now so what happens
when we can't really play with another
player we need to we still our board we
have just one computer no player at all
we need to be employed we need to be
able to implement a bot right so this
would look like that we can we can
introduce ourselves Jaime how and then I
need to answer whether Wall is guilty or
not or not so I don't know what's the
strategy behind this but I don't care
this is a program and that I want to use
and play so let's try to implement that
and we'll try to reuse as many
components as many concerns as we have
already had so we need to reuse the
computing verdict we will reuse that we
will reuse the player interaction and
interpretation communication in the
console and the other ones will need to
be written from scratch
so let's first write our algebras
so let's try to write operations so as
you can see will just write additional
operations will not change at all the
code that we've already written so
opponent mid opponent and get open and
decision those are those two operations
that we really need in order to have a
working working game and the program the
program itself as you can see in the
Deaf program at the bottom we can see
that we have a player instruction as
implicit dependency and the second
dependency is this new opponent opponent
instruction set so in total we have
three instruction sets from player free
instructions from player and two
instructions from open and we are
importing them and we can create a
program using this using this approach
so let's see how it looks like and I
will need your help in order to
implement that so let's create the
program what should we do we are meeting
this new opponent and so may be opponent
that means that we get an option so we
need to map it and there are two cases
right when there's there's opponent we
need to create a new program because
this is a new program so we are you
using for comprehension so what should
we what should we really do here we have
this mid prisoner is already being
executed so we have met the local player
and now we know in this seven line 17
that we have a new opponent and we we
can use it so what we need to do in our
application right here pepto your
decision so let's get that decision for
the local player and what's the next
step
so roller yes thank you so now the
opening decision and what we need to do
here remember this is a game with the
book with a unknown opponent that that's
what I what is called the unknown
opponent right so it it is about at the
beginning but we'll implement these
different things later on so this is
unknown opponent we don't know who it is
so what we need right now we know the
local player right so what we need to
tell the local player
yeah verdict using the same and the same
function player decision and opponent
decision which we should get from where
from here so yeah
and of course so as you can see when I
say something like that that means that
is this is a result from this
computation that I don't care about
right and if we I care about this reason
I should name those variables and player
open and decision yeah so right now
player decision open decision give
verdict verdict player decision now it
doesn't work because we need to yield
we need to yield something so remember
this is this is a one case right for for
the mapping we are giving verdict so
what's the verdict with such a signature
prisoner decision and other prisoner
decision sorry okay yeah but we need to
tell what player what player we are
giving the verdict for and this should
go right here so when you go to the
verdict signature you need to tell and
that the verdict is for this player and
the verdict is what we are computing
here so now it comprise we are yielding
unique because the whole computation
will be a unit so again what we are
doing here is we are mapping the
opponent to the program that returns a
unit because this is a program so what's
the other case so get or else what
should we do when there are there's no
point unknown opponent so it may not be
there the board can not be created or
the player over the network is not found
or cannot kind of right now okay right
now what should we do this is one of the
one of the possibilities we need to pass
a program here right so again a function
that will return a free value right now
I'm just recursing over so creating a
new game
and waiting for a new player so this is
how it this is how it looks like it
should work work very fine so as you can
see this this is something that we can
use so the program is a value we can
pass them around and have fun so this is
this is me playing the hard ball and on
this on this bot so I walk up freely and
the but unfortunately needs to stay
three years in in prison so let's go
back to to the slides we implemented
this and it looks something like that
maybe on the slide it looks a little bit
better because I didn't make so many
mistakes but I need to tell you story so
when I first came up I came up with this
implementation in our own module to the
problem of concerns and I send it over
to one of my friends and he responded me
with in an image because he likes to do
that and the image I got is this is this
one so he didn't really like this hole
for comprehensions and you know what I
did here those underscores right and
mapping and get all ll sing and and you
don't really know what's happening over
here
so I argue that yeah it's not very
nice-looking when you first look at it
but when you get familiar with this
whole approach it gets better
the for comprehension helps us to think
about the software because what's inside
the for comprehension is probably very
pure testable and we can really think
about it more intelligently because it's
just one piece of code that we and we
know that it just creates and
description for a program it can it can
do anything more and when you are
changing something a module that use
uses some kind of for comprehension you
cannot just put a you know in function
another function which is side effecting
in the into the middle unit think about
how can I mean you need to wrap it in
operation what this operation is how it
really helps us here so this is kind of
approach that we are taking using this
kind of tools and of course single
player program we need to we need to
create
it's a program that uses both player and
opponent for the type of the free so as
you can see we are now using freeze
which is a freestyle version of free is
more powerful and we are using unknown
opponents as our instruction set that
means that the player and opponent are
both there as you can see at the top so
again we need to interpret it into a io
using our player console and then we get
console a compilation error we got
computation error because just one set
of operations has already been
interpreted it means that this player
console handler is the only one that is
that hand that handles something it
handles the player operation and
interprets this into IO
and we still need this bot stateful
handler which interprets opponent into
IO okay so this is a simple
implementation using var and BOTS and
map and and with some kind of strategies
and doesn't really matter this is just
one piece of code in one place somebody
need to think about the strategies and
anything and things like that so we just
put it here and we can run our our
application so this is our single player
application where you use as many things
as we as we could created a new
algorithm and created a new bot Handler
the print lines and all those things are
the same so the workflow is as false
define the operations using this the ad
free or final paste classes create
programs using these four comprehensions
then try and try to run them and the
compiler will tell you which hunter is
still missing implement the handler into
IO or something like that and we repeat
until you get a successful successful
game so I spot you a little bit at the
beginning of this section that I will
need another another interpreter for the
opponent opponent again is meet opponent
which returns an option and get opponent
decision and the other one is a remote
opponent so what we need to do right now
is we need to create a game which which
is a multiplayer networking okay and
we'll use akka to do that but the akka
will be just in one piece of code over
over here the whole application will be
just the same as the de-baathification
nothing really changes and of course we
need to think in intelligently about
that so let's create let's think about
how the algorithm for meeting their then
you remote app on and although they so
player a and player B the player needs
to register and then the player B needs
to gather the waiting players and join
if there's a player that was waiting and
the other one needs to check whether
someone join there or not and unregister
when the new game is created so this is
this is kind of approach that we can
take and of course when you do when we
do that we can just encode it using our
free approach which is just a new set of
instructions in new algebra matchmaking
that helps those five functions right
five functions one of them is wait for
opponent functions those three are free
ones register check and unregister and
second one is for finding the opponent
get waiting player and join and join the
player so right now we didn't really
have anything about AK about network
about TCP HTTP anything like that we are
just creating the descriptions
instructions which can be used so we can
use those those those those functions
those instructions without
implementation that's the whole point
right so let's try to create a new crew
in create a new program find opponent
program that uses this match maid
matchmaking operations so that it does
it just waits for players and then when
it moon the open and is found it joins
the player and if not wait for another
one so it doesn't really matter what
matters is that you can see greater or
less when with the free which is another
one another program so we are creating a
program which has a program inside and
all those instructions are really a
programs which are free so we are
passing free around and returning free
that means we are passing programs
around and return free programs which
can get kind of crazy but this is what
we really need because we need to reuse
them as much as possible so we need to
be able to treat them as values so we
focused on matchmaking and remember this
bot state handler which also implemented
the same opponent operations and now we
created
new set of operations for matchmaking
right so what we can do is we we need to
somehow connect those those those things
together we need to connect the remote
player with remote opponent concern with
our new matchmaking operation set so
what we need to do is we need to
interpret our remote opponent concern
into another program so we are not at
the top of the of those of the screen we
are not interpreting into IO we are
interpreting into free so we are
interpreting free program into another
free program
oh-ho-ho so let's let's look at it from
from the diagram perspective which may
be more click here again we did have
this unknown opponent logic and upon an
interruption opponent interactions just
to two operations meet prisoner and get
prisoner's decision and we get this bot
opponent interpreter which was this VAR
state map and all those crazy things
with variables and the right now we have
remote opponent so this is this is the
one that we will interpret into free and
this free is a matchmaking program so a
program based on matchmaking so right
now what we need we have all those
blocks to better connect it together and
only the one that is missing is what
really what it means to have to register
as a weight entire unreduced and
unregister are waiting player and things
like that so only those 5 instructions
from matchmaking is what we really need
to interpret interpret into in order to
have a fully functional fully working
implementation of a multiplayer free
prisoner's dilemma so let's do that
let's create this one missing bit which
is a remote actor matchmaker again those
five operations look like that and our
handler for them looks like that
so register as waiting is just this
exclamation mark is sending message over
and this is wrapped in IO and unregister
is also sending a message to the server
and what else
asking server for for the waiting
players so as you can see
not very very complicated because we
constraint ourselves to just think about
implementing those five operations and
we don't really care about how those
five operations are used in the real
program up when we define the defined
opponent and wait for opponent programs
so that's why we interpret it in two
different freeze so that we can have
very very small pieces we can think
about
so end-of-the-world looks very very
similar as with the two other
applications is first we need to have a
free of unknown operation that returns a
unit then we are interpreting into free
and we get another free but with
different set of instructions like more
low-level things those multiplayer
operations and then we are interpreting
into IO which is the thing that that
contains that all those tasks and tales
from the akka and print lines and read
lines no matter what you really want and
we get this unsafe run at sync at the
end and we get real real side-effects so
real game that works over the network
using the a career mode module so what
we get free game modes 15 concerns and
also each of them is separately testable
and in my github repository I will show
you at the end although those tests are
really implemented so you can look at as
a reference how can you really test
those separate separated concerns in
total isolation and then you can connect
some of them together and test this
connection also in very good nice
relation so we focus on small B bit bits
and we get all those a cos VARs end of
the worlds which are side-effect 'full
and the print lines fat sleeps is there
are some things I haven't shown you
really I don't have so much time so this
is what we get when we can split our
application using this very very simple
tool when you think about that okay so
now some of those things that are
problematic we three have already been
addressed but first I gives us any more
so let's let's go through and as a
finishing note let's go
through some of those those features
what can you really achieve comparing
algebra using modules that I showing you
right so we have like five different
operation sets and we want the function
that uses them so like dependency
injection some something like that so we
don't really care about how many of them
are here we just put them put them there
we can use them in real pure cats we all
need to really care about the order
because the other one way around it
won't compile so this kind of
boilerplate that freestyle eliminates
another one and free approach which is
really a value right the program
description is a value so it creates
lots of objects so this is very GC heavy
so we need to be able to understand that
this is one of the trade-offs that we
are making we we have all those programs
passing around but those are just values
we are creating and for each operation
that we are using we are just creating
an another object so in freestyle we can
use another approach which is called
final tagless and this is very very
similar conceptually to free but it
doesn't have this this drawback of
creating lots of objects so when you see
the free program right so it MIT
prisoner is really returning the free of
s of prisoner right and in final targets
it looks like that so very similarly but
instead of free we have F and F is this
type parameter with with a hole inside
and that's all
so the concept concept is very very
similar if we want to for convention we
will need to have another bound on on
this F type but other than that we use
the same kind of approach the same kind
of thinking but what we get instead is
is less GC heavy or operation so if our
program is really really GC heavy using
fee we can think of switching to tagless
and in freestyle it looks like that so
it looks like just changing the way that
free ad free into at-ats tagless so
semantically they are very very similar
there are the same
and there are different mechanics so my
approach would be four of you who just
first heard about for your freestyle or
final toggles is to use a Katz library
in Scala directly with a boilerplate -
you know to get the feeling then use
final toggles directly in any language
then when you want really to create
complications that are production-wise I
hope I hope after understanding how
Haskalah Z or cats will work and how
free is in implemented using this
boilerplate remove this boilerplate and
and have fun with freestyle and then you
can decide whether you want to use at
freestyle at tablets or at free whether
this is a GC heavy application or not
and there are also some more concerns
you need to take into account other
mirskiy wrote a nice blog post about
that comparing those two approaches so I
really really enjoyed reading that
because it is very very nicely written
with the table
I stopped shot some of those those
pointing from the table on the slide so
please have a look if you are really
interested into comparing free and
Douglass and of course the github
repository six applications because I
implemented the free application the
free applications and freestyle
application so they are basically the
same so that you can see the difference
between those two
and of course freestyle is there to help
and all those tests I talked about are
also implemented in both pure free
approach and free style approach and
there are two ik actors which are all
also tested because they are very very
small so it's very very quick to do so
this is as a reference for the
implementation okay
my name is me how I work at the color
technology and this is my Twitter and my
my page my blog and thank you very much
for your attention
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>