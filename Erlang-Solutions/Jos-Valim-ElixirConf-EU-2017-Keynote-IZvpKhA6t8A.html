<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>José Valim | ElixirConf EU 2017 Keynote | Coder Coacher - Coaching Coders</title><meta content="José Valim | ElixirConf EU 2017 Keynote - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>José Valim | ElixirConf EU 2017 Keynote</b></h2><h5 class="post__date">2017-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IZvpKhA6t8A" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">this is our turtle if your conference in
Europe and I'm very glad to be here
especially because in January 2017 this
year
elixir became five years old and that's
counting from you know when I did the
first commit for what elixir would be
today and you know you can go to github
and see the whole history everything is
there and you can see the Commission
because it what happened but what I
believe not a lot of people know is that
Alex's started a bit before that right
like I think 99.999 percent of the
population when they have a problem
their first answer is not I'm going to
create a new programming language right
so there are other a couple things that
happen and like to say a couple of
points of no return where you are trying
to find a solution to a problem and then
you can't find it and then you find
something new that completely changes
your perspective that in those points of
no return they eventually led to Alex
here so if you ever see me give a
presentation about Alex here
you probably heard the story so if you
go back to 2008 rails 2.2 was being so
was mostly doing Ruby and rails
development and at that time rings 2.2
was released and one of the big things
that came in rails to the true is that
rails to the true is now thread safe
right and this was really when I first
started to hear about concurrency and
multi-core there was already some
pressure from the community because they
want to get the rails application they
want to put into production and they
wanted to use it as many cars as
possible in their production machines so
there was some work towards rails for
making rails Fred face
okay and today when I look back at it I
like I I look at with the different
perspectives so for example so white
thread safety right so in red in Ruby if
you want to use all the cores in your
machine use palm thread so
they can each run different cars and
track safety means that if you want you
can you'll be able to get your rails
application make it use treads and your
rails application is not going to blow
up right so today when I look back I
find the word track safety or something
that is thread safe really really funny
because that's the lowest guarantee that
it can give you software rights like oh
it's not going to blow up imagine you
being a software company and then that
client comes and say hey which
guarantees can you give to me about this
product and say it's not going to blow
up is it going to be fast hmm it's not
going to blow up right we need more is
better guarantee okay it's definitely
not enough and I keep saying this like
specially so I hope you grate it every
year I have this thing this I think
since 2016 but I'd say like it does if
they would say in 2015 we should be
using all course your machine and then
last year in 2016 we should be using
your cars on your machine and again 2017
is the same story you should be using
all the course of the resource that is
available your machine like last year
Apple announced the new Apple watch and
it had two cores like your wristwatch
has two core okay so we got there it got
to this point okay and we want and
everything we do should be using on the
course compiling your code running your
tests okay and they're going to be more
productive because of that but as I said
you know I didn't when I later I joined
the race team and I was working on and
sometimes we find bug reports people
would say well when I run when I put up
a new server and it's on high load I
start to see some concurrency issues and
those were very hard to reproduce or
hard to debug and then at the time I'm
thinking well if concurrence is becoming
more and more important okay
we need to we need to have a good
solution for this problem right and then
I started to see what are the solutions
for for bring concurrent programming and
all this path of searching for solutions
I think my first point of no return was
when I found functional programming okay
and there are a lot of the
ways you can categorize functional
programming but for me at the time and
to a big expense to today functional
programming is one is about having
explicit state in contrast to implicit
state right because if you think about
object orientation right one of the
reasons we have object orientation is
because want encapsulates state so we
have paid hidden side of objects that
all other objects have on other objects
like to have this Russian doll of state
and and it's really hard to reason about
it when you're writing concurrent
Suffolk does imagine that it has two
different cores right at the same time
and they are trying to change the same
state it's hard to find the situations
okay so I realize that well if I was if
I had this rule where I was making this
tape explicit as much as possible a
bunch of those issues that I'm really
struggling to find fixing the bug they
would be much easier to do so and not
only that right instead of most daily
things we transform them so analysis to
have a list and then you delete an
element from the list you don't mutate
the list to get a new list in place okay
so that was the first point of no-return
like if I was using those rules I'd say
those guidelines my software would not
only be better for concurrency but I
think it would also be clearer okay and
then I started to look more and more
into other functional programming
languages and I started to get books
read about everything else other
languages could do what we're doing or
call the benefits and there was one book
that helped a lot with the process which
is 797 weeks which is kind of in front
our book around the different ecosystems
in the different languages but from
there it really helped me in O to
compare those language side by side and
Airlink really stood out okay so that
was the second point of no return when I
and when I was done with that book and
then I started to study more and more
early I was like the software that I
write I want to run on this virtual
machine because while a lot of people
were focusing about concurrency
Ireland for them it was like no
concurrency
it's a solve a problem we are we are
worrying about distribution so while
everyone's thinking how can we use the
resources of this machine as efficiently
as possible
they're like well at some moment one
machine is not going to be enough and
they need to start using a lot of
machines to work towards whatever you're
doing for towards this common goal so we
need to consider distribution and they
did that in a way that we use the same
conceptual model which are processes for
doing concurrency and distribution so it
has this unified view which I sounds
beautiful
okay so and and then I started to work
more with Erlang study more and I like
to resume this mutual experience with
Erlang that I loved everything I saw but
I hated the thing they didn't see so I
was missing ways of doing meta
programming I was missing ways for doing
polymorphism I was missing a first-class
Unicode support and other things like
that and that when you get I had this
idea well what if I trying to create my
own programming language that is going
to try to solve those issues and that's
when it started
so it started the very beginning of 2011
and here is the commit graph so you can
see the commits so this is one year
before the elixir that we know today
right so you can see the number of
commits throughout that year of 2011 and
that's when we started and you can see
that at the beginning was really very
excited about this idea right like
they're a bunch of commits okay and
about April 2011 which is when the
number of commits started to go down
here's how elixir look like okay we
actually had something called F object
to define object so it was a objective
and object oriented language right e to
use a prototype object model okay the
way I did meta programming at the time
is that I used evolve everywhere so I
just pass it strings around and I was
used to evaluate them which is a stark
contrast to we've added here today like
manager today if you are calling evolved
there's probably you're probably doing
something
we should not be doing all right it's
completely the opposite right and then
so what I was doing here at the times
that I was just adding things on top of
things I was not really leveraging the
virtual machine delivered from machine
in the earlier on time so it was low it
was extremely slow and it didn't play
well with Erlang at all okay so we can
say that you know Alex here as at that
time we can say it was a rookie mistake
no didn't work all right okay so I tried
when Jim sided for the Star Wars they
actually went to add a page with the
Star Wars puns and that was the one I
like the most but all right
okay so Alex here as of April 2011 you
can see here that as a result of these
electric version okay you can see that
in April I started committing okay and I
say that I reach the depression valley
which was the moment that I realized
that this thing I was working on and
being and I was excited about for the
last four months it was really really
bad it was not good at all and you can
see that April was followed by a very
big spike in June where I thought like
actually I can make this work and then I
try to make it work and then realize
that nope right
I could not make it work it had
conceptual issues and if you are and I
told the story at the first electric
conference now it had in 2014 lasting
who was there all right a couple that's
great right and then I show this image
which I think shows really well what was
built in that moment is that I knew what
I needed of Island I knew the shape I
knew what I wanted to get true like I
knew that I wanted metaprogramming I
knew that I wanted polymorphism but I
had no idea how to get to there so I was
just like trying to feel leave the
things and trying to find a solution in
whatever way I could okay so at the end
of this process it came from positive
things right I was able to get to the I
was able to understand
this is a lot of bills which is really
important right I just didn't keep going
on and I was able to come up with a
little goal so you know what I want this
language to be productive because and
the time already having discussions in
the airline questions mainly say well
you know someone that is coming to
airline needs to learn about functional
programming he needs to learn about
concurrency needs to learn about
distribution is to learn about fault
tolerance okay how can we how can we
make people that are joining the
language that reproductive right and
there are a lot of ways that
documentation having a good tool and so
I said okay I want to be productive and
I want not only the long term
productivity but the short term
productivity as well people should be
able to have a good experience getting
started and then I said I want
accessibility I want to have
polymorphism okay and I want to have a
ways of limited programming so we can
exchange so we can expand the language
and at the bottom here the third goal is
compatibility and it's basically you
know if I'm building this language
because I want to leverage the runtime I
need to be compatible to the wrong time
if you knock this low I cannot I should
be between integrate reserving okay and
after thinking about this we have the
first big breakthrough after this use
Molinelli stop what's something that I
work with the hood called lag length and
the idea is so here's the problem that I
was thinking about at the time okay I
want to have meta programming and it was
clear that if all was a very bad idea
and then look at other languages I came
back to Lisp begins
and so this macros I said okay macros
the way we have in is they are really
really flexible okay but they're not
enough because we already have two other
lisps at the time running in the our
inverter machine and i did not want to
create yet a third Lisp okay so I was
thinking how can we combine lift macros
okay we paint natural syntax let's say
you know like a lip piercing that right
not only that since macros are extremely
flexible how can I guarantee that they
are explicit
it okay in the solution that we we came
for Lego Lang it's very similar to
holiday to work today so in Alex here
when you write something like adds one
and two internally that is represented
in the ASD that's represented by load
which is a total of three elements where
the first element is the function aid
the second element is a bunch of
metadata and the third element are the
arguments which in this case are the
numbers one and two and then we said
okay so that's the base language and now
we want to add a couple features to the
language but without modify these
underlying abstraction as much as
possible so it came with okay so now I
can have optional parentheses but that
doesn't change the representation or
presentation of the code is the same
right so Wes Mac what macros are aligned
was to do is to represent code as data
and then have macros that get this data
and transform this data and then make
more data and the operators are the same
thing they have the single presentation
it just happens to change the function
name okay
but in practice is we don't write those
nodes by hand what we do is this so
here's how we can you can implement
unless an Alex here unless malloc sphere
is just a macro it's not a keywords not
anything special and what it does is
that so quote is something that can
generate those ast for us so we say that
while we are receiving this data and we
want to that represents code and we want
to convert it to something else okay and
then we could worthy to a negated if
which is unless basically is so we
started to go into interaction okay we
can still have the natural syntax but we
can still have macro starting to get the
both pictures that we want it and then
at the end we said okay and in order to
guarantee explicitness every time i want
to use a macro i need to explicitly
require the module that defines it right
and that means that macros are lexical
and that's extremely important there is
no way in alex fear that you can have a
file injecting in
in some other file that is going to
change how that other file is compiled
that cannot happen its lexical so before
use a macro there is going to have
something above that line okay somewhere
in that file above that line that says
hey I'm using this module or in
requiring this module and it keeps it
explicit and bounded to a single file
okay
and not only that macros are
compile-time only after your compiler
code it's not going to the system's I'm
going to change and start
metaprogramming things at one time
you know when it's it's when it's
compiled it's over I like to say that
this is like same infinity right like
you can do a bunch of crazy stuff but
it's bounded to some particular
properties it's bound and per file and
it's bonded to compilation time only and
then hooray right I when I define these
I defined when I was done with this meta
programming with labelling we had not
only how I wanted the language to look
like and how I wanted to do meta
programming but I knew how we develop
the language because if we have those
properties we could we could use Alex
here to implement Alex or itself and
that's pretty much what happened so if
you go to the lecture code base the huge
majority of the standard library is
written nella clear itself okay and it's
thanks to those properties that allow us
to bootstrap the language and write a
lot of the language in itself so at the
end at the beginning of 2012 I went to
micro far as a platform attack and I
told them pretty much the star as a hey
I think there is a chance we can build
this new language that is going to focus
on productivity accessibility it's going
to leverage their lyrical machine and
and I think that is something that you
know a concurrence is becoming more and
more important it's something that we
would be able to start to use in the
next you know three to five years and I
went to this proposal because I wanted
them to allow me to work part-time on a
lecture initially and we all accepted
the proposal and you know and that led
to the time that
we're kind of like familiar today right
so a plataform attack accepting - you
know - were kinetic serious part of the
company was also really important
because we started to put company
resources into it as well so for example
the logo came you know from the our
designers platform attack and thank God
I was not the one designing the logo
because maybe we wouldn't not even be
here at all
right so and then I started working it's
part time and then book is planning to
come out altars were working on books
and then I started to work on that next
year full time which I have been for
like three years probably more than that
and we reached Alex e1o in September
2014 it was right after the first
electric conference that happen in
Austin and at the time already had more
than 180 contributors and we had three
books almost off the books already they
were just waiting first to say Alex
Romano is out okay and then that was in
2014 and now we just got in January kind
of like a celebration of the five years
we got Alex 0.4 out and we have more
than 520 contributors so thank you for
our contributions and this is
unfortunately only the code
contributions but I know that a lot of
you are contributing to the ecosystems
in a bunch of different ways right then
we are very thankful for that one of
those ways exactly for example packages
on the hex game hex PM started the
package manager for Alex Siri and became
the package manager for the whole
airline get consistent and we are
reaching almost 4,000 packages and I
know there are events happening now
around the world we have events happen
in Japan Mexico South America other
events happening in Europe so those are
great and then we have books podcasts
online online classes a bunch of
different ways to learn the language so
the community really stepped up and is
bringing the much-needed diversity all
right so that's Alex 0.4 and then the
next step is going to be Alex you want
apply and they are going to talk it's
very very very briefly
bit later but one of the things that I
from those five years one of the things
that I still like the most it's exactly
to be here at a little conference
because since the beginning of Alex here
when we started to have like a working
version I started to go to other
conferences and start to talk about
Alex's or to go to meet up and there I
always have to assume that the audience
never heard about a lecture at all right
and which is the difference here here
you know I hope everyone here heard
about an extra at least one otherwise
are probably you should go to the mid
forum because you're either on Roman so
and that's great because I can talk
about things that I wouldn't be able to
talk otherwise and explore concepts in
different ways that I will be able to do
otherwise so what I want to do so we are
20 minutes in okay so what I want to do
is that for now I want to explore what
is Alex here and that's going to be that
if you're closed version and then later
I want to talk a little bit about what
is happening in the future
and just glance for that very quickly
okay so what is Alex clear and this is
the electrical portion right so as I was
saying if I was in those other events
and they asked me and I'm introducing
Alex here I would tell them like Alex
here is a functional concurrence and
this repeated programming language for
writing maintainable and scalable
applications which is the description
that we have on our website and you know
it's a very reasonable description but
for the conference I want to make a
twist when I asked what is Alex here
what I actually want to answer is like
what is Alex you're made of okay so the
goal of this part of the talk is this so
I want to talk about those three
components data types modules and
processes with the hope that if you
understand how those three concepts
exist and how they relate to each other
you have all the background necessary
for understanding how your software
actually works in production so we are
going to talk about how I like to work
not the compiler not the syntax we are
going to talk about the runtime
highlights through words
the runtime okay but before we explore
those three things here okay we have
those three discrete things let's take a
step back okay I want to talk about some
mutable old language you can do whatever
language oh and the reason I'm doing
this step back is because it's very
likely that 99% of you it's coming from
a hole or mutable language background so
I have some lip of code here which is
saying Dictionary dot store so we have a
dictionary variable that holds the
dictionary object okay and then I'm
calling a store method that's in two
arguments the key and the value
okay and we can see here that the
dictionary has an object what it does
that it exactly it encapsulates the
state okay so it has some state that is
the internal dictionary which is this
internal key value store presentation
okay and this poor is the behavior that
is associated to that object right so
objects they couple this statement they
put state and behavior together that's
exactly what we can see in this piece of
code okay so that's how what we get with
object however if it's a bootable check
oriented language we have another
concept here which is exactly time
because at the moment so I have a
dictionary at the moment I say hey I
want to store this key and this value
that thing is going to rotate it's going
to change itself and have that key is
turning itself right and the reason that
I say that this represents time because
from an external perspective right
something happens that that's been
changed that thing was not static right
something happens somewhere let's make
that thing change and that can even lead
to things like laws of information
suppose that we imagine that the key
that we are trying to store it all
really existed in a dictionary with a
different value when I roll in this
operation here when I call this Mac that
Mutato dictionary it's going to change
the key to a new value and information
is lost there is information now that
just disappeared right is not going to
be referenced anywhere and then we're
going to have a garbage
I was going to go and remove it from our
system okay
so there's clearly time faster here
because things are changing right what
makes it hard to understand software in
those cables is because every object has
its own notion of times right so in a
lot of languages something some language
these trainings they're immutable but in
order limit restringing they're
available which means that when I'm
passing the key and the value they have
their notion of time as well so as you
create a bunch of different objects each
of those can rotate right and each of
those can rotate on their own so each of
them have their notion of time that's
what makes it that's what adds
complexity to softer right because you
can have all those things that can be
changing at any time at simile a related
way ok so what we did so what happens in
alex here is that those three things
they state the behavior and the time
they are completely put apart from each
other
ok we put them into those very three
distinct things so we have the data
pipes and they represent state so we use
the data facts
to represent the state represent the
data but they are immutable we cannot
change them so they are great for
modeling this state but you know we we
cannot rotate them they don't have this
notion of time tied to them and then we
have modules which is where we write our
code with functions and that's why we
put the behavior and as we're going to
see there is no beta empirically
associated to the behavior everything
that the behavior needs to have to work
its passive as an input and everything
that the behavior needs to return as a
result that work needs to be given out
as an output ok and then we have the
processes which kind of puts everything
together and adds this notion of time so
here's how it would write that code
right in an expiry so we need both data
and modules so the data here for example
now we don't have this increase this
implicit data that is passed around we
need to pass the map which is our
dictionary which is how I call
dictionaries analysis
we need to pass it explicitly as an
argument right in each argument is going
to be just as just data okay in the
behavior it's defined in modules and in
an extreme part is our behavior are
identified by the module name the
function name and the number of
arguments yet that function expect so
here our behavior is map dot put slash 3
which is the map which is the foot
function in the map module that exact
three arguments and let's say that's
data and the modules together and in
here we don't have we don't have time we
don't have notability okay if we want to
have durability which we also have time
we need to bring processes into the
equation ok and processes put those two
things together because here's the most
massive way of starting a process
analysis we call it spawn and we pass
three arguments so the first is the
module name the first the second is the
function name and the third is the
argument there are passes to that module
function so you can see here that when
we start a process we need to give the
behavior that we want that process has a
killed right so we are giving the
behavior to the process and the
arguments that we pass is the thing that
represents the data right and that's our
state so when we start a process it's
putting those two things together okay
and then if I wait to look at the code
is when it can look something like this
right
it looks function that has the data that
belongs to that process and the code the
behavior here in the middle which run
sequentially okay so I want to do a very
quick pause to just say ascertain the
separation apart here is extremely
important so sometimes we we someone
says even the boo so called a lot of the
code in galaxy it's wrapped between the
do and the end words right and sometimes
I have the question isn't do like a
weird word for a isn't like an
imperative world in contrast in contrast
to functional and my answer is usually
no like because what do is about is
about sequel
imperative programming is about showing
progress through the mutation of state
right and that's not what we are doing
here
so the do is there to tell you that the
Cole data right there is going to be
executed in the order that you're right
so exactly right I wrote here called run
sequentially okay and even if you look
at other languages like Haskell the dude
there it's not about imperative program
necessarily it's about running the
instructions that are fast and
sequentially and these mirrors exactly
that how we write a little code okay so
we have those processes they have the
data and they have a bunch of code that
we run sequentially so at the end of the
day okay we can say that processes they
all the data all right and they run the
code which is the behavior without
specified by lodges and functions
sequentially if we know that we do not
have only a single process when we run
our code we don't have only one of those
have a bunch of them running side by
side and that gives us the idea of
concurrency okay but you may ask okay
so that makes sense but what about time
right we said that processes are the one
responsible for introducing time and
where is time being added here right if
you have a bunch of processes running
side by side concurrently completely
isolated from each other do we have a
notion of time we have this this
question distinguishes if a tree falls
in the middle of the forest does it make
a sound
right which is if I have all it which
means for us like if we don't have
anything observing if there is a sound
not does it actually matter if it makes
a sound or not right so it have a bunch
of processes that they are already at
the same time but they don't really know
about each other
so what does it mean right do we have
time and I think that the answer is no
right we don't have time because we they
don't have any other reference besides
their own okay so when we think about
time in an expiry and in particular
which processes the reason we do that
the way we do that that we do is message
passing right so I have to process
and then I send a message to another
process and that process sends me a
reply back right so modeling now have
this notion of time because I know that
in order to get that reply I sent a
message first so there is a very good
relationship between cause and
consequence and that's what I like about
message back things exactly that it has
this beauty an idea of cause and
consequence to it that makes it easy to
reason about time the system how things
are progressing as we communicate with
each other and remember that I begin the
talk that I said that one of the things
that I like about the original machines
that we have the same abstraction that
is used for concurrency and distribution
right and it happens that message
passing it's a very good way of modeling
through the system as well at the low
level at least right and that's the same
abstraction that we are using in the
reason why this matters reason about
having good ways for modeling time in
modeling concurrency there is its
importance because without a good mental
model concurrency rubycles trained by
Amdahl's law ok so what is M does long
end of us say the following
and those law calculates the potential
is speed up that we are going to get in
your software if you increase the number
of course okay so here for example we
can see that we can see the lines here
so if 95 percent of my code can rarely
parallel for the parallel portion of
micro-sleeps 95 percent of my code we
can see that as we increase to you know
one thousand four sixteen thousand four
we are getting benefits right however
it's only 50 percent of my code is
actually can actually be parallelizable
you can see that after 16 cores we
pretty much don't get any benefit
anymore right like when we have four
cores already like 80 percent there and
then when we get to 16 there's pretty
much no reason to go forward right so
you know it's still not some magic thing
that they're going to we are going to
choose
current language or the language that
are using today it's going to add treads
right that's not enough you need to have
a good mental model because if you don't
have a good mental mental model you're
going to be constrained by this so we
need to have good tools that allows you
to look at a problem and say hey I know
I can understand I can model this
problem using tools that allowed me to
leverage problems that allow me to
leverage concurrency this way when we
get to you 64 cores 128 core right we
are still getting a reasonable speed up
right but processes they go way beyond
concurrency okay we already hated about
distribution so when to create processes
right so this is a verbal time to do a
very important disclaimer processes in
Aleks here they are not called designed
tools you don't create processes to say
oh like I have this new concern in my
application or a new concern in this
domain I'm going to create a process to
manage it no processes they are real
time they are tools to reason about
runtime properties to reason about
concurrency so when we create processes
if we need to have a little state that's
one a good thing which is the example
have been talking about or even if you
don't want to have mutable state you
just want to have concurrent execution
you want to start eight plus eight
processes where each of those is going
to fit fetch a different URL and they
never actually communicate between them
just for concurrent execution how every
also creates processes when we want to
handle and isolate failures if there is
something that it is acute and you
actually don't care that things fails
and succeeds you start a new process and
have it run that and then you know if
it's over it's going to be the tree
that's all getting rid of the forest and
nobody's watching it right it's over and
it's done I don't care about the result
okay or we also use them for modeling
distributed communication okay so at the
end of the day we can come back and look
here and say you know those are the
three properties the three primitives
that we have in our elective systems and
that's and what's the
the runtime uses to to work with and run
your code okay so we have the data types
that are state immutable state we use
that represent a state okay we have a
variety of data types to make this
representation of of state
straightforward that's why we have
pattern matching right which is put a
state upfront
okay we have modules which is where we
put the behavior and we have processes
that allow us to model different things
including time right and that gives us
concurrence it gives a distribution it
gives all tolerance but they're really
beautiful right because it's a single
abstraction with a couple parameters
around that was able to model those
concerns okay
from the design perspective I found
those things really Pleasant right
because we don't have a different
concept for each there's there's the
downside which is overload of a meaning
overloading of a - right but when it
applies practically is finding the
proper trade-off there it's really
exciting and I think processes which
come from the our network of machine
it's exactly one of those all right so
that's what is a lecture okay the elixir
conversion and now what I want to do is
that I want to move to the last part of
the talk where we're going to say a
little bit was what is common in the
future so Alice here 105
good news there is nothing big planned
[Laughter]
right so I really like the Alex remodel
for endings because it was our smallest
release since we had one no and it kind
of reviewed the direction we want to be
in and I have to be saying that since
Alex Irwin o is out like like to say
there are two kinds of 100 releases
there is one which is we're just getting
started
right and there is the one like he
biggest deal right of course are going
to continue improving things and
continue moving forward but
that's pretty much the deal right so
when we look at the previous lies there
with the data the behavior and the
processes right we we already added the
extensions that we wanted so let me row
back is it we we made a bunch of those
things to be morally right so for
example in Aleks here we have protocols
which is about doing polymorphism on top
of data types
it'll also try to code like this hey I
don't care which data type you give to
me
I just can't that implements this
particular protocol this was this was
one addition that Alex here brought to
to the original machine so it kind of
like well the data types in modular
process yes they come from the runtime
they come from our link but we improve
them it made kind of add a little bit of
our own spice to it right so data types
they are the protocols in modules we add
a meta programming so the meta
programming that we do we do that on top
of the behavior we do that when we are
defining the modules and that's why it's
compilation time only because after the
modules compiled it's over right and the
one that we actually let's say that we
improved the list was processes by Alex
you will know our most the biggest
improvements that we have done at the
process level was exactly to add tasks
and agents and just later on that we
started to play more with this process
area okay where so for example there's
gin station flow which I'm going to talk
about so mature which was adding a new
behavior to processes and how processes
can exchange data but anyway the point
is that we are doing a small increment
right there are no big revolutions
happening here and and what it happens
that we are going to have releases where
you know they're just maintenance
releases we are fixing bugs we are
adding some small features or small
properties and that's it so there's and
that means also that there is a lot of
space for contribution as well so if you
go to the issue tracker like you're
going to see the issues there they are
all going to be categorized by
application
by their difficulty if it's a discussion
if it's something that is already to be
implemented and you can join the
discussion either this tracker or in the
elixir link or manganese okay so this is
good news really like we are keeping it
really is going to be another small ones
that are going to recruit you're doing
small steps however it doesn't it
doesn't mean that you know it's over and
I'm going to see nothing different
coming to the language we are still
we're still exploring things and they
are going to come from time to time at
their own pace and one of them one
example is exactly Jenny Station flow
oxygen station flow we're actually
working on it for two years trying to
find a good model for modeling the
problem we had at hand so what a Jenny
station flow for those who are not
familiar so Jenn stage is a new behavior
it's a new clean that we we use to model
processes and it's all about exchanging
data between processes okay so it's
about optimizing this case where
processes they need to be communicating
large amount of data between them it's
also about back pressure so if you need
to contact with an external system
Jenny stage gives you tools to signal
how much data you want to consume right
now and flow is something built on top
of Jenn stage that allows you to express
computations like MapReduce cuter sort
and we are going to get this computation
and automatically parallelize everything
then use all the core machine right so
as I said those are improvements that we
are doing more at the process level
those abstractions built on top of
processes and we worked on it for two
years with the original goal of it being
added to elixir but at the beginning of
this year we realized that we are going
to keep those separate projects because
it kind of created a life on their own
and we brought some of their lessons
some of the things we learned here we
brought them back into elixir so alex
0.4 has a feature called task async
string that gives you a purpose a
potentially infinite source of data and
then you can control how many tasks you
to run from that source of data at the
same time so if you have for example or
even a cynic sorts of data imagine that
you have like 800 URLs to the same
domain and you need to fetch all of them
in multiple in parallel right you cannot
start 800 at the same time because it's
very likely that whatever they are using
like a proxy or surface will say hey
know what you're doing we're trying to
open 100 connections alright so you want
to keep that volume on say ok I want to
open eight and eight at a time and this
is something that you know initially we
wanted you to use any stage and flow for
that but we learned some lessons here we
could bring that directly into Alex here
while keeping changed angel apart ok so
but for all purposes Jen station flow
it's done it was a research project that
we were at it for a while and it's done
right now we focus on a single machine
so it's focus at concurrency eventually
we want to make a distributed but that's
a star and that's going to come much
later ok not now so if you want to learn
more a very good starting point is the
Jen's announcing Jenny stage blog post I
also gave a keynote presentation at a
lecture conference United states-led
last year that was talking about exactly
Jen station flow so those are two very
good research introductions another
project that we activ research project
we're working on is to have utf-8 atom
and so in a lecture we always favored
Unicode right was world reason I
actually created Alex here I wanted to
type my name without having to do a
bunch of weird dance with characters so
but atoms they still into electro right
now they are still lacking one right so
you cannot have the eros time on an atom
you cannot write Japanese characters ok
but I'm very glad to say that we have
made some really good progress in here
and there is a chance that by Alex Siri
one of five will be able to write code
like this you'll be able to say tests
that have a role I think in Japanese and
it's asserting that we have a atom
written in Japanese and and actually the
reason why
so here we have actually have two
features because the six Tests they
become functioning the first feature
that we need is to be able to write
function names as well in a Unicode and
then we have the atoms themselves and
it's really funny because when this
problem became apparent to me when
someone opened up an issue and they said
that they could not write a test exactly
with or the pound sign or the Euro sign
in it so they could not have an attached
description those crackers and then it
realized well that means that for
example is someone from Japan trying to
write their class description Japanese
or having Japanese crackers they simply
cannot do that and that's very likely a
horrible experience so we've worked it
together with the OTP team so there is a
whole huge discussion you can go to the
link about changing how atoms are stored
in the compiled code and that is merged
that's going to be part of the airline
20 release which means by Alex 0.5 if
you figure out all the details if I use
the electrode of five an airline 20
you'll be able to use utf-8 in your
atoms initially so you can't have utf-8
or any coding things in your functions
yet but so you cannot use like the pile
of emoji for a functioning I'm
sorry but you can do that for atoms and
iris and other things something and
that's in progress and we are hoping
that we are getting there okay by 1.5
which should be by June July or
something like that but we have other
ideas that we are exploring and they are
very early research one of them is beta
strains and property testing so in a
lecture we have this thing called
streams which allows you to lazily
generate data right but the way we use
trains today many of the ways it's
mechanical I can it'll need to grow and
build a stream yourself and what we are
thinking is what if we have daily
streams we have if we were able to say
hey I wanted to give me a random stream
of integers I wanted to be me
random stream of strings of binaries
off-key or whatever world of positive
integers okay so so what if we have been
strains in the language and n where if
we not only use those data streams to
generate data but also to validate the
data it's kind of like a daily
specification if you are familiar with
closure is back they have very similar
ideas in there so the idea is like what
if I can specify like the shape of my
data and from that I can validate
external external data I can validate
external data conform to this
specification this format I described
and I can also use it to generate data
when I want if we have that we can have
something like property testing and the
I do is property tax and so in Aleksey
we have the string module and we have
this function called start Swift which
is checked if a given string starts with
the other string okay and you know when
we implemented this function I need to
come up with examples out of my head I
need to say okay I'm going to use full
and bar to test those strings and then
we create some random examples right but
what if the examples I'm coming from
ahead they're not actually good or if
I'm missing some scenarios what property
testing allows the to do is that instead
of coming up with specific examples that
we write in our test we define a
property that we want this thing to
activate so say if I have two random
strings okay and I concatenate them then
it should start at the beginning of the
first string the concatenation that's
the property then I want this code to
activate okay
and that's going to take the burden out
of those of generating all those test
cases which is really excellent but to
me the next that's very good a purely
for property testing but the most funny
thing I think about property testing is
because it's actually a very good design
to and I chose this example on purpose
because we are trying to figure out at
some point if the string starts with
should
except and strings so what happens if I
have the end string that first argument
and an empty string a second argument is
it true or false should we allow that
and then to solve the problem we
actually paint tolerance and said hey
affirm what if you were to write it
property for this function which
property would you write and then he
wrote this property and he said
according to this property we should
have we should support them strings and
it should return to if I'm asking
finance string tax with an empty string
because that's the simplest property
that I can come up for this and they
were like done it's going to set them
strings and then we merge the proquest
and we lived happily ever after
so but again barrier research they are
going to have won't have more
information right so I don't know okay
something that we are also exploring and
this is Excel he is doing that as part
of his master thesis so again Jenna ctp
and it's very early research and what we
wanted to do here so we have a bunch of
HTTP clients in the community okay but
all those times and they do the job
apparently well okay but all those
clients they try to be a complete
solution they come with their pool they
have their own session storage they try
to do everything they try to bring
everything ok so and but sometimes we do
not need to bring all that complexity
like sometimes we want to have a smaller
abstraction to start from and then build
on top of that and that's exactly what
Jen HTTP is about so J HTTP is about
modeling HTTP at the process level so
all it does is going to hey you can
handle those things at the process level
and that's it you can think it of a
wrapper around the low-level anticipate
and then it's up to you it won't have
the same process starting panics creepy
connections you can do that if you want
to have a pool you can do that yourself
okay but the goal here is to have a
better foundation that is more flexible
that everyone is going to build on top
ok because we don't want to go in a
scenario that you know every year we
have a new h-2b Klein
of the year okay that's not what we want
to go to and we want to have a unified
foundation and allow everyone to build
what they want on top of that and
finally there are two other projects
that so we have this Google form of code
where we have students working on
projects and we had a break last year
but this year we are back and we have
two projects that we are hoping there
will get accepted the first one is the
elixir for matter so the idea is that we
are going to have a tool that is going
to go out there code and format it
according to certain rules so we don't
need to have style discussions or what
is preferred what is not preferred so
again this is the project that we are
going to start as a prototype trying out
some ideas in the Google form of cold
and you know all those ideas I forgot to
say the disclaimer but all those ideas
they may be I may be talking about them
next year
or I may be talking about that in five
years or I may be talking about that
never ok so again if they are we are
looking to those things that we are
exploring them but there is a lot to be
validated if you and the other Google
server project code a google Summer of
Code project that we are interested is
the language server protocol so then we
serve a protocol is an idea that came
from Microsoft and we have a bunch of
actors today right we have a bunch of
programming languages and we want those
actors to support all those different
programming languages and each language
and it editor has its own combination of
tools and things so we have like a M or
n matrix of protocols the things that
they used to communicate yeah use the
Lync Server protocols to have a common
thing in the middle that all editors are
going to talk and all levels are going
to talk so we don't need to reinvent
editor support for each editor in each
language and that's another Google form
of code idea that we are hoping it's
going to get accepted they will be able
to see some advanced segments throughout
this summer all right so that's like
what we have been peeking on lately for
the long term rather than the short term
the short term again is in Asia tracker
in the main discussion
it's always their development has always
been clear and explicit that's it and
finally I want to thank plataforma tech
so Alex here and you heard the story so
Alex Erie was built and designed since
2012 at platform attack all right so if
you are looking for thinking about
adopting an exterior and interested in
coaching any kind of design review or
custom development let me know heaters
up and yeah so that's the talk about
that exterior thank you for here
I'm so we're going to take some
questions over here thanks so much they
fit that was really awesome
but can you Renee's any questions we
have it Mike we have a mic up here and I
can come meet you as well so any
questions hands raised if anyone wants
to ask all right we have you're in it
you want to come over here or I mean I
can I'll run around and catch it I
wanted to ask about the probity testing
and I wasn't sure about the tests
there was one test and you ride the the
string streams yeah how many different
tests are running then yeah so property
taxes tools and Thomas who even be a
better candidate for answering this
question but all the things they are
configurable you can say I wanted to
generate plenty samples or you can give
it a time-based thing you can say well I
wanted to I wanted to run for one second
and all those things you're it's going
to be you can configure it at the common
line level for example so far helping
your machine you may want the team to
generate ten samples and that's it but
for our building productions you may
want to say hey I actually want to make
this thing time base and have those
things try for one second to generate
data to really hammer out this function
so you have different have different
parameters that you can use to control
and those things will be flexible enough
that you can control how much or for how
long you want those things to happen
depending on the environment that you're
run cool thank you for the question yeah
anyone else have a question
super we have about five minutes for
questions huh I just want to add to that
so say yeah yeah so this is property
based S is already there so if you want
to kind of experiment with it just
download a key CX and quickcheck mini
and then you can do these kind of simple
properties where you specify your code
instead of writing a test case you said
something more general about your code
and you generate your test case
and then the matter of how many best use
the parameter right and you can you can
as I said put that in there
the difficulty is to come up with the
properties what should my Co do but
that's also do the nice thing of it
because it makes you think about your
code and that's something which you
really can appreciate if you've done
this for a while yeah Hank Adamo thanks
does anyone else have a question
going once going twice
alright so that's that's a wrap so we
think we have yet everyone another man
replies okay</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>