<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Tomasz Kowal - Elixir and Elm - the perfect couple (Lambda Days 2016) | Coder Coacher - Coaching Coders</title><meta content="Tomasz Kowal - Elixir and Elm - the perfect couple (Lambda Days 2016) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Tomasz Kowal - Elixir and Elm - the perfect couple (Lambda Days 2016)</b></h2><h5 class="post__date">2016-04-27</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/mIwD27qqr5U" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">my name is Thomas Koval I'm working with
Farallon for the last five years I
recently moved to elixir at club car
they're both around solutions and
collect are hiring and also I'm
programming in Elm in my free time and
the one thing I want to tell you before
I started that I hate programming
language comparisons I hate it like from
the top of my heart because usually they
are really one-sided like this language
a has a nice feature and B doesn't
therefore a is better
and if programmers of language B don't
see it they suffering from the blob
paradox the paradox was introduced by
Cora ham in his great essay beating the
averages and what he also introduces in
the same essay is that programming
languages can be put in a power
continuum like from zero to over 9000
and the problem with it is that
programming languages are tools so for
me it's like comparing hammers and
screwdrivers I mean a hammer can be used
by a construction worker to everything
including screws and the watchmaker will
say that hammer is a useless tool so
it's maybe not smart to disagree with
pogrom during public speech by I did it
anyway so I want to define my problem
really well and my problem is building
interactive websites and I split it into
two sub problems which is the front-end
that should be reactive and the backend
that should be always online and now I
can give another quote by Paul Graham
from the same essay that all other
things being equal it's a mistake to
program in anything but the most
powerful programming language and
according to what I said I would change
it slightly that all other things being
equal it's a mistake to program in
anything but the most suitable language
for the problem domain and by the way it
fits perfectly as a tweet with hashtag
lambda days just saying so we need an
objective measure to compare two things
and I will be comparing almond elixir so
what I want to use is the number of
things you need to keep in mind to
understand given code fragments or
programmers memory
consumption or pmc for short just bear
with me with this definition I will use
a couple of times so here is a fragment
of a code in functional programming
let's assume it's a pure function and
that the last statement is actually the
returned value so to understand what
this function will return
we need to only know the arguments that
are passed in there those two functions
that are actually functions are great
for encapsulating what should be done
because seeing only the name of the
function we could infer what it will
return given the arguments so there are
only four things you need to know to to
infer what will be the return type so
for example even though I'm using the
same is the same syntax let's assume
that we have now method in a class in
object-oriented language so in this case
there are more things because we also
have arguments we have the functions but
we also have properties and the problem
with properties unlike with the
functions is that it's not enough to
have its name we probably would want to
know what else can modify the property
who kills who else can set it that's why
actually to reason about given code
fragment in our language we need to know
entire class definition and that's why
during studying they always tell us to
keep the functions shirt and keep the
classes short in object-oriented
language so where am I going with this
why am i telling you this because I'm
going to building front ends and
building a front end is actually
modifying document object model by
reacting to events events from user and
server so currently the most popular
programming language for that is
JavaScript and still to this day the
most popular library is called jQuery
and how is it done in jQuery so we're
attaching some code to an event on
document being ready do something next
in this do something block
we search for something in document
object model then we attach another
event on click this this thing do
something with this thing so the problem
with this approach is that as with the
oo language there are a couple of things
that are outside mainly the Dom so when
we are using this approach we have to
know everything about entire document
object model because we search it and as
in the oo example we need to know every
piece of code that modifies the Dom
which is potentially everything in our
program so this programming model this
programming model for front-end is is a
complete nightmare and if someone says
that he doesn't like JavaScript it's
usually not because he doesn't like
JavaScript per se it's a cool language
actually and you can do much with it if
you're disciplined and the discipline is
the key word here because John Carmack
once said that everything that is
syntactically legal that the compiler
will accept will eventually wind up in
your codebase so we we can't actually do
big stuff using something that doesn't
enforce good practices I want a
programming language or a framework that
will give me those constraints so let's
enter Elm elm is a functional statically
typed language that compiles to
JavaScript and usually you compose pure
functions however pure functions on
their own can't do anything they can't
print the screen they can't modify the
Dom they're simply useless that's why L
introduces something called signals
signals are by definition values
changing over time
so your main function in Elm is a signal
it has a type signal of HTML and here we
can see there are different HTML the
HTML is changing over time so that means
that it solves the problem of
modification of modifying the DOM and
now if we have something in the Dom it
can create
an action an event so all user inputs
and all server events are also modelled
as a signal there's a signal of user
inputs and server events and now we can
define a function that takes an initial
model takes an action and produces new
model and this function this update
function can be pure because the there
is the signal of actions and there's the
signal of models this is the impure part
however the code that developer is
writing is pure and again we can take
the model and create a pure function the
view function that creates HTML from the
model so this approach is really easy to
test and it's of course much more easy
to reason about them in JavaScript
however the problem is that there are
two things the problem is that we
generate the HTML every time but this is
solved by the virtual Dom so this is
similar to react Jas and actually the
implementation predates the one from
react.js and second thing is that we
need to keep entire application state in
model and this is actually cool idea and
it's great and it's easy to use however
we have to keep that in mind that we
need to have this state in one place so
because we have only twenty minutes
let's quickly jump to another topic
which is back-end programming so if I
want to create a service that is really
highly available I have to put it on
some hardware and this hardware may fail
so I want to have more computers and I
want to have network between them and
the network itself can fail which leads
to net splits so this is not really easy
in elixir this is solved by another
model which is a little bit similar to
2l but a little bit more complex too so
again we have the time line and we are
sending messages to actors however in
Elm the messages from signals are
processed one by one always in order in
the stupid
system the messages can be out of order
so it is the actor that says okay now
I'm processing it or no just queue it
for later then here actor gets another
message it processes it sends it to some
other actor the other actor can die in
Elm the graph of dependencies is static
in elixir actually things can change
dynamically so the actors can die and in
case you're sending something to the
actor that is dead the message gets
completely discarded so this is much
more complicated it's not as easy as in
Elm however what this gives you are
primitives for handling failure in
distributed system because we can check
if the actor is alive or reachable we
can subscribe to notifications about its
death and we can also kill it from
outside if we see that it is misbehaving
or enter the wild true loop or something
like that we can even read that groups
of actors in case there's someone
somehow depending on each other
so let's now check the PMC just remember
the definition so let's check the PMC
for elixir there are also arguments
there will be functions that I omitted
just for clarity but there will also be
those messages and this is much easier
than in oo because we don't have to set
up the state we just put the message
there and we can we can we can check how
this code behaves however in case we
have a system where some process sends
to this actor a message that is
malicious somehow we don't know who it
was
so we potentially have to search our
entire code base for the the malicious
process that is sending something wrong
so it's a little bit harder so in terms
of PNC in terms of things that you need
to keep in mind while programming Elm is
strictly better than elixir however does
it mean that it is a better language not
exactly
you remember cap theorem it basically
says that you can't have all three
things at the same time which are
consistency availability and partition
tolerance so if you're doing the
available back-end you you want the
availability you also want the
availability in case of partition
tolerance so you have to give up
consistency you just can't have this
nice static graph of dependencies that's
why the programming model is a little
bit more involved however it gives you
the tools to reason about programs that
are that are in distributed environment
but is it is all lost actually actually
not the if you're programming a website
you don't have to know everything about
those distributed systems you don't have
to know about supervision trees and
spawning processes this is a solved
problem for example Phoenix uses an
airline web server which is called
cowboy and it sets all the processing
for you in the same way if you have
persistent connections to database it's
also solved in your basic code but if
you need to access some external
services you have all this power under
your fingers when you're programming
with elixir and Phoenix but actually
Phoenix is not that much different than
elm-in-elm there was this one static
processing pipeline and in elixir in
Phoenix if you zoom in to one request
there's a concept of connection and
connection is a data structure that
holds everything you need to know about
the request which is where it came from
what were the parameters but also the
things that are needed to respond so the
response code the the actual HTML and
this is processed in a pipeline you get
the data structure called connection it
goes to an endpoint router pipelines and
controller and each of this thing things
can be
a function that takes the connection and
returns slightly modified connection so
if you zoom in for example to a
controller you can see that the
controller also takes connection returns
connection it runs it through common
services through action and it always
returns connection so there are
similarities between elixir and elm both
of them use single data structure that
the source of truth in elixir in Phoenix
this is on the on the request and the
flow is always in one direction which
makes it easy to reason about and the
easy to the back there is also one more
special thing they're both based on
messaging which means that today user
talked about channels so you can
basically translate what comes out of
channels into Elm signals and then build
a reactive application that is really
easy to maintain so this is basically
all I wanted to say and there are just
three things to remember if you leave
this talk and remember only three things
it would be firstly that different
programming languages solve different
problems that so if someone says that
the programming language a is better
than programming language B then ask
them to build what exactly second thing
is that if you need to create an
application that needs to be scalable
and interactive you should check out
both elixir and Phoenix and elm and the
third thing is that if you like this
term follow me on Twitter thank you very
much
so by default Phoenix
uses Postgres I can repeat the question
was what's the easiest way to run elixir
and elm with some persistence and the
answer is that Phoenix by default uses
PostgreSQL and this is the easiest way
to set it up even on multiple nodes you
can have the database separated from
your system because usually the heavy
thing is the processing and even having
the database in in one place for
websites is not a problem and if you
have this problem
Phoenix has this wrapper around
persistence it's called ecto and octo
can work with different databases the
question is if there is a standard of
sending messages between the languages
and yes there is rosetta talked about
channels channels are actually a
standard it's not only a Phoenix way
they build also a JavaScript library
that can handle using channels from the
browser but you could also build a
solution that runs on mobile or
somewhere else
so just translating the messages from
channels from Phoenix site to JavaScript
is already solved what you would do to
have them in Elm is just write a tiny
wrapper in Elm everything that connects
to to JavaScript which is impure and
it's not Elm is wrapped in something
called port</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>