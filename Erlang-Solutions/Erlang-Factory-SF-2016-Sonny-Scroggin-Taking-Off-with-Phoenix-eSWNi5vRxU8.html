<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory SF 2016 - Sonny Scroggin - Taking Off with Phoenix | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory SF 2016 - Sonny Scroggin - Taking Off with Phoenix - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory SF 2016 - Sonny Scroggin - Taking Off with Phoenix</b></h2><h5 class="post__date">2016-03-11</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eSWNi5vRxU8" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">welcome everyone thank you for coming
out before we get started I wanted to
just get a quick poll of the room of who
here actually works with Erlang on a
daily basis or all right good majority
and what about elixir okay cool and how
many of you have already started with
Phoenix okay cool so hopefully today for
those of you have already started
working with Phoenix I might be able to
show you something but this is kind of
an introductory to Phoenix
so hopefully along the way we can teach
you some insider kind of things that you
can take away and and have fun with so
my name is sunny Scroggins
I'm one of the core contributors to the
Phoenix framework and so before we get
started for those of you that don't know
Phoenix is a web framework and it is
built on top of the early or the elixir
programming language which of course
rides on top of the Erlang virtual
machine so and that's one of the things
that's so great about Phoenix in
particular is that it just works with
Erlang and the Erlang OTP protocols and
stuff so Erlang itself you know as you
all probably know already is a
functional programming language it has
immutable data by default and it can't
it's actually the only way that you have
data and of course has the awesome actor
based concurrency model and it has a
pre-emptive scheduler so I know that a
lot of people that work with Erlang work
at it from the language level but
there's also this the beam the virtual
machine underneath the hood is what's
really really incredible about this
whole ecosystem and so essentially the
beam is like an operating system for
your code
you know you've got the the kernel and
the standard library and stuff like that
and you've got OTP and then you've got
the language level stuff which is Erlang
and elixir and then you've got your code
kind of all living within there and then
within that you've got the the beam
itself has a scheduler for every single
core that's on your machine and this is
really where we all know what we all
know and love about Erlang is that it
works across all the cores on your
machine and so that you can take
advantage of that
so each scheduler runs independently and
has a run queue of all the processes in
your machine and of course processes are
how we interact with all of our
different pieces in the system and main
state maintain state be a recursion and
things like that communication through
message passing so all of these things
are pretty much most of what we learned
when we were learning Erlang or elixir
but each process is actually really
really interesting it has its own memory
space which has the stack and the heap
and the mailbox and then it's got links
and monitors to all the other processes
that it knows about and is linked to and
it has separate garbage collection so
and what all that comes down to is
really this you have isolation and
concurrency so crashes are isolated they
don't they don't take out other
processes within the system unless
they're supposed to like when they're
linked or something
and of course data is is isolated in
each process and garbage collection is
handled independently and the virtual
machine the scheduler takes care of load
balancing on Io and and and CPU and so
you have this efficiency on on
multi-core systems so and of course OTP
makes all this work really nicely with
supervision trees and all that kind of
stuff and so Phoenix itself is
essentially an OTP applica
that allows you to or it provides
functionality for the OTP application
that you're building it's not something
that you create and then it owns the
whole world
it runs independently and can be stopped
and started independently as well as any
other applications or OTP applications
that you have running within the overall
application that you're building and
that's really really interesting and
different from a lot of other things
that you might be familiar with out
there and so it's of course Phoenix is
is there for you to write your kind of
traditional HTTP stateless applications
where you're doing request response
cycles and then we also have an amazing
thing called channels which is geared
towards what the modern web looks like
and that is where you have stateful
connections to the server and you
maintain state between that and you have
a really nice message passing between
the client and server so as I said
Phoenix is an MVC framework we have the
the MVC kind of Model View controller
that comes with most of the other web
frameworks that are out there so it's it
should be very familiar to those with
experience with frameworks like rails or
Django in in Python we also have
channels for implementing soft real-time
features you can that can you know out
of the box it comes with you know with
support for WebSockets and long polling
but that can be adapted to use other
technologies as well and you can write
nice backends for it
phoenix is really easy to test we come
out of the box with a bunch of testing
utilities and things that make it really
easy to test things in isolation and to
test the whole stack as well and one of
the things that's really really really
nice of course
Phoenix is that it doesn't make you
compromise you know between performance
and productivity it gives you both many
people who have experience with
frameworks like rails for instance know
that you get really really nice
short-term productivity it's really easy
to get up and running and all that good
stuff but as time goes on it becomes
very very hard to maintain that code
over long periods of time and and then
also of course with that you you might
have high productivity in the beginning
but then when it comes time to scale
your application that's where the
hits the fan and you now have this hard
problem with trying to scale the
application and of course with the lick
sir because of Erlang and the whole
virtual machine you really don't have to
make that compromise you get both so
with that let's talk about performance a
few let's probably almost been about a
year maybe since this benchmark has been
taking place but it still is pretty
relevant as you can see here is this guy
here the gist is at the bottom went and
took a bunch of different frameworks and
different services and test it out each
one and benchmark them against each
other and what what we find here is that
gin in gin is a go framework I think and
play is from Scala and we've got like no
js' with an express cluster of machines
martini which is another go framework
and then we've got Sinatra and rails
down here and Phoenix was actually
tested in two versions and this is way
before 1.0 which is which is pretty
awesome
Phoenix is obviously here at the top
along with plug and plug itself is not
really a web framework but it is a
library that Phoenix rides on top of and
as you can see there it is at the top of
the pile against all of these other
works that are supposed to have like
incredible speed and so this is really
telling of what we get and as Chris
mentioned earlier this morning about the
story of you know going from going to
two million connections two million
WebSocket connections across multiple
clients you know attaching to one
machine and this is really just
incredible that you can have this kind
of scalability and performance and
efficiency in one single system so so
let's talk about how to get started with
phoenix installation is really really
simple we have a mix archive install
where you can just provide this URL and
it will install an archive for you and
you'll have it accessible across your
whole machine and so then you can just
use this command here mix phoenix new my
app and it will go ahead and generate an
application scaffolding for you creating
all the various files that you need to
get started configuration your actual
lib and then the web stuff as well as
all of the testing utilities and some
tests that will help you get started
it'll automatically fetch and install
dependencies for you as well including
the front-end build tools for all of
your javascript and CSS asset pipeline
kind of stuff and gets the dependencies
and then all you got to do is just
change into that directory you can run a
command called mix ecto create which
will create the the database for your
your application and then you can start
the server so you can do that with mix
phoenix server or you can use IE x as
well which will put you into an
interactive elixir prompt that'll allow
you to interact with your running
machine and with that you have a nice
pretty landing page that gets you going
and the server logs as well and one of
the things you'll notice is that
Phoenix generally will serve your pages
they're not going to the database and
stuff like that very very quickly this
is you know 230 microseconds and later
on in this talk we'll we'll get into the
some of the details of how that's
possible
so Phoenix is built on top of some other
really awesome libraries and plug is is
the main one and it's basically it's
just a simple abstraction for dealing
with different web servers and so the
main web server that it one runs with
out of the box is cowboy web server
which is written in Erlang and of course
you can build other adapters for
different servers like le I think
there's some some progress going on
there for that but it basically allows
you to deal with any web server as long
as it is adapted for for plug so and
then we have also ecto which we won't
talk too much about here in this talk
but it's basically a DSL for writing
queries and interacting with the
database which we do a lot in kind of
you know restful style applications so
probably one of the biggest things I
want to talk about in this talk is plug
because it's really such an integral
part of what Phoenix is for the
request/response stuff so I mean
essentially is a specification for
writing composable modules or functions
for dealing with the whole web request
and response and so what you get with
that is is you have just simple
functions or modules that have a
specific they export a couple of
different functions and you can use them
for anything throughout the stack and
the contract is really really simple it
just receives the connection as the
first argument and some options and it
just needs to return the connection and
so you make these simple tiny little
transformations of this connection data
structure throughout your the lifecycle
of the request
and that is really really simple to
follow because it becomes just kind of
like a pipeline of function calls so as
I said the plug specification there's
two types of plugs there's function
plugs and there are module plugs so
function plugs is essentially just a
single function that has those two
arguments the first being the the
connection and the second is the some
options and this is the type signature
that you would find in an elixir and
here's an example of such plug this one
would be for adding the content type of
application JSON to the response for
instance so you would use you write your
function here Jason header plug takes in
the con which is the connection and then
the options in this case we don't really
care what it is it's generally it's
gonna be like an empty list for the most
part but it could be anything that you
want and we just take this con and we
pipe it into these this put response
content type which is also a plug that
comes from the the plug library itself
and we're just telling it go ahead and
put in content type application JSON for
the response header so so the next thing
is module close and module plugs are
basically an extension to the function
plug you need just to export two
functions two functions in your module
and knit one and call to sew and knit
one just takes a set of options and it
just needs to return those options so
maybe you do some transformation of
those options to kind of initialize it
and then you just return those and those
options are then passed in as the second
argument to call two and of course call
two takes in the connection as the first
argument and it just needs to return the
connection and the interesting thing
about this is that knit one it can
actually be a compile-time optimisation
so
at compile time in it one could whatever
it returns is kind of cashed into the
file so you don't have to it doesn't
have to be executed each time it's
called so-so and here is an example of
that jason plug but just in a module so
we're just doing a knit one returning
the options call two we're doing the
same thing as before and so this is
probably hard for you to see in the back
but it just is the the the plug con data
structure and this is that simple data
structure that is the the connection
that's piped through your entire stack
and this is what I love about plug
because it's just the single source of
where you need to worry about the state
of your request it has fields in here
for dealing with the request the
response and different things in there
and so you don't have to have in
object-oriented systems you might have
several different objects that have to
coordinate to actually take in the
request and then use some parsing and
then have to actually end up spitting
out the results so as I said this is
comes from the plug documentation and
the plug documentation is pretty
fantastic it actually explains every
single field that's in here and gives
you an explanation of what there are
supposed to be there for so request
fields vegetable fields vegetable fields
is pretty interesting too because there
are certain times where you may not care
about parsing cookies for instance or
query string parameters and things like
that and so these fields are not
actually fetched and and parsed until
you want to or you need to so you can
save some computation time there and
then of course there's the response
fields which contains the body the
status headers and things like that and
then connection fields so the connection
feels the the main one here that's
that's used is the assigns and that
for you to store different values into
the connection that you need to use
throughout the lifecycle of the
connection maybe you grab a user from
the database and you would store that in
the connection so that you can have
access to it later on in the in the
lifecycle so so in Phoenix we have three
plugs
there's the endpoint the router and
controllers so the endpoint is
essentially the the place in your
application that sets up the the initial
plug pipeline and this is for every
single request that comes through the
system every plug that's set up in the
in the endpoint will always be run and
this is also at the end where it's fires
off with a router but overall this is
the kind of boundary of the application
this is where all the requests will
start from and so this is the kind of
the endpoint module that you have this
is what's really cool about this
approach in in for instance in rails
it's very difficult for you to kind of
have access to making sure like all the
different middleware that you might have
running in your application you don't
always have access to making sure that
things are executed in certain orders or
things like that and you have to really
kind of hack it through you know
configuration and and when the
application is initialized and we made
this very explicit through the endpoint
you you have to kind of plug every
single thing that you want to do and
these are the ones that are generated
for you automatically but you can
customize each thing you can take stuff
out that you don't need you can put
stuff in that you want extra to happen
on every single request and this just
makes it very explicit very easy to
reason about what's actually going on in
your application so we have this first
thing here is the socket which is for
the WebSocket stuff that we'll get into
later but we have plug static which
we'll handle static assets like CSS and
JavaScript and things like that let's
have a section for when you're in
development that you can turn on code
reloading and live reload so as you're
developing you make changes to different
files it'll automatically reload the
browser for you it'll automatically
recompile your code and make those
changes for you we also have plug
parsers which is used for parsing the
different pieces of the the request so
if it's if you have some query string
parameters it'll parse the query string
it'll parse multi-part forms and then
there's also a JSON parser which will
parse the JSON body we've also got a few
other plugs here that are some some nice
things that I won't get into right now
but got plugs for for a session to set
up your cookies and and all that good
stuff and then the final thing we do is
we plug the router which is the next
plug that we'll talk about so the the
router provides some nice macros that
you can use that map really well to HTTP
verbs so get put patch post delete and
so forth and these basically allow you
to match on the the URL and dispatch
that to a module that will handle that
action so and so this is just a very
simple router here we've got the scope
which basically allows everything in the
top-level scope to be matched on here
and then we just have like this get to
slash goes to the page controller which
is a module and the index is the action
or the function that's going to be
called within that module we also have
this nice thing called resources and
resources will automatically set up kind
of this seven restful routes that you
would normally have if you're familiar
with rails it's very similar so what's
really nice about elixir is the the
macros that allow you to build you know
sells that makes sense for stuff like
this
building building nice UI herb nice
stuff like this so and what that
actually does so if you look at this
like resources of rooms and users it's
all nested here what this actually does
is that when at compile time it takes
these macros and it generates a match
function they're all named match and
they all just have different patterns
here and so we at at runtime we just use
the beams pattern matching to pick the
right function and and route it that way
and it's incredibly fast to do it this
way whereas other frameworks have to
route based off regular expressions and
stuff like that they spend a lot of time
actually trying to dispatch which what
function you know what which handler do
I is do I invoke so in this way the beam
does all the work for us and so for each
one of these the the connection from
plug is the first argument that's passed
in and then the rest is all matched on
the on the request so something like
this and this here is just the function
heads so the next thing here is to show
you exactly what it looks like in the
bodies of those functions to so
something like get slashed a page
controller ends up compiling into this
and so we we put some private
information inside the connection name
spaced under the Phoenix namespace and
we're just basically setting up the
controller to handle the action and
piping that through we've got some nice
mixed tasks that you can run so mix
Phoenix talks about routes will then
print out and show you all the routes
that you have based on your current
router config and it will show you all
the modules and functions it'll show
sent to so
pipelines are obviously been around for
a long time in the 70s we all know when
we use UNIX for instance and of course
this allows you to kind of put common
functionality together and this is what
a lot of times we have to write in
certain programming languages where you
end up taking an argument and you have
to kind of wrap it and it's really
difficult to parse exactly what's going
on there because you have to read it
inside out and so in Erlang we see this
a lot where you you know got your
function and you've got your con and now
you've got con 1 and that goes to the
endpoint that gets returned and and so
forth and you kind of have to add these
new you know numbers to each one because
you can't rebind and so a problem with
this of course as those of you who have
programmed in Erlang know is if you want
to add something in the middle here then
you end up having to rename all of your
variables and it's very easy to cause a
bug probably right so so we want
something more similar to this where the
output from the something on the Left
goes into the input on the right and
that's what we get with the lick sir
with the pipe operator so this is much
easier to to understand what exactly is
going on and this is what plug does it
essentially gives you a pipeline of
functions to pass in this data structure
and you just perform these tiny
transformations each returning the
connection each time and it just pipes
it through to the end of your program so
start off with getting the connection
from parsing the the request send it in
to the end point plug which then sends
it into all the plugs that it has in it
in there goes through the router and
then your controller and then finally
you will send the response so and
looking at it like this
you essentially are taking a string from
the HTTP request doing all the parsing
and processing and then just spitting
out a new string
so another thing that is nice in the
router is router pipelines pipelines
allow you to take that like I said that
that common functionality and group it
together so if you have if you have like
HTML that your HTML website that you're
doing you might have some things that
you care about that happen on every
single request and so you can create
like a browser pipeline that allows you
to set up the session for instance you
might want to fetch the session from the
cookie find whoever's the current user
you might want to set up some some extra
headers for protecting from browser
attacks and things like that
and so that's what you do in in the in
the router in the scope here you can
just set up pipe through and pipe it
through the browser which will then go
through and after it figures out which
route its going to go to it will
dispatch through this function first
before it invokes the controller
so the other thing we have is generators
and generators allow you to kind of
scaffold out ideas and really we we use
them for learning tools for people that
are just getting started it will
generate all the code for you that you
need in order to get a simple crud
application going and then you can take
that and look at the code and learn from
it so obviously comes with kind of the
standard best practices that that we've
made for you and and allows you to get
going really quickly so showing you this
here real quick you can you know
creating a blog for instance you would
use Phoenix gen8 GML to generate an HTML
resource with like HTML views and things
like that you give it the name of the
model which would be post which is a
singular eyes thing posts plural which
will be the usually the resource route
on your website or on the URL and it
will also usually map to the same like
the table name that you'll use in your
database and then you can give it some
columns so we have a title which is a
string and we have text for body and
that will then generate all the files
for you and give you some instructions
at the bottom to proceed so it just says
hey stick this in your router and then
go ahead and migrate your database so we
stick that in the router and we were on
mix echo dot migrate and that ends up
creating the the table in the database
and then when you visit the the URL now
for slash posts you see an empty table
here you can click the new post button
and it will give you a new form to type
in your your title and your body if you
try to submit it with without any any
text in there it'll tell you that you
got a you got to fix some stuff here you
got
these fields can't be blank you correct
it resubmit and you get a post created
so and of course from here you can you
know show edit delete etc so all right
so controllers this is where you're
you're basically going to do all of your
your business logic for taking the
requests and making stuff happen so
controllers also have pipelines as well
so you just say plug and you can give it
the name of a function or a module for
instance and then you can also have
these execute conditionally as well so
you can say when the action which would
be the action the function name that's
going to be called is in you know create
or update for instance so this this
allows you to ensure that functionality
is is happening on certain actions all
the time
so just quickly we have the index action
which is generally when you go to slash
posts you will then fetch all the stuff
from the database and display it out to
the users you have the show action which
will be a slash post slash ID which will
just get a single record the new which
will generate a form and show you I'll
give you the the fields to create a new
one if you do a post to slash posts then
it will then take the form form elements
and and create a new post and save it
into the database and and so forth so
you've got the the Edit action which is
very similar to the new and you've got
put or patch four similar to the create
but you're doing a putting patch to the
posts with the ID and then of course you
can delete so so views and templates are
the next thing that's very interesting
about the Fenix actually views and
templates are separate in some other
frameworks they kind of combine them but
really a view is a module that is
responsible for rendering templates and
so it serves as a presentation layer so
you can create helper functions and
things like that that will be accessible
within the template itself and templates
are actually pre compiled so what that
means is if you have an HTML template
and when at compile time the view module
will then actually have a function named
you know index.html for instance and it
will have the body the contents of that
function will be the body of that
template and so it's pre compiled and so
at runtime you're essentially just doing
kind of string concatenation with
whatever variables that you have in your
assigns so this is an example of a view
where we've got
like a tidal function which would be a
helper that would just take in the model
and up case the title for instance which
is silly but you know it's just an
example and then of course you also have
things like rendering JSON so if you
have index dot JSON then you can encode
a your model into a map and that model
will then be encoded into JSON then is
the output and so you can actually do
like with this one here indexes a JSON
calls render mini and you tell it to use
the show JSON which would then invoke
this and send out an array of of post
objects so so this is very very nice to
deal with it's very explicit so you know
exactly what your outputs going to be
and it keeps you from shooting yourself
in the foot
and so templating for HTML is done with
eex which is stands for embedded elixir
and you can embed actual elixir code in
this bracket percent equals which will
output the evaluated code all right so
channels channels is really kind of the
the big deal in Phoenix it was one of
the first things that Chris had actually
started when he started Phoenix and it
all came out of the the fact that you
couldn't really do this very well in in
Ruby you know where you have multiple
clients connecting to a server and
holding the socket open it's just
incredibly painful and very difficult to
do at scale in other languages and so
you know channels allow you to route you
know pub/sub events through system and
do messaging back and forth between the
client and the server so they're very
similar to controllers except for that
they're bi-directional so the server can
send a message to the client anytime and
this and the client can send back to the
server as well
and what's really neat about the whole
channels thing and the pub pub sub is
that the abstraction is really nice
because you can build different backends
for it it comes out of the box with you
know support for distributed Erlang
which will you can start up new nodes
and connect the notes together and it
will take care of you know sending
messages across nodes which Chris just
showed this morning and you can of
course build a back-end for for
something else as well
there is the there's a Redis back-end
for instance a lot of people want to
deploy to services like Heroku and
Heroku doesn't allow you to do
distributed Erlang you can't connect the
nodes together and so there is a Redis
back-end that will allow you to kind of
circumvent that so
and of course phoenix' jeaious which is
the JavaScript client which comes out of
the box with that so setting that up you
just in your endpoint you have the
socket here and so now from with
WebSockets you can connect to that
endpoint and will start your socket
connection and then you have the user
socket which is where you kind of plug
in the transports out of the box we have
web socket and long polling and this is
where you would also if you had a
another transport like telnet or XMPP or
RabbitMQ you can you could plug that in
here and use a different transport and
this is kind of similar to the router as
well so you have like channel and then
you give it a name space here so you
have this topic rooms and then colon
subtopic and in this case we have a wild
card with the spastics which says hey
anything that has the topic of rooms
send it to this room's Channel
and the connect function is when you
first connect with the client it's gonna
come in here and this is kind of an area
where you can do authentication and
things like that make sure that the user
is actually able to connect and if you
return ok socket then you have
authenticated clearly and you're good to
go otherwise you can return error here
and it will decline the user so the room
channel is just a module that you can
set up here you can do pattern matching
on the on the topics as well so like in
this case we have rooms : lobby and if
it's rooms : lobby and if we get a
message and the socket then we can set
it up here to allow the user to to join
that topic you can return ok socket and
you're good to go and then you can also
do stuff like like this we can use
pattern matching to match on the
subtopic so we have rooms : and then
we're using the binary pattern match
operator here or I'm sorry that's a
string concatenation but but doing the
rest the rest of that string there will
be the subtopic and then you could just
return error you know with a reason
unauthorized if you don't want anyone to
join something else so then we can also
use broadcasts which will then broadcast
an event with a payload to all
subscribers that are subscribed to this
particular topic and of course Phoenix
Jas we've got setting that up is really
really simple you just connect on the
socket and then you can set up different
handlers and things to respond to
different events that come in from that
channel
so socket connect you can pass in
different parameters and things like
that into that this would be where you
might pass in like a token or JWT to
verify on the server then you set up
your socket your your channel until it
which channel you want to get in on and
when you're joining you can actually do
some nice kind of pattern matching
Erling Erlang knee things here which is
very clever that Chris came up with so
if you receive ignore then you probably
have like some authentication error or
something if you receive okay and a
message then you're good to go and then
it also has a timeout option too so
after you know 10,000 milliseconds then
your connections been interrupted so you
can set up other things on on error and
and when the channel actually closes you
can respond to the events like that and
then you can push events to the to the
server so the interesting thing here
from the outside view is that the
clients can connect from anything right
it could be an embedded device a web
browser or maybe a mobile app something
like that and then when you need to
scale you can add servers and it it all
the messaging just travels between the
different nodes automatically so it's it
works great and then you know let's say
you have a client that connects to the
other server all the messaging is
handled no matter what so gets
transferred between the servers but from
the inside view when you connect to the
server with socket connect you get a
process and when you join different
channels you end up getting a single
process for each channel and each
channel then holds state for that and so
you end up with a process per channel so
if you have a bug in your code
it doesn't affect the other channels so
if you have the the room channel and
there's a bug in in that particular
channel but you have maybe you know a
users channel or something like that
then if one crashes it doesn't affect
the others so that's where that
isolation comes in and of course they're
supervised so they get restarted in
things so and then of course you've got
the pub sub system that you know has the
different backends that you can create
which comes with already support for
distributed Erlang and Redis with a
separate package and then there's a
package for route rabbitmq I have
aspirations to work with XMPP and
phoenix channels and so eventually
someday I might get around to it when I
have time and I think there's people
working on various things like Co app
which is a protocol that's really great
for embedded devices so that's pretty
much the gist of it but really the the
thing is is that none of this stuff is
really all that new right we have you
know MVC kind of request response cycles
with many other frameworks we have you
know nodejs with you know that allows
you to write JavaScript to talk back and
forth to the server and and have these
you know long-lived connections and
things so what what is what is phoenix
matter in this case you know we already
have these technologies that that allow
us to do these and really comes down to
Erlang and where you have super vision
trees that can restart processes when
they die
you've got the amazing concurrency right
one of the things with nodejs and and
ruby is that in multi-threaded
environments it's really it's terrible
you you have usually one single thread
that you can work with and and with
Erlang everything works across all the
cores on your machine so I think in
today's world and in the future we
really have to be using technologies
that can take advantage of that and so I
think this is the future
of web development and I think we're
really gonna start seeing the the rest
of the communities kind of shifting
gears and and coming to the erlang side
because this is really the only
technology space that is easy to do
concurrency you know it's it's almost
too easy so with that thank you do you
have any questions yes yes so the
question is around database migrations
and where that lives so database all the
stuff that has to do with database is in
respect to the ecto library which is an
external dependency it ships by default
with Phoenix unless you specify that you
don't want the database and so when you
generate a new scaffolding or you know
use like the generators then a migration
file is generated for you and it will
tell in a nice DSL it will generate some
code that will tell the database how to
you know which what fields to create
what table to create and so forth and
you can do other migrations like adding
columns removing columns renaming
columns all that kind of stuff
yes
yeah the migrations and the model are
are needed needed in both and you also
have the model the model is really just
kind of a schema and it's there to
create the struct that will you know
allow your data structure to exist
within your system and and then act
hecto is really like you could spend a
week doing a talk on ecto and it's it's
really huge but it's amazing it's really
really great yeah yes yeah so in Phoenix
we we have on the front end I'm sorry
that the question was about the
JavaScript and what form of that is it
is it cs6 or es2015 whichever one you
want to call it now but yeah so
basically the the front-end build tools
that phoenix ships with is brunch which
is a build tool that's really really
simple to to configure just a few lines
of javascript configuration file and it
comes with like babel and and all that
kind of stuff
to generate the es6 files and you can
use that all with very with no work at
all so yeah it's a Babel the Babel
transpiler does all the work
yeah yes
one of the good things where you have so
if I understand the question it's great
that we have you know the ability to use
all cores but what about distributed
across multiple machines well that comes
with just Erlang right you have access
to all the stuff that Erlang provides so
you can spawn functions on other nodes
and you can run tasks that run on other
nodes whatever you want there's no
limitation where Phoenix is you know
it's it's an application that you
include and it generates code for you to
make it very easy removes a lot of
boilerplate and it provides kind of
patterns that allow you to organize your
code in certain ways but it doesn't
limit you in any other way it gives you
full access to the VM and you can do
whatever you want it's pretty awesome
yes so with the answer is CSS and
preprocessor and pre-processing CSS
that's handled by the brunch utilities
so there's different node packages that
you can download
there's SAS brunch and other tools that
you can use within the the brunch
ecosystem you can also you don't have to
use brunch either if you prefer webpack
or something else you can swap it out
it's not baked in or coupled at in any
way to to Phoenix at all so it's
completely separated
yes I don't know much about bullet okay
yeah so with cowboy cowboy provides
WebSocket support automatically within
that and so Phoenix just takes advantage
of that and so the Phoenix Jas is just
the JavaScript client that connects to
the backend and then you don't passes
messages back and forth so all right any
others
all right thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>