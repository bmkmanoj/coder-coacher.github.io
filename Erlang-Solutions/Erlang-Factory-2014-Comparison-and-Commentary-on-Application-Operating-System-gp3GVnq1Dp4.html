<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Erlang Factory 2014 -- Comparison and Commentary on &quot;Application Operating System&quot; | Coder Coacher - Coaching Coders</title><meta content="Erlang Factory 2014 -- Comparison and Commentary on &quot;Application Operating System&quot; - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Erlang Factory 2014 -- Comparison and Commentary on &quot;Application Operating System&quot;</b></h2><h5 class="post__date">2014-04-14</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gp3GVnq1Dp4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">alright so thank you if you actually
made it to the very last sessions of the
day and I very much appreciate you you
know not just going and actually trying
to hear some other stuff and thank you
for your time I yeah it you know I
myself I'm trying to fight to stay with
it so i know that for in the audience
just you know please just hang in there
so i'm also trying to like work on my
presentation style so part of that is
fighting back against powerpoint but the
other part of that is the last few
presentations I've done i'm trying to
show off some work that I've done and
you get me do that you get really
excited and you want to just download an
audience and give them like 80 million
slides and tell them all this stuff that
you know they're just glazed over so
what I'm trying to different approach
trying to really really reduce the
number of slides that I have really
really reduce the amount of information
trying to convey and actually try to
make it intelligible and so that you
won't you know pass out sleeping you
know while you're getting it so in that
in that in that that that thought that
narrative there you'll please ask
questions at any time and so I hopefully
it will be actually under time on
purpose and you know we can make it out
of here and and you'll get actually get
something out of this so the the purpose
of this talk is to actually to get you
to maybe think about some things in a
way maybe you have not before or to ask
some questions that maybe have them
before or just just to see the world a
little bit differently so so Who am I my
name's Thomas Stover I work now on
supporting a mixture code base that has
a lot to do with native code C C++ and a
heavy use of Erling and I came from a
background of systems programming
primarily with C primarily on linux and
so my experience in last six seven
months has been trying to introduce
myself to the universe of Erlin coming
from that perspective and that is a very
interesting experience and
you know if anyone is coming from the
other way around I think it would
actually even be harder but i would that
would be interesting if i would like to
share that story with me or compare
notes and the only thing L say about
that is I watched an excellent
presentation about three years ago and
one of the the main points that was
being trying to conveyed was that you
know this guy was so heartfelt with it
he says don't stagnate don't let
yourself stay you know in a comfort zone
for 10 20 30 years because even though
that may be where you need to be and
that may be what you're good at you're
still you know your mind rots your mind
deteriorates you actually get stupider
the longer you stay comfortable with
what you're doing and so it is good to
try to look at the world from a
completely different point of view and
and to help to to see what you can gain
out of that and when you lose that
you're not as clever as you think you
are if you're when you have that myopic
vision when you have when you stay
focused on just a little part of the
world you're losing a lot because the
world is a wonderful big place but all
kinds of stuff happening so I work for
this outfit called alert logic and who
we support of reasons when I'm here
obviously is you know we're looking to
find the best people in the world we are
in the cloud security space and we are
probably in the private sector we're
probably one of the largest collection
of erling engineers in North America a
yes yes so that's a really cool us we
have some fascinating problem domain we
probably have one of the largest
databases in the private sector we have
just some fascinating things and like
said we're having a native code as well
so there's you know a lot going on there
okay so moving forward here with our
narrative so there are a number of
themes that that are somewhat orthogonal
somewhat parallel that did all kind of
come up for discussion when you're when
you're a topic of sort of comparing and
trashing these two worlds two worlds
being see native code and Erlang and be
and some of those we'll talk about more
than others but few will just kind of
just touch on is the the functional
declarative versus procedural imperative
theme you know that is fascinating and
us that's an issue unto itself but
that's not really what we're talking
about today real Hardware versus virtual
hardware is our virtual machine is
something we'll session a little bit
more but again that that's not the focus
but it does it does matter I continue to
be dumbfounded by how the awareness
level of people who don't seem to
appreciate that for what it is not that
he did one is better than the other
they're both important concepts but
that's this sort of faded away from
discussion is more than I think it
should be static versus dynamic typing
not going to talk about that too much
other than to just mention that that is
a big deal I hate dynamic typing you
know whatever this is one of the things
you just swallow the pill I think with
erling early people love it that's great
has its advantages and that's cool but
just understand that it does matter you
are paying a price for that and just you
know an analogy would be there is a
Python project I think it's I thought
maybe somebody help me remember and one
of the things they just did they modify
the Python runtime in just a few ways
and one of the things they did was they
just simply switched it to a static
typing system and waiting orders of
magnitude more performance so point is
that you are paying a price for that it
it does matter and yeah I think for the
other way you're looking at it from the
you know kind of relate to the last song
from a static analysis perspective
that's the whole reason why we even have
specs and Erlang is because you know
anyway point is I'll get off that moving
on and then but did so but that best
relate to to the whole other reason why
you have high level tools in the first
place why you have things like Erlang
and looking at things from a higher
level spec is is the human performance
versus computer performance there's a
trade-off you know not everything has to
be done in assembly code not everything
we're not just soldering wires together
right there's time to do all these
things and if you can you can solve
problems using tools appropriate tools
that help your the human perform it's
actually get something done frequently
that's
much much more valuable than you know
how fast it's actually running a
computer okay so the next kind of theme
i'm going to call the the layers
quagmire and so we can look at this in a
few different ways of things so one of
the themes that's going on I think
industry-wide and academic wide is that
you have these if you look at this as
sort of a simplified view of
contemporary computing and one of the
themes that you keep saying is this
replication of layers that do many sorts
of the same things it's kind of like the
fractals in nature or how the atom
mirrors the universe right and so like
if you know if you take a higher level
where we see now is you have these
frameworks where we do cloud deployments
and we do where we take something we
generate something we dynamically
scale-out scale in create images on the
fly destroy images were thing and as
these systems advanced they take on
attributes of operating systems
themselves and you ranaut the point
where we are writing programs
specifically for these kinds of
environments so you continuously move on
down then we have where most of work is
done today you know your act the actual
program that you do right to do
something right I've supported by a user
land so like an a traditional operating
system that's going to be things like
you know your C library all the
background damon's your shell anything
like Erlang right that's your that's
your OTP framework that's the actual
Erlang shell that you've got to work
with and of course all this is on top of
a number of other things you've got your
your OS kernel today that can also be
entirely replaced by a hypervisor
directly it's just dedicated to running
other things you can do now we have
things like their Erling on Zim dumb Zen
scuze me or Java on bare metal there's a
number of these other projects where
you're just running that virtual machine
directly on the hardware layer and then
you've got the other one it's getting a
lot of talking has this lib OS concept
which would sort of be the the native
code equivalent of running say of the
on hardware there's a number of examples
like this let's say bare metal OS i
think is again when there's a the one
that the Craig I is used but basically
the idea is that you're going to try to
have a single tasking environment of
some kind that is just to run some
native code at the fastest performance
if it could be and then you know of
course this is on top of all these other
abstractions and the reason I put part
of this in here is it still a lot of
people you know and you see understand
why but have missed the concept that the
what we think of is is like CPU
instructions is actually an API to an
entire universe of software beneath that
so most of the things that are happening
that we think of as hardware is our very
much in the domain of software
everything of all the the cash work the
branch prediction the pipelining all
there's a whole universe of starving and
and these their trade offs for how was
how much that do we expose up to upwards
to the programmers the users and how
much we keep and internally and a lot of
that has to just simply to do with
legacy reasons but it's just a
fascinating thing to consider that we
just continue to replicate these these
layers over never again so but more
often not we think about the the layers
of in a deployment context of how is it
that we are actually utilizing these
things how was it we're laying out these
workloads so yeah because of
virtualization scheme so hopefully you
know there's a few of virtualization
models I think we just a quick look at
hopefully everyone's seen it before but
you know the some of them have their you
know the trade-offs between efficiency
and and usefulness not everything is
necessarily for performance reasons this
may just be for administrative overhead
for ease of just solving a problem just
have simply having less hardware but on
the other hand when you are actually
trying to
go for that performance curving did the
best you can with that then some of
these other things how about you know
one of them okay we got the gist you
have a regular hard regular computer an
operating system and you have a can take
like LXE or a containerized you know
like flares container something like
that then you have the ones probably the
most common where you have no you're
like weird in Rio in this laptop you've
got computer operating system then we
have virtualized operating environments
inside of that and on top of those we
have further operating systems with
workloads some of which inside of that
we have virtual machines with workload
so the point is that we're having
overhead overhead overhead over it
sometimes that's a big deal sometimes
it's not but it at the very least be
conscious of it it's amazing that we are
not conscious of that you know most
things now where you deploy and you know
cloud instance somewhere and you're now
your layers and layers and layers all of
which adds overhead yeah so part of
reducing overhead is is like we're done
a minute ago is you have these models
where ok we'll just won a virtual
machine directly on Hardware except the
hardware to actually support different
kinds of hardware is totally unrealistic
at this point in history so we just used
for the hypervisor itself as our heart
harder abstraction layer and then we
target you know whatever emulated you
know peripherals and stuff is inside
that computer and we can we can get a
model like this again we have you know a
vm based and a native code base but you
do see that and then this one I put in
here we probably never see will probably
never see this one but this actually in
terms of the amount of dollars deployed
and in turn in terms of you know
resources behind it this one is huge and
well guessing when take know where you
might see this will only explain what it
is so what you would have is you have a
one or more nodes of a traditional
operating system that's just basically
running a front-end about scheduling
what it would it mount to and then you
have an array of other computers that
are simply running a single task per
core
are computing something sometimes that
actually might be you know am but it
also could be native code and that's
actually that is a echar cryptographic
breaking technology that's us your guys
who are you know a quote unquote
simulating a you know fission bomb but
actually of course it's too you know
when you switch over and hexalimbs key
but yeah center it's no topic okay so
next theme that and that's kind of why
the title of this talk altogether is the
concept of an operating system versus
application operating system or a micro
service architecture are different ways
of looking at the same thing so you know
what is that was I mean so an operating
system at this point in time basically
just means a resource multiplexer just
something that we're using so that we
can run more than one program on the
same computer and application operating
system concept is we're going to take
facilities and ideas that we would
otherwise associate with this system of
operating system and sort of put that
inside one little program excellent
example being the are you know Erlang
system and early could be both of those
because of course you could make and
there has been you know erling that runs
it is not the Erlang runtime itself as
an operating system and of course it
also can mean something else entirely
which is the context of more than one
compute node and so you have a network
operating system if you incorporate the
distribution architecture as part of
that so a lot of different reasons why
they can buy things contribute to why
things are confused and why people have
different perspectives and you know why
some people say oh it's an apple it's an
orange puts banana well it's all of
these things just depending on what
you're looking at so the when you talk
about the like the micro service
architecture the big generally what that
means is that you have a message-passing
system of some kind and so the like
textbook example
of you know what would a message-passing
microservice architecture be is a
microkernel and basically the idea is
that you if you were building a
operating system kernel you would divide
that into these little bitty you know
services of some kind and just implement
some sort of minimalistic message
passing and and just split the task it
that way now it's interesting is that
although there are examples of this this
is kind of considered a failure you know
the the the presence of Linux itself
being a monolithic kernel architecture
or sort of the opposite idea of that is
kind of you know some would say put that
argument to aside but that's still that
does exist it's still using some some
ways and you know may come back in the
favor someday but a lot of the
literature a lot of the ideas from a
micro service architecture come from
this okay so Wow so like I said learning
they're coming to Erlang you know a few
months ago new from the background and
you when you learn that kind of stuff
you you at least the way I did it you
know you a lot of Google searches you
read different books and Yuri different
things you look at examples and there is
so much confusion out there and you know
I'm not saying that I understand
everything but good lord the number one
area where I think people are totally
confused about is you know of the
process model so let's take a minute to
export this so in a traditional
operating system we usually we've got a
concept of processes that essentially
means a protected memory space what that
means is that this is a facility given
to us by the hardware itself either from
something like a memory management Union
or segmentation architecture some kind
of where we had where it's implemented
with protection rings something to wear
we actually have a hardware assisted
process isolation and we have a address
space as global orca long stall the
different things inside a process and
that's our process a thread and a
traditional offering sensitive system
sense of the word is the same thing
except it shares that same process space
so we are we have intentionally given up
a portion between zero or one hundred
percent of that memory isolation between
processes and then there's this other
concept the most popular term for it
being a fiber there are other names for
it we'll use the word fiber I like that
which is where you have you were either
manually stack switching a frame or you
don't have a stack at all an example of
not having stack it all would be the
proto threads thing that you've seen a
Kentucky operating system manual stack
switching would be like GNU pth
something like that and the fiber
concept does exist outside of early yes
the early process model lets us do these
many hundreds of thousands of processes
and they're lightweight and that's great
but that's not a unique thing we can
still do that with regular traditional
native code rarely done but it can be
done so as I luding to in the early
universe our processors our processes
are implemented as a style of fire okay
why do we have the Erlang processes this
is an abstract concept why do we do that
there's a lot of reasons for that a lot
of different orthogonal reasons that
paint this patent this is also
contributing to confusion one of them
is simply we're trying to mitigate the
drawbacks introduced with functional
programming in the first place okay what
I mean by that so the functional
programming model is we have a mutable
state we have a mutable variables into
pass state around we have to do you know
tail recursive calls but you get to the
point where you can only do you know if
we're having to pass that as a parameter
every single time that there's a limit
to what you can do so as a way of making
that better expanding upon that we can
move things into different processes and
that is a variation on the theme so
that's that to me as I look at it as I
learn at it that's one of the whole
reasons why you have this multi process
model in the first place the other one
is that what's special about erling is
that we're not just programming an
application you're programming a system
at large and in order to do that you
have to have the multi-process model and
then at the same time that has given us
a strategy for concurrency so we can use
that same strategy for expanding to
multiple nodes or for SMP but it works
together so you have this synergy
between these three themes and that's
convey intersection of why you why you
would have that as sort of why this
comes up I see a lot of confusion on
that but that's my take on it you know I
didn't write erling someone else did so
maybe there's a better answer but that's
how I would choose to look at but I
haven't seen it written down that way I
wish someone would explain that to me Oh
us for a beer and I put 0 as another one
there because again i don't know if this
was an original design goal or not and
you know if you're fascinated with
historical computing architectures and
you know who isn't you have to bear in
mind that that expressed in the 1980s
you had expensive production grade
hardware in use that did not support you
know hardware-assisted memory protection
or any kind of segmentation architecture
and the only way
to do multiprocess in a protected way
was to use a virtual machine and to to
make your own process model this way as
I understand as I've been told I was
actually one of the original motivations
behind some of the designs of Java but
I'm not an expert in that field so so
does having these processes make
anything faster and early you know we're
told that a lot so well it kind of
depends no in some ways right so a you
know hardware versus virtual machine you
know there's the last few years right
when I think was microsoft research was
putting out a big kind of publicity
blitz about how you could do certain
optimizations and with just-in-time
compilers and you could get various
portions of interpreted code to run
faster than optimized native code and
you actually had intelligent people with
straight face they say that well now
that means that you know vm technology
is going to be faster than real hardware
well no perpetual motion is not real you
know you cannot take hardware run
simulated hardware that is faster than
the hardware that it's running on the
first place what that does simply mean
though is that your optimization
strategies can be superior or that the
original native code in the first place
which is poorly written that's a
different concept okay memory management
of course so you know yeah you're paying
you're paying a price for the
convenience of not worrying about your
own memory management you in terms of
locality and when you can do garbage
predict garbage collection and some of
these other things but there are ways to
mitigate that and that may or may not
matter right again it's a convenience
your your trade-offs the dynamic types
thing I talked about earlier and sort of
the big one depending on what your
problem domain is is the no vector
operation no vector operations meaning
we don't have
you know ways to do sort of a simdi or
you know GPU acceleration things like
that on the other hand this is awesome
this is some really beautiful powerful
tool I'm not knocking her like I think
it's awesome it helps you out a lot and
just simply used appropriately in the
right context or with the right use case
this helps you out a great deal and in
that sense it is saving you time and
performance and then on top of that as a
distributed tool you you can certainly
use that as a performance increase then
you may have otherwise done okay so
security model so that's another
fascinating thing to me is it so we come
from systems you everything is based on
okay what is this the security
ramification of denison what does that
mean and erling stuff it's almost like
okay well we're just not going to talk
about that so what I'd like to kind of
just fill in a little bit so
traditionally we talked about the
security model for writing programs
right the the original concept was you
had a computer it's locked in a room if
you have keys to the room where the
guard lets you in the room then you have
access to the computer so we call that
restricted physical access the now we
still have that we have the exact same
thing it's just simply restricted
network access so and and that's still
used that some of the best you know
highest performing systems today because
you don't want to have overhead of SS
Allison like that you simply have a
trusted Network and once you're behind
the proxy which you behind a firewall
you are privileged enough to access such
and such service and you're in so we
still have that model but most things
are when you run locally on a computer
what the difference between the
operating system processes gives you is
a hardware enforced memory protection to
the point where you can implement a
security so you can actually set things
up so that process a cannot read the
memory of process be
this kind of concept and then of course
when you have more than one computer
talking to each other security is
entirely based on if it's not based on
network access restriction is just based
on cryptography right okay now as a note
about that is if you're doing this model
of a process is made out of fibers like
erling the because you're not using
hardware for memory protection the only
way that you could actually make
security model that way would be through
a vm technology or something like you
know the the Google native code thing is
fascinating whether guys kind of sort of
dynamically soar like it just in time
compiler for already compiled code so i
think a way to look at which i don't
know that anybody else is describing it
this way but i would describe writing
code for your erling vm similar to
Colonel programming meaning that a few
things you are not you you work you are
tracking you were doing work on behalf
of a user so whereas an operating system
Orion system you might actually allow
that user to directly run code on your
computer and if you did that in Erlang
the analogy would be hey hand me a beam
compile module I'll just run it you
could do that if you want it to but
you're trusting them so you're usually
doing things like I'm going to perform
I'm going to run this function i'm going
to i'm going to facilitate this service
i'm going to run this process on behalf
of some user they have some kind of
security context that's stored in a
database or as part of our state and
that is what we'll use to enforce
whether or not we'll let an action
happen and that's what's going on a
kernel same thing so if your difference
when user space kernel space and way you
could think of that as in kernel space
yeah when you if you have a dynamically
loaded modules let's say on linux and
you let someone load of kernel module
you are you doing just that very thing
you're you're
allowing them privileged inside your
world to do anything you want and that's
why it has to be a restricted access to
something like that yeah okay so the
other great wonderful thing that the
world of Erlang does for you and in some
cases depending what you the only reason
to use it or the primary reason to do it
is because the supervisor eat logic so
that you can you know say all right
we'll we'll set up this sort of startup
procedure and this sort of advanced
recovery procedure and this sort of shut
down and graceful shutdown this kind of
thing and that is the lately depending
on how much you follow Linux world that
is kind of a forefront front burner
debate right now about kind of replacing
the system five I knit script facility
that you see with most likely looking
like it's going to be system d but there
are others that you know may went out in
the sort of natural selection of how
software it goes and you know windows
uses software control manager service
control manager bit dizzy they're the
sort of systems level equivalent of
those things and so when you're trying
to do something say to run just on the
Linux um and you and you have a
complicated dependency procedure of
which started in certain orders or you
still have the same problem solve you
just have to solve them other ways and
there's some elaborate you know creative
solutions that have seen to do that but
they're not as graceful and I have also
read about systems where people use an
erlang process that erling beam process
that doesn't do anything except control
the sequence that operating system
processes are started in and it monitors
them and it sort of watchdog for other
things because it's so useful at that
okay so another area kind of compare the
two would be when you're doing
networking or distribution so
the erling world everything is boiled
down to your message passing facility
you know if you're back inside their
regular lists you have sockets you can
still do sockets in Erlang obviously you
know one thing people don't necessarily
always understand about the sockets API
that if you're using as a higher level
is it's actually an abstraction to
several different kinds of network
protocols so we're not doesn't just have
to be you know ipv4 whatever there's an
API so in that sense it is a generic and
now if you weigh if you had to pick what
would be the equivalent of just one size
fits all message passing for native code
it would have to be sockets then when
you're inside the machine you know
native code obviously you've got some
more advanced I've seen mechanisms which
are use internal ii by erling them but
the point is that they still boil down
to the same kinds of abstractions that
you have between both I hear that
clapping is that I'm closed on okay
resource management is not necessarily
something this combo I think it was a
weak spot in Erlang in by that I mean
where you can sort of have tasks that
are associated with credentials that are
associated with you know priorities or
policies or even accounted so that's
long and stuff is it's still very much
important you say especially we're
trying to balance out different
workloads on a cloud deployment or just
balance them out and you know which
customers paying more and things like
that so area for its for exploration so
is that a message number okay this is
kind of neat you got you know the
dynamic code we like a hot code loading
airline you still distill does exist in
native code you can still do this I mean
it's done if when a native code furling
right and it analogy you would so
usually what you do as a concept where
you can dynamically load shared
libraries or pieces of shared libraries
10 okay and I you can you know it takes
more time but you can still do that
analogy is kernel modules AIX colonel
has a thing where you can load multiple
simultaneous versions of the kernel
module and is the exact same you know
concept that you use an erlang where
once all of the the users to the older
code are finished in the older codes and
it goes away what you don't have as well
as you do in say posix linux world is
the concept of your code being versioned
on disk and in such a way that you can
continue it so you can indefinitely
persistently hold different versions of
a library or a module at the same time
so you could you could I could just
store you know version 1234 of the same
library and I can have multiple users of
the same thing all working at the same
time all using it and just that's how
the system stays forever well I'm
defeating myself I'm Mac I'm almost
running out timing that was trying so
hard to go through so I thought like you
get as a thought exercise maybe just
show a curry example of some like where
you know you might try to use native OS
processes versus Erlang process stuff
and so we're going to be real hip and
think about a bulletin board system and
there actually is a bulletin board
system written in Erlang that i did find
doing a google search but I don't speak
Chinese so I can't tell you anything
about it but that might be interesting
if someone else knows about I'd love to
hear about but let's say you know let's
just sort of like job interview style
you know whiteboard something out here
so let's say we had okay we're going to
make this PBS system it's going to have
to have here multi nodes portman and
what a security model with different
users we want to be able to run you know
external doors and it's gonna have a
chat server alright so you know if we're
going to say all right let's just first
the total Erlang solution you know i
would say okay where you're going to
have to have some some port drivers so
that you can you know talk to these
external doors that's how we'll do that
way we can build us a chat server you
know that's great that's Earl and we can
do that whenever supervisory tree of
some kind will have a connection handler
facility and then so maybe we'll
associate each logged in user with a
process session handling process ok so
the connection handling thing is going
to have to have some kind of user
account database you know it could get
complicated it can be done yeah there is
ssh server and ER line okay let's sit
let's look at that if you just did
straight OS processes you can keep the
same thing right are the dual processes
we don't have to make a poor driver
they'll just simply run next turn you
know they're all individual processes
any way we can use IPC talk with them
chat server is no soul hair instead of
our supervisor tree will have systemd
instead of our connection handling will
just use SSH and then you log in and
then maybe we make us a you know a
custom shell or something that
corresponds to us and talk to all the
stuff all right so let's see how that do
this yeah so one so one thing about this
though is we had this multi-node
requirement so I want to be able to
expand the system to multiple user so
one way we get to this is just a naive
approach will have multiple deployments
of this and we'll do some sort of you
know dns trick or something round robin
balance or maybe a you know indirection
layer between so that clients get go get
connected to different ssh servers on
different nodes but let's say we want to
you know make that a little more
interesting so what you would need is
some kind of sort of session proxy
facility that takes a logged in context
connects to another computer which would
you would have other facilities and and
then sort of somehow
transcends that login credential to
another box we could build this we could
build this but that's that's a lot of
work so this I think is a good I thought
exercise as to where you where you can
mix and match the two concepts so right
off the bat you know i would use Erlang
i think is a great way to do ms to do a
communication mechanism between these
things maybe make this whole session
proxy concept out of Erlang but yet your
session handlers could still be
operating system native processes so you
could still use you could use the user
accounts on the system we can stick with
sshds or have to do anything we just
that's that's reliable trusted code
everyone's got their keys everyone's got
their passwords we stick with that on
the other hand chat server why in the
world did I not want to use our link for
that right I like the Erling supervisor
stuff and so we could we can mix and
match you know if ahead so we're like a
few minutes on time but you get the idea
that's the so that is that is it and you
know thank you for your attention and if
anyone has any questions I comments
anything so appreciate it thank you very
much
I've had a great time this conference is
the first time I've been here and I've
had a really it's I'd like to thank you
know everyone that has helped
participate I'll everyone that's helping
to do everything they're doing and
organizing these things are conferences
are hard to put together they're hard to
do appreciate everyone sponsoring and
everyone who is contributed to their
time in some way of doing these things
it's you know it's there they're fun to
enjoy but they are work to put on in
every level so I appreciate that for
everybody and I'd also say that being
that the crowd here has been just really
friendly this is just a you know you've
been to other conferences of different
you know I'm not going to make names if
you know you don't you don't have that
fun attitude people here are very
conversational they vary just it's good
it's a good crowd so feel good about
your community
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>