<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Torben Hoffmann - Erlang Patterns Matching Business Needs | Coder Coacher - Coaching Coders</title><meta content="Torben Hoffmann - Erlang Patterns Matching Business Needs - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Torben Hoffmann - Erlang Patterns Matching Business Needs</b></h2><h5 class="post__date">2014-06-16</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/LbR0LtEw_OA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">good good thank you thank you how many
of you had tried to convince her long is
a good thing how many have succeeded in
a big company one okay I'm going to try
and do something today that will help
you convince people not just in big
companies but in general i'm going to
talk about patterns from airline but
also the idioms of airline and how they
actually provide business value business
very is important there and if you went
to brew States talk this morning he
talked about the technology adaptation
life cycle when the book crossing the
chasm I'll giving talks about that
before related to our line and you have
the casimir this big crack that you want
to to to jump over and get into the
mainstream and sell it but in order to
cross you need to be able to talk about
business value it doesn't help raving on
about how wonderful some weird feature
of earning is unless you can relate it
to business value so let's let's take it
to of that and try and understand what
it is and then i'll relate erling to
this so this is enterprise software for
you so this is you can probably see
that's the death star from Star Wars for
the first movie and you can see its
enterprise software it's huge and it's
not done yet you take it to market and
you you wipe out a piece of your
competition and you have tons of people
working on this thing and as we all know
guess most of seen the movie the Death
Star ends up collapsing as will a lot of
enterprise software the question is what
actually killed the dev star this is
enterprise software and before I get
into this I I'm going to say a few
things that are derogative about Java
and Java programmers and I apologize for
that up front it's to make a point there
are still good people but they used over
so what killed the Death Star was it the
power shield breakdown exception well
they had that exception thrown but they
were able to
fire all of a lot of things that the
incoming flights anyway so they were
having some defensive mechanism against
that exception there wasn't really that
one that killed them was it then the
surface with a lace design exception I
don't know of you but I have always
wondered when I watched Star Wars for
that they have these alleys leading to
critical points where you can fly and
it's like stupid design was that what to
kill them no no no no that's not what
killed him what killed them was missile
entered unprotected ventilation shaft
exception and this is basically like the
Inquisition nobody expects the Spanish
Inquisition nor does anyone expected
missile entered on protected ventilate
ventilation shaft exception and this is
why these Java systems tend to break
because you don't think about all the
problems up front you always kill by
some obscure exception that somebody
froze so if you're like me then you
approach these people and they're having
these kind of issues their systems are
not stable and you go maybe you put your
hand up in these quorums and maybe
there's a different way of doing this
you're bold you've made it as a
different you don't say you must do this
differently I did that in the beginning
don't do that it'll just get you a lot
of enemies but when you do that you have
to expect resistance this is Java people
you've told that there might be another
way they turn into this Legion huge army
of Orcs they'll kill amongst each other
but they want to kill you and they come
charging at you and the biggest problem
with them is that they are like orcs in
the movies they're led by some evil uber
God and that's of course Larry Ellison
of Oracle he is the evil guy here he's
leading these people and they are
blindly following the path of Java like
this so what I do when I run into these
things because I'm a bit of a masochist
so I like taking on armies of Java orcs
there I come prepared I expect that when
you try to teach people the one true
religion as an erlang priest you must
come prepared you must be willing to
make
sacrifices in doing so so you come
prepared and you're ready to step the
people that are not willing to convert
religion freely so just be prepared for
that sort of thing and maybe not step
them literally you didn't get that
advice for me now okay here does anybody
know what this is no it's Latin hmm it's
actually lesson so I'll help you this is
actually the Olympic motto so this is C
choose I'll choose for tues so this is
faster higher and stronger this is your
Olympic motto that's something that well
if you forget about all the money
involved in Olympics people still
striving towards this now what is this
see choose Maya vilius that's the
business imperative of the modern world
that is faster bigger cheaper this is
what everybody wants so and don't take
that I used google translate I don't
know enough Latin to actually do it that
will so anyway but that is the business
imperium this is what everybody's
chasing in business and that comes down
to some of the everlasting software
requirements these have existed almost
since the dawn of software you had speed
to market important it had to be
reliable the software also especially
these days one machine is not enough so
it has to be scalable and then another
thing that a lot of people tend to
forget it has to be maintainable
somebody actually has to live with the
software somebody writes for a very long
time eighty percent of the lifetime of
its system is spent in maintenance such
things have to be maintainable all of
these things something that the ericsson
fought about then you have the agile
manifesto yeah so they talk about what
they value more than other things so
they value individuals and interactions
the value working software over
comprehensive documentation customer
collaboration over contract negotiation
and they responding to change over
following a plan
two points here the second and the
fourth bullet quite important we need
software that works and we also need to
be able to change what is we're doing
instead of rigidly doing something the
old-style way one of the things you can
do when you're doing this and now I'm
going to say something that some agile
people will say is absolutely ludicrous
you actually need to pay attention to
software architecture so that means you
need to have some separation of concerns
yes I know you have to think before you
start doing something or sometimes you
have to stop and think again and change
what you're doing yeah so yeah it's
quality driven there you have a
recurring styles so this is now we're
talking about patterns ways of doing
things you need some of that and then
conceptual integrity which means you
should have some sort of idea what the
system should be doing and somebody
should carry that through and it sounds
elitist but you have to have somebody
that is the caretaker of the overall
vision of the system good take all of
these things big melting pot that leads
into a little detour into talking about
erling history because Ireland was
actually created by business or company
trying to do something so one of the
things they were influenced by was not a
blank screen they were influenced by
thinking that was prevalent or should
still be so there are two ways of
constructing a software design one way
this is makes it so obviously so simple
there obviously no deficiencies that's
one way of doing a software design has
anybody worked on the system was done
like this not really yeah good the other
way is to make it so complicated there
are no obvious these deficiencies has
anybody worked on a system like that yes
so and this these wise words were
actually altered by tony hoare in 1981
my head calculations that's 33 years ago
software world still look like that but
some of this thinking and these problems
were actually taken into the original
requirements
for erlang done in the computer science
lab so you had to have large-scale
concurrency you want a soft real-time
distribute the systems for something you
need to cover when you're doing
telephone to Central's there you need to
interact with hardware that's all the
fun stuff when you're doing you telecom
you need to interact with hardware
people and these be added people that do
hardware so often and then you have to
have very large software systems
actually in the 90s there was a branch
of research where they talked about
feature into accidents in telephony
because people were bolting so many
features on a telephone switch that you
had to research into why you could
combine the features really crazy which
also means that you had complex
functionality you have to deal with and
then another thing this is a continuous
operations for many years Ericsson had
some very very clever customers some of
them said you know what you're not
getting paid unless the system works you
have continued stream of money when your
system starts working we stopped the
stream of money so that sort of makes
you sort of slightly motivated to make
sure your stuff is running there and
then related to that is you want
software maintenance on the fly you do
not want to take down the entire system
and stop the stream of money running
into your company you want to keep
things all the time and then your course
you want high quality and reliability
and fault tolerance and you're dealing
with hardware and all of this is a
little link here the slides will come
out there beyond attackers listen to
eight pieces describes is really really
well if you are in any way interest is
in technology management that is a feces
to read it's very readable don't know if
gun is here but that changed my view of
a lot of things by reading that thing
there so but now let's try and relate it
are we talking business here there how
does that relate to business needs so
reaction what they really wanted they
wanted productivity big company we want
protiviti we want no downtime we don't
want those pesky customers to stop
paying us and they weren't something
that always works modest aspirations but
this is what they wanted in business
terms but I want to translate this
slightly
because it turns out that most of the
managers in the 80s in the Ericsson they
were young in the 70s and they were
influenced by listening to ABBA music so
we can translate this and what they
really really wanted out of this was
money money money it's a rich man's
world so that's what they wanted and
this is actually and this is a key point
in understanding Ireland compared to
just about anything else it came out of
a company that needed to make money and
then you need to make money not off the
language but of using the language that
change is how we design a language yeah
so that's quite important and one of the
other things they had apart from
probably listen to tony hoare they also
have this thing in mind and you can then
debate with other languages how that
looks but if the language you're using
is simple it does not become part of the
problem a complicated programming
technology becomes part of the problem
c++ becomes part of the problem java
becomes part of the problem and even if
you go these days and you take something
like Scala it's so insanely complicated
it becomes part of the problem you're
trying to solve you do not want that you
want simplicity good all of this melting
pot has actually meant that can be used
for other things than telecom otherwise
we wouldn't be sitting here today so
good along the domains you try to
characterize them and this is good when
you're talking trying to talk to people
about when you said your user running on
when you shouldn't use it sometimes you
have to tell people don't use Erling
there so if you have something where low
latency is more important than
throughput you have something that's
stateful think that comes back to
telephone conversations they're most
stateful things in the world there if
you have something that's just stateful
let the people go release them and put
them on to the touch of Python and they
can have fun with their web stacks over
there and don't do anything but
stateless systems if you have something
that's massively concurrent so that
could be something like I'll just name
one thing what's up here that's a
massively concurrent system so we have
that learning is good
something that's distributed and that's
not just for the sake of distributing
things these days if you're successful
you're going to need more than one
machine so you want something that
distributes relatively easy there you
also want another thing to avoid having
an army of support engineers is you want
something that's for tolerant so that's
erling again and you also want to be
using OTP because if you're doing thi
stuff that does not need OTP why user
lying there and then non-stop operation
that comes in different flavors there
and my good colleague yes / spin out
there seeing her long run alongside
other systems it performs just as well
as all these other fancy things and on
the load often way better that's
important takeaway here and if you look
at this thing in doing one of these
there I'm doing a very advanced business
presentation now by the way I've thrown
in a table in my presentation that's
really advanced stuff there so you see
the different characteristics and any
look at what you want to do in messaging
web server software to distribute a
database in the queueing system the
traits of airline they match these
domains that's why our lang is
successful in these domains this is not
rocket science you can do the same thing
for whatever technology you come up with
and then you have to see doesn't match
the needs of the domain erlang despite
coming out of telecom fits a lot of
domains very very well good and now
since I'm the earning priest I'm going
to turn this into something that has a
slightly religious feel to it the golden
Trinity of airline this is simple this
is something you can print and you can
hand it all over to people and you
explain to them what the key tenants of
earning is this is why and this is why
erling is in engineering masterpiece
this is how you won't together these
things into something that's utterly
amazing nobody else does this brew state
set this everything this morning nobody
else has this combination right so you
have share nothing you have failed fast
and you have failure handling these are
the tenants the golden
trinity of earning so i'll just go
through them because i think you know
all of them quite well so you have this
we have memory and shared memory here i
lived in a company for many years where
mission-critical systems were done with
shared memory this kind of sucks when
the one process dies because it corrupts
the memory and the only thing you can do
then is to kill the other process off
and where where I was that meant you
have to have one machine go over to the
stamp by machine that triggered alarms
and they triggered phone calls all over
the globe and then some engineer had to
be called out at 3am in the morning
listening to some vice president being
very very angry you do not want that you
want to avoid that conversation it's not
a pleasant one so in Erlin of course we
have memory spaces for each process and
that means with the when the poor
process p1 there it dies it corrupts its
own memory space I think yes it does and
then we just wait for the garbage
collector to come along and everybody's
happy this is how you do switches in
Erickson that has nine lines of
availability you isolate these things
good then we have things with failures
the older you get you more you realize
that this is just true everything will
just go wrong I used to believe
especially with the first one here
programming r us until I turned about 30
I did not do programming errors and I
couldn't imagine myself doing a
programming error I'll write a few test
cases everything works no programming
ours yeah then you grow old and you
realize you will continuously do arrows
the only the only persons that do not
make programming ours are the ones that
never code so yeah and then there are
other things just making this slightly
more difficult disks will fail on you
then people will just use memory instead
yeah well memory will fail as well so no
safe haven there and then another thing
special because you're doing a stitch
beauty stuff because you're making a ton
of money and you have a lot of users you
have the network in and it will fail not
only a 3mn morning networks they fail
all over the day on top of 3 a.m. in the
morning and when you look at this
most paradigms out there their fault
intolerant this is how the death star
collapsed some exception was not handled
somewhere entire thing explodes that
means in these cases you deal with all
the errors or you die this is the way
you do that now you're speaking of
movies then it's it's outbreak this is
dustin hoffman you cover yourself up and
all sorts of gear and you go out and you
fight the little were bacteria and
viruses and you try to survive not so
much you like but yeah there you go in
erlang it's fault-tolerant by design no
other language is fault-tolerant by
design and that means you can you can
say something that would sound very very
strange to other people failures I
embraced and managed this is a way to do
it and it sounds crazy but basically
it's all about being slightly hardcore
about things so if you take a beating
you get up and you get on with your life
and your system and what better way to
characterize that by having Chun code
phantom in blood sport he takes a lot of
beating he fails over and over again but
he manages that and he gets up and he
survives now how does that look in code
so here we have a piece of Berlin code
this is not good code because you can
see there's this red stuff in it there
so here we have a convert function
they'll take a day and turn it into a
number of the day of the day in the week
and you have one there if people calling
you the wrong thing you'll turn it an
error this is not the let it fail way no
no we burn that code woof and we're left
like this and this is why we say Erlang
is not friend of defensive programming
Erlang encourages offensive programming
and then here is a short career advice
don't run around in the halls of a big
company saying we just let it crash just
let it fail it is not good for your
career prospects people will think
you're insane use other words don't fall
into my mistake on that one
so anyway so its offensive programming
another thing that comes out of the way
erling is built up and that's not just
the design of Everlong it's the people
doing the libraries around it but it's
in particularly easy you know like if
you do intentional programming and that
comes from your Armstrong's dr. thesis
their way it's a starter program where
the read of the program can easily see
what the programmer intended by that
code this is actually very good when you
have to maintain the code there and now
we're also intentional dictionary this
is the thick dicked library foam from
airline so you have a retrieval thing
that when you know if the key you're
looking for is not in the dictionary
it's an error and you should fail that's
my intention here I know the keys there
so if it's not there there's a big
mistake and I have to fade right now
that's your intention with this code you
can also do a find where your I'm not
sure if this key is in the dictionary so
I'll do a lookup and I'll deal with
either having okay and the value or
error because nothing's there but I'm
not failing here and then sometimes you
just want to know if it's there and then
you can do the East key function here
just look up if it's there this means
the intention of what it is you're doing
you can write that in one piece of the
line of code and people will know what
your intention was and know what the
context is supposed to be there now now
we have to turn this is into business
benefits and there are basic benefits of
let it fail this in Henry's I don't know
if he's here but big kudos to him for
doing this this was done a study done by
again Henry I actually okay that study
start back in 2002 when i was in
motorola that was back in the day when
motorola had enough money to have their
own lapse that could do research
together with universities so he rewrote
a hideous c++ application data mobility
application I was acting one of those
where there was one guy that knew how
this animal worked and we were not
allowed to piss him off because he must
he will no one service and is allowed to
leave the company because nobody else
knew what the c++ animal did luckily he
was a nice person so you
oh you didn't feel like pissing him off
but yeah so if you look at this analysis
here code that actually solves the
problem this is important code that
solves the need of your customer that's
the app code and you've got all sorts of
a left hook that code amounts to a
massive I'll be kind today nineteen
percent of the code in the original seco
nineteen percent of the code so when
you're looking at a screen nineteen
percent of that code is relevant to
solving the problem the rest of it is
related to all sorts of funny
disciplines within C++ defensive Code
twenty-five percent ah bunch of type
decorations lots of communication
everything and then if you want to turn
into something that others can use it
goes even worse and then you down to
like twelve percent of the code actually
matters and the rest is just all sorts
of other things not related solve the
problem enter earning and you jump above
sixty percent of the code actually being
related to solving the problem you're
looking at this is massive so when you
look in the screen 3 three-fifths of the
screen is relevant to you that's not a
lot of noise on the screen this is
beautiful when you have to maintain code
it's a massive time saver so here we
have a long as being three times as
productive this was not enough to
convince everybody inside motorola so
even when after we had some successes
there people were constantly saying
burling is so great blah blah blah why
is not the entire world using it so I
got tired of that I could basically tad
also having my bus bringing this up in
the you know you have the appraisal
things and you yeah what this erling is
not going anywhere blah blah blah so I
stopped that by doing a function point
analysis in function point analysis you
measure what's coming into the system
and what's going out and what you have a
storage inside the system so that's like
a language neutral way of looking at the
size of a problem it fits telecom
protocols amazingly because there you
have a lot of pd use coming into the
system some goes out and you can see
what sort of states you have there so
you can estimate it so i did a
conservative estimate of all of that and
measured up against the amount of time
we used for this and actually if you
look at this
the small print here it included all
things not related to her long as well
box test well well I love written in
quick check so that counter serving as
well system test that's actually the
people down in the lab in the basement
yeah system test always takes place in
the basement they're so so they those
people there they had to spend time on
it and you also had to pay for project
management at still some learning curve
and everything when they've all been
like three and a half times faster than
people would that would have written
this in Java or C++ this was a huge win
I fought for for my career and my
prospects it meant that nobody was
teasing me anymore it also meant that
nobody talked to me because then we
don't understand this it's out of this
league so we can't talk to this guy
until about a year after presented this
my manager has been one of the forefront
orcs trying to keep me down there he
came running down and said we have this
problem do you think you can solve with
it are like and you just sitting there
yes yes yes this is this is perfect so
we had to look at that and that's the
kind of thing you have to expect in some
big organizations in direct praise it's
a maximum you'll get as I didn't do this
huh can you repeat this I want to know
that's a good okay now I'll have a
little intermezzo and the internet so is
also a word hour on nim so which uses
his in his fantastic book my system has
any of you read that book no okay even
if you're not into chess get it and read
it because basically he's the father of
modern positional chess but the the
peers in his time and he started writing
these things around the First World War
his peers did not understand him he was
seen as weird and just not to be dealt
with and that also meant that the guy he
became slightly paranoid about things so
actually in the book you have sentences
like but here my lesser intelligent
critics will probably say blah blah blah
but I refute that so it's written in a
very funny style
the thing that actually happened with
him was that he I ended up putting some
concepts in place on how to build your
chest came around he came up with a
language for talking about different
things and kiss up until this point this
was just was more like less like a
gentleman sport where I am white i
attack you to death or I die when you
refuted my attack that was like
gentlemen sport of chess he made
positional tourism people say it's more
boring but there you go things change
over time there and then it comes down
to languages and models so this is an
example i tried ahead yeah god forbid i
was i was forced to go on an object
oriented analysis class i was allowed to
opt out of the design part i had to take
the analysis so had this example that
you have a railway system you want to
create a security system for railways so
you know that your trains running around
on the tracks and you want to avoid them
running into one another so the big
question here is when you're doing the
main model of this how many trains can
you have on one piece of the track can
you have zero one or can you have zero
too many there me I came out of a formal
specification background so I say okay
this is simple it must be 0 to n because
co2 one is just stupid because that
means you can't model trains running
into each other so how can you prove
that your software actually works this
is actually very important the answer in
that class was that it's okay to say
that you can not model tracks running
into each other then build software top
of that the main model so you can't talk
about them running integral because it's
just business logic this is just scary
you need to have a language for
something if you don't have a language
for something you can't talk about it
and this actually relates so then how do
we talk about Erlin being great how do
we talk about the things you know not
being great and you need to have a
language to explain express the
greatness and so here one second i'm
going to alarm you slightly code is not
enough to express the greatness of
airline some
times you need more so and what I've
done and try to do and with the help of
other like yes / and the people
companies to do visual erlang every pun
on visual basic also intended here
really trying to touch today so the
objectives for me in doing this is that
I want something that is detailed enough
to explain what's important in an erlang
system I will not try to explain every
little semantic detailer Berlin I think
there are language geeks in the academia
that will have way more fun with that
then I will I just want something that
helps me communicate the high level
points and I want to standardize on how
we show like architecture if you do a
bit of googling for lying and some
architecture you will see like five to
ten different ways of documenting it
rolling architecture and you have to
figure out what they mean by their boxes
and things on the screen it's on github
there so you can go and follow that and
I'll make announcements every time I do
updates to it on dueling mailing list
there there's a PDF there where you can
see the notation so I have some
processes here so this is how we marble
processes all processes are just things
in the ellipses sometimes they turn into
circles but service or also listen so
that's fine so have you have notation
for a one process monitoring with the
other you have for when two processes
are linked you have a way to spawn
another process you have a way for
notating how to send a message where
there and then you have exit signals and
actually you can see you q there at the
bottom it's actually trapping exits
that's why it has two servers around it
now I have a way to depict processes
then I add things like here we have
functions that's just a box for the name
and they are attained it if you have
state data and a function that means
that you have a process that's living on
and has some state data in it then you
use this wonderful I don't knowing what
the name for that kind of figure is yeah
but they were here you have a process
here that has some public API function
and has some state data inside of it so
now you can start talking about what
goes on in an erlang program without
having
to say to people just read the code now
with that in place I want to have some
erling patterns out in the open because
this is then when I can start talking to
other people say if I do this particular
problem inner line this is how it's
going to look it's sort of a pattern and
people who could probably relate to that
more than they can relate to a chunk of
Ireland code and I once again this is
about having a way of talking about
architecture and also if I've done
something I think it's smart shared with
other people so they can learn from it
that's what you do with the patterns
it's not about her being able to it I
can use listen this in this pattern and
no it's about communicating and sharing
insights and again another thing we have
in this and this is again we're running
is amazing we can consider failures
while we're designing the system and
this is important if you want to realize
the the business benefits of running so
now i'm going to throw some very ugly
hand on things in here this is a tuple
space storage pattern yeah this is one
of the simplest one yes but I we could
come up with in this case you have a
process here that is sitting in front of
it and it's table and what you want here
is you want to serialize the sequential
eyes the rights so that only one guy
right to it and then lot of people can
read from this table so you want to
protect it like that and what you have
here is that you have a function here
that lives in the module space up there
and it takes a key and then it takes the
table name and the key uses the lookup
function on the edge table and returns
the value it finds it so deal with that
key good the right thing we associate
that with the process we've started and
saying if i want to write into this
table I need to call the right function
that's governed by the process and then
you sit right to the table that you will
you're having and then you get true back
when you've written it so this is a
typical pattern you see in summerlin
programs and if you want to see an
elaboration of this pattern you should
go to see yes plus talk right after mine
while he's talking about fuse and he's
using an elaboration on top of this
pattern and this is actually funny
because we could
talk about these things oh you're using
that i am using that an animal putting
this on top of it that means you have a
way in a vocabulary are talking about
things this is where you start moving
things along and by the way yes when I
we have no aspirations of becoming the
Gang of Four we only two so you can't
become a gang I don't think we want to
write a book another pattern here manage
your work a pattern this one is when you
have things like you get a request in on
a web server and you need to get a
number of resources you can do that in
parallel because they don't depend on it
one another so what you do is you spawn
off and monitor a process a manager
process that will run each of the
workers that does the fetching of
whatever it is you need to find and the
manager actually spawn links all these
workers so if one of them dies it dies
you're monitoring it good you're
notified about it when they return the
results the manager collects them up and
then it sends a list of the results back
to the process and then you carry on
this is also a trivial pattern you've
seen a lot of web servers in the Allen
world and we named it the manager worker
pattern then what we started with was
not these two patterns we said that
supervisors they've got them easy we'll
just do them this is not easy this is
what we managed to boil it down to and
of course it will get the patterns out
will now be nice PDFs 23 pages with this
kind of drawings in there the drawings
will be done in latex it will not be my
handwritten things that will go in there
but the thing is you need to explain
these things and this is actually the
simplest we could get to and that when
we saw this we realized one thing one
major thing about Erlang and the
adoption of the language supervisors are
not as simple as we think most of you I
can call you up at two a.m. in the
morning because this is not an error so
I'll call you over to an m in the
morning and ask you how does it
supervisor work and you just say put a
little bit of the book everything comes
out you know it but for newcomers this
is a big hurdle
all the moving parts here what are they
doing so now I'll try to explain it so
you have a supervisor here have a
process that traps exits it has a
configuration consisting of a restart
strategy and it check the number of
child specification and it also has some
state data here a restart history so
when you call the start link up here I
can actually point like this you have to
start link here it invokes this internal
functionality that's an extraction
mechanism I introduce some sort of start
mechanism and the start thing what will
that do it will take a look at the
restart strategy and the child specs and
then it will start and number of the the
children of this process and it will do
it with a spawn link here and then it
will update the restart history now the
children here they can fail when they
fail the exit signal will go over to
some supervising functionality that will
have a look and read the restart history
and take decision of should I start
restart that child or should I go to the
terminating functionality and then emit
an exit signal this is sort of thing
where you need to have that in drawing
like this and then with a suitable good
explanation in writing and this is
important when I come to a yeah
basically I have to go to a Java person
and explain to them what's going on I
need this kind of material in order to
explain to him what's going on or I let
him loose at the OTP documentation and
hope he doesn't kill himself before he's
done reading it so this is where another
reason why we want to document these
patterns is this is a knowledge funnel
so up here everything is a mystery then
you start having heuristics at at some
point you have an algorithm so every
time we can document another pattern
we're taking something out of the
mystery range into heuristics and maybe
down to algorithm if we turn a library
out of it but this is important this is
how we grow a body of knowledge in the
Erlang world because it's not about how
you can do a fancy list comprehension
it's how
you build a system and this is where
repeating patterns are quite important
good then how does this relate to
software development so here you have a
standard agile development team they are
having a lunch break and my question to
you is this guy over here you know who
that is it's a person in an agile team
any ideas no he's the one that's just
about to fall off that beam so that of
course is the product owner agile teams
they function very much in the same way
as football teams to when the team is
losing you kick out the manager and the
agile team is losing you kick out the
product owner he's not doing his job
right so if you're the product owner you
want to take out the business benefits
of Erlang and the supervisors to survive
and the way you do that is you know that
only one process dies we've seen that
only one process dies and it's only that
one that's impacted by things so we only
have this isolation it gives you
continued service it's very very rare
that you fire a person that has a system
that continues to run system is making
money for the company it's very hard to
fire those persons they have to be
pricks basically to be filed you have
locked everything in a good way first of
all you have the standard error traces
in Erlang but you also if you use along
the right way you end up having things
lock so it is easy to to figure out
things so you know what is wrong when
it's failing and that means that you can
take a look at something and say I know
why this is failing and you do that very
fast I had an instance when we were
doing this berlin-based gateway in my
motorola days that came up to the
competitors in these iop testings and we
are fing failed I was passed for this oh
I had realized that I could do mistakes
in my software it failed we had a look
at it twenty minutes later we had a fix
for it five minutes later our
competitors equipment failed I could see
in my screen while
renault one I was thinking he pointed
out to the screen you have to fix this
and then these two system engineers at
system tests they had to bring out their
army of 528 developers to fix it after
I've talked to an army of 528 system
designers and then lo and behold 24
hours later they had a fix for their
problem this is what you get with early
you get into something we know what's
wrong and you can fix it really really
fast another thing with the supervisor
it is that if you have a corner case you
could fix it at leisure so if you have
something that happens once in a
fortnight in a blue moon you don't need
to fix it instantly you don't have
you're not running the Deaf star things
will not collapse over one exception and
will take you out of business if you
have something that's wrong in the
corner you can have a look at it and go
hmm you'll take me that much money to
fix it it'll save me that much money
over just doing a manual fix to this
I'll take the manual fix that means the
product owner is in charge this is this
this guy wants to be in charge he does
not want the software to be in charge
because that's was taking him down the
route to being fired don't know about
you but most people do not like to be
fired on a regular basis so and here
actually have a software architect at
the supports iterative development going
take your first random java architecture
does that architecture the software does
that support iterative development I
think not Berlin systems done the right
way actually support iterative
development that means if you want to
cruise with our line you can have this
one tattooed somewhere on your body or
you can just print it and then show to
people but that you understand the
failure model if you do not understand
the failure model on how it fits
together with letting a crash and these
things you cannot program an airline you
can say that then oh I want to do some
Alexia and then I can do Ruby stuff on
airline fine you can do that but if you
do not understand the failure model your
programming Ruby on the Java and all the
year
vm and none up too sure how many Nobel
prizes you can get for that I think none
so understand the failure model you need
to embrace failure things can go wrong
embrace it because this is the only way
you can build systems like the wet sap
system that are running around 600
servers 600 servers you can only do that
if you embrace failure but you have to
talk to it about it in the right way
explain to her and then you use the
patterns here to deliver business value
because you stay in charge and avoid
having you chasing the software trying
to stay alive and keep your job good
thank you thank you so let's say do we
have some questions yeah just a quick
question do did you put this vocabulary
so somewhere or did you get it from
somewhere or the Graham I mean they did
Airlines etc I mean the steps you take
to document and architecture well it's a
mixture of two things I used to be a fan
and still am off to process methodology
as a notation for talking about their
systems the problem is it hasn't
slightly impedance mismatch with the
Erlang so I was advised by could friend
to say do your own notation for a line
and then I just started looking at the
kind of things we had in her lung
solution how we talked about systems and
how people talk about things on the
owning mailing list and then I started
putting this is the kind of vocabulary
we need to have there and you can go
have a look at the the github repository
and see what's going on there and i'm
updating it as every time i have a
little bit of free time update that and
then try to move it forward like that hi
this is guarding against Ibaka
vocabulary I mean the same thing that he
asked I was wondering whether the manage
and the worker pattern that is short are
we saying that because behaviors are
eventually patterns
mean so when we are saying manager and a
worker pattern is are we saying that is
it a new kind of behavior that are we
moving towards or it's much smaller than
that right now and that is why you've
pointed the way you coined it yes and no
just to make it complicated in some
cases things are just slight tweaks and
reusing the existing OTP components in a
particular way in other cases you go
wait a minute I actually I can encode
this into a new behavior and then you
should do that but I would be hesitant
to do that right now or make sure that
over time that you say this is actually
something I can put into a library and
I'm not sure even the manage of work I
wouldn't put that into a new behavior I
probably put that into some sort of
library component and that quick check
the hell out of it to make sure that
I've covered all corner cases in it
because then that may it makes it even
more valuable for others they can put
this kind of component into the
architecture but you have to remember
one thing and this is where the pattern
movement of Java and the overworld has
failed tremendously it's not about
patterns the patterns are not the kind
of things you have to be able to talk
about it and then no know how to
architect your software it's something
you use to talk about what's going on in
your software because then you have
these java people they're sitting there
and then I throw in the visitor pattern
on top of the factory pattern on the
factory factory pattern that's not how
you do software you think about how you
want to structure it and then when you
want to talk about you say by the way
this follows this pattern this follows
this pattern and it's the same thing we
need to do here we need to take the
things that we see there's something
valuable in this let's see if we can
codify it in some way in a pattern
description at least now you have a
language that has most of the concepts
of rolling around and then you can start
describing these things and hopefully
all of us will benefit from knowing a
particular pattern does that yes
okay good thank you very much again and
remember to vote</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>