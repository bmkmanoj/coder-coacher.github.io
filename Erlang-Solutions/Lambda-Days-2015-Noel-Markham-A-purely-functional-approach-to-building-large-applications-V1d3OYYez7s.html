<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2015 - Noel Markham - A purely functional approach to building large applications | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2015 - Noel Markham - A purely functional approach to building large applications - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2015 - Noel Markham - A purely functional approach to building large applications</b></h2><h5 class="post__date">2015-03-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/V1d3OYYez7s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">everyone thanks repents my talk that
seems quite surprisingly busy room so
okay can I just get a bit of a show of
hands to start with uh who's is a
scarlet developer here that's good okay
who's not a scholar developer who's
never seen Scala code in their life
right okay so this is going to be quite
involved with code so hopefully you can
follow along there's plenty of kind of
functional ideas that we can take away
from this I'm in the scholar raffle
right now everything we're going to be
doing is code I don't have any slides
yeah okay I came across this plug-in
last week or reckful resent don't have
anyone heard of that so so I'm trying
that out so if this goes wrong that yeah
there's no talk okay so i said so it's
called a purely functional approach to
building large applications okay and in
in the 45 minutes I've got we're not
going to build a large application but
we're going to make a little bits of one
maybe and then we can maybe see how that
would apply to two larger applications
okay so like I said everything I do here
is going to be in the wrapper so the
first thing I want to do is I want to
bring in another library in scholar said
library at people familiar with that
yeah yeah people use it people scared of
it yeah okay all right we'll be using
that quite a bit today so just to prove
I'm not lying like I said everything
I've written here wit we're going to run
as well so this is actually going to be
a real thing so we're going to import
scholars out and then you're probably
quite familiar as well we'll bring in a
few a few other imports so we're going
to be dealing with futures so these
imports are generally what we use for
for playing around and evaluating
futures particularly in wrapper okay so
i'm going to introduce you to a couple
of functions that have been provided to
us by someone else that we can
effectively treat it as a black box we
know we know this is what we want to use
but we don't really have much access to
it we can't change these we can't do
anything else with it all we can do is
call it so the first one is in this
object called Twitter and we get a new
method here called get tweets and we've
got some parameters we can pass so the
name so that'd be like the twitter
handle of whoever we want to get the
tweets for and then you know an API key
and secret you know it's kind of
standard stuff for getting getting stuff
over over HTTP and this produces a list
of tweets and it completes me
synchronously so it completes in the
future I've also just provided here just
just the type that will be using so a
tweet which is made up of the actual
user who said it and then what they said
okay so once we've got this is this okay
at the back is this all legible and
everything okay yeah okay so once we've
got this weekend we can then call called
it call this method given say twitter
handle and then an API key in an API
secret naturally this completes in the
future so we have to block on the result
and then we can just inspect exactly
what we get here so we run that and then
we can see these are some of my most
recent tweets okay so what I thought we
could do is I thought it'd be
interesting and there's a few of these
Twitter box you see on the internet
which takes someone's input and then jut
like jumbled it all up and then produce
some some new text that kind of looks
like what they said but it's all a bit
weird you've seen those before they're
called ebooks sometimes like horse
ebooks and recruiter ebooks and things
like that no okay well generally they're
called Markov chains so what tends to
happen is you get a dictionary of some
text that text is analyzed and then that
produces new new text so what we've got
here is this method called generate
string which takes our string which is
going to be our dictionary and then this
value here called context and so what
this is that this is effectively going
to be how far we look in our dictionary
when we're creating new strings so
we have explained that the best but say
say we heard the string I don't know my
name is null my name is Christmas in
French so then when it comes to
generating a new strength if we had a
look ahead of say two and then we saw
name is from the original dictionary
fifty percent of the time the next word
is null and then fifty percent of the
time the next word is Christmas so we've
got this kind of weighted average here
and then we can then produce some some
random random data that it kind of looks
like I said it may be or it might just
be a bit weird ok so again this is
another another API that's provided to
us we can't change this this is what we
need to deal with ok so if we want to
plug these together you know we're in
the rattle here so we can we can
probably not do things as cleanly as we
work so we can take this this function
that I wrote on the previous slide we
can block on the result of that because
that was a future and then when we get
our list of tweets we can then
manipulate these into a string and then
call our generate string method and
maybe get some funny results so here's
our two methods and then when we call
random string we get just weird stuff
that kind of i might have said or
perhaps it's just a bit of a weird
insight into my thoughts yeah ok so what
we've got here is we've not we've not
done this in the most idiomatic way
really you know we've we've blocked on
futures you know we've kind of hard
coded everything in together let's see
let's see if we can make this a bit
nicer so because we're dealing with
futures we can effectively treat these
as like monadic sequences and bind on
the results and then produce a single
future at the end so this could be a
particular implementation of that so
we'll call get tweets and will bind that
result when it completes to this this
value here we will then manipulate that
from the list of tweets into just a
string and then we can pass that string
to our generator which you know we don't
know it might
be an online service that's really smart
or it might just be local and take a
while to process we bind the result of
that are and that's what we return and
then here as well I've just I've just
moved the configuration we had off to
the side so the things we needed to make
this rumors you know the API key and
secret that Twitter would need and then
I've said here that when we're
generating these chains only ever look
at looking in pairs of two words so if
this context was like six we'd get six
words and then the chances of finding
deviations in the text I've written
would probably be quite small so this
this then produces the same results as
we saw before giving giving it a twitter
handle and we block on the results we're
just going to get results again and yeah
sometimes sometimes some funny stuff
comes out yeah okay so what I thought we
could do is is try and extract this
configuration because right now it's
still hard coded it's still in our
source if we wanted to change this or if
we had different environments then we
know we need to we need to be hard
combing this in right now so what I
thought we could do is is maybe separate
this into some some slightly different
thing kind of it like a configuration
object but before we look at that I just
want to take a sidestep and just have a
bit of an explorer functions and they
shouldn't really be much surprising here
okay so we've got we've got a pair of
functions one that that takes a strain
and returns the integer well it takes an
inch or turn the boolean and these
pretty much do exactly what we say on
the 10 it's functional programming so
what we can now do is we can compose
these together so we can make function
cycle is even length string and that
would be take a string Line get the
results of that and then map that result
into another value so using this is even
and I'm just going to make a sweeping
statement here I'm going to make a
couple of these yeah and what we can say
is that
we can actually treat functions as
functors so these are effectively things
that are mappable so we can effectively
take the result of that first function
and then apply another function on it
and map that result and these these two
functions that have written here that
you know these do the same thing and
that they shouldn't really be any
surprise as to as to how this works okay
so then like so we're going to create
this this config object and it's just
just a nice place where we can collect
the information that we need and then
what we can do is we can provide a pair
of functions here so we can have a
function say just to grab the key from
our config given a config that gives us
the key for this example you know we're
just working with strange but I imagine
in a in a more proper application this
would probably be its own type but then
given any old conflict we have in the
world we can then get those values so
then you can probably start see now how
you would would what would wire up a
method to function called key and secret
given a config it returns a pair the
first one is the key second one is the
secret so this prayer you know there's
no there's no surprises here this is
nothing new hopefully so we can have
this function here where we create a new
function and then that takes a config
and then we pass that into each of the
functions as a tuple and we get what we
want so then we can then provide
configuration into our function and that
just works as as we'd expect but I
didn't run it here so here we go ok you
know there's nothing surprising so what
we've done we've successfully extracted
the config we're good to go that's great
but let's just hope this just before we
move on let's just have another think
and see if there's a slightly better way
we can do this so like I said functions
are our mappable in essence but
they're also flat mappable as well and
so we can treat functions as monarchs
and what what we're saying here is that
given a function we combined onto the
result of that function and then we can
take another function and apply that
function if you need to and unbind on
the result of that and then yield our
response so this is quite a trivial
example and you can imagine we could
build this up from lots of functions
that take a config and return something
and then we can bind on those results
and then yield something at the end and
notice here this is this is not an
explicitly brand new function I've
created here I've just used the fact
that these are functions in order to
create a more grand function and this
this almost builds on what rune I was
saying earlier is that we can deal with
these smaller smaller constructs and
then we can plug them together
appropriately and as long as we can
reason about all the single parts we can
reason about the fing as a whole and so
these two these two implementations I've
shown are basically the same thing oh
okay so far yeah okay so let's see what
we can do this so I've wrap I've wrapped
our two functions we have here in two
new functions so we pulled the
configuration out and we say well all we
really want to do when we want to get
tweets all we really care about is the
username that's all we know we don't
want to care in our application that the
API key is correct and the API secret is
correct that's all part of the configure
of the app and if that changes it
shouldn't have too much in effect on the
way the application works so we'll
extract that out and then we'll provide
a function that returns a function that
given a config gives us what we want so
we've got conflict here returns our list
of tweets asynchronously given that
conflict this returns a generated string
eventually so it's just a reminder these
are these are our signatures here so
then we can then provide
an implementation of this using flat map
and this might be one way you'd write
this so using the for comprehension we
could then call get sweets and bind on
the results so what would the result be
in this case well it's not actually a
list of tweets it's a future of a list
of tweets so we're kind of back where we
started it at the start of this little
exploration in that we would then have
to say block arm on the result of this
and then that would then give us our
list of tweets and then we could do what
we need to do to make that into a string
and then call generate strings so we're
not really that much better off right
now even though we've got the
configuration extracted so let's just
take a step back and say and see if
there's anything else we can do here so
from before we had these two functions
nothing nothing's changed but what I
suggest we could do is we could wrap
these in a slightly different type that
types called a reader and all I've done
here this provided by scholars add and
then all I've done is wrapped the
function in this reader construct and
then the type that results from that is
a reader of conflict to string so the
the first type is the the input to our
function and the second type is what's
returned from our function so i'll tell
you now for free that a reader is a Mon
out as well but then also it also gives
us this this function here run which
then when we pass in the given type it
then goes and execute whatever that
function is inside the reader so we can
see here that this then no sorry this
then works here as as we'd expect so as
before we can treat reader as a monarch
so we can use flat mark or for
comprehension and we can build over this
and law this is this is
same code as before except that we're
dealing with different types now so
rather than functions earlier which was
which is a really nice convenience that
we could use functions now we've got
this other thing called a reader and
then again we can we can actually create
this and then we can call run with our
config and then it just works as it did
before does this what makes sense so far
yeah yeah yeah ok so again we've not
we've not really made much progress here
or all I've done is actually provided
another level of indirection you know
we've still got this problem that we're
dealing with we're kind of futures are
getting in the way so the nice thing
about the reader Mon art is that it
provides a monarch transformer as well
and then we'll come on to that exactly
in a second but I just thought we'd take
a little assign just to have a very very
brief explore of what mono transformers
are so for those not familiar if we have
kind of stacked monarchs here so we've
got a future of an option of something
and then if we want to work with that
something scholars EDD provides us with
a new type called an option t and then
we can wrap our future of option of
something inside an option t and then we
can then almost just pretend that that
future isn't that so it's almost like
we're dealing with an option here again
so we can call map and then the function
we provide will then work on the value
in the future of that option and then
the nice thing as well is is that this
then also respects the way options work
so if it's a future of none when it
eventually completes then this map will
do nothing so again notice here that
when we're at this point we're actually
not not with our future of option of
something anymore with a brand new type
and so we need to then flick back to our
future of option with our run method
which provided an option t and then we
can just work on this as usual and you
can see here that we started off with a
sum of one when that completed we wanted
to add 9 to it and then when we
extracted the result we could see that
was the same so this functionality here
is specific for options because this is
an option t an option transformer and
and so the same thing is is here for for
the reader monitor as well so just as
earlier when we had a future of an
option of something if we had a reader
of a future of something we can abstract
over that future or any modern in
general so it could be a reader which
eventually returns an option of
something and then we can abstract over
that option much like we did with the
option T on the previous slide and then
just work with it as as as you as normal
so to use the reader tea let's say we
had a function here so takes a string
and returns a future of an integer
really really really simple function and
then I'm going to say another sweeping
statement here is that this function
here works in exactly the same way as
that reader constructed a minute ago so
this expects to take a single argument
function which returns a Mon out of
something so in this case it's going to
take a string and return a future event
and then we'll just help the compiler
alarm but it can usually work this out
itself and then this is the type of that
bat value here so in a way we've kind of
like extracted everything that was
getting in the way from art from our
things earlier so in this case are our
input as a string and then this all
happens in the future and returns an
integer and just like the option to
that's someone on itself I haven't
actually demonstrated here maybe maybe I
should but we could then run map or flat
map or anything similar manar decor or
stack are the ones of these are and then
when we call run with our string input
those functions all get called and the
input comes out of the other end all
wrapped inside the the mana that we were
obstructing over okay so now now that we
have this we can we can input string and
call run and then as soon as that future
completes we get the value and that that
is 11 characters long okay so back to
what we were doing earlier hi questioner
on the other what sorry yeah sure okay
so you're going to stretch me now so
this comes from the term wisely arrow
which is effectively just a fancy way in
category theory of saying a morphism
between two categories so it's just a
function effectively and we can think of
it as a function is going from one
domain so in our string in this case
into the future of integers okay yeah
yeah and the reason for this import this
is this is inside the skull of Zed prime
package but it's not an explicit input
so earlier when we did this this pulls
in lots of types but it doesn't actually
pull in closely and there's a few I
think even some of the option T stuff it
doesn't pull in as well is that okay
yeah okay so back to back to where we
were so we had our example from earlier
and this this is what we come up with so
we want a function given some config
goes and computes our result but then we
worked out that this this wasn't great
this was this was getting in the way
slightly
so taking one I just explained about
readers and reader tease we could use
reader tease in this case here and I
think it would look something like this
so we have this closely construct which
takes a config and then we can just call
the conflict here and then this returns
a reader T of this type here so we take
our config and it's going to return a
future of a list of tweets but we've
separated these out now so we don't need
to worry about it completing in the
future while we're working with it and
we don't really care about the config we
just know that at some point when this
gets run in order to run this we need a
config and so we can just say right well
here's the function you need to do but
when you get your config how to run it
ok and then race you know the same thing
here for generating our string we have a
function here given the config will then
go and do it all good no I did this
earlier as well sorry that imports on a
slider I end up not running so there we
go so now now we can have another go
where we got blocked earlier when the
future is getting in the way we can have
another go now that we're dealing with
read at ease and I think the function
would look something like this so Rita t
is a monarch and so when we call get
tweets we bind onto the result of that
so that will be a list of tweets we then
massage that information into the
representation we need in order to pass
in to get string and then we bind on the
result of that and that's what we end up
returning so one thing to note here is
when when this function gets called we
don't go and run it all we've done here
is effectively created a little script
and all we're really saying is when I
give you some config this is what you're
going need to go and do ok
and just just while this is on the slide
as well just just try and recognize the
code I've written here because I think
we'll be seeing this a little bit and
again and in fact we've already seen it
already we saw it here and look this
code is very similar but this this was
when we were white wiring conf again
automatically so yeah just just just
keep an eye on this code and we'll see
how this changes as as the rest of the
top goes on so then we can we can stack
this up for a particular user so we can
call it for me and then we can call run
with some config and then when we then
call this function it's going to do just
like we did before except now our config
is out of the way and now we don't even
care about the futures this will make
sense so far yep okay so we're kind of
done here really we've written our
application I've proved that it works
because I run it so we're good to ship
this and and go home but maybe maybe we
should just have a little thing about if
we can make this testable so I think one
thing we could do in order to write some
tests would be something like this and I
must apologize just with this
presentation system the code tends to
get quite busy or I think if you wrote
this in your day job you probably have
longer lines and things like that but
all I've done here we're working with
the same function and I've got a pair of
parameter lists now and I've
parameterised the two functions that we
needed to call so I'll call to Twitter
and then I'll call to our chain
generator and then I'm just going to
inject these when I need them and so in
our production code we would then put in
these concrete examples say go off to
Twitter uncle
and go to my generator and call that and
then we can wire this up with whatever
implementation we want so if we wanted
to say provide something like a mark or
something that we've written ourselves
we could go and do that and this this
starts the time I've done of people saw
Lars is taught yesterday when functional
marking this is the same thing you know
this is nothing scholar specific this is
nothing scholars that specific this is
purely using functions as parameters
we've got higher order functions here
and look this code here it hasn't hasn't
even changed and so the question then is
what are we going to do to test this and
thought what we could do is use scholar
check people familiar with Scarlett rack
use it yep yep okay so let's let's bring
scholar check-in that's all we're going
to need for today and then for those who
are not familiar with Scarlett check
what we do is we're going to specify
properties about our code and then we're
going to say for all the input that you
can provide I assert that this thing
will always be true and then we live it
up to the framework to then provide that
input so what we need to do is we need
to tell skylar check how to create a
list of tweets because it doesn't know
it you know that that's code we've
written we know what's a valid tweet and
what's not and things like that and
generally what you do with Scarlett
check is you then have a little implicit
where you say here's how you generate
arbitrary list of tweets and then when
it when when your property is called it
then creates a arbitrary tweet for you
and puts it in into your code but rather
rather than than doing all about
ourselves there's a library here called
shapeless contrib and this this provides
a neat way in order to provide arbitrary
case classes for us so just to save
reams and reams of code we can just pull
this one import in and then the compiler
is how to then go and create lists of
tweets for us that's another sweeping
statement and I can provide more
information about that later but that's
all we need to do for now and again
we've got another wall of code coming up
okay and this is what I think it an
interesting property could be so we're
writing a property here and then we're
saying for all these tweets whatever you
provide I reckon that this boolean
expression here will hold and so let's
let's kind of just break this down a
little bit well let's start here this is
our Rand string that we've been when
writing as we go along we've got a
couple of functions here and then a name
of the the user we want to to provide it
to get tweets for and then I think all
we really need to do for this test is
make sure that the list of tweets that
were given to us by our twitter service
that we use all of those in order to
provide our chain generation so that's
all that code did really a called
function it then massaged it into a
string and then call another function
with that string so I think all we need
to do is whatever the tweets we're given
we don't need to do anything with them
so I've created a read of T here just
using this closely construct again we
don't care about the config in this case
and we don't even care that it returns
in the future but obviously it needs to
return in the future so we just wrap
this in the future and move up same here
same deal we're just passing the
information through and then when we
call this we want to make sure that all
our tweets are then part of the
generated strength and so I think that's
what this code here says it says for all
the tweets make sure that the received
text contains the content of that does
that make sense yeah okay and then we
can run that and and let's Kyle a check
just do what it needs to do so we can
see that the property that we've decided
holds in this case celexa I apologize
for this earlier
because this is a big wall of code so
just wondering if there's anything we
can do to make this better so what we
had earlier was this little for
comprehension and for those of you
familiar with scala or Haskell and mon
ads in general the code we had on the
screen it didn't actually make use of
the the reader t itself all we were
doing was calling get tweets massaging
the data and calling generate string
there was nothing in our code actually
about the reader like that that was
definitely definitely needed but it
wasn't actually part of what we were
testing so what we could do is we can
just provide an abstraction over that
monarch completely and then we can say
actually so this is what we had you see
here that there's nothing here to do
with readers apart from the fact that
we're passing readers in and getting a
reader out so what we can do is we could
just provide an abstraction over this
and have something like this we say well
we know we're going to be working with
the monarch because we know we're in a
for comprehension so as long as the
function you provide takes a string and
returns an M of list of tweets and our
generate text returns an M of a string
then we can pretty much guarantee that
the whole thing will will work in that
same manner as well and look this code
still hasn't changed so I think the
thing to point out here is that all
these ends must be the same so we could
provide a function here that goes a
string to an option of a list of tweet
and then as long as this was a string to
an option of string then we would end up
with an optional string coming out of
the other end that might be an
interesting implementation or the answer
could be futures or pauses or any other
monarchs you can think of yourself so
now that we've said that we don't
actually care about the reader t we can
end up writing our test like this I
think we're testing the same thing here
so I'm using the ID moan art and if
you're not familiar with that that that
provides all the laws and properties of
my lads but it has no side effects or
any secondary effects at all so and also
in Scala is that the this this is just a
type alias two to the value inside so
you can almost ignore it there so I have
annotated it on these types but I've not
had to wrap this in some kind of ID
constructor which you would have to do
in Haskell and here we're still calling
round string but then there's no reader
T anymore it things are coming out of
the other end there's an ID of string
because we're passing in ids of
something and then again this test will
just work as it did before ok so that's
great so now we know our code works and
we've got test to prove it so we really
can just ship it and go to the beach and
and we're done but then of course
pointy-head boss comes along and says
actually there's a new feature we need
here we need to put some logging in
because people are not sure that the
output they're getting is correct so
what we could do here is we've got some
some log frameworks somewhere out there
provides a function like this giving
some input it's going to complete
eventually ok and so we are we go off
and we write our logging implementation
we use read of T's we maybe change our
comfort as well you know I don't know
provide the the server that the logger
needs to write to or the log level or
whatever things like that but then we
still need to update our run string
function which is where the actual
logging is going to take place and so I
think it could look something like this
so we need a new function here so that's
logging string to M of unit you know
like like that previous slide show it's
going to be a future of unit in
production but maybe when we're testing
we don't care that it completes in the
future we can mock out or provide a
secondary function that does this for us
and then you can see here I've put in a
couple of lines of where the logging
actually happens okay so then I think
now I think our I think our testing
parameters have slightly changed because
what we've got now is in our previous
test we we just assumed or implied that
the these two functions would get called
and we could do that because we wanted
to make sure that the code in between
those got used and so kind of by
deduction we could assume that those two
methods are called but now now that
we've got something that returns unit if
we want to verify that that gets cold we
can't use ID anymore especially if you
want to be stateless you know we could
write a function here returns idea of
unit that sets a vast somewhere and then
we're good to go but we're all really
smart functional programmers who don't
believe in shared mutable state so what
we could do is because we've provided an
abstraction over our monarch and in
production and in our integration tests
we're going to be using read at ease and
as we've seen already we use the
different Mart in our tests we can use
another mild as well and I think an
interesting one to use here would be a
writer and again i'm sorry for a big
wall of text and i've had to provide a
type alias just make things fit on the
screen so we could use a writer and then
for those not familiar with a writer
whenever we we call something with a
writer we we can almost do like a
secondary call somewhere and say write
this as well and write this and then
when we call run we then get almost like
a little log or a little register of
what was written this parameter here in
this case I've used a map for string of
end this can be any Mon I'd people
comfortable with what I'm annoyed is
says this week
depends of things and then what comes
out the other end is everything appended
together so when we call our tweets
function we want to say that we call
tweets once and then when we call this
one say that we've called our generate
text function once and then when we call
log every time I call log we want to say
that we've run that once notice it this
called set because we want to return
this value as a string but because this
is unit that there's a handy function
called tell okay so now we can run this
test and we can verify that that
everything we've said works just like no
okay so we actually have a bug in our
test here okay with any one spot what
that was no in a previous implementation
we actually called log twice and we've
said we only call it once here so if we
change this we can then run our tests
and everything works so what we've got
here is a nice is a nice test that
ensures that we call our logging twice
and that was the only effect that that
had there again I've kind of rushed
through this a little bit because I just
wanted to kind of show the the
principles behind this rather than going
into the implementation that when we
call run this actually returns a tuple
and we're only looking at what was
written and not the result but just kind
of wanted to show what we could do here
so that's how I all I had time for and
all I really wanted to show so far just
be interesting to can recap what we've
actually looked up here so we were
giving someone out on helpful api's you
know we had very little control over
those you know when we called this
Twitter function week we couldn't really
work with it in any other way so you
know this this could have been something
else this could be like going off and
making credit card purchase or maybe it
is pulling Twitter and we've only got a
certain number of API calls we're
allowed to make and so that that could
then have effect on how how we tested it
and so using the using the constraint
that we had to work with these api's we
found a really nice way
in order to provide different
configuration for our code using this
reader and read a team eyelids which are
just glorified functions and then we
found a nice way using out-of-the-box
tools in order to make this integration
really easy and really testable you know
these two API is didn't know anything
about each other and now we've provided
a way to wire these together in a way
that we can be sure works and we're
quite sure that we can test this in an
easy way without having to go off to
third parties or create long-running
brittle integration tests and then we've
done this really just using some
powerful libraries that that are really
really useful in in dated eight about
development throughout scholars EDD then
we use some scholar check at the end and
a very very small amount of shapeless
just just to make the creation of our
tests really really nice and succinct so
yeah that's about all I had time for
thank you if you have any questions I'll
be happy to go through them
yes yes definitely oh ok I was worried
about that yeah I definitely will now
I'll put the right hash tags on it and
all that hi thank you Thanks yes sir so
we can use mono transformers so I think
you'd have to do that yourself generally
this is the traditional way to do that
so you can stack those up but but this
is am honored in itself so you could
then stack a reader on top of that and
then you know a writer Mon out on top of
that Weber and you know good good luck
trying to work out exactly the the
dimensions you're going through there
but yeah generally for stacking monarchs
that doesn't actually come for free with
functional programming because mon ads
don't compose in a general way but they
do in specific ways so a lot of monarchs
have a transformer attached to them as
well option t we saw writer there's a
writer t Read A Team but things like
futures I don't think generally have a
transformer because you need to block to
get the results
yeah exactly yeah any other questions
okay
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>