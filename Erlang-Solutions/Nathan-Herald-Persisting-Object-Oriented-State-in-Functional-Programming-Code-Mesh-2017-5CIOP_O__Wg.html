<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Nathan Herald: Persisting Object Oriented State in Functional Programming - Code Mesh 2017 | Coder Coacher - Coaching Coders</title><meta content="Nathan Herald: Persisting Object Oriented State in Functional Programming - Code Mesh 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Nathan Herald: Persisting Object Oriented State in Functional Programming - Code Mesh 2017</b></h2><h5 class="post__date">2017-12-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/5CIOP_O__Wg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">I go by my OB I made that up a long time
ago cuz at the time there were only
three Google results so I have all the
Google results but not anymore some
people have copied me I used to work
wunderlist
we got bought by Microsoft autocorrect
hates Wunderlist and corrects it
wanderlust so if you see that in the
presentation that means that I was up
late and I didn't catch it and I'm sorry
but I probably meant wunderlist
and if you try to type one realist I
guarantee you you're gonna get wonder
lost like every time so I work at
Microsoft I work on a design team right
now I'm building some tools for them I
don't know just little things that they
need I made a dashboard before I came
here I like being in London it's my
first time in London that's why I put a
little hat it's good I hope to leave a
lot of time for questions also I know
that lunch is next and I apologize for
that I know that the whole time you're
like when is he gonna be done so I can
quit any time just raise your hand okay
there's no bad question so think about
the questions that you want to ask so
that you can ask them I do normally run
my own presentation software which is
very stressful but I'm actually in the
middle of a big refactoring and I guess
I can't use it I broke it this was me
and I was like I couldn't get it done so
yeah so I'm using keynote which was I
like my better but you know that's how
it goes also I love this little remote I
have I just wanna tell you about it cuz
I just I love it it has like it's
beautiful and has like one big button
it's the only remote I can find it has
like one big button you know so if you
ever give a talk or even at work like
and it has this really cool Mouse thing
you can do like it has a gyroscope and
you can like that's crazy either way you
should get that so this talk is about
persisting state because that is what
has dominated my life for the last five
years maybe persisting state turns out
to be very complicated because you have
servers and devices and all sort of
stuff so I like to name everything I
- like this is the thing is the thing
it's the thing and then we'll save it
under that name and I spent a lot of
time doing that so I think it's really
important I used to be a designer
actually and so when we talk about state
what we're really talking about is like
emails and to dues and insurance claims
stuff so I think it's actually really
important and that's the only reason I
learned programming and then now my
career has spiraled out of control and I
don't really do much design anymore so I
do primarily work on what we call
distributed systems which apparently is
like I don't does anyone not work on a
distributed system anymore I don't know
but we call it like it's a big thing I
mean it's just you know one network
cable and boom you know everything's
screwed so also I like object-oriented
on't actually understand a lot of
programming constructs but I like the
idea of objects it helps me out so I
like things to be offline first so I
probably don't like a lot of apps
because most apps aren't and it really
is reddit frustrating but yeah so wonder
list was offline first it worked no
matter if you had internet or not and
that changes how you have to think about
things and how you have to name things
and stuff like that I agree with this
tweet I don't know how long does it take
you to read this tweet have you read it
okay I don't one person not it that's
good I like using functional languages
but I am very liberal with the
definition of functional because
obviously like you can use JavaScript
and functional way and it is like
actually almost the most object or
anything which cause it doesn't even
have classes and it only has objects and
functions so either way but I like
functional style because I like unit
testing and so that just helps me out
right either way I've given you a lot of
buzzwords that's what I'm here for
that's what I do so just a little time
out this is a nice Picasso I just
thought it'd be nice yeah so this is
actually really what got me started down
even just getting into Erling or any-any
you know really complicated distributive
systems is because databases are
terrible and so we wander lists we're
always asking this question of ourselves
like how can we
rid of our database like how could we
have every person have their own
database and that would be great so I'm
not gonna answer this immediately
because that's what the talks about but
I would probably show that slide again I
think I don't really remember I have a
lot of slides and I hope I go faster
yeah so this is what a system looks like
for probably like every app that we use
generally some people work on
peer-to-peer software I don't I work on
software it looks like this I mean a lot
of peer-to-peer software has been
changed to look like this over time like
Skype and other things so peer-to-peer
is tough
I like web RTC I think it's awesome you
know I want to use it more it's not in
Safari really yet so we gotta wait but
but yeah so I think most things look
like that and then I found this cool
picture from the web which is the best
named conference I think because it's a
loved web code mesh number two and you
know I don't know it's a nice picture
that's an emoji of a bento so I like to
say everything is a thing and I like to
come up with names for things and so
when I started at Wunderlist I just
opened Wunderlist and I just started
making names for things and then we
built api's and then we built databases
and everything from that I started from
the customer and was like what are these
things and I was literally how it works
we made api's for all the collections
and then each collection can serialize
database access using transactions and
yeah but we made a rule that every
database can only really be touched by
one application and so we made this rule
and then that really affected how we
created our apps we ended up going like
this and so we every database just
really ended up being one table and then
had an application in front of it and
this was our object-oriented style of
our architectures the best we could do
we were transitioning from like a very
traditional monolith that didn't work
like malice can work but this one didn't
and so you know you just start from that
point and so we ended up with a very
like I capsulated behavior and state
under these names
there was access controls everything you
know there was external API his internal
api's and I really liked it I think it's
a very good way to do it I think it's an
easy thing to transition to because you
could just have one and then go to two
and then we ended up with about I think
we launched with 80 yeah I had written
the script to generate rails amps it was
terrible
but each one was very small and then we
eventually replaced all the rails with
other languages and things like that so
and all of that's a lie
tasks is a big one and so tasks is
actually a lot of different things we
didn't start out this way because I'm
very lazy but all the metrics were
showing us that these concerns needed to
be scaled differently and we launched
each app separately and we load-balanced
each app separately and so when the
metrics showed like you know our rights
are really slowing down our reads let's
just not do those at the same time and
then we can have ten readers and two
writers or whatever we need right
and so it allowed us having this idea of
having these small named things that we
could talk about really helped us just
even without reporting and everything we
could go to our dashboard and look like
what is how our task rights doing and we
got that for free because it's easy to
instrument like a rails app right or
like any kind of app like a like a play
app right it's difficult to be
disciplined to like instrument the parts
of an app and so if each app only does a
very small thing you kind of can be
really lazy but you still get all the
benefits of being disciplined probably
not true what I just said but it sounded
really good okay
yeah our api's were downloaded were
designed to be like you're downloading
each database table so from the iPhone
app perspective it would be like what
are my tasks what am i list they're all
disconnected there's no foreign keys or
anything like that and then the UI is
actually completely off of local storage
and so that's what gives you that
offline first capability and that's
really important to me and so we spent a
lot of time on doing the like background
sync right like how do we do sync in the
background and then keep everything else
yeah just you know and I would like this
before I worked at Microsoft but they
make this thing called service fat
which is like a server technology and
they have a thing called stateful
collections which allows you to deploy a
service under a name and it's almost
like this stateful array and you can
modify it and you're guaranteed that
your modifications happen one at a time
and are atomic and it's actually really
really nice you should look at if you've
never seen it the way they do it is they
just put a partition map and zookeeper
and that way each operation only happens
on one machine at a time and once you're
on one machine then it's very easy to
make sure one thing happens so there's a
very similar kind of what we did except
we just let the database serialize
transactions and they elevated that to
the application layer yeah couchdb is a
good example of how to do background
sync and then use local queries CouchDB
is basically like a mobile version of
couchdb it's completely compatible with
their sync protocol and so you can run
counter to be on the server and you can
pouch to be on the phone and they sync
as if their peers and and then you can
just query the database and this is what
the website looks like and you probably
can't read anything on that yeah so
we've went a long way off topic you're
like is any of this really
object-oriented what are we talking
about I think it is I do think that you
can take object-oriented concepts and
use them to do a good system but
obviously like we could do a lot better
I said especially the people at this
conference like I went to a lot of talks
and I was like I don't know what's going
on I don't know what you're talking
about
yeah well you really think we think of
object-oriented is like like I want to
talk to task number four or I want to
talk to user number 42 and you're like
how do we do that right and you know
exactly what I'm going to say okay so I
only say that because this another I
like to go off on tangents we use Anka
wunderlist because awk is very good at
WebSockets they have akka HTTP now and
as well talk and support so we actually
did use this model for mapping what we
call their devices right and so your
device did have an actor running and you
did communicate over socket to it and
then it provided you different
functionality to the other services so
this actor would then talk to tasks or
talk to lists
and you could tell it like I want my
lists and then it would go get them and
it was hand them to you and it was very
good at paralyzing all that stuff for
you so like you could say I want to do
these hundred different requests of
different services and it would do them
on the server and then it would send you
back the results and that was really
handy so we did actually have this like
tiny idea for devices but we never were
able to expand this out for Wunderlist
purposes to any other concept because
some things are just monolithic and
that's fine like you should I'm just
trying to say like don't worry about it
like it's okay you know everybody knows
this phrase right and it's dog I don't
know if you know the name of the person
who drew it but now you do because I
don't like to put anything in there
unless I know where it come from either
way behaviors like right so we're
talking about object-oriented behaviors
easy right we just write some functions
boom done right and we did this we wrote
our apps we're likes I get tasked it was
like that tacit did one thing like turn
tabs is fine right that I don't know I
feel like this is not too difficult but
then object state like we're back to
this again finally yeah and again I open
wonder list and I started looking at
what is the state now that I have to
persist right and where am I gonna put
it
and how am I gonna get it back it turns
out some things are easy like task title
you just save it and then when it
changes you just save it again we had a
lot of debates about like whether you
should merge it or not like when there's
two different changes and I said no it's
too short right it's not long enough for
that also that's difficult
so either way but a really good way to
do it is to use clocks and not your
clock human clocks are terrible and you
should never use them you have to make a
clock the clocks that we use I think are
these kind the Lamport time stamps we
have a number and we increment it and
I'm pretty sure that's what this is if
not it's something else that is related
we didn't use vector clocks because
they're complicated because every every
person who makes a change has their own
clock and I didn't wanna deal with that
so we have like a global clock for every
object so every task has a clock every
list has a clock and that way we kind of
know where and time it is
and that gives you a lot of a lot of
flexibility when you're making an update
you have to say like I'm making an
update but I'm starting from the second
version of this task well if the task is
on the fifth version on the server so
ever be like no you're out of date you
need to download the old stuff and merge
it in we copy this completely from couch
TV that's how couch TV works they have a
little revision number and you have to
have to specify it when you make an
update so we just copied it completely
ownership membership a little harder you
need like to some sort of array a list
or something like that but you can do it
the same way and that's what we do and
then for each device you're not actually
downloading a whole database right
you're just downloading a subset for the
user or for the device or for whatever
and so you just make a you just make a
decision like whatever what are we gonna
download where you gonna save it
Postgres if you don't know what to do
you should just post grass if you have a
lot of rights use Cassandra if you're on
a device you see qualité and then
you're done
cool sorry about that you probably know
all this either way I just want to
repeat and I'll go through a little more
specifics of what we did we use OS
processes we use run it to run them we
use console to make clusters we launched
a whole VM to run one process and we
build an image from every get commit so
we can do that we really do anyone can
launch process anywhere we don't have
any like master process list or anything
like that every process listens on port
8000 speaks HTTP or like JSON and you
just add Steve metrics yeah I call this
our crappy actor architecture or crafter
yeah either way Erlang has the same
thing right it has clusters and nodes
and IPC right has processes it has state
which is called state right where you
gonna save it at the same places I think
I think it's the same thing so back this
question what if ever user had their own
database right we just need to make some
actors
I'm gonna run very quickly through like
akka again I love it
it has the distribute actor registry
this is code sample you can't read I
don't like Scala and I don't like I've
never done Java and I don't really plan
to start today so but it's great like we
have some scholar services we are
talking stuff very reliable it's
actually the best services we have I
just feel like I'm I may be smart enough
to like write Scala but I'm not smart
enough to like edit six month old Scala
and that's what I'm that's what I'm
working on so this is a video I was just
thinking about like Java and this guy
makes the world's smallest cup of coffee
and that was really dumb I love it I
hope you like it too okay
or leans is great Microsoft made this
it's a c-sharp thing it's an actor or
they call their actors grains which is
really weird decision and that but it
includes features like clustering and
distribution and it includes the
distributed process registry as well
they use the distributive hash table so
they instead of having like a central
place like acha you have to have like a
set of nodes that are responsible for
the process registry where's this is
like it's like kind of everybody's kind
of whoa what is it
yeah but you can also spawn a grain
anywhere whereas most other actor
solutions will do a sharding like a ring
shard and then when a node fails they'll
have to like redo the ring where's this
like you're just literally randomly
placing them and you just update the
distributed hash table with like it's on
this node and then you send that off to
all the other nodes you can write it in
F sharp which is hilarious that's what
grain looks like in Orleans the
distributed hash table is eventually
consistent so I think I don't know
probably the word buzzword gossip would
be useful in this sign either way they
do say that they have consistent data
guarantees because they actually just
farm out their consistency to the
backend storage their default storages
as your tables and they just provide an
e-tag like the last scene e tag when
they do a write and if the e tag doesn't
match then you must be out of date there
must be another actor that's a mere
review somewhere that has updated as
well so instead of trying to prevent
there from being a second actor they
just make sure that you can't overwrite
another actor they do try to like if
they see another actor then they'll
choose a winner but you know network
partitions happen all the time so it
means obviously that you could read
stale data if you were to go the wrong
actor but it means you can't overwrite
data so stale data is fine if you have
clocks or something like that like we
use that for a real-time sync we didn't
want to have to guarantee order of
messages so we use the clocks to know if
we've seen something it's that way you
could do the same thing with this they
do it with the e tags so I want to use
early no because this is my statement
that everybody's gonna disagree with
yeah I think that's actually the trick
is without needing additional libraries
like built-in it's actually extremely
object oriented because you have a clear
way to encapsulate behavior and state
with Jen servers I mean just like right
there in front of you and so that's how
you make object so it's how you give
them names that's how you dress them let
me know these messages either way also
elixirs my favorite list it's a really
good list I like it macros are good
we'll argue about this at lunch time
either way there's global which you're
like a global distributed process
register you know you your names are
very limited you have these atoms you
don't want do that also like it's it's
very eventually consistent like you can
have to act to processes with the same
name for for quite a while so then you
just go to PG two which is also
eventually consistent but it's very good
it's it's very good if you don't mind
being eventually consistent if you don't
mind the idea that you could have two
processes with the same name at the same
time then this is the best one I think
Phoenix uses it for its WebSockets
that's what the that's actually the car
I just copy and paste it code from
Phoenix to make it look like I was cool
this is another file from Phoenix yeah
all the good transfer stories that I
know of are eventually consistent which
means again your state reads can be
stale because you guys now date process
and you're like what about I heard what
this elixir has registry yeah but it's
like for one node so it's great if
you're on one node and actually like
most distributed registries will use
this on each node to keep track of the
things on that note but then the
distribution is different but you could
do the same thing dinners or liens and
there is something boom I didn't do this
I already exists called early its
space-time I don't know what that is but
this looks cool but I just I don't like
this eventually consistent process
registry I really would like to know
there's one process with one name right
so of course of course
I've started some code so this is a like
replacement for gen server a wrapper
around gen server that persists a state
on every update every time state changes
this is like a normal example gen server
that does like a
to do I forgot Oh a that keeps
accounting of every time you ask it
something and this is using the
persisted one so you just give it an
adapter module that has a get in a put
and it'll call get on in it and it'll
call put any time anything else happens
I don't know why this doesn't exist
already and I think it must so someone
who wrote this before me should let me
know cuz I'm sure it's better than mine
but I've been looking for a while and I
haven't seen a nice gents or a
replacement that does a gen persisted
server I want to consistent process
registry but I don't want to learn paxos
and so I would I'm right now I have a
library to put the process mastery in
zookeeper and just use ooh keeper
directly I'm sure smarter people than me
could do it in or languor elixir but I
don't think I can do it this is how you
normally start gents over an elixir and
this is how you use the zookeeper
registry use the via syntax give it a
name again so I'm very big into naming
right but then I can do this and I know
that there's one task one two three and
I can address it from anywheres tasks
one two three and I know I'm either
going to get 0 or one things back which
I really like and then I have this other
library called Highlander which I want
to like wrap these other two and provide
some convenience functions and you might
remember the show yeah it's dumb
so the show Highlander the whole point
was like there could be only one and so
I'd like thought that was like a joke
for like the idea that there could only
be one process for that name either way
similar to my presentation software
they're not finished and so there's a
pattern there with me but other things
you can look at there's a thing called
LASP
I haven't used it yet but they replace
Erlang distribution and process registry
with their own it looks really
interesting I don't know there's a video
URL you won't remember but you can find
it in the slides later and this is the
title of the video I I didn't understand
everything that was in the video but it
was really cool and it was about like
how to keep track of all the crap and
they don't know things there's this
really cool thing called proto actor
which is like cross-platform actors I
don't understand that either but that
sounds really cool I mean it says it's
in Colin so I don't know if you're
running this on
Oh like I don't know I want to do it
either way that's how I feel about that
so you might be saying I'm gonna do our
line and that's okay I forgive you we
didn't use her laying it wanted us
either like I said we just structure
things with a concept we just try to
figure out how they collaborate and you
can do it too with anything I don't
really like Dogma or anything like that
so this is just like hopefully something
that would be interesting that you could
try to implement at work yeah the best
example I think of like the best use
case of this is a game because I didn't
make it someone else did called halo I'm
just how halo works actually halo uses
Orlean that's for Orleans came from
there's a really good talk this will be
in the slides later so you don't have to
write it down or anything but they go
over like what it was like to build halo
on top of Orleans and these are kind of
the concepts that they named so there's
a game so every game is an actor there's
a player every players an actor and then
every device right the Xbox it's like an
actor and they literally collaborate
with message-passing they keep each
other up to date like the game
orchestrates the players there's like a
matchmaker actor which puts people into
games like and they really built out
like all the different objects to
facilitate like playing multiplayer
games and they found it was like super
scalable cuz right like as your boxes
fill up you just add more boxes and you
just fill them up with more things right
and it was also really performant
because the message-passing had very
little overhead it was very quick and I
don't know it also just seemed easy to
talk about it so there's also an example
game I found called con rain I actually
didn't play the game I looked through
the code though and it's really
interesting good this uses or leans and
it's supposed to be like a smaller
example like unlike Halo which you can't
look at because they make money from it
I think the best game that I want to
make is tic-tac-toe because you can have
like the same kind of concepts right and
this is kind of what I would do but then
luckily like there's another thing we
need to name that we haven't named it
and that's the connection because
actually the connection has state right
and then I want to persist the game
state s3 you only have one right if I
think and he wrote this didn't he we're
all gonna play this game and I got
really distracted
with the tic-tac-toe I didn't finish
this game this is the repo like gonna
Ducote there is some code there but like
there like papers about tic-tac-toe and
it is so interesting like you have to
get into it like about how to how like I
because it's a matrix right and people
are like is there one matrix operation
we can do to determine if the game's
over and there's like so many arguments
online about it and there's like other
papers I was reading about
multi-dimensional Tac Tic Tac Toe and
like combinatorial games and like you
gotta look into this seriously also I
think rock-paper-scissors would be a
good game because it's like a time
sensitive game and I think that would be
a really cool thing to do by modeling
with like these actors like in a halo
style cuz how cool would it be to like
have all the power of like halo but like
for rock-paper-scissors so this was
basically the point of the whole thing
and this is the question that got me
started was and I haven't gotten there
yet
I'm not harm percent there but I'm gonna
keep probably building software and not
finishing it and talking about this for
a long time so we're gonna do some
questions I think I talked to 26 minutes
that's a long time for me there are no
bad questions but don't like make a long
statement it's not a question you know
cause like really like nobody likes I
like just I don't know in question and
usually what happens when people say
questions is like everyone claps right
then and doesn't ask a question and I'm
okay with that but I always feel really
weird about it and so I wanted to
acknowledge the weirdness but didn't let
it happen oh no I was gonna fail
well you didn't have to worry about
running out of time I talk really fast
I'm sorry me you didn't okay
fifty minutes for questions so there's
Joe it's also lunch like so like you
know I wanted to be respectful to the
food you're gonna disagree about this
nonsense about Ellen being object
oriented only I recant I think why off
dude or did probably silly years ago and
then that was before safer Edie came up
to me and said Airlines the only
object-oriented languages why I said
that to Alan Kay you're right but that
wasn't the question
yeah I was I was just thinking about
this thing about why doesn't every I
don't understand databases they seem to
be horribly complicated things and I
didn't really I was thinking this
difference between every user having
their own data and and so if I was doing
an airline you know I just do the next
table and you don't go binary and stick
it in there so so all my data's in one
place sticky in the file system in a
file that's very easy and I thought the
advantage of that is amazing because
it's easy to replicate it's
fault-tolerant and it's scalable you get
that for free what you don't get the
free is aggregate operations you can't
say find me all users you know who like
beer or something because they're
spreading these zillions of small
databases so if you've got a database
you can do aggregate computations very
quickly find me all people who like beer
and if you've got individual databases
where you've got all your own data you
can't do aggregate operations
efficiently and it seems to me that
perhaps there are ethical questions here
I think all I think we should have all
our own data and I think it should be
personal I think it should be and if
people want to do computations on that
they should send the program to me and I
can decide if I wish to executed that I
can also decide which of my data allowed
to seep out for other people to see so I
think I think really we should own all
our own date
nobody else should be allowed to see it
and I think this everybody should have
their own database it be physically
located on them with access right some
reason committed they'd like to see that
that change I don't think we should send
all our data to the NSA for analysis
it's funny because when you're talking I
feel like I have to raise my hand like
yeah I agree with you but what I've
noticed is that you can't actually have
each person have their own database but
I feel like each shared thing can have
its own database and that's what I think
we were trying to model like each list
would be kind of its own database and
then it would have access controls on
who could get into it like which other
people and that way then you could have
a copy of the things dead the shared
things that you all do and I think
that's why I like the idea of the game
right the game is the shared thing and
then the player has like their stats of
how many times they've won and stuff
like that or how many games they've
played but the game is like that in the
moment shared thing that links all the
people together and so I thought that
was interesting yeah but I agree I do
wish that we always joked that we would
just have like a sequel light database
on s3 for every person but that's
probably the worst thing we could do but
I think that'd be hilarious if somebody
wants to work on that let me know are
there any more questions or anything
else
like well you covered it just at the end
you're saying having sequel I on s3
because you have sequel out on the apt
and everyone has their own database they
say what why is it bad to have it all on
s3 just sync it that way if you do it by
if you do it wherever you like list
would have its own database then we
could do it yeah the problem is like
with the way people collaborate people
are in and out of collaboration
scenarios and so you need you don't want
to have like the way actually so like we
like email is great right but it's
terrible the model of email is we copy
an email right like you don't actually
send someone the email you wrote like
the email you wrote gets saved to your
mailbox and then they get a copy and
then that way if it was the same email
then when it changed you would see the
changes right and so with like
wunderlist or other collaboration
software you want to be working on the
same thing like you want to be playing
the same game at the same time and if
you had to copy that game to all the
people all the time I do feel like then
you're really limited on the number of
people that can collaborate at one time
so I think that's why we thought that it
would never really happen but maybe if
you went out and you just had a but even
more little databases than maybe it
would work but then I think I Amazon
would get upset with API calls and so
someone told me there is a limit on s3
calls and I told them I hope not yeah is
there any more questions or anything is
everyone hungry
okay well if we're lucky we can beat the
key</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>