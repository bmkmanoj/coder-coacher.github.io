<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Going bananas with recursion schemes for fixed point data types - Paweł Szulc (Lambda Days 2017) | Coder Coacher - Coaching Coders</title><meta content="Going bananas with recursion schemes for fixed point data types - Paweł Szulc (Lambda Days 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Going bananas with recursion schemes for fixed point data types - Paweł Szulc (Lambda Days 2017)</b></h2><h5 class="post__date">2017-03-23</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/IlvJnkWH6CA" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello everyone I'm so first of all just
clarify am i far from being the expert
and what I'm going to show you today is
something that I learned for the past
seven months when I was working the
company I'm working right now so yeah so
not really an expert but the things I've
learned were cool and fun and I just
want to share with you guys this notion
here I know it's a second day and we're
half of the day and you guys are
probably exhausted
however this this talk is very
color-code intensive so please don't
fall back into twitter you know timeline
whatever because you might get lost and
then you're going to be bored I have
some introduction here which I'm going
to skip because this introduction is
something you guys should be pretty much
familiar with basically the idea that
software engineering should be a little
bit more concerned about the fundamental
foundations things like mathematics and
function programming actually does
attend yeah that's why we're happy to be
here in this conference however is if
there is a problem with functional
programming there are some there are
some core problems that even though we
have we've been having function
programming for decades now are still
not yet fixed and one of those is
recursion I mean if you are using
strongly type dependent languages then
recursion is also kind of all the
problems of recursion star six for you
but uh just out of curiosity how many of
you guys actually use every other day
Irish or actor or code yeah lucky to
guys you know like you but us little
ones we have to use other languages and
and we have problems with recursion
which you guys probably don't have so on
reaction schemes the topic that we're
going to talk about basically what
you're going to guys see this kind of
way to tackle the problems that we
normally see with recursion that we can
do it in a reasonable way and out of
those recursion schemes which are kind
of kind of composable Combinator's
emerge patterns which are just
tremendous and I'm hopefully hopefully
in 45 minutes that I have will be able
to show you guys that however to
actually show the cool stuff I need to
first introduce you guys to the
fundamentals so just please you know put
your seatbelt and
with me um if you guys interested in
actually using recursion schemes the
libraries within Haskell I'm working in
code base in Scala because it's open
source and because there was no Scala
implementation of regression schemes one
of my colleagues pretty much just just
poured the irrigation schemes
implementation of Haskell into and
discover implementation which is called
mitosis can both both of those projects
are open-source so if you'll be
interested in more details where there
are the links also alright so testing
recursive structures if you want to talk
about recursion recursion structures
let's think of an example - so the
recursive structure is going to be
things like later structures like list
links by nature's are recursive or maybe
binary tree but those are like basic
data structures that you you'd normally
sign a computer science but are things
that you would find recursive in a way
that you use normally idea your bank
report is the report which is based on
reports which are based on reports and
so on and so on basically any structure
that is inductive inductively defined is
your recursive data structure now the
example I'm going to use here I try to
think of an example that would be simple
enough to comprehend within seconds so
we can focus on the cool stuff and not
really focus on the example so I've
chosen something very trivial which are
expressions so here is an expression you
know this one you have to see over here
and we can represent it in our code base
in a way like this so basically we have
a sum of ten data squared and
multiplication of 20 hops and poking and
1/2 and yeah so that's basically our
representation of our expression does it
make sense this representation yes
no yeah awesome we could think of this
representation or if you want to square
that we can just you know add another
layer and we can think of this
expression basically as a kind of
structure like tree right where where
our square here is our root and the
other expressions are nested so now when
we have a recursive structure like this
one we are so we can actually represent
them this is the representation that we
have in Haskell
and the cool thing about Haskell is that
it's you can really read what we just
seen here you can read this in color
base however I said this example is
going to be in Scala so we will have to
deal with death and and there's a cool
trick that you have to do if you have a
boilerplate
it's basically color your code base so I
have a convention here that if anything
is in gray just just treat it as a
bullet plate the cool thing isn't in
color alright and that's that's that's
how you're going to reach other Scala
code here so so I say the duck problems
with with recursive calls so let's let's
say we want to write a function evaluate
which will basically if our evaluate our
expression if we look at everything
about these bodies is Methodist right
forward for every case in our ADT we
provide a value if it's a leaf and I'm
saying a leaf basically a value either
an integer or or decimal value we just
return that value if it's something else
X for example funding two things
together well before we actually sand
those things together with that first
explicitly have to call recursively our
function to those two expression X C 1
and X B 2 right so we're kind of doing a
we're doing two things here we're doing
our business logic which is evaluating
the expression but also our code base is
responsible for pushing the recursion
forward down to the recursive structure
out there until it reaches the leaf and
then it can traverse back to give us the
final result that might look like a bad
idea I mean it's a little bit of noise
but we can survive right the problem is
that if you look at your other
implementation so for example make
string which takes an expressions and
gives you spring it kind of looks
similar right for least it has to give
you a value of those leaves if it's
actually doing something in it before it
actually will do it in this example
before it will give you a string it has
to first pass the calls to a recursive
call to our function so that we see that
as a pattern that emerges here however
that's
still not an issue the issue might be
something like a fraction optimized so
let's say we want to have a function
optimized that takes an expression and
give us an expression of the result the
difference is is that if we see a
multiplication where we multiply two
things which are equal we will just say
it's a square of one of those things and
it matters because if you have an
expression then which then you evaluate
it will be just faster to evaluate just
take that one expression evaluated and
you know make it square then evaluate
the left branch and evaluate the right
one they are exactly the same thing and
then the multiply them together so if
you look at this example here the this
line over here we we took from
expressions expression and we have this
case about multiplied if X P 1 X P two
are equal and we want to have a square
of X P one this is just fine however
this will not compile because the
compiler will require you to actually
provide implementation for other cases
as well which do nothing though those
implementation they basically just pass
around the value and nothing else right
there's a lot of boilerplate at this
point the important part the border bit
is the first line but the other stuff is
just passing around the recursion
explicitly is that an issue well
depending Li on how big of your
structure is in is definition and and
how your tool is having those bullet
plates in your code base but that's
still not the case imagine that for
example in this example I will forget to
call explicitly optimize on one of my
expressions will this compile yes it
will compile because multiply expects
from the left hand side expression the
compiler will be you know happy but we
will get the wrong result more
importantly if I call optimize on my
leaf if I call recursive call on my list
as well will this compile yes will it
terminate now so that's the kind of
issue here as a recursion recursion in
our code base even if you do stuff in
Haskell you kind of doomed with those
things as well
and if we really look at this example
all our code base is doing is basically
traversing our structure until it
reaches the leaf it picks up the values
from those leaf and goes back towards
the root of the structure and then calls
the business logic whatever that is in
our in our function and gives us the
final result when that be you know if we
if you look at the next string you will
just do exactly the same thing optimize
as well which is to traverse this
structure very very end and go back and
give you a value now what did that be
nice if we have something that will
actually traverse some mechanism that
will traverse the structure for us would
be just if I was just wondering if I'm
evaluating I want to I want to say what
it means to multiply two doubles
together to give me a double right I
don't want to go I don't want to do the
explicit recursion let somebody else do
that mechanism for me so this is this
this evaluate function I would rather
have to not call recursively whatsoever
I would like to say multiply has a
double one and the first double and
second double and I would say what it
means to actually multiply two doubles
together and I would like to pass that
function of an argument to my mechanism
that would prevail in structure forming
go to the leaf speak up the values go
back and call my evaluate function with
with the doubles already alright but
does it make sense or are you already
tweeting the idea is to have a function
that just basically does the business
logic and allow mechanism to traverse
the structure for you and you are not
really touching recursion whatsoever but
the problem is it's not really easy to
implement this function that way because
expression like multiply out our
expression it doesn't hold
so the multiplies have X P 1 and X B 2
and those two are of type expression
they are not type of type double or in
this example
not of type string so in order to write
this function that I could use with this
mechanic the mechanism I was saying is
that will implicitly do the recursion
for me I have to change the definition
of expression so I don't want to no
longer have this definition where
basically let's say multiplication is
has extra XP 1 XP 2 I want to have this
definition polymorphic so I want to say
expression a polymorphic over some type
a and multiplication has XP 1 s type a
and XP of two of type a as well whatever
that a is it might be string it might be
a double in my B user it might be
whatever type that you provide so this
will allow this to actually write that
function evaluate that to do that we'll
be working on expressions which are
formalized by double not by anything
else but um we can I introduce this we
made us a little bit more generic but in
a way we still need to we provided this
structure at the very beginning to
represent expressions like which are
recursive in their nature so I wonder I
still want to represent this the old
expression I still want to represent it
the question is with my new definition
can I actually do it is it possible why
what I should put in my a here to have
this any pops I could put an expression
well we can we can actually check this
out so listen um integer value actually
ignores the a write integer values this
parameterize by a but just basically
ignores it it can be you can put their
strings or user or double or whatever so
what we could do is we could just put
unit unit as nothing right and and
that's fine
the question would be what what should I
put here and some will take this out
if those guys are expression of unit so
this guy's an expression of unit and
that guy is expression of unit as well
then the sum has to be parameterized by
expression of unit because whatever
those guys whatever that a is and that a
here was expression of unit so whatever
that a is it's actually that a so that's
expression of unit so then my overall
price my some types will be expression
of expression of unit is sir kind of
weird by compiles so so we can actually
still deal with this expression the
simple expression when I asked to
introduce together ten plus five we can
still represent this in this more
generic representation because I can
provide my expression as a as an a now
the question is okay so but what if I
have a little bit more more complicated
example like this one and we can we can
recreate the same reasoning so I can
still put that unit over here
so my sum is expression of unit then
those two guys have to be the same so
this has to be an expression of unit so
divide this expression of expression of
unit so my final expression is
expression of expression of expression
of unit but just what is doable it
compiles you can kinda if you've been
living with Java well long enough you
kind of deal with boilerplate easily so
you can learn teach yourself to just
ignore them loose stuff but the problem
is that those things will compile
however if you have if you have some
function that is giving you expression
for some input so let's say the input is
a string and our function is parsing
function at parts of string and supposed
to give us the expression in our
previous representation this would
compile easily however here we don't
really know what kind of depth of our
expression final expression will be so
what's the type here
it's a recursion on the type level it's
like an expression of expression of
expression and then you don't really
know write one compile you're kind of
screwed at this point so in order to fix
this problem we have to introduce
something which is called six point data
type and there are different kind of
things for negative x we will focus on
one which is called six now six um
professional speakers will tell you that
comer in the middle of the presentations
and we are reaching the middle
representation you supposed to say a
joke right
ah when consumer Manion is always
selling like in the middle jokes about
his wife I'm kind of scared about
selling to us about my wife especially
the thing is being recorded so I give
you a picture of a kitty so your brain
can relax because you're going to see a
six in a minute it's kind of scary
concept especially if you don't the Java
for a living
but I still think it's easy a nicer way
it's been sick since collar the mask oh
but don't worry six isn't really that
bad it just you just have to brace
yourself you know brace yourself fix is
coming that's that would be a good man
here right anyway so this is fix sex is
basically a wrapper for a value this is
a class it has a constructor let's take
something it just basically wraps
something this this thing we call here
antics so we might ask ourselves what's
the type of that thing well we will also
learn that six is parameterized by some
types s but it's not any f you cannot
put there string or user it has to be a
type which is itself polymorphic so
spoiler alert in our example that s here
is our expression so we are signing
lesson sex is parametrized by that s and
we are we will be wrapping we will be
taking something of some type and we
will be wrapping that over our text and
what's the type of that something well
that something has
to be of type s but that F is primary by
which and we are saying 5/6 of s if that
kind of blows your mind deal with it
just you know give yourself some time it
will eventually compile in your head
just kind of believe me that it does
alright I just want to show you because
we only have 45 minutes and it's already
30 minutes so far and they're kind of
cool stuff I want to show you so just
just as Barris be you know it compiled
so one good work so let me give you an
example so we we have this expression
here an expression of expression of the
unit so when I said that six will wrap
our Express our app and that F here is
our expression let's just do that and
let's see what value will we actually
get from using this
so let's first wrap our leaf our integer
values so we are wrapping them over
thick so now the question would be what
should be the type of that in value it
shouldn't be no longer unit so let's
take our definition since thing is six
is already wrapping over expression
right so the F is expression for the F
should be prototype by six expression
right it's if I'm wrapping my expression
over fixed then the then story have to
jump here oh then this thing require us
to our F so our expression be
parameterized by six of expression it's
just by definition here if you want to
wrap me with if you want to wrap a value
which is expression I'm all good but
that expression has to be parameterized
by six of expression that that's the
only way for a disc to compile and then
we can wrap get our sum and it's going
to be a fixed of expression as well and
we can wrap our final element as well as
six and the type of it is a fixed of
expression so we are breaking this chain
of six over fix over fixed over
something because on the type level we
have a disability to to kind of break
that all so let me show you the more
work
the second example which is a little bit
more complex but we are doing exactly
the same thing we'll be wrapping our
expressions with sex so we wrapping our
our leaves so they have ticks and they
are paralyzed by sticks of expression
and so we will do the same thing with
flower decimal value and then with some
and then with our final position
so our final type of listed six of
expression check this out this is the
original structure that we have sorry
Alice color it's not really that great
but sometimes it will do type
interference so this is actually word
help so this will compile as well I mean
it's this thing is still needed
but compiler will handle this so it kind
of looks final final structure like this
looks like this so that's a cool stuff I
mean there's a little bit of boilerplate
here still but it's not really bad that
right we are able to represent our
recursive structure with our with our
types here the only thing is that we
have to wrap every element in that
structure with six and this compiles and
the cool thing is is now that when you
have that function the last one that
that we didn't really know what kind of
level of recursive calls was going to
have in our structure you can just say
this is part of six expression now
somebody might ask right now okay this
is fine but we don't really want to work
with six of expression we need an
expression it's a question for you guys
how do I get expression from fix of
expression I call wanna fix yeah I call
on fix and it works exactly so just a
reminder here so we kind of what we did
right now is what governments been doing
for decades so basically we introduce
the problem and then we found the
solution for it but just a reminder here
we did that we had a purpose at the very
beginning the idea was to represent this
evaluate function or whatever function
in a way that we will be able to say
evaluate works on expression of doubles
and gives us a double so we will no
longer have
Curtis calls within our function that
will be provided somebody else will do
the recursion implicitly for us and we
just provide their business logic so we
almost done we have on six we can
represent our structure and we need this
mechanism which is called katha morphism
and if you think Adam Morrison has a
fancy connection to mask it really isn't
it's just Eric Myers probably you know
having fun with their friends having
beer and just sort of different nicer
cata morphism is basically four fold are
and in the paper they are telling you so
basically their first introduce you to
the cattle morphism and once your head
is you know overwhelmed with all the
category theory that was just going to
be like oh and actually sold our if you
using functional programming and like
how it shit'll thank you you tell needed
right now that work should be a good
metaphor from the very beginning but if
you needed to build some mental model
here cattle morphism is nothing else
than fold are just define very generic
for any data structure that you have so
so if for example if you have left in
that paper they start with list as an
example lists are cool because you
already know how the structure looks
like you have no you have cons you're
fine you can do fold our even if you
don't have the function folder you can
implement fold our in your own the
question would be how can i fold how can
i call cat a morphism
on whatever structure that i and i have
and the idea here in recursion schemes
is that if you provide function
phungster for your structure you should
be fine so now the question is who
doesn't know what a functor is at this
conference okay arm
in four minutes one on one okay all
right so plan sir the thing of a functor
is specially implemented in Scala in
France FUNKER is a pipe class the idea
behind type class is that you provide
additional set of features within your
pipe
so you're saying you're giving you type
disability listen you can be a member of
my con mic of my club you can you type
you you can be a member of my club as
long as you implement this set of
features and they will obey this set of
laws and if you do that we good all
right so the idea here with functor is
that it's any other type F wants to be a
member of a functor type class he or she
has to implement one single method which
is called map and the idea is that if I
have some s of a and I have a function
that comes from A to B this map will
give me F of B in our example if I have
an expression of LifeSite integer and I
have a function from integer to string
this will give me expression of string
does that make sense and so so in Scala
so in Scala type classes are on a level
although they're not defined on the
Python level language on language level
sorry language level they kind of build
as a thing using some other concept from
the language the ideas will pretty much
simple always have to skip through some
of the slides here but if I if I'm
saying I have some function I say have
some function foo that takes from a at
which parameters by some a and some T
and I might have my a of T and I have
some function from B to integer and I
want to have this as integer I cannot
really implement this I don't have
enough knowledge about what a is and
what P is to implement that however if I
say there is an instance of a functor
for my tab type a then I already know
enough because now I can call that map
function and this will just work and the
way you provide the
instance is you just basically in at
least in Scala you provide instance of
that of that trait if you just from Java
world trace interface basically the same
thing you just provide that that that
instance of that trade and it kind of
works so as I said only four minutes we
did that into our whoever is lost sorry
but this may be it will be kind of
easier to understand this is our
expression and now we need to pray we
know we want to make expression the
member of the functor one o'clock all
right we need to have an instance of a
factor for our expression so as I said
we need to provide implementation to
that trice functor which means we need
to provide an implementation to method
map which which will take two arguments
it will take the expression of I and it
also will take a function that goes from
A to B so so the implementation is kind
of sprite forward and if you if you look
at it it kind of resembles the the older
recursive functions that we have right
this if I have a leaf I will just return
that leaf is if I have some other
structure within it I will call us on it
so once we provide an instance of funk
for functor for our types in this
example for the expression the Cata
morphism the mechanism that will
traverse our structure will actually do
the recursive calls forests can work on
any type as long as that size has as an
instance of the function so that's the
one thing we have awesome last bit
finally is that function that that that
function that we were hoping to
implement like a half an hour ago um one
in so before we do it it's not it
actually has name a name of this
function it's something that they call s
algebra and it's not really the algebra
that Adam Barsky was telling me about F
algebras are
functions as nothing to it it's
basically algebra of Si is just a
function
si to a so like expression of double to
double okay
is it so as I was signing I'm not an
expert you guys know this joke about
this old mathematical professor he was
like 70 or something and he was doing
those different parks and different
universities in states and he was so
tired of it and he was always driving
with his driver and like one day they're
driving from one University to another
and the driver sees this math professors
like really really exhausted so he's
sounding like listen boys I've seen your
talk like 100 times I can I don't
understand it but I can basically do it
from the memory you know you just sit
back and I will do it for you so that's
what they did and the driver is actually
in the middle of the presentation and
some student in the middle of the city
is like asking a very very hard question
excuse me I have a question so the drink
is like this question is so trivial
I will ask somebody from the end of the
hall to answer it so the algebras are so
trivial I'll just you know let Adam
answer it um but anyway we need to
provide this and and it's basically what
are we doing here so evaluate is now
algebra which is a function from
expression of double to double so kind
of neat right now right we have we only
deal with doubles at this point and we
are only at this point during this
business logic here so and the same same
thing goes for our make string as well
so the lesson does an example so I have
this algebra to evaluate that doesn't do
the recursion because the recursion will
be done for me I'm just concentrating on
the business logic here and now I have
some expression which I can define
with six point data types as you guys
remember and now at the very end I have
this mechanism that is called kata
morphism that it's implemented in
fortunately in matreshka so that
function kata you get from matreshka at
least in in scala and and and and that's
it and work it gives you the it gives
you it evaluates you the expression that
is defined here with a function
evaluated all you have to provide is
that as algebra so if I have my make
string function and I have example one
more time and I call expression to
Cather make string function it will give
me the representation of that expression
and string it's kind of like with go to
when bikes are mangas two-page paper
about go to being council he never said
we should remove go to he just said go
to this kind of problem as explicit
explicit element of the language and in
the high-level languages and this should
be put pushed to the level level
languages so director so the go-to is
done implicitly for us we never used go
to write we have four loops while loops
or whatever we kind of think of the more
more abstract concepts but if you look
underneath your assembly language
whatever that is by foot or whatever go
to is still there and an idea here is
about recursion schemes it's something
similar but for recursion but that's
just the tip of the iceberg and we have
12 minutes to actually show you the race
risk a little bit more of the iceberg
are you guys interested or Twitter we're
good
i awesome right so you remember this
example optimized where I have this
bunch of bullets late and also I could
provide a lot of errors because I could
call optimize on my lease or I could I
could forget the optimize and this thing
would either not terminate or would not
work correctly for some of the some of
the input if I define optimize in terms
of algebra where I saying this is
basically a function from Express
Express
to fix of expression this kind of
shortened due to this definition we only
have my my real consent which is the
case where we have a multiplication of
two elements and those elements are
equal then we just optimize it to square
and the other risk is just keep the rest
and that's it
and it optimize your works just believe
me it works now cata morphism is easy to
understand because basically it's full
are if you've been working with lists
for for sometimes that the chances that
you've seen fold ours they on that are
there are other much more system
morphisms that were defined in the
original paper but there or were also
extended throughout the year we I'm
going to go through all of them because
that would be like more additional talks
and my only note few not all but I want
to show you something cool there's
another morphism which is called
anamorphisms and anamorphisms is
basically unfold and unfold the idea is
about about unfold is that when fold
takes your structure and gives you a
value then out fold is something it's a
dual of that of that thing so it takes a
value and gives you an expression so for
example I have some integer and I want
to see an expression that defines that
integer in terms of multiplication to
multiply by two by two by two by some
odd number here so if I want to have
something like that and a morphism is
that the thing that I'm looking for
so you need to provide a dual full
algebra which is surprisingly cold :
algebra and that's basically the reverse
function from value a let's say from
doubles to the expression so in this
example two expressions of double so I
can I can define my divisors function of
the Col algebra saying if n is can be
divided by two
and is not to let me just returning
multiply 2 + + / 2 in other examples
just just give the delete value and if I
call as I take some value let's say 12
and call this animal system with that
Fallujah bra this will give me the the
expression so this is one of the
examples and now bear with me I'm trying
to make a point here just it will take
like five minutes so this is one of the
expressions you might wonder why when I
might need it that depends on your
context but there's another expression
called high-low morphism and you might
be already like holy crap the next one
where's my tweeter right well don't
worry it's not really that hard column
or prism is nothing else than just
basically anamorphisms followed by
catabolism so let's say you have a value
and you want to calculate the factorial
for it a very dumb implementation but
kind of proves my point
would be taking that value during an
animal's fission which would gives us
the expression representing that values
and then calling catabolism that we'll
call this technique evaluate function
that will actually evaluate it right so
that so the anamorphisms will explode
the value to a structure and then that
structure will be evaluated to to a
factorial right so 2012 will be 12 will
be represented us as two times two times
two times three and then we will
evaluate it to whatever is factorials 12
something big now so what I said hila
morphism is exactly that and you might
wonder why should I care the cool thing
is if you really think about it how how
it works how the how the Kadim work is
how the animalism works it takes some
values they compose it into structure it
has now some structure and a value but
takes that value in the constructor so
it goes down the tree answer it reaches
a leaf so we
already one passing on that structure
cut a morphism
on other hand the next step will have to
traverse upper structure first to your
leaf and then we'll go back to give you
a value now so you have we have two
passing of that structure we first
created and then we traverse it back to
actually calculate a value hi-low
morphism will do that for us so while an
important is actually creating that
structure the Cata morphism will be
already traversing it in parallel so
when this is done it will only just have
to go back and gives us the value so it
is almost twice as fast because it's
just running those two guys into running
the first one and then the second one
those guys are running in parallel and
give you the final result and and here
is an example of using a high-low but I
hope you guys can kind of get the idea
now as I said there are more cool things
about recursion schemes and the cool
thing about recursion schemes is
whatever that is cool about functional
programming is that they are composable
and this feature of composability gives
you a lot of strength and a lot of
robustness that you can have in your
code base especially if you're doing a
lot of recursion in your code base
because the stuff that I show you so far
was basically giving you an ability to
kind of free yourself from recursion and
from all the problems of recursion
because recursion scheme the recursion
is done for you implicitly but think of
a think of the example of example that I
can give from the context of my company
as writing a compiler if you ever have
to but there are other problems which
would be similar but this one is kind of
trivial to explain if you have for
example compiler for for Scala code base
or Haskell what you know and in Scala
you have for comprehension all or do
notation in Haskell which in Scala for
comprehension is on the compile time
level the sugar to cause a flat map
flatmap flat method map so if you and
this is how exactly how Scala compiler
is actually implemented it's implemented
in phases it's something which is called
multi passing
so the idea is that you take your
codebase you your ast and the inside
step let's say you just prevail the
whole structure of your code base and
you find all the four comprehensions and
you and you too sugar them to calls of
flat map flatmap splat maps and and map
at the range you already have the
developer slapnut bind the same idea and
then once you have that so you came from
AST to IFC now you have a newness in
your representation of your codebase and
now you can do some other stuff so do
some other the sugar ring or some other
compilation until on the final final
step you you compile to your final
assembly whatever that is in Scala is
going to be byte code and this idea is
pretty neat because now you have those
little functions on which you can focus
on I can I basically have this function
that takes code base and gives me the
sugar version without for comprehensions
I can unit test it
I can I can just focus on that simple
idea instead works I can combine with
all those other functions that I have
here combined them together and I have
very maintainable code base the problem
is this code waste is really really slow
right but because I have to provide that
structure each time I'm calling this
function
so while multi passing is nice in terms
of maintainability of most of the other
languages are using something which is
called monolith and and it's either
monolith from microservices it's other
monoliths and the idea is that you just
take the code base and you have a
function that gives you the assembly
every the sugar ring everything is just
what they've done in this one thing here
which is from the performance point of
view a neat idea however from
maintainability is kind of hell
now you can thing of those functions of
scatter morphisms
and i more freedoms as well but i don't
wanna confuse you so like that function
that goes from for comprehension that
compiles up to the to the flat map that
actually is a cat a morphism
it takes an expression and the value
it's like the ASD and the value is still
ASD so now we could define those one
more time cannot do this multi passing
right so we can define those little
steps so here I'm disagreeing this and
here I'm disagreeing that and we can
define that all SS algebra so we have
this maintainability feature and
testability and all that but the but as
I said recursion schemes are composable
so the the final function that you're
going to get is just access jessa as
algebra composed with s algebra composes
as algebra so the final thing that you
run over your structure goes over that
structure once you get the kind of thing
that we have here we can focus when we
define those little things we can focus
only on the things that we are
interested in like the sugaring this or
distributing that but on our production
call when we actually you know toll and
we take a source code and we want to
have assembly here we will have a single
run which is something which is called
Nana passing and all those kind of cool
features that a neat feature that you
would normally get when you do
functional programming because you have
composability in your code base think
about about all that that you only get
from the type system thing and you can
have it for recursions as well and this
is actually a very cool idea
if you guys interested matroyshka I saw
a quasar we have something we basically
compare we compile down from sequel to a
logical plan which represents sequels
which later on we compile down to some
no sequel databases to some some
dedicated connectors to physical plan
and if you want to see that in action if
you want to see recursion schemes that
will blow your mind
I'm just encourage you guys to see arm
Poyser references from different papers
that I read actually make the stock than
to actually understand what I'm doing at
work if you're interested my name is
Pavel so this is my Twitter if you want
to complain email as well and my blog
and I have two or three minutes to take
questions if anyone is interested
that magic thanks very cool talk and I
have a question you certainly should
have a problem with tail recursion
because for example when you created
this data structure with six points I
saw it look like there was some
branching out yeah if you like jump
align them I like what you're implying
nananana so the thing is matroyshka is
it's implemented as as a port from comet
implementation and in Haskell you don't
have problems with a recursion right and
matreoshka is also our business driven
open-source libraries so we have
features that we need in our product and
we so far we have quasar running in
different environments like very I would
say complex environments and we still
didn't hit the problem of tail recursion
so right now this is not there's no
trampolines in it probably there's going
to be if we're going to have an issue
and a github like these are crisis thing
isn't working we have selected stack
overflow exceptions but so far we it's
not implemented with with with
complaints Thanks so I think you can
also use Freebo not to do the exact same
thing and also you get monad 16 text for
free so lots of Vantage of using fix
data type over that so I didn't have
three here in this examples now I mean
you and in quasar meaning quizzer now I
may I mean you can implement the same
thing it's free mo not what do you mean
hey free mana is one of the recursion
schemes so if you think if you seen Adam
stock alright ah supreme Allah is
basically have a cure which is like the
leaves and you also have the free we are
so you can you can think of a free of si
being defined as basically either oh
yeah sorry
yeah yeah get it ah sorry dad
so basically you can you can think of a
so if you define in Scala you can think
of three as basically being to think so
it's so it's either so it's either SSI
right or or die correct that's free and
Co free while you add it as a something
similar sorry
Co free it's going to be it's going to
be a light coating sucks
um it's going to be a pair of Si and I
sorry I'm not I'm not a scholar
programmer Padma okay so the idea is
programmers the or here this is either
type if you're not so insulation this
does those are two types that you can
treat so we've been using thick as a
fixed point data type that allows us to
represent a recursive structure with a
type that wasn't recursive by definition
right because expression yet wasn't
recursive values and we expect to kind
of go back to recursive structure so so
in Haskell at least so free is defined
as either you get the fewer values the
other one is a functor over three that's
exactly what others here it's more more
even more simplified version of it no
it's a function over free itself it's
recursive so the free free Mona's is you
either get a leaf or you get a tree
light which is like a function over the
free yeah so by doing that by the table
advice it's still a type it's still a
time that you can use to represent a
recursive structure you can do that with
three and this gives you a and an
ability to because with with code free
you're no longer saying I have an
expression where it would call free you
can just label your L
and of your recursive structure so for
example an expression you might say
first level second level and that that a
is going to be your string or what
integer and three you are saying it's
either that recursive thing or some a or
suggest ring yes
mala girl still is still defined a type
that defines a recursive structure
yeah allocation schemes give you the
mechanism to traverse that structure
sure of my question a marginal question
was that that kind of type also give you
a monadic syntax because it has a leaf
so you can implement your expression as
a wrapper of Ramona's and then you can
write your DSP behind that Mona's or
other context so you don't have to use
stick which you don't have ramen on wrap
yourself you don't have to use fix you
can so I was just wondering if you so
you're going to use so for example let's
say an expression in our example you
remember expression which were just to
give you which there were some other
questions and we we were probably just
going to jump to an action I can talk
about it in a second if you want but
that expression I don't know if I have
it somewhere here still under crap
direct artist that expression has some
leaf like like integer value in decimal
value and then and then some recursive
structures right and in a way let's say
expression only doesn't have those leaf
there is no int and there's no decimal
value right let's imagine that end end
value and decimal value are defined of
some type but not in your ADT here let's
say that ADT comes from some library and
we have some other types that represents
the leaf then you will not use fixed
then you will use three because you're
going to have three of expression and
let's say integer value because now you
have a six a three represents your fixed
point datatype and you are saying I have
either my structure from my expression
or some leaf integer and then that's
when you because three is recursive
nature is basically 6.85 right but you
still need that mechanism that will
traverse the datatype and that's that's
what recursive screens gives you thank
you and your question all right thank
you much</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>