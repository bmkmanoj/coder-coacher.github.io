<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Testing with mutants - Jan Stępień (Lambda Days 2017) | Coder Coacher - Coaching Coders</title><meta content="Testing with mutants - Jan Stępień (Lambda Days 2017) - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Testing with mutants - Jan Stępień (Lambda Days 2017)</b></h2><h5 class="post__date">2017-03-07</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/UDW3qoSbccg" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">where was I in a queue against Anthony
that's me and very happy to be here with
Israel and always a pleasure
allow me to start with a short story not
long ago I was in London I was booking
my tickets and the airline I'm not going
to name the name of the airline asked me
to provide my surname exactly as it
appears in that passport so I looked at
my passport and I thought what can
potentially go wrong well this is the
confirmation email I get from them so
love these two interesting things
firstly my surname is mangled in an
interesting way because one character is
simplified to seven bit and the second
one's removed altogether and the German
there static boom which stands for
confirmation is botched in two distinct
ways firstly in the header and then in
the body of the message so why am i
sharing this story because I think that
writing correct software is really hard
and I think we can all agree on that
right we're really bad at writing code
as there are methods we typically apply
and given this difficulty some of them
were discussed by choose earlier today
for example using more advanced more
expressive type systems but what I'm
going to talk about today is tests
usually we write tests to to address
this difficulty somehow and the closure
world which I intend to focus on today
we typically start with an empty
skeleton of a project which by default
comes with a single test is broken and
we have to fix it this is a good
starting point we use testing we write
tests at a variety of levels we write
integration tests unit tests acceptance
tests user interface tests we even use
more advanced techniques like generative
testing which is taking the closure
community by storm where we can express
more general claims about our software
and then use the library to have it have
our claims subjected to entire hail of
inputs and test our understanding of a
domain for better
like here for example a checking with
their store decided impotant but this is
not enough and it's not enough because
it's still writing tests and as we
already know we have terrible at writing
code right so why would it be any better
at writing tests there is a number of
methods techniques which try to help us
somehow to increase our increase well
the degree of our trust to old tests you
some of them are for example code
coverage techniques they're insufficient
in many cases today I'd like to focus on
something else today I'd like to focus
on mutation testing oh I missed this
slide sorry because I was intending to
tell you now I blew the joke I was
intending to tell you that if we're only
not we're writing tests and we can't
would tell for sure how was the quality
of our tests because there is no one
behind the scenes who is testing our
tests and mutation testing as a
technique which allows us to firstly
evaluate the quality of our test suit as
well as give us concrete hence how to
improve it mutation testing was really
briefly discussed during the very
interesting lightning talk yesterday
evening today I'd like to start with
giving you some theoretical background
to this technique it all starts with the
competent programmer hypothesis
according to it code written by
competent programmers you differs from
correct code only by a small number of
thoughts we accidentally introduced in
their code thus a good test suit will
help us eliminate those few few faults
we accidentally put there so how can we
tell whether a test shoot is any good
well we can just grab the keyboard and
introduce a couple of faults and check
whether the test it catches them or not
if the tests you turns to read its
good sign as we all know we barely have
time to write correct code so on top of
that trying to check out tested by
writing incorrect code seems like not an
economically viable method what we do
when we don't have time for things we
try to automate them and this is what we
can do we can try to automatically
generate 40 versions of our programs and
subject them to a test suits and see
whether our tests
turn red when they see them if they do
excellent if they don't there is a
problem but now you might ask and
rightly so but there are so many ways we
can introduce bugs and faults into our
programs and if you take combinations of
those of those simple faults we
introduced there's a combinatorial
explosions of possibilities as this
brings us to the second hypothesis the
coupling effect hypothesis according to
it a test suit which would discover
simple faults will also discover more
complex faults which are combinations of
those simple ones thus complex faults
are coupled to simple ones through the
test suit which would to discover both
of them and those two methods offer us a
foundation a theoretical foundation for
a mutation testing so as we generate
faulty versions or programs run or test
suits and if those test you to remain
green we know there is something we
missed in our tests let's get some
concrete vocabulary defined those
invalid versions of our programs we
generate our mutants we try to kill
those mutants using our test suits if a
test it turns red the mutant is dead
those which still remain alive of heard
after the rotten run of our tests are
called survivors
affection testing like many good things
in computer science is several decades
old it was introduced in the beginning
of 1970s and was subject to according to
this very interesting a review paper was
subject of over 400 and the
publication's 400 yes according to
existing research both the coupling
effect and happended competent
programmer hypothesis are confirmed
that's giving backing to the entire
method existing research focused on
languages which were mainstream over
those decades so primarily C Java and
Fortran but still have there's a lot of
interesting things happening happening
right now
there are very interesting and powerful
implementations of this technique for
languages like Ruby Java JavaScript I
recommend taking a look what brought me
to to the subject was the fact that I
wasn't able to find a mutation testing
library for closure so I decided to
write one end here on a couple of
following slides I'd like to tell you
something about mutant my mutation
testing library for closure the library
itself is is executing four steps four
simple steps it reads all sources you in
the directory you pointed to in your
sources directory then for every single
top-level form in this in your sources
directory it tries to generate mutated
variants of this form it runs tests suit
which it finds in your test directory
for every mutant it generates and then
it reports all the survivors all the
survivors of this all those mutate
variants of your closure code which were
which didn't cause your test use to turn
red let's look about those steps in a
bit more detail firstly we have to
generate mutants
at closure at home iconic language comes
with excellent tooling for manipulating
its its source code a library which I
found very useful is rewrite clj does
anybody know really does anybody know
lain ancient a bit more hands it's a
very nice lining and plugin which allows
you to automatically get upgraded
versions of dependencies in your project
sealed a file it builds upon rewrites
elj which is a tool for manipulating
your closure files preserving
indentation white spaces comments and
and all this noise I'm using this
library to process our closure files and
generate some invalid VAR variations of
your code for example if I run into an
end expression your code
I might turned into an or if I see less
than check I might turn it into a less
or equal given I the empty predicate I
might try to turn it into a seek which
is a negation in a boolean context and
then finally given some function of
arbitrary complexity
I might just remove this this body
altogether super efficient I tell you
many tests will pass anyways
absolutely ultimately refactoring so
what we what we have are are those
modified versions of our program now we
have to reload the code enclosure we
have soit's foundations right we can
dynamically reevaluate functions we can
even add and remove namespaces however
we will despite this is very helpful but
we reloading just this one function is
not enough right because the function
itself might have affected everything
would end the same file below it and all
the other files which are requiring this
particular file a tool which comes very
useful as closure tools in any space
which comes with a number of useful
namespace mangling processing functions
one of them allows me to build an entire
graph of dependencies of those required
statements in closure projects this
allows me to reload all potentially
affected source code which might be too
much to recompile but I haven't yet
found any better way to attack the
problem and at this point I know that
your code is mutated all the affected
code is also updated and I can proceed
to run your tests running tests is just
looking at your test namespace he
pointed me to invoke enclosure core
tests to run tests on it and collecting
results if your tests use turns red I
just move on
if your test suit remains green I
preserve the mutant and finally
demonstrate in a single report here for
example is a report of mutant running on
itself
it's an extract from this report it took
a bit of hacking to get the thing wrong
on itself but it works and here it
reported it found eight survivors and
here I'm showing two of those you can
see that if I replace this end with an
or or just remove the entire body of
this function all the tests all the
tests are are occurring because I'm
horrible at writing tests and I'm very
happy because this thing works right
this thing I I ran it on a number of
prominent closure open-source projects
and was able to to
generates actual survivors which are not
caught by those projects I'm not going
to name any names because that's not the
point the point is this thing works this
thing is in a state where we can start
applying it and in the in our code bases
this being said it's too early to get
excited about it there are still a
number of rough edges which I would like
to discuss here first of all it's slow
it's forbiddingly slow authors of M
paper from 2001 discussed three main
solutions to the problem of high CPU
cost of mutation testing smarter faster
and fewer fewer faster and smarter let's
talk about those three approaches one of
I wanna through another by fewer we are
talking about generating fewer mutants
we can select what to mutate maybe we
don't need to mutate every single form
because the chance that have to yield
survivors is relatively low or next to
zero we will return to this topic in a
couple of minutes we might select our
mutation operators that is the way we
generate mutants maybe some mutants are
very unlikely to generate me to generate
survivors so running tests on them is a
waste of time of time anyway and we
might also sample mutants according to
some research randomly sampling just 10%
of mutants who generate and subjecting
them to your tests use allows you to
rather yield 80% of survivors meaning
you do 10% of the work and get 80% of
the result this might be a trade of your
interest to that let's talk about faster
one of the things which you can do and I
introduced and the library which which I
wrote is not restarting the VM keeping
the JVM hot and reloading the code
directly in it if your virtual machine
supports it beam the virtual machine or
any other
a VM which allows life culture building
this is a method which will allow you to
speed up the process significantly
another approach especially in the
advent of cloud computing is just
throwing machines of the problem notice
that once we generate mutated versions
of our software we can just scatter them
across our machines which will
independently run the tests yet and
report back whether it was green or not
the problem is pleasantly parallelizable
of course the trickiest bet is the thing
it's smarter but it's still worth taking
a look at we might execute only relevant
tests that is solve this dependency
graph of our namespaces and try to run
only tests which actually have a chance
of killing the mutant if we modified
something in the somewhere in the view
logic it's unlikely that the database
tests will will catch it right so it's
not worth to execute them it's just a
waste of our time we might also reorder
the test use this is an idea which it
which I find interesting we might notice
that certain tests are more likely to
kill mutants than the others now if we
were able to and not at the fact that
once we when we were running a test suit
we can stop running tests you after the
first to read the test because we
already know that the mutant is dead
which means that if we reorder our test
suit and put all the tests likely to
kill mutants at the front statistically
we might save some time because less
relevant tests only ran towards the end
or what they discussed is still nothing
compared to the fact that the whole
thing might not terminate which I find
delightful if you generate the mutant
which which which has an endless loop
inside which I did the number of times
you end up with this really unpleasant
situation and the underlying platform
does not help
first of all JVM cannot reliably stop
threats there is a method called thread
interrupt which is just a polite excuse
me could you stop you can ignore it
there is thread stop function a method
which which is deprecated and it's there
is a lengthy explanation why you
shouldn't use it mostly because of
portability reasons and lack of credit
predictability of this method you might
you might want to work out create a sub
process on the UNIX system and run your
tests there and then if the thing runs
for too long just kill it you can't do
that because JVM for portability reasons
does not implement the POSIX fork Cisco
well you might want to start one JVM per
a testitude but this is again even more
costly even more expensive in other
words I don't have a solution for this
problem so well if you have an idea let
me know because I want to hear from you
right this is something which other
mutation testing libraries cancelled by
for example forking out and killing
their subclasses I can do an JVM after
all what we've discussed so far
I think it's worth to mention where it's
worth mentioning where which paths to
introducing mutation testing might be
more most might return best return on
investment this is an idea which which
we came up with I mean it wasn't our
idea just appeared in the discussion and
it turned out that a lot of people were
thinking about it
at the same time some are completely
else on the globe an idea of running
your mutation tests and the continuous
integration continuous delivery
pipelines notice that given the high
cost and high high CPU costs the time it
takes to run a station tests it's not
really possible to convince your fellow
developers to execute mutation testing
in their TDD cycles it just takes wait a
long time it's also unlikely that he
will convince them to run their tests
around their mutation testing analysis
right before they push to to push to
either master or a future branch so what
why not try to automate it again like we
did at the beginning of the talk why not
let our continuous delivery pipelines
run all those mutation tests for us and
then about as you're as you're about to
create a pull request to the master
branch from the future branch you
working on you get back a feedback one
from a traditional CI system telling you
yes all tests are green that's cool and
then a follow-up one saying all tests
are green but but still there are
certain cases which you haven't covered
i mutated your code somehow and it
resulted in uncaught problems uncaught
potential regressions notice that there
is one more thing if we end use this
method in our mutation in our continuous
delivery pipelines we have full
historical knowledge of of what was just
modified meaning we looking at lines
which were just touched in the previous
code commit we can narrow our narrow the
scope of our mutation analysis just to
stuff which was modified there is no
need to run a mutation analysis on the
entire project we just focus on the code
modified with your current comment maybe
not just those lines but maybe in their
functions their classes files this
allows you to introduce mutation testing
where its most valuable on the code
which is just modified on the code which
well as hot and valuable right now from
the perspective of your business of your
organization and additionally putting it
there allows you to introduce the whole
method gradually because you're not
breaking anybody's workflow you're not
forcing people to run the thing on their
machines which will likely need some
opposition as long as you put it on some
server which will periodically pull your
stuff from your from your git repository
you can slowly and painlessly introduce
mutation testing into your organization
and see how it's how it's how it
performs how it helps you how it helps
you write better software or more
importantly but your test for your
software because that's the whole point
it might appear that I'm so far like
waving my hands in the air talking about
this entire continuous delivery pipeline
thing but there are concrete case
studies two years ago an engineer at in
view sorry for mispronouncing here ends
Matthew Gothia wrote a very interesting
blog post at India though you were
dealing with 100,000 lines of a C++ 3d
rendering engine a complex and mature
beast they were happy with their tests
and the pace of their development but
they noticed that they were slowing down
and they according to their analysis the
fault was the fact that the quality of
the test you deteriorated and this
prevented them from moving as quickly as
they were moving before they were
looking for solutions they looked at
code coverage as a simple approach to
the solution to the problem it didn't
work for them so they decided to just
randomly remove lines from their C++
code codebase and see whether the tests
see the breaks or not exactly what
mutation testing is about and they
introduced it as part of their
continuous delivery pipeline
they worked on small C++ comments
mutated only things which were touched
by those comments and goats actionable
results actionable feedback related just
to the code which was held right now
from the perspective of the business
either add more tests here because
something is missing or just throw it
away because it's dead code and they
didn't need to introduce this method on
the scale of the entire 100,000 lines of
C++ engine they could have introduced it
gradually commit by commit only on the
code which was important right now
and their feedback was excellent they
were very happy with results of the
method of the feedback they got from the
method and it's an action confirmation
of how mutation testing can be
introduced and then mature organization
dealing with a massive code base in the
language which you wouldn't expect to
chew too thick to this method nicely I
hope that and this short talk I was able
to convince you that mutation testing is
a viable method of evaluating the
quality of our test suits as well as
increasing this quality tools are there
there are available for most programming
languages we typically work with some of
them require some further work for
example non termination becomes an issue
well but they are there right now the
topic is how do we introduce them into
our code bases be it your java code base
beard your ruby scala javascript or any
other code base or Erlang as we as we
saw yesterday I think that mixing
existing tooling with putting it into
our continuous delivery pipelines we can
find we can we've got a very natural way
of introduces otherwise we'll earth
quake II method into into our
Quality Assurance pipelines if you like
this is all I've prepared so I would
like to thank you for attention you've
been a great audience and I think I will
open the floor to your questions thank
you very much hi well test in popular
libraries weren't you scared that your
functions became impure and did it for
example you enter discs this is a very
good very good comment yes what if
another reason for doing it in your
continuous delivery pipeline right but
this is possible mutation mutations I'm
introducing seem to be relatively simple
things there is the result of existing
research about what's mutations you
introduce your software like what what's
the yield of particular mutations how
effective they are and they are
typically very simple things or it's
simple simple mutations testing your
edge cases testing your bullion
conditions and so on arithmetic
off-by-one things yeah suddenly if true
remove everything and the name and I
accidentally invoke this true and it
removes everything yes run it in docker
containers thank you it's very good very
good comment thank you very much for
this I don't have a don't have a you
know a good answer sorry I think I have
a question coming there you didn't say
anything about equivalent mutants in
your talk how big a problem have you
found those to be equivalent equivalent
mutants mutants which would still work
because they are equivalent to the
original program thank you very much for
this question yes this is an excellent
excellent comment what if for example
I will remove a log statement from your
from Terminal called this part of our
mutation right your test seat remains
remains green but well it's kind of a
mutant but it just wasn't bitten saying
look don't debug something so it
technically doesn't break anything right
how do you address this problem I don't
know I think it's a very good very very
good point and maybe some form of
blacklisting mutants which are which
shouldn't be generated or ones which i
don't care about I have to I have to
look into it I'm sure that people
studied the problem and I think I just
need to dig into what they found out
thank you for this question
so what's the how useful do you think
mutation testing is in projects where
there's not 100% coverage or the tests
are failing depending on the order you
run them in so is this something that
you used all you would introduce only in
a very mature very very stable test suit
or do you think it's useful in any kind
of project I understand you're referring
to the so-called real world rice
it's dangerous there yeah so sure if you
don't have any kind of normal line
coverage of your Cobra your test suit
then introducing mutation testing seems
like like yeah quite quite a big
artillery for a problem which which you
could solve just by writing simple unit
tests right it's a bit too early to
introduce mutation testing there I think
that this tool would in the real world
excel at either code bases which are
already well tested but you want to
increase your trust in your tests use
unit and its likelihood to catch
regressions in the future or focusing it
on your most important and bug prone
things either bug prone things or things
which are where a cost of the potential
aggression will be very high like your
actual internals of your business logic
if you can extract the logic of your
organization to some modules which are
otherwise decoupled from the rest of the
world from the i/o and just focus on
your mutation analysis just on this
thing then you might introduce mutation
testing partially where its most needed
because costs of introducing faults
there will be the highest I hope this
works as it as an answer or a comment so
as a follow-up so if you had to choose
between this and property based testing
for that sensitive area of your code
which would you choose if you had to
choose one like allocate your time only
for one I'm a great fan of property
based testing by all means this being
said mutation testing addresses a
different problem mutation testing for
my understanding of the term property
based testing helps us write better
tests or whether we write better tests
using property based testing and then
mutation testing is something watching
the Watchers it tells us that
those are done a really nice test but
they still haven't covered the following
things so they're not they're not
solving the same problem there one is
helping another I think we have the
question here in the front the
microphone is coming I think because
we're recording about those questions
right so idea from a property-based
taste and also there's somehow shrink
rotators if you mutate in several places
good question and I'm already generating
very small mutations so if I'm flipping
less than two less than equal there is
not much I can shrink anymore okay maybe
there are ways where you can like you
know I removed the entire body of the
function this is surely can be shrunk to
removing subforms or something inside
absolutely but in some cases some
mutations are relatively relatively tiny
so reducing them even further I would
find it difficult okay thank you
oh we have two more questions three more
questions I'm so happy because we have
think I think we still have time for
them have you have you have you thought
about implementing a feedback loop I
mean when when you when you get the
results form from your mutations and
it's and it's and it's really something
that you should look at and and and then
based on that information
you could you could instead of instead
of doing it only by by by a some some
template you could you could learn that
the mechanism and and then and and and
based on on feedback that you get from
you can improve it on the next level
aha I haven't considered that but it
sounds very interesting
and let's talk about it afterwards
sounds very cool I so two more hands at
least
and and there are no bad questions
remember they're only bad answers my
question is when you create mutants do
they actually usually have only one
mutation or they prefer to create
mittens with more mutations at once I
generated just single mutation and test
your code on a single mutation and I
would assume that this is the right way
to do it based on the coupling effect
hypothesis that is the assumption that
if my test suit catches as a fault based
on one mutant it will also catch one
based which which has two problem two
folds inside of it also like there is a
chance that two mutations I would
introduce at the same time will cancel
each other out and then I have the
situation of this is kind of bad but
also it's totally fine and my second
question you got near the mutation
possibilities the Gottis taking patients
from other software only all the other
mutations are actually let's say
invented by yourself no I claim I claim
no novelty here I'm I'm heavily inspired
by all of the existing work which has
been happening all I did is that we just
keep adding parentheses and running at
the JVM okay thank you have you done any
work on parallelization of mutant I mean
to make it practically runnable in
multiple nodes I haven't this is
something which is on my to-do list what
I haven't yet invested any time into it
thank you for your talk to me looks like
the mutants testing is sort of extending
of the coverage so if you actually get
information from some sort of coverage
utility which tells you look this
function is not used or this branch of
the if condition is not used you can
actually skip those mutation because
they are useless so if you would
actually hook your tool to a coverage
tool getting information from yeah the
paths that are not executed you can
actually save in mutating in mutations
mm-hmm
this sounds very interesting this stands
for interesting I haven't thought of
that let's talk about it excellent this
is right oh come on there must be at
least one more question we still have
time for it I hope oh sure we do thank
you for the talk actually about the
question of shrinking do you think it
was more reasonable to expand mutations
because it's kind of complementary to
property based testing you don't want to
have the smallest mutation you actually
want to have the largest mutation which
it still goes unnoticed by the tests how
much of your code can I delete before
your test is catches it I like the idea
I would still have to wrap my head
around it but this sounds like a really
cool thing and instead of shrinking
mutants we can just keep growing them
sorry you were intending to say no I
just want to say I think it's different
because I do understand human tation
about if the test suite cannot catch a
small - catches a small error it will
probably catch a bigger one but these
are the big ones were going after and
maybe expand them would be the idea it's
a very good salt I'm wondering how it
fits into the competence program I
apophysis there's the assumption that
your code was generally correct give or
take
a couple of small things you forgot
about and mutation testing focuses on
the on you know on catching your small
edge cases and like unlike my test which
you wish you so if you delete the entire
function that work and the whole thing
still works
I mean tests are green in the case of
like well tested projects or well
implemented projects this should not be
the case but still thank you a very
interesting found what is the technical
way of introducing the mutants I mean is
it just a simple text substitution or is
it more sophisticated something I don't
know
parsing etc very good question the way
I'm doing it is using rewrites elj I can
read code from disk and get it as a
string
wait that's before we write coj I then I
get this I get the string I runs a
rewrite clj on my string I get a zipper
like representation of my code base it's
a data structure allowing you to to a
degree easily process your code process
your data structures this allows me to
change something in this in this like
ast like data structure then I can get
back from the zip representation using
rewrite CLG API I can get back a proper
closure data structure which is like
your code but with default and may just
evolve it and then I proceed to evolving
all the rest of your forms unchanged
thank you very good question yes so this
would be the follow-up of this question
so wouldn't it be better to do this on
bytecode level rather than on source
code very good very good point this is
how the Java library does it the Java
library p i-- t-- tests p i-- test is
executing on the bytecode level it takes
your class files and does some mutation
of the bytecode which would correspond
cleanly to some changes in your source
code and if this fairly tables like
rerender what
to the bytecode and show it's how it
would look like if you did it in your
source code whether I can do it in
closure probably yes whether I know
enough about JVM bytecode sure not so
it's it's it's something is that which
is a Matt refer probably faster and way
more difficult do we have time for any
more questions I think we'll have time
for one so how many if any of these kind
of a survivors would be can be consider
kind of false positives things that are
actually fine with your test and the
survivor just as if there's a problem or
maybe there isn't I think what what your
question is closely connected to what
referred at the very beginning of the
Q&amp;amp;A session that is those mutants which
are equivalent because I just removed a
log statement from your code and
everything still works right the false
positives how many of them it's
difficult to say I think it depends on
on mutation operations which library are
first on your code at any I mean at any
rate wherever whatever is their source
and how many of them are there some
eighth and some method must exist to to
address address the problem of those
mutations may be you know some regular
expression like syntax which allows you
to say if and your mutants debug appears
ignore this the survivor because I don't
care anyway or something I'm sure there
is a research going into this topic
which I haven't touched on well I guess
this was the last question so thank you
all very much for being here with me
today and if there's anything more I
will be there with you drinking coffee
thank you very much thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>