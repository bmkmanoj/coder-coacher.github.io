<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2015 - Alvaro Videla - Dissecting the Rabbit: RabbitMQ Internal Architecture | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2015 - Alvaro Videla - Dissecting the Rabbit: RabbitMQ Internal Architecture - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2015 - Alvaro Videla - Dissecting the Rabbit: RabbitMQ Internal Architecture</b></h2><h5 class="post__date">2015-04-13</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/WPischLIe8Q" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and thank you for for being here
the talk is called dissecting the rabbit
rabbit and Q internal architecture my
name is Alvaro Videla and you can don't
you don't need to pronounce it basic
it's a bit about me I work at RabbitMQ
we are right now four people working at
rabid
I'm co-author of the book RabbitMQ in
action
I made a simulator I will show you later
what is useful for don't know here who
knows Ellen everybody okay so basically
I can't skip my talk Hank go home oh you
some some can come here and give it so I
brought some stuff about the internals
of rabbit there I should write more
maybe and that's my contact info that's
book that I know you can be acquired in
Russian websites sorry or you can buy it
somewhere depends on you as long as you
read it I don't care how you got it
don't many talks one of the first copies
that went out into the Russian market
was actually from a function and
programmer from Australia so I don't
know what this guy was doing but he
leaks on state he has some side effects
when he bought the book because I have
the name below like this copy belongs to
whoever so if you want to work at rabbit
get in touch later or and that's the
description of the job basically and now
that we are lambda corn you should use
this programming language is much better
than whatever you ever heard about it's
a better culture so starting with the
sock intro the idea to show you or tell
you what rabbit is doing so we
understand what protein rabbit is trying
to solve because just to talk about the
internals without really knowing what's
trying what problem we are going after
it's quite hard then we go into
some part of the internals we may save a
time what happened inside a message and
inside the rabid message store and then
I want to talk about behaviors and
extensibility from from the RabbitMQ
point of view so what is RabbitMQ it's a
multi protocol messaging server it's
open source under the Mozilla Public
License polyglot in the sense that you
should be able to call in elixir or
airline for rabbit or any other language
or machine language and that you can
connect to it from many languages
sometimes people after you need to use
sell and to use rabbit no you don't you
can use PHP Haskell whatever you want
and you can see which streams I say PHP
and Haskell right you can go the whole
spectrum of of table flipping basically
it's written in a LAN OTP and I will
show you what's good about that later
multi-protocol it means you can get to
choose with mustache style you want
NQ pieces default protocol implemented
in rabbit then there is mqtt and stomp
mqtt telemetry protocol for password
oriented programming so if you are into
the Internet of Things and qtt was
created for that by IBM but is an open
protocol and stomp is a text-based
protocol which happens to be used for
example at CERN so if the last column
Collider every explode we of course we
won't know what happened but it was
probably because of stomp it's a
text-based protocol very simple so
anyway there you can see why you may
want to use one or the other
polyglot I said already you can use
rabbit from Java and no there lamb PHP
Ruby don't need Haskell and so on the
main difference is the Java and.net
clients are officially supported by the
rabbit team then the note client was
created by a colleague that work on
grabbed it for a long time I maintain
the PHP library another colleague
maintains the Ruby library and the
Haskell library was created by a German
guy so we know Germans commit no
mistakes early sound perfectly working
language I say this in Germany already
so I and I'm still alive and you can use
this from Kobol and that's true it works
and I made this joke at another
conference and the main sponsor of the
conference was a COBOL shop they weren't
so happy about this and if people use
rabbit yes some people use rabbit
Instagram indeed comm mailbox
MercadoLibre telefónica like lot of big
and small shops around the world then
you can get rabbit from there yeah of
course
if you cannot download it I should be
kicked out of this there is a simulator
you can find it there
it's the most non responsive web site
you can find on the web because that's
like I mean who needs responsive
websites anyway so that's the simulator
and I want to show you how rabbit works
or what's trying to solve and then we go
to the code so the main idea mr. chinta
is that you have a producer the producer
wants to send data to the consumer so to
send data you need an address in
rabbitmq or nqp they are call exchanges
I hope this is fine for everybody if I
connect the producer to the to the
exchange and then I send data it just
dies there at the exchange
why because I need to have cues so if I
instantiate a queue and bind it to to
the exchange and send data now the queue
goes to the message go to the queue and
lo and behold it cube messages like
there is nobody connected very early
probably wouldn't be queuing like that's
literally kicking me out of here and the
consumer can come later start consuming
messages if this is too slow for
whatever the reason you can have more
consumers by the
subscribe into the queue and then Robbie
we try to do the round rolling thing
then something that people may asks why
do you need the exchange and why you
don't just send data directly to the
queues for example and the thing is the
exchange is just a router and I like to
use this example if you go to the train
station live in Switzerland if you go to
the train station in suruc you come by
let's say international or local tickets
so you are greeted by a machine you
click a button saying what you want to
buy they give you a ticket and that
ticket will put you in a queue so you
can have two queues one for
international and one for local ticket
and when I arrived to to the train
station if I want local I will go there
if I want international I go to the
queue but nobody
ah nobody will nobody will attend me
because sorry I'm in throttle mode today
and the the the the problem is the the
this is my switch context which I switch
the draw mode I cannot get back to talk
mode there is nobody to attend me
because I mean it's whistlin who if you
are in Switzerland you want to see the
wonders of Switzerland that's why we
have all these consumers or people
selling you ticket but you can also
again come later and get your consumer
and so on so the exchange is actually
implementing a routing algorithm there
are many of them I won't go in detail
now but there is a direct fan out on
topic by default this is part of the NTP
specification and they did they tell
rabbit how to do routing the direct
exchange is saying select from queues
where routing key equal binding key the
binding key is the one here the routing
key is the one I specify in the message
there is no SQL query because RabbitMQ
doesn't use an SQL database but just to
give you
example that's what happened with the
direct exchange the fan-out exchange
just ignores routing key so if you need
to do broadcast you use fan out and if
you need to do multicast then use topic
in topic you can use some patterns to
decide what how to route messages in a
more advanced way than just what the
direct exchange is doing questions about
this no okay by the way if I'm talking
too fast just let me know and I have
this Latino blood inside me that doesn't
let me speak slow that's why you see
like whenever you go to Latin America
you see that we are always sleeping
under some palm tree because we always
speak too fast we say what we have to
say and then we we have we have we have
time to relax so internals of rabid
sorry internal rash
so my idea is to give you an approximate
thing of what happened in the life of a
message and of course you have a
producer the P the message they would
send a message to an exchange and the
message maybe gets route to some cue the
red thing there this is PHP code because
in a functional plumbing conference who
doesn't want to see some PHP to see that
we we take care of everybody in in nqp
you always need to create a connection
that will be the TCP connection first
line second line the get a channel in
nqp you can have multiple channels pair
per connection that's very important
when I start to explain the whole
supervisor thing from Ellen then on the
channel I start sending commands like
you declare to create a queue exchange
declare to declare an exchange do the
binding panic read a message send a
message with basic publish the
mrs. we'll go to an exchange so let's
say we have that code so the question is
what happens there I created a new
connection and a new channel I know you
cannot see it I will go in details later
but that is the supervisor tree that you
will get because you started our
connection in this case with three
channels if you see the structure below
is kind of repeated it's because the in
that case that connection open three
channels but more or less as the
supervisor tree that you get out of that
coma those comments so inner line
everybody knows how long but let's go a
bit about it for the recordings Ella has
processes they are probably thousands of
them is implementing the actor model
which by the way it's not something
coming from our language coming from
later as some speaker said today from
earlier sorry from Carl Hewitt and other
people that I brought the I think was
planner the language at MIT and they try
to have the actor or formalism for it
and then of course from there we have
today what is element which by the way
the latest crash motto
let this be recorded is part of the
Allen community don't try to steal it we
will fight for it
this processes will send messages to
each other each message has a cue don't
confuse this cue with RabbitMQ cues each
process has its mailbox which actually
is Kentucky where all the methods go
there and another interesting part of
Erlang is that this has this built on
machine which has a preemptive scheduler
many languages trying to implement the
actor model but they don't they don't
have a preemptive scheduler and
everything blocks when when laden are
reading from the network or whatever so
sometime people shall say I have the act
they are the actor model
somewhere in whatever language but they
forget that and they immediately compare
it to a long but that's like the base
along the
there is all this supervisor and think
that we will see soon so your app in
Erlang in this case the app is rabbit
will be running with all this in mind if
you want to read more about how L and of
scheduling this is a nice blog post by
Jesper it's interesting to see you how
the scheduler works then the
construction in Elam is very flat
you have modules more you will have just
functions function will have a DT it
means that a function with the same name
let's say hello with one argument is not
the same as hello with two arguments and
of course their argument to function and
in Erlang the resort is MFA which is
Mali function arguments couple usually
or whatever so how does that one look
like you have this for example in rabbit
this client supervisor has a module name
which needs to match the file name it
will implement a behavior which is
supervisor to in this case supervisor to
which is today spread a long way to many
a long process projects they started in
RabbitMQ was the first project creating
a supervisor to then we sport some
functions like startling 1002 and so on
and we include some header so that's
like the basic first part of your code
and then in Erlang you have the actual
code so you see we can we have three
functions called step link but actually
Oh - sorry the first one has only one
argument the second one has two
arguments so there are different
functions and yet that I will explain
later what what that tried to do
Supervision trees this is taken from the
airlin Docs and that page explains a lot
about how this works he have a
supervisor it will it will be an element
process that has a special function
which is supervised in other processes
it will take care that the other
processes are doing what they should do
not sure if this is politically
politically
correct to say that will be the Vista C
of your your ellenmilton machine making
sure everybody's doing whatever they
have to do then in the supervisor drill
you have worker process supervisors and
you have this hierarchy of process which
for example this in the client
supervisor I should show you this is the
function or the specification that's
saying how to start one of these
supervisor in this case but we can have
a worker like let me just go a bit back
the one at the bottom is starting a
worker the other a supervisor and and
this client knows how to start all these
children so when you have a child spec
that's something really cool for a line
you have the restart strategy so by just
providing this Adam you are telling what
happens if your process fails and for
rabbitmq this is really important
because we have I will show you soon we
have lots of processes that are reading
from the network and managing the
channel state they are starting new cues
sending messages to the queues
monitoring that the queues are actually
working monitoring of if the memory is
not overflown and stuff like that and
they need to know what happens if one of
those processes dies in Erlang but
you're saying let's say one for one it
means only restarting the the failing
process in that thing this is simple one
for one for example one for all see if
somebody fails
let's kill and restart all the siblings
simple one for one which is the one
rabbit using in that particular module
is a simplified version of one for one
which actually you can add all the
children dynamically and in the case of
rabbit whenever you have a new
connection you have a new TCP thingy new
channel and so on so all these children
need to be started dynamically then
there is a max restart that the process
allows in that amount of time so you can
say in this amount of seconds you can
we start this process this many times if
you keep restarting it just bring down
the app or whatever a strategy is and
this is important for example if you
have an app that is trying to to write
to the file system let's say and the
file system is full then what's the
point of Kim restarting this file writer
when we will keep failing after after
some time let's abort
then the child spec has these types for
the type crazy people of the other side
of functional programming like the
chalice bag we have like an IDE which is
just a term you pass the start function
which is a mobile function on some
arguments you can tell you how to
restart permanent permanent transient
temporary and so on yeah it looks like
this yes when you do it if you want
later I can show you the part rabbit
used specs but in the docs of airline is
full of this kind of stuff telling you
what each function expects you to have
or what they will return and so on so
it's not really enforcing the type
system but I think it's quite easy to
reason about what the function is doing
so the rabbit client supervisor going
back there will be a simple one for one
there can be no restart the client will
be the idea theme model function
argument what needs to be started
temporary is the how the restart
strategy works infinity I think is a
time that the supervisor let the child
wait till it killed something like that
and this one will be supervisor and the
M on the list at the end this is for
when you have a release in Erlang we
don't go there I don't want to give you
details that maybe now are not really
interesting for the discussion so a
permanent child needs to always be
restarted temporary will never be
transient 1-under started if it was
terminated and normally so by just
having these tuples and these
combinations you have a declarative way
of saying how your course will behave
there are no ifs not case if this fail
and throw this exception or that
exception do this is that there is not
even cosine how like new child or new
supervisor on you work and all you just
give this back all these are arguments
and that's it a long takes care of it
which I think for for a project like
rabbit it means that there is less code
being written basically so and it's
quite easy to go later to the call and
reason and try to understand what's
going on then we have all this work that
that I don't know I don't watch games of
thrones but I know that a lot of people
dying Game of Thrones that people like
because of it maybe I don't know but
airline was killing everybody way before
it was cool basically Robert knows
they're right brutal kill was there
since ever and if a child gets it
brought brutal kill message by you you
don't have time to collect your things
go to talk to st. Peter as you are
basically timeout in seconds we'll wait
this time mound before terminate
terminating all the children and the
infinity will give enough time to to
shut down the whole supervisor tree so
this is in Ravi this is interesting I
will show you later also because for
example in AMQP you can declare queues
to be out to delete right so the queues
are out of it either deleted once you
close the connection if I'm not mistaken
so rabbit has a process that is just
tracking cue names that this connection
declared when the supervisor tree shuts
down that process will also be shut down
in the
specific order so the process knows that
because it's being shut down it needs to
start deleting all all the cues that was
tracking so also why just having the
this tree of supervision we can really
know when we do some kind of garbage
cleaning in the in the project that we
have so going back to the connection
supervisor tree supervision tree at the
top I will go part by part rabbit has
always Revit TC big client supervisor
whenever there is a new connection it
will start a rabbit connection
supervisor the rabbit cue collector is
the one I was decide is the one I was
telling you that it's keeping track of
the cue names and the rabbit reader the
reader is the one reading from the from
the network and the intermediate
supervisor this one is rare to keep this
tree structure to know that when this
thing is closed the cue collector is
closed at the same time it's kind of
hawkish but is a way to to keep the
structure at the same level of the tree
so the intermediate supervisor will
supervise the channel supervisor
supervisor like what is going on here
like why you have that I told you that
there could be many channels per
connection and that one channel dies
doesn't mean you have to kill all the
channels so we have a supervisors of
supervisors there and then we can have
the structure at the bottom replicated
according to how many channels you have
so for that particular channel that is
just open we have a writer which will be
the process writing back messages to the
network and we have a limiter which is
kind of doing flow control so those are
the the end of the tree but the
supervisor will be just taking care of
that part if you open a new channel this
structure will replicate you know in
another part like that so if you open a
new channel you get a new limiter for
that channel and you right there and so
so for example in nqp if you send a
knack for the wrong message the
specification says that you need to kill
that channel but only that channel not
the connection so in with this structure
we can kill one branch of the tree and
let the other running and depending on
the message that that depending on the
exit status of the process the
supervisor on top knows if it has to
restart it it doesn't have to restart it
take care of it load it whatever so
depending on the kind of error is how
this propagates up and down the
supervision tree and back to the first
image we have the the this is the whole
structure one connection three channels
don't know what's next yeah you have
question about this yes
I don't know the details but it's in our
Doc's on the on the source code
explaining the reason I know it's
related to the cue collector or when
they they kill it
what happened with the cue collector but
I'm not I kind of give you the
excitement so again I know you can't see
it but what happens when a message is
published to rub it it's not good sorry
so
so when you send a message to rabbit you
cannot see it anyway sorry when you send
a message to rabbit it will it will call
for example the mess of basic publish
and this method will create a resource
with some virtual host so what it will
create a resource knowing in which
virtual host you polish the message and
so on then based on that record in
Erlang it will start going through the
if I do this maybe wait never do this
when you're doing a laptop so whatever
so this message will start going through
through the rabbit permission system and
and you need to see is they for example
that the user has access to the exchange
where they send a message it has access
to that particular exchange then it will
check if the exchange is actually there
it is there it will check if they
changes and internal exchange for
example if it not you get access refused
otherwise you keep going that message
inside Ravi so the process will decode
the content of the message for example
you can pass in the message some
properties saying like expiration of the
message you need to decode that and see
if the expiration are correct you can
pass a user ID in the message it will
say you see if that user ID is correct
and so on so this is why I told you
today when we were having lunch that to
those guys that l1 pattern matching is
better than F sharps and have kill and
closure and bring me bring your function
of roaming languages there are all wars
on this now except cloture the other one
so what's happening here we
Robert what are this silicon so here we
are trying to see is a user that claims
to be some user is actually that
particular user so the check user ID
function will get two arguments one are
the properties like the envelope of the
ordinate of the message and the second
one is a channel state this P basic is a
record with the properties of the
message so if the user ID is undefined
we don't care what the the channel state
is that what we have the underscore we
just return okay you don't you didn't
set any user ID there is no need to
validate that next header of the
function you set a new sir ID which is
then set in the variable user name and
in the second line of that header we
check what username the channel has and
that's the power of Alan or something
that the L important matching has that
most languages don't have it is the the
first time user name is used he will get
the value whatever that value was the
second time because the variable is
already bound the value has to match if
it doesn't match this part won't be
executed so by just having this part on
the header of the function you know that
it won't be called if the user name
doesn't match the third header of the
function the user claimed to be whoever
and in the channel is somebody else
maybe so okay is that somebody else in
Rabbid you can be an inter senator you
can tell your by configuration that that
user can impersonate other users so if
the user is an impersonator we return
true false precondition fail somewhere
or blah blah but by doing this pattern
matching from airline is quite easy to
see what's going on and it's very short
in the code the first few cases that we
want to
this card oh one is that the user ID was
not set second make sure the user ID is
exactly whatever username the user
provided when it created a connection if
that's not the case then we check in the
third part of the code I told this once
to roomful of prologue prologue
programmers they say like we have that
every Dame prologue but in other
languages is not that common to have
these variable bindings so you can see
what this is there is a blog post next
then we check if your channels is in
transaction mode or not and if it's in
transaction mode we need to see a
sequence for the transaction if it's not
then we keep the flow I won't go in
detail here once the message pass all
this part we will create a delivery and
something that is important is this the
message got all the checks from the from
the rabbit logic to see if the user can
publish this message if the exchange
exceeds this exchange is actually
writable blah blah blah but the
important part is we get a list of two
names for rabbit exchange routes so they
are the exchange logic will take place
and we wrote down a list of queue names
to see where the message has to actually
be sent and in that case the message
will be delivered to a queue maybe one
maybe many queue and in the case of
rabbit we don't duplicate message
content we keep track of an index and
know where the message is to prevent
duplicating data in memory and on the
hard disk then the queues they have some
optimizations like they will check if
for example the current there is a
consumer bound to this queue the
consumer has no work to do the consumer
told rabbit I don't want to watch any
message so shall send them and forget
them
so if rabbit detects that case it will
send a message right away to the to the
user to the connection and won't be
doing persistency at the Q level because
there is no point on doing that so
that's an optimization thing for example
then you will see the message has some
expiration Heather if it's set on this
and that happens to be zero or
whatever the message will be gone why do
I need that let's say you want to say I
don't want to queue any message if there
is a consumer ready the message has to
go to the consumer
if there is no consumer ready we don't
queue you can say that who wants that
that is quite common actually in in
places that they if they don't have
anybody to take your order they just
don't want you there because they don't
have room or whatever the reason so
rabid can google stuff like that for
example so after the exchange say -
which accuses you will go the queues
decide if I can send it right away to a
consumer if you need to persist at the
setup so at this point will reach the
message store the rabid message store
was made specifically for messaging is
not using Nisha repeat that after me
please
gravity is not using Nisha for storing
messages people keep repeating that
people that do analysis on me on rabbit
they say that that's not true rabbit is
not using Nisha for message storage this
that this message store will try to keep
messages in memory and flush to disk if
it has to of course they ban the
boundary of the mess of the message
store is a disk size and there are two
there is a transient one for messages
that are transient and one for
persistent messages and each queue has
an index the message is written to this
when you have delivery mode 2 which
means persistent message or when you
have the more pressure so I will start
patient to this trying to get rid of
both message and free up memory but the
idea for rabbit is to always try to send
messages from memory so it doesn't have
to touch the harddrive why we need a
custom message store all the things is
written in that blog post
if you want to see how the compaction of
files is done that comments the cassava
like a long essay on that l1 module
explaining in detail how messages are
moved from one file in the heart in the
heart right to the next one and so on
and how did react to memory pressure is
explained their creative flow I won't go
too much in detail because it is not so
much time but the idea of credit flow is
to prevent processes from killing each
other by sending too many messages into
their main mailbox that can happen so a
message would have a crazy spec saying
you can send me up to 200 messages and
after i hack 50 you can send me more of
messages basically that's inside rabbit
that's not the AMQP messages
these are airline messages so I don't
know if you can see it but I process
start sending messages to another one
and the 199 messages going 188 and so on
at some point that reached zero that
message will be blocked that process
sorry
blow up by the other the other process
won't let it send more messages when
does this happen rabbit for example
needs to write to the harddrive if the
processor is writing to the harddrive is
not fast enough at some point it will
start blocking the other processes and
so on yeah yes but no I mean it's a
creative process and yeah I will try to
do that to the other processes what do
you say but we prefer to reserve that
time for for the network side yes
the thing is when you need to maintain
rabbit and you need to reply to question
on the mailing list and you have tons of
user going to the menu list you need to
set a very specific vocabulary for
whatever you are talking about or people
will start mixing things up so we need
to give things in certain ways anyway
basically a process can be can block
another one and then you can have a
chain of love processes that are waiting
for for something for example the
channel may be blocked by the queues the
queues may be locked by the by the
process that is brought into the
harddrive and so on when this one is
finished writing to the harddrive we
start to let the others do things so
yeah the grandma created the blog
process and the delay grunting credit
you can read more there next behaviors
this is something that allows rabbit to
be very flexible and it gives a lot of
extension points inside rabbit and of
course Alan so it L AM behaviors they I
mean you know this like an interface for
component in the case of rabbit we
define the what an exchange should be
what a queue should be we have
decorators for example we have
authentication methods and so on so in
the case of an exchange you have this
behavior with some coal but you need to
implement route validate es change and
whatnot but if you implement that
interface you have your own custom
exchange there are consistent - exchange
there are random exchanges recent
history of change keeps track of the
last and messages react exchange every
message going through that exchange is
also logged in to react for example
under more so each exchange is
implementing our routing algorithm
basically then there is all this
authentication behaviors that you can
specify how you want in authentication
to work on gravid the message story
index by
default is using ETS and DTS you can use
a bit calc level DBE and so on depending
on your needs back into you don't like
her rabbit store message to this you can
write your own baking queue and
implement a behavior you tell rabbit
instead of using the default use this
one for example in the config you can
say that education buttons are those
HTTP and the default one there are all
these behaviors inside rabbit maybe now
we have more I don't know and you can
plug your code there how you play it
this boot steps in rabbit that they
build like a direct graph of
dependencies like this boot step will be
add the exchange type direct into rabbit
and require that the rabbit registry is
already running and it will enable can
turn already so Robbie would try to
build a graph like this one if you can
see it on github before you can not see
much there but it's a graph of all the
processes I'll start running in Erlang
and this is very declarative it's just
using the airline module attribute it
will run through your modules find
attributes will the graph is the graph
can doesn't have cycles it means rabbit
can boot for example the Federation
plugin for example uses that for
replication you can read more about that
there I explained how rabbit make sure
that the we are using the right behavior
that we don't execute arbitrary code
with those behaviors and so on and the
boot system is also explained there and
to finish what Robert is doing is trying
to use many of these feature from
Maryland for example the the whole super
version things of course it is also
extended inside rabbit with new
supervisors like supervisor to and stuff
like that and it's very extensible from
my experience they think that you can't
just hook
by using the the boot system for example
it just lets you declare your module as
a boot step and your module will be part
of rabbit without doing with the rabbit
even know it that this thing is they are
kinda so we recently moved to its hub
you can get the code there to let let
you know when rabbit start as a project
github wasn't even a thing so that's why
we recently moved to it so now there are
questions
so the question is what we need to
provide it to what not to use the
original supervisor I think there are
new restart strategies one of the
reasons is that there are different or
new ways to to restart process and see
why we need to return - yeah you
mentioned that you're not using Nisha
for storing messages and under stored
boarded in memory and on disk so why
aren't you using ninja and and what are
you guys using we are using our own
custom message store robert has a module
called message store which is
implementing the whole persistent thing
and patient to these deciding when to
page to these concerns like that okay so
why didn't you use Manisha which was
already for this purpose well it's not
made for that purpose Nisha is a releves
I mean you probably know from a lung and
it's made for for a different use case
mostly in memory database for for the
switches probably Robert can correct me
the case of mrs. Shin is that you have
maybe 10 K messages per second going
through your system or a hundred K and
Robbie needs to be able to handle that
use case and those hundred messages that
when they are in a second as soon as
they are probably asked by a consumer
those messages are gone from the
database normal database is usually used
that you keep data on it for a long time
and then you query that data in the case
of rabbit know we need to chef persist
messages which will maybe be one
millisecond inside the server and then
gone so that's the use case and that's
explained in that blog post I mentioned
before the the device of and many people
are saying why can't you we just used
let's say mine sequel you could probably
write on my sequel wrapper and put it
there but you need in every everyday
data structure every database has a
trade-off maybe some have very fast
writes the slow reads whatever
if that accommodated your use case be
happy to use or feel free to use
whatever that's why we have a plugin
system that you can put your own you
said when the messages arrived to the
queue and if there is already a consumer
connected there and there is no work for
this consumer you just send it directly
to the consumer
do you actually check the size of the
queue before you do that or you just go
directly to the consumer I mean are you
very key implementation or you can just
starve everything in the queue because
the consumer is now free and you can
just so rabbit is not really doing run
Robyn if it's like 100 percent it's not
here in the top but there is something
called basic cost quality of service
that you can tell rabbit that this
particular consumer can have a buffer of
a thousand messages let's say or 500 or
whatever so rabbit will always try to
fill that buffer and then we'll go to
the next consumer and in that particular
case that I mentioned in the top is if
the consumer has no work to do anything
nowak mode so if you're in know what
mode it means I send you the message and
I forget about it so because that those
conditions are met then rabbit does the
optimization because there is no point
in persisting a message otherwise it
would try to go through the normal flow
of per 15c or whatever and thanks and
the last question is how do you handle a
failure of this failure on the Q side
side like if my disc dices and
everything is persisting on the disc I
don't think everything goes with it
so I sent thousand messages to the Q and
the Q per system on the disc and the
node dies what happens to the thousand
messages at a center so if the message
are there if you can't restart the node
of course it will still be there there
is a recovery mechanism one rabbit rest
art that tries to read all the things
and recreate the queue but you don't
have any replication there is
replication Robin has mirror queues for
cluster replication Federation and
shovels for inter cluster application so
if you if you have your own look like
that you use the New York use is called
there is a master there will be slaves
they need to synchronize acts rights all
the stuff because one idea of NQ peace
do not sell the applicated messages so
rabbit needs to prevent doing that or if
you are come message in a note probably
need to prevent that this message is is
sent to another consumer example so
there are a lot of things that the
protocol imposing rabbit and this
replication mechanism has to take into
account in do anymore questions and in
common some columns in alert no okay
thank you very much thanks our speaker
and now let's have a 10-minute break
before the next up thank you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>