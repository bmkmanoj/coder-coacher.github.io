<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days 2018 - Marcin Rzeźnicki - Idris for (im)practical Scala programmers | Coder Coacher - Coaching Coders</title><meta content="Lambda Days 2018 - Marcin Rzeźnicki - Idris for (im)practical Scala programmers - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">⤵</li></ol></div></div><h2 class="post__title"><b>Lambda Days 2018 - Marcin Rzeźnicki - Idris for (im)practical Scala programmers</b></h2><h5 class="post__date">2018-03-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/9oTPqKB0z24" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hi everyone in Kia I'm Marcin reznitsky
I work for iterators in case you haven't
heard of us we're Scala consultancy
company based in Warsaw so you could
check us out if you feel like it and
having said that and today I'm gonna
give a talk about it risks for Scala
developers and you might be asking
yourselves what it's - why do we compare
a dress with Scala for one thing
eateries is known for its dependent
types but what that actually is and
what's the advantage of having these in
your type system what expressiveness are
explicitly do you gain with we've
dependent typing that I was trying to
explain a bit as well so to kick it off
there is this quote I very strongly
agree with it's been attributed to a lot
of people throughout the years but I
mean the actual author was Kurt Lewin
was American psychologists in 40s coined
this slogan and there is nothing more
practical than a good theory and well
theory will help us we'll start with it
a bit and it will help us to see what
the possibilities are what can we expect
of type systems and possibly where on
the scale of you know type system power
its precedent as where the type systems
that we are used to are so you can see
possibly what the benefits of dependent
typing or our contemporary programmer
are because it's not always the case
it's rarely the case that we want the
most expressive type system well for one
thing with gain of expressiveness you
often lose some guarantees for example
type inference
might not work or type-checking times
might be unbounded so the question is
was the point of impracticality on this
scale of expressiveness they're two
tools well that many tools but I want to
talk about two tools that can help us
exploring this this periodical landscape
one is a visual representation
it's called lambda cube and the other is
a mathematical framework or theory
called pure or sometimes generalized
pure type systems or generalized type
systems and that's a mathematical or
Fiori for describing and deriving type
system families so lambda cube is well a
cube a drawing of a cube and the idea
here is that if you travel different in
the skew bin or traverse cube in
different directions you get different
abstractions that you mix together to
create type systems and these
abstractions are where informally
speaking it's it's about dependence is
what dependencies between things that
type system might operate on like terms
and types what dependencies are allowed
we have four of them it could be a
feeling of what that is maybe I'll show
some snippets of code so when term
depends on term and by term we mean
constant a variable a function
application of function and so on you
know that just this simple simple
strings possible the examples are in
Scala in uni trees so you can possibly
functions and spin things like this but
you don't have any kind of polymorphic
computation so on this you get when you
allow a term to depend on type when term
depends on type you can write things
like identity function term which
depends on type and can be used in any
context for any type for any a or a
function which takes other function and
applies it twice to argument that kind
of stuff
basically parametric polymorphism
dependent type what you get is type
constructors possibly high order types
the Venerable list type or I know
functor these are types that do depend
on other types and when the type can
depend on term that's where it gets
interesting
that's actually the subject of this talk
in this guy's that's dependent type for
instance in a diversity and the our
example is you have a vector of which is
a type constructor which takes the time
you have vector of A's but it also takes
a natural number so you have vector of
five of a vector of six of ways the
intent here is that this natural number
expresses the length but this type
depends ultimately on a term which is a
natural number in this case well this
guy I can you can do the same thing
maybe that's a bit obscure for for you
but it's possible so if you look at the
upper example you have a function hood
which return type which result I've
depends on its arguments so that's a
type depending on term term that in this
example so in sky is also possible so
the idea is that if you travel up or
upward then you had term to tie
dependency when you travel right ways to
then unit type of term dependency when
you go through back to the cube you are
type 2 type dependency so that's how
long the cube describes families of
types well I think I was because time is
pressing I think I will keep the
mathematical stuff the slides are online
so you can check it out if you're
interested
so I guess well ski be pure type systems
theory what's important here is that all
corners of lambda cube can be
represented using this very and much
more
for example lambda cube can and that's
the point in case where you don't want
the most expressive systems possible for
example the pure type system theory can
represent South call system
that's a system where all types are an
inhabited or inhabited well why why
that's wrong because if you think about
curricular ties amorphous or
carry hard correspondence in this entry
under this interpretation proving a
theorem is equivalent to a program to a
computer program under this
interpretation types are propositions
and computations that create instance of
type are proof that this proposition
holds this computation can take
arguments and they are treated as
hypotheses of this theorem then if you
think about this way then when all types
are inhabited what you get is that
anything is provable and if anything is
provable then then reasoning in the
system is meaningless it's logically
inconsistent for instance types of
functions from A to B for any A to B
that's example of an uninhabited type
type that shouldn't be inhabited why
because under curry horde isomorphism
that represents a theorem when you know
something you'll know anything else and
equivalently if you're tasked with
writing a function from A to B for any A
to B you won't be able to do this
because if you take argument of type a
and you'll have to create some unrelated
type bead and how would you implement it
not possible well in system you it's
possible but that that's very expressive
type systems but it's meaningless it's
not really usable but corners of lambda
cubed I'll show you some examples of
what type systems are there so does I'm
gonna skip but
in the simplest system in the
bottom-left corner of the cube that's
what we start is the typed lambda
calculi and that's a system where you
can
well computational why it's it's
equivalent anything can be computed or
is equivalent to a lambda calculi and or
a Turing machine any computable function
can be computed there or type wise you
have only you can only have simple types
and one type constructor which is a
function type so this is not very
practical type system because there are
no real types so to say and there is no
polymorphism whatsoever you need
something more we need to at least have
ability to create types more elaborate
types so we go to the back of the cube
that we obtain system we had type 2 type
dependency and we obtain somewhat
strange system we just called lambda
Omega that's the system where you can
derive very elaborate type like either
list and well anything but there is no
term level polymorphism so you can't use
them in a function so you can have
whatever you want it types but you do
you won't use them at the function level
so you can have a function in this type
system which makes it strange which
creates length of any list even though
any list is representable in this type
system you can just have a function that
obtains the length of list of ins and so
on so and so that's not very practical
need to be able to mix type to type and
term to term dependencies so integral
upward the cube where we have to
somewhat famous types famous type
systems system F well system F is
because you're friends with Kipling
Miller type system you probably all
heard of it's a subset of this of this
type system and ultimately you get some
F Omega which sometimes called
higher-order polymorphic type lambda
calculus
that's that's where you get everything
you're used to in and when you think
about type systems and much more you can
unleash the whole power of lambda
calculi at the type level the type
computations can be arbitrarily complex
so it's very powerful and very
expressive type system it's so powerful
that languages actually do the were
slightly less than this type system well
for instance type inference is
undecidable in this type system although
if you think about it when you have full
lambda calculi at the type level then
you can represent unbounded recursion so
type checking my never finish
I never terminate so our day to day
languages like Scala and Hasker they
typically do not deliver the full power
of the system they deliver slightly less
for instance there is a thing called
higher-end polymorphism which cannot be
represented in Scala this directly to
give you a feeling of of the problem
well let's say you have a function from
a to a tuple of ACE this function
effectively doubles it's argument it
works for any type a so we could think
that it can be used in any context there
are no constraints on the type
whatsoever but if we want to use this
function like in like in this example so
we want to feed it with some argument of
type E and while we hope we get a couple
of beasts in return that should work but
it won't actually compile I'm not sure
if that's visible but in one compiled in
Scala scholar complain that well there
is a type A which it once and you give
it type B so why is that because sky
insists on having this type arguments to
be well quantified at the late at the
earliest possible moment at the
beginning of the function it needs to
set these types so in fictional sky like
here we would like it to be real I
dysfunction to have just one generate
argument one journal type parameter B
and pipe air should be like on this only
on this function level so that's how
would you probably would have written
that in fictional Scala but it's not
possible in Scala but it's impossible in
system app and the system F Amiga it's
not possible in scar so SCARA does not
deliver the full power of this type
system well it's possible in Harrisville
you can restrict type A to B well just
informally speaking at the level of of
this function so it's possible in IRA's
but it is in it are not hiring
polymorphism like free polymers
different free is not expressible as
well well there are other examples you
can prove something like on the type
level in system F Amiga and in Scala any
needs that a and B implies a for example
here's the here's the code I just said
that we have so it's personable so
powerful type system that common
languages cannot take advantage of so to
say but still there are some deceivingly
simple things but we cannot express even
given this very powerful type system
well collections what I mentioned there
are collections of known length well
that's that looks practical right we
probably don't want to take 7000 under
600 collections but it's you cannot
represent it in any of the type systems
I mentioned even given there there
powerfulness type of days were range of
day for example is restricted to month
that's a fact of life that's something
which we probably should be able to
express functions like sprints that's
interesting well a sprint but some level
can be seen as function from string to
string but we all know that it's not
really the case because the string
argument to a sprint function for format
string if you will gives has some
internal structure that determines what
sprint will operate on
so it's not really function from string
to string is a function dependent on the
string argument of something and we
cannot represent it and there are other
cases as well so question whether this
additional type safety that looks really
practical examples I mentioned I think
you you all would agree that it's
impractical whether this should be added
can we simulate it somehow in languages
that do not intrinsically support it
like Scala and is there any game is it
well possible so when I was researching
this I came across the Stack Overflow
discussion and there's this quote from
my taken from discussion where he
mentioned that you know the combination
of single type are dependent types and
implicit values and so forth so forth
means that Scala has surprised goods or
for dependent typing well if that's
something that miles Sabine mentions
then it's at least at the very least
worth considering so is it possible to
have this it's Cara and what effect on
you know our programming habits will not
have so let's let's go from the theory
to some practical examples well
I'm not sure is the divisible cold
because it's gonna be important well I
take it is so the collection here is I
will try to show you some examples of
dependent typing as found in eateries
that can be on the left and on the right
I'll show you the possible
implementations of these ideas in in sky
well the simplest dependent type is what
did I just do
well should I press press it again okay
I did that now the simplest dependent
type is this vehicle type here it's
dependent on dependency meaning only few
values it's technically value dependent
type it describes a vehicle which is
dependent on power so it can be you know
petrol pedal or extra can summing
instances of this I like bicycle and so
and so on
additionally you have a ref you
operation that's restricted only to a
petrol powered vehicles so this is
technically dependent type but it's you
know it's a thing where Scala
object-oriented Ness I guess really
shines and where a jurist needs to catch
up because this kind of dependencies I
would say they are the object oriented
programming essence and Scala is in some
part of different language so with many
ways to encode this and the
expressiveness in Scala is actually
better let me show you how for example
we can encode this dependency as subtype
so we can create a subtitle vehicle as a
petrol electric Bay and so on and so on
and then restrictions of refuel
operations are apparent to or obvious to
implement all right but there's one
problem and this problem is also it's
also this also exists in in address
implementation it's that we cannot
easily represent things like hybrid cars
which have well two power sources of
petrol or and elect to do that in
interest we would have to do something
fairly advanced like I don't know type
classes is found in Haskell but in Scala
it's I know very easy to achieve we just
can just encode this dependency s mixing
the straights and mix them in in
concrete implementations then you know
isolation was a refuel operation is just
as easy in addition we gain ability to
express something that's not really
expressed that's not easily expressible
in idris meaning
hybrid cars with many power sources but
there are other options you can use
phantom type the name comes from the
fact that this type is only used you
know during type checking it's not ever
used in implementation it doesn't have
any representation it just you know
parameterize this base type to give it
some additional trait for type checking
so we can encode power cells as a
phantom type we can have vehicles of
many power sources as easy as possible
and we can still rise refuel operation
even more akin to how it's written in a
dress and well these being field traits
make it work really well because Scala
in a completeness check of pattern match
is going to work in this case so this is
where Scott wind inside say but this is
very simple number let's move to some
more more sophisticated ones for
instance and interest is famous for
representing natural numbers on type
level well it's not really there is no
difference in address between value
world and type world both can be mixed
there is no difference between them so
for example a natural number is
implemented here is a recursive type can
be used on something with code type
level like here to have a vector vectors
had operation being restricted to non
empty vectors only well let's try to
simulate this is recursive type which
consists of fairly standard encoding
called charge encoding natural numbers
natural numbers are either 0 is either 0
or successor of some other number we can
encode this in Scala what does it at
rate a type member carrying reputation
of this and the recursive case is going
to be represented as
as type parameters too
to our retired constructors and using
this representation which is
translatable easily we can create single
item types meaning by singleton types I
mean types which have only one member
possible like type of 0 1 2 3 and so on
so on with values of these structures
there's only one structure that can
carry this type so well we just these
types represent on type level numbers
natural numbers but then in it is we
have a well they are interchangeable
with literal so it is understands that
for example 2 is a successor of
successor 0 and you can assign something
like number 500 to a natural number is
this possible well it's not really
possible you can do some tricks well for
example you can use macros to generate
the structure out of integer or literal
for you the implementation there would
just take a number which would have to
be constant because at compile time it
would have to apply type constructor as
as many times as needed and to
deconstructed you to the other the
opposite way but obviously it will have
to be at compile time constant because
had that be had that been a variable
then we wouldn't have been able to apply
we wouldn't know how many times to apply
this well then how would you write a
function which takes an input from user
and creates this natural number where
you could you know be smart and write it
simply in a recursive way to create this
representation but well there are some
problems with this approach first of all
and this slide is gonna be very
important later on first of all there
will be no type reservation what that
means we just return a natural number he
will lose our singleton type compiler
just knows there is some that with some
end inside but it doesn't know the
structure
and then we don't really gain anything
because we can't use we can pattern much
on type level anyway in Scala right so
even though we would be technically able
to create a natural number with this
structure from any integer number even a
variable then we wouldn't be able to use
it in any possible way so let's just
restrict ourselves to it literals for
for now okay so we added natural number
two type level let's try to simulate
something more complicated a fin which
means finitely bounded numbers so fin n
is a type that represents fin six for
example a range of numbers from a number
restricted to range maybe from zero to
five and it's constructors are easier
zero or successor but this successor is
limited in how many times it can be
applied so for example you can take four
fifth number out of six numbers but not
7:07 out of six numbers
so that's finding that isomorphic to
finnaly bounded natural number can we
encode this in Scala is type indexed by
integer it's recursive as well well yes
we can use the same technique we just
take everything that this type depends
on first we notice that there is no
representation for zero right so a range
from zero to minus one is not correctly
representable so you can encode this in
constraints in Scala everything that
this depends on this this recursion type
depends on we encode as type parameters
with appropriate bounds and using this
we almost algorithmic technique we
represent we can represent it in Scala
very easily but then how could we create
any computation for example how can we
convert this for this fittingly bounded
number to a natural number on type level
well it's it's possible as well so if
you take function like this like fenton
add meaning infinitely manager natural
you just and you try to recreate a type
level you just need to leave this
computation to a type well just creating
a type that represents this computation
say trait you encode everything that's
input of this function as a type
parameter you encode the result type as
type member in Scala and tasks you lift
a computation to a type then you create
a type that's capturing the result it's
sometimes known as aux pattern if you
are familiar with Scala type level
wizardry but I preferred name result
because that's what it really is the
type that describes that result of
Internet for a fin F is a natural number
n so that's a type of result so in this
way we'll lift a computation to a type
but then how would we make it do
anything compute anything well there's
only one thing in Scala that's possible
to that you can customize during
compilation because well there are
computations that compiler
- during type checking during
computation like type unification but
this is set in stone you cannot change
it but there is one thing you can steer
that implicit resolution so that's the
only way to make it make a compiler
compute something for us to find the
exact types we need oh cases we encode
as implicit search
we have base case meaning for fz0 so
well we just create an implicit with
correct result so result for a zero is
type level zero we already know how to
instantiate is implicit so this is our
base case and in the recursive case we
do the same thing so we say if you are
able to find a result for some finny
tree bounded number F which is going to
be so far and will be a natural number
and title natural so to say then I'm
able to create a result for successor of
this and yes I am able I'm proving it
like here I'm just taking success or a
type of the successor of this
representation here so I'm able to to
encode this computation fully then just
you know a few tricks and you're done
so you have a reason to not for
something is s of Z for example type so
we just created a computation that
happens exactly a type level and is a
direct translation of a dress code
what's more is our dependent type in
Scala here to preserve structure
representation that's the most important
thing here you can just make it return
type like not because not doesn't mean
anything to compile it doesn't know what
structure it has it needs to know the
exact structure so we return a captured
out type which as I told you before we
encode result in and in this way you can
have a very precise representation all
the structure is preserved so all the
implicit s-- all the further
computations can work on this structure
can deconstruct it
okie-dokie even more complicated
functions how many time do I have how
much time do I have ten minutes all
right
even you know come on 15 mins okay oh so
it was me all right all right even more
you know something that would look like
complicated complication more
complicated version you can create using
exactly this technique almost
algorithmically input as parameters
output those arguments and so on some
result type and coding and so on so on
you can create fairly complex
computations on type level this way now
this technique works UN called
computation implicit search what we can
even do better than either is what's in
what's most interesting thing maybe here
where eateries has maybe of finicky
bound at number because it doesn't know
if arguments are correct we don't have
to preserve that because the nature of
implicit search is such that if the
implicit is not found so the conversion
cannot be computed cannot be made then
simply the program won't compile so we
don't need to represent failing
computation by option or maybe because
we are sure that we've argument then it
will be a compilation error so as a
corollary if the computation succeeded
then program is compiled so we can
better than it is in some cases all
right so with this we are ready to
recreate a poster child of dependent
typing meaning a vector of which
captures length as a type using the same
techniques even with some you know added
tricks like contravariant covariance
here we can create vectors that track
their length in scala and there will be
a problem sometimes need to be a little
bit creative with this translation
because whereas where either says that
Thailand had are available only for
non-empty vectors then well yes but how
do we know for example the type of a
tail of this vector we can take
successor of something but we cannot
take is any predecessor so we don't know
the type of the tail and we can't really
pattern modern generic data types in
Scala so how would we implement you know
head for instance we cannot pattern
match so sometimes we need to get a more
creative I would say so we create some
free black type level predicate type of
a pattern article it spawns that and the
intent here is that we create we you
know enhance it in such way that it's
able to disk instruct or
in Scala parlance and apply for us so
take out the elements we need and
captures the types we need so we call it
its cons because it's really
implementable for and we encode up the
constraints and so we implemented us as
implicit search and so on so on and then
using it
using this implicit evidence we can
create a head and tell in it's going to
work exactly as in Idris so we need is
when you create a vector of two elements
and try to take head of it or head of
its tail then it's going to work but if
you want to you know recurs too deep
then you get a nice error that there is
a type mismatch between 0 and successor
well in Scala I can do the same thing
you can create a vector of two elements
and you cannot you know go too deep in
this into this vector what error
messages are maybe worse but they are
customisable anyway so so we can do the
same thing almost because well you might
feel you might feel as cheating a bit
because we probably notice that in all
these examples length of a collection
was statically known and then what how
can I represent collections with unknown
links that's a bit of a problem because
if length becomes part of type and
length is unknown because collection
comes from no database then what then
type is cannot be fully represented and
independent type in theory there is a
weight or this is called Sigma type but
better name is independent pair so
dependent pair is a type that takes
something as its first argument and
something that depends on it a second
argument when I did it again one more
minute for this so for example type of
filter is not a vector of filter
operation that you know filters vector
is a dependent pair which takes a number
which is length of collection after
filtering and a vector of according type
so for instance if you take a filter of
one two three
list with a predicate is even in
injuries it's not that Idris type
tracker magically knows that the answer
is one our vector of one element it just
uses different type to represent vector
of unknown length and it won't allow you
to do anything with it meaning type
checker unless you turn off the street
unless oh alright unless you pattern
match on the first element and if you
put or not if you deconstruct the first
element then nature of this type is that
the type of the second element will
follow accordingly and that's one thing
that each race has doesn't have so for
instance if comma if you assert here
that the first element is number freed
and you know that the type and type
checker knows more importantly that type
of the second element is vector of three
elements and if you know it's at least
one then it's vector of at least one
element so it's these are operations are
deemed safe but if you try to cheat then
it will tell you type mismatch between K
and s lon so this is the way to
represent and operate on something of
unknown length even though length is
part of type can we do that in Scala
where we can represent Sigma type in
Scala maybe a bit awkwardly but it's
representable in that you probably don't
see don't you the dependency here at the
first glance but it's hidden here you
just demand implicit that you know
follows the type so well just let us
take a look at example I don't have much
time for this so maybe let's take a look
at this example so for example dependent
vectors you can create like this you can
say that there is an implicit that that
carries a number a type level number and
vector of according number of elements
it looks good so for example if we
create a singleton to
then the only thing you'll be able to
have as a second argument will be a
vector of exactly two elements so not
for example if you try to put there a
vector of three elements it won't
compile so theoretically you are able to
represent this case in Scala it has
everything you need
unfortunately we go back to this slide
once the number is not constant there is
no type preservation meaning using some
reflection wizardry in Scala
if you lose the singleton type this one
so compiler knows that two has as a
representation as taxis as a
representation a successor of one of
type level one but once you lose this
type one for example it doesn't take
much to lose it for example you just
assign it to a generically typed
variable then the compiler doesn't know
anything here right it just know that
there is some type and that's a
representation and none of the implicit
none of the computations that I showed
before will work so that's the bridge
you can't cross so it's not really
practical to simulate codes in Scala
dependent these type collections in sky
because you'll be able to only represent
collections of known of statically known
length which is not to come on use case
of for to collect for collections and
all the things like filter that do not
preserve size you want you you have to
give up on them so this is not really
practical to have this type at the type
system level is going to work but once
you get out of this singleton type
preserved structure you don't have
anything but there are cases where it's
practical the famous Sprint for instance
well it's as value dependent think as
you will see in your life so print win
eateries takes a string parses it into a
structure and from this structure it
creates a final type so for instance a
type for a function print person and so
on its string two into string and in our
case it's string two
to string value is seamlessly lifted
into type it's as well dependent fingers
you'll see in your life
it even parses the dem string to create
you know a final type which is deduced
from the structure of the string well
this is the bridge you can cross as I
said as I said right you cannot just
take go from string to function type or
print function type in Scala because of
this so you'll be limited to possibly
macro which you will use to parse the
string into this structure but it's
still practical because format string in
print you can treat as effectively
constant string literal without you know
without crying right and everything else
you can recreate in Scala and the final
result is that the type print type of
this structure is string to inter string
and the destructor is string to double
to string you can do you can do it in
Scala as well so sprint looks practical
because it's what we are dependent on is
effect can be made effectively constant
without loss of functionality
so that's my final thesis you can do it
in Scala the type system of readers in
Scala aren't that different you can
express almost everything roughly
everything that you can in one in
another in the other but there are cases
which you can't express which are
effectively which deal with you know
real variables things that we do not
know but there are cases which are will
be more constant based cases like state
machines which are effectively constant
at compilation or print like cases or
rules protocols which are effectively
constant then without loss of
functionality we can have dependent
typing as shown in Scala and I guess
that's the end of it thank you very much
thank you okay so let's have five
minutes of questions five minutes of
questions thank you very much
yes so why can't these breeches be
caused in Scotland so why is doesn't the
scholars compiler or so I have the same
support as Idris why don't why is there
kind of worms also in it or so why did
it the way it's not built-in if I
understand your question correctly I'm
not sure if I do but and the question
was is can scan Scala compiler support
everything that I just compiled good
it's clear to me that this kind of
compiler has well it doesn't cause so
some reason breeches are not crossed yes
yes so so why is there this difference
between Idris and Skyler so it's a
design error for is the difference well
it's not because of you know type arrays
or anything like this there is it is
bucking for JVM it's actually because it
reads can represent so-called pea types
in dependent typing theory meaning types
dependent on terms and this term as in
in this case it always is is a algebraic
data type in it is any type you can
create this actually algebraic data type
so without any loss of generality
eatery's can say that a structure of
type can follow the structure of value
because both are algebraic data types in
scala there it's not like this so in
scala you can't really it's a matter of
representations most so in scala there
is no sort of a unique representation of
types which images there is so in it is
every type has this algebraic structure
and from it you can deduce the type the
real type of structure the real type
structure of the type
so that's the only difference I think so
the difference of representation what
what my question is more so why wouldn't
the scallop people just copy this from
artists why um well uh Scala is is I
would say important language it has you
know it's his access lot of libraries
it's widely used and Idris unfortunately
is not so you can say that Scala people
should migrate to Idris to have this
properties possibly but probably they
want so the only way to have this in
have this without changing language I
would say is to simulate this and it's
possible I guess that's my answer
thank you very much let's say question
yep coming back to higher country
polymorphism an example were you okay
yeah isn't it the case that in that
particular case we could actually
circumvent that by by caring so we would
first fix the typo of the function and
then the value or the other way around
if you tell me which example do you mean
once again there was a stop make that'll
the make okay right yeah okay whoops
your party trick huh yeah it's back all
right okay can we can we solve this by
kering yeah yeah that's my question
because there is nothing to our type of
occurring you mean I mean first take
just the B and then take the function so
it would be so the B type would be fixed
and
basically we could use it in in the
latter part of the signature my general
yeah I'm not sure I understand which
takes just be right and then and then
take the function that makes the power
so the type of to make per function is
in in further oh yes that would solve it
right but the definition of course there
are ways to represented in Scala well
you can just don't use function for
instance but use natural transformation
as in Quetta it would work as well
that's more an operating but it will
work as well but the thing is the
definition of higher rank polymorphism
is where you where the rank means where
the quantifiers are Universal
quantifiers so actually the rank is the
number of movements of quantifiers to
the right so to say visually so if you
just need to move one type 1.1 for all a
one level so to say to the right and its
rank 2 and so on so on so on so yes
that's of course that's over well I just
wanted to show some from the definition
so the definition of high rank
polymorphous is like this and this
cannot be represented in Scala that's it
cool yeah the other thing is I was
forgot it okay I will just just say stop
yeah
are you aware of the de meme saying that
schematics the lambda cube and makes it
into a lambda tesseract star text lambda
cube and makes it into a lambda
tesseract so like a for T cube because
as I take it as far as I understand it
is is that lambda cube doesn't really
use it or subtyping there are a lot of
things that are not that's there are a
lot of things that are not represented
well entices lambda cube for example
type constraints type classes in places
are totally beyond this and there are
some things like as I said a system you
which make you know it go even into more
dimensions like system you but that's
inconsistent system which I mentioned
there and yet what Scala does is totally
out of this
in fact it's totally and it's totally
you know beyond this cube so to say
that's true but if you take away all
these aspects like type constraints type
classes and implicit what you get is
basically an F lambda based system so
that's I would treat it more as an
educational aspect of my talk more than
you know Bo M theory because that's true
and there are some things in that are
not really well represented in theory so
just take it with a grain of salt it's
and it's educational more than the truth
we complete exact truth that's true
thank you thank you for the great talk
thank you
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>