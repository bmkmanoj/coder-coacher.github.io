<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Building the ideal betting stack by Chandru Mullaparthi | London Erlang User Group | Coder Coacher - Coaching Coders</title><meta content="Building the ideal betting stack by Chandru Mullaparthi | London Erlang User Group - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Building the ideal betting stack by Chandru Mullaparthi | London Erlang User Group</b></h2><h5 class="post__date">2017-10-18</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/eXMfxJ_5FTo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">they'd like you to welcome
Chandru will introduce himself
background
okay questions to the anytime really
that's fine yeah I'm doing hello
everyone my name is Chandra so building
an ideal betting stack basically the
home oh yes so the the thought occurred
when I was working at batteries 5
because betting that has a lot of legacy
to deal with and so whenever we wanted
to do anything radical in terms of the
architecture there's always the problem
of there's so much legacy to deal with
and see what you're always patching
stuff and incremental evolving this is
fine I mean that's real life but my my
take on it was well you need to imagine
what an ideal betting stack always looks
like so that you can always map apart
from where you are to where you want to
get to now the ideal batting side is
gonna evolve as time goes by and new
stuff comes onto the horizon you've got
new components available but I think
it's something which you need to
constantly update and say well if I
built it now from the ground up this is
what an ideal one would look like so
that at least you know where you have to
get to from where you are so bit about
me I started programming in those twelve
started getting paid to do it when I was
21 I've spent about 18 years in telecoms
both on the vendor side by side with
Erics
Ericsson and then most of it was with EE
in the UK joined the bedding industry in
2014 and currently working on an
advertising startup so we're building on
our own ad server and I provide
consulting for like solutions so yeah I
mean like I said at the beginning
basically it's all about what were the
bedding side looks like
build it from the ground up without
having to deal with legacy so I've sort
of divided it into programming languages
and some operational tools and databases
so we'll let's go buy that obviously our
lingo dpi I mean this I gave this talk
at a bedding conference so it where ever
line would have been new to people so
how many does everyone already use their
line and okay oh okay
so about half so I'll I'll still talk
about why are likes a good choice but if
it's getting boring just heckle and I'll
move on so it's well it's a functional
programming language it's very
expressive so you can you can actually
express your business logic and very few
lines of code it's optimized for
multi-core I think multi-core support
appeared in 2008 probably the first time
and it's been improved on ever since so
everything is really the language and
you've got OTP which is basically a set
of applications built using airline and
that's a list of some big companies
using it managed agency it's there's
telecoms is advertising this betting
there's communications so it's used in
quite a few diverse industries and so
moving on I mean this LX 0 which is the
hip young offspring of that line it has
a Ruby like syntax so if you are
primarily a ruby shop but you still want
to get the benefits of our line then
this might be for you but I think people
who are already experienced with our
line tend to stick with it I'm one of
them I've tried looking at ellicsr
somehow I think and somehow its its
flipped around I mean previously when
people used to complain about the syntax
of idling I used to say well what's the
big deal you know it's just fintechs can
you not learn it but every time I look
at LX 0 I think
uh-huh did my head learn the syntax so
maybe it is a thing it compiles down to
Koehler Lang and it runs on the beam VM
so you you still get the I suppose if
you're primarily coming from the Ruby
world then you get a get the best of
both worlds you get the same taxi like
and you get all the characteristics of
the BM BM there are a few big companies
already using it I don't know much about
so if there is more than great you know
add it to the list
so yeah I mean I mean interpret anytime
you want to talk about something in more
detail but so I so I included go in here
in terms of programming languages to
which could be used because well I mean
go is a better see in some ways it's got
good support for concurrency with its
channels and go routines
it's got xsplit excellent cloth
cross-platform support and the tool
chain is is really nice I mean I really
wish we had a dual chain similar to go
in our line and we've got some way to go
before we get there and I think that's
actually one of the the support for
concurrency and the tool chain is
actually one of the main attractiveness
for a lot of people and that's why
they're picking it up but I mean why
would I not use go for everything
because I think if you're comfortable
writing C code then goes great for you
you know if you're already a company
where you use a lot of C and your
experience with it and you can handle
all the problems that come with it
then that's great but I but still a lot
of go code ends up looking like C cold
and the biggest well one big problem is
well the support of mutable data now I
mean one of the main attractions of
functional programming is that you have
immutable data so actually it's easier
to reason about the code and tested
whereas the problem it goes it does
support mutable data so the challenges
will come with that well and so for
example cross-platform compilation for
example so you can build yeah you can
build pretty much in one place for
diverse platforms and the other thing is
you can you can basically package your
whole application into a single binary
so actually shipping it across is
deployment is basically stick one binary
and configure your unity or whatever and
then you're done first everyone comes
with a suitcase full of stuff and you're
the sort of there is no easy way to
deploy it so the that is the end I mean
at battery safai the the gaming team
tried to start using airline and they
were primarily developing on Windows and
and yeah and so there was a huge step
I mean learning curve involved and how
the heck do I make all this working and
and some of the Jason decoding libraries
for like it was building they were using
niffs
and well okay how do I build this on
Windows now like how's know much helped
with them because I think the last time
I wrote code on Windows was in 1997 so
it was just it's just to learn where as
we go you can build for Windows on
Machine Network Billa single binary so
middleware so again this is basically
stuff which you use to interconnect so I
had I had I had to choose within Kafka
and RabbitMQ and actually I chose Kafka
even though it's not written inhaling
primarily because I think that the way
it's been designed and built so how many
people know I have used Kafka okay so
basically it's a high performance
messaging platform it's well ideal but
there are a lot of places where actually
you can use it quite easily for
interconnecting systems family
asynchronously I mean there's no it's
it's essentially a store and forward
system if you like it has persistent
replicated queues and it supports at
least once and I think recently they've
rolled out what is exactly one semantics
which is quite handy to basically
offload some of that complexity it comes
with a few caveats so it's not as
straightforward as that but at least it
provides support for it provided you
develop your application within certain
constraints and and it supports this
buzzword compliant new design pattern
called the event sourcing I mean it
makes sense event sourcing as a design
pattern actually simplifies the lot of
business logic here to build so to take
a slightly deeper look at it essentially
you've got a Kaffir cluster you got
producers and you have what are called
DB connectors which is basically
something which piggybacks onto the
a basis the right to head logs and it
can stream it into a class good luster
you've got something called Steam stream
processors which is essentially it
consumes data coming out of Kafka and it
stores its output back in so you're all
here to write it is you don't have to
worry about where the data is coming
from and where it's being stored Kafka
streams the library handles all that for
you and you've got basically your
bog-standard consumers so up in our hits
box standard pub/sub so Kafka has this
notion of topics so each topic is like
if you like a logical recollection of
your messages so if you're talking about
betting you could say that all bets for
a certain fixture are in one topic so
that if you want to settle all the bets
in a fixture you consume all the bets
out of that rather than going to your
database running a query saying give me
all bets which match this and then try
to do that and you can have and you got
the concept of partitions so that if you
have a bunch of consumers here you can
they can all consume simultaneously from
all the partitions so I mean and the
nice thing about CAF cases it's the
queues are the topics are a bit like a
time machine so you can you can consume
it but then you can always go back and
say right I want to consume all the
messages from a day or a month if you've
got enough storage so you can keep going
back to the same data without having to
run queries on it and within a partition
the ordering is guaranteed the other
nice by Canada
well interconnecting component we have
is there's G RPC again nothing
revolutionary about it it's just
a common way of doing RPC between
systems implemented in different
languages and we like with all these
things you know standardization is nice
and as long as we can all agree that ok
we talk your PC then you can talk to a
C++ service writing will be written and
Ruby or Java and interconnect them
without having to I mean previously you
could have done it with soap or you can
do it with rest using HTTP but in both
of them the problem is the the the
transmission of messages is not
optimized so G RPC uses a binary format
so it uses Google protocol buffers so
the messages are packed much more
efficiently on the wire right
right so these are the different
communication mechanisms you get with G
RPC you get the unary RPC which is the
traditional clients of request response
you've got server streaming our pcs
where the client sends a single request
and the server strands is sent the
stream of messages as a response or
you've got client streaming are pieces
where the client can send the series of
messages and when it indicates that it's
it's sent everything there is to be send
it waits for a server response or this
barrage bi-directional streaming it's
vital a bit like you and your spouse
having an argument here both throwing
stuff at each other at the same time but
but a concrete example of that is say
you are doing speech to text in real
time so what you can do is the client
can be sending snippets of the speech in
real time and the server as it decodes
sends you back stuff it is decoded you
can have a single conversation where
it's a continuous stream of data yeah
yeah it's mostly the case but sometimes
you've got to argue right
any particular reason I think really
only because G RPC is sort of more
up-and-coming I guess it's just that I
mean Peter engines a he passed away
recently as well I mean I suppose you
could do the same but I don't know
whether it has I don't know she drank
you enough to know whether it supports
all the use cases here so I would say
yeah probably because I don't know much
about G thank you yeah
and yeah and a 0 and Q support like
request/response like RPC ok
right can you do a request response word
I thought it was more a message bus
right okay so from an Operations point
of view
so this Prometheus which is basically a
monitoring and alerting system so it
supports a multi-dimensional data model
basically what it is is for a single
data point you can attach a number of
different labels to it so when you query
you can say give me all the data which
you know where the labels match and he
can have fairly complex queries with it
it's got a powerful query language and
it's developed and in go
so it basically comes with as a single
binary so deployment is very easy and
its default model is pulling metrics
rather than pushing and it scales quite
well with respect to pulling metrics
from a lot of systems it's it's CN CF
project so actually it plays quite well
sorry CN CF is the cloud native
computing foundation from where you you
get this and you get G RPC and this yeah
I'll talk more about the future ones but
basically the cloud native forum is
trying to build a set of technology
so that you can actually deploy systems
easily in the cloud and you get all the
good stuff easily without having to
build it yourself
so this open dressing is basically an
open standard for distributed tracing
again with all of these things it's not
that you can't do it yourself but if you
were doing everything yourself then you
can but if you got systems written in
diverse languages and you want to
integrate them I think really all these
these things I'm putting out here are
stuff which enables you to build systems
in different languages and integrate
them easily so opened rising again is
basically an it's an open standard or so
imagine so you've got quite a deep stack
of requests coming into your system and
then it traverses multiple systems and a
response goes back to the user now you
want to know how you know how long the
certain request is staying is taking on
each leg of the stack I mean if if you
didn't have open Dre open dressing and
you wanted to build it the the logical
way is well let each a system Amit Amit
an event saying this is the correlation
idea of they were is of the request I'm
dealing with I started here I finished
here
and let it travel through and that's
pretty much really what open dressing is
it just defines the standard so that you
don't have to argue about how to
implement it so they there's an example
of a request flowing from the client and
a number of systems at the at the back
being invoked and what it does is it
enables easy visualization of execution
flow in this system because as when
you're writing a distributed system you
don't want to think about you know how
to do all this he just it's nice to have
a standard so you can just build
focus on your business logic instead and
you can visualization using open source
tools such as Zipkin and Jaeger
so that is base that is an example of
service execution flow visualized in
Zipkin so you get the nice stack
visualize then you can see how much time
yes your whole your systems are spending
in each leg and actually there are and
this is basically a competing
visualization tool which were released
called Jaeger which does pretty much
similar it's quite similar to Zipkin but
what it also has is it has mechanisms
for back pressure so that if your
systems are generating a lot of tracing
traffic it can basically push back and
say can you back off a bit I can't deal
with all this configuration management
again on the face of it fairly simple to
do but then you start doing it at for a
lot of systems you run into a lot of
problems so again this is another CNC or
is it called etcd which is a distributed
key-value store it's useful as a
centralized configuration store it has
the ability to push messages out to
subscribers when configuration has
changed and what they basically also say
is I haven't used it for this but you
can use it to implement distributed
coordination but so I mean configuration
is something we've all we all deal with
in different ways and and every language
you use specifies a different way of how
you can specify yoga how you can specify
your
raishin I've pretty much used every
different way of doing it and eventually
I've come to the conclusion that
actually centralizing your configuration
and let systems pull their configuration
from centralized store is a better way
of managing it than having it in
configuration files like for example in
airline you can put your configuration
in sis config files but then you have
the problem of right I have a difference
is config for for all my various
environments I've got different
configuration file for each node type I
have and just getting a sense of well is
the configuration right across a cluster
of systems it's kind of hard to do
whereas if you could centralize it
within a data store like that which
which has the ability to which which
gives you high availability so that you
can actually deploy CDA as a cluster and
make sure your configuration is highly
available and when there's a change it
can push messages out to the connected
clients I think it's it's quite useful
and databases obviously the the heart of
most systems so in terms of power sequel
databases you've got lots of choices but
having in Postgres every five is
building a betting sector I'd probably
start using Postgres 4 if I needed a
sequel database I mean I was obviously
it's got high performance and large
installed base active dela breathing
races because there's 10 news release
license-free and you can easily find
people who can help you with it as well
the next thing is react how many people
have worked with react right it's a well
it's it's it's a distributed North
sequel database what it really gives you
is various control leavers so that you
can trade-off consistency for
availability depending on your use case
so the the classic example it's based on
the Amazon dynamo paper which came out a
long time ago the classic example is
well if you've got a if you're dealing
with a shopping cart then actually you
want high availability and you don't
really bother worry so much about
consistency because before a customer
pays they're always going to check and
if you've added us product twice or if
you put back a product in which they've
removed previously they probably won't
be too upset about it because they're
gonna check anything and remove it again
whereas at the point of placing an order
and you're committing to it you want to
make sure that you've actually recorded
it and you don't lose that data and what
we react basically gives you is that
those control levers that you can say I
want this request to be consistent so
that all the replicas answer or you can
say as long as somebody's got a copy of
this I'm fine with it it's got built-in
CR DG support basically C oddities are
data types which which help you resolve
inconsistencies automatically even if
you've got multiple multiple clients
modifying the same data it it gives you
the ability to
resolve inconsistencies for you
inconsistent which typically arise from
net splits in your database I mean it is
by a certain set of rules so as long as
you mortally a data so that it can it
can be designed using key oddities then
actually a lot of it comes to you for
free it's based on Amazon dynamo paper
and probably you've heard recently that
bash Oh as a company when went bust but
I think luckily for the rest of us
better e65 bought out the IP for the
source and react and they're open
sourcing well they said they will open
source the parts which are not which are
only available to enterprise users
probably you are you know more about the
plans to open source I think there was a
talk a few weeks ago
to get that guidance
yeah sorry
so yeah as a as this summary I think
from a betting point of view that is how
I would classify a choice of technology
for implementing various spots via
betting stack so as you can see our long
lx0 there's a lot of real-time stuff
which needs to scale and be stable
golang I think I would use it for data
transformation tools and operational
utilities purely because of its speed of
execution and the ease of deploying them
a bedding stack needs a lot of actually
UI applications for traders to manage
your operation actually you could do
them as web applications but I think
it's a it's a lot easier probably to
just build applications
UI applications on Windows and you don't
have to worry about browser
compatibility and then this PostgreSQL
for storing all your customer
subscription data and again I mean I
think with a sequel and a sequel
database you could you could put both
you could implement it in both ways but
I think the challenge the set of
challenges are different which it comes
down to its comes down to how
comfortable you are with using either
one of them and sometimes I think the
expertise you have in-house Trump's what
some of the technology can provide even
though it's slightly better the the cost
of adopting a new technology further and
for an organization is quite high and
yeah
yeah I mean so I mean you can always
shard your database across so that you
are you do rolling upgrades or so that
your customer base in I mean my point
there is actually react is great in some
ways it gives you some capabilities but
it's not for free it's not easy to use
it because you still have to what it's
doing is basically moving all the
complexity up to the application level
so you actually have to think about all
those things and at least having seen in
the news and batteries were successfully
they've used it successfully but it's
not by any means easy both from design
and development point of view and in
operation I mean react both from a
design and development perspective and
also an operational perspective it
doesn't come for free there is a lot of
complexity involved in it so if as an
organization you you you don't have the
time to build up that capability and
you're more comfortable with the sequel
database
there are ways you can manage your
operation
yeah it's just a different set of
yeah I mean from my point of view you
you can do it in either one of them
it's just ultimately I I think the
choice of Technology isn't just about is
it the best thing from an idealistic
programmer point of view but it's more
what what are the cost for me as an
organization to actually adopt this and
sometimes if you pick something up like
react and but your entire development
team knows nothing about either lying or
the cap theorem or eventual consistency
then by the time you get to grips with
it and what product you you probably
we're behind the market so you're better
off sticking to something like that it's
yeah I I I deliberately stayed away from
it because I just thought actually at
least in my point ago I think it's one
of those things where I didn't know it's
probably heretical these days to say you
can live without it it's almost become
in some places and end in itself rather
than a means to an end I think yes sure
it's there and I can see the value of it
in terms of having you know so that you
don't have arguments about well it runs
OK in development and it runs in UAT why
is it not running in production and it
gets you over those challenges but I
think it it's probably not a necessary
condition I would say you can you can
live without it yeah yeah so but I
actually wanted to make one announcement
as part of this I talked about JRPG
earlier we hear PC has libraries for
about nine or ten different languages we
well we've we've open sourced an
application which provides G RPC both
client and server support in Erlang it's
been open source for about a month or so
now but I thought I'll announce it
officially yes
yeah I'm unbiased in that because I've
been I've been in there Lang for a long
time I prefer that Yesi my view is I
think our lungs a simpler language yeah
I mean like I said if you are if you are
if you're heavily involved with Ruby but
you want the the goodies of the bean VM
actually a luxurious and easier probably
adoption but for you but everything I
think is a simpler language whereas
elixir has got a lot of
yeah yeah and there's very little of the
language so you can learn the language
quickly but I think the the bigger
challenges you have in implementing a
disappeared system is actually getting
your head around the challenges of
dealing with concurrency so I think at
least in my view if the language is
simple enough then you can move on to
the hard parts of actually now dealing
with concurrency in a system because
that's never easy but it's a I think the
viewer here in the airline community is
and I might be wrong
it's just that elixir is adding more and
more features to the language and that's
not necessarily always a good thing so I
think almost every old-time airline
program where you speak to will say I'm
fine thanks that'll stick to our life
but I think alex is great and that it's
attracting a new audience airline was
always seen as a bit old and stuffy and
boring
yeah you're right I mean that so my
priorities there actually was
scalability and and stability and I've
heard from several places that actually
RabbitMQ suffers on the Lord and I can
sort of relate to that because I wish I
have I haven't encountered the stability
issues but I've heard from pretty
reliable quarters that are actually
under lowered RabbitMQ builds up message
queues yeah
I mean it might yeah and it well I mean
okay you know I I take your point data
no I take your point about Duke you but
I think at some point someone is gonna
replace the deleted election with
probably something like Kraft or you
know of them zookeepers there but I
don't think that is your main problem my
main problem is everything here is that
it uses mpg under the hood and from
previous life I know that amnesia hits
problems beyond the certain scale now
okay you can I mean I got bitten badly
by it
I was at one time I think I had the
claim to think that I was the biggest
energy a cluster I had I was running but
at that time nobody knew about whatsapp
so it's different story but beyond a
certain point it becomes quite unstable
in this admittedly I should have done
more edge load control but it blew up
spectacularly in our faces quite a few
times and my my yes yeah I mean I
I currently comes out for a company
which uses rabid tonight either but I
haven't seen lowered figures and how it
yeah
yeah exactly and this this talk is from
the perspective of betting stack and for
betting stack I think really the use
cases are more simple it's just I've got
a stream of data and I want to consume
it as fast as I can
yeah yeah yeah
yeah yeah yeah yeah I mean and like I
said I I personally haven't encountered
the stability issues in RabbitMQ but I'm
putting two and two together in terms of
I've heard from very reliable sources
who are personally going to experience
the pain of unstable rabbit clusters and
my own experience with amnesia in terms
of instability and the Lord so like I
said this is an ideal wedding stock from
my point of view and I think if I needed
a middleware component for a bedding
stack I would put Kafka there yeah three
one three yeah
see I
yeah yeah the closest thing you have to
that is a stream processor so basically
you you can zoom from a topic you
transform it and you stick it back in
you know the topic so it's it's it's
it's not the same thing but that's the
closest Kafka has no I seriously I'm not
trying to yes yeah yeah I mean II it's
not I'm not saying Kafka is better than
RabbitMQ in every day in every way it's
just that knowing the the kind of
traffic flows in betting I would I think
use Kafka over RabbitMQ I mean it it
very much depends on how fast you are
able to consume it and because you have
the ability to have multiple consumers
for the same topic the the the latency
very much depends on how fast are you
able to consume it so I mean people
typically report they can consume
millions of messages a second but we're
not operating Kafka at that scale so but
that's never been our bottleneck
Sarris when I say vib battery six-five
was evaluating Kafka for they use but
not not in traffic handling but more
traffic analysis which is which is sort
of out was a critical path but we are
using Kafka in our own product okay I
mean I I've only worked with odds
betting I haven't worked with spread
betting so I can't really comment on
that but for odds betting yeah yeah
yeah
I think yeah I mean for for
communication between Erlang systems I
would just use native Erlang
I wouldn't use native RPC but I would
use fairly simple TCP socket based term
to binary binary to term I mean that's
that works actually for for unary our
pcs we found that a a very simple RPC
application we wrote ourselves performs
much better than G RPC because you don't
have the whole HTTP overhead and it's
much simpler but so within that between
our line systems I can't really see the
value of using VR PC but the thing is
it's it's nowadays it's a very
heterogeneous environment you find
yourself in and if you insist on
sticking to everyone in terms of binary
stuff integration becomes harder though
it's more of Shammai yeah simple terms
of binary over or socket is we always
move way more efficient than the HTTP to
encoding of data
first day
you give it on a case of us
okay
yeah
so specifically in what context are we
talking about RabbitMQ was recovery yeah
so I mean this is in the context of
betting yeah how much of it is
transactional well your bed placement is
transactional you're the distribution of
odds updates is
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>