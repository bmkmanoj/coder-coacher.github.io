<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Depending on Types - Stephanie Weirich | Coder Coacher - Coaching Coders</title><meta content="Depending on Types - Stephanie Weirich - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Depending on Types - Stephanie Weirich</b></h2><h5 class="post__date">2015-11-20</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/n-b1PYbRUOY" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">thank you yeah so I'm going to be
talking about kind of types and usually
people who talk about kind of types they
talk about languages like AG de or
or Idris and pac-man so just before I
get started how many people have used
one of those three languages before good
yay but if you haven't don't worry I'm
going to talk today about my favorite
dependently typed language which of
course is Haskell right is it right and
you might be wondering you know Haskell
really dependently typed language yeah
especially if you programmed in clock
and acta you know you might worry can I
write the programs that are write an ad
can I write those program those same
programs in Haskell right now i'm going
to say anyone yes with qualifications
right and so the purpose of my talk
today is to talk about this little
asterisk here and it also talked about
the yes right what kind of dependently
type programs can we write in Haskell
how do you do that how do they compare
to similar programs that you might write
a nag that right and I'm going to do
this all through through some running
examples right so I'm going to talk
about what Haskell looks like today
asterisks included I'm going to compare
that to what else is out there because
we're drawing on a lot of great ideas
from dependent type theory and a lot of
great languages like AG de Kock and
Idris and then at the very end I want to
talk a little bit about about how we
could do better how we could make that
asterisk a little bit smaller ok and so
we can't do everything but we can we can
do some impressive thing so hopefully I
can impress you ok so our running
example is going to be an example of a
data structure with an invariant all
right so here's a data structure within
invariance of red black tree maybe you
remember it from a data structures class
maybe maybe you hated it in your data
structures class I love it right cuz
right so it's the invariants are
guaranteeing that this is a balanced
tree that it doesn't get too far out of
balance that when you look up in the
tree it's fast and it does this with
just just some pretty simple invariance
right so we have a bunch of colors right
so here's our tree we have some nodes in
the middle of the tree they have colors
we have some leaves the leaves are all
black the node at the very top is black
going down if you start at the top and
you go down to the leaves you're going
to go through the same number of black
nodes on every time and when you have
red nodes you can have red nodes but
they have to have black children right
and so those are very insecure they're
just going to make sure things can get a
little bit unbalanced but they can't get
really far unbalanced you can't have
more than twice as long in in
a direction right so these are so these
are very instant and these immigrants
are all about the running time of this
treats we're going to use this tree to
like maybe implement some kind of set
but the correctness of our set
implementation doesn't depend on this
invariance only the running time so
testin is going to be kind of hard to
verify it unless we're actually testing
specifically things about colors and and
black height the other thing I want to
point out is that I'm going to show you
a bunch of code in this talk all of this
code you can just check out on my github
repository as well as some other related
code okay so let me i'm going to start
way at the beginning so this code is
going to start from a functional pearl
written by Chris Okazaki about how to
insert in red black trees right and so
here we're just going to define right so
we're going to define some red black
trees oh this is so dim so we have our
two colors red and black here's our
definition of a tree who either have
leaves they're empty so i'm using e we
have nodes that's the t data constructor
which has a mark for its color we have a
left tree we have some data i'm just
going to use some type a if the data is
kind of unimportant today right so we
have a love tree the data and a right
tree right and here is insertion of a
new data value into this tree that we're
using it as a binary tree to represent a
set this is the insertion just without
with ignoring the colors right so this
doesn't preserve the invariance right so
we're going to insert into the tree and
if it's an infantry we're just going to
make a new node to contain that new data
value and that new note is going to be
read write and if it's not an empty tree
if we have a node we're going to look to
see whether we should insert on the Left
insert on the right where maybe that
value is already in the tree so we don't
have to do anything now this code here
for
eight it could violate the invariance
great because it doesn't do any
rebalancing or anything how could it
violate the invariance right well we
could end up making a tree that has read
at the top okay we start with an empty
thing and added one value to it we get a
red tree so that's one way we could
violate the invariance or maybe we're
going to insert somewhere in the middle
it free we might have a non-empty tree
and we might end up putting a red node
next to a red node so we have two ways
to fix those invariants right so one
thing we're going to do is blackened
right so blacken just takes a node that
we have and mix it black and so we use
black and right up here so after we do
this insertion we're just going to my
fiat make sure that that top is black
right so that handles the one way are
invariant but could be violated the
other way is here when we actually do an
insertion into the left or the right if
we find that we're making to internal
read notes together we're going to do
some rebalancing to move them around and
so let me just show you how rebalancing
looks in a picture right so there's
actually four ways that we could violate
but where we could have to internal red
nodes right so we're only doing one
insertion right so these these great
triangles they're just arbitrarily well
form trees right so we're only doing one
in search and so there's only one
violation so it could either be on the
left side or on the right side and then
the one below could be on the left or
the right so there's four situations
that we need to worry about and we end
up just taking all four of those of
those trees and rewriting them into this
tree right changing the colors of some
notes but preserving the order of the
the four sub trees that are hanging off
they just stay in order we're also
preserving the black height the black
height doesn't change
right notice each of these four trees
has one black note at the top and this
one on the two branches it still has the
same black height and it pushes a red up
to the top okay so those two things
together right so just back up a bit
blackened imbalance that's all you need
to preserve this red black tree
invariant right if you start with a red
black tree and you insert into it and
you do these two things you get a new
red luxury right right oh here this is
the code for balance that corresponds to
this picture and it just SAT I put this
in because I wanted to show you just how
beautiful the pattern matching is for
the balance function right it's each of
these cases that's right they just
identify you know here we have they just
correspond exactly to the pictures right
a black node and then a red on the right
and then a red child of that and then we
put it back together in the right order
if it's not one of those four cases the
balance function just leaves the tree
illa okay so how do we know I just told
you right all right so do you believe me
right well how do you know your haskell
code is correct you type check it right
yeah you you're on quick check right by
the but the type checker has to like it
first right and and I like to be able to
use the type checker when I program to
give me more confidence that I'm writing
the right cover right and so what I want
to do is I want to redefine insertion
right so that I have a type that only is
a valid red black tree and rewrite
insert so that the result type has to
also only contain red black trees how am
I going to do that so that's our goal to
write is is capture those invariants
that I just showed you in
in a special type called red black tree
right and then if i can write insert to
have this type then I know I preserve
that invariant okay so let's look at how
agda does it first and then I'll show
you how we could use features of Haskell
to do something very similar so this is
some code that i got from dan Licata so
he was introducing agda at a place
called the oregon programming language
summer school you should all go if
you've not gone it's a crash course on
programming language theory and research
it's really fun this is he was trying to
he was introducing agda and how to do
dependently type programming in that
language and so let me just walk through
how his definition of what a red black
tree is right so you start off we have
we have these natural numbers color sets
just normal data types what you expect
just kind of like you would define them
in haskell right and all the action is
down here in the tree type right which
is it's not just a regular data type
it's an indexed type so this type has
two arguments and those two arguments
are what we're going to use to put
constraints on this data structure all
right so let's look at the let's look at
how those indices vary by the different
branches so we have we have three
branches now so we still have e that we
had before but now we've kind of split
up our nodes into red nodes and black
nodes because they're going to behave a
little bit differently with the types
right so if you see here right so II
leaves are always black right and so
that's why we're going to index the tree
type with be right to say the type is
going to tell us exactly that we have a
black tree and the same is true for TB
that also creates a black tree and then
TR that creates a red tree and so we can
use that to enforce our color invariant
so we have this invariant that red trees
have black children so if you look at
the two arguments to a red tree you see
they have they have to have black
children
right so the the type has to be be here
if it's Anna are here it's not going to
type check right so we also have some
dependent types right so here when you
have a black tree that can have any
color of children right red or black and
so the constructor for for black nodes
it generalizes over the colors of the
two trees right so the type of this sub
tree and the type of that sub tree that
depends on what the colors of those
trees are right so c1 and c2 and then
these in arguments that's the height of
the tree the black height we're also
tracking that as well so the MP trees
have a black height of 0 red trees
whatever the black height of the left
and the right is and they have to be the
same whatever that height is the height
of a red tree and a black tree also has
to have the same black height for left
and right but the black height is one
more for the tree that you get from
running this constructor right so the
dependent types right they're capturing
all of these invariants that we just
talked about the to guarantee that this
must be a red black tree right because
we have an express this dependency right
now I will point out that you know you
notice some of these arguments are in
curly braces right Hector doesn't
distinguish between types and terms what
curly braces means to agda is that the
compiler should try to figure out what
these arguments are the programmer
shouldn't have to type them in so just
like the Haskell type checker tries to
infer what the types are when you
instantiate a polymorphic function that
agda type checker is going to try to
infer anything that's written in curly
braces and then the let there's one more
variant that we didn't do so just for
completeness we also had to require that
the root of the tree be black and we
wanted to define just
this RBT type this red black tree type
that only contains valid red black trees
and that's what this light is doing
right so our RBT type right is just it's
just a tree that is black right and in
this type we're also kind of hiding what
it's black height is we don't want that
to leak out in our definition of what
the red black tree type doesn't really
matter what the black height is as long
as the invariance of valid it are
preserved in the internal data structure
okay so that's it right so this is how
you how you represent this type in
handgun how do we do it in half so here
back so that's the same thing before
let's look at the half full version and
it's pretty similar so here in haskell
I'm using two features and Haskell to be
able to just kind of almost just
transliterate the agate code into
Haskell so I'm using something called a
generalized algebraic data type I get it
right so this allows Haskell data types
to to be indexed to take arguments that
vary based on what the constructors are
so we can do the same thing at Haskell
the other thing we're doing is something
that's called data type promotion this
allows you to take regular data types
like color and natural numbers and use
them in types right so that's why it's
legal to be able to say be here I be as
a data constructor what's it doing at a
type but the data type promotion is
giving the type language more data to
talk about more things to work with it's
just a more expressive type language we
can't put arbitrary programs in our
types we don't have programs in our
types but we do at least have some data
types in our types and we can kind of
think like think of of color acting like
a data kind here so that coffee is over
just just nicely right and so let's see
what it looks like if we try to try to
use this in GHC just to verify that we
are capturing these invariants so here
I'm creating this little tree here
there's a red node at the top two in
peace
at the bottom right so i can create it
an sdhc well what's its type right and
JT will infer the type it'll tell me
that's the type of a red tree with black
id0 right there's no internal black note
only black leaves alright so i could try
to make a bigger one so i could take
that a little bit here stick it
underneath and put a black coat note on
top of it and ask for that type and GHC
will tell me well that's a black tree of
height one success or zero now i can try
to be sneaky and make a tree with a red
node with a red child now this is a tree
that is violating a property all right
and so i could type that in and I of
course get a type error right that's
actually a pretty informative type yard
and says I can't match red with black
right I in the first argument of the red
tree constructor I expected a black tree
but you gave me a red tree so our type
checker is actually catching when these
vile it when these invariants are
violated all right and then the
continuing the story on the top level
right just like we can define this RBT
type we can do exactly the same thing
here all right just where we can hide
the the height of the tree and constrain
that color at the top at the root to be
black so how are they different right so
we've established these data structures
are we really doing the same thing right
so so yes no right so there are some
subtle differences going on with them
because agda and haskell think of types
in different ways all right so an active
doesn't really make types special types
are just like other things they just
happen to be bits of your program that
appear to the right of the colon and
haskell types are really special right
they they're always inferred right we're
based on him Lee Miller type inference
which can infer all types right whenever
we use something that takes
argument type inference figures it out
for us right we have this restriction
right this separation the weekend we
don't have arbitrary programs in our
types so the only thing that we can use
to index these data structures are
things that are in the type language
that's why we had to have that data type
promotion to add new things for our type
language so we could make some
interesting indices right and then the
other thing is since we have this
separation between types in terms we can
erase them it's easy for the Haskell
compiler to just erase all of the types
and that makes our compilation efficient
it also gives us parametric V properties
all right what does that show up in
terms of this particular example right
well I mentioned already that since we
have to we have to use data type
promotion to make this code work right
we have to have something from the type
language even though i'm writing b + 0
here this is not the same b + 0 that
appear in in program expressions this is
something similar to it looks just like
it but an analogous thing at the type
level the other things a little more
subtle since types are erased there's
one thing that the agda definition of
this top-level type can do that we can't
do right so here if you will take the
active definition right in both cases
we're kind of hiding what the black
height of the tree is right it doesn't
appear in the RBT type you can't look at
it but in Agra you can get it at runtime
you can write a function that says give
me the black height of this tree going
to take a red black tree and give you a
natural number and so we just pattern
matches it finds that natural number and
returns it but in in Haskell that
natural number it's a type right and you
can't return a tight as a result of a
function because it's going to get
erased there's nothing there to return
so is this good or bad
in this case maybe we don't care but if
we do want to have access to the runtime
value we're going to have to do
something different and I'll get back to
what we have to do later on in this
there's a way to work around it but
directly we don't have that direct
access anymore ok so that was creating
the data structure now what about
working with it how do we work with that
data structuring you might be a little
bit worried because you saw this balance
function right and we just made a type
that requires that the tree satisfy all
the red black tree invariance then i
showed you the valance function and the
whole point of the balance function is
to take a tree like this as an argument
right and what's its type it's not a red
black tree right look what two Reds in a
row you saw it doesn't type check so
what are we going to do right and so
that's really that's really the
challenge here of working with the
Pettitte types is you have to be very
precise about where your vibe erience
are allowed to be violated and where
they're not all right so what I'm going
to work on in the next couple slides is
how we can create some types for the
balance function and I'm going to
specialize the balance function a little
bit to make our job a little bit easier
because if you look at this type this is
a pretty big structure right where is it
violating its kind of our doubt all
right so what I want to do right so
think about how the balance function
works right this is how it works right
we're going to take those four trees and
turn it into that tree but it's actually
it's cold in two different places in the
insertion code right it's called when
you insert on the left right and it's
called when you insert on the right so
you can kind of think of this as really
two functions right one where the
possible violation could occur on the
left side of the tree and one where the
possible violation could occur on the
right side of the tree and so I'm going
to define I'm going to separate those
two functions into balance left and
balance right this is actually more
efficient
because since we know the violations on
the left side of the tree we don't even
have to look for violations over here we
know they can't occur right and in
likewise for this so if you if you read
crew soca sakis book about purely
functional data structures he actually
suggests this the splitting as an
optimization to make the red black tree
implementation run faster okay so we're
going to split it into two cases and
once we have split it we can do one more
thing right which is we can kind of so
here so here like if you look at this
argument right we're taking an entire
tree as as an argument but we really
care about the individual part so I'm
going to specialize it again and create
a balanced function that works on the
left when its argument is a black tree
when it's one of these TVs right and so
that one balanced lb it then just takes
the three components and what is that
doing that's focusing us down even more
so now this is the argument that we're
worried about how to type check right
and that's a much smaller thing that's
that's that's going to be easier for us
to describe what it's type is right so
just to recap right so we started with
balance we specialized it to just
thinking about it when the thing on the
left was was unbalanced and then we
specialize again for when the note at
the top was black right we're still
always going to be producing the same
result right and that's what we need to
think about for its typing right what is
the type of this balance lv function
right so here's the three cases that
this function has to have right so we
have a tree that looks like this so
there's two red nodes in a row all
everything else is good and we want to
put it together like that or maybe the
violation is on the other side or maybe
there's no violation at all maybe
everything is fine and we just want to
put it back together okay so what is the
type of the argument and
what are we going to get back out that's
that's really tricky it's actually two
separate questions so let's think about
that result type a little bit what are
we going to get out of it results right
what type is the same so all three of
these they're well formed by their will
form red black trees right they don't
have any violations anymore but we don't
know what color they are right because
sometimes we're going to get back a red
tree and sometimes we're going to get a
black tree and so what we need right
what we need we're going to need a type
of trees we know it's not going to be an
empty tree because we just inserted into
it right but we don't know what color is
going to be so i'm going to call this
type a hidden tree there's a type that
doesn't tell us what the color is but is
otherwise a well-formed red black tree
okay so we have to define that type and
then now on this side this argument
great what about this this is a little
bit different right again it's a
non-empty tree but it can break the
color variants at the root so this one
I'm going to call it almost tree it's
almost a red black tree because it has
exactly at most one violation right
either it's a red red a red red or it's
fine all right so I'm going to need
these if only these two types in order
to finish this function okay so let's
look at hidden tree right so in Agra
that definition looks like this so we
have two ways that we could have these
trees a red one or a black one right all
we've done really is we've not included
that color as an index to this type
right before our BTW had color told you
the type told you the color of the tree
this one does not it's also non empty
right and we know it's not empty we're
just holding we're just holding regular
trees and hiding the colors but we know
it's not empty because the black in the
case that we have a black tree the
height has to be at least one right so
that's going to enforce that we have a
tea tree as well all right so we either
have a red tree or we have a black tree
so that's pretty straightforward right
what about almost tree right now this
was more important right the input or a
function with a tree that breaks out in
various right well there I'm going to do
this would write it this way although
street it also is not going to tell us
what its color is right but it's going
to be a tree that has some color right
with some left and some right and we're
not going to have any sort of
constraints on what the color of the
left and color of the right bar right so
if this if the tree is a red tree right
this could be black this could be read
this could be lack this could be read
this is actually a little bit looser
than what we need because this will
allow that tree with the red on top and
to read notes but that's fine it's
enough it'll also allow one red node
here and a red node there otherwise the
black heights have to be the same and
here what we're doing here to keep track
of the black height in this one so here
I don't have two different constructors
for red and black I only have one
constructor and the reason I did it that
way is to show you this cool thing right
so here we can actually calculate what
the black height is based on what the
color of this note is and we do that by
writing a little function that says if
it's black you increment if it's red you
don't so okay where are we where we're
trying to write the type of this balance
function we needed some new types to
help us out that allow us to relax the
invariance a little bit can we break
these types also in haskell right so
it's pretty straightforward so hidden
tree you can actually just almost
directly copy that over to high school
with what I've shown you already but
what about this type is it look at this
function here how we going to do that in
high school
right I guess I'll show you that in a
minute let me show you actually that
this is exactly what we need in the AG
de code so here's our agda definition
for balancing that tree so again this is
kind of what it's going to look like
we're going to take a tree that looks
like this we know that the thing on top
we were we were in the case where
there's a black here and this on the
left and a regular tree on the right and
we're going to turn it into this tree
just like balance did before right so
all we need to do so we need to look for
those two cases where we have read read
together and rebalance them and if we're
not in those cases we know we have a
balanced tree now before in oak osakis
version we just kind of had this
catch-all thing for balance that just
said any other tree is good but in Ag de
we have to prove that any other tree is
good and so we the way we do that is we
actually have to to consider all of the
remaining cases and show how you can put
them back together and still get a good
tree again right it doesn't take our
award for it that we didn't miss any
cases we have to show that the remaining
cases still we didn't have to do any
reshuffling any rebalancing so it's
helping us with our proof right and so
we so we can do that okay here's the
haskell version of the same data types
right so again that hidden tree is not
really much of a problem but what about
almost tree right now there were two
things that were going on in the agda
definition of alma street one of those
is we had that function to calculate the
black height based on the color right
that was a real dependent type going on
there right and so what we're going to
do here in haskell we're going to use a
feature called a type family so type
family is a hassle way of writing a
function at the type level so we're not
only than just a regular high school
function but we still have functions
available to us right and so it's high
family just says there's something
called inker it takes a
color and a natural number gives us a
new natural number so if we increment
red we get it leaves a number alone to
increment black we get successor same
thing alright so we have to use a tight
family the other thing is we have to
deal with that issue of a racer right we
need to know we need to know what that
color is because we're actually if you
go back and look at this code here we're
pattern matching all oak or pattern
matching on the color of the node in the
red tree to look for those violations
right so we need to have that around it
wrong time it better not be erased all
right and so we can't just if we don't
have this argument this is the argument
that's going to allow us to do that
pattern match right we can talk about
the relationship between the color but
we need to have that color it's some
sort of run time representation and so
the technique we're going to use for
that is called a singleton type right
and it's a way of it's a way of using a
gatot to make a connection between type
level data and runtime data so let's
just take a look at the singleton type a
little bit so the singleton type it's
indexed by a color and his two
constructors SR and SB but srs type says
it's the color red and s beef type says
it's the color black right so whenever
we want to represent red who use SR and
we pattern match on SR we know the color
is red right because that tight
connection there right it's called a
singleton because if you think about the
type singh are we know exactly what it
should be right we know it must be s are
you know what that data constructor is
the same is true for seeing be it must
be s be right and so that's what's going
to give us that real dependency right so
this is this is how you write a pie and
Haskell is you use a singleton type to
connect the type in turn mileage
together right I'm going to give a plug
for the singletons library that my
student Richard Eisenberg has developed
to help make working with Singleton's
more convenience ok so here is the AG de
code for rebalancing that we just saw
I'm going to turn it into the Haskell
code I'll do it again right we just
added a few simple tips and that's it
right because we had captured the same
it's the same argument that we had
before right so we can do it right right
and so it kind of in lockstep right
we're taking this I to code and
rewriting it just like in a school so
are they the same and we've done the
same thing have we proven the same thing
about red black trees well the types
look the same we've got two colons in 1
colon but they look the same but they
don't mean the same thing so if you
really think about what these types mean
right and an Ag de the type means if I'm
given a red black tree and an element
after the result of insertion i will
give you back a valid red luxury what is
the Haskell me if I'm given a valid read
poetry in an element if I give you back
something it will be a valid red black
tree you know that's the difference
there right had does add to the language
where everything has to be proven total
right all functions like insert you have
to prove that they're going to give you
something back so we actually know more
about insert in the active version than
we knew in the Haskell version so we're
not we don't have everything right but
we we have a slightly weaker result but
we do know if we do get anything back
right and maybe we can run some tests
here we know we get something back it's
going to be valid and and that's that's
a pretty big difference right now we can
talk a little bit about totality
one thing about it and ag2 though is its
inescapable you have to do it always
right and you don't really always want
to prove everything total even when
you're doing proofs you may not want to
prove everything total and let me just
kind of them let me just show you what I
mean by that sometimes not doing a proof
is simpler than doing a proof right so
what does that mean here not proving
things simple not proving totality is
simpler than proving to italie so we
started with o Kesava DS version of
insertion into red black trees that was
12 beautiful lines of code right and
then we translated so we had an Ag
diversion we took the AG diversion
translated into haskell right that was
49 lines of code all right four times
bigger and what were those lines of code
well we had to define some new types we
had to give some signatures we had to we
had one day to constructor for trees we
had to break that into 24 red nodes and
black nodes and we had to have some
helper functions and we had some really
precise types about what's going on when
we we did this balancing right we knew
it exactly what was going on because we
wrote down what almost treatment and
what hidden treatment and if you start
from scratch and you said ok I'm just
going to write some Haskell code to
verify the red black tree properties of
insertion you can actually do that with
fewer lines of code right and you could
be less precise right so here's I have
in the git repo you could check it out I
wrote it in 32 you probably get it
shorter than that write it it's shorter
because we kind of skipped this hidden
tree type we would make things a little
bit less precise right we can combine
some of I did this distinction between
right here i specialized balance to win
the note at the top was black and when
it was red because I had to they had
different types but if I kind of
be a little less precise I can merge
those two functions together and just
have a single function with singleton
arguments to tell you me which one it is
but just a less precise type now I can't
do this in Ag de because i need that
precision for the totality argument but
if i'm not proving totality i can get
away with it all right so yes it's
really great we should prove our
programs total but I don't want to be
forced to every single time I want to
i'm going to have that choice i want to
be able to prove as much about my
program as I care oh sorry good you
can't see the Microsoft auto update from
here okay what's next alright so the all
of this stuff works in GHC today right
and but there was that asteroid I told
you you can't do everything I showed you
when it works out well right but there
are some there's some Magda code you
just cannot do right and there's many
reasons why you can't do it one of the
reasons why you can't do it is that you
can you can't promote gadgets you can
only promote things that are not indexed
normal data types and to be able to
promote things that our index what that
amounts to is turning the type language
like a dependently typed language and so
this is something and I have been
working on for a little bit of time now
so my students and I have kind of worked
out in the core theory how we can lift
this restriction so that we can promote
everything it turns out Haskell has this
thing called kinds which talk about that
which are the type of types it's very
convenient if we do this to just merge
types and kinds together so it kind of
simplifies things in a way at the same
time and then my student Richard
Eisenberg he has been implementing this
and he's made fantastic project progress
he has it available as a branch to GHC
on github and he is as we speak merging
it back into head so that it could get
released in the next
release 4ghz so so that's going to be
awesome right so that we're going to be
able to do much much more example so
like the one I showed you another thing
is that we should have a real pie type
in ghd this is this is kind of up next
on the queue how do we do that in
Haskell because remember Haskell makes
this strict separation and we have this
work around the singleton library but
once you start making extensive use of
Singleton's it gets kind of painful what
I showed you now was fine and it worked
but if you did a lot of it you would not
be happy right and so to have a pie type
we kind of know how to do it gundry last
year worked out how you can kind of
think about just taking out parts of the
type language and parts of the term
language that are the same and
introducing a new quantifier 22 range
over those and so Richard is going to
tackle that as soon as he finishes this
merge right I don't know how long it
takes but he plans to graduate very soon
so you've got incentive ok another thing
people ask me is why why did this in the
first place why not just use agda right
and but also my joke is because i like
TDD right type driven development and i
want to do it in in haskell right right
and if you see things like so here was a
poster count on that agda mailing list
right so this is the somebody's
perspective of programming red black
trees and agnes so this is not the
implementation that I just showed you is
another one somebody else did it too and
I really focus in on the bottom right
you know it's like he's never
implemented red black trees before not
even and what I didn't show you was
deletion deletion is much much more
difficult than for red black trees and
what then insertion right and it would
not fit in a 45 minute talk um he so
he'd never done it before but he just
has expressed his emberiza nagda and let
it go and it told him how to write the
code
right he you know you can look up the
invariance for red black trees and a
text books in it and it told you what to
do right so this is the experience I
want to bring into Haskell as well I
think the high school would benefit
right and so but I'll standing up so i
will go a little bit quickly what am I
going to work on next right so I'm
missing a little bit about totality
checking it's really all or nothing now
right you either do it everywhere in
agda or you do it nowhere in Haskell I
would like to have some kind of totality
checking somewhere so I can have a
choice about the matter there are places
where Haskell's Henley Milner type
system gets in the way I've been looking
at a lot of extensions of Henle Milner
over the years and I will continue to do
that right because they just make your
type system more programmable so that
you can express more domain-specific and
application-specific and variance in
your type system right and I would love
to see more work on ide support for type
driven development in particular writes
the language is like interest and addict
there there was there thinking about
these ideas and I want to see them in
Haskell too ok so that's my last slide
so I'm going to end with a bunch of
thanks to Co authors who have been
working on these type system extensions
with me for their for many years now I
had made a lot of this stuff possible
and I think it's really fun and I hope
everybody can do some dependently type
of programming and Haskell in the future
sure if we have time I will be briefed
by introducing these dependent types the
type signatures have gotten somewhat
more complicated are there any
performance implications in GHC to
actually like checking that what your
written is correct about performance of
the types of the type checker yes um so
once you can make the type checker as
slow as you want through your type
annotations right because once you can
start writing functions and you turn off
you turn on undecidable instances you
can write whatever program you want that
the type checker will happily try to run
so yes there are performance
implications but we're programmers so we
think about performance
oh now we don't have time okay well I'll
take it offline i'm happy to talk about
this</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>