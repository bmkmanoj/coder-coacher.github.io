<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Thinking like an Erlanger - Torben Hoffmann | Coder Coacher - Coaching Coders</title><meta content="Thinking like an Erlanger - Torben Hoffmann - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Thinking like an Erlanger - Torben Hoffmann</b></h2><h5 class="post__date">2015-01-30</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/6sBL1kHoMoo" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello and welcome to the erlang
solutions monthly webinar my name is
Marty militias I'm the VP for Emir
region here at erlang solutions today's
webinar represents a continuation of a
series of webinars we have been running
across topics of interest in the world
of Erlang and dealing with solutions
based on the Erlang programming language
specifically today we will try and tell
you a bit about how language Spink we
regularly hear from people starting with
Erlang and the most common comment that
we get is that Erlang is easy to pick up
however the issue often lies in changing
the way one thinks that indeed seems to
be the real challenge of taking on the
Erlang paradigm as you know Erlang is
based on a couple of core principles
such as share knocking processes fail
fast and failure handling now today's
webinar will specifically talk about how
to design systems with asynchronous
message passing between processes that
do not share any memory and to give you
an example we will be using a Conway's
Game of Life which poses a couple of
questions relevant to issues in
implementation that apply to all
asynchronous message passing solutions
to just tell you that as with any live
event we may obviously experience a
couple of technical issues so please
bear with us in the case that happens
but to start by telling you a bit about
allowing solutions we are a products and
services orientated company completely
devoted to the Erlang programming
language since we started in 1998 we
have worked with organizations and
individuals using airline we've been
helping to evolve the language and we
have been working with organisations
that are sort of furthering their line
cause today we have just over 100 people
sitting across our offices in London
Stockholm Krakow Budapest Seattle and
Buenos Aires and working on projects
across the world really we are very keen
on creating value and competitive
advantage for our customers across
industries and truly unique features and
characteristics of Erlang as a language
we are equally ambitious in developed
based products and some of those include
our Mongoose I am messaging platform the
react distributed database and wombat
OAM which is a monitoring and management
technology for Erlang systems as well as
many other solutions that we develop and
that that are applicable across sectors
and problem areas where Erlang obviously
makes sense now I'm particularly pleased
to say that our speaker today is Tobin
Hoffman the CTO of erlang solutions
Tobin has spent a number of years as a
self-confessed Erlang priest advocating
the use of Erlang across industries and
helping businesses and individuals
benefit from our language and Erlang
based technologies Tobin will give us a
first-hand account on what it really
means to think like an Erlanger and what
obstacles typically present themselves
on that journey now please allow me to
finish by saying you are very welcome to
pose questions throughout the duration
of the webinar by using the chat
facility on the webinars interface our
speaker Tobin will answer as many
questions as time allows at the end of
the webinar if any questions do go
unanswered you're welcome to raise them
via email using the following address
webinar at our line - solutions comm I
will now gladly hand over to Tobin
Hoffmann who will be glad to start us
off with the webinar Thank You Martin
and one of the things that not mentioned
before that it's difficult to pick up
how to think like an arena and and one
of the reasons is if you take a map of
existing programming languages and you
look at how they relate to one another
most of these maps never show Erlang
it's an outlier it's an alien that came
down from space and it was given to
earth by another agent Joe Armstrong who
did wonderful things to put in India
ingenuity into the language so so if you
come here and you you want to learn -
how to think like an Arab
so you probably want to see the airline
code I will have to warn you here you
can't you can't handle the airline code
this is not about code as such because
syntax is irrelevant anybody that would
come along and say that syntax has
anything to do with thinking they need
to have their heads examined and you
probably also want to avoid working with
thinking on the other hand is everything
if you do not know how to think with the
tools you're using then the tools will
not become a natural extension of
yourself and you'll end up doing
horrible things like for instance
writing fight Python like code in Erlang
don't do it it's horrible
embrace hurling instead so let's go into
this so there's something here about
Erlang and where it comes from and how
things are fitting so Erlang originally
comes from Telecom and that is a vast
area of fun stuff if you take a
general-purpose language like C++ or
Java just to take some of our favorites
you'll you'll see that the amount of
code you need to do to feel out the
needs of telecom is quite large but on
the other hand you design a language to
be fit for telecom like Ellen you get a
much smaller gap and that gap is
actually important one of the things
that makes it important for you if
you're a developer is that you can sit
down every day and have fun because the
amount of code you need to put in place
to solve the ideas solve the problems in
the domain space you're looking at it's
going to be very small as long as the
domain fits the requirements or the
characteristic has of telecom
fortunately a lot of modern web so ever
domains fit those requirements so that's
why it's a good fit if you on the other
hand is is more into of making business
and everything then that's smaller gap
you have here actually equals money
because you can be a lot more productive
and deal with errors creeping up a lot
easier in Erlang because you have a less
code to worry about all of this then
comes back to what are the key points
earlier is made before so it's actually
about protocols Berlin's made for
telecom so it is very good for dealing
with protocols and I can recommend
both of these books here horse book is
something everybody should reach not
just because it's Tony Hall because it's
but more because it's a very elegant
book on how to think in terms of having
processes that does some sort of
communication with one another to get
things rolling which is basically what
you have in Erlang with all the
processes and the message passing if you
want to take it a step further and I had
to do that while I was studying you have
to buy this enormously expensive book
from Springer it comes in at one hundred
and twenty dollars just to make it a
little bit pricey but it's actually a
very very good book that talks about all
the things involved in designing
protocols and and one of my pet peeves
in in software engineering in general is
that all the stuff people have been
doing in telecoms to deal with protocols
and make them well described is
something that every software engineer
should have a look at because at the end
of the day it's not what you put inside
a module on an object or whatever it's
the interaction with other objects
modules and processes and what-have-you
that's important and that's where the
the bulk of your energy should go when
you're designing software systems on an
example or how you describe things so
you have the Paxos protocol for solving
things related to misses secure passing
a message to making sure everybody has
it it's used in in react the no sequel
database and there's a wealth of
protocols out there you can go on
Wikipedia and see how they work and the
beautiful thing is it is very easy to
implement and you know mine but the
thing is here that's important is that
you describe them by these things called
NASA's sequence charts where you show
the different entities involved and what
messages they're sending to one another
so now we come to this one that I'm
throwing around left right and center
when people ask me what is the important
core of Erlang
and this is the golden Trinity of Erlang
so this
what also not mentioned in the beginning
you have shown off even processes that
cannot share memory you can only
exchange things between the processes by
sending messages then you have failed
fast so this is the notion of if
something goes wrong don't try to be a
hero about it just die immediately
and in order to counter that approach
and actually make software that runs you
need to have failure handling and these
are the three pillars upon which Ernest
builds you will not find any other
languages that have this particular mix
of these features done in this elegant
way as Erlang has it so this is what
makes earnings so different this is why
it doesn't fit in over a chart of the
inheritance of programming languages
this is the ingenuity of Joe Armstrong
and the computer science lab at Ericsson
that is coming to its full glory so
first thing is processes you have to Lou
use a lot of them really really really a
lot of them because they're too cheap
the Erland vm is amazing you can spin up
hundreds of thousands of the more
millions of them and it will just with
next to no overhead in it it's not like
a big fat thread in an operating system
yeah and then apart from then using a
lot of them then you have to focus on
the interactions or protocols as I
mentioned before go so now we're going
to do something here that if this was
broadcast out of the US it would
probably say don't try this at home I'm
going to talk about the game of life and
how we could do that in Erlang so game
of life is a simple cellular automaton
where you have a number of cells
evolving over time depending on their
native neighbors and it happens in
discrete time so you have time ticking
at a regular interval and then things
are moving along according to that so
I'm just going to the bit about the the
rules of this automaton so we can
understand what it is we're talking so
here you can see with the cell marked
with a black cross it's one cell that
we're concerned
about it has a number of neighbors
marked with the fancy purple color
around it and the rules of the game is
that if you have two or three neighbors
you will survive if there's an empty
space and you have three neighbors it
will give birth to a new cell and all
all the cases here then the new the cell
then the next generation will be emptied
the field on the port will be empty so
so let's see yeah I've create a little
colony of the cells and let's see what
happens as time progresses so here time
is at the beginning and then we have one
time step and you can see how the cells
multiply die or stay alive and here we
can see there's another one here where
and the notice here and you probably if
you know the rules of the game you
probably already calculated that has
something weird going on there's these
worlds they wrap around at the top and
bottom and on the site left and right
hand side so it's like a round world
collapse collapsed into it here but what
I'm showing it in today for the sake of
the medium we're having it today yeah so
if you see it it progresses along here
and this
this one looks actually to be doing
really really well this initial
configuration here and we see two times
six and we go on and actually I wouldn't
take you through the end but I think
this as I recall it this one lasts for
nineteen generation before it dies out
there now doing this is something that a
lot of people have done in the computer
science education because it's such a
nice problem simple rules and everything
and the traditional way of doing this is
you do it with a 2d array and you can
have one array per time step going from
one time to another
you take your DeRay and then you look at
that and compute the values of the cells
in the new array which is the next time
step in the sequence now I will then
claim there are some issues with the
traditional approach and these are
issues that will come to light if you go
about and do is
in quite extreme it does not scale well
so if you run it on an enormous Liebig
grid with a large number of cells on it
it will not scale in and getting in
things to run fast as you have more
cores available because it's basically a
sequential solution you're having there
and then you have another thing is doing
an imperative data structure is quite
ugly in in Erlang it's really really
ugly to do the 2d array thing there
especially if you are getting into your
line for good and then no it's just not
nice yeah
and then I've controlled here that some
people just wait a minute
this is insane it's solving the game of
life with processes in Erlang it's never
going to work well I have measurements
that on my machine if you go to a 300 by
300 grid there meaning you have 90 mm
90,000 just 90 thousand processors or
cells in your game of life then the
process version is just as fast if not
faster than the 2d array one and then
you can imagine what happens as you
scale it up because the process one is
continuing to scale well while the other
one is just stuck in its ways so but we
can take that offline if you want to
discuss that with me anyway so the basic
learning idea is you probably can see by
now one process itself is that he's
stopping thing for a lot of people
coming in forming they do not feel that
throwing another process on the table is
a good idea it is try and think you can
you can always remove processes from
your architecture but throw one in and
and see if it works and makes things
easier then you let these processes talk
to the neighboring cells or the process
is representing the neighboring cell and
then you can quote the rules of the game
of life yeah so this means you have to
have a proto
call in place and here is that when you
want to update from one time step to
another you collect information from all
your neighbors you have eight neighbors
in the split they're there and you see
if that neighbor is filled or not and
then depending on how many neighbors
there are you can update the content of
your own cell and then progress to the
next time step now as I told you earlier
you have to use prosthesis a lot of it
so you the question here is is this
Erlang enough if Erlang is a word you
can use but I'm using it in fact I
started out by using this and I realized
you can actually make it more and more
Erlang in it so you can spawn a process
to collect information from all the
neighbors it has that nice benefit that
this little collector process has a wire
very confined job it has to do so it's
easy to write that code and then you can
leave it outside the normal cell thing
that does other things maintain the the
nature of the cell and then so we'll
just start the collector the collector
will ask all the neighbors and then will
send back to the cell when it has
connected from all eight neighbors how
many neighbors there were was around and
then the cell can update itself and go
to the next time step yeah and you've
been good listener so fast or I will
actually show you some Merlin code and I
hope you can handle it so here we have
to connect the loop that's the little
collector process that shortly before
that you can see at the top one that
there is that when you're out of we have
an empty list what you're waiting on
meaning you've received from all your
neighbors you just tell back to your
mother cell okay this is what you have
to change - because I've collected
information and this is where you have
to go this is your next content either
one or zero they're being filled or not
filled there and then in the meantime
you have this where you're still waiting
on some of your neighbors to get back to
you and give you an information about
the content of their their cell and then
you have this receive where you cysts
okay if it's one of the ones we're
waiting for
then we will update our neighbor account
with the content of the neighbor their
cell that just came back to us and then
we continue looping as I said until all
neighbors have come back to us
nice and easy piece of code there and
then you're looking at this and this is
okay there's a lot of different things
float around processes and everything
will this work actually it works under
certain conditions which is also the the
trick and this is where we will now
progress and you have to be aware that
from this point on in this talk we're
talking about going to be talking about
gaming lifestyle but the principles here
in in how you'd look at a synchronous
protocols and you try to figure out if
they're doing the right thing or not
it's the same principle
regardless of what problem you're
looking at game of life I've chosen it
because the rules are simple and it's a
fun one to work with but it'll
illustrate what you have to do in any
railing systems like a system where you
have protocols to deal with so it works
provided you only take one step at a
time so I have my huge collection of
processes representing the cells of a
game of life if I just say do one step
and then wait for all of them to finish
then it'll work and if you let the cells
run freely to say just go ahead evolve
over time and just run as fast as you
can then your cells would actually get
out of sync because the minute you've
received from all your neighbors you
will go to the next time step and then
you will not be able to talk the ones
that are left behind in history so that
means that you get requests for all time
what was the value of your this cell
back in the past and you also get
requests for future time because as soon
as the cell has progressed the t2 it'll
start asking people around it for what
what is your content at t2 and they will
still be stuck at t1 and they will have
no idea what they evolved into because
they still missing information from
their neighbors a
gee one in order to calculate what they
will become at t2 so this is ugly but
it's the same ugliness you'll find it
any asynchronous suit the assistant so
let's see if we can deal with it we can
fix it
so all time requests meaning somebody is
asking for things that happened in your
past you just keep it history so a cell
will just keep a history of what it it's
well use were at time 0 1 2 and so on so
that means you can if somebody asked for
you the song thing in your history
you'll just look up in the history and
given the the answer now slightly more
interesting is if somebody asks you what
is your value in the future since time
travel and wormholes have not hit the
Earle and run time system yet we have to
deal with this in a different way so we
have to queue the response to the the
guy asking you and this is something
that often happens in our lying there
that if you don't know the answer right
now but you know you will be able to
answer in just a little while
you just queue the response and the
other one will just wait for you to be
ready to answer now this will handle
these things let me come into something
else
what about failures because this is one
of the other things when we talk about
designing learning systems that systems
will go down even a system Britain in
Ireland will have failures and things
going wrong anybody who claims that they
are writing software that without
failures in a well they're probably not
writing any code at all so yeah that's
my stance on it so what do we do nothing
you supervise the sales so your line
supervisor this is the beauty of it so a
knowing supervisor will restart a prosit
with the original arguments used to
start the process and we can use that
because even though you can do that then
you are into issue that all state and
history is lost so you start from from
from 0 with the initial value and then
you just have to say how can I be part
of this world where if instance if
you've gone on to ten hundred then you
just left behind ever
party else there so the triggers the
fixes here is you monitor all the cells
in your game of life and then when they
die you pick them up again and then you
step them forward to current time so
they will just speed through the history
and get up to where everybody else is
right now and this can actually be shown
in a supervision diagram and this is how
the code I'm using here notation I've
been working on for a bit called visual
Merlin and it's on github actually but
and it's I've done some updates since
the last uploaded to get in but but I'll
get the other updates up shortly but
here you see you have a top process here
and it has its kicks off a Cell
supervisor which is monitoring and
supervising all the life's little cells
in our game of life and then we have
another trick here and this is the cell
manager the cell manager is one
responsible for making sure that the
cells would actually catch up with the
rest of the cells if they die and that's
because the cell supervisor does
remember it's a standard Erlang
supervisor the only thing you can do is
restart a cell in its original state so
the cell manager is also monitoring
these little cells and when they detect
them going down its it spawns of a
process called that I called Kaiser that
will pace the cell forward to current
time and let's see how that works here
so this is again an MSc and i do
recommend that all of you write down
MSC's when you're trying to design
anything Caroline Java whatever write
down MSC C's so here we have that a cell
is going down
it runs internatio and it terminates
then the cell manager is then we are
waiting for this cell to be restarted
and the restart will happen from the
cells supervisor that will just send a
Reese the restart message to herself but
basically is doing a start
link yeah and then as soon as the cell
has been restarted the cell man it will
start monitoring the cell and start a
pace a process that will make sure that
you can pace the process of the new cell
forward until what as I've called here
next time because then I have a global
clock process that actually allows you
to take a figure out the maximum time
any of the cells in your world has
progressed to and that is then the page
asks that gets it back and then tells
the cell please catch up and then you're
back where you were before so this is
something that you would actually run
into again in your live systems that you
have something restarting and then you
probably have some sort of lits
i need to calibrate with the world again
and i've depending on what calibration
means in your particular case you'd have
to write out these and as Emma sees and
make sure that things are happening but
it is doable and it's a lot more to opal
when you do it with Emma sees instead of
just hacking around slapping code into
an editor and hoping that you get it
right do the MSDS because it could be
tricky sometimes to figure out what goes
on in these errors in areas so you get
to see more code now
so here the cell manager as a total was
is monitoring the the cells so when it
receives a Down message because it's not
in Turing that it means that the process
has gone down and what you do then is
you you're keeping a list of cells you
are monitoring there and then you take
the reference related to this out of it
and then you say okay our rate for this
particular cell with its x and
y-coordinate being restarted in process
that does that then it goes on and the
monitors that process when once it has
been restarted and then you go on and
you just say now I'm monitoring a
different one on keeping that in my
state in the South state and then at the
end you're spawning a pacer function to
get the new process up to speed and then
you're just looping again
and yeah so we could taking it like that
that's it now at this point that's
actually didn't deadlock in the code and
that happens if you have a collective
process that has asked one of its
neighbor about a what is the content of
that cell and then that neighbor dies
before it responds
it gives gives a respond to you and that
is a problem because as you know and
online you don't get any messages unless
you've you've asked for them in this
case the collective doesn't have asked
the neighbor I'm very patient I'll just
wait the end of the world for him to
come back and in this case he will never
come back and that means you run into a
deadlock and this is something you have
to fix otherwise you're sleeping a
system that doesn't work so how do you
deal with that that means you need to go
into testing and this is another thing
that is actually necessary the minute
you stop step out of the nice confines
of a synchronous model you need to do
something to deal with a synchronicity
in your system and then the answer to
this is you have to use quick check and
then you build up a model in critic
operation by operation and it's all
based on looking at the emissive
sequence chart for the protocol they are
looking at so you have to be slightly
methodological about this and do it step
by step but then you get to something
that really tests the nature of the
protocol you have in hand so what do we
do here we also have to throw tricks at
it because it's you can't really test an
Asian front swing without doing some
mocking in EQC because the alternative
would be for a game of life that you do
a reference implementation and then you
run the reference implementation and
your process based one for a while and
then compare the results but that tells
you nothing about if the protocol
between the cells are in order and
that's actually the most important thing
if you're doing something that's not a
toy thing like game of life you need to
make sure that the protocol is working
because probably that's what you've been
paid for to put in the world
so and that with the mocking do you have
a little little problem is that you
can't call the module on the test in
mock those calls so in the fix here is
you had a protocol module which I'll
show you in a second and that's another
thing sometimes you need a little bit of
shrinking to make sure that things have
happened because it's quick check is
actually running everything on a
synchronous mode and it when it detects
if you've completed an action it will
immediately check that everything has
been done correctly and if you're not
waiting for your asynchronous system to
do the things you asked it to do then
quick check will say that you have a
failing system but you fix this by
adding some helper functions and I'll
also show how this is done for game of
life so here is the protocol module this
is a very very simple module the only
thing it does is an interaction of two
functions query content when you're
asking another cell for what's the
content of it that cell at a certain
time so that's just rhetoric of that one
and when you have to reply to a cell
that okay this is my value at this given
time then it's again you have the query
response and that's again a simple
interaction to the normal functions in
your cell
egle cell module and it's the same trick
you have to do when when you have things
that involve self calls you cannot mock
them on this to put them into a separate
module but if you do it like me and you
put the name protocol after it makes it
pretty obvious what is going on and they
are very simple these functions this is
one of the sacrifices we have to do in
order to be able to test this in the
same manner and I'm pretty sure your
manager will be quite happy that you're
doing the good stuff to make sure that
testing is done correctly now sometimes
in critic you need to shrink and in this
case here I created a function that is
it called collecting status and it does
something sensible hit it it asks the
collector process behind the scenes
what is your current not the list of
neighbors you're waiting on to give you
a reply back and what is the current
count of neighbors that have that have
filled up at the moment or present there
and that there is something that you can
use for debugging and then you should
reply it as I've done in my code this is
for debugging and testing only you
should not use this for anything live
there but this is just to ensure that
the neighbors have has been asked about
the status because that's the first
thing the collector will do there and if
you don't allow them that process to run
a little bit before quick check checks
if it has called the neighbors then
quick word check will say that you've
failed your test so that's where you
need to search before you evaluate
things on the quick check side now doing
a step is like the most important thing
in game of life there so what you do is
and this is where you do the syncing you
you tell the cell please do a step go
ask your neighbors get the responses
back and go on so here we've broken it
down and here's if we have the avoid
collecting status it will continue this
is a simple little loop where it'll ask
for collecting status and collecting
status would only give you something
sensible something that's different from
undefined when it's running and it's
waiting for neighbors to come back to
the announcer where the questions the
process has asked and here I'm just
doing a 5 millisecond sleep every time
and then I'm just waiting for it to say
I'm ready I've sent out my things and
this means that I can now allow quick
check to evaluate if things have gone
right and then this is where you check
it in quit yet because quick check has
when you're doing mocking it allows you
to check that you're calling out to
certain functions in other modules and
in this case here we have that we need
to see eight times that I'm calling the
Eagle protocol query content so I have
to ask all of my 8 neighbors when I'm
doing a step if I have not done that
when I start up the step
I have not fulfilled the contract of
protocol of Eagle and then I cannot be
said to have a functioning piece of code
and this is how I do it in in creature
you create these call-outs and they
saying I need to see these also
otherwise things are not working and
these are the ones you have to wait for
that's the syncing you should just saw a
minute ago good now then we need to fix
the deadlock and the deadlock was that
you've been asked you asked the neighbor
about his value and he dies before he
can reply back to you so the way you do
it is you monitor all your neighboring
cells the collector loop will monitor
all the neighbors and that means that
whenever it gets a down message in there
it will make sure that it's one of the
neighbors it's monitoring that's the
first round to appear the false branch
saying okay I got something that I don't
know what it is and I'll just ignore
that there in the other case here you've
seen it is one of the ones you are
monitoring so the first thing you do is
there you monitor a neighbor ID again
you're just waiting for for that process
to be up and running and you get a once
it's up and running you you actually go
in and create an Erlang money to on it
and you get a reference for that there
and then you ask the neighbor again
please
what's your content you query it for its
content because it lost any notion of it
had to reply when when it died REM again
supervisors would only restart processes
to their original state they will not do
anything to to build up state that was
there before there and then you just
continue the loop here and that actually
fixes the deadlock now a recap here so
you have a process per cell and this is
the key point you can always remove them
again throw as many as you like at the
problem and see what works there in many
cases people are throwing too few
processes at the problem so that's
something you need to be aware
and then have some short-lived processes
for small tasks of course when you do
that and you're doing OTP things if you
have shortened processes that you do not
turn into an OTP process you will spawn
link them to your OTP process and then
if they die you should die as well and
then everything is under control if you
just form the processes you run into the
issue if your OTP process goes down all
those little processes that it created
will linger on and that will cause
memory leaks or other things in the long
run and then again re-emphasizing here
focus on the protocols between the
processes this is how we doing
get the protocols right and then you
will be a happy trooper and then you use
the supervisors to restart things that
are going down and again remember they
start things in their original state so
you might have to do a bit of work to
get them up to speed
yeah and then in this case here we have
the monitoring manager that actually is
doing these things to get the cells up
to speed and in in game of life it's
pretty simple to do it we just just asks
the cells to run through the current
maximum time there and then it the cell
has caught up with the rest of the one
once there but when you're doing real
life things it tends to be that you need
to do something more elaborate and then
you have to think about how to do that
there but it's the same principles that
I've just gone through that you should
apply now thinking you know on and on
all focus on the protocols the MSE is
there and then you ask what could go
wrong here because this is the kind of
thing that will tell you where to put in
supervision and how to do it they're
tools to do all of this they're lots of
processes spawned them for small things
use the supervisors Lincoln monitor good
things to keep the hygiene of your
system in place and then you can use the
G proc for registering and pops up
frameworks one caveat with G progress
it's
not meant to do a 300 by 300 game of
life simulation I tried that and deep
rock tight very very hard on me it could
not handle that load at all so if you go
to see the code are created on concave
up you will see that I've substituted G
poke with something else but for
real-life things you're probably not
going to do something as insane as I've
done here with what game of life then
deep rock is your friend because then
you don't have to write the code to do
these things and everything's in order
yeah then also the trick to use is
timeouts if you don't get a reply back
within the time I haven't talked about
these in this fight but these are good
things to make sure that the things are
progressing a have a timeout if a
timeout happens and stop thinking about
okay something went wrong here let's me
see if I can can fix that so and then if
you're doing things involving money and
banking switching that thing there then
keep ledges around of what has been
committed in the system for game of life
there's nothing really to say I've
committed this in any sense so there but
in other case if that might be a good
trick to pull out there when you have to
start things and agree upon what
happened before you died yeah
so here's food for thought you can think
about because why use Erlang what can
you only do in Ireland there the thing
you can is you can avoid writing your
own service framework and that's
something I recommend you go and read
that one it's actually a very well
written response on the mailing list
there and it's one of the benefits you
get in Ireland because you have your
service framework with the processes
your GP supervision mechanisms and
everything you have your own service
framework so you don't have to write it
yourself
that is actually a lifesaver in many
cases then yeah
remember the asynchronous protocols are
nasty there again use EQC running a
quick check from Kubik
testing focus on one process don't try
to do many at the same time mock calls
to all other processes involved there
and then there's some work in progress
in the repo there are still a few
glitches left left that I'm willing to
accept the pull requests on to get them
fixed there and the code is here
it's my github account and you can just
go and get it as I said I accept pull
requests in any shape or form and if you
have questions around the code simply a
mail and I'll try to help you decipher
some of the things that are in there and
I must warn you though if you go in
there that there are certain things I
need to do a little bit of cleaning up
to get right because there were some
asynchronous things that were biting my
heels and knees and most of my legs off
it so they are not solved in the nicest
men are possible but a lot of the
principles should be quite good so good
now if you want to learn early apart
from looking at code like the game of
life that I put out there then you have
to think about if you want your life if
you think your purpose of your life is
to serve as a warning to others or if
you want to do something that is
remembered for anything but a drastic
disaster yeah so you should take some
training to do that don't just do so you
can take training courses from erlang
solutions of course I have I have to say
that they're good yeah or you can take
learning summerlin online and read
through that book and get you something
and going there there and then you can
use the Erlin questions mailing lists
all of these are things that I would
recommend you doing so you can get up to
speed fast because in the ESL training
courses a lot of the thinking that I've
been talking about here is what is in
the exercises and if you use it right
then you can actually do that so and
then do it hands-on pearling is not a
language you learn about by reading
about it you need to get your hands out
of your pockets on the keyboard and in
turn editor and then start slapping some
code together that is what makes you
learn it in
and then because Berlin is so different
from everything else give it time to
sink in if you're spending just a week
underline and then you say I don't
really get this and it's just weird
stuff you are cheating yourself give it
time to sink in because as I said
earlier airline is an outlier in the
landscape of programming languages the
golden Trinity of airline is what makes
Berlin very very special it takes a
while before you understand how to use
this but here I've given you some hints
in this presentation so they'll go and
you saw seemed an experiment with things
there and even I'll say even if you
never get to write a commercial system
in Erlang just doing some Erlang and
starting to do some of the process based
things that I've been talking about here
about processes with protocols in it and
how do you look at that it'll make you a
better software engineer even if you
have to write all right Java for living
there so and then then a word on
addiction because those are things that
keeps creeping up with those questions
there it's built on top of the Orlan VM
it has a more Ruby like certain text
just hygienic macros so it's easy to
two-tier cells and we're doing some work
on a Lego Mindstorms library with Alexia
and we've done into yourself for that
and that is actually quite nice
unfortunately I was not the one that got
the idea it was one of my colleagues
Jimmy Snuka but it was really good code
and you can ask for for links to that
code as well if you want to see that so
anyway what it looks at us a lot better
than Erlang it here is the support for
data handling is about better in the
next year so some some of the quirks you
might have inner line with records and
other things that are well a bit 90s in
their way of looking at the world it's
better in helix here there but this is
this is what you have to remember if if
if some hipster is raving about Alexia
we can calm them down and say you still
have to learn the villain programming
model elixir is running on the iron and
VN so lots of processes I'm just
and how to embrace fail fast and
supervision if you're not doing that in
Alexia then you're basically doing rupee
on the UL nvm and that is not gonna make
anybody happy
in the long run so keeping up lots here
we have it Ellen the golden Trinity
running share nothing processes misses
passing fail fast approach and and link
monitor concept these are things work
with them play with them see how the
they can be used to solve different
things it's something that will change
the way you think about the software in
general one of the things an anecdote
here at the end is that when I worked at
Motorola we did a product in Ireland
from the ground up but the more we got
into it and the more we understood the
existing project we realized the data
actually been rewriting like 50% of the
Erlang VM in that other legacy product
and that makes you go hmm the concepts
of Erlang is something that creeps up
again and again and then the question is
do you want to get it almost for free
but just taking rolling or do you want
to be a man about it and write it all in
C from the bottom up and lose all your
hair and grow in the Atlantic beard it's
up to you I've chosen to go for the
airline route so I still have my hair so
then this is where Erlang floral this
makes you a happy true place because you
can deal with the failures in the
program in a system because you have a
language for it in other languages you
have well sort of a language for it but
you basically have that you have
exceptions and you need to do a lot of
try-catch and exceptions and that is
excuse my friends very very very very
ugly to look at Berlin on the other hand
accepts and embraces failure by saying
things will go wrong you need to deal
with it and that's what the future
billing is so if you want to get in
touch you can contact Laden there and if
it's on the code go to github and pop me
a mail if you're you have
questions regarding the code thank you
token I'd like to thank you and I'm sure
everyone will join me in thanking you
for a very compelling talk on our land
and in the thinking like an Erlanger and
how to sort of get to that position so
I'm glad to say that as ever we've
received a bit of an avalanche of
questions and they typically arrive
faster than we can cover them so I'll
have to apologize to begin with to
everyone whose questions will not be
answered simply due to the available
time remaining but to answer as many as
quickly as we can
Tobin we've had a really interesting
question from someone obviously looking
to start in Iraq and Martin is basically
asking from a perspective of a typical
invert in inverted commas non-functional
programmer how long does it take to
become a productive coder in our land is
Martin that's a very good question out
there and it all depends on your
background but I would say that I did
some metrics on this was work motorola
and my impression is that anywhere from
between one to three months of time then
you're back at the productivity you had
before if you were doing C++ or Java and
then after that then you end up being
about four times as productive after one
and a half year of it but within a month
to three three months you back at your
old productivity and I think that is
pretty cheap there I know that it'll
take me longer to be productive in Java
if I had to to go in and then all those
libraries and you know that you need to
do to be productive there thank you to
all them for that I think that sort of
gives a pretty concrete answer just to
try and again answer as many questions
as we can
theater is asking is it possible to move
logic from cell manager to supervisor
you could try and do that but it would
it would make things clunky because you
basically have to rewrite the supervisor
behavior to really do that I think the
key point with Erlang the OTP
supervisors use them for what they're
good for which is to restart things you
have a known starting point and then
whenever you need to do fix is to clean
up start something like the cell manager
on the side and let that do the cleaning
up it makes your code a lot easier to do
there and I'm pretty sure that the
things I'm doing in so many - if you
can't look at the code I don't think you
can do that in a supervisor without
going through tremendous hoops yeah so I
would recommend this this approach also
take some software let it do the job
it's good at and then only do the things
that are missing thank you to open again
and again apologies to everyone sending
questions we're getting about three
questions whilst we're answering you
know the one question that's being asked
so again we'll try and answer as many as
we can so to move on now on this
particular topic on Tobin a person is
asking what is the benefit of the cell
manager when the supervisor restarts in
its original state can't the new process
simply check if it needs to speed up as
part of the startup process so if you'd
like you to repeat that
David is asking what is the benefit of
the cell manager you know when the
supervisor restarts in its original
state can't the new process simply check
whether it needs to speed up as part of
the startup process yeah you could
probably do it that way
and the reason why I didn't do it that
way was that I realized that I also
needed to keep a count of the processes
because I had remember if you remember I
threw out deep rock as a way to get the
process identifier for given cell and
that is also a part of the cell
manager's job is that you can get an
idea about what is the process
identifier for a given cell and then it
could become natural to throw in the
monitoring in that module and
and do it from there and I that's the
reason why the code ended up like this I
think I'll have to go back and see a
little more careful intermitting this
cell actually do this the speed up there
but it I rejected it at the time for a
number of reasons which I have forgotten
about right now but I'll go and revisit
it because it's a good question but I
think my idea of about doing it was also
to have the registry there and then it
made sense to to to keep the monitoring
over there but I'll going back and
revisit that it's always good to go back
and revisit your code thanks for that
token and now really interesting
question we've received from Philippe
Philippe is basically asking why are
many existing lying applications
sequential in need of parallelization
you know if your mind is such a powerful
parallel tool that's a very difficult
question to answer but I think one of
the things that you can do with Erland
quite easily if you pick up some
frameworks say like yours or cowboy you
activate get rolling on doing something
and and then you harness the power of
Berlin's parallelism by using those
frameworks and then the code you're
writing ends up being quite sequential
because the parallelism concurrency
happens under the hood and adding to
that is that a lot of people won't say
when they start out a neuron they
haven't lost their past so to speak you
have to forget about how you write code
in normal languages and start working
with concurrency and do that and I think
a lot of the code that you run into the
people have started our out and only
over time do they realize that
concurrency is your friend and you have
to embrace it more I think that's the
reason behind it but for individual
projects it's a case-by-case evaluation
and I can't give a definitive answer on
that
Thank You Tobin I just like to take a
second and thank everyone sending
questions we are receiving probably a
record number of questions at a record
speed so clearly the webinar has
stimulated a lot of interest and a lot
of people sort of
actively thinking as we speak so to move
on to the next question
Antonio asking for storing variables
with the high access rate is G proc the
best solution or should we perhaps
bypass it and use ETS Antonia this is
what I had to do so you a spot on deep
rock was simply too slow there so I had
to throw in its in here and that's what
the the cell manager process is doing
it's it's a bypassing deep rock and it's
going directly into an edge stable there
and that that is actually a common
concurrency pattern you will see in our
line that when you have these things
that you read need to read a lot and
have access to that then you create an
edge table that everybody read from it
and only synchronize through a process
when you're doing rights to it there
typical verlan concurrency pattern and
that's what I used here for the cell
manager fantastic thank you talkin just
a move on the straightaway to the next
question
Errol is asking is it possible and
indeed common to use Erlang or OTP just
in a supervisor role to manage non
Erlang processes for example dotnet why
are ports for example yes I'm not saying
it's common but you can definitely do it
there and it depending on the problem
you're looking at it might be a very
good idea to mix
erlin with something else if you have
existing logic in it there because then
you get the good concurrency for the i/o
things in our line and then you have
your existing business market managed
through a port and if something goes
wrong you can just restart that port so
it's very doable
but I'm not sure that it's very common
thank you so open another question from
Carlos Carlos is asking you know when
we're looking at more real world
applications do you would you normally
keep one process per cell or a customer
even if it is not active or connected
oh that's that's a good one I think the
simplicity rule applies here so so you
would model everything by having each
use of being a process but then you also
need to be wary of the memory
consumption because if you have a
million users
none of not all of them are active it
could be wasteful and harm your memory
usage if they're all alive so what you
do in those cases is you put some
timeouts in into your system and if you
had no transactions on a process for a
while you hibernate it and then that's
where you can either hibernate the
process or do the most sensible thing
which is to store the state related to
it that next time the user logs on then
you get this the state or the
information about that user out of that
stable storage that if you used to do
that
Thank You Tobin unfortunately we have
time for just a couple of further
questions Rajeev is asking why wouldn't
you just simply let the supervisor bring
the dead process back to restarted
States instead of the monitor because
without you can't do that in the
supervisor as I said earlier without
going through tremendous hoops and
that's sort of destroys the purpose of
the supervisor and again if you go in
and if you ever allowed to see some of
the code that Ericsson has written then
this pattern of having a supervisor
that's just responsible for getting
something restarted and then having a
process on the monitoring process on the
side that does something more elaborate
to get things back into shape it's a
very common pattern and if you can also
go I can't name projects right now but
there's a number of open-source projects
with Erlang where that approach is
actually used as well because you don't
pollute the supervisor because most of
the things I'm doing in the T cell man
it is impossible to do the supervisor
and it makes for a nicer code to just
put it outside okay Tobin and one thank
you for that and one final question from
Kai Carr is asking are there any tools
available for the flow diagrams yes
there is there's a free one called
plant UML abstract the fact that it's
made for UML the sequence chopped thing
there is amazing its text-based and very
easy to use and that's what I've used
for all these diagrams in in this slide
tech thank you to open once again I'm
afraid that's all the time we have
available for today now once again I'm
sure everyone will join me in thanking
you for a great talk on on how to think
like an ER Langer many thanks to all of
you who have joined us for the webinar
as well there are a lot of questions
that haven't been answered that all of
those questions I will personally pass
on to Tobin and will answer them and
obviously send them back to you using
your email details now please join us
again for our next monthly webinar
following today we will be sending you a
very short survey to make sure we
capture your feedback of today's webinar
please also note that the recording of
the webinar and the presentation that
was shared today will also become
available for you to collect on erlang
solutions corporate website at
www.tanahoy.com thank you very much once
again and we look forward to seeing you
on our next webinar</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>