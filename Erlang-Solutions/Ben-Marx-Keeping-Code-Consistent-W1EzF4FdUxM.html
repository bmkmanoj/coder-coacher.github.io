<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Ben Marx | Keeping Code Consistent | Coder Coacher - Coaching Coders</title><meta content="Ben Marx | Keeping Code Consistent - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Ben Marx | Keeping Code Consistent</b></h2><h5 class="post__date">2017-06-02</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/W1EzF4FdUxM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">right so last talk of a day so hopefully
I'll keep you all engaged but so this is
keeping code consistent and why that's
especially important with a new language
like a lick sir as well as Willie
mentioned I'm Ben I'm the lead developer
bleacher report for those of you don't
know bleacher report is the second
biggest sport platform in the world
behind ESPN it's been around since about
2008 what made it unique at the time was
that you could follow your teams locally
professionally and even players as well
so that made it really unique for the
time and it started out in 2008 which
meant obviously that the web was very
different at that time it was much more
passive experience he didn't get push
notifications you can constantly
interact with your content you signed up
for newsletter you went to a website if
breaking news happen you've got an email
about it maybe or you just constantly
check the site and for those of you who
are familiar with bleacher report you
can see that we have a new logo and in
your design and this is really a
culmination of two years of effort both
on the front and the back end so we've
we managed to take the whole system and
rewrite the majority of it on the back
end and then the front end is consistent
across all of our apps so it's been
really great and shows all the hard work
that we've done and so as I mentioned
why elixir like why would we choose
elixir and part of that I just alluded
to in the fact that you can do push
notifications and it's a much more
interactive web so in the beginning
October 2014 was only adopted elixir or
rather when we made the first commit
elixir 1.0 I just been released and I
just looked back at Jeff Lee mention
this morning was in September 2014 and
when I was telling this talk I looked
back at the first commit that we made
and the differences in the NYX file were
quite remarkable the conventions have
changed quite a lot for us it was it was
a bit of a gamble because Phoenix hasn't
had was about a year before Phoenix went
to 1.0 but for us it was a necessity as
I've alluded to already that it was a
the web is much more interactive on
demand and the problem that we were
having was that as our traffic grew we
had a we had to keep adding servers
because and doing all these things as
adding servers only works so well for so
long because eventually either the money
expires or it just won't keep up with it
and as a developer it's also not really
that
and encouraging when the only solution
your problem is to add servers because
it's part of the reason that you know
the majority reason that we do these
things is because we like writing code
and if your code can't handle the
traffic then that's sort of depressing
and sort of reflects badly on you the
second option we did as most companies
did mr. comment patterns across the
industry was to use various caching
strategies and that works pretty well
until it doesn't so especially with art
with our system we had long-running
cache maybe like tags or League
standings these kind of things you had
short caches like scores or content and
then it worked well enough people system
running but we had we still had lots of
problems and the problems were the most
when we had breaking news and this is
when this needs to be the most resilient
because if you have breaking news people
come to your site the site has to stay
up if it doesn't stay up they'll go to a
competitor and I probably won't come
back to you and we evaluated a number of
language when choosing elixir before
choosing a lick sir but the reason that
we initially thought elixir is great for
all of the bullet point reasons that we
know it's scalable fault tolerance all
those kind of things concurrency but we
also had to find a language that we
could teach to the rest of the
developers because if you if you're just
there by yourself it's not going to do
it we have about 12 or 13 back-end
developers and if 12 of those back-end
developers don't want to use the
language that we choose and it's not
going to be adapted adopted rather so we
we chose elixir because it had a
familiar syntax that we felt like people
would get behind if we could prove that
it worked so this was the Phoenix
guidelines for the version of Phoenix
that we adopted do what feels right the
very last eye fair approach to software
development and this was because it was
really early in the lifecycle of Phoenix
I think it was 0.5 /dev CoffeeScript was
still part of the inks at this point
which is very early on and there's there
are some benefits and trade-offs when
you adopt a framework or language at
this stage first
any language or framework that's free
1.0 is still finding its way it's still
developing the api and so on and phoenix
was no different EXO for instance didn't
have changed stats at this time
so what change that's our one of them
the most teachable things that we've
been able to use
to teach other developers about
functional programming elixir so at the
time we were just basically taking
structs and turning in random places and
doing these things but that was okay
because it worked well enough and it
sort of gave us a footing with the
language and when we when they sold the
elixir to the company I don't they
didn't mention this part that it was so
so early on in the life cycle of the
framework they rather focused on the
positive aspects of elixir and Phoenix
and I joined which report to work with
the lick sir I was really excited about
elixir and its opportunity came and so I
I joined as quickly as I could
I was hired as a ruby developer but I
was I was determined to write a liqueur
this was why I went there
and at the time that I started I didn't
really know much about elixir other than
I made some very simple apps the
documentation was changing so frequently
that it was hard to keep up but I played
with it enough that I really wanted to
continue working with it so I saw an
opportunity about a week or two and two
my employment a bleacher report - we had
a problem with this really simple app
that fetched embed data so a lot of us
we aggregate a lot of our content we
have internal of writers we also have
you know we pull in content from Twitter
Instagram Facebook other writers and so
on and the problem was was it if we made
too many requests to this embed service
at the same time the response time would
increase exponentially until it timed
out and this to me is like doing the
lots of simple things at the same time
it seems like an excellent use case of
elixir and concurrency so it took me a
couple of days to sort of port the code
into a lick sir and the surprising thing
was that it works really really well
whereas with the other app if you add in
multiple requests it would exponentially
increase with the elixir app you could
add multiple apps or multiple requests
and it would only incrementing increase
and we deployed it to production
everything worked really well but there
was a problem the code was a mess so I'm
going to show you probably one of the
worst functions in elixir I've ever
written it's so bad you can't even see
the whole function
like if I put the whole function up you
wouldn't be able to see the read the
code so in this this function isn't bad
for a lick sir the function is bad in
any language actually have known better
um first of all the name is terrible for
what for URL what does that do
second the you know inconsistent spacing
around the tuple but you can and it does
even though you can't see all of it it
does at least three things one is to
pretend the HTTP for the format the URL
the second is to call out to fetch pm by
data the third is to handle the response
and the fourth is to return a response
based on what kind of content is if it's
Twitter Instagram etc videos so on and
you can see that I'm very excited about
elixir because I try to do all the
superficial looks or things a pattern
matching tuple pipe up pipe case
statement and conditioner all in one
function so you know say you want to
teach this so we have an app that works
it's performing really well it's
something that we feel like this is
going to this will do what we wanted to
do and we should invest more time to see
if this was going to work out for us now
I show this is someone else the bit
obvious problem is this collaborative
barrier how do you show someone just
terrible code and expect them to have
good standards are they going to take
that into example are they going to see
that it's a mess and not want to invest
in it any further and salsa confusing
for me because like Andre I mentioned
earlier in his talk about documentation
your your writing documentation for your
future self and others and beyond that
it's not extensible so at the time we
had maybe six or seven content types and
now we have about fifteen so what I just
had you know multiple conditionals then
it would have been about a hundred line
long to the function and you would
introduce more more bugs as well
potentially because it's confusing to
follow and so on and one of the things
that we realized at this point was we
have to sort of codify our liquor apps
and it took us about six months or so to
get our first sort of fleet of elixir
apps in production and by that time
Phoenix was post 1.0 so we felt you know
that it had a long way to go litora was
was already quickly picking up traction
and the app works really well and other
developers also expressed interest in
learning the language you know it was at
the port at that time people were really
like weren't alone in this language I
want to learn I want to write develop an
elixir so we had to see so at this point
we had to decide how we're going to do
this fortunately creo came out around
this time and one of the one of the sort
of I know serendipitous things about the
elixir community is that in the
beginning the the the the answer to the
problem came really quickly we had all
these you know and they had all these
different solutions so fast and there
are a few other static analysis
libraries but what makes create a unique
and especially for this purpose in
writing consistent code is that it
teaches you about offering explanations
you can see if you get an error
you know another perhaps in another
lending library it doesn't show you why
it's that it just gives you an error the
developer will try to figure it out or
maybe they'll just go ask you but with
kratos you can go in and expand it it
will tell you exactly why it's doing it
so this is good for two things one it
gives the developer and a bit of
confidence in the fact that they can
figure out the problem themselves to not
have to go ask you how to do it and the
second is of course that they don't have
to ask you or interrupt other people to
do it they can do it on their own and it
also structures the app like in the
sorry it also structures the app in a
way that is reproducible across other
other apps as well because it has a
configuration file and it it actually
took us a lot of time when we first
adopted it because all of our
applications were so distinct and the
standards for phoenixon elixir we're
changing all the time
but once we got it in place and once we
found it what we wanted to do it was it
was really easy to standardize because
creator was opinionated like any other
lending library should be but it allows
you to make the changes that you need to
do to work for you and it's interesting
that is each each I release of preto
comes out there are different changes in
the linting which means that you know
just like phoenix of all just like
elixir is evolving just like our
understanding of elixirs evolving credit
was also evolving so it so when they
when a new lending or a new standards
introduced we have to say is this right
for us and decide yes or no but it was
worked out really really well especially
at that time when we were training a lot
of people so if you run cryto it will
tell you that the function I showed
before is really bad because it's too
long it's too complex and does too many
things so with that and so with that in
mind we can rewrite into something like
this so now we have four functions you
have three private functions and the
entry function it's much clearer what it
does the name is still bad but you can
see exactly what's going on you take a
URL it's formatted it's the embed data
and formats about content type and so
each function is basically doing one
thing with and another thing that we
introduced at this point was having more
competent and decorative decorative
functions and thus instead so instead of
trying to guess which type this is we
could tell the function what time it is
so in the bottom function areas you have
content type is an atom so that's a
Twitter tweets of Instagram Facebook
video whatever it's declarative but you
don't have to get and if this really
reduce the number of bugs we had
especially because in the previous
implementation it sort of there's a bit
more JSON some empty field in this way
we can return to only the fields that we
need which made life a lot easier and
made the reduce the number of bugs it's
also much more extensible because now
you should add a new content type and
you can have an ID function and so on
and this was one of the things that I
really found about it looks to be really
engaging was that it it encourages
explosiveness and it's a very expressive
language and so so now that we have a
better function how do we have add more
information around it and type sex and
dilator are I guess people have mixed
opinions on them I'm Anna I'm in favor
of using types X and dialyzer because
you know we as I mentioned earlier it's
about expressiveness and about
expression so here we have the same
function one of the nice things about
dialyzer is that you type stuff is that
you can create your own custom
types so now we have even more
information about this function it takes
a string and it returns an embed and if
you look above it's a map
and what's also nice is that it's fairly
objective you know it'll complain if you
do the wrong thing which in some cases
might make it just as good for document
you can for simple functions you don't
even necessarily need to write
documentation because if it's a some
function it takes a couple of integers
or some numbers or integers and it
returns an integer so you have this very
clear laid out thing for you to see and
dhaka I mean good documentation is great
of course but good documentation is also
subjective if I look at this function I
know exactly what's going in and exactly
what's coming out it also encourages you
to think more about what you're doing
with your functions when you have to
when you have this sort of thing hanging
over your shoulder saying look at you
know I'm I'm watching everything you're
doing and making sure you're doing it
correctly it it is and adds more thought
to you to your function to your to how
you write your software there of course
some downsides and this is why perhaps
it might not be good for people who are
new to the works or to use it because
you can get perplexing errors and you
have less control over included
libraries so if they don't use them or
they have incorrect types then you might
see those as well so so here's a couple
of errors and you know I has no local
return is one of the most common things
that I've seen when I my own code and it
was very confusing to physics I don't
understand why he's doing this then I
read around a bit and it turns out that
according to Costas is the creator of
dialyzers that you just have to use a no
return type which is kind of strange
because it doesn't I know it doesn't
provide the information I have but the
nice thing about that is that it
encourages you if you're the curious
type to go out and see more and learn
more about why these things do the
things they do and then the second is
kind of it's kind of overwhelming if
you're new to the language but I think
it's worth it because it gives you more
control with it other thing to be aware
of is that you can be that there's
equivalent specificity so both of these
functions will mostly expect
pass the one on top they both return
struck sectors that changed that is more
specific struck than struck so which is
also nice because you have you can be a
specific as you want the downside of
course is that you know you you can be
less specific but the general sentiment
is the same that one is just a more
specific version of the other
and I think Fred bear who wrote learn
you some Erlang and explained it really
nicely
silly me it turns out that I was wrong
and dial arrows or dialyzer was right
all along
it would keep telling me my spec was
wrong and I kept believing it wasn't
I lost my fight dialyzer my code one
this is a good thing I believe and this
is an excellent explanation of why it's
worth the effort to deal with dialyzer
especially if you're starting a new
project it's a lot easier to to start
rather than go back and fill in all the
functions all the specs because it can
take a lot of time and especially if
you're on a deadline of these kind of
things and the next thing about it just
like credo is that it'll catch it'll
potentially catch things that developers
might miss like like in the function
sure at the beginning when the curly
brace had a space in it by a crater
would catch bed and just in the same way
that on the previous showed slide showed
that the type spec was incorrect on the
second bit there I wouldn't have caught
that so it's nice to have another layer
of of checking there and now we'll move
on to a little bit more subjective bits
documentation the next thing about luck
sir as I've mentioned before is the
expressiveness in the explicitness
documentation is no exception
documentation is the first class citizen
in elixir X stock makes it extremely
easy to write to have beautiful
documentation that's easily readable and
you've almost get it for free if you
write if you write your documentation
so let's look back at that other
function one more time so now we have
some more context attempts to fetch and
extract embed data for URL and formatted
according to defined content pipe so
that gives you a lot more of a clearer
understanding of what's going on and
some cases I like to write the
documentation first I'll write the
function I'll sort of think about how
it's going but because it gives you a
nice mental model of what
to do and how your data is transformed
or manipulated through throughout the
throughout the function and it also
helps it also helps me to write better
function names because you have to once
you to explain what it's doing it's
essentially that you give a summary of
the functions the functions what the
function will do then you can come back
and change the function name which is
essentially the topic of the function so
now instead of four or whatever that
means now you have such an extract in
bed which is much clearer and gives you
much better idea of what's going on and
now the URL per M you can see that even
someone who's never programmed would
probably be able to figure out what's
going on and this is better for everyone
if you come into a new project you can
easily do you can easily see what's
going on you can easily explain to other
people without being there because
you've already written it and also I
mean it looks everyone who's written
code has written document has six months
later come back and had no idea what
their what the Cobras doing so having
these things in places is very useful so
this brings us to one more component of
consistent coding which is testing I
mean testing is fundamental in any
setting and one of the interesting
things that we've done at bleacher
report so when they hired me a bleacher
report it was the sort of the
traditional whiteboard interview was it
was a Ruby whiteboy interview I'm not
very good at whiteboard interviews so I
wasn't sure if I'd gotten a job but
apparently I didn't but we've changed
that and instead of doing that we try to
duplicate or replicate what will you do
in a normal day of work so we give you
an open house opening to take home tests
would make it very very general if
you're applying for a back in position
we'll give you some you know maybe
you'll write an API or do something with
data these kind of things and we leave
it intentionally vague and if they don't
add tests then they don't move forward
because when you interview someone
essentially you put your best foot
forward it's like a first date which
side is trying to figure out do they
like the other side and this is a real
this is then like the best predictor for
success that we've that we've had so far
so it's really changed the way that we
interview candidates and made it much
more successful and of course the nice
thing about testing is that
you see if your code works and this is
good for any developer at any level of
proficiency but especially when you're
new when you're learning a new language
it builds confidence because you can
write the code test it and even if it's
bad code it's a test pass then that
means that you have a good first rough
draft and you get it to a working site
and then you can iterate over it much
quicker because you have the confidence
that as long as the tests pass and the
tests are written well then everything
is fine so how to measure coverage this
is something that we've you know of
course you can measure coverage by just
the number of pests that you have which
is not a very good indicator of what's
going on because you can just test one
part of the project but not another and
so on X coveralls is another helpful
library that we've that we found that to
be very useful for just that reason it
gives you nice pronounce of what's going
on you can see everything that's covered
all the files and and so but you know
I'm not a big fan of test coverage
percentage
I mean nightly I I don't see the need
for necessarily a hundred percent test
coverage it depends on the situation of
course but it's better to focus on the
data flow on how the application behaves
rather than trying to get time to cover
all of the test cases for instance you
know you see those things on Twitter
every once in a while or like on the of
having to two things that work
independently well but when they work
together they fall apart and so that's
sort of the same approach that we take
the testing is that of course it's you
know it's important to do unit tests for
various situations but if you have to
choose one of the other tests your set
style your application flows for
successes for happy paths for failure
fast and these kind of things but the
one thing that's nice about test
coverage percentage is that if you have
a low test cover it that means that
something's wrong either you're either
you're using a lot of code in your in
your application isn't doing anything or
your test or you're not testing it at
all so it's useful barometer but it's
not you know ninety four point six or
four point four 96 percent maybe doesn't
make a big difference and another thing
you can do with that with
several is when you have a full request
you can see the new total new code that
was tested so you can you know if you
run the pull request you can you know
what the the new files are and you can
see the corresponding test case test
coverage so this makes it very nice just
to see what's going on and you can as a
developer you can cover this and you you
know you helps out a lot to write good
tests and to see if the test is actually
test if you're testing the unit of the
individual functions or if you're
actually testing the flow of the data so
to give a quick recap these are sort of
before areas that we focus on so far
with that analysis with credo and
dialyzer type specs documentation and
testing so we've covered basically
everything but the actual code itself
code itself all these are somewhat
superficial elements of testing of an
application and the reason that that we
do it this way is because this was all
leads up to sort of the linchpin that
pulled it all together which is which
are code reviews and this is you know I
I've never worked at a place that hasn't
done code reviews but I can and I can't
imagine why you would work why you would
not do a code review because it it's you
know it serves like an editorial process
even though you know great writer is
going to have an editor no matter you no
matter the the skill of the writer and
just like a anyone any level of coder
should have a good code reviewer because
it it's a this is the time to sort of
study the application logic and study
what's going on and having had set those
set those standards in place that makes
code reviews much easier and much for
both sides for the for the reviewer I
mean I've done this times before where
if you see some little error typos or
whatever you just mark those because
you're not hurry you review the code
send it back and you don't really focus
on what's actually going on in the
application so by by offloading all of
this and by having this consistent
process across all of our pull requests
and code reviews it makes it a lot
easier in addition to that we have
service reviews before an application is
deployed to production and you know
measure data page performance logging
monitoring and a bunch of other things
and the reason that we do is this is
because it it's very
it makes it very easy and almost boring
habitual because you can just say okay
we literally have a checkbox that they
have have we invented database fluence
have we load tested have we do we have
the right monitoring place and for most
of these things they're saying they're
the same across the apps or you know
depending on the function of the
application maybe you have different
metrics or these kind of things but for
the most part these are just checkboxes
and becomes boilerplate and another
thing that's helpful with code reviews
are CI hooks of course we use credo we
have a credo check to make sure that the
style is correct we have X coveralls to
to show the test coverage and to show
the changes on that and all that leads
back to the focus on the code men as I
mentioned earlier it's much easier on
the reviewer it's much easier on the
developer and you can you know it's it's
pretty remarkable how much easier it is
to talk about the code rather than to
worry about whether you have these
various standards in place you can focus
on you know especially when you're
learning a new language or even if
you're a you know proficient in the
language you can find bottlenecks you
can teach best practices and since we
have these things in place and this is
what we did earlier with when we were
training developers to do this we would
have them write essentially a rough
draft have the coverage have the test
coverage in place and have all these
other things in place and then we would
sit down with em where we show you know
because we were using our scissors we
were traditionally a ruby shop they
would write very sort of Ruby ish elixir
code which works well enough but there's
you know you want to carry the bad
habits from one language into another
language or rather take idioms from
another language and try to try to sort
of force them onto another language like
that image that Josie showed of the
alphabet and trying to jam the right to
get the wrong letters into different two
different outlines of the letters so it
gave the developers a lot of confidence
as well because now they can go back and
they can redo it and it it took us I
think I took on average about two to
three weeks for most of the developers
to become proficient enough in elixir to
start writing their own code and to not
have to
have these in person code of reason go
back to the more less formal github
reviews and it's pretty much because we
create with all of our back in
developers now use elixir and some of
our front-end developers are using
elixir as well so it's not mean that
this is working as somewhat and one of
the most rewarding things in ways to see
that this is actually working is when
the reviewer learns from the developer
from the newer developer it's really
cool to see to have your own assumptions
challenged by the way that they've tried
to do things because they've learned
elixir or they bring other things in
from other languages or other ideas that
you hadn't thought of and so it becomes
a two-way street
and it shouldn't be an intimidating
process I mean I remember the first time
that I had a code review at bleach
report I was I was very nervous because
this is the first time you know I'm
showing them this was in Ruby code
actually um but I was worried that I
would be judged because I don't like we
had we didn't really have these sort of
standards in place at the time so maybe
the way that I was doing was really
wrong and they would you know they would
be like why did we hire describe this is
a mistake but now that we have these
standards in place it's much easier for
it to for this to happen and to infer to
be a successful process so now with that
with that said you know we have code
reviews into the for sort of standards
that I mentioned before how can you
measure this success how can we look
back over the last year and a half and
see how we progress and if these things
are worthwhile if they're improving our
stack and so on and I doubt that anyone
would argue with maybe the exception of
type specs that these are all useful but
is it worth doing it first of all it's
an ongoing process not all of our
applications are dimensions use type
specs and our coding style has evolved
greatly and it looks over the last year
and a half so I think of our standards
is being viscous where they're sort of
slow-moving you know we have
foundational things but they can change
over time and but that being said once
you know we have these standards in
place all the test documentation code
style it's all the same
become habitual and predictable so that
makes it so much easier to move for
application application and so every
year the NFL Draft for those who aren't
familiar with this we have you know
American football one night in April
they draft the first round so each to
each of the 32 teams drafts the player
and I'm not a sports fan so I don't
really understand the hoopla behind this
but every year this is consistently our
busiest night of the year and in the
past you know it's you can scale up
because you know it's going to be busy
you can do all these things to handle it
but I'm conversely in the past that I
mentioned the problem that I alluded to
earlier was that you can't predict
breaking news so that was where the
system really was was having trouble
struggling elixir however has proven to
be you know a godsend for us I'll give
you an example of that Kevin Durant who
was playing for the Oklahoma Thunder
though it's kind of funny actually now
that I've been working on the sports
company for a couple of years I actually
have I know more about sports than I
ever thought I would in my life
so I have these little anecdotes so
Kevin's alright so Kevin Durant played
for the Oklahoma Thunder which is the
NBA team and the Golden State Warriors
are the local sort of Bay Area team and
the previous year the Warriors and the
Thunder had this very long drawn-out
playoff it was very very testy very hot
you know and the Warriors won in the
seventh in seven games and there's a lot
of bad blood between the two the two
teams and then Kevin Durant became two
free agents and to everyone's surprise
he decided to join the Warriors you know
people in the Bay Area we're very happy
you know the Warriors are already a good
team another you know an even better
team and people in Oklahoma were of
course furious and burning and jerseys
and effigies and all these kind of
things and whatever they do and you know
we were just it was a normal day at work
we're just typing you know working on
whatever
and it wasn't was it later until someone
realized that our traffic had like
tripled or quadrupled in within a couple
of minutes because people flooded the
site and no one knows that it happened
at the time in the past this would have
caused problems we've had alerts going
on we've had issue issues with the the
platform itself and these things but we
look back and you know the response time
was hovering around 100 milliseconds and
it was kind of another testament to
elixir it's sort of this traffic
independent response times where
Bleacher Report's traffic is very
typical you know people get up in the
morning they check they leave work they
check they check and you know we have
offices in London as well so it's sort
of all the time but even when traffic
spikes the response time so hablar is
mostly around 100 milliseconds and it's
been a really great press so back to the
dress so this was our first year where
all of the core infrastructure had
basically been migrated to elixir last
year was the first year that we hadn't
done with almost all of the important
stuff on elixir but this year was the
first real test of elixir all our push
notifications everything that serves the
app scores basically everything that's
important to have this night succeed was
on a lick sir so we felt you know
confident because of everything that I
mentioned before but you know everything
has to go right on this night this is
like I said this is the state of the
union of 4br like if something goes
wrong then it's you know the problem for
everyone and in the past we've had
issues getting saying everything mostly
worked like for instance last year we
had some problems with caching as and
this is where caching really bite us
content was still being served but we
weren't able to update the information
so if you're coming to the site and
you're still getting the same
information then maybe you won't come
back especially when other sites maybe
have the information faster so this year
everyone's on call everyone's in the
office from 5 p.m. to 9 p.m. for the
entirety of the first round of the dress
and you know it's exciting it's sort of
like you know before you start a race or
a competition or something you're very
nervous or that it gets giving a talk as
well you're nervous and you hope it goes
well
and the first pick happened we got the
notifications on the phone when they
were announced and we someone had the
sort of analytics to see the concurrent
users and it was quickly spiking and
within about 15 minutes we had the
highest concurrence was ever had by
about thirty thirty thousand users which
is pretty impressive and the last time
the last highest number of concurrent
users we had was when LeBron James the
NBA player went from Cleveland to Miami
and his decision special and we knew
this was happening I wasn't the company
the time but this was I mean this was
expected you know it wasn't breaking it
was breaking his innocence that
something was going to happen but it was
expected breaking news because it was a
there was all this a big special about
it and so on so this is a big
achievement for us and I think LeBron
went to the heat like five or six years
ago so it's been a while since we've had
this kind of traffic so so let's see how
did we fare of course this is the
traffic patterns from Thursday to Sunday
you know you can clearly see where the
1st 2nd 3rd and Sunday night of the
dress take place and I mean then this is
traditionally what you'd expect people
are most engaged in the first round less
though and it's the second less so in
the 3rd and then it sort of goes back to
our normal traffic and each dodge is 15
minutes and the initial the sort of the
base of this graph is higher than it
would be because people are coming to
site more frequently because of the the
pre-draft news and these kind of things
so clearly we had a lot of traffic let's
see how we handle it on the left is in
second so that's you know of one 16
milliseconds header milliseconds and so
on
so we're hovering around 50 milliseconds
these three sort of spikes are very
annoying because even though they're
like between under 200 notes under but
the highest spike is about a quarter of
a second which is still very good but I
would like them to be all around a
hundred milliseconds at the goal at Lone
Star look sir Steven wintermeyer gave a
really good talk about latency and about
response times and how people perceive
how speedy our site is and according to
Google 100 milliseconds is where if you
sub 100 milliseconds is optimal
so unlike the years test where people
were frantically trying to keep the
system up or dealing with caching issues
within 15 minutes or so we didn't we
were eating tacos in playing video games
once the to address once the toothpicks
came on once we broke the traffic record
we didn't really we were all just
sitting around it was it was kind of
surreal because you prepare for this
thing and then it works really well but
you know I'm sort of testing to take
person so I expect that things are going
well that means something's gonna go
wrong immediately you know as soon as we
relax it's going to go bad and you know
we ended up leaving about two hours
earlier and we wouldn't we didn't even
have to be there at all because there
was no ongoing maintenance that we had
to do for the elixir system and you know
it was really nice as well because the
next day we got all these emails from
like the CEO the president every one
higher up just effusive phrase about all
the hard work that we've been doing for
the last couple of years on the front
end the back end the design side and the
content and product side as well so it's
been a great success for us so you know
I talked to the beginning about the
whole point of being having code
consistency is so that people can move
from application application without
worrying about it so number of
contributors should probably show that
should probably high for applications so
this is a monolith that we've had since
the beginning of time there are 59
contributors I never use that I never
even clone the repo which is race
because I was manage to avoid that it's
not fun to work on because it's
eight-year-old project so here's some
corresponding numbers for the first
elixir EPS so the first book strap is
turned after years old we've had 23
contributors the O embed app which is
the first app with the code I showed in
the beginning we've had 12 contributors
and another app the metadata app we have
10 contributors and the reason that I
showed the metadata app is because we
were able to use this time that we had
spend time developing we this was
metadata Apple's a way for us to sort of
add all this information like a Lex hero
data that Google requested that really
helps ourselves and I think our traffic
our number of search for impressions was
higher than it ever been so it was a
great success and having a stable system
means that we can
spend all this time doing what we love
which is writing programming and not
worrying about being on call or having
to deal with firefighting because being
on call at the beginning of bleacher
report was really rough
we have intermittent outages or caching
issues and since we have a lot office in
London that meant you would potentially
be up all night or will be woken up
multiple times the fix the cash or do
this kind of thing and now we sleep
through the night it's really a
testament to a lick sir and the work
that we put into it and it's been good
for us because you know we were featured
on Apple News Google Play App Store and
all these kind of things which which
further drives this forward and so that
sort of all that and with one last thing
so if you're curious about adopting a
lick sir
Joe's a baleen Bruce Kate and I are
writing a book about adopting litter
it's the pragmatic book should be out
later this year and the whole idea is to
take these things that are subjective
and they're still evolving standards are
evolving the community and to have it
laid out for you so that you can do it
easily enough and there are all idea is
that you get you know if you're trying
to convince your boss or your company to
use the elixir here's the here's the
book this is why you should do it and
this is how to do it from team building
your monitoring to production to
deploying in all these things it sort of
covers all standards of elixir
development from a higher level it
doesn't include like elixir language
syntax or semantics for Phoenix because
they're already great books for that but
that's uh that's all I've got so thank
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>