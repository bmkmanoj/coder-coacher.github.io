<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Getting Pretty Serious - Louis Pilfold - Elixir.LDN 2017 | Coder Coacher - Coaching Coders</title><meta content="Getting Pretty Serious - Louis Pilfold - Elixir.LDN 2017 - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Getting Pretty Serious - Louis Pilfold - Elixir.LDN 2017</b></h2><h5 class="post__date">2017-08-24</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/g4HXeP_CZbc" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">[Laughter]
I'm here to talk about elixir code style
and reducing the cost of reading code
and reducing the cost of writing code
especially in the context of elixir
projects where there's more than one
contributor so what is the elixir
standard style and it's there an Alexis
standard style do we largely conform to
one way of writing Alexa code so here
we've got two examples which hopefully
you can see the first example uses two
space indentation and the second example
uses four space limitations so who
prefers to space indentation and the
related code who prefers four space does
anyone do anything else
taps perhaps three we've got a three in
okay cool
so other than you were pretty consistent
here cool so that's good so like it
looks like this there is some sort of
standard style being hinted at by at
least this room and hoping that's
indicative for the rest of the community
right so here's another example we've
got a function with three clauses and
it's got a very short body for each
clause i might though i might write them
with each clause of one line as on the
top example or i might write them using
the the do sugar on multiple lines as in
the bottom so who might do the first
example
who might do the second okay cool
and would anyone - anything else
well cool see like we're a little bit
less consistent here so previously
there's one person you wanted for space
but now there's like a bit more of a mix
including me he doesn't want comments in
the first one so there's a variety of
preferences just in this one room so
presumably that's going to be an even
wider variety of preferences in the
wider community around the globe so
another example keyword lists list
delimiter position we've got a top
example this sort of Lisp style I would
say where we've got the braces on the
same line it's the first in the last
item and then we've got one I might say
some more see like style with the braces
get their own lines so who prefers the
first one few people who prefers the
second one okay so even more mix we've
got even more things that can can vary
in our code and then about trailing
commas I put a trailing comma here
so that's yes another thing that can
change another way in which we know
that's another way in which we can
diverge and I find this particular
example of like whether we put the
braces on the same line or different
line interesting because I've seen it
change over time it seems that certain
big-name elixir projects preferred for
Lisp style and then there was a point in
time when they switched over to the one
with them separate lines which was even
more confusing for me because I started
with the separate lines and then notice
that people were doing the same lines
switch to that and then they switch back
again just confused me and my muscle
memory so my points is that everyone in
this room has a slightly different style
writing fairly similar stuff but there's
lots of small things that we either
consciously or unconsciously do
different and as an extension of this
every code base has their own style and
often at code base might even have more
than one style or no style as different
developers work a different part of the
system over time does it matter
does code style make any difference
whatsoever
so here I've gots
two similar pieces of code written in
why think to be quite different ways
so the first makes use of as much
syntactic sugar as possible and the
second one does not so on the second one
instead of using a do end block we've
just got a keyword list
I'm sure good of course that has a key
do that has the body of the block inside
it and rather than using the block sugar
which is writing lines one after the
other we're cooling the curiously named
underscore underscore block underscore
underscore special form which is what a
block actually becomes when it's tea
sugared so each line becomes an argument
to this function oh and we've also put
parentheses in every single course if
you look at def module and use they've
got parentheses in them as well so if we
took these two examples and fed them
into the compiler we get exactly the
same result they can parse words actly
the same thing they passed the same ast
it's generate the same bytecode they
behave in exactly the same way as far as
the compiler is concerned these two
examples are exactly the same there's
nothing there's no difference between
the two so the compiler doesn't care
from that point of view this there's no
technical reason why you should use one
style another or even if we should use a
single style so if this is the case why
do we care or why do I care about code
star why they're strong opinions here so
I believe that a clear and consistent
style makes it easier for humans to read
code and this is really important
because compilers are quite easy but
humans actually really hard and this is
the thing we need to be focusing on so
here's a quote from the wonderful Sandi
Metz that I really like code is written
many more times right oh my god code is
read many more times than is written
which means the ultimate cost of code is
in the reading it therefore follows that
code should be optimized for readability
adhering to a common code style saves
you money I really like this I also like
that it says a consistent code style
rather than saying the best or a
particular code style so I think that
it's important it's more important that
it's consistent
and thus can become familiar rather than
it's my style or the best sigh which is
committing myself so how can we achieve
a common code style how can we make sure
that when we've got multiple developers
in one project they all wind up
producing the same thing
it's structuring everything the same way
so one thing we could do is use a linter
so linters of programs that inspects the
style of your code and report by any
sci-fi licious you you might have
written so a few years back I went to
this relaxer so I wrote one called dogma
and shortly afterwards another pops are
called Creed a so let's see what would
happen if we were on one of these lenses
on those two examples from before that
the compiler says are exactly the same
so this is crude agree and run on the
first example and it reports no problems
which is fantastic right now we've got a
way of programmatically verifying a
style it's agreeing saying yes this is
the correct way to write the code we
found the consistent style so what
happens if you've run out on the other
one we still don't get any violations as
far as the lint is concerned this is
also fine so both styles are acceptable
I think this is a problem so because we
don't have the one style anymore both of
those things can be written in two
different ways
the links are gets us closer to being
consistent but it doesn't actually give
us proper consistency and why is this so
it comes down to how linters work so
lenses work by having a predefined set
of patterns that they're looking for in
your code and if it finds one of these
patterns it says nope this isn't okay
and then it reports an error to you so
they're effectively a black list saying
there's a subset of styles that you
can't use but anything outside of that
that's fine that's good go ahead and do
that so they don't provide a consistent
style rather they give you a slightly
smaller number or the inconsistent
styles and there are other other issues
too so they ban substitute for stars as
I said but they also require manual
fixing of the style so if you've been
writing your code and then you've run
your tests and they go pass and you you
want to get pushed you're going to run
the lens in
it says you've got 20 style ation so
you've got to manually open all those
files navigate to where the problems are
fix all the errors yourself run the
linter again to see if it's happy
because perhaps you've misunderstood
what he wanted you to do and then you've
got to run the tests again because
you've changed code there's a very real
chance that you've made a mistake
somewhere and you've introduced a bug
furthermore Linder's tend to be highly
configurable you can make decisions
about how you want things indented or
maybe whether or not you want to use
semicolons should you use else with
unless that sort of thing which means
that you time that you've saved on
checking for these violations you just
push over to another area which is
arguing about exactly what things that
linty should be checking for because
everybody wants the lint to be enforcing
their style I would style to be
consistent but I don't want to sacrifice
time and ease of writing in order to
achieve this so is there another
alternative over the last year or so
I've been writing in addition to exactly
writing a bunch of high school and rust
and elm and one thing that all these
languages share is a really wonderful
tool which helps others prom got a
formatter and a formatter is a tool that
takes source code and rewrites it in one
specific allowed style without any input
from the programmer so after using one
of these for a while I've really missed
it and it wanted in elixir so I started
making my own which you can see here
could X formats and so as you can see it
doesn't matter how we structure it I
could do that horrible thing where
squishing the entire thing on one line
for semicolons as soon as I hit save or
run the run the formatter its ignores
all of that it writes it in the way that
it deems to be correct so it's now
perfectly consistent and requires
absolutely no extra effort on my part so
if you compare them to lenses for
matters specify a single correct style
it's perfectly consistent they fully
automate the maintenance of style
and there's zero configuration so
there's no way that they can take any
more time from you so here's another
example of the format formats of being
run and I find this one particularly
interesting for a couple of reasons
first you can see that in order for a
formatter to be worth using it has to
pay attention to how wide the code is
going to be so when so when we've got
the first list as a variable and nested
inside the other one it puts it on one
long line because that it thinks is
short enough to fit on one line but if
we nest them inside the other it
realizes that needs two breaks it
otherwise you're going to get an
incredibly long line but it's even
smarter than that it knows that the
outside list can be split to it so it's
flats but the inside one can be spread
wide and then we get very human looking
very easily readable code
what's even cool about this I realized
after using it for a while it's that
this is something I would have had to do
myself if I made a list longer I would
at some point go
oh it's now a hundred and thirty
characters wide this is getting a bit
much I want to click OK press ENTER and
restructure the entire thing now I don't
need to do this anymore I just have to
put the new content in hit save and then
it doesn't for me I'm actually doing
less work with the format than it was
previously
and I've through lots of video gaming
programming and all that stuff giving
myself slightly knackered hands and if I
can do more with less typing that's
fantastic for me and my health and I
don't really want to work about
something like this anymore
so if you're like me this is the
question earrings for sitting now how
does it work I think it's very
interesting and there's a lot of
information and maybe not so much time
so this is going to be a bit of a
high-level crash course but it's gonna
be some more links at the end and so
there's three steps first step is pass
the source code into the abstract syntax
tree so this is the thing that jay-z
jay-z was showing us earlier where we
put some code into quotes gives you back
this elixir data representation of the
code that you just put in so we start
with that
step two we convert the tree into a
printable algebra more algebra it's
later
and the third step we prints the algebra
in such a fashion that respects the
maximum width that we've allowed it so
thanks for Lichter
writing a parser for x it's
fantastically easy it's just one line
it's code string two quoted parts in a
string and you're done you've done 33%
of the work and you can go home this is
really fun you can do lots of really
interesting stuff think about this
making macros and compilers and static
analysis tools and stuff so go nuts the
next two steps a bit trickier and
they're mostly the work of these two
gentlemen here Phillip waddler and
Christian Lynn dick so Phillip waddlin
roots at paper could a pretty printer
which suggested a new algorithm a new
outro base algorithm for pretty printing
source code and it was written in
Haskell of course it was which made the
algorithm only word in Haskell was it
need to be believed lazily evaluated and
then a Christian came along and wrote a
new spin on it which would work for
languages that mortals can use the
restrict which was in a camel but it
works perfectly well in Alexa so the
algorithm is actually really simple it's
it's made up of six simple algebraic
data types and two functions fits and
formats the one that the users going to
be using is formats and fits is just an
internal implementation detail of
performance so I'm going to give you
each one of these dated just and see
what they represents the first ones text
and text is just a string so if you want
to format a string you just pass it
through a string is already printed
there's nothing to do to it easy so if I
print the text 1000 I get back a string
1000 so cons is used to join two
documents together
so if I have cons of double spaced and
cons of 1000 and I format the whole
thing I get
the two strings could pacinator together
so I get to double one thousand line
again and that's simple any time format
two tries to prints a line it just
renders a new line so if I use this
concat function which is just a little
handy wrapper around cons if I con cats
11 line and 2222 I get 11 and then a
space and then 2222 so nest is where
things start to get a little bit more
interesting and we start to see some
maybe some benefits over just
concatenating strings together so nest
is a form that's used for specifying
indentation and when we try and render
nest
we don't actually print anything instead
we modify the behavior of the fourth of
the formatter so if there is a line
inside nest
we don't just print it as a new line we
print it as a new line followed by a
certain amount of indentation which is
the integer specified by the nest form
so for example if there's a line we're
gonna nest with the value of four that
everything comes after it is indented by
four so and this is our port we've got
first two lines have no invitation and
the FIR and the third one follows a nest
on the line so it's indented by one and
another cool thing about Ness is that
it's tax so if you have a nest for nest
for and in a line we have eight spaces
of indentation so you can see how we can
start to use these for nesting structure
inside each other so if Evan if and
another and another if each one of them
with the nest of two it builds up to six
levels of imitation so up until now
algebra still doesn't really give us too
much of a string concatenation until we
introduced break so break bricks
interesting because it's a
non-deterministic form and what break
represents is either a space or a new
line and the way it works is that when
it's printed the format function calls
the fits function says this looks out
this next chunk of algebra will it fit
on a single line so that will that
literally I can't fit this entire list
and
online and if the answers yes cool every
single one of these brokes is going to
be a space item space ice in space I
some space if it doesn't fit we're going
to put all the breaks in as new lines
and now we have a flat document that's
what it fit on that fits on space we've
allowed it so we've got the same
document here can cats break world if we
format it with a maximum width of 80
fits on one line if we format it with a
maximum width of 4 so with the average
we've got so far
we can make a formatter it respects the
maximum width but it's very much all or
nothing so this entire document will be
completely white as in the middle
example or it will be clean white is the
first example or completely flat is in
the second example but if you let a
human write some code they're probably
going to pick something in the middle so
they're put a few number of breaks as
possible in order to make it fit within
that space they've got and they're going
to selectively pick which bricks they
want rather they're just the first one
so to do that we introduce like the
final algebraic form which is group so
group allows us to group together
select a selection of bricks saying that
if any of these break they have to break
together and when you reach another
break inside that's then they can decide
themselves how they want to break so it
can be either flats or white so this is
a little confusing so here's a slightly
more detail example I've so in the top
line here's the code I want to format
and it's going to formatted with a very
narrow width so it won't fit break I've
used with the word break I've ignored
cats they're not there and then there's
a bunch of text and then I've
represented the groups with angle
brackets so the way they are even once
it starts to the first seven says can I
render this entire thing on one line and
the answer is no okay so strip off the
top-level group which is the one
wrapping your tie thing and find any
top-level breaks so there's that one
after the equals and I'm going to turn
it into a new line and then we get the
second example does this fit no it still
doesn't so we strip off another group
and then we make any breaks that we find
out into new lights and then
got another document and just this week
yes if it's fantastic so now we can
concatenate the whole thing together and
print it that's it that's all there is
to this app to this algorithm you now
know everything you need to know about
pretty printing and then from them it's
really quite simple there's not much
more to it you just need to find one
really big ast to algebra function which
perhaps and matches on every single kind
of node you can have in the elixir ast
and then generates a suitable algebraic
documentation node in the tree in my
implementation this is occurring about a
thousand line long function so it's a
bunch of work but it's it's conceptually
quite straightforward and very easy to
unit test because it's just a pure
function that does something very simple
and you can immediately see if it works
or not because we wonder what Alexa
looks like so yeah I think this is
really fun if you want to know more
about this algorithm or pretty printing
I thoroughly recommend you read the two
papers I've never read a paper before
but they're both really short and really
simple and easy and well I've checking
out interestingly the elixir standard
library has nearly an implementation
this algorithm comes in it so if you if
we print something to the console in IX
it will wrap lists on multiple lines and
it will split structs to be long it does
this using almost the same algorithm and
it's found in the interpret algebra so
the dock the documentation for there
it's quite good and it will also give
you some forms that you can play with to
get started
and if you want to check out what I've
done go to that github URL already had a
few people contribute so please get
involved and ask questions break things
rapport problems yeah thank you very
much and I feel like I've done this is a
really cool project they really like in
it and it's bringing something that I
really want to Alexa and I feel like
I've been helped directly and indirectly
by many people such as Phillip what a
load Christian Lynn dick the electrical
team especially with the stuff that's
coming the next version of elixir that
brings a lot more information to the
parser so we can actually tell things we
couldn't tell before from the
and Alex who's doing the google Summer
of Code projects making another similar
formats that uses a completely different
algorithm which is worth checking out
honeycomb team and anyone that's
contributed to X format thank you very
much any any questions we can take like
one or two at most you have all one your
question question how does X format
compared to the formatter
being developed in the google Summer of
Code the one by Alex cool so it uses a
completely different algorithm which is
one based off of the macro to string
function and I couldn't tell you what
the implicit implications of using the
different algorithm are it seems to be
working for him
not any done any direct comparisons of
them I think currently the one I'm
working on is a bit more mature but
we'll see how things pan out it's quite
nice having more than one project right
because I can you know screw up and you
think so
the ax is different style for macros and
functions you when it's macro you don't
use parents and if it's a function you
do use parents and actually from AST you
can't know if it's a macro of a function
so how did you address that we just have
a list of popular use macros or you do
really recognize if it's macro and
function at runtime so everywhere
disagrees about this everyone has
completely different idea about exactly
when you should use parentheses and we
shouldn't and like if it's a macro is a
common thing or maybe it's a particular
set of functions or whatever it is so
this is what examples in which the two
formats is change so alex is formats
that does have a whitelist of if I see
these functions def def macro I think
maybe like schema a few other things
then we don't put friends around it I
I I don't think this is like the optimum
way to go about this problem for a few
reasons you you're never going to know
all of them like macro EDS ELLs people
are going to invent and you can actually
define functions with those names that
do different things there's nothing
special about them so I think the
approach I've taken which I'm pretty
happy with so far is so instead to try
and identify the context in which people
would be using a DSL and the rule I've
come up with is if it's in the top level
of a block or if it's in the top level
of a file
don't use prints because all the things
like def def macro schema all other
stuff is at the top level you there's a
few places where it doesn't use prunes
now which I think maybe I would want to
but as a a very simple completely
deterministic way to make this decision
I'm totally bored of it but if you if
you can come up with a an addition to
this I'm thinking maybe there's a hybrid
approach where we default to this but
there's some situations in which would
do a different thing that would be
really cool all right thank you if you
want to ask him when he's off stage I
think we need to we need to wrap up for
the next weekend all right thank you
thank you
[Laughter]</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>