<!DOCTYPE html><html lang="en"><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-114897551-4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-114897551-4');
</script><script type="text/javascript" src="//platform-api.sharethis.com/js/sharethis.js#property=5ac2443d1fff98001395ab6c&amp;product=sticky-share-buttons" async="async"></script><title>Lambda Days - Daniel Krzywicki - The continuous evolution of asynchronous agents | Coder Coacher - Coaching Coders</title><meta content="Lambda Days - Daniel Krzywicki - The continuous evolution of asynchronous agents - All technical stuff in one place" name="description"><meta name="keywords" content="education, coding, programming, technology, nodejs, mongodb, software, computer science, engineering, teaching, coaching, coder, learning, java, kotlin, machine learning, AI, ML, tech talks, angular, javascript, js, typescript"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/bootstrap.css"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/coder-coacher.css"></head><body><div class="container-fluid"><h1 class="site-title"><a href="/">Coder Coacher</a></h1><hr><h4 class="site-subtitle text-right">Coaching Coders</h4></div><div id="amzn-assoc-ad-99d6751e-2392-4004-ad16-73aa8385d9d0"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=99d6751e-2392-4004-ad16-73aa8385d9d0"></script><div class="post__breadcrumb"><div class="container"><ol class="breadcrumb"><li><a href="/">Coder Coacher</a></li><li><a href="/Erlang-Solutions/">Erlang Solutions</a></li><li class="active">â¤µ</li></ol></div></div><h2 class="post__title"><b>Lambda Days - Daniel Krzywicki - The continuous evolution of asynchronous agents</b></h2><h5 class="post__date">2014-04-29</h5><div class="container"><div class="video-responsive"><iframe width="560" height="315" src="https://www.youtube.com/embed/gx77jCVGU0s" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div><div class="post__text">hello my name is daniel chubb its key
and I'm a PhD student here at agh and
today I'm going to show you how
evolutionary algorithms can be made
continues with the use of a synchronous
agents I will also see how functional
patterns allowed to achieve this but
first let me stop start with a short
introduction so I do anybody here know
this man I don't see any hands so are
all theses Harris Harris is a lot of
hippie here in Krakow who travels around
the region with his horses and he often
comes to practice drink or in before I
mean sometimes run across him when he
raises his horses on the castle hill
next but wall by the Viswa river and the
thing is two years ago his horse when he
was crossing the main square which you
may have already visited his horse
started to give birth and finally gave
birth on the planter of the green area
around the city centre and while they
stayed there only for a day or two about
it than they moved on that the reason
why i am telling you this is because I
almost amazed how the day be horse was
able to you know stand by itself just a
few hours after it is both and then was
able to move on just a few days later
and in fact many animals are able to
quickly master all the basic skills
needed to survive and they do not need
laurel they nor do they get any
attention from the arts and our species
is an interesting exception in this book
i read many years ago morris claim that
we have to give birth in our species so
early because we basically have you know
very big heads and the heads of our
babies are so big that if we were to
gain both later the hydrogen come out of
the uterus
in fact when you look at the proportion
of the human head on you know the body
had ratio you can see this clearly so as
a result our babies are burned early and
are very dependent on the parents and
they stay such for many years amores
claimed through there that this long
dependency to our parents is perhaps the
reason why we develop such high social
skills and as a consequence may be why
we've not love culture at all and in
another book you may have heard
dachshunds in turn claim that genes are
not the only vector of evolution instead
we may also enter it cultural genes
called means from our social environment
and together all of these for our
extended phenotype which all interns is
the actual property which you know is
using evolution and speaking of memes
you might be probably wondering why i am
telling you all of this my point is
there is no such thing as discrete
generations in nature I mean of course
if you have two related individuals you
can always compute a discrete
genealogical distance between them but
if you look at this on a time axis our
generations overlap so basically you
have the possibility to share much more
information between individuals and
subsequent generations than just our
genetic information and okay so now we
can we can move on to evolutionary
algorithms that being said well I
suppose most of you probably know who
basic have form of an expeditionary
algorithm we start with an initial
population and which we call and we
generate next population by selecting
the best individuals which are some
potential solutions to our problem so we
select the best individual
and i transformed i am using some
operators like mutation for solver right
and we repeated often some stopping
condition is met sometimes you can
introduce also elitism which consists in
passing the best individuals from one
generation to another without changing
them but all in all we always end up
with discrete generations right goal is
for every study is basically a single
loop for the full whole population so
why is it the problem or no why is it so
thirsteee well because we have
synchronized and global selection we
select throwing the whole population in
one step and where is it bad or because
we lose this property which is in nature
that generations overlap and additional
information can be passed over so not in
order to overcome this problem annual
burton was the blood here at agh all
right some years ago which combines
evolutionary algorithms with multi-agent
systems and in this systems the
probability of reproduction of an
individual is not only reflected by
genes and the corresponding thickness
but also by his world history the
knowledge of of individual which
together form the extended phenotype and
agents were proven to be good are enough
for a long time enough are all can
spontaneously reproduce and produce new
agents so in this way selection starts
to be decentralized and is all set to
emerge from the interactions of
independent agents okay so let's let's
look at an example so this is a very
very simple although this is a very
simple example of a nation aramith
eugene system so every agent is assigned
with a solution the corresponding
fitness and some initial energy and
agents meet randomly with each other and
they fight by comparing
yes the winner takes some energy from
the loser and when they gather enough
energy they can reproduce and produce
new ages and obviously when the energy
drops to zero they die ok so what the
algorithm is not very complicated but
the question is how to program it right
there is a number of a gene software the
market but most of them will share or
fall into one of the two categories the
first is to treat agents as simple data
structures which are only processed
sequentially in a loop that well then we
is very simple to do this but we lose
any parallelism and we also end up again
with more or less sequential discrete
generations so the other way is to treat
each of these objects and put them into
separate threads every agent in
temperate threat but I think what I i
really don't need to tell me what
happens if you want to have let's say
10,000 pages right with ten thousand
threads so no that's that's not a
solution so what we do to to allow to to
well to help both many many agents but
not having many threats and still gets
all a potential for parallelism or we
could use Acuras abuse lee and the only
problem will have to overcome it that
accuracy by major reactive right very
reactive messages agents should be
proactive but well generally we just
need to put a loop somewhere I'll get
back to it in a few slides another key
question in in such agency relations is
how to efficiently design the meetings
of Ages that is how to put add edges
together so that they can perform some
actions together in the sequin is
implementation that's not very difficult
right because we'll have a global axis
to the whole population but well it
becomes more difficult when we want to
have a synchronous agents and we could
desire a brute
protocol through each agents huge would
renegotiate meetings but all it's not
very efficient because there is a lot of
communication which is needed and
involved so instead we should use a
mediator from editor pattern and
introduce an additional entity which
would mediate the meetings between the
agents and in a recent work we proposed
a way to introduce such mediating
entities which allowed to efficiently
implement agent meetings both in
synchronous and asynchronous
implementations and in fact it's very
similar to not reduce more which would
you allow so i'm going to show you now
how to design such an intelligent system
with a functional way using two two
types of functions the first function is
agent behavior when triggered by an
external action either is out agents
choose an action to be performed bar
based on the current state knowledge
behavior etc we've already talked about
this and so in other words for those who
do work I'll in the agency edging topic
this is a very simple belief desire
intent mobile so here here's what it
looks like now our algorithms car so
based on the energy the agent chooses
some strategy to execute so if the
energy is 0 it dies it is above some
threshold you wrap each rep reduces and
otherwise with files mm-hmm so the first
an attribute step is as follows so we
have some agents and we define some
behaviors and then simply we're not
edges to behavior and we group them into
these behaviors so the second function
this mobile is a meeting function for
every behavior we saw before the
collection of corresponding agents is
transformed into a new one so again with
an example we need
to process every kind of of behavior and
all the edges which shows this behavior
so as we can see well these agents can
be shuffled grouped into smaller groups
and each such group is processed as a
separate meeting by applying a different
specialized function right we'll have
the fight function which will exchange
energy by comparing fitness will have a
reproduction function which which which
will simply apply some genetic operators
and so on and so the second MapReduce
step the outputs to the meetings are all
the edges are divided into groups and
the inputs of every meeting while our
process and the ill some other meet
agents as a result so here for example
we can have two agents which have the
same energy on the input and on the out
what we have can have a pair of agents
and one agent has taken some energy from
the other another example is on with
reproduction right we had two agents
meeting for reproduction and as a result
we have four edges to parents and two
children and of course when we have more
like a death behavior while the output
is empty right so all we have to do now
is reduce the results of all of these
meetings into the new population okay so
you might you might tell that this model
is still is still step based right we
still have an iteration and it's still
this we can still end up with this
regeneration the fatties it does not
have to this can be programmed both in a
synchronous wire and in an asynchronous
work so well the synchronous version
with me simpler in skala we simply group
agents by behavior and then flat mop
each group if a meeting function and
it's all right we have a new population
and we only have to iterate it until
some stopping condition is met it's a
bit more complicated if you want to do
this a synchronous
but still it's not very hard first we
need to represent every agent as an
actor and that we have to introduce some
mediating entities which will allow such
agents in adverse to communicate without
exchange too much too much messages so
we introduce something which is called a
meeting arena and every agent initially
calls vomiting a king the behavior
function to determine the kind of area
it wants to join basically every
behavior is represented by a separate
area and then verily I can wait for a
timeout to pass or it can wait for
another agent to join and when one of
these conditions is met it can simply
trigger a meeting and a synchronous
meeting which means that the arena can
go back to listen for incoming edges now
what we have to do is our synchronously
call the meeting function for these two
agents or one or more it depends on
value written want to have and the last
animation I don't have in openoffice was
the update of the state of the initial
age right as a result of the meeting the
state of these actions can be updated
new agents may be created these agents
can be terminated okay so the fact is
that we don't you don't really see the
loop here because of the messy animation
but if you imagine arrows on the Latin
on variety basically have the loops
these are reactive loops that we needed
that the interesting point is that every
agent has independent loop we no longer
have global loop in the whole population
and as a result we no longer have
artificial generations actually every
edge it has a equal chance are to meet
and to reproduce and the only limitation
is the resources on on the computer
ahead right because of course in
practice we'll have much
less what the scores in agents because
we want to have thousands tens of
thousands of agents but well this can be
overcome because we can use a dedicated
dispatcher for the agents pool and of
course the order in which the Asians get
to call the behavior function and the
order in which they get to lead that
reminds the rest of the algorithm but
this order is actually something which
depends on the dispatcher we use and we
can use different places we can also
look at this life as well this equation
synchronization we saw before right with
a simple loop in just a special case
because it's just a special case of a
dispatcher we take the incoming agents
and well we all know its a mix of a
first-in-first-out right and a fern this
Parcher but well this generally be
expressed as a special case of this but
also other policies can be used we can
allow edges to to to execute randomly in
random order and one eventually when we
have enough course no computers all of
them could basically execute completely
independently so we have implemented
this algorithm involve Scala and in our
line and it's very sad for me to say but
the Scala a synchronous implementation
turned out to be worse than the earlier
one so that's why I didn't brought a
graphic because I don't want to share
this because I'm very sad about it and I
still working on it but we also ran
their own version on nodes with 12 cores
in the frenette and we compared a
synchronous implementation a fully
extend produce implementation with a
hybrid implementation in which we
basically had the sequential algorithm
much but running in separate processes
so that every process is like an island
and every item physics equations are
written
side and the islands communicate from
gracious and we found out that well both
algorithms are similar in the beginning
but in later stages of the computation
as reproduce version is clearly the blue
one is clearly better so sorry because
well on the y-axis you have the fitness
value which needs to be minimized so the
blue graph is both lower and it also has
a much much smaller standard deviation
which is the bar scene so if finishes
passed it finishes now it's change fewer
population it takes fewer populations to
reach a better result and with greater
than certainty so to sum up well we can
express a multi-agent system like like
this by defining a behavior function and
a meeting function for every behavior so
it basically split the logic of a system
into these two functions when capsulate
agent logic into the first and we
encapsulate the protocol in the middle
faction function we don't have to walk
to implement and broadcast in protocol
and negotiation and so on we assume that
these agents will get together and you
also need to our will to program the
interval interaction once they do second
we can apply this model together with
with actors to get if we look if you
looked at the previous previous image
basically I could have like a stream of
agents coming from the HS pool and going
through the arenas performing meetings
and returning to two edges pool and this
stream can be made parole because the
meetings of the agents are independent
so basically the more course we have the
more parallel it gets
and also if we don't have enough for us
we can also try to tweak a policy of the
dispatcher and we can have interesting
examples and a sequential version is a
special case of such a mobile and
finally the lack of explicit generations
you have achieved or proved to be a more
efficient as a store when asked ok so
that's it today we'd have any questions
implementations they can be whether they
are on the bucket and I think the
repository is private as of now but we
can make it public anytime once it's
because it's you know it's not really
stabilized it's not really a library
because it's more like research but we
can always focused on god on github so
we can look at it
you</div></div><div class="container-fluid bottom-ad"><div id="amzn-assoc-ad-6a809dda-347a-4187-8a86-91faf94575da"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&amp;adInstanceId=6a809dda-347a-4187-8a86-91faf94575da"></script></div><div class="text-center">We are a participant in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for us to earn fees by linking to Amazon.com and affiliated sites.</div><script>(function(w, d){
    var b = d.getElementsByTagName('body')[0];
    var s = d.createElement("script"); s.async = true;
    var v = !("IntersectionObserver" in w) ? "8.6.0" : "10.4.2";
    s.src = "https://cdnjs.cloudflare.com/ajax/libs/vanilla-lazyload/" + v + "/lazyload.min.js";
    w.lazyLoadOptions = {};
    b.appendChild(s);
}(window, document));</script></body></html>